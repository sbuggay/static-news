<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702026058725" as="style"/><link rel="stylesheet" href="styles.css?v=1702026058725"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.reedbeta.com/blog/the-shunting-yard-algorithm/">The Shunting-Yard Algorithm (2011)</a> <span class="domain">(<a href="https://www.reedbeta.com">www.reedbeta.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>9 comments</span></div><br/><div><div id="38566636" class="c"><input type="checkbox" id="c-38566636" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#38566455">next</a><span>|</span><label class="collapse" for="c-38566636">[-]</label><label class="expand" for="c-38566636">[1 more]</label></div><br/><div class="children"><div class="content">A few months ago I wanted to add arithmetic parsing to my game&#x27;s debug console, and went with this approach.<p>While researching the area, I came across this exact blog post, and thought it was perfect. It explains things clearly and concisely (without even needing code&#x2F;pseudocode). Granted, it&#x27;s a simple algorithm, but this post was just so much nicer than any of the (higher ranked) results that Google gave me. And it has no ads!<p>It made me sad. Years ago, it seemed like Google helped me find lots of nice little pages like this one. It&#x27;s much harder to find web articles of this quality anymore.<p>Back to this article specifically, I particularly appreciated the &quot;Advanced Usage&quot; section, where it briefly (and clearly!) goes over some useful extensions to the algorithm. These were very much on my mind (since I wanted parentheses and function calls). They are <i>simple</i> extensions to a <i>simple</i> algorithm, but it&#x27;s nice to have them summarized for you before you dive in.<p>It was a breezy joy to implement (did it even take an hour?). And I can think of other easy ways to extend its capabilities further. This style of arithmetic parsing would be a wonderful thing for beginner programmers to cut their teeth on. It exposes them to a number of important computer&#x2F;programming ideas, yet is simple to implement while also being directly useful.</div><br/></div></div><div id="38566455" class="c"><input type="checkbox" id="c-38566455" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#38566636">prev</a><span>|</span><a href="#38565957">next</a><span>|</span><label class="collapse" for="c-38566455">[-]</label><label class="expand" for="c-38566455">[1 more]</label></div><br/><div class="children"><div class="content">A more succint presentation here: <a href="https:&#x2F;&#x2F;www.andreinc.net&#x2F;2010&#x2F;10&#x2F;05&#x2F;converting-infix-to-rpn-shunting-yard-algorithm" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.andreinc.net&#x2F;2010&#x2F;10&#x2F;05&#x2F;converting-infix-to-rpn-...</a></div><br/></div></div><div id="38565957" class="c"><input type="checkbox" id="c-38565957" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38566455">prev</a><span>|</span><a href="#38565883">next</a><span>|</span><label class="collapse" for="c-38565957">[-]</label><label class="expand" for="c-38565957">[1 more]</label></div><br/><div class="children"><div class="content">Some limitations of this particular article:<p>* it doesn&#x27;t mention that operator-precedence (usually: Pratt) parsing is another alternative<p>* it doesn&#x27;t mention that you don&#x27;t have to evaluate the expression directly; it&#x27;s perfectly possible to output an AST, RPN, or some kind of minimal bytecode.<p>* unless you do a bit of optimization, you can&#x27;t reduce the number of &quot;registers&quot; needed à la Schneider. While generally <i>less</i> relevant for interpreters unless you do some careful platform-dependent design, interpreters can easily benefit from the one-register case.<p>* you&#x27;re allowed to use an ahead-of-time LR machine generator, you don&#x27;t have to encode its tables by hand (but for simple grammars it&#x27;s not actually that hard to work out with comments).<p>* it doesn&#x27;t sufficiently mention that you <i>really</i> want to work with IDs in a lot of cases; among other things this avoids further unary&#x2F;binary problems (though I suppose synthesizing an extra argument also works).</div><br/></div></div><div id="38565883" class="c"><input type="checkbox" id="c-38565883" checked=""/><div class="controls bullet"><span class="by">zachgray</span><span>|</span><a href="#38565957">prev</a><span>|</span><a href="#38565529">next</a><span>|</span><label class="collapse" for="c-38565883">[-]</label><label class="expand" for="c-38565883">[1 more]</label></div><br/><div class="children"><div class="content">as always I wonder about (re?) posts of such old content, but given the algorithm in question itself is such a relic, maybe it’s fine<p>Adding my two cents, this is a really great little algo that I personally have implemented for the fun of it many times as a means of comparing languages to one another, really just for my own benefit. the kotlin instantiation was my fave thus far but I am overdue to revisit this in things like mojo and zig, so big +1</div><br/></div></div><div id="38565529" class="c"><input type="checkbox" id="c-38565529" checked=""/><div class="controls bullet"><span class="by">codenlearn</span><span>|</span><a href="#38565883">prev</a><span>|</span><a href="#38566444">next</a><span>|</span><label class="collapse" for="c-38565529">[-]</label><label class="expand" for="c-38565529">[1 more]</label></div><br/><div class="children"><div class="content">I wrote my first calculator app 11 years ago using shunting yard algorithm. It’s a wonderful algorithm, hats off to Dijsktra for coming up with a simple and elegant algorithm.</div><br/></div></div><div id="38566444" class="c"><input type="checkbox" id="c-38566444" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#38565529">prev</a><span>|</span><a href="#38566012">next</a><span>|</span><label class="collapse" for="c-38566444">[-]</label><label class="expand" for="c-38566444">[2 more]</label></div><br/><div class="children"><div class="content">This post was an interesting one. I often get this problem in interviews, but never knew about this algorithm, so I implemented it and I love it!<p>I also found that it&#x27;s super-easy to extend to support parentheses.<p>Some Ruby code to share if anyone would like to see it.<p><pre><code>    PRECEDENCES = [
      [&#x27;+&#x27;, &#x27;-&#x27;],
      [&#x27;*&#x27;, &#x27;&#x2F;&#x27;]
    ]

    def precedence_of(operator)
      PRECEDENCES.find_index do |level_ops|
        level_ops.include?(operator)
      end
    end

    def lower_precedence(token, than:)
      precedence_of(token) &lt; precedence_of(than)
    end

    def apply(operator, l, r)
      case operator
      when &#x27;+&#x27;
        l + r
      when &#x27;-&#x27;
        l - r
      when &#x27;*&#x27;
        l \* r
      when &#x27;&#x2F;&#x27;
        l &#x2F; r
      else
        raise Exception.new(&quot;Unknown operator #{operator}&quot;)
      end
    end

    def collapse(operators, operands, next_operator: nil)
      while !operators.empty? &amp;&amp;
          (next_operator.nil? ||
          lower_precedence(next_operator, than: operators.last))

        r = operands.pop()
        op = operators.pop()
        l = operands.pop()

        operands.push(apply(op, l, r))
      end
    end

    def expect_operator(token)
      if precedence_of(token).nil?
        raise Exception.new(&quot;Expected operator, got #{token.inspect}&quot;)
      end

      return token
    end

    def expect_operand(token)
      if token[&#x2F;^\d+$&#x2F;]
        return token.to_i
      end

      raise Exception.new(
        &quot;Expected value or nested expression beginning with &#x27;(&#x27;, instead got #{token.inspect}&quot;
      )
    end

    def should_cons(str, char)
      return !str.nil? &amp;&amp; str[&#x2F;^\d+$&#x2F;] &amp;&amp; char[&#x2F;^\d+$&#x2F;]
    end

    loop do
      input = gets

      tokens = []

      input.chars.each do |char|
        if should_cons(tokens.last, char)
          tokens.push(tokens.pop() + char)
        else
          if char.strip.size &gt; 0
            tokens.push(char)
          end
        end
      end
      
      puts tokens.inspect

      expect_value = true

      operators = []
      operands = []

      parentheses_stack = []

      tokens.each do |token|
        if expect_value
          if token == &#x27;(&#x27;
            puts &quot;PUSHING #{operators.inspect} #{operands.inspect}&quot;
            parentheses_stack &lt;&lt; [operators, operands]
            operators = []
            operands = []

            next
          else
            operand = expect_operand(token)
            operands &lt;&lt; operand
          end
        else
          if token == &#x27;)&#x27;
            puts &quot;COLLAPSING #{operators.inspect} #{operands.inspect}&quot;
            collapse(operators, operands)
            result = operands.last
            puts &quot;RESULT #{result.inspect}&quot;

            operators, operands = parentheses_stack.pop()
            operands.push(result)
            puts &quot;POPPING(+ pushing) #{operators.inspect} #{operands.inspect}&quot;

            next
          else
            operator = expect_operator(token)

            puts &quot;COLLAPSING #{operators.inspect} #{operands.inspect}&quot;
            collapse(operators, operands, next_operator: operator)
            operators.push(operator)
          end
        end

        expect_value = !expect_value
      end

      collapse(operators, operands)

      puts operands.last
    end</code></pre></div><br/></div></div><div id="38566012" class="c"><input type="checkbox" id="c-38566012" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#38566444">prev</a><span>|</span><label class="collapse" for="c-38566012">[-]</label><label class="expand" for="c-38566012">[1 more]</label></div><br/><div class="children"><div class="content">I implemented this algorithm for a hobby project around five years ago.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;LoganDark&#x2F;cpp-calculator&#x2F;blob&#x2F;315c3e9814e772ac063f698218842c2b2a10751b&#x2F;CalcAST.cpp#L22-L223">https:&#x2F;&#x2F;github.com&#x2F;LoganDark&#x2F;cpp-calculator&#x2F;blob&#x2F;315c3e9814e...</a><p>It was sort of butchered to try to handle function calls as well, but it&#x27;s still kind of shunting-yard. It also doesn&#x27;t handle unary operators well. But it worked for its original purpose, I suppose.</div><br/></div></div></div></div></div></div></div></body></html>