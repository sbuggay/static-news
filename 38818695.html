<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704013264123" as="style"/><link rel="stylesheet" href="styles.css?v=1704013264123"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://martinfowler.com/bliki/DiffDebugging.html">DiffDebugging</a> <span class="domain">(<a href="https://martinfowler.com">martinfowler.com</a>)</span></div><div class="subtext"><span>mpweiher</span> | <span>22 comments</span></div><br/><div><div id="38820367" class="c"><input type="checkbox" id="c-38820367" checked=""/><div class="controls bullet"><span class="by">jkaptur</span><span>|</span><a href="#38820282">next</a><span>|</span><label class="collapse" for="c-38820367">[-]</label><label class="expand" for="c-38820367">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I originally posted this page on 2004-06-01... Diff debugging isn&#x27;t a term that&#x27;s caught on much in the industry, but I haven&#x27;t seen a another term generally used to describe it.<p>I can&#x27;t speak to 2004, but these days &quot;bisect&quot; is the standard term in my circles (even when we&#x27;re not actually using git and its bisect command).<p>It would be interesting to know whether git was the first to associate that word with this activity... especially given it&#x27;s atrocious naming of everything else :P</div><br/><div id="38822406" class="c"><input type="checkbox" id="c-38822406" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38820367">parent</a><span>|</span><a href="#38820282">next</a><span>|</span><label class="collapse" for="c-38822406">[-]</label><label class="expand" for="c-38822406">[2 more]</label></div><br/><div class="children"><div class="content">Bisecting an interval has been in use in mathematics quite some time before the existence of Git. Bolzano proved (his version of) the intermediate value theorem in 1817, but it has been used in calculations for _way_ longer.</div><br/><div id="38822546" class="c"><input type="checkbox" id="c-38822546" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#38820367">root</a><span>|</span><a href="#38822406">parent</a><span>|</span><a href="#38820282">next</a><span>|</span><label class="collapse" for="c-38822546">[-]</label><label class="expand" for="c-38822546">[1 more]</label></div><br/><div class="children"><div class="content">I think we said &quot;use a binary search to find the regression&quot; or similar.</div><br/></div></div></div></div></div></div><div id="38820282" class="c"><input type="checkbox" id="c-38820282" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#38820367">prev</a><span>|</span><a href="#38820318">next</a><span>|</span><label class="collapse" for="c-38820282">[-]</label><label class="expand" for="c-38820282">[3 more]</label></div><br/><div class="children"><div class="content">A more generic term is &quot;delta debugging&quot;, which has been around for a while. git bisect is one example of a tool which does it, another is Zeller&#x27;s DD tool 
<a href="https:&#x2F;&#x2F;www.st.cs.uni-saarland.de&#x2F;dd&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.st.cs.uni-saarland.de&#x2F;dd&#x2F;</a><p>It&#x27;s also possible to do this is a Bayesian fashion.</div><br/><div id="38821288" class="c"><input type="checkbox" id="c-38821288" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#38820282">parent</a><span>|</span><a href="#38821115">next</a><span>|</span><label class="collapse" for="c-38821288">[-]</label><label class="expand" for="c-38821288">[1 more]</label></div><br/><div class="children"><div class="content">dd? Isn&#x27;t that a problem on UNIX systems where &quot;dd&quot; (the disk destroyer) is a standard command.</div><br/></div></div><div id="38821115" class="c"><input type="checkbox" id="c-38821115" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38820282">parent</a><span>|</span><a href="#38821288">prev</a><span>|</span><a href="#38820318">next</a><span>|</span><label class="collapse" for="c-38821115">[-]</label><label class="expand" for="c-38821115">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very curious in the Bayesian approach to bisect debugging. Got a reference?</div><br/></div></div></div></div><div id="38820318" class="c"><input type="checkbox" id="c-38820318" checked=""/><div class="controls bullet"><span class="by">jonmoore</span><span>|</span><a href="#38820282">prev</a><span>|</span><a href="#38820191">next</a><span>|</span><label class="collapse" for="c-38820318">[-]</label><label class="expand" for="c-38820318">[1 more]</label></div><br/><div class="children"><div class="content">There is a more general algorithm called Delta Debugging (<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Delta_debugging" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Delta_debugging</a>), introduced in Andreas Zeller’s 1999 paper &quot;Yesterday, my program worked. Today, it does not. Why?&quot; (<a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;318774.318946" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;318774.318946</a>), recommended if you’re interested in the topic.</div><br/></div></div><div id="38820191" class="c"><input type="checkbox" id="c-38820191" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38820318">prev</a><span>|</span><a href="#38820208">next</a><span>|</span><label class="collapse" for="c-38820191">[-]</label><label class="expand" for="c-38820191">[3 more]</label></div><br/><div class="children"><div class="content">This has been an essential tool for me over the years as a working &quot;data scientist&quot;.<p>Let&#x27;s say you&#x27;ve been working on an &quot;algorithm&quot;, which is a combination of cleverly-crafted SQL to fetch the right data, some ad-hoc data processing code in Python, getting predictions from a model, and some additional mathy stuff to translate the model prediction into something useful. You probably built it interactively in a REPL or notebook environment. You might have some ad-hoc assertions scattered across your scripts, but nothing resembling a test suite.<p>That&#x27;s just how things go, and if you did it differently you&#x27;d probably never get your work done. But now you have a problem: you have what you believe is a mostly-working&#x2F;mostly-correct implementation, which you built incrementally and interactively, but now needs to be put into production. Without any real tests, your script has immediately become &quot;legacy code&quot;: <a href="https:&#x2F;&#x2F;understandlegacycode.com&#x2F;blog&#x2F;what-is-legacy-code-is-it-code-without-tests&#x2F;" rel="nofollow">https:&#x2F;&#x2F;understandlegacycode.com&#x2F;blog&#x2F;what-is-legacy-code-is...</a>. If things went well, you had time to extract some common utility functions and write unit tests for them, but you probably don&#x27;t have more than that.<p>So now what do you do? You <i>want</i> to refactor it into testable units, so you can build out a proper test suite. But you can&#x27;t refactor code without tests, lest you risk breaking something. You did extensive manual checking and validation of your outputs, but you can&#x27;t keep doing that over and over.<p>In this case, the best option that I&#x27;ve found is to do pretty much what Fowler is advocating for here. Extract a set of known inputs that don&#x27;t take too long to run through the algorithm, and save their known-valid (or known-close-enough-to-valid) outputs. Then, piece by piece, start refactoring, re-running at each stage. If the outputs differ by more than floating-point roundoff error, you&#x27;ve either found a bug in your original implementation, or you introduced a bug in your refactor. Once you&#x27;re sure that your refactor is OK, you can &quot;lock in&quot; the changes by adding new tests for the refactored sections. Repeat until satisfied, or out of time.</div><br/><div id="38820631" class="c"><input type="checkbox" id="c-38820631" checked=""/><div class="controls bullet"><span class="by">gcarvalho</span><span>|</span><a href="#38820191">parent</a><span>|</span><a href="#38820517">next</a><span>|</span><label class="collapse" for="c-38820631">[-]</label><label class="expand" for="c-38820631">[1 more]</label></div><br/><div class="children"><div class="content">Seems like you’re describing snapshot testing, whereas the article talks about bisecting.<p>Bisecting is useful when you find a bug which your test suite did not, and which may have been introduced a long while ago.  So you search for the first offender between the last known-good commit and the most recent, usually with an automated test that reproduces the bug, and which should be introduced in the suite to prevent it from happening again in the future.<p>A snapshot test is basically a “let me know if this unit stops giving this output for this specific input”.  And sometimes the fix is to acknowledge that this new output is now the correct version by overwriting it to the snapshot.</div><br/></div></div><div id="38820517" class="c"><input type="checkbox" id="c-38820517" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#38820191">parent</a><span>|</span><a href="#38820631">prev</a><span>|</span><a href="#38820208">next</a><span>|</span><label class="collapse" for="c-38820517">[-]</label><label class="expand" for="c-38820517">[1 more]</label></div><br/><div class="children"><div class="content">I worked somewhere that had very complicated price calculations. The complexity came from all sorts of options like pricing schemes, taxes, etc. Many were optional and there were all sorts of interdependencies. It returned an object with lots of pricing details. It really, really sucked to change or debug and there were 0 tests.<p>I added some tests like you described. Some known price inputs and configuration options and the observed return value from a presumed good state. It didn&#x27;t verify anything was correct, but it did catch “drift.” The expected object would be updated when changing the calculations, if the difference conformed to expectations based off the changes.<p>I got some pushback because the tests werent testing correctness but it was trivial to implement and it did catch cases where we changed something and something else that should have been unrelated changed as well. A shit test for even shittier code I guess.</div><br/></div></div></div></div><div id="38820208" class="c"><input type="checkbox" id="c-38820208" checked=""/><div class="controls bullet"><span class="by">RegW</span><span>|</span><a href="#38820191">prev</a><span>|</span><a href="#38820991">next</a><span>|</span><label class="collapse" for="c-38820208">[-]</label><label class="expand" for="c-38820208">[2 more]</label></div><br/><div class="children"><div class="content">DiffDebugging is not a term I have ever heard of before, but I guess it&#x27;s something I do on a regular basis.  The code used to work, it doesn&#x27;t now, WTF has changed?</div><br/><div id="38821018" class="c"><input type="checkbox" id="c-38821018" checked=""/><div class="controls bullet"><span class="by">broast</span><span>|</span><a href="#38820208">parent</a><span>|</span><a href="#38820991">next</a><span>|</span><label class="collapse" for="c-38821018">[-]</label><label class="expand" for="c-38821018">[1 more]</label></div><br/><div class="children"><div class="content">Right, this is the common sense approach for identifying the cause of a regression. Not sure what people do other than this unless it&#x27;s a very simple codebase</div><br/></div></div></div></div><div id="38820991" class="c"><input type="checkbox" id="c-38820991" checked=""/><div class="controls bullet"><span class="by">pixel_tracing</span><span>|</span><a href="#38820208">prev</a><span>|</span><a href="#38822243">next</a><span>|</span><label class="collapse" for="c-38820991">[-]</label><label class="expand" for="c-38820991">[2 more]</label></div><br/><div class="children"><div class="content">A well known very large successful trillion dollar company emphasizes this heavily and it’s called identifying Cause By, regressions are categorized before a build is submitted, in the current build, or in previous builds. It’s extremely important to identify cause by (commit) in order to either revert or fix.</div><br/><div id="38822719" class="c"><input type="checkbox" id="c-38822719" checked=""/><div class="controls bullet"><span class="by">theyinwhy</span><span>|</span><a href="#38820991">parent</a><span>|</span><a href="#38822243">next</a><span>|</span><label class="collapse" for="c-38822719">[-]</label><label class="expand" for="c-38822719">[1 more]</label></div><br/><div class="children"><div class="content">Sounds interesting. Could you elaborate, I don&#x27;t quite understand it. You test for regression errors before commit? But why commit with known regression errors?</div><br/></div></div></div></div><div id="38822243" class="c"><input type="checkbox" id="c-38822243" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#38820991">prev</a><span>|</span><a href="#38821021">next</a><span>|</span><label class="collapse" for="c-38822243">[-]</label><label class="expand" for="c-38822243">[1 more]</label></div><br/><div class="children"><div class="content">Note that when (other people&#x27;s, surely, not yours) bad git history with unrelatedly-broken commits everywhere means you can&#x27;t bisect, you can use bisect --first-parent to travel down only the first-parent history (which should be just merges to master) rather than having to laboriously figure out whether it&#x27;s &quot;bad&quot; or &quot;skip&quot; this time.<p>If you&#x27;re unfortunate enough to have an impoverished &quot;linear history&quot;, you&#x27;re stuck figuring out whether it&#x27;s &quot;bad&quot; or &quot;skip&quot;, sorry.</div><br/></div></div><div id="38821021" class="c"><input type="checkbox" id="c-38821021" checked=""/><div class="controls bullet"><span class="by">aantix</span><span>|</span><a href="#38822243">prev</a><span>|</span><a href="#38820063">next</a><span>|</span><label class="collapse" for="c-38821021">[-]</label><label class="expand" for="c-38821021">[5 more]</label></div><br/><div class="children"><div class="content">Martin, small commits interrupt flow, contain intermediary trains of thought that aren’t relevant, and decompose the entirety of the feature in to unrecognizable pieces removing all wholistic meaning.<p>Stop doing it.</div><br/><div id="38822073" class="c"><input type="checkbox" id="c-38822073" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#38821021">parent</a><span>|</span><a href="#38821113">next</a><span>|</span><label class="collapse" for="c-38822073">[-]</label><label class="expand" for="c-38822073">[1 more]</label></div><br/><div class="children"><div class="content">If you want a a wholistically meaningful thing to look at for the feature, look at the PR.<p>When you&#x27;re looking for a smoking gun commit, you want it as small as possible, otherwise it&#x27;ll take longer to fix.</div><br/></div></div><div id="38821113" class="c"><input type="checkbox" id="c-38821113" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38821021">parent</a><span>|</span><a href="#38822073">prev</a><span>|</span><a href="#38822230">next</a><span>|</span><label class="collapse" for="c-38821113">[-]</label><label class="expand" for="c-38821113">[2 more]</label></div><br/><div class="children"><div class="content">But it&#x27;s much easier to rebase, squash, and reorder lots of small commits than a few big ones.</div><br/><div id="38822234" class="c"><input type="checkbox" id="c-38822234" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#38821021">root</a><span>|</span><a href="#38821113">parent</a><span>|</span><a href="#38822230">next</a><span>|</span><label class="collapse" for="c-38822234">[-]</label><label class="expand" for="c-38822234">[1 more]</label></div><br/><div class="children"><div class="content">The experience of splitting in git could be made nicer in a few ways, but yeah.</div><br/></div></div></div></div><div id="38822230" class="c"><input type="checkbox" id="c-38822230" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#38821021">parent</a><span>|</span><a href="#38821113">prev</a><span>|</span><a href="#38820063">next</a><span>|</span><label class="collapse" for="c-38822230">[-]</label><label class="expand" for="c-38822230">[1 more]</label></div><br/><div class="children"><div class="content">&gt; interrupt flow<p>sorta. this really varies strongly from person to person and i wouldn&#x27;t generalize. but you can construct small commits after you&#x27;re done with your work.<p>&gt; contain intermediary trains of thought that aren&#x27;t relevant<p>no. delete these, they should not be present in the final history.<p>&gt; decompose the [...]<p>i don&#x27;t know what this is supposed to mean.</div><br/></div></div></div></div></div></div></div></div></div></body></html>