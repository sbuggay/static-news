<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719219674315" as="style"/><link rel="stylesheet" href="styles.css?v=1719219674315"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://learn.microsoft.com/en-us/windows/arm/arm64ec">Arm64EC – Run x86_64 and Arm code in the same process</a> <span class="domain">(<a href="https://learn.microsoft.com">learn.microsoft.com</a>)</span></div><div class="subtext"><span>heinrich5991</span> | <span>24 comments</span></div><br/><div><div id="40772475" class="c"><input type="checkbox" id="c-40772475" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#40773243">next</a><span>|</span><label class="collapse" for="c-40772475">[-]</label><label class="expand" for="c-40772475">[9 more]</label></div><br/><div class="children"><div class="content">Wow! This might actually make it possible for Actually Portable Executable to support running on Windows ARM. I&#x27;m already putting the ARM code inside all my binaries. There&#x27;s just never been a way to encode that in the PE headers. But if my emulated WinMain() function for x86-64 could detect that it&#x27;s being emulated and then simply ask a WIN32 API to jump to the ARM entrypoint instead, it&#x27;d be the perfect solution to my problems. I actually think I&#x27;m going to rush out and buy a Windows ARM computer right now.</div><br/><div id="40772619" class="c"><input type="checkbox" id="c-40772619" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40772475">parent</a><span>|</span><a href="#40772932">next</a><span>|</span><label class="collapse" for="c-40772619">[-]</label><label class="expand" for="c-40772619">[1 more]</label></div><br/><div class="children"><div class="content">And this kind of beautiful insanity is why you&#x27;re one of my favorite developers of this era.<p>Also,<p>&gt; I&#x27;m already putting the ARM code inside all my binaries.<p>Wait, I thought CPU architecture was the one limitation that <i>did</i> affect APE - you mean on unix-likes APE binaries are already compatible across amd64 and aarch64?<p>Edit: rereading <a href="https:&#x2F;&#x2F;justine.lol&#x2F;cosmo3&#x2F;" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;cosmo3&#x2F;</a> it does say that, doesn&#x27;t it - and ARM64 listing &quot;Windows (non-native)&quot; just means that one platform uses (for the next few hours-days, at least...) emulation. That&#x27;s amazing:)</div><br/></div></div><div id="40772932" class="c"><input type="checkbox" id="c-40772932" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#40772475">parent</a><span>|</span><a href="#40772619">prev</a><span>|</span><a href="#40772790">next</a><span>|</span><label class="collapse" for="c-40772932">[-]</label><label class="expand" for="c-40772932">[1 more]</label></div><br/><div class="children"><div class="content">I found the <a href="http:&#x2F;&#x2F;www.emulators.com&#x2F;docs&#x2F;abc_arm64ec_explained.htm" rel="nofollow">http:&#x2F;&#x2F;www.emulators.com&#x2F;docs&#x2F;abc_arm64ec_explained.htm</a> article extremely helpful at understanding what the ABI is doing, you might like it too.</div><br/></div></div><div id="40772790" class="c"><input type="checkbox" id="c-40772790" checked=""/><div class="controls bullet"><span class="by">lewurm</span><span>|</span><a href="#40772475">parent</a><span>|</span><a href="#40772932">prev</a><span>|</span><a href="#40772629">next</a><span>|</span><label class="collapse" for="c-40772790">[-]</label><label class="expand" for="c-40772790">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I actually think I&#x27;m going to rush out and buy a Windows ARM computer right now.<p>If you have an Apple Silicon machine you can run a Windows Insider build via UTM in a VM.</div><br/></div></div><div id="40772629" class="c"><input type="checkbox" id="c-40772629" checked=""/><div class="controls bullet"><span class="by">zorgmonkey</span><span>|</span><a href="#40772475">parent</a><span>|</span><a href="#40772790">prev</a><span>|</span><a href="#40773102">next</a><span>|</span><label class="collapse" for="c-40772629">[-]</label><label class="expand" for="c-40772629">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure the API you&#x27;ll want to detect that is IsWow64Process2.</div><br/><div id="40773690" class="c"><input type="checkbox" id="c-40773690" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#40772475">root</a><span>|</span><a href="#40772629">parent</a><span>|</span><a href="#40773110">next</a><span>|</span><label class="collapse" for="c-40773690">[-]</label><label class="expand" for="c-40773690">[1 more]</label></div><br/><div class="children"><div class="content">IsWow64Process2ForRealThisTime</div><br/></div></div><div id="40773110" class="c"><input type="checkbox" id="c-40773110" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#40772475">root</a><span>|</span><a href="#40772629">parent</a><span>|</span><a href="#40773690">prev</a><span>|</span><a href="#40773102">next</a><span>|</span><label class="collapse" for="c-40773110">[-]</label><label class="expand" for="c-40773110">[2 more]</label></div><br/><div class="children"><div class="content">I love the 2s and Exes at the end of Windows API call names</div><br/><div id="40773273" class="c"><input type="checkbox" id="c-40773273" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#40772475">root</a><span>|</span><a href="#40773110">parent</a><span>|</span><a href="#40773102">next</a><span>|</span><label class="collapse" for="c-40773273">[-]</label><label class="expand" for="c-40773273">[1 more]</label></div><br/><div class="children"><div class="content">wait&#x2F;waitid&#x2F;waitpid&#x2F;wait3&#x2F;wait4<p>dup&#x2F;dup2&#x2F;dup3<p>creat&#x2F;open&#x2F;openat&#x2F;openat2<p><i>cough</i></div><br/></div></div></div></div></div></div><div id="40773102" class="c"><input type="checkbox" id="c-40773102" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#40772475">parent</a><span>|</span><a href="#40772629">prev</a><span>|</span><a href="#40773243">next</a><span>|</span><label class="collapse" for="c-40773102">[-]</label><label class="expand" for="c-40773102">[1 more]</label></div><br/><div class="children"><div class="content">Quickly create a donation page, you have this moment haha</div><br/></div></div></div></div><div id="40773243" class="c"><input type="checkbox" id="c-40773243" checked=""/><div class="controls bullet"><span class="by">Aissen</span><span>|</span><a href="#40772475">prev</a><span>|</span><a href="#40772551">next</a><span>|</span><label class="collapse" for="c-40773243">[-]</label><label class="expand" for="c-40773243">[1 more]</label></div><br/><div class="children"><div class="content">A long-term contributor to LuaJIT (@corsix) added Arm64EC support and introduced the franken ABI at FOSDEM 2024, with a very entertaining talk: <a href="https:&#x2F;&#x2F;fosdem.org&#x2F;2024&#x2F;schedule&#x2F;event&#x2F;fosdem-2024-1762-arm64ec-microsoft-s-emulation-frankenstein&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fosdem.org&#x2F;2024&#x2F;schedule&#x2F;event&#x2F;fosdem-2024-1762-arm6...</a></div><br/></div></div><div id="40772551" class="c"><input type="checkbox" id="c-40772551" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40773243">prev</a><span>|</span><a href="#40772415">next</a><span>|</span><label class="collapse" for="c-40772551">[-]</label><label class="expand" for="c-40772551">[2 more]</label></div><br/><div class="children"><div class="content">Windows 9x can run 16-bit realmode (V86), 16-bit protected mode, and 32-bit protected mode code in the same process by using different segment descriptors. Too bad amd64 wasn&#x27;t compatible with that model, nor the virtualisation features that came afterwards, or Intel could&#x27;ve made ARM32&#x2F;64-mode segments a reality if they decided to add an ARM decoder to their microarchitecture.</div><br/><div id="40773088" class="c"><input type="checkbox" id="c-40773088" checked=""/><div class="controls bullet"><span class="by">st_goliath</span><span>|</span><a href="#40772551">parent</a><span>|</span><a href="#40772415">next</a><span>|</span><label class="collapse" for="c-40773088">[-]</label><label class="expand" for="c-40773088">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ... 16-bit realmode (V86), 16-bit protected mode, and 32-bit protected mode code in the same process by using different segment descriptors...<p>&gt; ...Intel could&#x27;ve made ARM32&#x2F;64-mode segments a reality...<p>While I myself admire this particular breed of masochism, the direction that Intel currently wants to take is apparently quite the opposite.<p>In May last year, they proposed X86S[1][2][3] which tosses out 16-bit support <i>completely</i>, along with 32 bit kernel mode (i.e. the CPU boots directly into 64 bit mode, 32 bit code is only supported in ring 3).<p>The proposal trims a lot of historical baggage, including fancy segmentation&#x2F;TSS shenanigans, privilege rings 1 &amp; 2, I&#x2F;O port access from ring 3, non-flat memory models, etc... limiting the CPU to 64 bit kernel mode, and 64 or 32 bit x86 user mode. With the requirement for 64 bit kernel mode, it effectively also removes un-paged memory access.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86-64#X86S" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86-64#X86S</a><p>[2] <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;technical&#x2F;envisioning-future-simplified-architecture.html" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;developer&#x2F;articles&#x2F;t...</a><p>[3] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36006446">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36006446</a></div><br/></div></div></div></div><div id="40772415" class="c"><input type="checkbox" id="c-40772415" checked=""/><div class="controls bullet"><span class="by">classichasclass</span><span>|</span><a href="#40772551">prev</a><span>|</span><a href="#40773388">next</a><span>|</span><label class="collapse" for="c-40772415">[-]</label><label class="expand" for="c-40772415">[1 more]</label></div><br/><div class="children"><div class="content">This ( <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;arm&#x2F;arm64ec-abi" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;arm&#x2F;arm64ec-abi</a> ) feels a lot like a modern rethinking of Universal Procedure Pointers (i.e., between PowerPC and the 68K emulator on Power Macintosh).</div><br/></div></div><div id="40773388" class="c"><input type="checkbox" id="c-40773388" checked=""/><div class="controls bullet"><span class="by">Tempest1981</span><span>|</span><a href="#40772415">prev</a><span>|</span><a href="#40773197">next</a><span>|</span><label class="collapse" for="c-40773388">[-]</label><label class="expand" for="c-40773388">[1 more]</label></div><br/><div class="children"><div class="content">&gt; requires the use of the Windows 11 SDK and is not available on Windows 10 on Arm.<p>So what should developers do re: Win10 users? Separate builds for them?</div><br/></div></div><div id="40773197" class="c"><input type="checkbox" id="c-40773197" checked=""/><div class="controls bullet"><span class="by">nomercy400</span><span>|</span><a href="#40773388">prev</a><span>|</span><a href="#40772700">next</a><span>|</span><label class="collapse" for="c-40773197">[-]</label><label class="expand" for="c-40773197">[2 more]</label></div><br/><div class="children"><div class="content">So is this Arm64EC Windows-only? Is it standardized?<p>If not, is this not just another target architecture? You cannot use it on arm64 architectures, and your app already supports x86.</div><br/><div id="40773491" class="c"><input type="checkbox" id="c-40773491" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40773197">parent</a><span>|</span><a href="#40772700">next</a><span>|</span><label class="collapse" for="c-40773491">[-]</label><label class="expand" for="c-40773491">[1 more]</label></div><br/><div class="children"><div class="content">It’s not anything special, it’s arm code compiled with the x64 abi. The theory behind it is simple enough.</div><br/></div></div></div></div><div id="40772700" class="c"><input type="checkbox" id="c-40772700" checked=""/><div class="controls bullet"><span class="by">frozenport</span><span>|</span><a href="#40773197">prev</a><span>|</span><label class="collapse" for="c-40772700">[-]</label><label class="expand" for="c-40772700">[7 more]</label></div><br/><div class="children"><div class="content">Struggling with the use case.<p>It seems like this is when you have the source or the libs but choose to mix x86 and arm?<p>It would seem if you have the source etc you should just bite the bullet and port everything.</div><br/><div id="40772815" class="c"><input type="checkbox" id="c-40772815" checked=""/><div class="controls bullet"><span class="by">adamjs</span><span>|</span><a href="#40772700">parent</a><span>|</span><label class="collapse" for="c-40772815">[-]</label><label class="expand" for="c-40772815">[6 more]</label></div><br/><div class="children"><div class="content">Two use-cases jump to mind:<p>* Allows incremental porting of large codebases to ARM. (It&#x27;s not always feasible to port everything at once-- I have a few projects with lots of hand-optimized SSE code, for example.)<p>* Allows usage of third-party x64 DLLs in ARM apps without recompilation. (Source isn&#x27;t always available or might be too much of a headache to port on your own.)</div><br/><div id="40773325" class="c"><input type="checkbox" id="c-40773325" checked=""/><div class="controls bullet"><span class="by">vsl</span><span>|</span><a href="#40772700">root</a><span>|</span><a href="#40772815">parent</a><span>|</span><a href="#40772967">next</a><span>|</span><label class="collapse" for="c-40773325">[-]</label><label class="expand" for="c-40773325">[1 more]</label></div><br/><div class="children"><div class="content">3. Improve x64 emulation performance for everybody. Windows 11 on ARM ships system DLLs compiled as Arm64EC - makes the x64 binaries run native ARM code at least within system libraries.</div><br/></div></div><div id="40772967" class="c"><input type="checkbox" id="c-40772967" checked=""/><div class="controls bullet"><span class="by">callalex</span><span>|</span><a href="#40772700">root</a><span>|</span><a href="#40772815">parent</a><span>|</span><a href="#40773325">prev</a><span>|</span><a href="#40773186">next</a><span>|</span><label class="collapse" for="c-40772967">[-]</label><label class="expand" for="c-40772967">[2 more]</label></div><br/><div class="children"><div class="content">At that point why trust the emulator over the port? Either you have sufficient tests for your workload or you don’t, anything else is voodoo&#x2F;tarot&#x2F;tea leaves&#x2F;SWAG.</div><br/><div id="40773115" class="c"><input type="checkbox" id="c-40773115" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#40772700">root</a><span>|</span><a href="#40772967">parent</a><span>|</span><a href="#40773186">next</a><span>|</span><label class="collapse" for="c-40773115">[-]</label><label class="expand" for="c-40773115">[1 more]</label></div><br/><div class="children"><div class="content">We might be lucky and the emulator guys might have enough testing</div><br/></div></div></div></div><div id="40773186" class="c"><input type="checkbox" id="c-40773186" checked=""/><div class="controls bullet"><span class="by">frozenport</span><span>|</span><a href="#40772700">root</a><span>|</span><a href="#40772815">parent</a><span>|</span><a href="#40772967">prev</a><span>|</span><label class="collapse" for="c-40773186">[-]</label><label class="expand" for="c-40773186">[2 more]</label></div><br/><div class="children"><div class="content">Yeah but you need to port the SIMD before shipping anyways?<p>So if you&#x27;re doing incremental stuff might as well stub out the calls with &quot;not implemented&quot;, and start filling them in.</div><br/><div id="40773270" class="c"><input type="checkbox" id="c-40773270" checked=""/><div class="controls bullet"><span class="by">creshal</span><span>|</span><a href="#40772700">root</a><span>|</span><a href="#40773186">parent</a><span>|</span><label class="collapse" for="c-40773270">[-]</label><label class="expand" for="c-40773270">[1 more]</label></div><br/><div class="children"><div class="content">The SIMD part will be emulated as normal, as far as I understand. So you can ship a first version with all-emulated code, and then incrementally port hotspots to native code, while letting the emulator handle the non-critical parts.<p>At least in theory, we&#x27;ll see how it actually pans out in practice.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>