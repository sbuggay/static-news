<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700730064108" as="style"/><link rel="stylesheet" href="styles.css?v=1700730064108"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://imapenguin.com/2023/11/a-gentle-introduction-to-twos-complement/">A gentle introduction to two&#x27;s complement</a>Â <span class="domain">(<a href="https://imapenguin.com">imapenguin.com</a>)</span></div><div class="subtext"><span>surprisetalk</span> | <span>16 comments</span></div><br/><div><div id="38389183" class="c"><input type="checkbox" id="c-38389183" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38389533">next</a><span>|</span><label class="collapse" for="c-38389183">[-]</label><label class="expand" for="c-38389183">[7 more]</label></div><br/><div class="children"><div class="content">Applying the unary &quot;negate&quot; operation isn&#x27;t particularly useful test.<p>For reference (and note the apostrophe locations):<p>* sign-magnitude is slightly easier for multiplication&#x2F;division but makes addition&#x2F;subtraction marginally harder. It&#x27;s widely used in bigint libraries, and IEEE binary floats use a variant of it (unlike IEEE decimal floats, which are not at all sane).<p>* two&#x27;s complement is optimal for addition&#x2F;subtraction, but has a weird &quot;most negative&quot; value. Fixed-width multiplication and division have a couple warts but .<p>* ones&#x27; complement is not particularly useful compared to the above two choices, though I suppose it&#x27;s marginally easier to sort than sign-magnitude<p>* offset-binary is useful for naive sorting, but casting to&#x2F;from unsigned is not a nop.<p>For two&#x27;s complement at least, to avoid the UB you can just cast to&#x2F;from unsigned around most operations. Division has to be done with some kind of branches, however.<p>I rather wish we had an integer `NaN` instead of the most-negative value.<p>Also, there are several useful overflow behaviors: trap, wrap, saturate, unspecified, and undefined. &quot;unspecified&quot; is particularly useful if you&#x27;re sometimes transpiling to a JS-like language that doesn&#x27;t actually support integers.</div><br/><div id="38389633" class="c"><input type="checkbox" id="c-38389633" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#38389183">parent</a><span>|</span><a href="#38389296">next</a><span>|</span><label class="collapse" for="c-38389633">[-]</label><label class="expand" for="c-38389633">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about other bigint libraries, but java.math.BigInteger uses two&#x27;s complement, not sign-magnitude. This class is designed to imitate machine-size two&#x27;s complement integers.<p>The most negative value is a wart in two&#x27;s complement, but negative zero is a wart in sign-magnitude and ones&#x27; complement.<p>The advantage of ones&#x27; complement compared to sign-magnitude is that the former needs minimal circuitry to implement subtraction. Namely, it just needs to invert every bit and then feed it into the adder.<p>You only need to avoid undefined behavior in two&#x27;s complement in C and C++. UB is not a property of two&#x27;s complement, but a particular language&#x27;s design choices. I can assure you that there is no UB in two&#x27;s complement in Java or x86 assembly.<p>Note that offset-binary is used in IEEE 754 floating-point exponents.</div><br/></div></div><div id="38389296" class="c"><input type="checkbox" id="c-38389296" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38389183">parent</a><span>|</span><a href="#38389633">prev</a><span>|</span><a href="#38389654">next</a><span>|</span><label class="collapse" for="c-38389296">[-]</label><label class="expand" for="c-38389296">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think an integer NaN would be a good idea. People&#x27;s intuition around the existing float NaNs is not good.<p>I want to make user defined types like BalancedI32 (32bit signed integer but the magnitude of MAX and MIN are the same) possible in Rust. Today the stdlib is allowed to make NonZeroI32 which as its name suggests lacks zero but you can&#x27;t make such types yourself except via wrapping these NonZero types with xor or similar.<p>(In nightly Rust you can just break the rules and do the same thing the stdlib does, but there&#x27;s no obligation to keep that working and it will never be stabilized)<p>Because of the Guaranteed Niche Optimisation this means Option&lt;BalancedI32&gt; would have identical size to i32. So you get the same practicality as a normal signed integer with a sentinel value, but the same programming ergonomics as an expensive high level type.</div><br/><div id="38390450" class="c"><input type="checkbox" id="c-38390450" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38389183">root</a><span>|</span><a href="#38389296">parent</a><span>|</span><a href="#38389654">next</a><span>|</span><label class="collapse" for="c-38390450">[-]</label><label class="expand" for="c-38390450">[1 more]</label></div><br/><div class="children"><div class="content">&gt; People&#x27;s intuition around the existing float NaNs is not good.<p>I think that, if NaN was defined to be an unconditional trap but can be deferred for efficiency, then it could have worked much better. NaN surprises people because it was exposed in the first place, while it should really have been hidden behind the scene (because the presence of NaN means you are already wrong somewhere, and you are expected to be notified about that fact). In terms of Rust, say, every f32 operation could have returned `Result&lt;f32, FloatError&gt;` (mostly likely to be aliased though) that has the exactly same layout as the current f32. The current split between qNaN and sNaN (among others) is unnecessarily complex with little benefit.</div><br/></div></div></div></div><div id="38389654" class="c"><input type="checkbox" id="c-38389654" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#38389183">parent</a><span>|</span><a href="#38389296">prev</a><span>|</span><a href="#38389533">next</a><span>|</span><label class="collapse" for="c-38389654">[-]</label><label class="expand" for="c-38389654">[3 more]</label></div><br/><div class="children"><div class="content">IEEE decimal is definitely complicated and confusing, but it does seem to unambiguously be sign-magnitude?  The confusing part is how the magnitude works, not how signedness works...</div><br/><div id="38389959" class="c"><input type="checkbox" id="c-38389959" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38389183">root</a><span>|</span><a href="#38389654">parent</a><span>|</span><a href="#38389533">next</a><span>|</span><label class="collapse" for="c-38389959">[-]</label><label class="expand" for="c-38389959">[2 more]</label></div><br/><div class="children"><div class="content">The weird interleaving of the exponent with the mantissa - and the existence of noncanonical values - means you can&#x27;t just through them into sign-magnitude integer comparison routines.</div><br/><div id="38390306" class="c"><input type="checkbox" id="c-38390306" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38389183">root</a><span>|</span><a href="#38389959">parent</a><span>|</span><a href="#38389533">next</a><span>|</span><label class="collapse" for="c-38390306">[-]</label><label class="expand" for="c-38390306">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that interleaving is mainly used for making better use of bits? To me it is more like the limitation of exact power-of-two bit sizes, for example decimal40 (1 sign bit + 9 exponent bits + 30 mantissa bits) should have been not that bad. In comparison, decimal32 could have the following combinations:<p><pre><code>    s  e    m
    1 11   20   - 6 mantissa digits, exponent range too large (~10^+&#x2F;-1000)
    1  7   24   - 7 mantissa digits, exponent range too small (~10^+&#x2F;-60)
    1  7.6 23.3 - still 7 mantissa digits, but interleaving gives exponent range of ~10^+&#x2F;-90
    1  4   27   - 8 mantissa digits, exponent range too small to even contain binary32
    1  1   30   - 9 mantissa digits but no usable exponent range
</code></pre>
I guess it is not the worst trade-off.<p>Your point about non-canonical values is entirely valid though. I do know it is mostly due to the expensive normalization step, but that only sounds like a reason to always prefer DPD---there is little reason to define a decimal FP standard if it is not for hardwares nowadays.</div><br/></div></div></div></div></div></div></div></div><div id="38389533" class="c"><input type="checkbox" id="c-38389533" checked=""/><div class="controls bullet"><span class="by">CSSer</span><span>|</span><a href="#38389183">prev</a><span>|</span><a href="#38389602">next</a><span>|</span><label class="collapse" for="c-38389533">[-]</label><label class="expand" for="c-38389533">[1 more]</label></div><br/><div class="children"><div class="content">To be honest, I feel pretty insecure about bitwise operations. I was really psyched for the primer link, but it 404ed :(</div><br/></div></div><div id="38389602" class="c"><input type="checkbox" id="c-38389602" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#38389533">prev</a><span>|</span><a href="#38389968">next</a><span>|</span><label class="collapse" for="c-38389602">[-]</label><label class="expand" for="c-38389602">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s spelled ones&#x27; complement. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ones%27_complement" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ones%27_complement</a></div><br/></div></div><div id="38388734" class="c"><input type="checkbox" id="c-38388734" checked=""/><div class="controls bullet"><span class="by">kr0bat</span><span>|</span><a href="#38389968">prev</a><span>|</span><label class="collapse" for="c-38388734">[-]</label><label class="expand" for="c-38388734">[5 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  To find the twoâs complement of 5, we invert all the bits (changing 0s to 1s and 1s to 0s) and then add one to the result.
</code></pre>
I am embarrassed by the fact that I wasn&#x27;t aware of this. I always interpreted the two&#x27;s complement as the difference between the all the numbers before the high bit, minus the high bit. Aka 10000000 â 01111011 = 0101</div><br/><div id="38389568" class="c"><input type="checkbox" id="c-38389568" checked=""/><div class="controls bullet"><span class="by">svat</span><span>|</span><a href="#38388734">parent</a><span>|</span><a href="#38389494">next</a><span>|</span><label class="collapse" for="c-38389568">[-]</label><label class="expand" for="c-38389568">[1 more]</label></div><br/><div class="children"><div class="content">That it&#x27;s the same thing may be more familiar in base 10: for example with 3-digit numbers, the 10&#x27;s complement of (say) 428 is 1000-428 = 572, and you get the same result if you &quot;invert&quot; each digit (subtract from 9) and add 1: 571 + 1 = 572. This is just because 
(999-x)+1 = 1000-x.</div><br/></div></div><div id="38389494" class="c"><input type="checkbox" id="c-38389494" checked=""/><div class="controls bullet"><span class="by">KMag</span><span>|</span><a href="#38388734">parent</a><span>|</span><a href="#38389568">prev</a><span>|</span><a href="#38390088">next</a><span>|</span><label class="collapse" for="c-38389494">[-]</label><label class="expand" for="c-38389494">[1 more]</label></div><br/><div class="children"><div class="content">One of the advantages of two&#x27;s compliment (particularly relevant in early hardware that really needed to minimize gate count) is that you can use an adder to perform subtraction: just flip all of the bits of the argument to subtract, and have an extra carry input to pretend you have a carry-in bit to be added to the least significant bit.<p>If you want your CPU to efficiently support multi-precision addition, you can have an overflow machine state flag and have an instruction that uses that overflow flag as the carry-in to the least significant bit during addition.</div><br/></div></div><div id="38390088" class="c"><input type="checkbox" id="c-38390088" checked=""/><div class="controls bullet"><span class="by">dperrin</span><span>|</span><a href="#38388734">parent</a><span>|</span><a href="#38389494">prev</a><span>|</span><a href="#38389515">next</a><span>|</span><label class="collapse" for="c-38390088">[-]</label><label class="expand" for="c-38390088">[1 more]</label></div><br/><div class="children"><div class="content">When I first learned two&#x27;s complement I sort of accepted it as something to memorise for a test and didn&#x27;t really understand (or care) why it worked.<p>What really made it click for me was thinking of it as modular arithmetic. If you consider 8-bit integers, they range from 0-255 and you&#x27;re actually working modulo 256. So you can think of 0-127 as your non-negative numbers. The numbers from 128-255 behave as negatives modulo 256 (e.g. -1 mod 256 = 255).</div><br/></div></div><div id="38389515" class="c"><input type="checkbox" id="c-38389515" checked=""/><div class="controls bullet"><span class="by">YiraldyGuber</span><span>|</span><a href="#38388734">parent</a><span>|</span><a href="#38390088">prev</a><span>|</span><label class="collapse" for="c-38389515">[-]</label><label class="expand" for="c-38389515">[1 more]</label></div><br/><div class="children"><div class="content">I find it much easier to think of everything in unsigned terms. If I want 8bit -5, I really want 256-5=251. I&#x27;ve done plenty of that in my time but I don&#x27;t think I&#x27;ve once consciously inverted bits and added 1.</div><br/></div></div></div></div></div></div></div></div></div></body></html>