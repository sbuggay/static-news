<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725267676795" as="style"/><link rel="stylesheet" href="styles.css?v=1725267676795"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/">Extreme Pi Boot Optimization</a> <span class="domain">(<a href="https://kittenlabs.de">kittenlabs.de</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>85 comments</span></div><br/><div><div id="41421157" class="c"><input type="checkbox" id="c-41421157" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#41423289">next</a><span>|</span><label class="collapse" for="c-41421157">[-]</label><label class="expand" for="c-41421157">[6 more]</label></div><br/><div class="children"><div class="content">Power is really one of the weaknesses of the rpi family (I&#x27;m quite excited for the new pico 2 for exactly this reason - it seems like they&#x27;re finally making it easy to enter a relatively deep sleep without external hardware).<p>I built some cameras for an application like this using a Google Coral mini, whose camera is not nearly as good as the HQ cam, unfortunately, but it supports a built in suspend + wake from onboard RTC that is very easy to use and perfect for a periodic camera app - while still having enough oomph and 2GB of memory to handle a high resolution image. (You can physically hook an HQ camera up but the software pipeline doesn&#x27;t exist to manage it on the coral AFAIK.)<p>The Rpi ecosystem is a lot more mature and (sorry, friends) I trust the future availability of rpi more than I trust Google to keep delivering the coral line, but it really underscored how helpful good power support in the hw was.<p>(Ironically, we ended up outsourcing the next version of these cameras to a firm that built them using an rpi and we just threw in a much larger battery to compensate. Which means I have a stack of 100 unopened coral dev minis + cameras looking for either good ideas or to sell to someone. Oops.)</div><br/><div id="41423257" class="c"><input type="checkbox" id="c-41423257" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#41421157">parent</a><span>|</span><a href="#41421396">next</a><span>|</span><label class="collapse" for="c-41423257">[-]</label><label class="expand" for="c-41423257">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the Coral line already dead&#x2F;discontinued? The site (coral.ai) seems to have been last updated in 2021 and it says Copyright 2020.<p>Oh god, just searched for &quot;google coral twitter&quot; looking for an official twitter presence of the project and the second hit was a tweet of yours looking to sell your 100 excess boards.</div><br/></div></div><div id="41421396" class="c"><input type="checkbox" id="c-41421396" checked=""/><div class="controls bullet"><span class="by">cgearhart</span><span>|</span><a href="#41421157">parent</a><span>|</span><a href="#41423257">prev</a><span>|</span><a href="#41421410">next</a><span>|</span><label class="collapse" for="c-41421396">[-]</label><label class="expand" for="c-41421396">[2 more]</label></div><br/><div class="children"><div class="content">Interesting, I’ve always run pis from wall power. Is the pi hardware incapable of similar power optimizations to coral, or is this a problem of a lack of software support for power management on pi? (I assume from your mention of external hardware to manage power that it’s not just a software issue.)</div><br/><div id="41421869" class="c"><input type="checkbox" id="c-41421869" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#41421157">root</a><span>|</span><a href="#41421396">parent</a><span>|</span><a href="#41421410">next</a><span>|</span><label class="collapse" for="c-41421869">[-]</label><label class="expand" for="c-41421869">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really mixing two things and wasn&#x27;t very clear about it.<p>The pico can kinda deep sleep but it requires an external wakeup trigger. It can&#x27;t deep sleep from its own clock. Even so its deep sleep is pretty high power compared to most embedded chips.<p>The zero (w) and zero 2 w don&#x27;t have the equivalent of suspend-to-ram with a low sleep current. I&#x27;m not sure if that&#x27;s a limitation of the SOC or the driver or both, but rpi was fairly clear it wasn&#x27;t in the cards: <a href="https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;linux&#x2F;issues&#x2F;1281">https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;linux&#x2F;issues&#x2F;1281</a></div><br/></div></div></div></div><div id="41421410" class="c"><input type="checkbox" id="c-41421410" checked=""/><div class="controls bullet"><span class="by">brk</span><span>|</span><a href="#41421157">parent</a><span>|</span><a href="#41421396">prev</a><span>|</span><a href="#41423289">next</a><span>|</span><label class="collapse" for="c-41421410">[-]</label><label class="expand" for="c-41421410">[2 more]</label></div><br/><div class="children"><div class="content">Out of curiosity what are you doing that can’t be done with an OTS camera these days?</div><br/><div id="41421837" class="c"><input type="checkbox" id="c-41421837" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#41421157">root</a><span>|</span><a href="#41421410">parent</a><span>|</span><a href="#41423289">next</a><span>|</span><label class="collapse" for="c-41421837">[-]</label><label class="expand" for="c-41421837">[1 more]</label></div><br/><div class="children"><div class="content">Dual cameras at 90deg to each other with lightweight onboard ml to decide capture &#x2F; no capture + geotargeted higher frame rate captures for regions of interest. In a housing that can handle hard impacts from brush and off-road use (we take pictures of pasture).<p>A lot of the video solutions have much worse image quality than a still camera operating at 1fps to 1&#x2F;20 fps; you can stick a quite good camera on an rpi.<p>It&#x27;s quite likely we could COTS this but there was no interest from vendors when we wanted to start with 200 of them. So we went with a custom solution.<p>(We are <a href="https:&#x2F;&#x2F;enriched.ag" rel="nofollow">https:&#x2F;&#x2F;enriched.ag</a> -- if you scroll down you can see our overly-heavy-metal but quite tough camera unit. Some day it will be injection molded instead...)</div><br/></div></div></div></div></div></div><div id="41423289" class="c"><input type="checkbox" id="c-41423289" checked=""/><div class="controls bullet"><span class="by">turblety</span><span>|</span><a href="#41421157">prev</a><span>|</span><a href="#41423203">next</a><span>|</span><label class="collapse" for="c-41423289">[-]</label><label class="expand" for="c-41423289">[1 more]</label></div><br/><div class="children"><div class="content">The real tragedy is the proprietary bootcode.bin gpu code that is a blackbox and we don&#x27;t have the source code for.<p>How horrible that a tinkering&#x2F;hobbies project has to have these hidden secret blackboxes that can&#x27;t be modified.</div><br/></div></div><div id="41423203" class="c"><input type="checkbox" id="c-41423203" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#41423289">prev</a><span>|</span><a href="#41421513">next</a><span>|</span><label class="collapse" for="c-41423203">[-]</label><label class="expand" for="c-41423203">[1 more]</label></div><br/><div class="children"><div class="content">Impressive. But every time I read one of these pieces I remember when I recorded Plan 9 booting on a Pi Zero: <a href="https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;blog&#x2F;2020&#x2F;09&#x2F;02&#x2F;1900#resurrecting" rel="nofollow">https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;blog&#x2F;2020&#x2F;09&#x2F;02&#x2F;1900#resurrecting</a> (GIF is real time output).</div><br/></div></div><div id="41421513" class="c"><input type="checkbox" id="c-41421513" checked=""/><div class="controls bullet"><span class="by">hysan</span><span>|</span><a href="#41423203">prev</a><span>|</span><a href="#41422400">next</a><span>|</span><label class="collapse" for="c-41421513">[-]</label><label class="expand" for="c-41421513">[2 more]</label></div><br/><div class="children"><div class="content">Two other good articles on decreasing Pi boot times are:<p>- <a href="https:&#x2F;&#x2F;www.furkantokac.com&#x2F;rpi3-fast-boot-less-than-2-seconds&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.furkantokac.com&#x2F;rpi3-fast-boot-less-than-2-secon...</a><p>- <a href="http:&#x2F;&#x2F;himeshp.blogspot.com&#x2F;2018&#x2F;08&#x2F;fast-boot-with-raspberry-pi.html" rel="nofollow">http:&#x2F;&#x2F;himeshp.blogspot.com&#x2F;2018&#x2F;08&#x2F;fast-boot-with-raspberry...</a><p>I used these two to make a digital photo frame with a Pi that boots very quickly to a browser in kiosk mode. If you have very minimal requirements, you can get some very impressive boot times.</div><br/><div id="41423137" class="c"><input type="checkbox" id="c-41423137" checked=""/><div class="controls bullet"><span class="by">rvdca</span><span>|</span><a href="#41421513">parent</a><span>|</span><a href="#41422400">next</a><span>|</span><label class="collapse" for="c-41423137">[-]</label><label class="expand" for="c-41423137">[1 more]</label></div><br/><div class="children"><div class="content">Thabks for the link ! Got the code accessible for this kiosk picture frame by any chance  ?</div><br/></div></div></div></div><div id="41422400" class="c"><input type="checkbox" id="c-41422400" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#41421513">prev</a><span>|</span><a href="#41423096">next</a><span>|</span><label class="collapse" for="c-41422400">[-]</label><label class="expand" for="c-41422400">[6 more]</label></div><br/><div class="children"><div class="content">I like the article as a whole, but I&#x27;m unsure about this point:<p>&gt; For example: Disabling CPU turbo just to save some current consumption is a bad choice, because the resulting extra time will use more energy than just getting the job done quickly and shutting off.<p>In one of my computer engineering classes, I learned that power consumption rises as the square of clock frequency - so doubling the clock will quadruple the power.<p>That seems like it&#x27;d imply that you&#x27;d actually have to measure the power difference to determine if the quadratic increase from the clock boost will outweigh the product of the constant power consumption with the additional time spent on the task.<p>Related - it&#x27;d be nice if the Pi&#x27;s CPUs included granular power consumption information, either derivable from the datasheet, or as real-time values exposed in registers.</div><br/><div id="41422918" class="c"><input type="checkbox" id="c-41422918" checked=""/><div class="controls bullet"><span class="by">daalex</span><span>|</span><a href="#41422400">parent</a><span>|</span><a href="#41422688">next</a><span>|</span><label class="collapse" for="c-41422918">[-]</label><label class="expand" for="c-41422918">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In one of my computer engineering classes, I learned that power consumption rises as the square of clock frequency - so doubling the clock will quadruple the power.<p>This is not quite correct.
Switching power of a chip (ignoring static leakage) is proportional to voltage squared times frequency.
Most chips require a higher voltage to reach higher clock speeds, so there is a quadratic relationship there.
However, I believe that the raspberry pi does not have dynamic voltage control, so reducing clock speed without also reducing voltage will not effect total switching energy consumption.</div><br/></div></div><div id="41422688" class="c"><input type="checkbox" id="c-41422688" checked=""/><div class="controls bullet"><span class="by">Salgat</span><span>|</span><a href="#41422400">parent</a><span>|</span><a href="#41422918">prev</a><span>|</span><a href="#41422461">next</a><span>|</span><label class="collapse" for="c-41422688">[-]</label><label class="expand" for="c-41422688">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a base amount of power overhead the device will use no matter what, even if it does nothing. They even provide benchmarks that show that current consumption for turbo increases 10% but reduces boot time by 11%, for a small but measurable difference in total energy used.</div><br/><div id="41423167" class="c"><input type="checkbox" id="c-41423167" checked=""/><div class="controls bullet"><span class="by">mortenlarsen</span><span>|</span><a href="#41422400">root</a><span>|</span><a href="#41422688">parent</a><span>|</span><a href="#41422461">next</a><span>|</span><label class="collapse" for="c-41423167">[-]</label><label class="expand" for="c-41423167">[1 more]</label></div><br/><div class="children"><div class="content">What about the internal resistance of the battery? Doesn&#x27;t that increase with higher current?<p>As in 1A for 2 seconds uses less actual battery power than 2A for 1 second due to internal loss in the battery?<p>I may be remembering this wrong, It has been a long time since I studied this stuff.</div><br/></div></div></div></div><div id="41422461" class="c"><input type="checkbox" id="c-41422461" checked=""/><div class="controls bullet"><span class="by">naming_the_user</span><span>|</span><a href="#41422400">parent</a><span>|</span><a href="#41422688">prev</a><span>|</span><a href="#41423096">next</a><span>|</span><label class="collapse" for="c-41422461">[-]</label><label class="expand" for="c-41422461">[2 more]</label></div><br/><div class="children"><div class="content">This is very interesting, thanks for sharing!<p>So if it takes 1J to do some computation in 1 second (say 1GHz at 1W), you&#x27;re saying that in the perfectly spherical cow case, it takes 2J to do that same computation in 0.5 seconds (2GHz at 4W).<p>However, that&#x27;s just CPU consumption, if the overall system has a static rate of 4W, then it takes 5J (1J CPU, 4J system) at 1Ghz to do the task in a second, or 4J (2J CPU, 2J system) at 2GHz to do the task in 0.5 seconds.<p>Am I understanding you correctly? Basically, if the overall system&#x27;s power consumption is similar to the CPU&#x27;s power consumption at turbo, then it makes sense to turbo, if not, it doesn&#x27;t?</div><br/><div id="41422710" class="c"><input type="checkbox" id="c-41422710" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#41422400">root</a><span>|</span><a href="#41422461">parent</a><span>|</span><a href="#41423096">next</a><span>|</span><label class="collapse" for="c-41422710">[-]</label><label class="expand" for="c-41422710">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is all correct, as long as you&#x27;re implicitly assuming that the CPU itself has some static power dissipation as well (which it does) in addition to the rest of the system.<p>Unfortunately I missed the actual benchmarks in the article that empirically measured the power difference.</div><br/></div></div></div></div></div></div><div id="41423096" class="c"><input type="checkbox" id="c-41423096" checked=""/><div class="controls bullet"><span class="by">merpkz</span><span>|</span><a href="#41422400">prev</a><span>|</span><a href="#41422514">next</a><span>|</span><label class="collapse" for="c-41423096">[-]</label><label class="expand" for="c-41423096">[4 more]</label></div><br/><div class="children"><div class="content">Why did I always had impression that decompressing data is much faster than reading inflated data off disk? Like, if you need to read just 5MB and decompress it would take less time than just to read 10MB off a disk, for example, but this article kinda states the otherwise.</div><br/><div id="41423237" class="c"><input type="checkbox" id="c-41423237" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41423096">parent</a><span>|</span><a href="#41423141">next</a><span>|</span><label class="collapse" for="c-41423237">[-]</label><label class="expand" for="c-41423237">[1 more]</label></div><br/><div class="children"><div class="content">This is actually something that flip-flops across hardware generations and platforms. Hard drives used to be really slow and consumer machines would often reduce data bandwidth by compressing things because processors were “faster” than disk. But today’s SSDs are actually really fast, sometimes so fast that CPUs can barely keep up just processing the data coming off of them, so the balance can also shift in the opposite direction. And in embedded your storage might be slow but you may not have the processing power to spare decompressing. Or maybe you do and it saves on flash write cycles. This is a complicated topic!</div><br/></div></div><div id="41423141" class="c"><input type="checkbox" id="c-41423141" checked=""/><div class="controls bullet"><span class="by">olex</span><span>|</span><a href="#41423096">parent</a><span>|</span><a href="#41423237">prev</a><span>|</span><a href="#41423152">next</a><span>|</span><label class="collapse" for="c-41423141">[-]</label><label class="expand" for="c-41423141">[1 more]</label></div><br/><div class="children"><div class="content">The article states a &quot;net-positive energy result&quot;, not necessarily a faster time for this specific optimization. They say GZIP decompression is energy-intensive, so while the combination of read + decompress may be faster, the CPU load during decompression and memory relocation of the decompressed data ultimately consumes more energy than reading an uncompressed kernel and running it directly.</div><br/></div></div><div id="41423152" class="c"><input type="checkbox" id="c-41423152" checked=""/><div class="controls bullet"><span class="by">erinaceousjones</span><span>|</span><a href="#41423096">parent</a><span>|</span><a href="#41423141">prev</a><span>|</span><a href="#41422514">next</a><span>|</span><label class="collapse" for="c-41423152">[-]</label><label class="expand" for="c-41423152">[1 more]</label></div><br/><div class="children"><div class="content">Might&#x27;ve been the case with &quot;spinning rust&quot; (hard drives) but solid state storage can have lower access and read times -- no need to wait for a disk to spin up or move read heads to the right position on a platter etc</div><br/></div></div></div></div><div id="41422514" class="c"><input type="checkbox" id="c-41422514" checked=""/><div class="controls bullet"><span class="by">arendtio</span><span>|</span><a href="#41423096">prev</a><span>|</span><a href="#41420807">next</a><span>|</span><label class="collapse" for="c-41422514">[-]</label><label class="expand" for="c-41422514">[3 more]</label></div><br/><div class="children"><div class="content">I wondered why a custom kernel came so late. If you want to optimize, wouldn&#x27;t you start with LFS or some source-based distribution? Autonomous software updates don&#x27;t seem to be a necessity anyway on such a device.<p>In addition, I wonder if it would be possible to optimize the EFI&#x2F;BIOS on such a device. At least on my standard Arch Linux desktop, it takes a significant amount of boot time:<p><pre><code>  $ systemd-analyze 
  Startup finished in 10.076s (firmware) + 1.339s (loader) + 1.569s (kernel) + 2.974s (initrd) + 3.894s (userspace) = 19.854s</code></pre></div><br/><div id="41423677" class="c"><input type="checkbox" id="c-41423677" checked=""/><div class="controls bullet"><span class="by">creatonez</span><span>|</span><a href="#41422514">parent</a><span>|</span><a href="#41422935">next</a><span>|</span><label class="collapse" for="c-41423677">[-]</label><label class="expand" for="c-41423677">[1 more]</label></div><br/><div class="children"><div class="content">&gt; wouldn&#x27;t you start with LFS or some source-based distribution<p>You don&#x27;t ever want to actually use LFS (the manual from the LFS project) in the real world as compiling GNU is far too much work. A minimalistic kernel + busybox system is much less pain. But Gentoo would not be a bad option too.</div><br/></div></div><div id="41422935" class="c"><input type="checkbox" id="c-41422935" checked=""/><div class="controls bullet"><span class="by">daalex</span><span>|</span><a href="#41422514">parent</a><span>|</span><a href="#41423677">prev</a><span>|</span><a href="#41420807">next</a><span>|</span><label class="collapse" for="c-41422935">[-]</label><label class="expand" for="c-41422935">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wondered why a custom kernel came so late. If you want to optimize, wouldn&#x27;t you start with LFS or some source-based distribution? Autonomous software updates don&#x27;t seem to be a necessity anyway on such a device.<p>Buildroot (which they used) is made exactly for this.
With buildroot, you configure your own &quot;Distribution&quot; and generate a single bootable image from it.<p>&gt; In addition, I wonder if it would be possible to optimize the EFI&#x2F;BIOS on such a device. At least on my standard Arch Linux desktop, it takes a significant amount of boot time:<p>Not exactly sure about raspberry pi hardware, but a lot of other embedded SoCs have a pretty minimal bootloader that runs with u-boot, which is typically very fast (at least if you set the delay it waits for user input to 0)</div><br/></div></div></div></div><div id="41420807" class="c"><input type="checkbox" id="c-41420807" checked=""/><div class="controls bullet"><span class="by">Avamander</span><span>|</span><a href="#41422514">prev</a><span>|</span><a href="#41421322">next</a><span>|</span><label class="collapse" for="c-41420807">[-]</label><label class="expand" for="c-41420807">[24 more]</label></div><br/><div class="children"><div class="content">IMHO boot times of Linux distros in general are rather sad, which is then significantly amplified on weak(er) hardware such as this. I&#x27;ve gone through similar efforts with the MQ-Pro SBC. One can also really feel this on laptops (except Macbooks I guess). Annoying.</div><br/><div id="41420974" class="c"><input type="checkbox" id="c-41420974" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#41420807">parent</a><span>|</span><a href="#41423261">next</a><span>|</span><label class="collapse" for="c-41420974">[-]</label><label class="expand" for="c-41420974">[14 more]</label></div><br/><div class="children"><div class="content">It very much depends what you define as &quot;boot time&quot;. For example, Windows optimizes for time to fist UI, meanwhile everything else continues to load and the PC stays unusable for multiple seconds after &quot;boot&quot;.</div><br/><div id="41421308" class="c"><input type="checkbox" id="c-41421308" checked=""/><div class="controls bullet"><span class="by">kiwijamo</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41420974">parent</a><span>|</span><a href="#41421220">next</a><span>|</span><label class="collapse" for="c-41421308">[-]</label><label class="expand" for="c-41421308">[1 more]</label></div><br/><div class="children"><div class="content">This is frequently due to startup apps, not Windows itself. I generally find when I disable stuff like Steam, Teams, Creative Cloud, OEM (e.g. HP) software, etc Windows is usable as soon as I log on. My work Windows laptop has most startup apps disabled (with the exception of OneDrive and Teams which I use frequently enough that it makes sense for it to be enabled on my work laptop) and I log on to a desktop ready to go. My personal laptop has everything except OneDrive disabled. YMMV and I acknowledge the default settings of letting apps insert themselves as Startup apps without user approval is not ideal. I note this is also an issue on MacOS from experience at my previous employer who issued me a Macbook which was configured as per corporate policy to have various apps including anti virus and the like loading on login to desktop. Only platforms that is so far immune to this is open source distros like Debian (using GNOME, its default desktop environment) et al but I&#x27;ve yet to work for an employer that uses Linux.</div><br/></div></div><div id="41421220" class="c"><input type="checkbox" id="c-41421220" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41420974">parent</a><span>|</span><a href="#41421308">prev</a><span>|</span><a href="#41421353">next</a><span>|</span><label class="collapse" for="c-41421220">[-]</label><label class="expand" for="c-41421220">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Windows optimizes for time to fist UI,&quot;<p>I&#x27;m going to apologise right now for giggling at your typo.  Microsoft have done some horrible things to UI.<p>The start menu - yes they created the fucking thing, yes it is now called start by everyone - own it (think Biro and co and stop being dicks) and it belongs at the left hand side. &quot;We&quot; know better than you, lets put it in the middle and surround it with weird shit and lets make it odd and put fucking games controllers on a corporate laptop and other wankery that we can&#x27;t be bothered to curate because we are so poor but if you love our weather forecasts and shitty ... whomever will pay us .. whatever thing.<p>I think that Microsoft have lost interest in humanity as anything than a pool of subscription slaves to contribute to their bottom line.<p>That is some pretty aggressive fisting.</div><br/><div id="41421545" class="c"><input type="checkbox" id="c-41421545" checked=""/><div class="controls bullet"><span class="by">pbhjpbhj</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41421220">parent</a><span>|</span><a href="#41421353">next</a><span>|</span><label class="collapse" for="c-41421545">[-]</label><label class="expand" for="c-41421545">[1 more]</label></div><br/><div class="children"><div class="content">The principal menu is still bottom left doing what they clearly see as most important thing in the OS, advertising shit and feeding you heavily politicised propaganda. So useful!</div><br/></div></div></div></div><div id="41421353" class="c"><input type="checkbox" id="c-41421353" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41420974">parent</a><span>|</span><a href="#41421220">prev</a><span>|</span><a href="#41421295">next</a><span>|</span><label class="collapse" for="c-41421353">[-]</label><label class="expand" for="c-41421353">[1 more]</label></div><br/><div class="children"><div class="content">My Windows box starts fast, gets to login in moments, and is usable immediately. Are you sure you don&#x27;t have a bunch of extra software set to run at startup? Steam? Adobe Creative Cloud? Oculus Support?<p>My corp Mac actually has this issue as it launches some security software, launches the browser, checks that apps are up to date and security patches are applied etc. It takes several seconds (10-20?) before it&#x27;s ready to use.</div><br/></div></div><div id="41421295" class="c"><input type="checkbox" id="c-41421295" checked=""/><div class="controls bullet"><span class="by">genewitch</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41420974">parent</a><span>|</span><a href="#41421353">prev</a><span>|</span><a href="#41422702">next</a><span>|</span><label class="collapse" for="c-41421295">[-]</label><label class="expand" for="c-41421295">[4 more]</label></div><br/><div class="children"><div class="content">you all reboot windows?
madness.<p>I got devuan down to about 8 seconds from startup -&gt; login -&gt; shutdown on the tty. Gentoo boots pretty fast to a desktop (maybe 15-20 seconds) - a lot of the slowdown on &quot;modern&quot; linux is systemd waiting for NICs and whatever to quiesce. Hilariously, Ubuntu is by far the <i>worst</i> at boot times, i&#x27;ve had ubuntu sit there for minutes because it was airgapped.<p>I kinda lost interest in attempting to speed up boots more than that, maybe if i had some funding i could get debian or gentoo down to a couple of seconds of boot overhead before X&#x2F;wayland&#x2F;whatever runs.</div><br/><div id="41421321" class="c"><input type="checkbox" id="c-41421321" checked=""/><div class="controls bullet"><span class="by">kiwijamo</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41421295">parent</a><span>|</span><a href="#41422702">next</a><span>|</span><label class="collapse" for="c-41421321">[-]</label><label class="expand" for="c-41421321">[3 more]</label></div><br/><div class="children"><div class="content">Windows is pretty fast nowdays on modern hardware (especially if it&#x27;s booting off an SSD drive) and Debian&#x2F;GNOME is also pretty fast to a desktop as well. Slow boots off a SSD drive would point at an issue somewhere regardless of your OS.<p>I generally do shutdown on my gaming tower PC as the idle power usage isn&#x27;t great and shutdown&#x2F;boot is fast enough that it&#x27;s not much difference compared to suspend. Laptops though I just suspend -- I often get weeks of uptime in Windows.</div><br/><div id="41421487" class="c"><input type="checkbox" id="c-41421487" checked=""/><div class="controls bullet"><span class="by">genewitch</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41421321">parent</a><span>|</span><a href="#41422702">next</a><span>|</span><label class="collapse" for="c-41421487">[-]</label><label class="expand" for="c-41421487">[2 more]</label></div><br/><div class="children"><div class="content">I almost want to test this out - shut down my PC, unplug it, hit the power button, wait like 15 minutes, then turn it back on. Will it still be &quot;pretty fast&quot;? My (probably wrong) understanding was windows boot times are so fast because it&#x27;s really just hibernating when you shut down. I&#x27;m sure there&#x27;s technical names for the power state (S0?) - but ram is kept &quot;warm&quot; so that resume basically just needs to check that all the devices it needs are connected and reset the software clock.<p>I&#x27;m currently showing 50.6GB &quot;in use&quot; and 62GB commit on my windows machine. My boot drive is an intel SSD on <i>sata</i>, less than a GB&#x2F;second - this implies if windows does recover memory from disk on &quot;cold&quot; boot my machine will take about a minute to restore RAM.<p>i may be conflating things, but i&#x27;ve lived with this assumption that shutting down my PC is merely hibernating it, and as such, i always pull mains power before removing hardware.</div><br/><div id="41422182" class="c"><input type="checkbox" id="c-41422182" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41421487">parent</a><span>|</span><a href="#41422702">next</a><span>|</span><label class="collapse" for="c-41422182">[-]</label><label class="expand" for="c-41422182">[1 more]</label></div><br/><div class="children"><div class="content">If you see the BIOS screen, then it isn&#x27;t suspended.<p>It could still be suspend-to-disk, but desktop PCs don&#x27;t do that.<p>Windows &#x27;fast boot&#x27; does work by saving some critical state on shutdown, but it&#x27;s still a complete shutdown.</div><br/></div></div></div></div></div></div></div></div><div id="41422702" class="c"><input type="checkbox" id="c-41422702" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41420974">parent</a><span>|</span><a href="#41421295">prev</a><span>|</span><a href="#41421039">next</a><span>|</span><label class="collapse" for="c-41422702">[-]</label><label class="expand" for="c-41422702">[3 more]</label></div><br/><div class="children"><div class="content">When I reboot my Windows PC every 3 months or so, I can start using it as soon as the desktop shows up. No slowdown. I have 5800x3d&#x2F;64GB&#x2F;2TB&#x2F;4090. I don&#x27;t have any startup apps other than the ones that come built-in with enterprise edition.<p>Why do you have such a different experience?</div><br/><div id="41423067" class="c"><input type="checkbox" id="c-41423067" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41422702">parent</a><span>|</span><a href="#41421039">next</a><span>|</span><label class="collapse" for="c-41423067">[-]</label><label class="expand" for="c-41423067">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Why do you have such a different experience?<p>Well...<p>&gt; I don&#x27;t have any startup apps other than the ones that come built-in with enterprise edition.<p>There is the matter where 99% of people aren&#x27;t on enterprise, and of the 1% who are, virtually all are running it laden with a pile of corporate garbage.</div><br/><div id="41423248" class="c"><input type="checkbox" id="c-41423248" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41423067">parent</a><span>|</span><a href="#41421039">next</a><span>|</span><label class="collapse" for="c-41423248">[-]</label><label class="expand" for="c-41423248">[1 more]</label></div><br/><div class="children"><div class="content">Guy goes into the doctor&#x27;s office. Says, &quot;Doctor, it hurts when I do this. &quot; You know what the doctor says?<p>&quot;Don&#x27;t do that&quot;<p>Seriously tho, anyone can activate enterprise edition with MAS. And even if you&#x27;re on home edition, why would it take longer to boot up? All the crap is on your SSD, not your RAM</div><br/></div></div></div></div></div></div><div id="41421039" class="c"><input type="checkbox" id="c-41421039" checked=""/><div class="controls bullet"><span class="by">layoric</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41420974">parent</a><span>|</span><a href="#41422702">prev</a><span>|</span><a href="#41423481">next</a><span>|</span><label class="collapse" for="c-41421039">[-]</label><label class="expand" for="c-41421039">[1 more]</label></div><br/><div class="children"><div class="content">Exactly my experience as well. I moved away from Windows (10) earlier this year, and login times (waiting for the user desktop to come up after putting in credentials) took ~10 seconds. Sometimes it was faster after a fresh install, but it never lasted, even when regularly managing what services and apps were loaded on startup.</div><br/></div></div><div id="41423481" class="c"><input type="checkbox" id="c-41423481" checked=""/><div class="controls bullet"><span class="by">Avamander</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41420974">parent</a><span>|</span><a href="#41421039">prev</a><span>|</span><a href="#41423261">next</a><span>|</span><label class="collapse" for="c-41423481">[-]</label><label class="expand" for="c-41423481">[1 more]</label></div><br/><div class="children"><div class="content">I consider boot time from power off until I can start the first application I want.<p>But I am a bit strict about what I consider slow on modern hardware though. Why should a regular desktop distro wait around five seconds for networking and NTP before displaying login, or why should it take UEFI 5s to start the OS. I can forgive SBCs running off an SD card taking 15-30 seconds to boot, but not a PC that&#x27;s significantly faster in all other aspects.<p>I&#x27;m not even going to start with all the crap that starts on an average Windows desktop. It&#x27;s disgusting.</div><br/></div></div></div></div><div id="41423261" class="c"><input type="checkbox" id="c-41423261" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41420807">parent</a><span>|</span><a href="#41420974">prev</a><span>|</span><a href="#41423181">next</a><span>|</span><label class="collapse" for="c-41423261">[-]</label><label class="expand" for="c-41423261">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure how much distros can do here, the userspace part of boot time is negligible (unless there is some horrible misconfiguration, like networkmanager waiting 90 seconds for nonexistent wifi...). My linux box takes about 4 seconds until graphical.target, most of which is connecting to wifi and ntpd, both of which are optional in principle.<p>If you really want a fast boot, ditch all the bootloader compatibility layers, abstractions and dynamic configuration possibilities like initramfs. But then you would be at the mercy of the hardware vendor, which is definitely not worth it.</div><br/><div id="41423436" class="c"><input type="checkbox" id="c-41423436" checked=""/><div class="controls bullet"><span class="by">Avamander</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41423261">parent</a><span>|</span><a href="#41423181">next</a><span>|</span><label class="collapse" for="c-41423436">[-]</label><label class="expand" for="c-41423436">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My linux box takes about 4 seconds until graphical.target, most of which is connecting to wifi and ntpd, both of which are optional in principle.<p>But why should a login screen wait behind networking target for example? That ordering is up to the distributions.<p>&gt; If you really want a fast boot, ditch all the bootloader compatibility layers, abstractions and dynamic configuration possibilities like initramfs. But then you would be at the mercy of the hardware vendor, which is definitely not worth it.<p>You&#x27;d expect that would be the case with SBCs, most if not all do overlays instead of ACPI. Very few also offer UEFI, so there isn&#x27;t a slow(er) layer there either, but you are at the mercy of the vendor.</div><br/></div></div></div></div><div id="41423181" class="c"><input type="checkbox" id="c-41423181" checked=""/><div class="controls bullet"><span class="by">deivid</span><span>|</span><a href="#41420807">parent</a><span>|</span><a href="#41423261">prev</a><span>|</span><a href="#41421335">next</a><span>|</span><label class="collapse" for="c-41423181">[-]</label><label class="expand" for="c-41423181">[1 more]</label></div><br/><div class="children"><div class="content">Linux can boot quite quickly with the right settings, I&#x27;ve written about it at [0], but distros (reasonably) build very generic kernels and initramfs, which are not particularly fast to boot<p>[0]: <a href="https:&#x2F;&#x2F;blog.davidv.dev&#x2F;posts&#x2F;minimizing-linux-boot-times&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.davidv.dev&#x2F;posts&#x2F;minimizing-linux-boot-times&#x2F;</a></div><br/></div></div><div id="41421335" class="c"><input type="checkbox" id="c-41421335" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41420807">parent</a><span>|</span><a href="#41423181">prev</a><span>|</span><a href="#41421506">next</a><span>|</span><label class="collapse" for="c-41421335">[-]</label><label class="expand" for="c-41421335">[4 more]</label></div><br/><div class="children"><div class="content">&gt; except Macbooks I guess???<p>My M1 MacBook takes an order of magnitude longer to start than my Windows Desktop PC. Once it&#x27;s started up, leaving it on re-logging in takes no time but rebooting takes a while.</div><br/><div id="41421737" class="c"><input type="checkbox" id="c-41421737" checked=""/><div class="controls bullet"><span class="by">Pesthuf</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41421335">parent</a><span>|</span><a href="#41421343">next</a><span>|</span><label class="collapse" for="c-41421737">[-]</label><label class="expand" for="c-41421737">[1 more]</label></div><br/><div class="children"><div class="content">It really is a shame. When Mac OS X first implemented launchd, its boot times improved drastically. It booted really fast even when computers still using hdds. So when Macs got SSDs, they booted incredibly quickly.<p>But then, with some macOS update, they screwed it up and never bothered to fix it. Imagine how fast those things could boot with their super fast drives and SOCs if someone fixed this regression…</div><br/></div></div><div id="41421343" class="c"><input type="checkbox" id="c-41421343" checked=""/><div class="controls bullet"><span class="by">rafram</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41421335">parent</a><span>|</span><a href="#41421737">prev</a><span>|</span><a href="#41421506">next</a><span>|</span><label class="collapse" for="c-41421343">[-]</label><label class="expand" for="c-41421343">[2 more]</label></div><br/><div class="children"><div class="content">There’s something wrong with your M1 MacBook. I’ve used three and none of them has taken longer than 20-30 seconds from power button to desktop.</div><br/><div id="41421358" class="c"><input type="checkbox" id="c-41421358" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41421343">parent</a><span>|</span><a href="#41421506">next</a><span>|</span><label class="collapse" for="c-41421358">[-]</label><label class="expand" for="c-41421358">[1 more]</label></div><br/><div class="children"><div class="content">20-30 seconds is much longer than the ~6 seconds for my Windows PC.<p>Old article but:<p><a href="https:&#x2F;&#x2F;www.tomshardware.com&#x2F;reviews&#x2F;fastest-windows-10-boot-time,5810.html" rel="nofollow">https:&#x2F;&#x2F;www.tomshardware.com&#x2F;reviews&#x2F;fastest-windows-10-boot...</a></div><br/></div></div></div></div></div></div><div id="41421506" class="c"><input type="checkbox" id="c-41421506" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#41420807">parent</a><span>|</span><a href="#41421335">prev</a><span>|</span><a href="#41421322">next</a><span>|</span><label class="collapse" for="c-41421506">[-]</label><label class="expand" for="c-41421506">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confused by this statement. For me Linux boot is incredibly fast, even on old machines with slow storage. For example, my MacBook Air 11 (running Linux) boots to login so fast I barely see any boot logs. systemd-analyze reports the graphical target is reached in &lt; 4 s.<p>Two things seem to be key here. I don&#x27;t use a desktop environment. I either boot in text mode (and then startx as needed), or I boot to X with a lightweight login manager (lightdm). The important bit is that no DE reduces the number of services by an order of magnitude, which put a lot of I&#x2F;O pressure during boot on old hardware. The booted system is less than 200 MB, even when running X. The second thing that can speed things up is EFI stub: <a href="https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;EFISTUB" rel="nofollow">https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;EFISTUB</a>.</div><br/><div id="41423450" class="c"><input type="checkbox" id="c-41423450" checked=""/><div class="controls bullet"><span class="by">Avamander</span><span>|</span><a href="#41420807">root</a><span>|</span><a href="#41421506">parent</a><span>|</span><a href="#41421322">next</a><span>|</span><label class="collapse" for="c-41423450">[-]</label><label class="expand" for="c-41423450">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Two things seem to be key here. I don&#x27;t use a desktop environment. I either boot in text mode (and then startx as needed), or I boot to X with a lightweight login manager (lightdm).<p>&gt; I&#x27;m confused by this statement.<p>Should you be confused?</div><br/></div></div></div></div></div></div><div id="41421322" class="c"><input type="checkbox" id="c-41421322" checked=""/><div class="controls bullet"><span class="by">markus_zhang</span><span>|</span><a href="#41420807">prev</a><span>|</span><a href="#41420900">next</a><span>|</span><label class="collapse" for="c-41421322">[-]</label><label class="expand" for="c-41421322">[7 more]</label></div><br/><div class="children"><div class="content">My first instinct: can we use some other core? Do we really need Linux to take a photo and transfer it to the cloud?<p>I&#x27;m not a hw person so curious how to complete the task with minimum budget.<p>Interesting read. Thank you!</div><br/><div id="41421568" class="c"><input type="checkbox" id="c-41421568" checked=""/><div class="controls bullet"><span class="by">bigiain</span><span>|</span><a href="#41421322">parent</a><span>|</span><a href="#41421796">next</a><span>|</span><label class="collapse" for="c-41421568">[-]</label><label class="expand" for="c-41421568">[1 more]</label></div><br/><div class="children"><div class="content">My same first thought.<p>For no reason other than I have a pair of them sitting on my kitchen table right now, I wondered how the ESP32-CAM setup would compare. I think it&#x27;s only good for 2megapixel images, But I&#x27;d bet both its startup time and its power consumption would be close to an order of magnitude lower. (Here&#x27;s some details if you&#x27;re curious: <a href="https:&#x2F;&#x2F;components101.com&#x2F;modules&#x2F;esp32-cam-camera-module" rel="nofollow">https:&#x2F;&#x2F;components101.com&#x2F;modules&#x2F;esp32-cam-camera-module</a> )</div><br/></div></div><div id="41421796" class="c"><input type="checkbox" id="c-41421796" checked=""/><div class="controls bullet"><span class="by">grishka</span><span>|</span><a href="#41421322">parent</a><span>|</span><a href="#41421568">prev</a><span>|</span><a href="#41420900">next</a><span>|</span><label class="collapse" for="c-41421796">[-]</label><label class="expand" for="c-41421796">[5 more]</label></div><br/><div class="children"><div class="content">The problem is that this particular project uses camera and wireless networking, both requiring very non-trivial drivers. It is possible, in principle, to do it on bare metal, but getting the required peripherals working won&#x27;t be easy.</div><br/><div id="41421849" class="c"><input type="checkbox" id="c-41421849" checked=""/><div class="controls bullet"><span class="by">hypercube33</span><span>|</span><a href="#41421322">root</a><span>|</span><a href="#41421796">parent</a><span>|</span><a href="#41420900">next</a><span>|</span><label class="collapse" for="c-41421849">[-]</label><label class="expand" for="c-41421849">[4 more]</label></div><br/><div class="children"><div class="content">ESP is a platform that has both though - wireless and camera on the esp32. Those can quick resume out of a low power sleep and connect to Wi-Fi and dump a picture or a series of pictures - I don&#x27;t know what&#x27;s more efficient.</div><br/><div id="41422676" class="c"><input type="checkbox" id="c-41422676" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41421322">root</a><span>|</span><a href="#41421849">parent</a><span>|</span><a href="#41422422">next</a><span>|</span><label class="collapse" for="c-41422676">[-]</label><label class="expand" for="c-41422676">[2 more]</label></div><br/><div class="children"><div class="content">Are you talking about the 2MP ESP32-CAM modules? Those things are an order of magnitude worse when it comes to fps and perceptual image quality vs Arducam&#x27;s offerings for the RPi. Also all sorts of specialized hardware like depth sensing cameras work out of the box with the RPi.<p>ESP32 can do both wifi and cameras in the same sense that I can run back to back marathons. I just gotta take a couple of naps at hotels along the way.</div><br/><div id="41423326" class="c"><input type="checkbox" id="c-41423326" checked=""/><div class="controls bullet"><span class="by">m00x</span><span>|</span><a href="#41421322">root</a><span>|</span><a href="#41422676">parent</a><span>|</span><a href="#41422422">next</a><span>|</span><label class="collapse" for="c-41423326">[-]</label><label class="expand" for="c-41423326">[1 more]</label></div><br/><div class="children"><div class="content">You can connect the esp32 to a proper camera, you don&#x27;t just have to use the development board for it.<p>If you&#x27;re just taking a picture and uploading it via wifi, you&#x27;re better off doing it bare metal. It can do everything stated in OP&#x27;s post. MIPI support isn&#x27;t available until ESP-P4 though.</div><br/></div></div></div></div><div id="41422422" class="c"><input type="checkbox" id="c-41422422" checked=""/><div class="controls bullet"><span class="by">kfarr</span><span>|</span><a href="#41421322">root</a><span>|</span><a href="#41421849">parent</a><span>|</span><a href="#41422676">prev</a><span>|</span><a href="#41420900">next</a><span>|</span><label class="collapse" for="c-41422422">[-]</label><label class="expand" for="c-41422422">[1 more]</label></div><br/><div class="children"><div class="content">Or Pi Pico W, I&#x27;ve used that on a few projects. Nearly instant boot</div><br/></div></div></div></div></div></div></div></div><div id="41420900" class="c"><input type="checkbox" id="c-41420900" checked=""/><div class="controls bullet"><span class="by">jtrueb</span><span>|</span><a href="#41421322">prev</a><span>|</span><a href="#41423517">next</a><span>|</span><label class="collapse" for="c-41420900">[-]</label><label class="expand" for="c-41420900">[5 more]</label></div><br/><div class="children"><div class="content">Just stay booted and use a lower power microcontroller … 105mA … that’s not the right order of magnitude</div><br/><div id="41422451" class="c"><input type="checkbox" id="c-41422451" checked=""/><div class="controls bullet"><span class="by">declan_roberts</span><span>|</span><a href="#41420900">parent</a><span>|</span><a href="#41421744">next</a><span>|</span><label class="collapse" for="c-41422451">[-]</label><label class="expand" for="c-41422451">[1 more]</label></div><br/><div class="children"><div class="content">Every single person is reading this with a voice in their head asking &quot;why not use an esp32 et al?&quot;<p>But of course the article is good enough because it&#x27;s interesting, even if it&#x27;s not the right tool for the job.</div><br/></div></div><div id="41421744" class="c"><input type="checkbox" id="c-41421744" checked=""/><div class="controls bullet"><span class="by">award_</span><span>|</span><a href="#41420900">parent</a><span>|</span><a href="#41422451">prev</a><span>|</span><a href="#41423517">next</a><span>|</span><label class="collapse" for="c-41421744">[-]</label><label class="expand" for="c-41421744">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand what this means exactly, could you please elaborate?</div><br/><div id="41422088" class="c"><input type="checkbox" id="c-41422088" checked=""/><div class="controls bullet"><span class="by">jtrueb</span><span>|</span><a href="#41420900">root</a><span>|</span><a href="#41421744">parent</a><span>|</span><a href="#41423517">next</a><span>|</span><label class="collapse" for="c-41422088">[-]</label><label class="expand" for="c-41422088">[2 more]</label></div><br/><div class="children"><div class="content">I’m sure there are others, but as mentioned elsewhere in this thread ESP32 or NRF70 could take care of this for a lot less (off of bare metal or RTOS if you just need WiFi and Camera.)</div><br/><div id="41423336" class="c"><input type="checkbox" id="c-41423336" checked=""/><div class="controls bullet"><span class="by">m00x</span><span>|</span><a href="#41420900">root</a><span>|</span><a href="#41422088">parent</a><span>|</span><a href="#41423517">next</a><span>|</span><label class="collapse" for="c-41423336">[-]</label><label class="expand" for="c-41423336">[1 more]</label></div><br/><div class="children"><div class="content">A good reason would be the lack of support for MIPI for the camera.</div><br/></div></div></div></div></div></div></div></div><div id="41423517" class="c"><input type="checkbox" id="c-41423517" checked=""/><div class="controls bullet"><span class="by">sydd</span><span>|</span><a href="#41420900">prev</a><span>|</span><a href="#41422433">next</a><span>|</span><label class="collapse" for="c-41423517">[-]</label><label class="expand" for="c-41423517">[1 more]</label></div><br/><div class="children"><div class="content">Ehm instead of spending like weeks on this why not use a hardware that is meant for such applications like an ESP32?</div><br/></div></div><div id="41422433" class="c"><input type="checkbox" id="c-41422433" checked=""/><div class="controls bullet"><span class="by">kfarr</span><span>|</span><a href="#41423517">prev</a><span>|</span><a href="#41422840">next</a><span>|</span><label class="collapse" for="c-41422433">[-]</label><label class="expand" for="c-41422433">[1 more]</label></div><br/><div class="children"><div class="content">If you like Rasp Pi ecosystem you might want to try the Pi Pico W, it&#x27;s similar in spirit to microcontrollers like ESP32 but allows you to use micropython and has a neat set of peripherals that work &quot;out of the box&quot;:
<a href="https:&#x2F;&#x2F;shop.pimoroni.com&#x2F;products&#x2F;raspberry-pi-pico-w?variant=40059369619539" rel="nofollow">https:&#x2F;&#x2F;shop.pimoroni.com&#x2F;products&#x2F;raspberry-pi-pico-w?varia...</a></div><br/></div></div><div id="41422840" class="c"><input type="checkbox" id="c-41422840" checked=""/><div class="controls bullet"><span class="by">stereo</span><span>|</span><a href="#41422433">prev</a><span>|</span><a href="#41420797">next</a><span>|</span><label class="collapse" for="c-41422840">[-]</label><label class="expand" for="c-41422840">[1 more]</label></div><br/><div class="children"><div class="content">Is the Pi connected to the network with a static IP? Getting a fresh one from DHCP can, in this context, take quite a bit of time and energy.</div><br/></div></div><div id="41420797" class="c"><input type="checkbox" id="c-41420797" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#41422840">prev</a><span>|</span><a href="#41420754">next</a><span>|</span><label class="collapse" for="c-41420797">[-]</label><label class="expand" for="c-41420797">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking that Circle (<a href="https:&#x2F;&#x2F;github.com&#x2F;rsta2&#x2F;circle">https:&#x2F;&#x2F;github.com&#x2F;rsta2&#x2F;circle</a>) might be faster to boot than a kernel, but it doesn&#x27;t seem to support MIPI cameras.</div><br/></div></div><div id="41420754" class="c"><input type="checkbox" id="c-41420754" checked=""/><div class="controls bullet"><span class="by">abraae</span><span>|</span><a href="#41420797">prev</a><span>|</span><a href="#41420800">next</a><span>|</span><label class="collapse" for="c-41420754">[-]</label><label class="expand" for="c-41420754">[1 more]</label></div><br/><div class="children"><div class="content">Very impressive. I&#x27;ve toyed with using the Pi for an intelligent trail camera. Startup time is critical - a PIR sensor detects an animal passing and you want to be taking photos ASAP so every second counts.<p>Lowering the power usage is awesome too.</div><br/></div></div><div id="41420800" class="c"><input type="checkbox" id="c-41420800" checked=""/><div class="controls bullet"><span class="by">ocean_moist</span><span>|</span><a href="#41420754">prev</a><span>|</span><a href="#41421243">next</a><span>|</span><label class="collapse" for="c-41420800">[-]</label><label class="expand" for="c-41420800">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if booting the OpenBSD kernel would be faster. Although, the OpenBSD init system is notoriously slow.<p>Also I feel (but don&#x27;t know for sure) most of the time before executing the user space program would be spent by systemd.</div><br/><div id="41420828" class="c"><input type="checkbox" id="c-41420828" checked=""/><div class="controls bullet"><span class="by">jmclnx</span><span>|</span><a href="#41420800">parent</a><span>|</span><a href="#41421384">next</a><span>|</span><label class="collapse" for="c-41420828">[-]</label><label class="expand" for="c-41420828">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Although, the OpenBSD init system is notoriously slow.<p>Is this on the PI where it is slow.  On my T420 it seems fine, but the re-linking of various daemons does add time.  But that is done for security so I am fine to live with it.<p>Me, I want fast power down time so I can get out the door fast.  And so far NetBSD, OpenBSD and Linux seems to meets that need :)</div><br/></div></div><div id="41421384" class="c"><input type="checkbox" id="c-41421384" checked=""/><div class="controls bullet"><span class="by">hamburglar</span><span>|</span><a href="#41420800">parent</a><span>|</span><a href="#41420828">prev</a><span>|</span><a href="#41421243">next</a><span>|</span><label class="collapse" for="c-41421384">[-]</label><label class="expand" for="c-41421384">[1 more]</label></div><br/><div class="children"><div class="content">Don’t these types of systems generally just nuke init entirely and provide a custom PID 1 ?</div><br/></div></div></div></div><div id="41421243" class="c"><input type="checkbox" id="c-41421243" checked=""/><div class="controls bullet"><span class="by">geerlingguy</span><span>|</span><a href="#41420800">prev</a><span>|</span><a href="#41421706">next</a><span>|</span><label class="collapse" for="c-41421243">[-]</label><label class="expand" for="c-41421243">[1 more]</label></div><br/><div class="children"><div class="content"><i>Supposedly</i> on the Pi 5, the SoC could be put to sleep while RP1 remains active, and the RP1 has enough compute to handle like 4 or 8 pixels of data from an attached camera... I think RPi might be able to get much better suspend support with their new PMIC and RP1. But so far still waiting to see something handy like Wake on LAN support native in Pi OS.</div><br/></div></div><div id="41421706" class="c"><input type="checkbox" id="c-41421706" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#41421243">prev</a><span>|</span><a href="#41421661">next</a><span>|</span><label class="collapse" for="c-41421706">[-]</label><label class="expand" for="c-41421706">[1 more]</label></div><br/><div class="children"><div class="content">Assuming it stays up for about 10-15s this is a saving over staying idle of around 85%, based on the idle burn rate from toms hardware. Not bad at all!</div><br/></div></div><div id="41420772" class="c"><input type="checkbox" id="c-41420772" checked=""/><div class="controls bullet"><span class="by">gigel82</span><span>|</span><a href="#41421661">prev</a><span>|</span><a href="#41421008">next</a><span>|</span><label class="collapse" for="c-41420772">[-]</label><label class="expand" for="c-41420772">[7 more]</label></div><br/><div class="children"><div class="content">3.5s is cool, but if the entire scenario was really connecting to WiFi and uploading an image every couple of minutes, an ESP32 would&#x27;ve been a much better choice for power consumption (unless the camera module you need for Pi has some specific features that none of the esp32-cam compatible cameras does)</div><br/><div id="41421089" class="c"><input type="checkbox" id="c-41421089" checked=""/><div class="controls bullet"><span class="by">teamonkey</span><span>|</span><a href="#41420772">parent</a><span>|</span><a href="#41421512">next</a><span>|</span><label class="collapse" for="c-41421089">[-]</label><label class="expand" for="c-41421089">[5 more]</label></div><br/><div class="children"><div class="content">ESP32 only supports up to 4MB of PSRAM while a single RPi HQ Camera still is 18MB.</div><br/><div id="41421113" class="c"><input type="checkbox" id="c-41421113" checked=""/><div class="controls bullet"><span class="by">pitaj</span><span>|</span><a href="#41420772">root</a><span>|</span><a href="#41421089">parent</a><span>|</span><a href="#41421512">next</a><span>|</span><label class="collapse" for="c-41421113">[-]</label><label class="expand" for="c-41421113">[4 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t the camera have it&#x27;s own framebuffer that the MCU can stream? I don&#x27;t see why the MCU would have to hold the whole frame in memory.</div><br/><div id="41422227" class="c"><input type="checkbox" id="c-41422227" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#41420772">root</a><span>|</span><a href="#41421113">parent</a><span>|</span><a href="#41421267">next</a><span>|</span><label class="collapse" for="c-41422227">[-]</label><label class="expand" for="c-41422227">[1 more]</label></div><br/><div class="children"><div class="content">The library comes with ESP32 use DMA for image stream. 
Don&#x27;t think you can workaround that, unless you write your own driver</div><br/></div></div><div id="41421267" class="c"><input type="checkbox" id="c-41421267" checked=""/><div class="controls bullet"><span class="by">teamonkey</span><span>|</span><a href="#41420772">root</a><span>|</span><a href="#41421113">parent</a><span>|</span><a href="#41422227">prev</a><span>|</span><a href="#41421512">next</a><span>|</span><label class="collapse" for="c-41421267">[-]</label><label class="expand" for="c-41421267">[2 more]</label></div><br/><div class="children"><div class="content">At least with ESP32-CAM api, the instruction to capture an image returns a pointer to image data in psram.<p>I would imagine a Pi Zero is more efficient at converting that raw image data to some compressed file format too.</div><br/><div id="41423359" class="c"><input type="checkbox" id="c-41423359" checked=""/><div class="controls bullet"><span class="by">m00x</span><span>|</span><a href="#41420772">root</a><span>|</span><a href="#41421267">parent</a><span>|</span><a href="#41421512">next</a><span>|</span><label class="collapse" for="c-41423359">[-]</label><label class="expand" for="c-41423359">[1 more]</label></div><br/><div class="children"><div class="content">ESP23-P4 will support up to 32mb in PSRAM, MIPI, and hardware h.264 encoding. It&#x27;ll be a great chip for video.</div><br/></div></div></div></div></div></div></div></div><div id="41421512" class="c"><input type="checkbox" id="c-41421512" checked=""/><div class="controls bullet"><span class="by">Neywiny</span><span>|</span><a href="#41420772">parent</a><span>|</span><a href="#41421089">prev</a><span>|</span><a href="#41421008">next</a><span>|</span><label class="collapse" for="c-41421512">[-]</label><label class="expand" for="c-41421512">[1 more]</label></div><br/><div class="children"><div class="content">I might recommend a slightly higher end micro with a mipi csi interface but otherwise agree. This is so much work to do what microcontrollers can do almost effortlessly.</div><br/></div></div></div></div><div id="41421008" class="c"><input type="checkbox" id="c-41421008" checked=""/><div class="controls bullet"><span class="by">Sarkie</span><span>|</span><a href="#41420772">prev</a><span>|</span><a href="#41422745">next</a><span>|</span><label class="collapse" for="c-41421008">[-]</label><label class="expand" for="c-41421008">[2 more]</label></div><br/><div class="children"><div class="content">Was expecting to see different governors tested.<p>Is that not a thing on a pi?</div><br/><div id="41421332" class="c"><input type="checkbox" id="c-41421332" checked=""/><div class="controls bullet"><span class="by">kiwijamo</span><span>|</span><a href="#41421008">parent</a><span>|</span><a href="#41422745">next</a><span>|</span><label class="collapse" for="c-41421332">[-]</label><label class="expand" for="c-41421332">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m fairly sure this is, I recall playing with this when I first got my Raspi.</div><br/></div></div></div></div><div id="41422745" class="c"><input type="checkbox" id="c-41422745" checked=""/><div class="controls bullet"><span class="by">hcfman</span><span>|</span><a href="#41421008">prev</a><span>|</span><a href="#41421006">next</a><span>|</span><label class="collapse" for="c-41422745">[-]</label><label class="expand" for="c-41422745">[1 more]</label></div><br/><div class="children"><div class="content">Lovely project</div><br/></div></div><div id="41421006" class="c"><input type="checkbox" id="c-41421006" checked=""/><div class="controls bullet"><span class="by">phoronixrly</span><span>|</span><a href="#41422745">prev</a><span>|</span><label class="collapse" for="c-41421006">[-]</label><label class="expand" for="c-41421006">[4 more]</label></div><br/><div class="children"><div class="content">You really should look into using the right hardware for the purpose instead. (Disclamer - I despise Raspberry and their overpriced closed devices, and also HN maniacally trying to use them for stuff they the wrong choice for)</div><br/><div id="41421110" class="c"><input type="checkbox" id="c-41421110" checked=""/><div class="controls bullet"><span class="by">nbf_1995</span><span>|</span><a href="#41421006">parent</a><span>|</span><label class="collapse" for="c-41421110">[-]</label><label class="expand" for="c-41421110">[3 more]</label></div><br/><div class="children"><div class="content">What sort of hardware would you recommend for this use case?</div><br/><div id="41422052" class="c"><input type="checkbox" id="c-41422052" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#41421006">root</a><span>|</span><a href="#41421110">parent</a><span>|</span><label class="collapse" for="c-41422052">[-]</label><label class="expand" for="c-41422052">[2 more]</label></div><br/><div class="children"><div class="content">Literally any ESP32 would be better suited. There is zero reason to be booting an entire OS to take a picture and blip it over WiFi.</div><br/><div id="41423135" class="c"><input type="checkbox" id="c-41423135" checked=""/><div class="controls bullet"><span class="by">moefh</span><span>|</span><a href="#41421006">root</a><span>|</span><a href="#41422052">parent</a><span>|</span><label class="collapse" for="c-41423135">[-]</label><label class="expand" for="c-41423135">[1 more]</label></div><br/><div class="children"><div class="content">ESP32 is great, but it simply can&#x27;t work with the IMX477 camera used in this project. This camera has resolution of 4072x3176, or about 12M pixels, which is way above what any ESP32 can handle.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>