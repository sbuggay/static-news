<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715072455713" as="style"/><link rel="stylesheet" href="styles.css?v=1715072455713"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lannonbr.com/blog/2020-01-27-shift-optimizations/">Array.shift Optimizations in Firefox&#x27;s JavaScript Engine (2020)</a> <span class="domain">(<a href="https://lannonbr.com">lannonbr.com</a>)</span></div><div class="subtext"><span>melvinroest</span> | <span>11 comments</span></div><br/><div><div id="40283372" class="c"><input type="checkbox" id="c-40283372" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40283253">next</a><span>|</span><label class="collapse" for="c-40283372">[-]</label><label class="expand" for="c-40283372">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it should be able to run on any JS runtime with comparable performance<p>How long until every app ships their own wasm js runtime to ensure consistent performance characteristics?</div><br/></div></div><div id="40283253" class="c"><input type="checkbox" id="c-40283253" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40283372">prev</a><span>|</span><a href="#40283219">next</a><span>|</span><label class="collapse" for="c-40283253">[-]</label><label class="expand" for="c-40283253">[2 more]</label></div><br/><div class="children"><div class="content">It is important that such optimization will keep the array&#x27;s full capacity when naively implemented. For example, calling `Array.shift` 999,000 times to an array with 1,000,000 elements will reduce it to 1,000 elements but its capacity will be at least 1,000 times that. A reasonable implementation would shrink the capacity when some threshold is reached [1].<p>[1] This threshold should be much lower than the growth threshold in order to prevent an unnecessary copying when the number of elements is around the threshold.</div><br/><div id="40283587" class="c"><input type="checkbox" id="c-40283587" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#40283253">parent</a><span>|</span><a href="#40283219">next</a><span>|</span><label class="collapse" for="c-40283587">[-]</label><label class="expand" for="c-40283587">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s so clear-cut that the capacity should be decreased in that case, because it not only destroys the theoretical complexity of algorithms using it, but also because in practice there can be cases where an array gets increased to 1000000 elements, then it gets consumed to 0 elements, after which it again is increased to 1000000 elements for the next round of operations. Converting the array to be backed by a smaller allocation is not free.<p>Indeed, which case is even more common: large arrays getting smaller and then kept that way, or large arrays getting smaller to grow again later?<p>I suppose some more complicated metric (e.g. keeping track of reallocations per array) could help with the most common cases.</div><br/></div></div></div></div><div id="40283219" class="c"><input type="checkbox" id="c-40283219" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#40283253">prev</a><span>|</span><a href="#40269916">next</a><span>|</span><label class="collapse" for="c-40283219">[-]</label><label class="expand" for="c-40283219">[1 more]</label></div><br/><div class="children"><div class="content">Some other languages also perform this optimization, for example Ruby and Crystal.</div><br/></div></div><div id="40269916" class="c"><input type="checkbox" id="c-40269916" checked=""/><div class="controls bullet"><span class="by">melvinroest</span><span>|</span><a href="#40283219">prev</a><span>|</span><label class="collapse" for="c-40269916">[-]</label><label class="expand" for="c-40269916">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised to read that for less than 50K elements it&#x27;s likely to be O(1). It&#x27;s a clever trick to just move the memory address one element further :)</div><br/><div id="40283191" class="c"><input type="checkbox" id="c-40283191" checked=""/><div class="controls bullet"><span class="by">matharmin</span><span>|</span><a href="#40269916">parent</a><span>|</span><a href="#40276561">next</a><span>|</span><label class="collapse" for="c-40283191">[-]</label><label class="expand" for="c-40283191">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually not exactly 50K, and likely varies across Chrome&#x2F;V8 versions, operating system and&#x2F;or machine architecture. On my browser the threshold is around 22500 elements. For a quick test, see [1].<p>The difference in V8 appears to be based on whether or not the array is stored in &quot;large object space&quot; [2], which seems to be used when the object is somewhere between 64kb and 128kb [3] (once again can depend on lots of factors). I wonder how many other optimizations depend on that?<p>[1]: <a href="http:&#x2F;&#x2F;www.lonniebest.com&#x2F;BadShiftPerformance&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.lonniebest.com&#x2F;BadShiftPerformance&#x2F;</a>
[2]: <a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;42202676" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;42202676</a>
[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;danbev&#x2F;learning-v8&#x2F;blob&#x2F;master&#x2F;notes&#x2F;heap.md#pagesize-in-v8">https:&#x2F;&#x2F;github.com&#x2F;danbev&#x2F;learning-v8&#x2F;blob&#x2F;master&#x2F;notes&#x2F;heap...</a></div><br/></div></div><div id="40276561" class="c"><input type="checkbox" id="c-40276561" checked=""/><div class="controls bullet"><span class="by">melvinroest</span><span>|</span><a href="#40269916">parent</a><span>|</span><a href="#40283191">prev</a><span>|</span><label class="collapse" for="c-40276561">[-]</label><label class="expand" for="c-40276561">[4 more]</label></div><br/><div class="children"><div class="content">Some more technical info that browsers nowadays have O(1) behavior when using Array.shift() [1].<p>[1] <a href="https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1348772" rel="nofollow">https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1348772</a></div><br/><div id="40282831" class="c"><input type="checkbox" id="c-40282831" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#40269916">root</a><span>|</span><a href="#40276561">parent</a><span>|</span><label class="collapse" for="c-40282831">[-]</label><label class="expand" for="c-40282831">[3 more]</label></div><br/><div class="children"><div class="content">Disclaimer: when I worked on Internet Explorer in its twilight years I built a fork of BingBot that surveyed JS API usage and delivered a report to a Partner-level SE, whom I was in awe of, that I shared a team-room with.<p>In my experience, Array.prototype.shift() had limited applications because it mutates the source-array. I gathered it exists because at the time it was specc’d in the late 1990s the other cool kids, bash and perl, both had had args shift and JS didn’t want to feel left-out.<p>How different would the world be today if Array.prototype.shift instead froze the array and returned a reference to a +1 slice of the array instead? There was a fantastic opportunity to introduce FP and immutability to a whole generation of software people - which we (as an industry) squandered to our detriment. Ultra-new languages like Go and Zig still default to in-place mutable data and it’s maddening!<p>What hath shell scripts wrought?</div><br/><div id="40282867" class="c"><input type="checkbox" id="c-40282867" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40269916">root</a><span>|</span><a href="#40282831">parent</a><span>|</span><a href="#40283306">next</a><span>|</span><label class="collapse" for="c-40282867">[-]</label><label class="expand" for="c-40282867">[1 more]</label></div><br/><div class="children"><div class="content">Do you think Array.prototype.push() also has limited applications? It too mutates the source array, but must be the most commonly used Array method there is. And the two combined make for a lovely FIFO.<p>Anyone is certainly free to use Array.prototype.slice() if they want a view.</div><br/></div></div><div id="40283306" class="c"><input type="checkbox" id="c-40283306" checked=""/><div class="controls bullet"><span class="by">pipe01</span><span>|</span><a href="#40269916">root</a><span>|</span><a href="#40282831">parent</a><span>|</span><a href="#40282867">prev</a><span>|</span><label class="collapse" for="c-40283306">[-]</label><label class="expand" for="c-40283306">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t say go is exactly ultra new</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>