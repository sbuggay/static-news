<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692003665494" as="style"/><link rel="stylesheet" href="styles.css?v=1692003665494"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rcrowley.org/2010/01/06/things-unix-can-do-atomically.html">Things Unix can do atomically (2010)</a> <span class="domain">(<a href="https://rcrowley.org">rcrowley.org</a>)</span></div><div class="subtext"><span>pabs3</span> | <span>18 comments</span></div><br/><div><div id="37118024" class="c"><input type="checkbox" id="c-37118024" checked=""/><div class="controls bullet"><span class="by">mbid</span><span>|</span><a href="#37117623">next</a><span>|</span><label class="collapse" for="c-37118024">[-]</label><label class="expand" for="c-37118024">[5 more]</label></div><br/><div class="children"><div class="content">The rename system call is not quite atomic. From <a href="https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;2&#x2F;rename" rel="nofollow noreferrer">https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;2&#x2F;rename</a>:<p>&gt; <i>However, when overwriting there will probably be a window in which both oldpath and newpath refer to the file being renamed.</i><p>A better way to think about rename is that it&#x27;s given by two atomic operations in sequence: (1) An atomic link call to make the file available under the new name, and then
(2) an atomic remove operation to delete the old name. Thus, it&#x27;s possible to observe the state after (1) but before (2).</div><br/><div id="37118505" class="c"><input type="checkbox" id="c-37118505" checked=""/><div class="controls bullet"><span class="by">jakewins</span><span>|</span><a href="#37118024">parent</a><span>|</span><a href="#37118085">next</a><span>|</span><label class="collapse" for="c-37118505">[-]</label><label class="expand" for="c-37118505">[2 more]</label></div><br/><div class="children"><div class="content">Dan Luu also says rename is not atomic, at the bottom of this post: <a href="https:&#x2F;&#x2F;danluu.com&#x2F;file-consistency&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;danluu.com&#x2F;file-consistency&#x2F;</a><p>I&#x27;ve wondered ever since I read that what the first bullet there means. It can&#x27;t be what you&#x27;re saying here, what you&#x27;re saying would apply to racing processes as well as crashes?<p>So then.. what does he <i>mean</i> when he says rename isn&#x27;t atomic if there&#x27;s a crash? What&#x27;s the failure condition &#x2F; in-between state that can occur if there&#x27;s a crash?</div><br/><div id="37118733" class="c"><input type="checkbox" id="c-37118733" checked=""/><div class="controls bullet"><span class="by">mbid</span><span>|</span><a href="#37118024">root</a><span>|</span><a href="#37118505">parent</a><span>|</span><a href="#37118085">next</a><span>|</span><label class="collapse" for="c-37118733">[-]</label><label class="expand" for="c-37118733">[1 more]</label></div><br/><div class="children"><div class="content">&gt;what does he mean when he says rename isn&#x27;t atomic if there&#x27;s a crash?<p>Not sure. One of the papers he cites [1] has this to say about rename atomicity:<p>&gt;<i>Directory operations such as rename() and link() are seemingly atomic on all file systems that use techniques like journaling or copy-on-write for consistency</i><p>So it seems to depend on the file system. But the authors claim that not just link but also rename is atomic without qualification, which appears to be false, so I&#x27;m not sure how trustworthy this is.<p>There&#x27;s a stackoverflow comment [2] that suggests that ext4 guarantees the kind of sequential atomicity property (atomic link followed by atomic remove) I mentioned:<p>&gt;<i>Kernel implementation depends on filesystem but here&#x27;s implementation of Linux ext4 filesystem: elixir.bootlin.com&#x2F;linux&#x2F;v5.19.3&#x2F;source&#x2F;fs&#x2F;ext4&#x2F;namei.c#L3887 – it seems to first mark the inode as dirty, then create new link and after that delete the old link. If the kernel crashes in the middle, the end result could be two links and dirty mark. I would guess (but didn&#x27;t investigate if this true) that journal recovery during the next mount would fix the end result to match atomic behavior of leaving either the old or new state depending on exact crash location.</i><p>In general, I find it rather weird how little authoritative documentation there is about whether or not this property holds given how important it is.<p>[1] <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;osdi14&#x2F;osdi14-paper-pillai.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;osdi14&#x2F;osdi14...</a><p>[2] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7054844&#x2F;is-rename-atomic#comment129720402_7054851" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7054844&#x2F;is-rename-atomic...</a></div><br/></div></div></div></div><div id="37118406" class="c"><input type="checkbox" id="c-37118406" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37118024">parent</a><span>|</span><a href="#37118085">prev</a><span>|</span><a href="#37117623">next</a><span>|</span><label class="collapse" for="c-37118406">[-]</label><label class="expand" for="c-37118406">[1 more]</label></div><br/><div class="children"><div class="content">the type of atomicity I&#x27;ve always seen it used for is, two processes try to rename a file at the same time, only one will succeed; the winner does what they planned and then rename the file back.<p>I guess you shouldn&#x27;t ignore the error with both processes using the same destination name, why folks generally tend to put their pid in the lockfilename</div><br/></div></div></div></div><div id="37117623" class="c"><input type="checkbox" id="c-37117623" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37118024">prev</a><span>|</span><a href="#37118701">next</a><span>|</span><label class="collapse" for="c-37117623">[-]</label><label class="expand" for="c-37117623">[4 more]</label></div><br/><div class="children"><div class="content">The author intends the list to be read as &#x27;rights&#x27; or &#x27;entitlements&#x27; of user land code:<p>&gt; The philosophy here is to let the kernel do as much work as possible.  At my most pessimistic, I trust the kernel developers more than a trust myself.  More practically, it’s stupid to spend CPU time locking around an operation that’s already atomic.<p>From a system&#x27;s point of view, this list is also a list of demands on file system design.  And you can tell that POSIX was invented before distributed computing really was a thing.<p>Some of the POSIX demands are really quite costly to satisfy in a distributed, networked filesystem, and often unnecessarily degrade performance.</div><br/><div id="37118225" class="c"><input type="checkbox" id="c-37118225" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#37117623">parent</a><span>|</span><a href="#37118701">next</a><span>|</span><label class="collapse" for="c-37118225">[-]</label><label class="expand" for="c-37118225">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s impossible to reliably satisfy anything in a distributed networked anything. There aren&#x27;t costs as much as tradeoffs. Reliable, fast, accurate: pick one.</div><br/><div id="37118463" class="c"><input type="checkbox" id="c-37118463" checked=""/><div class="controls bullet"><span class="by">bmer</span><span>|</span><a href="#37117623">root</a><span>|</span><a href="#37118225">parent</a><span>|</span><a href="#37118532">next</a><span>|</span><label class="collapse" for="c-37118463">[-]</label><label class="expand" for="c-37118463">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the difference between &quot;reliable&quot; and &quot;accurate&quot;?<p>In any case, I have seen enough of these &quot;A, B, C : pick N&quot; (where 0 &lt; N &lt; 3) mantras shot down (usually by re-examining whether the constraints&#x2F;assumptions of the original mantra apply in a specific situation, or just through plain algorithmic engineering) that whenever someone drops something like this, I mostly tune it out.<p>In the case of distributed network &lt;anything&gt;, implementing programs in languages that help you manage important invariants automatically (and preferably not at run-time, but at compile-time) is key in creating robust systems that are both reliable, and fast.<p>But if you have such tools, and you are trying to also meet a set of standards that were designed without any care for distributed computing, then...yeah.</div><br/></div></div><div id="37118532" class="c"><input type="checkbox" id="c-37118532" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37117623">root</a><span>|</span><a href="#37118225">parent</a><span>|</span><a href="#37118463">prev</a><span>|</span><a href="#37118701">next</a><span>|</span><label class="collapse" for="c-37118532">[-]</label><label class="expand" for="c-37118532">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a trite observation that doesn&#x27;t actually _say_ anything.<p>But formulated in that language, my comment becomes: POSIX picks less than useful trade-offs for distributed file systems.<p>An extreme example: POSIX&#x27;s atime gives you something you seldom need, but imposes a huge burden.  That&#x27;s such a bad trade-off, that approximately no-one implements the original spec, even if nothing is distributed at all.</div><br/></div></div></div></div></div></div><div id="37118701" class="c"><input type="checkbox" id="c-37118701" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#37117623">prev</a><span>|</span><a href="#37118170">next</a><span>|</span><label class="collapse" for="c-37118701">[-]</label><label class="expand" for="c-37118701">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot wrong or at least weirdly described in the symlink entry.<p>&gt; <i>symlink(oldpath, newpath) operates very much like link(2) but creates a symbolic link at a new inode rather than a hard link to the same inode.</i><p>This is a really rough description.  What really happens with a hardlink is a new directory entry is created that points to the same inode; with a symlink a new inode is created of type symlink that points to a directory entry by path&#x2F;name.<p>&gt; <i>Symbolic links can point to directories, which hard links cannot, making them a perfect analogy to link(2) when locking entire directories. This will fail with the error code EEXIST if newpath already exists, making this a perfect analogy to link(2) that works for directories, too.</i><p>Except there&#x27;s no way to count the number of symlinks that point to a given path like there is with the link count of the inode with multiple hardlinks.<p>&gt; <i>Be careful of symbolic links whose target inode has been removed (&quot;dangling&quot; symbolic links) — open(2) will fail with the error code ENOENT.</i><p>As symlinks point to a path, a dandling symlink is the result of the target path being removed (or not existing), not removal of an inode. You can put something else at that path, and the symlink will take you there instead.  ENOENT is returned because the symlink doesn&#x27;t point to anything.<p>The lstat(2) call can be used to examine symlinks directly, normally file operations access the file through the symlink making it mildly challenging to distinguish between a regular file and symlink.<p>&gt; <i>It should be mentioned that inodes are a finite resource (this particular machine has 1,245,184 inodes).</i><p>This is unrelated information.  It is filesystem format dependent.</div><br/><div id="37118760" class="c"><input type="checkbox" id="c-37118760" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#37118701">parent</a><span>|</span><a href="#37118170">next</a><span>|</span><label class="collapse" for="c-37118760">[-]</label><label class="expand" for="c-37118760">[1 more]</label></div><br/><div class="children"><div class="content">There also is a limit to the number of hardlinks to an inode (filesystem dependent).</div><br/></div></div></div></div><div id="37118170" class="c"><input type="checkbox" id="c-37118170" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#37118701">prev</a><span>|</span><a href="#37118518">next</a><span>|</span><label class="collapse" for="c-37118170">[-]</label><label class="expand" for="c-37118170">[2 more]</label></div><br/><div class="children"><div class="content">The POSIX specification defers most semantics of rename to ISO C. It does mention atomicity, but only in the non-normative “Rationale” section, and also again only with reference to ISO C, so this is an aspirational rather than a strict requirement of POSIX.  On referral, however, it turns out that the C standard omits an explicit requirement for rename to be atomic. Consequently, rename is not definitively atomic in either POSIX or C.<p>I’m reminded that NFS was for a long time a popular storage for ISP mail but notoriously prone to non-atomic renames (or anything else, for that matter), and that is why many maildir implementations instead prefer an hard link followed by an unlink, via a tmp&#x2F; subdirectory on the same filesystem, during delivery and move&#x2F;copy operations.</div><br/><div id="37118250" class="c"><input type="checkbox" id="c-37118250" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#37118170">parent</a><span>|</span><a href="#37118518">next</a><span>|</span><label class="collapse" for="c-37118250">[-]</label><label class="expand" for="c-37118250">[1 more]</label></div><br/><div class="children"><div class="content">The faulty renames can be handled by looking for stale files and restoring or removing them. Once mail gets into the delivered directory, any duplicate link in a temporary directory gets deleted</div><br/></div></div></div></div><div id="37118518" class="c"><input type="checkbox" id="c-37118518" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#37118170">prev</a><span>|</span><a href="#37118259">next</a><span>|</span><label class="collapse" for="c-37118518">[-]</label><label class="expand" for="c-37118518">[1 more]</label></div><br/><div class="children"><div class="content">&gt; By making frequent use of msync(addr, length, MS_INVALIDATE), data written in this manner can be shared between processes that both map the same file.  mmap(2), msync(2).<p>MMAP_SHARED means that the same physical memory pages are available via different  virtual addresses. All the writes are visible immediately, at least in the same way as in the regular memory (you may still need mfence-es or a cache flush depending on CPU).<p>MS_INVALIDATE is essentially a no-op on Linux.</div><br/></div></div><div id="37118259" class="c"><input type="checkbox" id="c-37118259" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37118518">prev</a><span>|</span><a href="#37118586">next</a><span>|</span><label class="collapse" for="c-37118259">[-]</label><label class="expand" for="c-37118259">[2 more]</label></div><br/><div class="children"><div class="content">The way to deal with link() on NFS is to stat() the old file after and see if it has two links. That&#x27;s how you know you won.</div><br/><div id="37118593" class="c"><input type="checkbox" id="c-37118593" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#37118259">parent</a><span>|</span><a href="#37118586">next</a><span>|</span><label class="collapse" for="c-37118593">[-]</label><label class="expand" for="c-37118593">[1 more]</label></div><br/><div class="children"><div class="content">Indeed:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jaysoffian&#x2F;dotlock&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;jaysoffian&#x2F;dotlock&#x2F;</a><p>I think I first learned that trick from procmail and then confirmed it with the NFS spec? Been a long time...</div><br/></div></div></div></div><div id="37118586" class="c"><input type="checkbox" id="c-37118586" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#37118259">prev</a><span>|</span><label class="collapse" for="c-37118586">[-]</label><label class="expand" for="c-37118586">[1 more]</label></div><br/><div class="children"><div class="content">Really cool use of strace to peak under the covers of what the user land is doing. Very cool blog. Thanks to Pabs3 for posting it.</div><br/></div></div></div></div></div></div></div></body></html>