<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688374862775" as="style"/><link rel="stylesheet" href="styles.css?v=1688374862775"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://codegolf.stackexchange.com/questions/215216/high-throughput-fizz-buzz/236630#236630">55 GiB/s FizzBuzz (2021)</a> <span class="domain">(<a href="https://codegolf.stackexchange.com">codegolf.stackexchange.com</a>)</span></div><div class="subtext"><span>tentacleuno</span> | <span>83 comments</span></div><br/><div><div id="36570260" class="c"><input type="checkbox" id="c-36570260" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#36569111">next</a><span>|</span><label class="collapse" for="c-36570260">[-]</label><label class="expand" for="c-36570260">[4 more]</label></div><br/><div class="children"><div class="content">Meanwhile 99% of developers claim that writing desktop apps with Electron is perfectly fine, speed of the language and runtime doesn&#x27;t matter since you are going to wait for I&#x2F;O anyway and waiting a few seconds after launching an app to be able to use it, is perfectly fine even on most powerful hardware.<p>99% of managers claim that developers cost more than hardware, so it&#x27;s perfectly fine if the code is slow, they can just buy more hardware.</div><br/><div id="36570388" class="c"><input type="checkbox" id="c-36570388" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#36570260">parent</a><span>|</span><a href="#36570389">next</a><span>|</span><label class="collapse" for="c-36570388">[-]</label><label class="expand" for="c-36570388">[1 more]</label></div><br/><div class="children"><div class="content">These two viewpoints aren’t mutually exclusive. If they needed to develop fizzbuzz at 55GB&#x2F;s, they might conclude that electron won’t get them there.</div><br/></div></div><div id="36570389" class="c"><input type="checkbox" id="c-36570389" checked=""/><div class="controls bullet"><span class="by">wsve</span><span>|</span><a href="#36570260">parent</a><span>|</span><a href="#36570388">prev</a><span>|</span><a href="#36569111">next</a><span>|</span><label class="collapse" for="c-36570389">[-]</label><label class="expand" for="c-36570389">[2 more]</label></div><br/><div class="children"><div class="content">Is your point that we should prioritize app performance and spending more on larger teams of develops, over the ease of quickly writing apps in popular frameworks that work on any system and the web?<p>If so, that&#x27;s missing half the picture. &quot;People don&#x27;t care about performance&quot; isn&#x27;t why devs gravitate towards Electron. Devs and managers gravitate towards Electron because it means they don&#x27;t have to hire extra people and do more work to get their native apps working on whatever operating systems they ship to <i>and</i> rewrite the whole app for the web. Yeah, it&#x27;d be nice not to have the performance penalty, but some teams have accurately calculated that the performance loss the customer realistically notices is worth the benefits of writing and maintaining the app.</div><br/><div id="36570464" class="c"><input type="checkbox" id="c-36570464" checked=""/><div class="controls bullet"><span class="by">hk1337</span><span>|</span><a href="#36570260">root</a><span>|</span><a href="#36570389">parent</a><span>|</span><a href="#36569111">next</a><span>|</span><label class="collapse" for="c-36570464">[-]</label><label class="expand" for="c-36570464">[1 more]</label></div><br/><div class="children"><div class="content">I feel like a lot of devs take things like YAGNI and “move fast and break” things a bit too seriously and to great extreme.<p>They’re too willing to accept an adequate solution because it “works” rather than spending just a little bit more time to find a more appropriate solution.</div><br/></div></div></div></div></div></div><div id="36569111" class="c"><input type="checkbox" id="c-36569111" checked=""/><div class="controls bullet"><span class="by">Noumenon72</span><span>|</span><a href="#36570260">prev</a><span>|</span><a href="#36569418">next</a><span>|</span><label class="collapse" for="c-36569111">[-]</label><label class="expand" for="c-36569111">[1 more]</label></div><br/><div class="children"><div class="content">Besides living up to the username of &quot;ais523 - high effort answers&quot;, the author also does some high effort comments with someone who can&#x27;t get the program to run. The resolution:<p>&gt;  I suspect that what&#x27;s happening is that the program was somehow compiled with ASLR turned on. For some reason, the dynamic linker doesn&#x27;t respect the 4 MiB alignment of the BSS segment in this case, effectively ignoring my .align, and that&#x27;s what&#x27;s causing the bugs.</div><br/></div></div><div id="36569418" class="c"><input type="checkbox" id="c-36569418" checked=""/><div class="controls bullet"><span class="by">pier25</span><span>|</span><a href="#36569111">prev</a><span>|</span><a href="#36569467">next</a><span>|</span><label class="collapse" for="c-36569418">[-]</label><label class="expand" for="c-36569418">[11 more]</label></div><br/><div class="children"><div class="content">Makes you wonder... How fast would everything be if it was written in assembly.<p>In audio dev it&#x27;s very common for dsp code to be written in assembly.</div><br/><div id="36570451" class="c"><input type="checkbox" id="c-36570451" checked=""/><div class="controls bullet"><span class="by">MagicMoonlight</span><span>|</span><a href="#36569418">parent</a><span>|</span><a href="#36570062">next</a><span>|</span><label class="collapse" for="c-36570451">[-]</label><label class="expand" for="c-36570451">[1 more]</label></div><br/><div class="children"><div class="content">Even if everything was just written in java we’d be better off than the current system of embedding chrome into a python instance and then running a webserver in javascript to render a document.</div><br/></div></div><div id="36570062" class="c"><input type="checkbox" id="c-36570062" checked=""/><div class="controls bullet"><span class="by">kryptiskt</span><span>|</span><a href="#36569418">parent</a><span>|</span><a href="#36570451">prev</a><span>|</span><a href="#36569985">next</a><span>|</span><label class="collapse" for="c-36570062">[-]</label><label class="expand" for="c-36570062">[2 more]</label></div><br/><div class="children"><div class="content">It would end up like Steve Yegge&#x27;s tale of Geoworks:<p>&quot;OK: I went to the University of Washington and [then] I got hired by this company called Geoworks, doing assembly-language programming, and I did it for five years. To us, the Geoworkers, we wrote a whole operating system, the libraries, drivers, apps, you know: a desktop operating system in assembly. 8086 assembly! It wasn&#x27;t even good assembly! We had four registers! [Plus the] si [register] if you counted, you know, if you counted 386, right? It was horrible.<p>I mean, actually we kind of liked it. It was Object-Oriented Assembly. It&#x27;s amazing what you can talk yourself into liking, which is the real irony of all this. And to us, C++ was the ultimate in Roman decadence. I mean, it was equivalent to going and vomiting so you could eat more. They had IF! We had jump CX zero! Right? They had &quot;Objects&quot;. Well we did too, but I mean they had syntax for it, right? I mean it was all just such weeniness. And we knew that we could outperform any compiler out there because at the time, we could!<p>So what happened? Well, they went bankrupt. Why? Now I&#x27;m probably disagreeing – I know for a fact that I&#x27;m disagreeing with every Geoworker out there. I&#x27;m the only one that holds this belief. But it&#x27;s because we wrote fifteen million lines of 8086 assembly language. We had really good tools, world class tools: trust me, you need &#x27;em. But at some point, man...<p>The problem is, picture an ant walking across your garage floor, trying to make a straight line of it. It ain&#x27;t gonna make a straight line. And you know this because you have perspective. You can see the ant walking around, going hee hee hee, look at him locally optimize for that rock, and now he&#x27;s going off this way, right?<p>This is what we were, when we were writing this giant assembly-language system. Because what happened was, Microsoft eventually released a platform for mobile devices that was much faster than ours. OK? And I started going in with my debugger, going, what? What is up with this? This rendering is just really slow, it&#x27;s like sluggish, you know. And I went in and found out that some title bar was getting rendered 140 times every time you refreshed the screen. It wasn&#x27;t just the title bar. Everything was getting called multiple times.<p>Because we couldn&#x27;t see how the system worked anymore!<p>Small systems are not only easier to optimize, they&#x27;re possible to optimize. And I mean globally optimize.&quot;<p><a href="http:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2008&#x2F;05&#x2F;dynamic-languages-strike-back.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2008&#x2F;05&#x2F;dynamic-languages-st...</a></div><br/><div id="36570408" class="c"><input type="checkbox" id="c-36570408" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#36569418">root</a><span>|</span><a href="#36570062">parent</a><span>|</span><a href="#36569985">next</a><span>|</span><label class="collapse" for="c-36570408">[-]</label><label class="expand" for="c-36570408">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly, AI might change this. Not that it would be a good idea to write everything in assembly, but at least it would be possible now.<p>Some wonderful systems were written in assembly. Donkey Kong comes to mind.</div><br/></div></div></div></div><div id="36569985" class="c"><input type="checkbox" id="c-36569985" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#36569418">parent</a><span>|</span><a href="#36570062">prev</a><span>|</span><a href="#36569605">next</a><span>|</span><label class="collapse" for="c-36569985">[-]</label><label class="expand" for="c-36569985">[2 more]</label></div><br/><div class="children"><div class="content">Assembly is hardly the reason this is fast. It is necessary to this solution but by no means sufficient.<p>Extreme algorithmic research combined with a high LOK of Linux syscalls and platform specific optimizations is what allows this to exist. To quote the author, Alex Smith, himself:<p>&gt; @chx: I already have a master&#x27;s thesis. This was harder.<p>This is in a different universe than what can be produced by simply &quot;do it in assembly&quot;.</div><br/><div id="36570274" class="c"><input type="checkbox" id="c-36570274" checked=""/><div class="controls bullet"><span class="by">wheelerof4te</span><span>|</span><a href="#36569418">root</a><span>|</span><a href="#36569985">parent</a><span>|</span><a href="#36569605">next</a><span>|</span><label class="collapse" for="c-36570274">[-]</label><label class="expand" for="c-36570274">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Extreme algorithmic research combined with a high LOK of Linux syscalls and platform specific optimizations is what allows this to exist.&quot;<p>No, author&#x27;s extreme boredom and&#x2F;or free time allowed this to exist. Nothing else.</div><br/></div></div></div></div><div id="36569605" class="c"><input type="checkbox" id="c-36569605" checked=""/><div class="controls bullet"><span class="by">geek_at</span><span>|</span><a href="#36569418">parent</a><span>|</span><a href="#36569985">prev</a><span>|</span><a href="#36570211">next</a><span>|</span><label class="collapse" for="c-36569605">[-]</label><label class="expand" for="c-36569605">[1 more]</label></div><br/><div class="children"><div class="content">Or if everything had been written by &quot;ais523 - high effort answers&quot;</div><br/></div></div><div id="36570211" class="c"><input type="checkbox" id="c-36570211" checked=""/><div class="controls bullet"><span class="by">tragomaskhalos</span><span>|</span><a href="#36569418">parent</a><span>|</span><a href="#36569605">prev</a><span>|</span><a href="#36569891">next</a><span>|</span><label class="collapse" for="c-36570211">[-]</label><label class="expand" for="c-36570211">[1 more]</label></div><br/><div class="children"><div class="content">I started in software dev in 1988; the only languages I knew were BASIC and Z80 assembly so, since everyone knew BASIC was kind of lame I naturally assumed I&#x27;d be a machine code programmer, albeit on slightly more exotic processors.  Day one got handed a book on C -&gt; mind blown.</div><br/></div></div><div id="36569891" class="c"><input type="checkbox" id="c-36569891" checked=""/><div class="controls bullet"><span class="by">dumdumchan</span><span>|</span><a href="#36569418">parent</a><span>|</span><a href="#36570211">prev</a><span>|</span><a href="#36569750">next</a><span>|</span><label class="collapse" for="c-36569891">[-]</label><label class="expand" for="c-36569891">[1 more]</label></div><br/><div class="children"><div class="content">It wouldn&#x27;t run at all since it wouldn&#x27;t exist.</div><br/></div></div><div id="36569750" class="c"><input type="checkbox" id="c-36569750" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#36569418">parent</a><span>|</span><a href="#36569891">prev</a><span>|</span><a href="#36570398">next</a><span>|</span><label class="collapse" for="c-36569750">[-]</label><label class="expand" for="c-36569750">[1 more]</label></div><br/><div class="children"><div class="content">You dont need Assembly, you need to the code not to be terrible, which is generally hard with the amount of code&#x2F;developers needed.</div><br/></div></div><div id="36570398" class="c"><input type="checkbox" id="c-36570398" checked=""/><div class="controls bullet"><span class="by">jojobas</span><span>|</span><a href="#36569418">parent</a><span>|</span><a href="#36569750">prev</a><span>|</span><a href="#36569467">next</a><span>|</span><label class="collapse" for="c-36570398">[-]</label><label class="expand" for="c-36570398">[1 more]</label></div><br/><div class="children"><div class="content">It depends. You can write bubblesort in assembly and it will be pretty damn slow.
I can imagine those assembly leaders could push out pretty fast C implementations as well.</div><br/></div></div></div></div><div id="36569467" class="c"><input type="checkbox" id="c-36569467" checked=""/><div class="controls bullet"><span class="by">mellosouls</span><span>|</span><a href="#36569418">prev</a><span>|</span><a href="#36570387">next</a><span>|</span><label class="collapse" for="c-36569467">[-]</label><label class="expand" for="c-36569467">[1 more]</label></div><br/><div class="children"><div class="content">Previous:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29031488">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29031488</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29413656">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29413656</a></div><br/></div></div><div id="36570387" class="c"><input type="checkbox" id="c-36570387" checked=""/><div class="controls bullet"><span class="by">k1next</span><span>|</span><a href="#36569467">prev</a><span>|</span><a href="#36569428">next</a><span>|</span><label class="collapse" for="c-36570387">[-]</label><label class="expand" for="c-36570387">[1 more]</label></div><br/><div class="children"><div class="content">Interviewer: So let&#x27;s start with a simple coding challenge, it&#x27;s called FizzBuzz. Have you heard of it?</div><br/></div></div><div id="36569428" class="c"><input type="checkbox" id="c-36569428" checked=""/><div class="controls bullet"><span class="by">sschueller</span><span>|</span><a href="#36570387">prev</a><span>|</span><a href="#36569611">next</a><span>|</span><label class="collapse" for="c-36569428">[-]</label><label class="expand" for="c-36569428">[3 more]</label></div><br/><div class="children"><div class="content">For a second I thought it said 55 GiB&#x2F;s FritzBox which is a popular router in the German speaking part of Europe. My ISP also just last week tweeted a new 60 GiB&#x2F;s capable OPNSense box[1] that will be available soon.<p>[1] <a href="https:&#x2F;&#x2F;twitter.com&#x2F;init7&#x2F;status&#x2F;1674920410889043973" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;init7&#x2F;status&#x2F;1674920410889043973</a></div><br/><div id="36569564" class="c"><input type="checkbox" id="c-36569564" checked=""/><div class="controls bullet"><span class="by">MrFoof</span><span>|</span><a href="#36569428">parent</a><span>|</span><a href="#36569454">next</a><span>|</span><label class="collapse" for="c-36569564">[-]</label><label class="expand" for="c-36569564">[1 more]</label></div><br/><div class="children"><div class="content">I’ve a DEC750 that I’ve bumped to 16GB memory.  A 10GbE capable (2.3GbE Wireguard) router that’s silent and idles on par with my cable modem (8W) has been a great piece of equipment I don’t see myself replacing until 2030-2035.  I even plugged in a USB WiFi adapter so if cable goes out, it fails over specific VLANs and will use my cell phone to keep core connectivity up for work, etc.<p>They’re not cheap, but if you want some serious kit that also financially supports the OPNSense project, the Deciso appliances are tough to argue.  Power efficient, durability-focused components, just work.<p>It’s nice seeing their commercial offerings getting beefier.</div><br/></div></div></div></div><div id="36569611" class="c"><input type="checkbox" id="c-36569611" checked=""/><div class="controls bullet"><span class="by">haunter</span><span>|</span><a href="#36569428">prev</a><span>|</span><a href="#36569021">next</a><span>|</span><label class="collapse" for="c-36569611">[-]</label><label class="expand" for="c-36569611">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Save it as fizzbuzz.S (that&#x27;s a capital S as the extension)<p>What’s the significane of “.S” vs “.s”?</div><br/><div id="36569627" class="c"><input type="checkbox" id="c-36569627" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#36569611">parent</a><span>|</span><a href="#36569633">next</a><span>|</span><label class="collapse" for="c-36569627">[-]</label><label class="expand" for="c-36569627">[1 more]</label></div><br/><div class="children"><div class="content">Capital S will run the pre processor first.<p>Edit:<p>From manpage:<p><pre><code>    file.s
        Assembler code.
    file.S
    file.sx
        Assembler code that must be preprocessed.</code></pre></div><br/></div></div><div id="36569633" class="c"><input type="checkbox" id="c-36569633" checked=""/><div class="controls bullet"><span class="by">wkz</span><span>|</span><a href="#36569611">parent</a><span>|</span><a href="#36569627">prev</a><span>|</span><a href="#36569684">next</a><span>|</span><label class="collapse" for="c-36569633">[-]</label><label class="expand" for="c-36569633">[1 more]</label></div><br/><div class="children"><div class="content">IIRC, I believe that the difference traditionally was whether to pass the input through the preprocessor (.S), or not (.s).<p>Not sure if it makes a difference on modern toolchains.</div><br/></div></div><div id="36569684" class="c"><input type="checkbox" id="c-36569684" checked=""/><div class="controls bullet"><span class="by">zen_1</span><span>|</span><a href="#36569611">parent</a><span>|</span><a href="#36569633">prev</a><span>|</span><a href="#36569621">next</a><span>|</span><label class="collapse" for="c-36569684">[-]</label><label class="expand" for="c-36569684">[1 more]</label></div><br/><div class="children"><div class="content">The convention I&#x27;m used to uses .S to denote hand-written assembly files (usually tracked in git) vs .s for machine generated assembly which can be overwritten as needed.</div><br/></div></div><div id="36569621" class="c"><input type="checkbox" id="c-36569621" checked=""/><div class="controls bullet"><span class="by">easytiger</span><span>|</span><a href="#36569611">parent</a><span>|</span><a href="#36569684">prev</a><span>|</span><a href="#36569021">next</a><span>|</span><label class="collapse" for="c-36569621">[-]</label><label class="expand" for="c-36569621">[1 more]</label></div><br/><div class="children"><div class="content">GCC et al won&#x27;t overwrite a .S but if you ask it to gen ASM (e.g. gcc -S xyz.c) it will overwrite a .s</div><br/></div></div></div></div><div id="36569021" class="c"><input type="checkbox" id="c-36569021" checked=""/><div class="controls bullet"><span class="by">langsoul-com</span><span>|</span><a href="#36569611">prev</a><span>|</span><a href="#36568536">next</a><span>|</span><label class="collapse" for="c-36569021">[-]</label><label class="expand" for="c-36569021">[27 more]</label></div><br/><div class="children"><div class="content">Interesting how Java is so fast. Among the fastest of c, cpp, asm, go and rust.<p>How?</div><br/><div id="36569081" class="c"><input type="checkbox" id="c-36569081" checked=""/><div class="controls bullet"><span class="by">Veliladon</span><span>|</span><a href="#36569021">parent</a><span>|</span><a href="#36569455">next</a><span>|</span><label class="collapse" for="c-36569081">[-]</label><label class="expand" for="c-36569081">[10 more]</label></div><br/><div class="children"><div class="content">Because the JVM has had 27 years of R&amp;D work done to it. If you have a really hot path a JIT will typically continually recompile it in the background with more and more optimization work and start putting the loop through that progressively more optimized code. When you&#x27;re doing gigabytes of FizzBuzz the JIT will quickly have something pretty comparable to the best native code.</div><br/><div id="36569373" class="c"><input type="checkbox" id="c-36569373" checked=""/><div class="controls bullet"><span class="by">colmmacc</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569081">parent</a><span>|</span><a href="#36569585">next</a><span>|</span><label class="collapse" for="c-36569373">[-]</label><label class="expand" for="c-36569373">[4 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t matter for FizzBuzz, but in general JIT should really out-perform &quot;native&quot; statically compiled compilers on most real-world workloads. While there&#x27;s a small penalty for the profiling JIT needs, there are massive gains for data and access dependent optimizations that static compilation can&#x27;t achieve without explicit hints. For example, a JIT can observe the most commonly accessed data and re-order it to optimize for the pre-fetching pipeline. Or it can re-order operations to optimize for cache-line hotness.</div><br/><div id="36569720" class="c"><input type="checkbox" id="c-36569720" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569373">parent</a><span>|</span><a href="#36569585">next</a><span>|</span><label class="collapse" for="c-36569720">[-]</label><label class="expand" for="c-36569720">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but in general JIT should really out-perform &quot;native&quot; statically compiled compilers on most real-world workloads.<p>In theory, yes, but in practice I&#x27;ve never seen it happen. Best I ever saw was matching C speed at toy benchmarks. Even in this benchmark here, Java is decent, but does not beat even the naive implementations in C&#x2F;Rust.<p>Also, AOT compilers can do PGO as well, so they can use the same techniques. But they also have way more time and resources, so they can do things like whole program optimization, which is something JITs cannot do because they have much smaller computation and memory budget.<p>It happened already many times to me that the first naive version of a C&#x2F;C++&#x2F;Rust program&#x2F;function I wrote was already faster than a carefully tuned Java equivalent. AOT compilers for &quot;fast languages&quot; got really good these days. The design of language also influences how well it can be optimized by the compiler. E.g. it might look impressive JVM can devirtualize dynamic calls at runtime, but C++&#x2F;Rust often don&#x27;t have to do this at all as programs in those languages tend to have very few virtual calls if any at all.</div><br/><div id="36570016" class="c"><input type="checkbox" id="c-36570016" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569720">parent</a><span>|</span><a href="#36570379">next</a><span>|</span><label class="collapse" for="c-36570016">[-]</label><label class="expand" for="c-36570016">[1 more]</label></div><br/><div class="children"><div class="content">If you didn&#x27;t need more evidence, the fact that the Java community has been slowly moving towards AoT with GraalVM should cement it. Java&#x27;s JITs are damn impressive pieces of engineering, but the structural advantages of traditional compilation still win out surprisingly often.</div><br/></div></div><div id="36570379" class="c"><input type="checkbox" id="c-36570379" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569720">parent</a><span>|</span><a href="#36570016">prev</a><span>|</span><a href="#36569585">next</a><span>|</span><label class="collapse" for="c-36570379">[-]</label><label class="expand" for="c-36570379">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Java is decent, but does not beat even the naive implementations in C&#x2F;Rust.<p>Java doesn&#x27;t beat C  in this benchmark but beats Rust with ease.</div><br/></div></div></div></div></div></div><div id="36569585" class="c"><input type="checkbox" id="c-36569585" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569081">parent</a><span>|</span><a href="#36569373">prev</a><span>|</span><a href="#36569404">next</a><span>|</span><label class="collapse" for="c-36569585">[-]</label><label class="expand" for="c-36569585">[1 more]</label></div><br/><div class="children"><div class="content">oddly enough fizzbuzz stuff likely needs an on the stack code replacement, i.e. compiling and replacing the currently executed code, which tends to be subpar.<p>The submitted code snippets for Java do not need OSR, though... yet they can be improved further, e.g. should drop the use of String entirely (which would not feel very Java). The other attempt to convert int -&gt; String (byte) uses the naive way to divide by 10 on each iteration, Java.&#x27;s Integer.toString does it way better.<p>Edit: on a 2nd thought, having a dedicated direct buffer [same allocation, different slices] per all the 8 out of 15 ares for numbers and NOT converting int-&gt;String each operation but adding 15 would be a pretty boon as most of the time the change would be only the last 2 bytes, and there won&#x27;t be any &#x27;div&#x27; to be had. <i>Div is generally slow (compared to L1&#x2F;L2 cache misses, and L3 hit), there is not algorithm to parallelize it, and there is one (few) unit that can perform div, unlike &#x27;add&#x27;)</i></div><br/></div></div><div id="36569404" class="c"><input type="checkbox" id="c-36569404" checked=""/><div class="controls bullet"><span class="by">pier25</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569081">parent</a><span>|</span><a href="#36569585">prev</a><span>|</span><a href="#36569455">next</a><span>|</span><label class="collapse" for="c-36569404">[-]</label><label class="expand" for="c-36569404">[4 more]</label></div><br/><div class="children"><div class="content">Will V8 be able to do the same some day?</div><br/><div id="36569658" class="c"><input type="checkbox" id="c-36569658" checked=""/><div class="controls bullet"><span class="by">lordgrenville</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569404">parent</a><span>|</span><a href="#36570215">next</a><span>|</span><label class="collapse" for="c-36569658">[-]</label><label class="expand" for="c-36569658">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that a statically typed language is inherently faster than a dynamically typed one, no matter how much you optimise the latter. The JS interpreter&#x2F;VM simply has a lot more work to do than the JVM.</div><br/></div></div><div id="36570215" class="c"><input type="checkbox" id="c-36570215" checked=""/><div class="controls bullet"><span class="by">curling_grad</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569404">parent</a><span>|</span><a href="#36569658">prev</a><span>|</span><a href="#36569874">next</a><span>|</span><label class="collapse" for="c-36570215">[-]</label><label class="expand" for="c-36570215">[1 more]</label></div><br/><div class="children"><div class="content">I think WASM will be the mainstream for frontend before that happens... But you never can&#x27;t predict the future!</div><br/></div></div><div id="36569874" class="c"><input type="checkbox" id="c-36569874" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569404">parent</a><span>|</span><a href="#36570215">prev</a><span>|</span><a href="#36569455">next</a><span>|</span><label class="collapse" for="c-36569874">[-]</label><label class="expand" for="c-36569874">[1 more]</label></div><br/><div class="children"><div class="content">Java is a lot better source (and target) to optimize for than JS. It&#x27;s quite bit more work to have all numbers being floating point by default.</div><br/></div></div></div></div></div></div><div id="36569455" class="c"><input type="checkbox" id="c-36569455" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#36569021">parent</a><span>|</span><a href="#36569081">prev</a><span>|</span><a href="#36569415">next</a><span>|</span><label class="collapse" for="c-36569455">[-]</label><label class="expand" for="c-36569455">[9 more]</label></div><br/><div class="children"><div class="content">Java is only slow to start the VM.  If your process is long-lived it&#x27;s exceedingly quick because you only pay the startup penalty once.<p>&quot;GC pauses&quot; are greatly exaggerated in terms of impact and frankly for the vast majority of uses cases GC simply doesn&#x27;t become an issue.<p>The JVM is really really good because at one point or another they had basically every luminary in the field working on it.</div><br/><div id="36570183" class="c"><input type="checkbox" id="c-36570183" checked=""/><div class="controls bullet"><span class="by">Shorel</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569455">parent</a><span>|</span><a href="#36569731">next</a><span>|</span><label class="collapse" for="c-36570183">[-]</label><label class="expand" for="c-36570183">[2 more]</label></div><br/><div class="children"><div class="content">Java has a ridiculously fast new operator. Much faster than the one in C++.<p>It works by allocating all or most needed memory at program start, instead of asking the operating system for it every time.
But, as soon as you don&#x27;t use heap memory, and use the stack, C++ is again much, much faster than Java.<p>It all depends on memory management.</div><br/><div id="36570257" class="c"><input type="checkbox" id="c-36570257" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36570183">parent</a><span>|</span><a href="#36569731">next</a><span>|</span><label class="collapse" for="c-36570257">[-]</label><label class="expand" for="c-36570257">[1 more]</label></div><br/><div class="children"><div class="content">C++&#x27;s new operator can also do this using &quot;placement new&quot; semantics[1], which usually means making (and using) a custom allocator.  You&#x27;re still using the normal new operator, just passing extra parameters to do the placement you want.<p>To your second point about raw speed, one of the extraordinary things we found in long-running processes performing computation using real-time marketdata at Goldman was that the HotSpot JVM was able to optimize java programs through the day due to their usage, so if you started them each day they would actually end up faster than the C++ versions at the end of the day even though they would start off slower.  That&#x27;s not due to memory allocation it&#x27;s due to things like inlining of functions.<p>The implication of that is that if you very carefully inlined all the functions appropriately in the C++ version based on profiling actual usage you would be able to achieve the same result, but for the JVM it just happens automatically without you doing anything.<p>[1] Search <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;new" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;new</a> for &quot;Placement New&quot;</div><br/></div></div></div></div><div id="36569731" class="c"><input type="checkbox" id="c-36569731" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569455">parent</a><span>|</span><a href="#36570183">prev</a><span>|</span><a href="#36569415">next</a><span>|</span><label class="collapse" for="c-36569731">[-]</label><label class="expand" for="c-36569731">[6 more]</label></div><br/><div class="children"><div class="content">The fear of GC pauses is mostly outdated. It was right in the past, but it is becoming less and less of an issue with the new GC work coming online. And for small heaps in web application servers, the pauses were a blip on the high percentiles of response times and you usually had a dozen other issues before that.<p>It&#x27;s similar to SWAP in Linux. It was implemented somewhat meh in older kernels, and usually if swap got hit, the system died anyhow. So there was no real difference between random processes being OOM-killed or the system grinding to a halt swapping. Modern kernels in the 4+ line have received quite a bit of work on the swap handling and swap is used a lot and very cleverly to eek out just a bit more available memory more quickly.<p>Old habits die hard though and it takes time for old knowledge to change.</div><br/><div id="36569817" class="c"><input type="checkbox" id="c-36569817" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569731">parent</a><span>|</span><a href="#36570313">next</a><span>|</span><label class="collapse" for="c-36569817">[-]</label><label class="expand" for="c-36569817">[4 more]</label></div><br/><div class="children"><div class="content">The problem of GC pauses is solved only if you can afford to waste 5x-20x more memory than the app is really using. Otherwise those low-pause modern collectors can burn a significant number of CPU cycles or even fall into emergency STW path (when they can&#x27;t keep up with garbage production rate).</div><br/><div id="36569971" class="c"><input type="checkbox" id="c-36569971" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569817">parent</a><span>|</span><a href="#36570313">next</a><span>|</span><label class="collapse" for="c-36569971">[-]</label><label class="expand" for="c-36569971">[3 more]</label></div><br/><div class="children"><div class="content">If the allocations die trivially (the extreme&#x2F;vast majority do) in the young gen, STW doesn&#x27;t occur. Indeed being aware, how the GC operates is important to write a decent Java application. So is understanding how the hardware works in general.</div><br/><div id="36570205" class="c"><input type="checkbox" id="c-36570205" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569971">parent</a><span>|</span><a href="#36570313">next</a><span>|</span><label class="collapse" for="c-36570205">[-]</label><label class="expand" for="c-36570205">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If the allocations die trivially (the extreme&#x2F;vast majority do) in the young gen<p>Low pause GCs (ZGC, Shenadoah) for Java are not generational yet.<p>Also, even if they were, a very high temporary object allocation rate increases young gen GC frequency and thus increases the number of objects pushed to old gen eventually.<p>And it is not like those young gen GCs are free either. They burn quite some CPU time and they cause micro-pauses - the GC has to scan parts of the heap to learn which objects are reachable and then it has to copy the survivors. In practice, high allocation rate requires a decent amount of overhead RAM to make that process efficient. It doesn&#x27;t matter if pauses are only 10 ms short if you do 50 of them per second. ;)<p>In non-GCed languages those trivial short-term objects are typically allocated on stack and their allocation&#x2F;deallocation is trivial and doesn&#x27;t pause at all.</div><br/><div id="36570433" class="c"><input type="checkbox" id="c-36570433" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36570205">parent</a><span>|</span><a href="#36570313">next</a><span>|</span><label class="collapse" for="c-36570433">[-]</label><label class="expand" for="c-36570433">[1 more]</label></div><br/><div class="children"><div class="content">&gt;the GC has to scan parts of the heap<p>Hmm, for generation GCs, it should use Card marking, the pointers in the tenured gen should have means to be trivially determined where they belong to. With 64bit pointers, there is space for quite a lot of metadata, incl. the Class (or most commonly allocated&#x2F;used classes).</div><br/></div></div></div></div></div></div></div></div><div id="36570313" class="c"><input type="checkbox" id="c-36570313" checked=""/><div class="controls bullet"><span class="by">kalleboo</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569731">parent</a><span>|</span><a href="#36569817">prev</a><span>|</span><a href="#36569415">next</a><span>|</span><label class="collapse" for="c-36570313">[-]</label><label class="expand" for="c-36570313">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>it is becoming less and less of an issue with the new GC work coming online</i><p>I feel like I&#x27;ve been hearing this same line for 20 years now</div><br/></div></div></div></div></div></div><div id="36569415" class="c"><input type="checkbox" id="c-36569415" checked=""/><div class="controls bullet"><span class="by">atomicnumber3</span><span>|</span><a href="#36569021">parent</a><span>|</span><a href="#36569455">prev</a><span>|</span><a href="#36568536">next</a><span>|</span><label class="collapse" for="c-36569415">[-]</label><label class="expand" for="c-36569415">[7 more]</label></div><br/><div class="children"><div class="content">Imo it&#x27;s one of Javas strengths. If you need to, you can write ugly but ridiculously fast code. It does end up looking more like writing C than java though, but obviously your whole codebase doesn&#x27;t need to look like that and it&#x27;s portable.</div><br/><div id="36569583" class="c"><input type="checkbox" id="c-36569583" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569415">parent</a><span>|</span><a href="#36569752">next</a><span>|</span><label class="collapse" for="c-36569583">[-]</label><label class="expand" for="c-36569583">[1 more]</label></div><br/><div class="children"><div class="content">The only part Java lacks - headless objects (aka project Valhalla). It has been mimicked with direct buffers and offset for ~20y now (since Merlin release). Other than that java is similar to a guided &quot;gcc -O2&quot;</div><br/></div></div><div id="36569752" class="c"><input type="checkbox" id="c-36569752" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569415">parent</a><span>|</span><a href="#36569583">prev</a><span>|</span><a href="#36568536">next</a><span>|</span><label class="collapse" for="c-36569752">[-]</label><label class="expand" for="c-36569752">[5 more]</label></div><br/><div class="children"><div class="content">Sure, you can write Java like C and get performance typically within 0.3x to 1x of C. But Java written in this style is even less ergonomic than C is, so if you have to do do it, there is not much point in using Java.</div><br/><div id="36569868" class="c"><input type="checkbox" id="c-36569868" checked=""/><div class="controls bullet"><span class="by">antonhag</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569752">parent</a><span>|</span><a href="#36568536">next</a><span>|</span><label class="collapse" for="c-36569868">[-]</label><label class="expand" for="c-36569868">[4 more]</label></div><br/><div class="children"><div class="content">It is quite common that you only need to optimize very small parts of a program to this level. The rest of the program can be written in more conventional styles.<p>You could of course FFI into e.g. C for those parts, but that is usually harder to maintain than a few well optimized java classes.</div><br/><div id="36570017" class="c"><input type="checkbox" id="c-36570017" checked=""/><div class="controls bullet"><span class="by">generichuman</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569868">parent</a><span>|</span><a href="#36569984">next</a><span>|</span><label class="collapse" for="c-36570017">[-]</label><label class="expand" for="c-36570017">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You could of course FFI into e.g. C for those parts, but that is usually harder to maintain than a few well optimized java classes.<p>Hopefully Foreign Function &amp; Memory API [0] makes FFI so much easier that we get to drop down to C without much fuss.<p>[0] <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;442" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;442</a></div><br/></div></div><div id="36569984" class="c"><input type="checkbox" id="c-36569984" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569868">parent</a><span>|</span><a href="#36570017">prev</a><span>|</span><a href="#36568536">next</a><span>|</span><label class="collapse" for="c-36569984">[-]</label><label class="expand" for="c-36569984">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It is quite common that you only need to optimize very small parts of a program to this level.<p>It&#x27;s a quite common myth developers believe about performance. Hotspots do happen sometimes, but once they have been optimized you quicky end up with a flat profile and an &quot;everything is slow&quot; problem. And in some types of apps, the majority of code is performance critical.</div><br/><div id="36570369" class="c"><input type="checkbox" id="c-36570369" checked=""/><div class="controls bullet"><span class="by">antonhag</span><span>|</span><a href="#36569021">root</a><span>|</span><a href="#36569984">parent</a><span>|</span><a href="#36568536">next</a><span>|</span><label class="collapse" for="c-36570369">[-]</label><label class="expand" for="c-36570369">[1 more]</label></div><br/><div class="children"><div class="content">It depends - even when you run into an &quot;everything is slow&quot; problem, it might be that it&#x27;s like 1 endpoint out of 2000 that causes performance issues. In this case, you might need to focus very much on performance for that endpoint, but maybe not for other endpoints. Profilers can help you figure out what code to focus on.<p>If the majority of code is performance critical, the tradeoffs are of course different.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36568536" class="c"><input type="checkbox" id="c-36568536" checked=""/><div class="controls bullet"><span class="by">idlewords</span><span>|</span><a href="#36569021">prev</a><span>|</span><a href="#36569616">next</a><span>|</span><label class="collapse" for="c-36568536">[-]</label><label class="expand" for="c-36568536">[15 more]</label></div><br/><div class="children"><div class="content">The first company to offer a native hardware implementation of FizzBuzz is going to revolutionize hiring and bring back boom times for our industry.</div><br/><div id="36570443" class="c"><input type="checkbox" id="c-36570443" checked=""/><div class="controls bullet"><span class="by">Aromasin</span><span>|</span><a href="#36568536">parent</a><span>|</span><a href="#36568954">next</a><span>|</span><label class="collapse" for="c-36570443">[-]</label><label class="expand" for="c-36570443">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll maybe be pleased to know that I&#x27;ve already had this as a coding interview at a couple of high frequency trading FPGA interviews. I didn&#x27;t do well at all in the first interview. Second time I got asked it I laughed, because I had spent a weekend down a rabbit hole, programming one on an old Cyclone V. Basically just a load of counters and state-machines. It&#x27;s something like this:
<a href="http:&#x2F;&#x2F;www.righto.com&#x2F;2018&#x2F;03&#x2F;implementing-fizzbuzz-on-fpga.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.righto.com&#x2F;2018&#x2F;03&#x2F;implementing-fizzbuzz-on-fpga....</a></div><br/></div></div><div id="36568954" class="c"><input type="checkbox" id="c-36568954" checked=""/><div class="controls bullet"><span class="by">mindcrime</span><span>|</span><a href="#36568536">parent</a><span>|</span><a href="#36570443">prev</a><span>|</span><a href="#36568868">next</a><span>|</span><label class="collapse" for="c-36568954">[-]</label><label class="expand" for="c-36568954">[2 more]</label></div><br/><div class="children"><div class="content">At Fogbeam Labs work has been proceeding to bring perfection to the crudely conceived idea of a FizzCabulator. This device not only supplies inverse reactive current for use in unilateral phase detractors, but is also capable of automatically synchronizing cardinal grammeters. The only new principle involved is that instead of power being generated by the relative motion of fizzes and buzzes, it is generated by the modial interaction of magneto-reluctance and capacitive duractance.</div><br/><div id="36569508" class="c"><input type="checkbox" id="c-36569508" checked=""/><div class="controls bullet"><span class="by">logicallee</span><span>|</span><a href="#36568536">root</a><span>|</span><a href="#36568954">parent</a><span>|</span><a href="#36568868">next</a><span>|</span><label class="collapse" for="c-36569508">[-]</label><label class="expand" for="c-36569508">[1 more]</label></div><br/><div class="children"><div class="content">I love it. How about a quantum computing version?<p>You know who wrote this:<p>&quot;Essentially, the Quantum FizzBuzz Decoupler is a device that bifurcates the bifizzial substrates and recoheres them into units of Buzzifactive tri-fusion. Its pivotal design focuses on the tripticate circuitry which utilizes pseudo-string theory, ensuring the cyclic decoupling of the Fizzionic and Buzzionic isotopes, thereby creating a conflux of cryptic poly-angular interdigitations.<p>This hyper-convoluted mechanism leverages the intrinsic infra-doodlality of its multitudinous nano-digitators, producing a reiterative bi-fractal resonance with every flicker of the reciprocal quark-flux nano-helices. Interlocking harmonic modulators within the Decoupler support the synchronous crystallization of the brizzulated waveforms, thus reinforcing the transluminal juxtapositioning of multi-fuzzional intermediates.<p>Within its dual-core, it harmonizes the phasic disentanglement of quasi-quintessential quantum flux through the divaricating spindles of the orthofizzial transinductor. Furthermore, the Decoupler incorporates an ultra-gloptic resonator to facilitate the recursive modulation of the bifizzial and tri-buzzoidal constituents, hence the stupendously high FizzBuzz output.&quot;</div><br/></div></div></div></div><div id="36568868" class="c"><input type="checkbox" id="c-36568868" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#36568536">parent</a><span>|</span><a href="#36568954">prev</a><span>|</span><a href="#36569031">next</a><span>|</span><label class="collapse" for="c-36568868">[-]</label><label class="expand" for="c-36568868">[4 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t even need to spin your own silicon, just slap FizzBuzz on the $50k Xilinx XCVU13P and FizzBuzz at a whopping &gt;500GB&#x2F;s using all of its transceivers. Though, you&#x27;d probably need two of &#x27;em (somebody has to receive all that FizzBuzz) so toss in another $50k for another, and them hmm you need some top tier signaling talent to manage all that, so probably add in $250k to get somebody to do this. A mere $350k for the FizzBuzz crown, it&#x27;s a steal really.</div><br/><div id="36569361" class="c"><input type="checkbox" id="c-36569361" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#36568536">root</a><span>|</span><a href="#36568868">parent</a><span>|</span><a href="#36569031">next</a><span>|</span><label class="collapse" for="c-36569361">[-]</label><label class="expand" for="c-36569361">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re paying more than $300-500 for a XCVU13P, you&#x27;re doing it wrong.</div><br/><div id="36569421" class="c"><input type="checkbox" id="c-36569421" checked=""/><div class="controls bullet"><span class="by">Foobar8568</span><span>|</span><a href="#36568536">root</a><span>|</span><a href="#36569361">parent</a><span>|</span><a href="#36569031">next</a><span>|</span><label class="collapse" for="c-36569421">[-]</label><label class="expand" for="c-36569421">[2 more]</label></div><br/><div class="children"><div class="content">Is there a joke somewhere there? Because I don&#x27;t see how this chip can be found at $300-500.</div><br/><div id="36569515" class="c"><input type="checkbox" id="c-36569515" checked=""/><div class="controls bullet"><span class="by">zorgmonkey</span><span>|</span><a href="#36568536">root</a><span>|</span><a href="#36569421">parent</a><span>|</span><a href="#36569031">next</a><span>|</span><label class="collapse" for="c-36569515">[-]</label><label class="expand" for="c-36569515">[1 more]</label></div><br/><div class="children"><div class="content">Here is one on ebay for $600, realistically you&#x27;d need a nice rework station and the skills to reball it to actually use it. FPGA pricing for on places like mouser and digikey is notorious for being an outright lie, the high volume prices are way less then 50k (don&#x27;t get me wrong they&#x27;re still expensive chips, just less expensive than that).<p><a href="https:&#x2F;&#x2F;www.ebay.com&#x2F;itm&#x2F;364213117135?hash=item54cccb20cf:g:iIcAAOSw2ENkM7wH" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ebay.com&#x2F;itm&#x2F;364213117135?hash=item54cccb20cf:g:...</a></div><br/></div></div></div></div></div></div></div></div><div id="36569031" class="c"><input type="checkbox" id="c-36569031" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36568536">parent</a><span>|</span><a href="#36568868">prev</a><span>|</span><a href="#36568726">next</a><span>|</span><label class="collapse" for="c-36569031">[-]</label><label class="expand" for="c-36569031">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s trivial; a shift register that latches the 15 initial values, and then just rotates them around, reading off the last one as the output.</div><br/><div id="36569770" class="c"><input type="checkbox" id="c-36569770" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#36568536">root</a><span>|</span><a href="#36569031">parent</a><span>|</span><a href="#36569481">next</a><span>|</span><label class="collapse" for="c-36569770">[-]</label><label class="expand" for="c-36569770">[1 more]</label></div><br/><div class="children"><div class="content">This realization almost got me suspended in a high school. Our goal was to make an extensible fizzbuzz(barbazzfrongetc)er and I got fascinated by the problem of making wheels. I wrote a program the generated circular lists in mit scheme that could be used as wheels (ie circular lists with either #f or fizz, buzz, bar, fizzbuzz etc). It was structured as a competition (fastest fizzbuzz up to int16 where the fizzes and buzzes would be given by the teacher at competition time), and the winner would get a chocolate bar or something inane. I couldn&#x27;t eat it because I can&#x27;t eat milk.<p>I was the only one who spent some serious time on the task, and in the end my implementation was the fastest by several orders of magnitude, despite being the only using something else than C, C++ or java. The programming teacher refused to believe I wrote it myself, but due to a stroke of luck I have saved every revision of the code as a part of a primitive folder based SCM-scheme.<p>I ended up getting a louse grade due to me not caring too much about school, but the teacher and I were on good terms and he became somewhat of a programming mentor to me</div><br/></div></div><div id="36569481" class="c"><input type="checkbox" id="c-36569481" checked=""/><div class="controls bullet"><span class="by">sweettea</span><span>|</span><a href="#36568536">root</a><span>|</span><a href="#36569031">parent</a><span>|</span><a href="#36569770">prev</a><span>|</span><a href="#36568726">next</a><span>|</span><label class="collapse" for="c-36569481">[-]</label><label class="expand" for="c-36569481">[3 more]</label></div><br/><div class="children"><div class="content">Ah, but for 8 of the values, you need to print the number, which changes each iteration.</div><br/><div id="36569794" class="c"><input type="checkbox" id="c-36569794" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#36568536">root</a><span>|</span><a href="#36569481">parent</a><span>|</span><a href="#36568726">next</a><span>|</span><label class="collapse" for="c-36569794">[-]</label><label class="expand" for="c-36569794">[2 more]</label></div><br/><div class="children"><div class="content">BCD increment is trivial in hardware.</div><br/><div id="36569864" class="c"><input type="checkbox" id="c-36569864" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#36568536">root</a><span>|</span><a href="#36569794">parent</a><span>|</span><a href="#36568726">next</a><span>|</span><label class="collapse" for="c-36569864">[-]</label><label class="expand" for="c-36569864">[1 more]</label></div><br/><div class="children"><div class="content">pretty much that sums it up -&gt; no division, please</div><br/></div></div></div></div></div></div></div></div><div id="36568726" class="c"><input type="checkbox" id="c-36568726" checked=""/><div class="controls bullet"><span class="by">duxup</span><span>|</span><a href="#36568536">parent</a><span>|</span><a href="#36569031">prev</a><span>|</span><a href="#36568950">next</a><span>|</span><label class="collapse" for="c-36568726">[-]</label><label class="expand" for="c-36568726">[1 more]</label></div><br/><div class="children"><div class="content">At the very least their hiring question will be relevant.</div><br/></div></div><div id="36568950" class="c"><input type="checkbox" id="c-36568950" checked=""/><div class="controls bullet"><span class="by">m3kw9</span><span>|</span><a href="#36568536">parent</a><span>|</span><a href="#36568726">prev</a><span>|</span><a href="#36569616">next</a><span>|</span><label class="collapse" for="c-36568950">[-]</label><label class="expand" for="c-36568950">[1 more]</label></div><br/><div class="children"><div class="content">Harnessing power of the sun we can build a planet scale computer to bring fizzbuzz to 50gigaterrabits bee second</div><br/></div></div></div></div><div id="36569616" class="c"><input type="checkbox" id="c-36569616" checked=""/><div class="controls bullet"><span class="by">edwintorok</span><span>|</span><a href="#36568536">prev</a><span>|</span><a href="#36569049">next</a><span>|</span><label class="collapse" for="c-36569616">[-]</label><label class="expand" for="c-36569616">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t use io_uring so it might be possible to make this go even faster these days...</div><br/></div></div><div id="36569049" class="c"><input type="checkbox" id="c-36569049" checked=""/><div class="controls bullet"><span class="by">x86x87</span><span>|</span><a href="#36569616">prev</a><span>|</span><a href="#36569007">next</a><span>|</span><label class="collapse" for="c-36569049">[-]</label><label class="expand" for="c-36569049">[1 more]</label></div><br/><div class="children"><div class="content">maybe it&#x27;s fast, but is it enterprise quality? <a href="https:&#x2F;&#x2F;github.com&#x2F;EnterpriseQualityCoding&#x2F;FizzBuzzEnterpriseEdition">https:&#x2F;&#x2F;github.com&#x2F;EnterpriseQualityCoding&#x2F;FizzBuzzEnterpris...</a></div><br/></div></div><div id="36569007" class="c"><input type="checkbox" id="c-36569007" checked=""/><div class="controls bullet"><span class="by">lxe</span><span>|</span><a href="#36569049">prev</a><span>|</span><a href="#36569657">next</a><span>|</span><label class="collapse" for="c-36569007">[-]</label><label class="expand" for="c-36569007">[1 more]</label></div><br/><div class="children"><div class="content">I keep getting failures to resize kernel buffer, no matter how or where I pipe it.</div><br/></div></div><div id="36569657" class="c"><input type="checkbox" id="c-36569657" checked=""/><div class="controls bullet"><span class="by">leijurv</span><span>|</span><a href="#36569007">prev</a><span>|</span><a href="#36569233">next</a><span>|</span><label class="collapse" for="c-36569657">[-]</label><label class="expand" for="c-36569657">[1 more]</label></div><br/><div class="children"><div class="content">This inspired me to plumb the depths of FizzBuzz, seeking further into it than anyone ever has before: the 10^10000000000th digit (it&#x27;s a &quot;1&quot;): <a href="https:&#x2F;&#x2F;github.com&#x2F;leijurv&#x2F;reverse-fizzbuzz">https:&#x2F;&#x2F;github.com&#x2F;leijurv&#x2F;reverse-fizzbuzz</a></div><br/></div></div><div id="36569233" class="c"><input type="checkbox" id="c-36569233" checked=""/><div class="controls bullet"><span class="by">simlevesque</span><span>|</span><a href="#36569657">prev</a><span>|</span><a href="#36569624">next</a><span>|</span><label class="collapse" for="c-36569233">[-]</label><label class="expand" for="c-36569233">[1 more]</label></div><br/><div class="children"><div class="content">I sometimes wonder if someone is running that program right now until it crashes in a couple decades.</div><br/></div></div><div id="36569624" class="c"><input type="checkbox" id="c-36569624" checked=""/><div class="controls bullet"><span class="by">rs38</span><span>|</span><a href="#36569233">prev</a><span>|</span><a href="#36568918">next</a><span>|</span><label class="collapse" for="c-36569624">[-]</label><label class="expand" for="c-36569624">[2 more]</label></div><br/><div class="children"><div class="content">do I need glasses, or not a single c#&#x2F;.net implementation?</div><br/><div id="36569690" class="c"><input type="checkbox" id="c-36569690" checked=""/><div class="controls bullet"><span class="by">rs38</span><span>|</span><a href="#36569624">parent</a><span>|</span><a href="#36568918">next</a><span>|</span><label class="collapse" for="c-36569690">[-]</label><label class="expand" for="c-36569690">[1 more]</label></div><br/><div class="children"><div class="content">found my glasses and there is a candidate AVX optimized to 1 GB&#x2F;s</div><br/></div></div></div></div><div id="36568918" class="c"><input type="checkbox" id="c-36568918" checked=""/><div class="controls bullet"><span class="by">MortimerDukePhD</span><span>|</span><a href="#36569624">prev</a><span>|</span><a href="#36569849">next</a><span>|</span><label class="collapse" for="c-36568918">[-]</label><label class="expand" for="c-36568918">[6 more]</label></div><br/><div class="children"><div class="content">My all-time favorite FizzBuzz story:<p><a href="https:&#x2F;&#x2F;css-tricks.com&#x2F;tales-of-a-non-unicorn-a-story-about-the-trouble-with-job-titles-and-descriptions&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;css-tricks.com&#x2F;tales-of-a-non-unicorn-a-story-about-...</a></div><br/><div id="36569379" class="c"><input type="checkbox" id="c-36569379" checked=""/><div class="controls bullet"><span class="by">KnobbleMcKnees</span><span>|</span><a href="#36568918">parent</a><span>|</span><a href="#36569398">next</a><span>|</span><label class="collapse" for="c-36569379">[-]</label><label class="expand" for="c-36569379">[2 more]</label></div><br/><div class="children"><div class="content">What a silly story. They applied for a job that made it clear they were looking for someone who could proficiently program, and they couldn&#x27;t do it. So they didn&#x27;t get the job. What a surprise.<p>Asking for a list of tasks that will come up or code examples is particularly naive. Technical jobs aren&#x27;t a laundry list of exact needs.<p>Being an engineer in any field requires versatility, including the ability to solve problems on your feet and to learn new technology, or to learn tech you already know to a greater depth, at the drop of a hat.<p>This is one of the few times I&#x27;ve ever read a story about impostor syndrome where the story teller actually was an impostor. Bizarre.</div><br/><div id="36570083" class="c"><input type="checkbox" id="c-36570083" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#36568918">root</a><span>|</span><a href="#36569379">parent</a><span>|</span><a href="#36569398">next</a><span>|</span><label class="collapse" for="c-36570083">[-]</label><label class="expand" for="c-36570083">[1 more]</label></div><br/><div class="children"><div class="content">I think you missed the point of the story, which was that the company was asking for a combination of skills that never exist in the same person. An unicorn. In that context it is reasonable to assume that if you have the core competency (in this case design skills, not coding), then you should apply.<p>Also fizz buzz has nothing to do with the kind of programming that was expected from the job description. Now you might reasonably object that fizz buzz is <i>supposed</i> to be something so rudimentary that any programmer could implement. But the point is UI&#x2F;UX people don&#x27;t typically do any algorithms work at all. Their interaction with JS is often just to call an API and shove the resulting data where it needs to be in the DOM. They may never have to use a loop, ever. Or conditional testing. Or think about infinite sequences. To a proper software engineer like you or me fizz buzz seems ridiculously simple. But I could totally see a UX designer whose only interaction with self-taught JS is to glue APIs together being tripped up.</div><br/></div></div></div></div><div id="36569398" class="c"><input type="checkbox" id="c-36569398" checked=""/><div class="controls bullet"><span class="by">throwaway675309</span><span>|</span><a href="#36568918">parent</a><span>|</span><a href="#36569379">prev</a><span>|</span><a href="#36569175">next</a><span>|</span><label class="collapse" for="c-36569398">[-]</label><label class="expand" for="c-36569398">[1 more]</label></div><br/><div class="children"><div class="content">Her point about the title &quot;engineer&quot; being in nearly every job posting while basically conferring zero meaning is definitely on point, but her mock outrage  about being asked an <i>extremely rudimentary programming question</i> surprised me given that one of the requirements of the job was JavaScript...</div><br/></div></div><div id="36569175" class="c"><input type="checkbox" id="c-36569175" checked=""/><div class="controls bullet"><span class="by">Noumenon72</span><span>|</span><a href="#36568918">parent</a><span>|</span><a href="#36569398">prev</a><span>|</span><a href="#36569401">next</a><span>|</span><label class="collapse" for="c-36569175">[-]</label><label class="expand" for="c-36569175">[1 more]</label></div><br/><div class="children"><div class="content">In this context, I was expecting another unusual&#x2F;proficient implementation of FizzBuzz. I didn&#x27;t enjoy this story about someone who was asked FizzBuzz in an interview and didn&#x27;t think the position should require her to know that.</div><br/></div></div><div id="36569401" class="c"><input type="checkbox" id="c-36569401" checked=""/><div class="controls bullet"><span class="by">firesteelrain</span><span>|</span><a href="#36568918">parent</a><span>|</span><a href="#36569175">prev</a><span>|</span><a href="#36569849">next</a><span>|</span><label class="collapse" for="c-36569401">[-]</label><label class="expand" for="c-36569401">[1 more]</label></div><br/><div class="children"><div class="content">I love this story because I run across jobs all the time that sound great in the title and then you read the job description - it often sounds like a list of buzzwords or a combination of multiple people into one job. It’s like she says, they lumped everything into one position.</div><br/></div></div></div></div><div id="36569849" class="c"><input type="checkbox" id="c-36569849" checked=""/><div class="controls bullet"><span class="by">jagrsw</span><span>|</span><a href="#36568918">prev</a><span>|</span><label class="collapse" for="c-36569849">[-]</label><label class="expand" for="c-36569849">[1 more]</label></div><br/><div class="children"><div class="content">This exercise appears to be somewhat flawed, even if entertaining&#x2F;informative. Instead of evaluating the speed at which complex problems are resolved, it predominantly tests a peripheral issue: the efficiency of extracting memory from one process and transferring it to another. This allows for the illusion that the second process continues to write to a console&#x2F;file, even though, technically, it does not - executing pv &gt;&#x2F;dev&#x2F;null is essentially a no-op, as the write system call returns almost instantly.<p>vmsplice grants access to a process&#x27; buffer&#x2F;memory to another process - a shared mem equivalent. As the initial competition requirements are likely vague, I&#x27;d imagine it&#x27;s unclear if this is still good wrt the rules.</div><br/></div></div></div></div></div></div></div></body></html>