<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737622878780" as="style"/><link rel="stylesheet" href="styles.css?v=1737622878780"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://blog.vmchale.com/article/escardo-oliva-functional">A Proper x86 Assembler in Haskell Using the Escardó-Oliva Functional</a> <span class="domain">(<a href="http://blog.vmchale.com">blog.vmchale.com</a>)</span></div><div class="subtext"><span>Smaug123</span> | <span>18 comments</span></div><br/><div><div id="42802044" class="c"><input type="checkbox" id="c-42802044" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#42799335">next</a><span>|</span><label class="collapse" for="c-42802044">[-]</label><label class="expand" for="c-42802044">[1 more]</label></div><br/><div class="children"><div class="content">I know I might be barking up &quot;just a showcase&quot; tree, but what&#x27;s the memory complexity of this? E g. a nice property of multipass assemblers is that these only need to keep a list of symbols in the memory rather than the whole program. Not really a concern for modern systems with large memories, but then those neat haskell tricks usually carry some extra O(n)s - in addition to (avoidable) extra constant factors due to hidden linked lists and immutability. Aka the infamous haskell quicksort - much shorter and clear, but also not really a quicksort.</div><br/></div></div><div id="42799335" class="c"><input type="checkbox" id="c-42799335" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#42802044">prev</a><span>|</span><a href="#42801923">next</a><span>|</span><label class="collapse" for="c-42799335">[-]</label><label class="expand" for="c-42799335">[6 more]</label></div><br/><div class="children"><div class="content">One pass, but.. I&#x27;m willing to bet there is some transitional internal state which had to be looped over to do this, subsuming the &quot;pass&quot; inside lazy eval. You have to know the indeterminate &quot;where&quot; to jump to, which depends on subsequent state. So you preserve execution state, calculate on, and return at end to fill in the gaps.</div><br/><div id="42800983" class="c"><input type="checkbox" id="c-42800983" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#42799335">parent</a><span>|</span><a href="#42800696">next</a><span>|</span><label class="collapse" for="c-42800983">[-]</label><label class="expand" for="c-42800983">[1 more]</label></div><br/><div class="children"><div class="content">Yes - it&#x27;s pretty opaque to trace through, but you can see in `valid` that for a given move history, a &quot;good&quot; test is performed on each instruction in the assembly listing - a full pass. This is invoked, asymptotically at least, once per jump per level of the search tree explored in `bigotimes`. Each level &#x27;i&#x27; of the search tree has a history of `i` jumps decided to be short or near and branches &#x27;n-i&#x27; times; both of those average out to n&#x2F;2, so the tree searches n^2 nodes with each node doing &#x27;n&#x27; iterations over the list of instructions to check all jumps are valid, so the total running time is O(n^3).<p>(With some modifications to the code as shown, anyway: `lookup` is linear but used in such a way it can be replaced with a constant vector index, instruction lists can be compressed to just jumps &amp; labels with byte counts following, avoiding the duplicate invocations of `p` in `arginf`, etc).<p>I&#x27;d be dubious that there&#x27;s an algorithm to find the true minimum in less than cubic time, but there&#x27;s plenty of &quot;good enough&quot; approaches: most branches will be definitely short or definitely not; jumps backwards can be resolved when encountered; jumps forward can be written long and replaced with a short jump plus no-op padding when the target is encountered within short jump distance.</div><br/></div></div><div id="42800696" class="c"><input type="checkbox" id="c-42800696" checked=""/><div class="controls bullet"><span class="by">rhet0rica</span><span>|</span><a href="#42799335">parent</a><span>|</span><a href="#42800983">prev</a><span>|</span><a href="#42800652">next</a><span>|</span><label class="collapse" for="c-42800696">[-]</label><label class="expand" for="c-42800696">[2 more]</label></div><br/><div class="children"><div class="content">Yes, that seems to be what the aptly-named &quot;tardis&quot; monad does, but the article notes that it isn&#x27;t sufficient because of the minutiae of how jump instructions themselves can vary in length under x86.<p>In an act of brilliance that surely proves beyond all doubt that Haskell&#x27;s main reason for existing is to upstage the esolang scene, the author solves the problem by trotting out a special-purpose constraint satisfaction algorithm. (You can imagine what kind of computational complexity this implies. The creators of this algorithm note that it can enumerate all tic-tac-toe games in just over a second!)</div><br/><div id="42801485" class="c"><input type="checkbox" id="c-42801485" checked=""/><div class="controls bullet"><span class="by">asplake</span><span>|</span><a href="#42799335">root</a><span>|</span><a href="#42800696">parent</a><span>|</span><a href="#42800652">next</a><span>|</span><label class="collapse" for="c-42801485">[-]</label><label class="expand" for="c-42801485">[1 more]</label></div><br/><div class="children"><div class="content">Explanation here: <a href="https:&#x2F;&#x2F;kcsongor.github.io&#x2F;time-travel-in-haskell-for-dummies&#x2F;" rel="nofollow">https:&#x2F;&#x2F;kcsongor.github.io&#x2F;time-travel-in-haskell-for-dummie...</a></div><br/></div></div></div></div><div id="42800652" class="c"><input type="checkbox" id="c-42800652" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42799335">parent</a><span>|</span><a href="#42800696">prev</a><span>|</span><a href="#42801923">next</a><span>|</span><label class="collapse" for="c-42800652">[-]</label><label class="expand" for="c-42800652">[2 more]</label></div><br/><div class="children"><div class="content">That bigotimes function that it&#x27;s talking about is doing something like tree search with backtracking - lazy evaluation isn&#x27;t really relevant as far as I can see. I don&#x27;t think the statement that it&#x27;s &quot;one pass&quot; is meant to mean that it&#x27;s a closed form solution or something, the point is that you can write your code as plain single pass logic and this generic functional tool does the rest.</div><br/><div id="42800693" class="c"><input type="checkbox" id="c-42800693" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#42799335">root</a><span>|</span><a href="#42800652">parent</a><span>|</span><a href="#42801923">next</a><span>|</span><label class="collapse" for="c-42800693">[-]</label><label class="expand" for="c-42800693">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a showcase for Haskell and well worth reading. I should be less snide.<p>Nowadays &quot;multipass&quot; means Mila Jovovich but it used to mean &quot;another complex language with massive implications we deal with by divide-and-conquer-through-the-filesystem&quot; and in the case of the York ada compiler that was some amazing number like 10 or more passes.<p>There was a fashion for running your C instrumented and then recompiling it after runtime branch choice evidence was collected. I think the Dec Alpha OSF&#x2F;1 compiler did it optionally.</div><br/></div></div></div></div></div></div><div id="42801923" class="c"><input type="checkbox" id="c-42801923" checked=""/><div class="controls bullet"><span class="by">guerrilla</span><span>|</span><a href="#42799335">prev</a><span>|</span><a href="#42800716">next</a><span>|</span><label class="collapse" for="c-42801923">[-]</label><label class="expand" for="c-42801923">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this is a fun problem. This is where the majority of my work went when writing an x86-virus that lived in the NOP areas between functions. Compilers produced those blocks of NOPs after function bodies to make the following function addresses aligned to to 16-byte boundaries. I chained all of those cavities together with jumps, distributing as much code as would fit and then putting a jump to the next cavity at the end. The trick is that you could fit more instructions (3 more bytes?) if you had a shorter jump.<p>I still want to write my own assembler some day.</div><br/></div></div><div id="42800716" class="c"><input type="checkbox" id="c-42800716" checked=""/><div class="controls bullet"><span class="by">vdupras</span><span>|</span><a href="#42801923">prev</a><span>|</span><a href="#42799265">next</a><span>|</span><label class="collapse" for="c-42800716">[-]</label><label class="expand" for="c-42800716">[1 more]</label></div><br/><div class="children"><div class="content">Or you could just be pessimistic in your offset calculation and assume that all &quot;in between&quot; unconditional jumps are 5 bytes in length. I know I know, not proper. But I doubt that in real code, that simpler algo would make you miss a lot of opportunities for 2 bytes jumps.</div><br/></div></div><div id="42799265" class="c"><input type="checkbox" id="c-42799265" checked=""/><div class="controls bullet"><span class="by">netr0ute</span><span>|</span><a href="#42800716">prev</a><span>|</span><label class="collapse" for="c-42799265">[-]</label><label class="expand" for="c-42799265">[8 more]</label></div><br/><div class="children"><div class="content">This is basically irrelevant now that better ISAs like RISC-V have a fixed instruction length (2 or 4 bytes) so the fancy algorithm here isn&#x27;t necessary.</div><br/><div id="42801906" class="c"><input type="checkbox" id="c-42801906" checked=""/><div class="controls bullet"><span class="by">tliltocatl</span><span>|</span><a href="#42799265">parent</a><span>|</span><a href="#42799781">next</a><span>|</span><label class="collapse" for="c-42801906">[-]</label><label class="expand" for="c-42801906">[1 more]</label></div><br/><div class="children"><div class="content">Having fixed instruction length doesn&#x27;t make the need to load large constants magically disappear. These just get split between multiple instructions. If anything, RISC-V might be worse. See also <a href="https:&#x2F;&#x2F;maskray.me&#x2F;blog&#x2F;2021-03-14-the-dark-side-of-riscv-linker-relaxation" rel="nofollow">https:&#x2F;&#x2F;maskray.me&#x2F;blog&#x2F;2021-03-14-the-dark-side-of-riscv-li...</a>.</div><br/></div></div><div id="42799781" class="c"><input type="checkbox" id="c-42799781" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#42799265">parent</a><span>|</span><a href="#42801906">prev</a><span>|</span><a href="#42800624">next</a><span>|</span><label class="collapse" for="c-42799781">[-]</label><label class="expand" for="c-42799781">[1 more]</label></div><br/><div class="children"><div class="content">That fancy algorithm is relevant to RISC-V (and in fact, most fixed-length ISAs) because loading an immediate into a register needs one or two instructions depending on the immediate; you surely want to elide a redundant LUI instruction if you can. Of course such redundant instructions don&#x27;t harm by itself, but that equally applies to x86 as the algorithm <i>is</i> an optimization.</div><br/></div></div><div id="42800624" class="c"><input type="checkbox" id="c-42800624" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#42799265">parent</a><span>|</span><a href="#42799781">prev</a><span>|</span><a href="#42799324">next</a><span>|</span><label class="collapse" for="c-42800624">[-]</label><label class="expand" for="c-42800624">[1 more]</label></div><br/><div class="children"><div class="content">This same problem applies to RISC-V with the C extension, because the J and JAL instructions have a larger range than the C.J and C.JAL instructions.</div><br/></div></div><div id="42799324" class="c"><input type="checkbox" id="c-42799324" checked=""/><div class="controls bullet"><span class="by">Coolbeanstoo</span><span>|</span><a href="#42799265">parent</a><span>|</span><a href="#42800624">prev</a><span>|</span><a href="#42799369">next</a><span>|</span><label class="collapse" for="c-42799324">[-]</label><label class="expand" for="c-42799324">[3 more]</label></div><br/><div class="children"><div class="content">As a result of RISC-V existing, all x86 processors have ceased to exist or be produced.</div><br/><div id="42800799" class="c"><input type="checkbox" id="c-42800799" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#42799265">root</a><span>|</span><a href="#42799324">parent</a><span>|</span><a href="#42799369">next</a><span>|</span><label class="collapse" for="c-42800799">[-]</label><label class="expand" for="c-42800799">[2 more]</label></div><br/><div class="children"><div class="content">Accurate, if said sometime in the future rather than today.</div><br/><div id="42801994" class="c"><input type="checkbox" id="c-42801994" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42799265">root</a><span>|</span><a href="#42800799">parent</a><span>|</span><a href="#42799369">next</a><span>|</span><label class="collapse" for="c-42801994">[-]</label><label class="expand" for="c-42801994">[1 more]</label></div><br/><div class="children"><div class="content">There are still people making z80 machines today, so no.</div><br/></div></div></div></div></div></div><div id="42799369" class="c"><input type="checkbox" id="c-42799369" checked=""/><div class="controls bullet"><span class="by">nicebyte</span><span>|</span><a href="#42799265">parent</a><span>|</span><a href="#42799324">prev</a><span>|</span><label class="collapse" for="c-42799369">[-]</label><label class="expand" for="c-42799369">[1 more]</label></div><br/><div class="children"><div class="content">ARM would have been a better example because the amount of people that care about RISC-V is a rounding error compared to x86 or ARM.</div><br/></div></div></div></div></div></div></div></div></div></body></html>