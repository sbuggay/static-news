<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696755677368" as="style"/><link rel="stylesheet" href="styles.css?v=1696755677368"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gilmi.me/blog/post/2023/10/05/haskell-alternative-frontend">An alternative front end for Haskell?</a> <span class="domain">(<a href="https://gilmi.me">gilmi.me</a>)</span></div><div class="subtext"><span>amalinovic</span> | <span>46 comments</span></div><br/><div><div id="37805740" class="c"><input type="checkbox" id="c-37805740" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#37805881">next</a><span>|</span><label class="collapse" for="c-37805740">[-]</label><label class="expand" for="c-37805740">[14 more]</label></div><br/><div class="children"><div class="content">Most of the comments so far are negative, so I&#x27;ll add something positive. One thing I love about the Haskell community is how they are always questioning their assumptions and genuinely seeking the best way to do things (often drawing upon or contributing to computer science research). The core concepts behind Haskell are clean and simple (essentially something between System F and System Fω), but there&#x27;s a lot of baggage on the surface that obscures that underlying elegance. We should encourage people taking an introspective look into their tools and asking how they can be better, even if certain proposals are unrealistic or controversial.<p>I think the author is just writing down their opinions (which are worth discussing!) and not seriously trying to start a new GHC frontend. Personally, I think Haskell is approximately stuck in a local maximum, which can only be escaped by embracing dependent types (which are actually simpler than where Haskell has been heading) rather than building increasingly complex approximations of them. Once you try a dependently typed language like Agda, Lean, Coq, or Idris, it&#x27;s hard to go back to the complexity of having two (or more!) separate languages for types and programs.<p>Regarding the proposals in the article, the most interesting to me is (2), although I&#x27;m not sure about some of the specifics. In general, I think Haskell needs a way to graduate (or retire) language extensions, rather than having them accumulate unboundedly. It&#x27;s harder to talk about Haskell when everyone is using a different flavor of it.</div><br/><div id="37805997" class="c"><input type="checkbox" id="c-37805997" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#37805740">parent</a><span>|</span><a href="#37806913">next</a><span>|</span><label class="collapse" for="c-37805997">[-]</label><label class="expand" for="c-37805997">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Personally, I think Haskell is approximately stuck in a local maximum, which can only be escaped by embracing dependent types<p>To give a counter point, there seem to be lots of small wins that aren&#x27;t taken, possibly in part <i>because</i> people seem to wait for the big ideas.<p>Take partial functions like head: You can do what Haskell and Java do and throw an exception. Or you can have dependent types and statically prevent the function from being applied to an empty list. But the obvious and easy solution in the current language would be to return Maybe, which isn&#x27;t done because there&#x27;s a feeling that it&#x27;s not a big enough step to be worth the effort, and dependent types will eventually solve this anyway.</div><br/><div id="37808938" class="c"><input type="checkbox" id="c-37808938" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#37805740">root</a><span>|</span><a href="#37805997">parent</a><span>|</span><a href="#37806479">next</a><span>|</span><label class="collapse" for="c-37808938">[-]</label><label class="expand" for="c-37808938">[1 more]</label></div><br/><div class="children"><div class="content">I recently got into an argument with someone who insisted that since “undefined” could be considered “non-terminating” there was nothing wrong with the current behaviour.</div><br/></div></div><div id="37806479" class="c"><input type="checkbox" id="c-37806479" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#37805740">root</a><span>|</span><a href="#37805997">parent</a><span>|</span><a href="#37808938">prev</a><span>|</span><a href="#37806338">next</a><span>|</span><label class="collapse" for="c-37806479">[-]</label><label class="expand" for="c-37806479">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But the obvious and easy solution in the current language would be to return Maybe, which isn&#x27;t done because there&#x27;s a feeling that it&#x27;s not a big enough step to be worth the effort, and dependent types will eventually solve this anyway.<p>That&#x27;s not why it&#x27;s not done.  listToMaybe already exists[1] and you can&#x27;t change the type of head without breaking everyone&#x27;s code, so head in the next version of base will come with a warning[2] and that&#x27;s about as much as you can do whilst still maintaining backwards compatibility.<p>[1] <a href="https:&#x2F;&#x2F;www.stackage.org&#x2F;haddock&#x2F;lts-21.14&#x2F;base-4.17.2.0&#x2F;Data-Maybe.html#v:listToMaybe" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.stackage.org&#x2F;haddock&#x2F;lts-21.14&#x2F;base-4.17.2.0&#x2F;Dat...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;haskell&#x2F;core-libraries-committee&#x2F;issues&#x2F;87">https:&#x2F;&#x2F;github.com&#x2F;haskell&#x2F;core-libraries-committee&#x2F;issues&#x2F;8...</a></div><br/></div></div><div id="37806338" class="c"><input type="checkbox" id="c-37806338" checked=""/><div class="controls bullet"><span class="by">yakubin</span><span>|</span><a href="#37805740">root</a><span>|</span><a href="#37805997">parent</a><span>|</span><a href="#37806479">prev</a><span>|</span><a href="#37807604">next</a><span>|</span><label class="collapse" for="c-37806338">[-]</label><label class="expand" for="c-37806338">[2 more]</label></div><br/><div class="children"><div class="content">In cases when head is used though, you clearly just want to unpack the first element of a list. So if you replace head with a function that returns a Maybe, all you’re going to do is pattern match on its result to check if it’s a Just. So I don’t see a benefit over matching x::_ against the list straight away.<p>(I do see how a function like that is useful, but I don’t think it’s a good replacement for head.)</div><br/><div id="37808793" class="c"><input type="checkbox" id="c-37808793" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#37805740">root</a><span>|</span><a href="#37806338">parent</a><span>|</span><a href="#37807604">next</a><span>|</span><label class="collapse" for="c-37808793">[-]</label><label class="expand" for="c-37808793">[1 more]</label></div><br/><div class="children"><div class="content">Some people think that if you don&#x27;t throw exceptions then you don&#x27;t have to bother dealing with errors. ¯\_(ツ)_&#x2F;¯</div><br/></div></div></div></div><div id="37807604" class="c"><input type="checkbox" id="c-37807604" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#37805740">root</a><span>|</span><a href="#37805997">parent</a><span>|</span><a href="#37806338">prev</a><span>|</span><a href="#37806081">next</a><span>|</span><label class="collapse" for="c-37807604">[-]</label><label class="expand" for="c-37807604">[1 more]</label></div><br/><div class="children"><div class="content">Liquid Haskell solves the head problem as well as DTs - and it&#x27;s available as a plugin. You can literally use Liquid types as easily as any library.</div><br/></div></div><div id="37806081" class="c"><input type="checkbox" id="c-37806081" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#37805740">root</a><span>|</span><a href="#37805997">parent</a><span>|</span><a href="#37807604">prev</a><span>|</span><a href="#37806913">next</a><span>|</span><label class="collapse" for="c-37806081">[-]</label><label class="expand" for="c-37806081">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting counterpoint, but I think it&#x27;s a bit of a different tradeoff. Adding, say, dependent types, can be done as a gradual process with opt-in (via language extensions) and &quot;only&quot; requires heroic effort on the part of the compiler writers... whereas changing &#x27;head&#x27; requires 10000i Hackage packages to update their code.<p>This is all tied into how inflexible the base&#x2F;Prelude story is currently, etc. If the Prelude were a fully independent library where you could just depend on any old version you like, then there&#x27;d be no problem changing the signature. (Other than the usual diamond dependency problems). Of course you can choose NoPrelude and go from there, but then you&#x27;re already in a place where changing &#x27;head&#x27; doesn&#x27;t matter to you, only the maintainer of your alternative Prelude.<p>People are working on both of these aspects, and that&#x27;s got me really excited about where Haskell is going these days!<p>(I&#x27;ve always loved Haskell as a language, but there have been undeniable ecosystem issues.)</div><br/></div></div></div></div><div id="37806913" class="c"><input type="checkbox" id="c-37806913" checked=""/><div class="controls bullet"><span class="by">LeanderK</span><span>|</span><a href="#37805740">parent</a><span>|</span><a href="#37805997">prev</a><span>|</span><a href="#37806037">next</a><span>|</span><label class="collapse" for="c-37806913">[-]</label><label class="expand" for="c-37806913">[2 more]</label></div><br/><div class="children"><div class="content">&gt; embracing dependent types (which are actually simpler than where Haskell has been heading) rather than building increasingly complex approximations of them<p>very much second that! haskell has band-aid type-level programming that is so awful, but sometimes so useful, that it&#x27;s really hurting a lot. I would just really like to deprecate type-families and would like to see as a the first step some non-dependently typed type-promoted functions. There&#x27;s a great, pragmatic, proposal I would really like to see implemented. I, personally, don&#x27;t need dependent types thaaaaaat much but type families are so unergonomic and really a dead-end I think. It&#x27;s just stupid.<p>it&#x27;s sad to see that the dependent haskell progress is losing steam and, as it is my impression, getting maybe a bit lost in the weeds?</div><br/><div id="37807602" class="c"><input type="checkbox" id="c-37807602" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#37805740">root</a><span>|</span><a href="#37806913">parent</a><span>|</span><a href="#37806037">next</a><span>|</span><label class="collapse" for="c-37807602">[-]</label><label class="expand" for="c-37807602">[1 more]</label></div><br/><div class="children"><div class="content">DTs aren&#x27;t losing steam at all. There are people chugging along implementing them.</div><br/></div></div></div></div><div id="37806037" class="c"><input type="checkbox" id="c-37806037" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#37805740">parent</a><span>|</span><a href="#37806913">prev</a><span>|</span><a href="#37806982">next</a><span>|</span><label class="collapse" for="c-37806037">[-]</label><label class="expand" for="c-37806037">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think Haskell needs a way to graduate (or retire) language extensions, rather than having them accumulate unboundedly. It&#x27;s harder to talk about Haskell when everyone is using a different flavor of it.<p>That is what the standardization process is for. I don&#x27;t think that the parties that could write a new Haskell standard have the time, resources, or bandwidth to work on one. That&#x27;s why for now we&#x27;re stuck with 98, 2010 and a bunch of extensions.</div><br/></div></div><div id="37806982" class="c"><input type="checkbox" id="c-37806982" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#37805740">parent</a><span>|</span><a href="#37806037">prev</a><span>|</span><a href="#37806492">next</a><span>|</span><label class="collapse" for="c-37806982">[-]</label><label class="expand" for="c-37806982">[2 more]</label></div><br/><div class="children"><div class="content">I really like the Haskell that goes easy on the dependent-type sort of stuff: and I say that as someone who has been on-call for Sigma (which is like, top 3 industrial use cases).<p>It’s just really, really expressive without trying to solve the halting problem via some unification failure mode.<p>Type classes and GADTs already give you 10x the canvas you can get without trouble anywhere else, and if you keep it tight, you have the tooling to really tune it up.<p>Idris is awesome, do that if you’re doing that. Haskell is changing all the time: it became a serious production tool: I’d really like for it to stay one.</div><br/><div id="37808598" class="c"><input type="checkbox" id="c-37808598" checked=""/><div class="controls bullet"><span class="by">nyssos</span><span>|</span><a href="#37805740">root</a><span>|</span><a href="#37806982">parent</a><span>|</span><a href="#37806492">next</a><span>|</span><label class="collapse" for="c-37808598">[-]</label><label class="expand" for="c-37808598">[1 more]</label></div><br/><div class="children"><div class="content">Haskell&#x27;s current dependent typing is expressive, but also painful to use and almost impossible to debug. The main thing I want out of dependent Haskell isn&#x27;t more power (though I wouldn&#x27;t turn it down), it&#x27;s the ability to write type-level Haskell like Haskell instead of some early Prolog prototype.</div><br/></div></div></div></div><div id="37806492" class="c"><input type="checkbox" id="c-37806492" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#37805740">parent</a><span>|</span><a href="#37806982">prev</a><span>|</span><a href="#37805881">next</a><span>|</span><label class="collapse" for="c-37806492">[-]</label><label class="expand" for="c-37806492">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think Haskell needs a way to graduate (or retire) language extensions<p>That sounds like the Extension lifecycle framework proposal <a href="https:&#x2F;&#x2F;github.com&#x2F;ghc-proposals&#x2F;ghc-proposals&#x2F;pull&#x2F;601">https:&#x2F;&#x2F;github.com&#x2F;ghc-proposals&#x2F;ghc-proposals&#x2F;pull&#x2F;601</a></div><br/></div></div></div></div><div id="37805881" class="c"><input type="checkbox" id="c-37805881" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#37805740">prev</a><span>|</span><a href="#37807836">next</a><span>|</span><label class="collapse" for="c-37805881">[-]</label><label class="expand" for="c-37805881">[12 more]</label></div><br/><div class="children"><div class="content">Many of these address &quot;paper cuts&quot;. Individually, they aren&#x27;t huge issues. But lots of small annoyances can easily add up and make a language not fun to use, and especially punishing for beginners. That&#x27;s why some language communities prioritize fixing such paper cut problems. The Haskell community mostly doesn&#x27;t seem to.<p>Another minor thing that happens to annoy me very much is how everything about Haskell&#x27;s syntax and standard conventions is so diff-unfriendly.<p>To see what I mean, I picked the first &quot;official&quot; example I could find. Here are a few lines of code from the one of the  examples in the Haskell playground (<a href="https:&#x2F;&#x2F;play.haskell.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;play.haskell.org&#x2F;</a> -- it seems to pick a random one each time you load it):<p><pre><code>    data Visitor
      = Member Profile
      | NonMember (Maybe T.Text)
      deriving Show

    data Profile =
      Profile
        { name :: T.Text
        , birthday :: Time.Day
        } deriving Show
</code></pre>
You see Haskell code like this all the time, and the (IMO old-fashioned) lack of an optional trailing comma practically forces you into something like this. But just imagine inserting another variant to Visitor before Member, or removing the name field from Profile!<p>A more practically minded language might allow a syntax like this:<p><pre><code>    data Visitor =
      | Member Profile
      | NonMember (Maybe T.Text)
      deriving Show

    data Profile = Profile {
        name :: T.Text,
        birthday :: Time.Day,
    } deriving Show
</code></pre>
Bamm, each line is identical, editing is easy, diffs are clean. TypeScript, for example, has something like this for union types. Haskell unfortunately doesn&#x27;t.</div><br/><div id="37806162" class="c"><input type="checkbox" id="c-37806162" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#37805881">parent</a><span>|</span><a href="#37806858">next</a><span>|</span><label class="collapse" for="c-37806162">[-]</label><label class="expand" for="c-37806162">[7 more]</label></div><br/><div class="children"><div class="content">This resonates quite strongly with me.<p>Back when I first learned Haskell, I strongly got the impression that the Haskell community just... didn&#x27;t like programming? I kept running into endless papercuts like these, language extensions which were poorly documented and mutually incompatible but basically mandatory due to widespread usage, and libraries which were considered &quot;top-of-the-line&quot; but where anything beyond the happy path was considered an open research topic.<p>All in all, it felt more like a loose collection of unfinished PhD theses than an actual programming language. Which is a real shame, because it has quite a few <i>excellent</i> concepts which are a genuine pleasure to use. Unfortunately I think languages like Rust and F# are essentially killing any chance it has at gaining a mainstream foothold: they bring over enough of the good parts of Haskell into mainstream programming that it simply isn&#x27;t worth having to deal with the bad parts anymore.</div><br/><div id="37808448" class="c"><input type="checkbox" id="c-37808448" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#37805881">root</a><span>|</span><a href="#37806162">parent</a><span>|</span><a href="#37806509">next</a><span>|</span><label class="collapse" for="c-37808448">[-]</label><label class="expand" for="c-37808448">[1 more]</label></div><br/><div class="children"><div class="content">Personally I think of Haskell the same way I think of C++ in terms of language features. There are so many and so much to choose from that there should be one person in every company that has simply decided that the company uses <i>this</i> particular subset and that&#x27;s it, pending very detailed and well-motived discussions in the future, but at a snail&#x27;s pace.<p>In my particular case I would also prefer for that subset to be chosen with a conservative and considerably less PLT-enthusiastic mindset, i.e. bog standard `RIO` style that prefers imperative code working on bags of mutable values of different types when solving problems.<p>But yeah, Haskell is a wide language and that&#x27;s why it&#x27;s so hard to adopt. People tend to learn ostensibly the wrong things, oftentimes from people who&#x27;ve never actually written any real production code but like to theorize and hypothesize about &quot;the best pattern for X&quot; and so on.</div><br/></div></div><div id="37806509" class="c"><input type="checkbox" id="c-37806509" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#37805881">root</a><span>|</span><a href="#37806162">parent</a><span>|</span><a href="#37808448">prev</a><span>|</span><a href="#37806702">next</a><span>|</span><label class="collapse" for="c-37806509">[-]</label><label class="expand" for="c-37806509">[4 more]</label></div><br/><div class="children"><div class="content">&gt; language extensions which were poorly documented and mutually incompatible<p>I often hear complaints about mutually incompatible language extensions, but when I aske I hardly ever find anyone who can name two!  Can you?</div><br/><div id="37806744" class="c"><input type="checkbox" id="c-37806744" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#37805881">root</a><span>|</span><a href="#37806509">parent</a><span>|</span><a href="#37806702">next</a><span>|</span><label class="collapse" for="c-37806744">[-]</label><label class="expand" for="c-37806744">[3 more]</label></div><br/><div class="children"><div class="content">One thing GP may be thinking of is the multitude of deriving-related extensions. For example when DeriveAnyClass and GeneralizedNewtypeDeriving are turned on simultaneously, the latter often doesn&#x27;t work due to GHC silently picking the former on a newtype when both could be used. This particular annoyance has been fixed by a new extension, DerivingStrategies. Until this, it&#x27;s impossible to turn on both extensions in a single module and have some newtypes derive some classes using one and some using the other.<p>I can&#x27;t think of anything else that could be incompatible. I would also disagree GP&#x27;s claim that extensions are poorly documented. GHC is very well documented, including all its extensions.</div><br/><div id="37807153" class="c"><input type="checkbox" id="c-37807153" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#37805881">root</a><span>|</span><a href="#37806744">parent</a><span>|</span><a href="#37806702">next</a><span>|</span><label class="collapse" for="c-37807153">[-]</label><label class="expand" for="c-37807153">[2 more]</label></div><br/><div class="children"><div class="content">I believe that is <i>exactly</i> the one I ran into.<p>One library required DeriveAnyClass, another library required GeneralizedNewtypeDeriving. I couldn&#x27;t enable both into one file at once, and I couldn&#x27;t split the definition into two files. In other words: you&#x27;re screwed. DerivingStrategies solved this, but that came out <i>years</i> after the problem started.<p>As to the &quot;poorly documented&quot;:<p>I believe at the time neither the docs for DeriveAnyClass nor those for GeneralizedNewtypeDeriving mentioned the issue even existed, let alone a potential workaround.<p>A lot of other extensions have documentation written for computer scientists, not for programmers who just want to use it. It was not unusual for me to end up enabling an extension because some library required it, opening up the docs and having literally zero clue what was going on, and just end up copy&#x2F;pasting the example code and praying it worked.<p>Extensions like OverloadedLists are totally fine, but once you get beyond the &quot;Syntax&quot; section the docs quickly become unreadable for most people not actively researching programming languages. It&#x27;s not unusual for the docs here to start with &quot;more details can be found in the paper XYZ&quot;, and be filled with terminology which is neither explained in-place nor have a link to an explanation.<p>When I read docs, I quickly want to know 1) what it is 2) why it is needed 3) how I can use it 4) what the implications are. From my personal experience, the GHC docs simply do not provide me with these.</div><br/><div id="37808434" class="c"><input type="checkbox" id="c-37808434" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#37805881">root</a><span>|</span><a href="#37807153">parent</a><span>|</span><a href="#37806702">next</a><span>|</span><label class="collapse" for="c-37808434">[-]</label><label class="expand" for="c-37808434">[1 more]</label></div><br/><div class="children"><div class="content">OK, fair enough that these two <i>were</i> incompatible, but I think your earlier statement is really misleading!<p>&gt; language extensions which were poorly documented and mutually incompatible but basically mandatory due to widespread usage<p>Neither DeriveAnyClass nor GeneralizedNewtypeDeriving is basically mandatory, and this problem only existed between the introduction of the latter in 2015 and the introduction of deriving strategies is 2017.<p>It&#x27;s definitely fair to say there&#x27;s a lot of crufty stuff in the Haskell world (there&#x27;s also a lot of crufty stuff in the ecosystem of any other language I&#x27;ve used) but I think you really overstated the case.</div><br/></div></div></div></div></div></div></div></div><div id="37806702" class="c"><input type="checkbox" id="c-37806702" checked=""/><div class="controls bullet"><span class="by">zainhoda</span><span>|</span><a href="#37805881">root</a><span>|</span><a href="#37806162">parent</a><span>|</span><a href="#37806509">prev</a><span>|</span><a href="#37806858">next</a><span>|</span><label class="collapse" for="c-37806702">[-]</label><label class="expand" for="c-37806702">[1 more]</label></div><br/><div class="children"><div class="content">&gt; All in all, it felt more like a loose collection of unfinished PhD theses than an actual programming language.<p>Yeah, to me Haskell is the experimental forefront of programming language theory and the most developed concepts get incorporated into the actual programming languages over time.</div><br/></div></div></div></div><div id="37806858" class="c"><input type="checkbox" id="c-37806858" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#37805881">parent</a><span>|</span><a href="#37806162">prev</a><span>|</span><a href="#37807836">next</a><span>|</span><label class="collapse" for="c-37806858">[-]</label><label class="expand" for="c-37806858">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  the (IMO old-fashioned) lack of an optional trailing comma<p>I’ll note that in Haskell circles, the usual proposal is a <i>leading</i> comma, which would look like this:<p><pre><code>    data Profile =
      Profile {
        , name :: T.Text
        , birthday :: Time.Day
        } deriving Show
</code></pre>
The commas essentially end up like bullets — a style I thoroughly like.</div><br/><div id="37807047" class="c"><input type="checkbox" id="c-37807047" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#37805881">root</a><span>|</span><a href="#37806858">parent</a><span>|</span><a href="#37807836">next</a><span>|</span><label class="collapse" for="c-37807047">[-]</label><label class="expand" for="c-37807047">[3 more]</label></div><br/><div class="children"><div class="content">Your syntax is incorrect, it should be<p><pre><code>    data Profile =
      Profile
        { name :: T.Text
        , birthday :: Time.Day
        } deriving Show
</code></pre>
(You can&#x27;t write `,` directly after `{`.)<p>This is also why the commas are _not_ like bullets, no matter how you format them. The first one is always special.<p>I agree that somebody should make a language extension that allows what the parent posts says.<p>Doing this does not need a language split &#x2F; new frontend; this is what language extensions do very well. If they are popuplar, they become part of a new (de-facto) standard, such as GHC2021: <a href="https:&#x2F;&#x2F;ghc.gitlab.haskell.org&#x2F;ghc&#x2F;doc&#x2F;users_guide&#x2F;exts&#x2F;control.html#extension-GHC2021" rel="nofollow noreferrer">https:&#x2F;&#x2F;ghc.gitlab.haskell.org&#x2F;ghc&#x2F;doc&#x2F;users_guide&#x2F;exts&#x2F;cont...</a><p>And there is precedent for this: There is one place where trailing commas for good diffability are already allowed: Module exports.<p><pre><code>    module MyModule (
      fun1,
      fun2,
      main,
    ) where
</code></pre>
Many language extensions exist to remove such &quot;papercuts&quot;; this looks like a good candidate.</div><br/><div id="37808489" class="c"><input type="checkbox" id="c-37808489" checked=""/><div class="controls bullet"><span class="by">poorlyknit</span><span>|</span><a href="#37805881">root</a><span>|</span><a href="#37807047">parent</a><span>|</span><a href="#37807899">next</a><span>|</span><label class="collapse" for="c-37808489">[-]</label><label class="expand" for="c-37808489">[1 more]</label></div><br/><div class="children"><div class="content">The comment you&#x27;re replying to refers to the fact that<p><pre><code>    the usual proposal is a leading comma
</code></pre>
You&#x27;re right that it&#x27;s not valid Haskell but that wasn&#x27;t the goal here.</div><br/></div></div><div id="37807899" class="c"><input type="checkbox" id="c-37807899" checked=""/><div class="controls bullet"><span class="by">mjan22640</span><span>|</span><a href="#37805881">root</a><span>|</span><a href="#37807047">parent</a><span>|</span><a href="#37808489">prev</a><span>|</span><a href="#37807836">next</a><span>|</span><label class="collapse" for="c-37807899">[-]</label><label class="expand" for="c-37807899">[1 more]</label></div><br/><div class="children"><div class="content">When breaking an expression into multiple lines, it is best to place an operator at the start of a line.</div><br/></div></div></div></div></div></div></div></div><div id="37807836" class="c"><input type="checkbox" id="c-37807836" checked=""/><div class="controls bullet"><span class="by">aranchelk</span><span>|</span><a href="#37805881">prev</a><span>|</span><a href="#37805674">next</a><span>|</span><label class="collapse" for="c-37807836">[-]</label><label class="expand" for="c-37807836">[1 more]</label></div><br/><div class="children"><div class="content">A plug for PureScript:<p>Haskell-like syntax, row polymorphism, nice interface for records. Warts removed from standard libraries. Everything is a total function, but otherwise names and type signatures will be very familiar. Strict evaluation. The primary compile targets is JavaScript, second most popular is Erlang. Excellent FFI.</div><br/></div></div><div id="37805674" class="c"><input type="checkbox" id="c-37805674" checked=""/><div class="controls bullet"><span class="by">frou_dh</span><span>|</span><a href="#37807836">prev</a><span>|</span><a href="#37805529">next</a><span>|</span><label class="collapse" for="c-37805674">[-]</label><label class="expand" for="c-37805674">[1 more]</label></div><br/><div class="children"><div class="content">Tried with OCaml, multiple times, and they all withered away and practically everyone is back to using normal OCaml syntax.<p>(I&#x27;m not only talking about ReasonML, Reason, ReScript etc. There was a more officially proposed revised syntax too: <a href="https:&#x2F;&#x2F;caml.inria.fr&#x2F;pub&#x2F;old_caml_site&#x2F;camlp4&#x2F;tutorial&#x2F;tutorial005.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;caml.inria.fr&#x2F;pub&#x2F;old_caml_site&#x2F;camlp4&#x2F;tutorial&#x2F;tuto...</a>)</div><br/></div></div><div id="37805529" class="c"><input type="checkbox" id="c-37805529" checked=""/><div class="controls bullet"><span class="by">chpatrick</span><span>|</span><a href="#37805674">prev</a><span>|</span><a href="#37807772">next</a><span>|</span><label class="collapse" for="c-37805529">[-]</label><label class="expand" for="c-37805529">[2 more]</label></div><br/><div class="children"><div class="content">These are by far not the biggest problems with Haskell and splitting the language will definitely not help.</div><br/><div id="37806575" class="c"><input type="checkbox" id="c-37806575" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#37805529">parent</a><span>|</span><a href="#37807772">next</a><span>|</span><label class="collapse" for="c-37806575">[-]</label><label class="expand" for="c-37806575">[1 more]</label></div><br/><div class="children"><div class="content">It does seem like coffeescriptification. I would argue the way to tidy up Haskell is<p>1. decide on a decent non GHC extended standard. (maybe the last one was good enough? not been following)<p>2. build out a decent standard library to cover all the usual things from datetime handling to web serving without using GHC extensions<p>Then let everyone use that<p>Even better have a JVM&#x2F;CLR type target for syntax experimentation. I think they have this already.</div><br/></div></div></div></div><div id="37807772" class="c"><input type="checkbox" id="c-37807772" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#37805529">prev</a><span>|</span><a href="#37805346">next</a><span>|</span><label class="collapse" for="c-37807772">[-]</label><label class="expand" for="c-37807772">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Remove tuples - use records instead.<p>Seriously? Mainstream languages are busy adding tuples because they make code so much cleaner when used appropriately. Leaving them out of Simple Haskell™ would be a big mistake, IMHO.</div><br/><div id="37808586" class="c"><input type="checkbox" id="c-37808586" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#37807772">parent</a><span>|</span><a href="#37805346">next</a><span>|</span><label class="collapse" for="c-37808586">[-]</label><label class="expand" for="c-37808586">[1 more]</label></div><br/><div class="children"><div class="content">Yes this appears to be a silly suggestion, tuples are everywhere, especially as arguments for functions where it does not make sense to name the fields. They are also a structural type and records in Haskell are, unfortunately, nominal types.
If Haskell records were structural (one would use newtype to make a nominal record), then tuples could be syntactic sugar for a structural record with field names 1, 2 etc. There is value in unifying them with records, but we still need them.</div><br/></div></div></div></div><div id="37805346" class="c"><input type="checkbox" id="c-37805346" checked=""/><div class="controls bullet"><span class="by">thealistra</span><span>|</span><a href="#37807772">prev</a><span>|</span><a href="#37807582">next</a><span>|</span><label class="collapse" for="c-37805346">[-]</label><label class="expand" for="c-37805346">[2 more]</label></div><br/><div class="children"><div class="content">Just an opinionated bunch of changes. Some of them I really hate. Some of them I don’t care.<p>This should really by going though proposals 1 by 1. Not as a features-someone-likes.<p>Cons list syntax is the worst proposal</div><br/><div id="37805454" class="c"><input type="checkbox" id="c-37805454" checked=""/><div class="controls bullet"><span class="by">sparkie</span><span>|</span><a href="#37805346">parent</a><span>|</span><a href="#37807582">next</a><span>|</span><label class="collapse" for="c-37805454">[-]</label><label class="expand" for="c-37805454">[1 more]</label></div><br/><div class="children"><div class="content">Instead of the cons proposal, should just make the `(:)` operator work on ListLike[1] instead of only built in lists.<p>[1]:<a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;ListLike-4.7.8&#x2F;docs&#x2F;Data-ListLike.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;ListLike-4.7.8&#x2F;docs&#x2F;Data...</a></div><br/></div></div></div></div><div id="37807582" class="c"><input type="checkbox" id="c-37807582" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#37805346">prev</a><span>|</span><a href="#37807150">next</a><span>|</span><label class="collapse" for="c-37807582">[-]</label><label class="expand" for="c-37807582">[1 more]</label></div><br/><div class="children"><div class="content">A breaking chance in the frontend could be provided as a language extension. Some years later, it could be made the new default, and the old model would have to be explicitly enabled via one of the older omnibus extensions like `Haskell2021`. In the best case, the breaking changes are unambiguous and can be be automated via a rewrite tool.</div><br/></div></div><div id="37807150" class="c"><input type="checkbox" id="c-37807150" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#37807582">prev</a><span>|</span><a href="#37805355">next</a><span>|</span><label class="collapse" for="c-37807150">[-]</label><label class="expand" for="c-37807150">[5 more]</label></div><br/><div class="children"><div class="content">I like the change of $ to &lt;|<p>Dollar signs are so noisy and opaque.</div><br/><div id="37808860" class="c"><input type="checkbox" id="c-37808860" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#37807150">parent</a><span>|</span><a href="#37807761">next</a><span>|</span><label class="collapse" for="c-37808860">[-]</label><label class="expand" for="c-37808860">[1 more]</label></div><br/><div class="children"><div class="content">My biggest syntax gripe since starting out with Haskell is needing to introduce &#x27;$&#x27; at some point during a chain of &#x27;.&#x27;:<p><pre><code>    mySet

    toList mySet

    reverse . toList mySet

    reverse . toList $ mySet
</code></pre>
The first three look pleasing to the eye, but the fourth is ugly.  I want to write the third one, not the fourth.</div><br/></div></div><div id="37807761" class="c"><input type="checkbox" id="c-37807761" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#37807150">parent</a><span>|</span><a href="#37808860">prev</a><span>|</span><a href="#37807611">next</a><span>|</span><label class="collapse" for="c-37807761">[-]</label><label class="expand" for="c-37807761">[2 more]</label></div><br/><div class="children"><div class="content">This is what F# uses (as well as |&gt;, &gt;&gt;, and &lt;&lt;), and I like it a lot. It&#x27;s consistent and intuitive pattern. Every time I read Haskell, it takes extra effort to read . and $ instead.</div><br/><div id="37808529" class="c"><input type="checkbox" id="c-37808529" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#37807150">root</a><span>|</span><a href="#37807761">parent</a><span>|</span><a href="#37807611">next</a><span>|</span><label class="collapse" for="c-37808529">[-]</label><label class="expand" for="c-37808529">[1 more]</label></div><br/><div class="children"><div class="content">I do think that it would be useful for the community at large to move onto `&amp;` more (as that is what `|&gt;` actually is), together with `&gt;&gt;&gt;` for forward function composition. Certainly I think it flows better with the rest of the language, which is predominantly read left-to-right and downwards.</div><br/></div></div></div></div><div id="37807611" class="c"><input type="checkbox" id="c-37807611" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#37807150">parent</a><span>|</span><a href="#37807761">prev</a><span>|</span><a href="#37805355">next</a><span>|</span><label class="collapse" for="c-37807611">[-]</label><label class="expand" for="c-37807611">[1 more]</label></div><br/><div class="children"><div class="content">You can already never use $ and use &lt;| instead. Nothing is making you use $</div><br/></div></div></div></div><div id="37805355" class="c"><input type="checkbox" id="c-37805355" checked=""/><div class="controls bullet"><span class="by">temp123789246</span><span>|</span><a href="#37807150">prev</a><span>|</span><a href="#37806182">next</a><span>|</span><label class="collapse" for="c-37805355">[-]</label><label class="expand" for="c-37805355">[3 more]</label></div><br/><div class="children"><div class="content">Curious about the reasoning for removing type aliases? I don’t have an opinion on that myself</div><br/><div id="37805413" class="c"><input type="checkbox" id="c-37805413" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#37805355">parent</a><span>|</span><a href="#37806182">next</a><span>|</span><label class="collapse" for="c-37805413">[-]</label><label class="expand" for="c-37805413">[2 more]</label></div><br/><div class="children"><div class="content">newtypes are strictly better. Basically 100% of the time a type alias leaks some API that&#x27;s inappropriate for the intended usage of the type, and you can derive newtype methods if you actually want to do that.</div><br/><div id="37807614" class="c"><input type="checkbox" id="c-37807614" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#37805355">root</a><span>|</span><a href="#37805413">parent</a><span>|</span><a href="#37806182">next</a><span>|</span><label class="collapse" for="c-37807614">[-]</label><label class="expand" for="c-37807614">[1 more]</label></div><br/><div class="children"><div class="content">Not <i>strictly</i> better. Type aliases are sometimes a nice thing to use.</div><br/></div></div></div></div></div></div><div id="37806182" class="c"><input type="checkbox" id="c-37806182" checked=""/><div class="controls bullet"><span class="by">Ossiamk</span><span>|</span><a href="#37805355">prev</a><span>|</span><a href="#37807500">next</a><span>|</span><label class="collapse" for="c-37806182">[-]</label><label class="expand" for="c-37806182">[1 more]</label></div><br/><div class="children"><div class="content">Why not just go all in and start with Haskell 2, the way Python did with Python 3? Yes it&#x27;s less convenient, looses interoperability etc., but Pythons experience shows that its doable and in the end it might be worth it.</div><br/></div></div><div id="37807500" class="c"><input type="checkbox" id="c-37807500" checked=""/><div class="controls bullet"><span class="by">kruhft</span><span>|</span><a href="#37806182">prev</a><span>|</span><label class="collapse" for="c-37807500">[-]</label><label class="expand" for="c-37807500">[1 more]</label></div><br/><div class="children"><div class="content">Liskell was one.<p>It was Haskell with S-Expressions (Lisp like) as it&#x27;s front end.</div><br/></div></div></div></div></div></div></div></body></html>