<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733562053692" as="style"/><link rel="stylesheet" href="styles.css?v=1733562053692"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.moment.dev/blog/lies-i-was-told-pt-1">Lies I was told about collab editing, Part 1: Algorithms for offline editing</a> <span class="domain">(<a href="https://www.moment.dev">www.moment.dev</a>)</span></div><div class="subtext"><span>antics</span> | <span>55 comments</span></div><br/><div><div id="42344936" class="c"><input type="checkbox" id="c-42344936" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42344709">next</a><span>|</span><label class="collapse" for="c-42344936">[-]</label><label class="expand" for="c-42344936">[5 more]</label></div><br/><div class="children"><div class="content">Hi! Author of Eg-walker &amp; ShareJS here, both of which are referenced by this post.<p>You write this article like you&#x27;re disagreeing with me - but I agree completely with what you&#x27;ve said. I&#x27;ve been saying so on HN for years. (Eg, in this comment from 6 years ago[1].)<p>The way I think about it, the realtime collaborative tools we use today make a lot of sense when everyone is online &amp; editing together. But when users edit content offline, or in long lived branches, you probably want the option to add conflict markers &amp; do manual review when merging. (Especially for code.)<p>Luckily, algorithms like egwalker have access to all the information they need to do that. We store character-by-character editing traces from all users. And we store <i>when</i> all changes happened (in causal order, like a git DAG). This is far more information than git has. So it should be very possible to build a CRDT which uses this information to detects &amp; mark conflict ranges when branches are merged. Then we can allow users to manually resolve conflicts.<p>Algorithmically, this is an interesting problem but it should be quite solvable. Just, for some reason, nobody has worked on this yet. So, thanks for writing this post and bringing more attention to this problem!<p>If anyone is interested in making a unique and valuable contribution to the field, I&#x27;d love to see some work on this. Its an important piece thats missing in the CRDT ecosystem - simply because (as far as I know) nobody has tried to solve it yet. At least not for text editing.<p>[1] Bottom part of this comment: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19889174">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19889174</a></div><br/><div id="42347994" class="c"><input type="checkbox" id="c-42347994" checked=""/><div class="controls bullet"><span class="by">CalebJohn</span><span>|</span><a href="#42344936">parent</a><span>|</span><a href="#42347286">next</a><span>|</span><label class="collapse" for="c-42347994">[-]</label><label class="expand" for="c-42347994">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Algorithmically, this is an interesting problem but it should be quite solvable. Just, for some reason, nobody has worked on this yet. So, thanks for writing this post and bringing more attention to this problem!<p>I&#x27;m skeptical that an algorithmic solution will be possible, but I can see this being handled in a UX layer built on top. For example, a client could detect that there&#x27;s been a conflict based on the editing traces, and show a conflict resolution dialog that makes a new edit based on the resolution. The tricky part is marking a conflict as resolved. I suspect it could be as simple as adding a field to the crdt, but maybe then it counts as an algorithmic solution?<p>[1] <a href="https:&#x2F;&#x2F;josephg.com&#x2F;blog&#x2F;crdts-go-brrr&#x2F;" rel="nofollow">https:&#x2F;&#x2F;josephg.com&#x2F;blog&#x2F;crdts-go-brrr&#x2F;</a></div><br/></div></div><div id="42347286" class="c"><input type="checkbox" id="c-42347286" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344936">parent</a><span>|</span><a href="#42347994">prev</a><span>|</span><a href="#42344709">next</a><span>|</span><label class="collapse" for="c-42347286">[-]</label><label class="expand" for="c-42347286">[3 more]</label></div><br/><div class="children"><div class="content">I mentioned Loro in another comment which uses EG Walker, do you think they are an example of what you had mentioned? This comment also seems relevant [0].<p>Regarding your [1], I had a similar idea and I am beginning to think that only something like an LLM or similar can truly merge conflict free because only they are powerful enough to understand users&#x27; intent.<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42343953#42344880">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42343953#42344880</a></div><br/><div id="42347500" class="c"><input type="checkbox" id="c-42347500" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42347286">parent</a><span>|</span><a href="#42344709">next</a><span>|</span><label class="collapse" for="c-42347500">[-]</label><label class="expand" for="c-42347500">[2 more]</label></div><br/><div class="children"><div class="content">Does Loro generate conflict ranges when merging branches, thus allowing manual conflict resolution?<p>I’ve heard people suggest using LLMs for years for this - but CRDTs work because the same computation on two peers is guaranteed to produce the same result. LLMs can’t guarantee that. You could probably use an llm in leu of a human manually merging conflicts - but in that case we still need the crdt to first generate those conflict ranges to pass to the llm. Essentially an llm could solve the UX problem, but the underlying algorithm still needs this feature first to allow that to be used.</div><br/><div id="42348227" class="c"><input type="checkbox" id="c-42348227" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42347500">parent</a><span>|</span><a href="#42344709">next</a><span>|</span><label class="collapse" for="c-42348227">[-]</label><label class="expand" for="c-42348227">[1 more]</label></div><br/><div class="children"><div class="content">It seems that they might, but perhaps not in a good way yet, and they have it as a goal.<p>From <a href="https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#next-steps-for-loro" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#next-steps-for-loro</a>:<p>&gt; When merging extensive concurrent edits, CRDTs can automatically merge changes, but the result may not always meet expectations. Fortunately, Loro stores the complete editing history. This allows us to offer Git-like manual conflict resolution at the application layer when needed.<p>From <a href="https:&#x2F;&#x2F;loro.dev&#x2F;docs&#x2F;tutorial&#x2F;time_travel" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;docs&#x2F;tutorial&#x2F;time_travel</a>:<p>&gt; once we have a more refined version control API in place.<p>I&#x27;m interested to hear your opinion of their partial adoption of Eg-walker: <a href="https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#leveraging-the-potential-of-the-eg-walker" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#leveraging-the-potential-of-the-e...</a></div><br/></div></div></div></div></div></div></div></div><div id="42344709" class="c"><input type="checkbox" id="c-42344709" checked=""/><div class="controls bullet"><span class="by">pvh</span><span>|</span><a href="#42344936">prev</a><span>|</span><a href="#42344241">next</a><span>|</span><label class="collapse" for="c-42344709">[-]</label><label class="expand" for="c-42344709">[2 more]</label></div><br/><div class="children"><div class="content">Mechanical merge algorithms can perform better or worse on different kinds of conflicts (the specific example of editing deleted text is just one of many edge cases) but in the end no CRDT can decide if your merged text is what you <i>mean</i> to say.<p>We go into a bunch more detail in the Upwelling paper about the differences between (what we call) semantic and syntactic conflicts in writing: <a href="https:&#x2F;&#x2F;inkandswitch.com&#x2F;upwelling&#x2F;" rel="nofollow">https:&#x2F;&#x2F;inkandswitch.com&#x2F;upwelling&#x2F;</a><p>Ultimately, my feeling is that serious collaboration is a document review problem as much as anything else. That said, this is particularly true in journalism and scientific publishing and can be mostly ignored for your meeting notes...<p>Anyway, if you see this comment, thanks for a nice piece of writing, Alex. Love to see folks wrestling with these problems.</div><br/><div id="42344865" class="c"><input type="checkbox" id="c-42344865" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42344709">parent</a><span>|</span><a href="#42344241">next</a><span>|</span><label class="collapse" for="c-42344865">[-]</label><label class="expand" for="c-42344865">[1 more]</label></div><br/><div class="children"><div class="content">Hi Peter! Thanks so much for the kind words. I hope you noticed that a lot of the article ends up being a motivation for Ink &amp; Switch&#x27;s work, which we call out directly at the end. I am a big fan! :)<p>EDIT: Oh, also I meant to link to Upwelling, but forgot what it was called. I settled for a different link instead because it was deadline.</div><br/></div></div></div></div><div id="42344241" class="c"><input type="checkbox" id="c-42344241" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42344709">prev</a><span>|</span><a href="#42344298">next</a><span>|</span><label class="collapse" for="c-42344241">[-]</label><label class="expand" for="c-42344241">[7 more]</label></div><br/><div class="children"><div class="content">I think this happens because the mathematical, or causal, or entropic, notion of conflicts has been conflated with semantic conflicts. In the past I have made the same mistake, though inversely and was adamantly informed that I had no clue what I was talking about :)<p>Things get way nastier when you start considering trees, e.g. yJS operates on JSON documents. From a UI standpoint (where the UI is showing some shallow level and hasn&#x27;t been expanded to the deeper level) users could never even see edits that have been deleted.<p>I think that the class of CRDTs that preserve conflicts (IIRC that is when a register can hold multiple values) hold the most promise. Users should then be presented with those conflicts - and it could even be completely visual. Being able to scrub through history also seems like a viable alternative (allowing the user to figure out how a strange thing happened, or how their changes disappeared).</div><br/><div id="42344405" class="c"><input type="checkbox" id="c-42344405" checked=""/><div class="controls bullet"><span class="by">Onavo</span><span>|</span><a href="#42344241">parent</a><span>|</span><a href="#42344298">next</a><span>|</span><label class="collapse" for="c-42344405">[-]</label><label class="expand" for="c-42344405">[6 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Users should then be presented with those conflicts - and it could even be completely visual. Being able to scrub through history also seems like a viable alternative</i><p>I think &quot;Git&quot; would be a wonderful name for this type of CRDT.</div><br/><div id="42345806" class="c"><input type="checkbox" id="c-42345806" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42344405">parent</a><span>|</span><a href="#42344529">next</a><span>|</span><label class="collapse" for="c-42345806">[-]</label><label class="expand" for="c-42345806">[3 more]</label></div><br/><div class="children"><div class="content">For all things Git is good at, conflict resolution is most definitely not one of them. There are many ways to slice a conflicting diff into plus and minus parts, and somehow Git usually manages to create conflicts that are the least human readable. We live in an era of widely adopted and universal language servers, yet Git pretends that every change is just a char added or removed. There are many tools out there which do a considerably better job at this, for example by diffing the AST, not the text representation.</div><br/><div id="42346219" class="c"><input type="checkbox" id="c-42346219" checked=""/><div class="controls bullet"><span class="by">Wowfunhappy</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42345806">parent</a><span>|</span><a href="#42344529">next</a><span>|</span><label class="collapse" for="c-42346219">[-]</label><label class="expand" for="c-42346219">[2 more]</label></div><br/><div class="children"><div class="content">Hi, I&#x27;m a hobbyist coder with lots of personal forks of open source projects. I frequently spend a lot of time merging in changes from upstream. Can you suggest tools that would help with this?</div><br/><div id="42347729" class="c"><input type="checkbox" id="c-42347729" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42346219">parent</a><span>|</span><a href="#42344529">next</a><span>|</span><label class="collapse" for="c-42347729">[-]</label><label class="expand" for="c-42347729">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;mergiraf.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mergiraf.org&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42344529" class="c"><input type="checkbox" id="c-42344529" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42344405">parent</a><span>|</span><a href="#42345806">prev</a><span>|</span><a href="#42344445">next</a><span>|</span><label class="collapse" for="c-42344529">[-]</label><label class="expand" for="c-42344529">[1 more]</label></div><br/><div class="children"><div class="content">I mentioned Loro in another comment, but they actually do conflict resolution on top of Git trees [0]. Jujutsu is also interesting but I&#x27;m not sure if they do any conflict resolution [1].<p>[0] <a href="https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#loro-version-controller" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#loro-version-controller</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj">https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj</a></div><br/></div></div><div id="42344445" class="c"><input type="checkbox" id="c-42344445" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42344405">parent</a><span>|</span><a href="#42344529">prev</a><span>|</span><a href="#42344298">next</a><span>|</span><label class="collapse" for="c-42344445">[-]</label><label class="expand" for="c-42344445">[1 more]</label></div><br/><div class="children"><div class="content">More like Pijul or Darcs?<p>Git is popular, but it&#x27;s not particularly great at conflict resolution.</div><br/></div></div></div></div></div></div><div id="42344298" class="c"><input type="checkbox" id="c-42344298" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#42344241">prev</a><span>|</span><a href="#42346391">next</a><span>|</span><label class="collapse" for="c-42344298">[-]</label><label class="expand" for="c-42344298">[5 more]</label></div><br/><div class="children"><div class="content">I would wager that, in general, supporting the notion that several different entities are all the authority over a piece of data simultaneously and without live coordination is not solvable. This is a learned lesson for distributed systems, and is readily apparent in the article when considering distributed editing of documents. Same goes for dual input in flight cabins, parenting, and probably any other disparate example one can think of.</div><br/><div id="42344510" class="c"><input type="checkbox" id="c-42344510" checked=""/><div class="controls bullet"><span class="by">beefnugs</span><span>|</span><a href="#42344298">parent</a><span>|</span><a href="#42347112">next</a><span>|</span><label class="collapse" for="c-42344510">[-]</label><label class="expand" for="c-42344510">[3 more]</label></div><br/><div class="children"><div class="content">It is solvable, but needs more complicated contextual information that many people would not want to bother entering : &quot;this word i just changed only makes sense if it is apart of this whole sentence, which is not necessarily required for the whole paragraph...&quot;<p>And calling this &quot;solvable&quot; is a funny thing to think about, since huge portions of the earth think the chaos output of LLMs could be anywhere near deciding the final output of computation at this point in time</div><br/><div id="42346973" class="c"><input type="checkbox" id="c-42346973" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#42344298">root</a><span>|</span><a href="#42344510">parent</a><span>|</span><a href="#42347112">next</a><span>|</span><label class="collapse" for="c-42346973">[-]</label><label class="expand" for="c-42346973">[2 more]</label></div><br/><div class="children"><div class="content">heh, I bet no matter what kind of textual explanation you required, I can provide the situation it does not cover.<p>You say this word is only required if it&#x27;s a part of this whole sentence? OK, the other edit kept the whole sentence, but changed a single other word in it, which happened to be the subject.</div><br/><div id="42347119" class="c"><input type="checkbox" id="c-42347119" checked=""/><div class="controls bullet"><span class="by">eastern</span><span>|</span><a href="#42344298">root</a><span>|</span><a href="#42346973">parent</a><span>|</span><a href="#42347112">next</a><span>|</span><label class="collapse" for="c-42347119">[-]</label><label class="expand" for="c-42347119">[1 more]</label></div><br/><div class="children"><div class="content">100%.<p>The given situation is solvable only by the humans involved. They want different things. Either one of them has authority over the other, or they talk it over.</div><br/></div></div></div></div></div></div><div id="42347112" class="c"><input type="checkbox" id="c-42347112" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42344298">parent</a><span>|</span><a href="#42344510">prev</a><span>|</span><a href="#42346391">next</a><span>|</span><label class="collapse" for="c-42347112">[-]</label><label class="expand" for="c-42347112">[1 more]</label></div><br/><div class="children"><div class="content">Brewer&#x27;s CAP theorem of distributed data storage. you can have two out of these three:<p>1. Consistency<p>2. Availability<p>3. Partition tolerance</div><br/></div></div></div></div><div id="42346391" class="c"><input type="checkbox" id="c-42346391" checked=""/><div class="controls bullet"><span class="by">leoc</span><span>|</span><a href="#42344298">prev</a><span>|</span><a href="#42344337">next</a><span>|</span><label class="collapse" for="c-42346391">[-]</label><label class="expand" for="c-42346391">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In 2009, a surprising amount of the discourse was focused on the algorithms git used to automatically merge changes together.<p>IIRC Torvalds himself was quite pessimistic about what could be achieved with automatic merging. (And in this he was correct.) He said that Git had rejected the idea that a version-control system could, or should attempt to, &quot;solve the merging problem&quot; by finding a sufficiently-smart algorithm which would do the right things automatically.<p>&gt; Offline editing is a UI&#x2F;UX problem<p>True. There are two deeper root causes here:<p>1) computing&#x27;s commitment to cargo-culting old solutions and, relatedly,<p>2) its devotion to the belief &quot;in general 5-lb sacks are nicer to deal with than 10-lb sacks: therefore I should fit my 10 lbs of POL into one 5-lb sack&quot;.<p>The default vision of &quot;text editor&quot; is &quot;Mosaic textarea&quot;, &quot;MacWrite&quot; or something in between, so the quest is usually to bolt merging onto something like that with the minimum possible change. Make it a menu item, or a little dialog box with a few options. If there is some kind of GUI support for merging hidden deep in the menus it&#x27;s a programmer-UI diff-merger horror that barely does the minimum, or a strikethrough-based view which feels treacherous like navigating a ship through a fog. But in fact in text editing with offline collaboration merging, partly-manual merging at that, is a central part of the process and it needs to be central to the design of the editor. Unfortunately MacWrite is a local maximum which isn&#x27;t easy to get far away from.</div><br/><div id="42346962" class="c"><input type="checkbox" id="c-42346962" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#42346391">parent</a><span>|</span><a href="#42344337">next</a><span>|</span><label class="collapse" for="c-42346962">[-]</label><label class="expand" for="c-42346962">[1 more]</label></div><br/><div class="children"><div class="content">what are the alternatives, though?<p>For example, often when someone mentions &quot;cargo-culting&quot; and &quot;old solutions&quot;, their next words are &quot;stop editing code as text, edit as a syntax tree&quot;. But it has the same problem, just replace &quot;character&quot; with &quot;statement&quot;! Bob added a line to &quot;else&quot; branch of &quot;if&quot; statement, Alice deleted the entire statement, along with &quot;else&quot; branch - what is the smart system to do?</div><br/></div></div></div></div><div id="42344337" class="c"><input type="checkbox" id="c-42344337" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42346391">prev</a><span>|</span><a href="#42344504">next</a><span>|</span><label class="collapse" for="c-42344337">[-]</label><label class="expand" for="c-42344337">[3 more]</label></div><br/><div class="children"><div class="content">Hi folks! Author here. Happy to answer questions or take feedback. I&#x27;ll be in meetings for an hour or two but I love talking about this stuff. :) Here or over email if you prefer, alex@moment.dev</div><br/><div id="42345153" class="c"><input type="checkbox" id="c-42345153" checked=""/><div class="controls bullet"><span class="by">jakevoytko</span><span>|</span><a href="#42344337">parent</a><span>|</span><a href="#42345163">next</a><span>|</span><label class="collapse" for="c-42345153">[-]</label><label class="expand" for="c-42345153">[1 more]</label></div><br/><div class="children"><div class="content">If you keep the offline support, you&#x27;ll eventually uncover even more fun cases. &quot;I started working on this on an airplane where the wifi was down. But then decided I didn&#x27;t like the direction it was going and just closed the laptop and took a nap. I spent the next few days working on the document on my desktop. Over the weekend I opened the doc on my laptop and now all of my airplane changes are in the doc and everything is garbled. Help, I didn&#x27;t mean to merge them!&quot;<p>Git would never automatically mash your local changes in without your explicit consent. bzr would never have dreamed of it. But things like Google Docs will happily do it.<p>It&#x27;s awesome to see all the progress y&#x27;all have made! Good luck with early access!</div><br/></div></div><div id="42345163" class="c"><input type="checkbox" id="c-42345163" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#42344337">parent</a><span>|</span><a href="#42345153">prev</a><span>|</span><a href="#42344504">next</a><span>|</span><label class="collapse" for="c-42345163">[-]</label><label class="expand" for="c-42345163">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the problem with just adopting patch&#x2F;diff style merging? I mean, offline collaborative text editing is a solved problem for decades if you&#x27;re going to phrase it as just a UX optimization problem.</div><br/></div></div></div></div><div id="42344504" class="c"><input type="checkbox" id="c-42344504" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344337">prev</a><span>|</span><a href="#42344797">next</a><span>|</span><label class="collapse" for="c-42344504">[-]</label><label class="expand" for="c-42344504">[5 more]</label></div><br/><div class="children"><div class="content">I had an interest in CRDTs for quite a while now, as I like the local first philosophy of developing software, that works offline in its entirely but can also work online, a sort of progressive enhancement [0]. Recently I&#x27;ve been looking into Loro [1] which seems like it is able to effectively merge disparate offline text edits together, by using some new algorithms that were written about last year, such as the Event Graph Walker [2]. I&#x27;ve been combining this with ElectricSQL [3], which is a sync engine for Postgres. In the past they had their own CRDT right inside Postgres which would then sync tables, but they have rewritten their product to focus primarily on being a sync engine first and perhaps a conflict resolution library second. Therefore, I store the Loro changes binary in a table in Postgres as a blob that I then sync via Electric to all my clients.<p>Ultimately though, it is as you and others like @zamalek in this thread have said, the mathematical notion of conflict resolution might not actually mean anything semantically, therefore it is difficult to have long running offline edits merge together cohesively; it works with things like Google Docs where the user can see what other users have written in real time, which works for 99% of use cases, and sometimes I wonder whether one really needs such long running offline syncs, as it seems to be a very niche goal to target. Short running offline is nice to have and even necessary, especially for products one expects to work wholly offline, but it is the long term I don&#x27;t see much value in, as in not collaborating online for weeks or months at a time but still expecting cohesive edit merges.<p>[0] <a href="https:&#x2F;&#x2F;localfirstweb.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;localfirstweb.dev&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;loro.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;loro.dev&#x2F;docs&#x2F;advanced&#x2F;event_graph_walker" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;docs&#x2F;advanced&#x2F;event_graph_walker</a><p>[3] <a href="https:&#x2F;&#x2F;electric-sql.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;electric-sql.com&#x2F;</a></div><br/><div id="42344556" class="c"><input type="checkbox" id="c-42344556" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42344504">parent</a><span>|</span><a href="#42344797">next</a><span>|</span><label class="collapse" for="c-42344556">[-]</label><label class="expand" for="c-42344556">[4 more]</label></div><br/><div class="children"><div class="content">Alas, Loro fails The Color of Pomegranates test as well. (JSON trace, really cool toy they got there: <a href="https:&#x2F;&#x2F;pastebin.com&#x2F;6dSDc6Su" rel="nofollow">https:&#x2F;&#x2F;pastebin.com&#x2F;6dSDc6Su</a>)</div><br/><div id="42344724" class="c"><input type="checkbox" id="c-42344724" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344504">root</a><span>|</span><a href="#42344556">parent</a><span>|</span><a href="#42344880">next</a><span>|</span><label class="collapse" for="c-42344724">[-]</label><label class="expand" for="c-42344724">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is as I mentioned in my 2nd paragraph, mathematical conflict resolution is not semantically relevant for humans much of the time. That is why I don&#x27;t think automated merge conflict resolution with no human input can really work, that is why Git asks you to resolve merge conflicts before committing again. CRDTs can only really help when users edit disparate pieces of data, and if editing the same piece of data, <i>some</i> set of users need to be there, as in an online rather than offline capacity, to facilitate the merges, such as in Google Docs where if I edit a sentence with a spelling correction and you delete the sentence entirely, I will ask you directly what&#x27;s up.<p>Now, what some Git merge software is doing is using LLMs to coordinate merges, which I think might be useful to do so in plain text editing too, perhaps embedded into these CRDT libraries, but fundamentally, there must be <i>someone</i> to facilitate merges, whether it be a human agent or an AI one. It is impossible to do so with an entirely automated solution simply because <i>the machine does not know the intents of all its users</i>.</div><br/></div></div><div id="42344880" class="c"><input type="checkbox" id="c-42344880" checked=""/><div class="controls bullet"><span class="by">williamstein</span><span>|</span><a href="#42344504">root</a><span>|</span><a href="#42344556">parent</a><span>|</span><a href="#42344724">prev</a><span>|</span><a href="#42344797">next</a><span>|</span><label class="collapse" for="c-42344880">[-]</label><label class="expand" for="c-42344880">[2 more]</label></div><br/><div class="children"><div class="content">The text sync algorithm I wrote succeeds at the &quot;The Color of Pomegranates&quot; test.     See <a href="https:&#x2F;&#x2F;cocalc.com&#x2F;wstein&#x2F;dev&#x2F;share&#x2F;files&#x2F;2024-12-06.md" rel="nofollow">https:&#x2F;&#x2F;cocalc.com&#x2F;wstein&#x2F;dev&#x2F;share&#x2F;files&#x2F;2024-12-06.md</a> for some details of the exact patches.   This algorithm, which we came up with in 2015, is described at <a href="https:&#x2F;&#x2F;blog.cocalc.com&#x2F;2018&#x2F;10&#x2F;11&#x2F;collaborative-editing.html" rel="nofollow">https:&#x2F;&#x2F;blog.cocalc.com&#x2F;2018&#x2F;10&#x2F;11&#x2F;collaborative-editing.htm...</a>   
It&#x27;s a different approach than that taken by Yjs, Automerge, and Egwalker, with signficant pros (and cons!) relative to those algorithms.   It has been used in production in CoCalc for over 8 years, and was also used by the recently shutdown Noteable Jupyter notebook project.</div><br/><div id="42346163" class="c"><input type="checkbox" id="c-42346163" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42344504">root</a><span>|</span><a href="#42344880">parent</a><span>|</span><a href="#42344797">next</a><span>|</span><label class="collapse" for="c-42346163">[-]</label><label class="expand" for="c-42346163">[1 more]</label></div><br/><div class="children"><div class="content">This is absolutely fascinating and immediately one of my favorite articles of all time, full stop. Along the way, it implicitly illustrates a path to successful engineering x product thinking path that I&#x27;ve never seen written down somewhere and I think is crucial for sustainable impact. Thank you!</div><br/></div></div></div></div></div></div></div></div><div id="42344797" class="c"><input type="checkbox" id="c-42344797" checked=""/><div class="controls bullet"><span class="by">major4x</span><span>|</span><a href="#42344504">prev</a><span>|</span><a href="#42345540">next</a><span>|</span><label class="collapse" for="c-42344797">[-]</label><label class="expand" for="c-42344797">[1 more]</label></div><br/><div class="children"><div class="content">I love this mini article, however, I disagree with the main conclusion that collaborative editing is not an algorithmic but a UI&#x2F;UX problem. I think that collaborative editing is a semantic problem. To the best of my knowledge (I&#x27;m writing this comment without much preparation), all SVN&#x2F;Git algorithms are based on UNIX diff (Hunt–Szymanski algorithm). UNIX diff (and patch) is purely syntax driven.<p>Actually, I will make a small deviation here: I think it is a big industry&#x2F;startup&#x2F;open source project there, in creating a set of semantic diff algorithms&#x2F;implementations. For example, due to my present job, I am very interested in collaborative editing of electrical circuits, and layouts for PCB and chips. Altium and KiCad are trying, for exmaple, to store everything in XML&#x2F;text files and put the text files in Git&#x2F;SVN and I can tell you a botched C++ program is nothing in comparison to a botched and malformed electrical circuit. So we need diff tools that &quot;know&quot; about a text file, vs rich-text with formatting, vs bitmap vs vector image, vs song, vs English text. Anybody want to start an open source project (DM me or put a comment here).<p>Anyhow, thanks to the authors on the great insights and let&#x27;s work on the take home!</div><br/></div></div><div id="42345540" class="c"><input type="checkbox" id="c-42345540" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42344797">prev</a><span>|</span><a href="#42345683">next</a><span>|</span><label class="collapse" for="c-42345540">[-]</label><label class="expand" for="c-42345540">[1 more]</label></div><br/><div class="children"><div class="content">My rephrasing of the problem on coordination-free algorithms is that collaboration is largely a subset of correspondence.  For some reason, so many of these discussions try to treat it as a completely separate thing.  This invariably results in longer feedback loops for those corresponding with no direct communication of what, specifically, they have done.</div><br/></div></div><div id="42345683" class="c"><input type="checkbox" id="c-42345683" checked=""/><div class="controls bullet"><span class="by">mweidner</span><span>|</span><a href="#42345540">prev</a><span>|</span><a href="#42345835">next</a><span>|</span><label class="collapse" for="c-42345683">[-]</label><label class="expand" for="c-42345683">[1 more]</label></div><br/><div class="children"><div class="content">One challenge is that the algorithms typically used for collaborative text editing (CRDTs and OT) have strict algebraic requirements for what the edit operations do &amp; how they interact. So even if your server is smart enough to process the &quot;Colour&quot; example in a UX-reasonable way, it&#x27;s very hard to design a corresponding CRDT&#x2F;OT, for optimistic client-side edits.<p>You can work around this by not using CRDTs&#x2F;OT. E.g., the server processes operations in receipt order, applying whatever UX logic it wants; clients use a rebase&#x2F;prediction strategy to still allow optimistic edits on top (cf. <a href="https:&#x2F;&#x2F;doc.replicache.dev&#x2F;concepts&#x2F;how-it-works" rel="nofollow">https:&#x2F;&#x2F;doc.replicache.dev&#x2F;concepts&#x2F;how-it-works</a>). Doing this for text editing has some challenges, but they&#x27;re separate from the CRDT&#x2F;OT challenges discussed here.</div><br/></div></div><div id="42345835" class="c"><input type="checkbox" id="c-42345835" checked=""/><div class="controls bullet"><span class="by">klntsky</span><span>|</span><a href="#42345683">prev</a><span>|</span><a href="#42344495">next</a><span>|</span><label class="collapse" for="c-42345835">[-]</label><label class="expand" for="c-42345835">[2 more]</label></div><br/><div class="children"><div class="content">Looks like a good use case for LLMs!<p><a href="https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;67538beb-73e8-800a-b602-fe26b131e543" rel="nofollow">https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;67538beb-73e8-800a-b602-fe26b131e5...</a><p>HMU if interested in building it</div><br/><div id="42346925" class="c"><input type="checkbox" id="c-42346925" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#42345835">parent</a><span>|</span><a href="#42344495">next</a><span>|</span><label class="collapse" for="c-42346925">[-]</label><label class="expand" for="c-42346925">[1 more]</label></div><br/><div class="children"><div class="content">Hardly.  That just threw away Edit1, failing to follow instructions even in this very simple case.</div><br/></div></div></div></div><div id="42344495" class="c"><input type="checkbox" id="c-42344495" checked=""/><div class="controls bullet"><span class="by">robertclaus</span><span>|</span><a href="#42345835">prev</a><span>|</span><a href="#42345893">next</a><span>|</span><label class="collapse" for="c-42344495">[-]</label><label class="expand" for="c-42344495">[4 more]</label></div><br/><div class="children"><div class="content">The most surprising part of this article for someone uninitiated like myself is probably that products&#x2F;algorithms are claiming this automatic reconciliation is consistently possible. Maybe I&#x27;ve spent too much time resolving code merge conflicts by hand, but this seems intuitively obvious to me...<p>Feels like <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1831" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1831</a></div><br/><div id="42344977" class="c"><input type="checkbox" id="c-42344977" checked=""/><div class="controls bullet"><span class="by">williamstein</span><span>|</span><a href="#42344495">parent</a><span>|</span><a href="#42345893">next</a><span>|</span><label class="collapse" for="c-42344977">[-]</label><label class="expand" for="c-42344977">[3 more]</label></div><br/><div class="children"><div class="content">What they claim is that if all editing stops, then after a period of time everybody will be looking at the SAME document.  This is what is meant by &quot;eventual consistency&quot;.  Achieving this in general is indeed a difficult problem, but (some of) these algorithms do solve it, though it can be  tricky to correctly prove that they do.   I agree that it is not possible to ensure that the document everybody is looking at is what they actually wanted it to be.  However, there are some options for what happens, where some results may be technically correct -- we are all looking at the same thing -- but obviously really bad.  This beautiful talk has some examples: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=x7drE24geUw" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=x7drE24geUw</a></div><br/><div id="42345866" class="c"><input type="checkbox" id="c-42345866" checked=""/><div class="controls bullet"><span class="by">robertclaus</span><span>|</span><a href="#42344495">root</a><span>|</span><a href="#42344977">parent</a><span>|</span><a href="#42345893">next</a><span>|</span><label class="collapse" for="c-42345866">[-]</label><label class="expand" for="c-42345866">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t eventual consistency theoretically trivial...? You just delete the whole document after every transaction. I think it&#x27;s safe to assume anyone talking about this _means_ the results remain meaningful - which for text&#x2F;meaning is subjective.</div><br/><div id="42347280" class="c"><input type="checkbox" id="c-42347280" checked=""/><div class="controls bullet"><span class="by">williamstein</span><span>|</span><a href="#42344495">root</a><span>|</span><a href="#42345866">parent</a><span>|</span><a href="#42345893">next</a><span>|</span><label class="collapse" for="c-42347280">[-]</label><label class="expand" for="c-42347280">[1 more]</label></div><br/><div class="children"><div class="content">Proving that there exists an algorithm that results in an eventually consistent view of the document is trivial.  However, that&#x27;s not what we&#x27;re talking about.  Instead, researchers define a specific algorithm (e.g., involving CRDT&#x27;s or OT&#x27;s or something else), then prove that their algorithm results in an eventually consistent state.     This reminds me a little of the relationship between proving that there exists an algorithm to factor all positive integers (this is trivial) and proving there exists a subexponential time algorithm to factor integers, which is much less trivial (see <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lenstra_elliptic-curve_factorization" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lenstra_elliptic-curve_factori...</a>).</div><br/></div></div></div></div></div></div></div></div><div id="42345893" class="c"><input type="checkbox" id="c-42345893" checked=""/><div class="controls bullet"><span class="by">miltonlost</span><span>|</span><a href="#42344495">prev</a><span>|</span><a href="#42344933">next</a><span>|</span><label class="collapse" for="c-42345893">[-]</label><label class="expand" for="c-42345893">[2 more]</label></div><br/><div class="children"><div class="content">AI trying to figure out user intention and incorrectly so due to their heuristics or inherent missing context in merges, is why autocorrect has become almost more trouble than it&#x27;s worth these days. Texts on phones are impossible to start with &quot;well&quot; or &quot;we&#x27;ll&quot; as it will replace with the other before the second word. Algorithms need to stop saying that what they find more likely must be true; &quot;more&quot; likely is less useful when there&#x27;s a 51&#x2F;49% chance or a 4&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3...3% chance. Sometimes the AI will be right; sometimes it will be wrong. I&#x27;m far more upset when its wrong than the few times it&#x27;s right. The same problems with offline editing will raise their head as AI forces its way into our lives attempting to make decisions based on not nearly enough info.<p>Basic symbol or character-by-character manipulation cannot reveal why the changes occurred, just what happened.</div><br/><div id="42346981" class="c"><input type="checkbox" id="c-42346981" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#42345893">parent</a><span>|</span><a href="#42344933">next</a><span>|</span><label class="collapse" for="c-42346981">[-]</label><label class="expand" for="c-42346981">[1 more]</label></div><br/><div class="children"><div class="content">Turning off automatic autocorrect is one of the first thing I do when i get a new phone. Sure, show me suggestions, but let me decide myself if I want them or not!</div><br/></div></div></div></div><div id="42344933" class="c"><input type="checkbox" id="c-42344933" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#42345893">prev</a><span>|</span><a href="#42346714">next</a><span>|</span><label class="collapse" for="c-42344933">[-]</label><label class="expand" for="c-42344933">[1 more]</label></div><br/><div class="children"><div class="content">Just use git (:
(Half joking)</div><br/></div></div><div id="42346714" class="c"><input type="checkbox" id="c-42346714" checked=""/><div class="controls bullet"><span class="by">smoyer</span><span>|</span><a href="#42344933">prev</a><span>|</span><a href="#42344421">next</a><span>|</span><label class="collapse" for="c-42346714">[-]</label><label class="expand" for="c-42346714">[2 more]</label></div><br/><div class="children"><div class="content">I miss Google Wave.</div><br/><div id="42346828" class="c"><input type="checkbox" id="c-42346828" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#42346714">parent</a><span>|</span><a href="#42344421">next</a><span>|</span><label class="collapse" for="c-42346828">[-]</label><label class="expand" for="c-42346828">[1 more]</label></div><br/><div class="children"><div class="content">Oh! Now I remember the name of the tool that came before Google wave and (I think) inspired it.<p>Etherpad.</div><br/></div></div></div></div><div id="42344421" class="c"><input type="checkbox" id="c-42344421" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#42346714">prev</a><span>|</span><a href="#42345474">next</a><span>|</span><label class="collapse" for="c-42344421">[-]</label><label class="expand" for="c-42344421">[3 more]</label></div><br/><div class="children"><div class="content">The example seems like it would be easier if we’d gone in the direction of allowing more complex commands, like vim does. Imagine if real editors had been developed for the last 30 years or however long, instead of stagnating at vim (which is clearly a nice text editor, but it could be nice to have an editor designed around writing prose). Maybe neovim will save us. Some day.<p>Bob’s intent is to edit the word color, and inserting a u. But, he is limited to just expressing “put u here,” which is not at all what he wants to <i>achieve</i> it is just a mechanical description of what operations need to occur.<p>Alice’s intent is to delete the whole sentence, but she’s similarly limited to just saying “delete delete deleted delete delete…” to a bunch of letters.<p>Ending up with a u is the obvious dumb result of treating language as a pile  of characters. The correct behavior is to say: because the world Bob has edited no longer exists, his edit is clearly nonsense, don’t apply it. Which editor does that?</div><br/><div id="42344500" class="c"><input type="checkbox" id="c-42344500" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#42344421">parent</a><span>|</span><a href="#42345474">next</a><span>|</span><label class="collapse" for="c-42344500">[-]</label><label class="expand" for="c-42344500">[2 more]</label></div><br/><div class="children"><div class="content">Considering that software can only guess the intent if it&#x27;s not declared explicitly, I&#x27;m curious what such an &quot;intent declaration&quot; language would look like.</div><br/><div id="42344759" class="c"><input type="checkbox" id="c-42344759" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344421">root</a><span>|</span><a href="#42344500">parent</a><span>|</span><a href="#42345474">next</a><span>|</span><label class="collapse" for="c-42344759">[-]</label><label class="expand" for="c-42344759">[1 more]</label></div><br/><div class="children"><div class="content">At the limit, it would probably look like an LLM, because it&#x27;s akin to rules-based AI in the &#x27;90s vs neural network AI today. Expert systems had programmers write many rules in order to process information, which is what this &quot;intent declaration&quot; language would also be like, users writing many rules that would be followed. But this approach didn&#x27;t work because even humans didn&#x27;t even know all of the rules needed, therefore we turned to the statistical approaches of current neural network AI.</div><br/></div></div></div></div></div></div><div id="42345474" class="c"><input type="checkbox" id="c-42345474" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#42344421">prev</a><span>|</span><a href="#42344506">next</a><span>|</span><label class="collapse" for="c-42345474">[-]</label><label class="expand" for="c-42345474">[7 more]</label></div><br/><div class="children"><div class="content">Now that there are LLMs available, why is this still a problem? You just have to detect the conflicts and show a powerful enough LLM the two versions and tell it to do its best job at merging. This solves exactly the kind of issue described in the post. Oh, bonus point: you don&#x27;t have to take any metadata.</div><br/><div id="42347269" class="c"><input type="checkbox" id="c-42347269" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42345474">parent</a><span>|</span><a href="#42346304">next</a><span>|</span><label class="collapse" for="c-42347269">[-]</label><label class="expand" for="c-42347269">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly how I see it too, true intelligent merging algorithms are, at the limit, going to be basically LLMs because only something that powerful can understand user intent in a way that non-ML algorithms cannot.</div><br/></div></div><div id="42346304" class="c"><input type="checkbox" id="c-42346304" checked=""/><div class="controls bullet"><span class="by">jakelazaroff</span><span>|</span><a href="#42345474">parent</a><span>|</span><a href="#42347269">prev</a><span>|</span><a href="#42345957">next</a><span>|</span><label class="collapse" for="c-42346304">[-]</label><label class="expand" for="c-42346304">[3 more]</label></div><br/><div class="children"><div class="content">If there are only two conflicting updates, sure, maybe that would work. But there might be more than two peers, and their updates might arrive in any order. That&#x27;s why CRDT merges must be both commutative and associative.<p>Can we guarantee that an LLM will get exactly the same result merging (A ∨ B) ∨ C as it would merging A ∨ (B ∨ C)? Even when the temperature is 0?</div><br/><div id="42347227" class="c"><input type="checkbox" id="c-42347227" checked=""/><div class="controls bullet"><span class="by">mweidner</span><span>|</span><a href="#42345474">root</a><span>|</span><a href="#42346304">parent</a><span>|</span><a href="#42345957">next</a><span>|</span><label class="collapse" for="c-42347227">[-]</label><label class="expand" for="c-42347227">[2 more]</label></div><br/><div class="children"><div class="content">You could avoid the CRDT rules if you only use the LLM on the server. I.e., user comes online and sends their diff to the server, which LLM-merges it into the latest state and then sends that back to all clients.<p>This doesn&#x27;t help you do merges client-side during live collaboration (for showing your optimistic local updates), but there the low latency reduces conflicts anyway, so you can fall back on a semantically-imperfect CRDT.</div><br/><div id="42347262" class="c"><input type="checkbox" id="c-42347262" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42345474">root</a><span>|</span><a href="#42347227">parent</a><span>|</span><a href="#42345957">next</a><span>|</span><label class="collapse" for="c-42347262">[-]</label><label class="expand" for="c-42347262">[1 more]</label></div><br/><div class="children"><div class="content">If you have a central server, you don&#x27;t need CRDTs, which are designed to work even in pure peer-to-peer scenarios. Figma is one example of this [0]:<p>&gt; <i>Figma isn&#x27;t using true CRDTs though. CRDTs are designed for decentralized systems where there is no single central authority to decide what the final state should be. There is some unavoidable performance and memory overhead with doing this. Since Figma is centralized (our server is the central authority), we can simplify our system by removing this extra overhead and benefit from a faster and leaner implementation.</i><p>&gt; <i>It’s also worth noting that Figma&#x27;s data structure isn&#x27;t a single CRDT. Instead it&#x27;s inspired by multiple separate CRDTs and uses them in combination to create the final data structure that represents a Figma document (described below).</i><p>[0] <a href="https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology-works&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology...</a></div><br/></div></div></div></div></div></div><div id="42345957" class="c"><input type="checkbox" id="c-42345957" checked=""/><div class="controls bullet"><span class="by">miltonlost</span><span>|</span><a href="#42345474">parent</a><span>|</span><a href="#42346304">prev</a><span>|</span><a href="#42344506">next</a><span>|</span><label class="collapse" for="c-42345957">[-]</label><label class="expand" for="c-42345957">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You just have to detect the conflicts and show a powerful enough LLM the two versions and tell it to do its best job at merging. This solves exactly the kind of issue described in the post.<p>How does &quot;LLM tries its best&quot; solve the problem of exactly syncing documents offline? &quot;Tries its best&quot; implies it could fail which is what the problem already is. An LLM only adds a new layer of abstraction, but now the downside is it&#x27;s impossible to analyze.<p>Maybe I just have a much higher threshold of &quot;solved&quot; than you do, but anything non-deterministic (without some human judgment a la git) is not a good solve for document syncing.<p>A &quot;powerful enough LLM&quot; is the equivalent of &quot;and a wizard does it&quot;.</div><br/><div id="42346007" class="c"><input type="checkbox" id="c-42346007" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#42345474">root</a><span>|</span><a href="#42345957">parent</a><span>|</span><a href="#42344506">next</a><span>|</span><label class="collapse" for="c-42346007">[-]</label><label class="expand" for="c-42346007">[1 more]</label></div><br/><div class="children"><div class="content">LLMs at t=0 are predictable (will produce the same output starting from the same input) and do a much better merge work than any other non ML based algorithm.<p>Cut &amp; paste all the examples you can come up to Claude and tell me if LLMs are not able to do this kind of merging.</div><br/></div></div></div></div></div></div><div id="42344506" class="c"><input type="checkbox" id="c-42344506" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42345474">prev</a><span>|</span><label class="collapse" for="c-42344506">[-]</label><label class="expand" for="c-42344506">[1 more]</label></div><br/><div class="children"><div class="content">This is so, so, sooo good. I&#x27;ve never been brave enough to say it out loud, but this is 110% my experience.<p>I imagine it is somewhat a consequence of the divide between engineering and product.<p>It <i>can</i> resolve all conflicts, and it&#x27;s such a holy grail to go decentralized &#x2F; get Google Docs-like editing down to a a package in your favorite language. But, in practice, its intractable for arbitrary data, even just an arbitrary string.<p>I do wish there was a formal proof that showed &#x2F; proved this to share in HN discussions re: CRDTs...but hey, this is great! The &quot;it left a u&quot; example is simple, intuitive, and with a charitable listener, I doubt they&#x27;d argue we can&#x27;t figure out a string unambiguously, but we can figure out JSON unmabiguously.</div><br/></div></div></div></div></div></div></div></body></html>