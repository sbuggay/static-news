<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733648455680" as="style"/><link rel="stylesheet" href="styles.css?v=1733648455680"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.moment.dev/blog/lies-i-was-told-pt-1">Lies I was told about collab editing, Part 1: Algorithms for offline editing</a> <span class="domain">(<a href="https://www.moment.dev">www.moment.dev</a>)</span></div><div class="subtext"><span>antics</span> | <span>104 comments</span></div><br/><div><div id="42344936" class="c"><input type="checkbox" id="c-42344936" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42350041">next</a><span>|</span><label class="collapse" for="c-42344936">[-]</label><label class="expand" for="c-42344936">[22 more]</label></div><br/><div class="children"><div class="content">Hi! Author of Eg-walker &amp; ShareJS here, both of which are referenced by this post.<p>You write this article like you&#x27;re disagreeing with me - but I agree completely with what you&#x27;ve said. I&#x27;ve been saying so on HN for years. (Eg, in this comment from 6 years ago[1].)<p>The way I think about it, the realtime collaborative tools we use today make a lot of sense when everyone is online &amp; editing together. But when users edit content offline, or in long lived branches, you probably want the option to add conflict markers &amp; do manual review when merging. (Especially for code.)<p>Luckily, algorithms like egwalker have access to all the information they need to do that. We store character-by-character editing traces from all users. And we store <i>when</i> all changes happened (in causal order, like a git DAG). This is far more information than git has. So it should be very possible to build a CRDT which uses this information to detects &amp; mark conflict ranges when branches are merged. Then we can allow users to manually resolve conflicts.<p>Algorithmically, this is an interesting problem but it should be quite solvable. Just, for some reason, nobody has worked on this yet. So, thanks for writing this post and bringing more attention to this problem!<p>If anyone is interested in making a unique and valuable contribution to the field, I&#x27;d love to see some work on this. Its an important piece thats missing in the CRDT ecosystem - simply because (as far as I know) nobody has tried to solve it yet. At least not for text editing.<p>[1] Bottom part of this comment: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19889174">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19889174</a></div><br/><div id="42354747" class="c"><input type="checkbox" id="c-42354747" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#42344936">parent</a><span>|</span><a href="#42348740">next</a><span>|</span><label class="collapse" for="c-42354747">[-]</label><label class="expand" for="c-42354747">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>So it should be very possible to build a CRDT which uses this information to detects &amp; mark conflict ranges when branches are merged. Then we can allow users to manually resolve conflicts.</i><p>So you end up with “conflict” as part of your data model. Seems an amusing way of achieving the C (“conflict-free”) of CRDT, though perfectly legitimate and probably the only way.<p>The next fun challenge is when you get conflicts over conflict resolution!</div><br/></div></div><div id="42348740" class="c"><input type="checkbox" id="c-42348740" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42344936">parent</a><span>|</span><a href="#42354747">prev</a><span>|</span><a href="#42347994">next</a><span>|</span><label class="collapse" for="c-42348740">[-]</label><label class="expand" for="c-42348740">[3 more]</label></div><br/><div class="children"><div class="content">Hi Joseph! I am sorry, I was not trying to say your work sucks. I was trying to (1) help practitioners understand what they can expect, and (2) motivate problems like the one you mention at the end.<p>(1) might seem stupid but I think just <i>evaluating</i> these systems is a challenging enough technical problem that many teams will struggle with it. I just think they deserve practical advice—I know we would have appreciated it earlier on.</div><br/><div id="42353055" class="c"><input type="checkbox" id="c-42353055" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42348740">parent</a><span>|</span><a href="#42347994">next</a><span>|</span><label class="collapse" for="c-42353055">[-]</label><label class="expand" for="c-42353055">[2 more]</label></div><br/><div class="children"><div class="content">No need to apologise or change your article or anything. I think it’s great! It’s true that I haven’t written any articles or blog posts about this problem. People absolutely will appreciate more discussion and awareness of this problem, and I’m delighted you’re getting people talking about it.<p>I’m motivated by wanting the problem solved, not getting the most praise by random people on the internet. If today that means being cast in the role of “the old guard who’s missing something important” then so be it. What fun.</div><br/><div id="42354892" class="c"><input type="checkbox" id="c-42354892" checked=""/><div class="controls bullet"><span class="by">lifeisstillgood</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42353055">parent</a><span>|</span><a href="#42347994">next</a><span>|</span><label class="collapse" for="c-42354892">[-]</label><label class="expand" for="c-42354892">[1 more]</label></div><br/><div class="children"><div class="content">I just want to congratulate you both for contributing to the sum of human knowledge and understanding without resorting to entrenched positions, a rarity in todays online discourse.  Great to read positive attitudes</div><br/></div></div></div></div></div></div><div id="42347994" class="c"><input type="checkbox" id="c-42347994" checked=""/><div class="controls bullet"><span class="by">CalebJohn</span><span>|</span><a href="#42344936">parent</a><span>|</span><a href="#42348740">prev</a><span>|</span><a href="#42353087">next</a><span>|</span><label class="collapse" for="c-42347994">[-]</label><label class="expand" for="c-42347994">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Algorithmically, this is an interesting problem but it should be quite solvable. Just, for some reason, nobody has worked on this yet. So, thanks for writing this post and bringing more attention to this problem!<p>I&#x27;m skeptical that an algorithmic solution will be possible, but I can see this being handled in a UX layer built on top. For example, a client could detect that there&#x27;s been a conflict based on the editing traces, and show a conflict resolution dialog that makes a new edit based on the resolution. The tricky part is marking a conflict as resolved. I suspect it could be as simple as adding a field to the crdt, but maybe then it counts as an algorithmic solution?<p>[1] <a href="https:&#x2F;&#x2F;josephg.com&#x2F;blog&#x2F;crdts-go-brrr&#x2F;" rel="nofollow">https:&#x2F;&#x2F;josephg.com&#x2F;blog&#x2F;crdts-go-brrr&#x2F;</a></div><br/><div id="42349083" class="c"><input type="checkbox" id="c-42349083" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42347994">parent</a><span>|</span><a href="#42351016">next</a><span>|</span><label class="collapse" for="c-42349083">[-]</label><label class="expand" for="c-42349083">[3 more]</label></div><br/><div class="children"><div class="content">That is what josephg was suggesting:<p>&gt; it should be very possible to build a CRDT which uses this information to <i>detects &amp; mark conflict ranges when branches are merged</i></div><br/><div id="42353556" class="c"><input type="checkbox" id="c-42353556" checked=""/><div class="controls bullet"><span class="by">CalebJohn</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42349083">parent</a><span>|</span><a href="#42351016">next</a><span>|</span><label class="collapse" for="c-42353556">[-]</label><label class="expand" for="c-42353556">[2 more]</label></div><br/><div class="children"><div class="content">I should have been more clear in my original comment.<p>I don&#x27;t think that the conflict detection&#x2F;resolution needs to live inside the CRDT data structure. Ultimately you might want to bake it in out of convenience, but it should be possible to handle separately (of course the resolution will ultimately need to be written to the CRDT, but this can be a regular edit).<p>Keeping the conflict resolution in the application layer allows for CRDT libraries that don&#x27;t need to be aware of human-in-the-loop conflicts, and can serve a wider range of downstream needs. For example, a note app and a version control system might both be plain text, but conflict resolution needs to be handled completely differently. Another example would be collaborative offline vs. online use cases, as noted above, they are very different use cases.</div><br/><div id="42355427" class="c"><input type="checkbox" id="c-42355427" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42353556">parent</a><span>|</span><a href="#42351016">next</a><span>|</span><label class="collapse" for="c-42355427">[-]</label><label class="expand" for="c-42355427">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure I agree that that approach would work. There’s two reasons:<p>1. The crdt has an awful lot of information at its disposal while merging branches. I think “branch merging” algorithms should ideally be able to make use of that information.<p>2. There’s a potential problem in your approach where two users concurrently merge branches together. In that case, you don’t want the merges themselves to also conflict with one another. What you actually want is for the standard crdt convergence properties to hold for the merge operation itself - and if two people concurrently merge branches together (in any order) then it all behaves correctly.<p>For that to happen, I think you need some coordination between the merging and the crdt’s internal data structures. And why not? They’re right there.<p>A sketch of a solution would be for the merge operation to perform the normal optimistic merge - but also annotate the document with a set of locations which need human review. If all peers use the same algorithm to figure out where those conflict annotations go, then the merge itself should be idempotent. The conflict annotations can be part of the shared data model.<p>Another, maybe simpler approach would be for the crdt library itself to just return the list of conflicting locations out of band when you do a merge operation. (Ie, we don’t change the crdt data structure itself - we just also return a list of conflicting lines as a return value from the merge function). The editor takes the list of conflicting locations and builds a ui around the list so the user can do manual review.</div><br/></div></div></div></div></div></div><div id="42351016" class="c"><input type="checkbox" id="c-42351016" checked=""/><div class="controls bullet"><span class="by">astrobe_</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42347994">parent</a><span>|</span><a href="#42349083">prev</a><span>|</span><a href="#42353087">next</a><span>|</span><label class="collapse" for="c-42351016">[-]</label><label class="expand" for="c-42351016">[2 more]</label></div><br/><div class="children"><div class="content">Do you think that a LLM&#x2F;&quot;AI&quot; can reliably solve the merging problem?</div><br/><div id="42351293" class="c"><input type="checkbox" id="c-42351293" checked=""/><div class="controls bullet"><span class="by">taejo</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42351016">parent</a><span>|</span><a href="#42353087">next</a><span>|</span><label class="collapse" for="c-42351293">[-]</label><label class="expand" for="c-42351293">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you think that a LLM&#x2F;&quot;AI&quot; can reliably<p>No. LLMs definitely have uses where reliability is not a requirement, but that&#x27;s one requirement which LLMs clearly never meet</div><br/></div></div></div></div></div></div><div id="42353087" class="c"><input type="checkbox" id="c-42353087" checked=""/><div class="controls bullet"><span class="by">barrystaes</span><span>|</span><a href="#42344936">parent</a><span>|</span><a href="#42347994">prev</a><span>|</span><a href="#42351746">next</a><span>|</span><label class="collapse" for="c-42353087">[-]</label><label class="expand" for="c-42353087">[2 more]</label></div><br/><div class="children"><div class="content">I would simply argue that the “offline” editing is a people-problem and hence van not be solved using automation. People shall find a way to break&#x2F;bypass the automation&#x2F;system.<p>The only “offline editing” that I allow on human text documents is having people add comments. So not editing, no automated merging.<p>For “offline editing” that I allow on automation (source code) is GIT which intentionally does not pretend to solve the merge, it just shows revisions. The merge is an action supervised by humans or specialised automation on a “best guess” effort and still needs reviews and testing to verify success.</div><br/><div id="42353235" class="c"><input type="checkbox" id="c-42353235" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42353087">parent</a><span>|</span><a href="#42351746">next</a><span>|</span><label class="collapse" for="c-42353235">[-]</label><label class="expand" for="c-42353235">[1 more]</label></div><br/><div class="children"><div class="content">Yes I agree. But remember: but git will automatically merge concurrent changes in most cases - since most concurrent changes aren’t in conflict. You’re arguing you want to see &amp; review the merged output anyway - which I agree with.<p>Ideally, I want to be able to replace git with something that is built on CRDTs. When branches have no conflicts, CRDTs already work fine - since you merge, run tests, and push when you’re happy.<p>But right now CRDTs are too optimistic. If two branches edit the same line, we do a best-effort merge and move on. Instead in this case, the algorithm should explicitly mark the region as “in conflict” and needing human review, just like git does. Then humans can manually review the marked ranges (or, as others have suggested, ask an llm to do so or something.). And once they’re happy with the result, clear the conflicting range markers and push.</div><br/></div></div></div></div><div id="42351746" class="c"><input type="checkbox" id="c-42351746" checked=""/><div class="controls bullet"><span class="by">gritzko</span><span>|</span><a href="#42344936">parent</a><span>|</span><a href="#42353087">prev</a><span>|</span><a href="#42352218">next</a><span>|</span><label class="collapse" for="c-42351746">[-]</label><label class="expand" for="c-42351746">[1 more]</label></div><br/><div class="children"><div class="content">The author describes the case of overlapping concurrent splices. It is a known funky corner case, yes.
If we speak of editing program code, the rabbit hole is deeper as we ideally expect a valid program as a result of a merge. There was a project at JetBrains trying to solve this problem through AST-based merge. After delving into the rabbit hole much much deeper, the guys decided it is not worth it. This is what I was told.</div><br/></div></div><div id="42352218" class="c"><input type="checkbox" id="c-42352218" checked=""/><div class="controls bullet"><span class="by">ashoeafoot</span><span>|</span><a href="#42344936">parent</a><span>|</span><a href="#42351746">prev</a><span>|</span><a href="#42347286">next</a><span>|</span><label class="collapse" for="c-42352218">[-]</label><label class="expand" for="c-42352218">[2 more]</label></div><br/><div class="children"><div class="content">What i would love is, if the edit conflict was already baked into the language . Conflict&lt;Implementation1, Implementation2&gt;.</div><br/><div id="42353539" class="c"><input type="checkbox" id="c-42353539" checked=""/><div class="controls bullet"><span class="by">GTP</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42352218">parent</a><span>|</span><a href="#42347286">next</a><span>|</span><label class="collapse" for="c-42353539">[-]</label><label class="expand" for="c-42353539">[1 more]</label></div><br/><div class="children"><div class="content">What would be the advantage vs having an UI that clearly shows the conflict?</div><br/></div></div></div></div><div id="42347286" class="c"><input type="checkbox" id="c-42347286" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344936">parent</a><span>|</span><a href="#42352218">prev</a><span>|</span><a href="#42350041">next</a><span>|</span><label class="collapse" for="c-42347286">[-]</label><label class="expand" for="c-42347286">[6 more]</label></div><br/><div class="children"><div class="content">I mentioned Loro in another comment which uses EG Walker, do you think they are an example of what you had mentioned? This comment also seems relevant [0].<p>Regarding your [1], I had a similar idea and I am beginning to think that only something like an LLM or similar can truly merge conflict free because only they are powerful enough to understand users&#x27; intent.<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42343953#42344880">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42343953#42344880</a></div><br/><div id="42347500" class="c"><input type="checkbox" id="c-42347500" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42347286">parent</a><span>|</span><a href="#42350041">next</a><span>|</span><label class="collapse" for="c-42347500">[-]</label><label class="expand" for="c-42347500">[5 more]</label></div><br/><div class="children"><div class="content">Does Loro generate conflict ranges when merging branches, thus allowing manual conflict resolution?<p>I’ve heard people suggest using LLMs for years for this - but CRDTs work because the same computation on two peers is guaranteed to produce the same result. LLMs can’t guarantee that. You could probably use an llm in leu of a human manually merging conflicts - but in that case we still need the crdt to first generate those conflict ranges to pass to the llm. Essentially an llm could solve the UX problem, but the underlying algorithm still needs this feature first to allow that to be used.</div><br/><div id="42355036" class="c"><input type="checkbox" id="c-42355036" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42347500">parent</a><span>|</span><a href="#42348227">next</a><span>|</span><label class="collapse" for="c-42355036">[-]</label><label class="expand" for="c-42355036">[1 more]</label></div><br/><div class="children"><div class="content">Loro is planning on doing so, as the other comment says. Related, is this what you are looking for [0]? The commenter says that their implementation will surface conflicts to the user.<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42348381">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42348381</a></div><br/></div></div><div id="42348227" class="c"><input type="checkbox" id="c-42348227" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42347500">parent</a><span>|</span><a href="#42355036">prev</a><span>|</span><a href="#42348969">next</a><span>|</span><label class="collapse" for="c-42348227">[-]</label><label class="expand" for="c-42348227">[1 more]</label></div><br/><div class="children"><div class="content">It seems that they might, but perhaps not in a good way yet, and they have it as a goal.<p>From <a href="https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#next-steps-for-loro" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#next-steps-for-loro</a>:<p>&gt; When merging extensive concurrent edits, CRDTs can automatically merge changes, but the result may not always meet expectations. Fortunately, Loro stores the complete editing history. This allows us to offer Git-like manual conflict resolution at the application layer when needed.<p>From <a href="https:&#x2F;&#x2F;loro.dev&#x2F;docs&#x2F;tutorial&#x2F;time_travel" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;docs&#x2F;tutorial&#x2F;time_travel</a>:<p>&gt; once we have a more refined version control API in place.<p>I&#x27;m interested to hear your opinion of their partial adoption of Eg-walker: <a href="https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#leveraging-the-potential-of-the-eg-walker" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#leveraging-the-potential-of-the-e...</a></div><br/></div></div><div id="42348969" class="c"><input type="checkbox" id="c-42348969" checked=""/><div class="controls bullet"><span class="by">dmurray</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42347500">parent</a><span>|</span><a href="#42348227">prev</a><span>|</span><a href="#42350041">next</a><span>|</span><label class="collapse" for="c-42348969">[-]</label><label class="expand" for="c-42348969">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but CRDTs work because the same computation on two peers is guaranteed to produce the same result. LLMs can’t guarantee that.<p>This doesn&#x27;t seem like a hard requirement. It&#x27;s a nice property for some academically interesting peer-to-peer trustless algorithm, but in typical software architectures you won&#x27;t get a situation where Alice receives Bob&#x27;s edits and Bob receives Alice&#x27;s edits without them passing through a centralised server that can reconcile them first.<p>In any case, LLMs can be run deterministically (temperature=0, or use a fixed random seed and a single core where necessary).<p>I don&#x27;t expect further serious work in the offline text editing space. The next generation will certainly be some form of &quot;guess, then ask an LLM to guess&quot;</div><br/><div id="42353110" class="c"><input type="checkbox" id="c-42353110" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42344936">root</a><span>|</span><a href="#42348969">parent</a><span>|</span><a href="#42350041">next</a><span>|</span><label class="collapse" for="c-42353110">[-]</label><label class="expand" for="c-42353110">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in typical software architectures you won&#x27;t get a situation where Alice receives Bob&#x27;s edits and Bob receives Alice&#x27;s edits without them passing through a centralised server that can reconcile them first.<p>Thats the exact situation these algorithms are all designed to handle. If you require a centralised reconciling server, you’re taking a big step back in functionality - and you no longer have an eventually consistent system.<p>But as I say, asking an llm - what exactly? Most of the time concurrent edits are in different regions of a document and you want them to be merged automatically in the obvious way. It’s only when the same text (same line) is edited by two peers that you want to invoke a llm (if at all). If that’s the case you still need the crdt to detect conflicting ranges - you’re just using an llm instead of a human to resolve them. And in that case, CRDTs are still missing the important feature this blog post talked about. You’re just proposing a different UX layer on top of that missing feature.<p>And really, you’ll probably still want human review. LLMs have a tendency to do drive-by edits in situations like this, adding or removing commas in prose, changing formatting in code and so on. I don’t trust LLMs to touch my code or my writing without human review.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42350041" class="c"><input type="checkbox" id="c-42350041" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42344936">prev</a><span>|</span><a href="#42344709">next</a><span>|</span><label class="collapse" for="c-42350041">[-]</label><label class="expand" for="c-42350041">[3 more]</label></div><br/><div class="children"><div class="content">The other dark side of implementations using CRDTs is the infrastructure load. I wrote about this [0] in depth previously, and Supabase wrote an article [1] a couple of years ago about a CRDT extension for Postgres which I&#x27;m happy to discover agrees with my empirical findings.<p>If you&#x27;re going to use CRDTs, do yourself a favor and either use Redis or similar (though the amount of memory being consumed is painful to think about), or MyRocks [2] (or anything else based on RocksDB &#x2F; LevelDB). Whatever you do, do _not_ back it with an RDBMS, and especially not Postgres.<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40834759">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40834759</a><p>[1]: <a href="https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;postgres-crdt">https:&#x2F;&#x2F;supabase.com&#x2F;blog&#x2F;postgres-crdt</a><p>[2]: <a href="http:&#x2F;&#x2F;myrocks.io" rel="nofollow">http:&#x2F;&#x2F;myrocks.io</a></div><br/><div id="42354044" class="c"><input type="checkbox" id="c-42354044" checked=""/><div class="controls bullet"><span class="by">michaelsalim</span><span>|</span><a href="#42350041">parent</a><span>|</span><a href="#42344709">next</a><span>|</span><label class="collapse" for="c-42354044">[-]</label><label class="expand" for="c-42354044">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for this. Seems really useful since I&#x27;m building using Yjs + Postgres myself. Might save the day one of these days!</div><br/><div id="42355024" class="c"><input type="checkbox" id="c-42355024" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42350041">root</a><span>|</span><a href="#42354044">parent</a><span>|</span><a href="#42344709">next</a><span>|</span><label class="collapse" for="c-42355024">[-]</label><label class="expand" for="c-42355024">[1 more]</label></div><br/><div class="children"><div class="content">PowerSync has an article on using Postgres with Yjs (and perhaps look into Yrs, the Rust implementation, as well as other Rust crates like Loro and Automerge that are much faster) and they use a table in the database that stores the changes, is that what you are doing too [0]?<p>[0] <a href="https:&#x2F;&#x2F;www.powersync.com&#x2F;blog&#x2F;postgres-and-yjs-crdt-collaborative-text-editing-using-powersync" rel="nofollow">https:&#x2F;&#x2F;www.powersync.com&#x2F;blog&#x2F;postgres-and-yjs-crdt-collabo...</a></div><br/></div></div></div></div></div></div><div id="42344709" class="c"><input type="checkbox" id="c-42344709" checked=""/><div class="controls bullet"><span class="by">pvh</span><span>|</span><a href="#42350041">prev</a><span>|</span><a href="#42345683">next</a><span>|</span><label class="collapse" for="c-42344709">[-]</label><label class="expand" for="c-42344709">[2 more]</label></div><br/><div class="children"><div class="content">Mechanical merge algorithms can perform better or worse on different kinds of conflicts (the specific example of editing deleted text is just one of many edge cases) but in the end no CRDT can decide if your merged text is what you <i>mean</i> to say.<p>We go into a bunch more detail in the Upwelling paper about the differences between (what we call) semantic and syntactic conflicts in writing: <a href="https:&#x2F;&#x2F;inkandswitch.com&#x2F;upwelling&#x2F;" rel="nofollow">https:&#x2F;&#x2F;inkandswitch.com&#x2F;upwelling&#x2F;</a><p>Ultimately, my feeling is that serious collaboration is a document review problem as much as anything else. That said, this is particularly true in journalism and scientific publishing and can be mostly ignored for your meeting notes...<p>Anyway, if you see this comment, thanks for a nice piece of writing, Alex. Love to see folks wrestling with these problems.</div><br/><div id="42344865" class="c"><input type="checkbox" id="c-42344865" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42344709">parent</a><span>|</span><a href="#42345683">next</a><span>|</span><label class="collapse" for="c-42344865">[-]</label><label class="expand" for="c-42344865">[1 more]</label></div><br/><div class="children"><div class="content">Hi Peter! Thanks so much for the kind words. I hope you noticed that a lot of the article ends up being a motivation for Ink &amp; Switch&#x27;s work, which we call out directly at the end. I am a big fan! :)<p>EDIT: Oh, also I meant to link to Upwelling, but forgot what it was called. I settled for a different link instead because it was deadline.</div><br/></div></div></div></div><div id="42345683" class="c"><input type="checkbox" id="c-42345683" checked=""/><div class="controls bullet"><span class="by">mweidner</span><span>|</span><a href="#42344709">prev</a><span>|</span><a href="#42344241">next</a><span>|</span><label class="collapse" for="c-42345683">[-]</label><label class="expand" for="c-42345683">[2 more]</label></div><br/><div class="children"><div class="content">One challenge is that the algorithms typically used for collaborative text editing (CRDTs and OT) have strict algebraic requirements for what the edit operations do &amp; how they interact. So even if your server is smart enough to process the &quot;Colour&quot; example in a UX-reasonable way, it&#x27;s very hard to design a corresponding CRDT&#x2F;OT, for optimistic client-side edits.<p>You can work around this by not using CRDTs&#x2F;OT. E.g., the server processes operations in receipt order, applying whatever UX logic it wants; clients use a rebase&#x2F;prediction strategy to still allow optimistic edits on top (cf. <a href="https:&#x2F;&#x2F;doc.replicache.dev&#x2F;concepts&#x2F;how-it-works" rel="nofollow">https:&#x2F;&#x2F;doc.replicache.dev&#x2F;concepts&#x2F;how-it-works</a>). Doing this for text editing has some challenges, but they&#x27;re separate from the CRDT&#x2F;OT challenges discussed here.</div><br/><div id="42348700" class="c"><input type="checkbox" id="c-42348700" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42345683">parent</a><span>|</span><a href="#42344241">next</a><span>|</span><label class="collapse" for="c-42348700">[-]</label><label class="expand" for="c-42348700">[1 more]</label></div><br/><div class="children"><div class="content">Author here! Just chiming in to say this is a very underrated comment which I fully cosign. :)</div><br/></div></div></div></div><div id="42344241" class="c"><input type="checkbox" id="c-42344241" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42345683">prev</a><span>|</span><a href="#42344298">next</a><span>|</span><label class="collapse" for="c-42344241">[-]</label><label class="expand" for="c-42344241">[8 more]</label></div><br/><div class="children"><div class="content">I think this happens because the mathematical, or causal, or entropic, notion of conflicts has been conflated with semantic conflicts. In the past I have made the same mistake, though inversely and was adamantly informed that I had no clue what I was talking about :)<p>Things get way nastier when you start considering trees, e.g. yJS operates on JSON documents. From a UI standpoint (where the UI is showing some shallow level and hasn&#x27;t been expanded to the deeper level) users could never even see edits that have been deleted.<p>I think that the class of CRDTs that preserve conflicts (IIRC that is when a register can hold multiple values) hold the most promise. Users should then be presented with those conflicts - and it could even be completely visual. Being able to scrub through history also seems like a viable alternative (allowing the user to figure out how a strange thing happened, or how their changes disappeared).</div><br/><div id="42344405" class="c"><input type="checkbox" id="c-42344405" checked=""/><div class="controls bullet"><span class="by">Onavo</span><span>|</span><a href="#42344241">parent</a><span>|</span><a href="#42344298">next</a><span>|</span><label class="collapse" for="c-42344405">[-]</label><label class="expand" for="c-42344405">[7 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Users should then be presented with those conflicts - and it could even be completely visual. Being able to scrub through history also seems like a viable alternative</i><p>I think &quot;Git&quot; would be a wonderful name for this type of CRDT.</div><br/><div id="42345806" class="c"><input type="checkbox" id="c-42345806" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42344405">parent</a><span>|</span><a href="#42344529">next</a><span>|</span><label class="collapse" for="c-42345806">[-]</label><label class="expand" for="c-42345806">[3 more]</label></div><br/><div class="children"><div class="content">For all things Git is good at, conflict resolution is most definitely not one of them. There are many ways to slice a conflicting diff into plus and minus parts, and somehow Git usually manages to create conflicts that are the least human readable. We live in an era of widely adopted and universal language servers, yet Git pretends that every change is just a char added or removed. There are many tools out there which do a considerably better job at this, for example by diffing the AST, not the text representation.</div><br/><div id="42346219" class="c"><input type="checkbox" id="c-42346219" checked=""/><div class="controls bullet"><span class="by">Wowfunhappy</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42345806">parent</a><span>|</span><a href="#42344529">next</a><span>|</span><label class="collapse" for="c-42346219">[-]</label><label class="expand" for="c-42346219">[2 more]</label></div><br/><div class="children"><div class="content">Hi, I&#x27;m a hobbyist coder with lots of personal forks of open source projects. I frequently spend a lot of time merging in changes from upstream. Can you suggest tools that would help with this?</div><br/><div id="42347729" class="c"><input type="checkbox" id="c-42347729" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42346219">parent</a><span>|</span><a href="#42344529">next</a><span>|</span><label class="collapse" for="c-42347729">[-]</label><label class="expand" for="c-42347729">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;mergiraf.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mergiraf.org&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42344529" class="c"><input type="checkbox" id="c-42344529" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42344405">parent</a><span>|</span><a href="#42345806">prev</a><span>|</span><a href="#42344445">next</a><span>|</span><label class="collapse" for="c-42344529">[-]</label><label class="expand" for="c-42344529">[1 more]</label></div><br/><div class="children"><div class="content">I mentioned Loro in another comment, but they actually do conflict resolution on top of Git trees [0]. Jujutsu is also interesting but I&#x27;m not sure if they do any conflict resolution [1].<p>[0] <a href="https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#loro-version-controller" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;blog&#x2F;v1.0#loro-version-controller</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj">https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj</a></div><br/></div></div><div id="42344445" class="c"><input type="checkbox" id="c-42344445" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42344405">parent</a><span>|</span><a href="#42344529">prev</a><span>|</span><a href="#42353200">next</a><span>|</span><label class="collapse" for="c-42344445">[-]</label><label class="expand" for="c-42344445">[1 more]</label></div><br/><div class="children"><div class="content">More like Pijul or Darcs?<p>Git is popular, but it&#x27;s not particularly great at conflict resolution.</div><br/></div></div><div id="42353200" class="c"><input type="checkbox" id="c-42353200" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42344241">root</a><span>|</span><a href="#42344405">parent</a><span>|</span><a href="#42344445">prev</a><span>|</span><a href="#42344298">next</a><span>|</span><label class="collapse" for="c-42353200">[-]</label><label class="expand" for="c-42353200">[1 more]</label></div><br/><div class="children"><div class="content">The advantage that CRDTs have is they have a complete replay. <i>In theory</i> you could do some clever stuff with that.</div><br/></div></div></div></div></div></div><div id="42344298" class="c"><input type="checkbox" id="c-42344298" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#42344241">prev</a><span>|</span><a href="#42346391">next</a><span>|</span><label class="collapse" for="c-42344298">[-]</label><label class="expand" for="c-42344298">[6 more]</label></div><br/><div class="children"><div class="content">I would wager that, in general, supporting the notion that several different entities are all the authority over a piece of data simultaneously and without live coordination is not solvable. This is a learned lesson for distributed systems, and is readily apparent in the article when considering distributed editing of documents. Same goes for dual input in flight cabins, parenting, and probably any other disparate example one can think of.</div><br/><div id="42344510" class="c"><input type="checkbox" id="c-42344510" checked=""/><div class="controls bullet"><span class="by">beefnugs</span><span>|</span><a href="#42344298">parent</a><span>|</span><a href="#42347112">next</a><span>|</span><label class="collapse" for="c-42344510">[-]</label><label class="expand" for="c-42344510">[4 more]</label></div><br/><div class="children"><div class="content">It is solvable, but needs more complicated contextual information that many people would not want to bother entering : &quot;this word i just changed only makes sense if it is apart of this whole sentence, which is not necessarily required for the whole paragraph...&quot;<p>And calling this &quot;solvable&quot; is a funny thing to think about, since huge portions of the earth think the chaos output of LLMs could be anywhere near deciding the final output of computation at this point in time</div><br/><div id="42349733" class="c"><input type="checkbox" id="c-42349733" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#42344298">root</a><span>|</span><a href="#42344510">parent</a><span>|</span><a href="#42346973">next</a><span>|</span><label class="collapse" for="c-42349733">[-]</label><label class="expand" for="c-42349733">[1 more]</label></div><br/><div class="children"><div class="content">&quot;It is solvable&quot; is equivalent to &quot;politics are not necessary&quot;, which I can&#x27;t agree with.<p>Agreeing on edits requires a shared context, a shared understanding of the goal and requirements of the text being edited, and a shared projection of how readers should understand the text and how they will understand it instead.<p>The specific contextual information required for automated editing is dependent on the combined situation of all writers, considering their professional, personal and cultural contexts.<p>Assuming that context can&#x27;t be made available in a systematized way, the machine will choose an edit that is not guaranteed to match the intentions and expectations of the people involved. Instead, it will just act as adding one more writer to the mix.</div><br/></div></div><div id="42346973" class="c"><input type="checkbox" id="c-42346973" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#42344298">root</a><span>|</span><a href="#42344510">parent</a><span>|</span><a href="#42349733">prev</a><span>|</span><a href="#42347112">next</a><span>|</span><label class="collapse" for="c-42346973">[-]</label><label class="expand" for="c-42346973">[2 more]</label></div><br/><div class="children"><div class="content">heh, I bet no matter what kind of textual explanation you required, I can provide the situation it does not cover.<p>You say this word is only required if it&#x27;s a part of this whole sentence? OK, the other edit kept the whole sentence, but changed a single other word in it, which happened to be the subject.</div><br/><div id="42347119" class="c"><input type="checkbox" id="c-42347119" checked=""/><div class="controls bullet"><span class="by">eastern</span><span>|</span><a href="#42344298">root</a><span>|</span><a href="#42346973">parent</a><span>|</span><a href="#42347112">next</a><span>|</span><label class="collapse" for="c-42347119">[-]</label><label class="expand" for="c-42347119">[1 more]</label></div><br/><div class="children"><div class="content">100%.<p>The given situation is solvable only by the humans involved. They want different things. Either one of them has authority over the other, or they talk it over.</div><br/></div></div></div></div></div></div><div id="42347112" class="c"><input type="checkbox" id="c-42347112" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42344298">parent</a><span>|</span><a href="#42344510">prev</a><span>|</span><a href="#42346391">next</a><span>|</span><label class="collapse" for="c-42347112">[-]</label><label class="expand" for="c-42347112">[1 more]</label></div><br/><div class="children"><div class="content">Brewer&#x27;s CAP theorem of distributed data storage. you can have two out of these three:<p>1. Consistency<p>2. Availability<p>3. Partition tolerance</div><br/></div></div></div></div><div id="42346391" class="c"><input type="checkbox" id="c-42346391" checked=""/><div class="controls bullet"><span class="by">leoc</span><span>|</span><a href="#42344298">prev</a><span>|</span><a href="#42348381">next</a><span>|</span><label class="collapse" for="c-42346391">[-]</label><label class="expand" for="c-42346391">[4 more]</label></div><br/><div class="children"><div class="content">&gt; In 2009, a surprising amount of the discourse was focused on the algorithms git used to automatically merge changes together.<p>IIRC Torvalds himself was quite pessimistic about what could be achieved with automatic merging. (And in this he was correct.) He said that Git had rejected the idea that a version-control system could, or should attempt to, &quot;solve the merging problem&quot; by finding a sufficiently-smart algorithm which would do the right things automatically.<p>&gt; Offline editing is a UI&#x2F;UX problem<p>True. There are two deeper root causes here:<p>1) computing&#x27;s commitment to cargo-culting old solutions and, relatedly,<p>2) its devotion to the belief &quot;in general 5-lb sacks are nicer to deal with than 10-lb sacks: therefore I should fit my 10 lbs of POL into one 5-lb sack&quot;.<p>The default vision of &quot;text editor&quot; is &quot;Mosaic textarea&quot;, &quot;MacWrite&quot; or something in between, so the quest is usually to bolt merging onto something like that with the minimum possible change. Make it a menu item, or a little dialog box with a few options. If there is some kind of GUI support for merging hidden deep in the menus it&#x27;s a programmer-UI diff-merger horror that barely does the minimum, or a strikethrough-based view which feels treacherous like navigating a ship through a fog. But in fact in text editing with offline collaboration merging, partly-manual merging at that, is a central part of the process and it needs to be central to the design of the editor. Unfortunately MacWrite is a local maximum which isn&#x27;t easy to get far away from.</div><br/><div id="42346962" class="c"><input type="checkbox" id="c-42346962" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#42346391">parent</a><span>|</span><a href="#42348560">next</a><span>|</span><label class="collapse" for="c-42346962">[-]</label><label class="expand" for="c-42346962">[2 more]</label></div><br/><div class="children"><div class="content">what are the alternatives, though?<p>For example, often when someone mentions &quot;cargo-culting&quot; and &quot;old solutions&quot;, their next words are &quot;stop editing code as text, edit as a syntax tree&quot;. But it has the same problem, just replace &quot;character&quot; with &quot;statement&quot;! Bob added a line to &quot;else&quot; branch of &quot;if&quot; statement, Alice deleted the entire statement, along with &quot;else&quot; branch - what is the smart system to do?</div><br/><div id="42348371" class="c"><input type="checkbox" id="c-42348371" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#42346391">root</a><span>|</span><a href="#42346962">parent</a><span>|</span><a href="#42348560">next</a><span>|</span><label class="collapse" for="c-42348371">[-]</label><label class="expand" for="c-42348371">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the syntax tree approach is a silver bullet, but it does vastly reduce the kind of annoying things that trip up git merges today. Issues like whitespace conflicts, formatting clashes, reordering of import statements...<p>Though we seem to have collectively decided it&#x27;s easier to solve this by forcing everyone to adopt the same auto formatter configs, which, I guess fair enough</div><br/></div></div></div></div><div id="42348560" class="c"><input type="checkbox" id="c-42348560" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42346391">parent</a><span>|</span><a href="#42346962">prev</a><span>|</span><a href="#42348381">next</a><span>|</span><label class="collapse" for="c-42348560">[-]</label><label class="expand" for="c-42348560">[1 more]</label></div><br/><div class="children"><div class="content">[Author here] I am sorry, I think I phrased the automatic merging point confusingly. I was trying to say that when multiple commits change a file, git will attempt to merge them together, but it MUST flag direct conflicts. Sounds like we agree this is the right approach overall though.</div><br/></div></div></div></div><div id="42348381" class="c"><input type="checkbox" id="c-42348381" checked=""/><div class="controls bullet"><span class="by">MazeChaZer</span><span>|</span><a href="#42346391">prev</a><span>|</span><a href="#42351312">next</a><span>|</span><label class="collapse" for="c-42348381">[-]</label><label class="expand" for="c-42348381">[2 more]</label></div><br/><div class="children"><div class="content">The observation of this article is spot on! CRDTs are an awesome formal model for distributed data structures, but I was always bothered by the notion that all conflicts must be resolved automatically (hence also the name, conflict-free replicated data type). As the article illustrated, this is a hopeless endeavor. I believe what is needed is a proper structured representation of conflicts, that allows for sharing them and resolving them collaboratively, giving back control to the users and supporting them in the process. One of my favorite papers “Turning Conflicts into Collaboration” [1] makes a compelling argument for this idea.<p>As part of my ongoing PhD studies, we have developed our own formal model for structured conflict representation, based on lattice theory: “Lazy Merging: From a Potential of Universes to a Universe of Potentials” [2]. Incidentally, it is also a CRDT, but it does not attempt to resolve conflicts automatically. Instead, it represents them within the collaborative documents. Approaching the problem from mathematics allowed us to arrive at a simple conceptual model that can guarantee strong properties, like, e.g., the completeness, minimality, and uniqueness of merges, even after repeated merges of existing conflicts. And merges can be calculates very easily. I always wanted to make a blog post about it, but I never came around to do it.<p>[1] <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1007&#x2F;s10606-012-9172-4" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1007&#x2F;s10606-012-9172-4</a><p>[2] <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.14279&#x2F;tuj.eceasst.82.1226" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.14279&#x2F;tuj.eceasst.82.1226</a></div><br/><div id="42349264" class="c"><input type="checkbox" id="c-42349264" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#42348381">parent</a><span>|</span><a href="#42351312">next</a><span>|</span><label class="collapse" for="c-42349264">[-]</label><label class="expand" for="c-42349264">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for those citations, they look really interesting!<p>&gt; hence also the name, conflict-free replicated data type<p>When I was introduced to CRDTs the acronym stood for <i>commutative</i> replicated data types (eg in the paper by Shapiro et al). I prefer this actually, despite it being harder to pronounce.<p>A conflict is a complicated idea, and while &quot;conflict free&quot; is a <i>technically</i> correct way of describing the result, it can be misleading as evidenced by this post and your comment.<p>Commutativity is the property that when Bob applies changes in the order [Bob, Alice] and Alice applies changes in the order [Alice, Bob] that they both end up with the same document. It doesn&#x27;t imply that the document is somehow &quot;free&quot; of &quot;conflicts&quot; in a sense that may be meaningful at a higher level of abstraction.</div><br/></div></div></div></div><div id="42351312" class="c"><input type="checkbox" id="c-42351312" checked=""/><div class="controls bullet"><span class="by">keizo</span><span>|</span><a href="#42348381">prev</a><span>|</span><a href="#42344337">next</a><span>|</span><label class="collapse" for="c-42351312">[-]</label><label class="expand" for="c-42351312">[1 more]</label></div><br/><div class="children"><div class="content">I implemented differential sync (<a href="https:&#x2F;&#x2F;neil.fraser.name&#x2F;writing&#x2F;sync&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neil.fraser.name&#x2F;writing&#x2F;sync&#x2F;</a>) mostly because I couldn’t understand anything else and seemed simplest in my grugnotes.com app -- and while the app is pretty janky and not fully real-time, it does get your example merge right regardless of who comes back online first. In the case the deletion comes online first, the &#x27;colour&#x27; version is thrown out and not saved in edit history. I’m sure there’s a lot more wrong with it, have no idea what would happen with more than two users, but for my case I’m happy with it. :)</div><br/></div></div><div id="42344337" class="c"><input type="checkbox" id="c-42344337" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42351312">prev</a><span>|</span><a href="#42350467">next</a><span>|</span><label class="collapse" for="c-42344337">[-]</label><label class="expand" for="c-42344337">[6 more]</label></div><br/><div class="children"><div class="content">Hi folks! Author here. Happy to answer questions or take feedback. I&#x27;ll be in meetings for an hour or two but I love talking about this stuff. :) Here or over email if you prefer, alex@moment.dev</div><br/><div id="42345153" class="c"><input type="checkbox" id="c-42345153" checked=""/><div class="controls bullet"><span class="by">jakevoytko</span><span>|</span><a href="#42344337">parent</a><span>|</span><a href="#42345163">next</a><span>|</span><label class="collapse" for="c-42345153">[-]</label><label class="expand" for="c-42345153">[2 more]</label></div><br/><div class="children"><div class="content">If you keep the offline support, you&#x27;ll eventually uncover even more fun cases. &quot;I started working on this on an airplane where the wifi was down. But then decided I didn&#x27;t like the direction it was going and just closed the laptop and took a nap. I spent the next few days working on the document on my desktop. Over the weekend I opened the doc on my laptop and now all of my airplane changes are in the doc and everything is garbled. Help, I didn&#x27;t mean to merge them!&quot;<p>Git would never automatically mash your local changes in without your explicit consent. bzr would never have dreamed of it. But things like Google Docs will happily do it.<p>It&#x27;s awesome to see all the progress y&#x27;all have made! Good luck with early access!</div><br/><div id="42348543" class="c"><input type="checkbox" id="c-42348543" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42344337">root</a><span>|</span><a href="#42345153">parent</a><span>|</span><a href="#42345163">next</a><span>|</span><label class="collapse" for="c-42348543">[-]</label><label class="expand" for="c-42348543">[1 more]</label></div><br/><div class="children"><div class="content">Hi Jake! Long time no chat! I hope everything is going well. Yep, those are exactly the kinds of cases we seek to give people more control over. It&#x27;s like you read my mind. :)</div><br/></div></div></div></div><div id="42345163" class="c"><input type="checkbox" id="c-42345163" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#42344337">parent</a><span>|</span><a href="#42345153">prev</a><span>|</span><a href="#42350467">next</a><span>|</span><label class="collapse" for="c-42345163">[-]</label><label class="expand" for="c-42345163">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the problem with just adopting patch&#x2F;diff style merging? I mean, offline collaborative text editing is a solved problem for decades if you&#x27;re going to phrase it as just a UX optimization problem.</div><br/><div id="42348515" class="c"><input type="checkbox" id="c-42348515" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42344337">root</a><span>|</span><a href="#42345163">parent</a><span>|</span><a href="#42350467">next</a><span>|</span><label class="collapse" for="c-42348515">[-]</label><label class="expand" for="c-42348515">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I understand the question fully, but yes, I am a big fan of the diff&#x2F;review&#x2F;patch-style tools like git for offline editing, and that is exactly why I call them out in the final paragraphs. The reason I don&#x27;t agree that it&#x27;s completely closed-book solved is because I think the git diff UI is not appropriate for most people whoa re not developers.</div><br/><div id="42349806" class="c"><input type="checkbox" id="c-42349806" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#42344337">root</a><span>|</span><a href="#42348515">parent</a><span>|</span><a href="#42350467">next</a><span>|</span><label class="collapse" for="c-42349806">[-]</label><label class="expand" for="c-42349806">[1 more]</label></div><br/><div class="children"><div class="content">Not the exact git GUI, but bear in mind Word has supported offline edit&#x2F;merge for decades and it&#x27;s done in a similar way (you see diffs visually and can accept&#x2F;reject them). Lawyers depend on that workflow heavily.</div><br/></div></div></div></div></div></div></div></div><div id="42350467" class="c"><input type="checkbox" id="c-42350467" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#42344337">prev</a><span>|</span><a href="#42344504">next</a><span>|</span><label class="collapse" for="c-42350467">[-]</label><label class="expand" for="c-42350467">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m angry that I guessed right. I really don&#x27;t like how flat the model for text generally is. I don&#x27;t see text as a [Char], so if the computer does there&#x27;s a hidden mismatch that people have grown to work around and with (just like searching on the Internet before 2005 felt. You had to know what was gonna work and then got the right to claim how easy it was)<p>We structure text in an implicit hierarchy given by spacing, margins and a bunch of other subtle things that [Char] doesn&#x27;t capture, but can encode for other humans. I think that this is were all the problems stem from, and that with right (tm) structure a lot of the operations can be merged trivially with way fewer surprises.
Easier said that done for sure, and there will be more weird cases, but I&#x27;m guessing they will get closer to being just the conflicts that really need authors to deal with.</div><br/></div></div><div id="42344504" class="c"><input type="checkbox" id="c-42344504" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42350467">prev</a><span>|</span><a href="#42349620">next</a><span>|</span><label class="collapse" for="c-42344504">[-]</label><label class="expand" for="c-42344504">[5 more]</label></div><br/><div class="children"><div class="content">I had an interest in CRDTs for quite a while now, as I like the local first philosophy of developing software, that works offline in its entirely but can also work online, a sort of progressive enhancement [0]. Recently I&#x27;ve been looking into Loro [1] which seems like it is able to effectively merge disparate offline text edits together, by using some new algorithms that were written about last year, such as the Event Graph Walker [2]. I&#x27;ve been combining this with ElectricSQL [3], which is a sync engine for Postgres. In the past they had their own CRDT right inside Postgres which would then sync tables, but they have rewritten their product to focus primarily on being a sync engine first and perhaps a conflict resolution library second. Therefore, I store the Loro changes binary in a table in Postgres as a blob that I then sync via Electric to all my clients.<p>Ultimately though, it is as you and others like @zamalek in this thread have said, the mathematical notion of conflict resolution might not actually mean anything semantically, therefore it is difficult to have long running offline edits merge together cohesively; it works with things like Google Docs where the user can see what other users have written in real time, which works for 99% of use cases, and sometimes I wonder whether one really needs such long running offline syncs, as it seems to be a very niche goal to target. Short running offline is nice to have and even necessary, especially for products one expects to work wholly offline, but it is the long term I don&#x27;t see much value in, as in not collaborating online for weeks or months at a time but still expecting cohesive edit merges.<p>[0] <a href="https:&#x2F;&#x2F;localfirstweb.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;localfirstweb.dev&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;loro.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;loro.dev&#x2F;docs&#x2F;advanced&#x2F;event_graph_walker" rel="nofollow">https:&#x2F;&#x2F;loro.dev&#x2F;docs&#x2F;advanced&#x2F;event_graph_walker</a><p>[3] <a href="https:&#x2F;&#x2F;electric-sql.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;electric-sql.com&#x2F;</a></div><br/><div id="42344556" class="c"><input type="checkbox" id="c-42344556" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42344504">parent</a><span>|</span><a href="#42349620">next</a><span>|</span><label class="collapse" for="c-42344556">[-]</label><label class="expand" for="c-42344556">[4 more]</label></div><br/><div class="children"><div class="content">Alas, Loro fails The Color of Pomegranates test as well. (JSON trace, really cool toy they got there: <a href="https:&#x2F;&#x2F;pastebin.com&#x2F;6dSDc6Su" rel="nofollow">https:&#x2F;&#x2F;pastebin.com&#x2F;6dSDc6Su</a>)</div><br/><div id="42344724" class="c"><input type="checkbox" id="c-42344724" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344504">root</a><span>|</span><a href="#42344556">parent</a><span>|</span><a href="#42344880">next</a><span>|</span><label class="collapse" for="c-42344724">[-]</label><label class="expand" for="c-42344724">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is as I mentioned in my 2nd paragraph, mathematical conflict resolution is not semantically relevant for humans much of the time. That is why I don&#x27;t think automated merge conflict resolution with no human input can really work, that is why Git asks you to resolve merge conflicts before committing again. CRDTs can only really help when users edit disparate pieces of data, and if editing the same piece of data, <i>some</i> set of users need to be there, as in an online rather than offline capacity, to facilitate the merges, such as in Google Docs where if I edit a sentence with a spelling correction and you delete the sentence entirely, I will ask you directly what&#x27;s up.<p>Now, what some Git merge software is doing is using LLMs to coordinate merges, which I think might be useful to do so in plain text editing too, perhaps embedded into these CRDT libraries, but fundamentally, there must be <i>someone</i> to facilitate merges, whether it be a human agent or an AI one. It is impossible to do so with an entirely automated solution simply because <i>the machine does not know the intents of all its users</i>.</div><br/></div></div><div id="42344880" class="c"><input type="checkbox" id="c-42344880" checked=""/><div class="controls bullet"><span class="by">williamstein</span><span>|</span><a href="#42344504">root</a><span>|</span><a href="#42344556">parent</a><span>|</span><a href="#42344724">prev</a><span>|</span><a href="#42349620">next</a><span>|</span><label class="collapse" for="c-42344880">[-]</label><label class="expand" for="c-42344880">[2 more]</label></div><br/><div class="children"><div class="content">The text sync algorithm I wrote succeeds at the &quot;The Color of Pomegranates&quot; test.     See <a href="https:&#x2F;&#x2F;cocalc.com&#x2F;wstein&#x2F;dev&#x2F;share&#x2F;files&#x2F;2024-12-06.md" rel="nofollow">https:&#x2F;&#x2F;cocalc.com&#x2F;wstein&#x2F;dev&#x2F;share&#x2F;files&#x2F;2024-12-06.md</a> for some details of the exact patches.   This algorithm, which we came up with in 2015, is described at <a href="https:&#x2F;&#x2F;blog.cocalc.com&#x2F;2018&#x2F;10&#x2F;11&#x2F;collaborative-editing.html" rel="nofollow">https:&#x2F;&#x2F;blog.cocalc.com&#x2F;2018&#x2F;10&#x2F;11&#x2F;collaborative-editing.htm...</a>   
It&#x27;s a different approach than that taken by Yjs, Automerge, and Egwalker, with signficant pros (and cons!) relative to those algorithms.   It has been used in production in CoCalc for over 8 years, and was also used by the recently shutdown Noteable Jupyter notebook project.</div><br/><div id="42346163" class="c"><input type="checkbox" id="c-42346163" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42344504">root</a><span>|</span><a href="#42344880">parent</a><span>|</span><a href="#42349620">next</a><span>|</span><label class="collapse" for="c-42346163">[-]</label><label class="expand" for="c-42346163">[1 more]</label></div><br/><div class="children"><div class="content">This is absolutely fascinating and immediately one of my favorite articles of all time, full stop. Along the way, it implicitly illustrates a path to successful engineering x product thinking path that I&#x27;ve never seen written down somewhere and I think is crucial for sustainable impact. Thank you!</div><br/></div></div></div></div></div></div></div></div><div id="42349620" class="c"><input type="checkbox" id="c-42349620" checked=""/><div class="controls bullet"><span class="by">yaweezy</span><span>|</span><a href="#42344504">prev</a><span>|</span><a href="#42354469">next</a><span>|</span><label class="collapse" for="c-42349620">[-]</label><label class="expand" for="c-42349620">[1 more]</label></div><br/><div class="children"><div class="content">Really enjoyed reading the post and the comments. And it’s good to see a general consensus on this point. I had a short stint at a legaltech startup and began putting together a framework for resolving drafting edits&#x2F;conflicts. In the legal context, it was more critical that the user actively signed off on a change to avoid random errors, so my thought was to implement a UI&#x2F;UX solution to review each change similar to Microsoft Word’s spelling and grammar check. There were some other options I proposed, like showing multiple ways that the change could be implemented. The team decided to focus on solving easier problems and the startup folded not too long after that. But it was a really fun exercise. Glad to see folks are still thinking deeply about it.</div><br/></div></div><div id="42354469" class="c"><input type="checkbox" id="c-42354469" checked=""/><div class="controls bullet"><span class="by">Confirm2754</span><span>|</span><a href="#42349620">prev</a><span>|</span><a href="#42344797">next</a><span>|</span><label class="collapse" for="c-42354469">[-]</label><label class="expand" for="c-42354469">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for your research! I&#x27;ve been working on integrating CRDT into note-taking software recently. Thank you for letting me know what&#x27;s more important!</div><br/></div></div><div id="42344797" class="c"><input type="checkbox" id="c-42344797" checked=""/><div class="controls bullet"><span class="by">major4x</span><span>|</span><a href="#42354469">prev</a><span>|</span><a href="#42352458">next</a><span>|</span><label class="collapse" for="c-42344797">[-]</label><label class="expand" for="c-42344797">[2 more]</label></div><br/><div class="children"><div class="content">I love this mini article, however, I disagree with the main conclusion that collaborative editing is not an algorithmic but a UI&#x2F;UX problem. I think that collaborative editing is a semantic problem. To the best of my knowledge (I&#x27;m writing this comment without much preparation), all SVN&#x2F;Git algorithms are based on UNIX diff (Hunt–Szymanski algorithm). UNIX diff (and patch) is purely syntax driven.<p>Actually, I will make a small deviation here: I think it is a big industry&#x2F;startup&#x2F;open source project there, in creating a set of semantic diff algorithms&#x2F;implementations. For example, due to my present job, I am very interested in collaborative editing of electrical circuits, and layouts for PCB and chips. Altium and KiCad are trying, for exmaple, to store everything in XML&#x2F;text files and put the text files in Git&#x2F;SVN and I can tell you a botched C++ program is nothing in comparison to a botched and malformed electrical circuit. So we need diff tools that &quot;know&quot; about a text file, vs rich-text with formatting, vs bitmap vs vector image, vs song, vs English text. Anybody want to start an open source project (DM me or put a comment here).<p>Anyhow, thanks to the authors on the great insights and let&#x27;s work on the take home!</div><br/><div id="42354263" class="c"><input type="checkbox" id="c-42354263" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#42344797">parent</a><span>|</span><a href="#42352458">next</a><span>|</span><label class="collapse" for="c-42354263">[-]</label><label class="expand" for="c-42354263">[1 more]</label></div><br/><div class="children"><div class="content">Hey, I am trying to make a version control system with semantic diff. Electrical circuits and layouts are high on my list.<p>My profile has links to webpages with my contact info.</div><br/></div></div></div></div><div id="42352458" class="c"><input type="checkbox" id="c-42352458" checked=""/><div class="controls bullet"><span class="by">breadwinner</span><span>|</span><a href="#42344797">prev</a><span>|</span><a href="#42354216">next</a><span>|</span><label class="collapse" for="c-42352458">[-]</label><label class="expand" for="c-42352458">[1 more]</label></div><br/><div class="children"><div class="content">Has anyone tried Microsoft&#x27;s fluid framework for collaborative editing?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;FluidFramework">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;FluidFramework</a><p><a href="https:&#x2F;&#x2F;fluidframework.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fluidframework.com&#x2F;</a></div><br/></div></div><div id="42354216" class="c"><input type="checkbox" id="c-42354216" checked=""/><div class="controls bullet"><span class="by">aetherspawn</span><span>|</span><a href="#42352458">prev</a><span>|</span><a href="#42345893">next</a><span>|</span><label class="collapse" for="c-42354216">[-]</label><label class="expand" for="c-42354216">[1 more]</label></div><br/><div class="children"><div class="content">Seems like a great application for AI. An LLM could most likely predict how things could be merged with high accuracy in 3 steps:<p>1. Look at the authors changeset to put a “reason”, or similar, to the edit<p>2. Ask whether either of the edits makes the other edit redundant<p>3. Ask the LLM which order to replay the changes (addition or deletion) to preserve the reason of both edits, or otherwise pick the best order<p>I doubt you need even a 70B model to get “90% good results”, which is all you probably need, because lets be honest offline editing is quite an edge-case to begin with in 2025.</div><br/></div></div><div id="42345893" class="c"><input type="checkbox" id="c-42345893" checked=""/><div class="controls bullet"><span class="by">miltonlost</span><span>|</span><a href="#42354216">prev</a><span>|</span><a href="#42348788">next</a><span>|</span><label class="collapse" for="c-42345893">[-]</label><label class="expand" for="c-42345893">[2 more]</label></div><br/><div class="children"><div class="content">AI trying to figure out user intention and incorrectly so due to their heuristics or inherent missing context in merges, is why autocorrect has become almost more trouble than it&#x27;s worth these days. Texts on phones are impossible to start with &quot;well&quot; or &quot;we&#x27;ll&quot; as it will replace with the other before the second word. Algorithms need to stop saying that what they find more likely must be true; &quot;more&quot; likely is less useful when there&#x27;s a 51&#x2F;49% chance or a 4&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3&#x2F;3...3% chance. Sometimes the AI will be right; sometimes it will be wrong. I&#x27;m far more upset when its wrong than the few times it&#x27;s right. The same problems with offline editing will raise their head as AI forces its way into our lives attempting to make decisions based on not nearly enough info.<p>Basic symbol or character-by-character manipulation cannot reveal why the changes occurred, just what happened.</div><br/><div id="42346981" class="c"><input type="checkbox" id="c-42346981" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#42345893">parent</a><span>|</span><a href="#42348788">next</a><span>|</span><label class="collapse" for="c-42346981">[-]</label><label class="expand" for="c-42346981">[1 more]</label></div><br/><div class="children"><div class="content">Turning off automatic autocorrect is one of the first thing I do when i get a new phone. Sure, show me suggestions, but let me decide myself if I want them or not!</div><br/></div></div></div></div><div id="42348788" class="c"><input type="checkbox" id="c-42348788" checked=""/><div class="controls bullet"><span class="by">Gehinnn</span><span>|</span><a href="#42345893">prev</a><span>|</span><a href="#42345540">next</a><span>|</span><label class="collapse" for="c-42348788">[-]</label><label class="expand" for="c-42348788">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think the primary change is that these debates were focused on producing diffs that humans read; now the debate is whether the algorithms can accomplish this result with no human involvement at all.<p>The better the diff captures the intent of the user change, the easier the diff is to read, AND it also becomes easier to understand merge conflicts, as the conflict becomes a conflict of intents and not characters.
Sometimes certain conflicts can even be avoided if the diffs are chosen right (or are expressive enough, e.g. when code moves can be detected).</div><br/></div></div><div id="42345540" class="c"><input type="checkbox" id="c-42345540" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42348788">prev</a><span>|</span><a href="#42350350">next</a><span>|</span><label class="collapse" for="c-42345540">[-]</label><label class="expand" for="c-42345540">[1 more]</label></div><br/><div class="children"><div class="content">My rephrasing of the problem on coordination-free algorithms is that collaboration is largely a subset of correspondence.  For some reason, so many of these discussions try to treat it as a completely separate thing.  This invariably results in longer feedback loops for those corresponding with no direct communication of what, specifically, they have done.</div><br/></div></div><div id="42350350" class="c"><input type="checkbox" id="c-42350350" checked=""/><div class="controls bullet"><span class="by">eps</span><span>|</span><a href="#42345540">prev</a><span>|</span><a href="#42344495">next</a><span>|</span><label class="collapse" for="c-42350350">[-]</label><label class="expand" for="c-42350350">[1 more]</label></div><br/><div class="children"><div class="content">OP, your site&#x27;s scrolling is completely broken on an older iPad. Just can&#x27;t scroll the page at all. It shows only first screenful. Pulling it up just shows whitespace below and bounces back. Reader mode shows the whole page, but then all formatting is gone, so it&#x27;s also unreadable. Just FYI.</div><br/></div></div><div id="42344495" class="c"><input type="checkbox" id="c-42344495" checked=""/><div class="controls bullet"><span class="by">robertclaus</span><span>|</span><a href="#42350350">prev</a><span>|</span><a href="#42345835">next</a><span>|</span><label class="collapse" for="c-42344495">[-]</label><label class="expand" for="c-42344495">[4 more]</label></div><br/><div class="children"><div class="content">The most surprising part of this article for someone uninitiated like myself is probably that products&#x2F;algorithms are claiming this automatic reconciliation is consistently possible. Maybe I&#x27;ve spent too much time resolving code merge conflicts by hand, but this seems intuitively obvious to me...<p>Feels like <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1831" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1831</a></div><br/><div id="42344977" class="c"><input type="checkbox" id="c-42344977" checked=""/><div class="controls bullet"><span class="by">williamstein</span><span>|</span><a href="#42344495">parent</a><span>|</span><a href="#42345835">next</a><span>|</span><label class="collapse" for="c-42344977">[-]</label><label class="expand" for="c-42344977">[3 more]</label></div><br/><div class="children"><div class="content">What they claim is that if all editing stops, then after a period of time everybody will be looking at the SAME document.  This is what is meant by &quot;eventual consistency&quot;.  Achieving this in general is indeed a difficult problem, but (some of) these algorithms do solve it, though it can be  tricky to correctly prove that they do.   I agree that it is not possible to ensure that the document everybody is looking at is what they actually wanted it to be.  However, there are some options for what happens, where some results may be technically correct -- we are all looking at the same thing -- but obviously really bad.  This beautiful talk has some examples: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=x7drE24geUw" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=x7drE24geUw</a></div><br/><div id="42345866" class="c"><input type="checkbox" id="c-42345866" checked=""/><div class="controls bullet"><span class="by">robertclaus</span><span>|</span><a href="#42344495">root</a><span>|</span><a href="#42344977">parent</a><span>|</span><a href="#42345835">next</a><span>|</span><label class="collapse" for="c-42345866">[-]</label><label class="expand" for="c-42345866">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t eventual consistency theoretically trivial...? You just delete the whole document after every transaction. I think it&#x27;s safe to assume anyone talking about this _means_ the results remain meaningful - which for text&#x2F;meaning is subjective.</div><br/><div id="42347280" class="c"><input type="checkbox" id="c-42347280" checked=""/><div class="controls bullet"><span class="by">williamstein</span><span>|</span><a href="#42344495">root</a><span>|</span><a href="#42345866">parent</a><span>|</span><a href="#42345835">next</a><span>|</span><label class="collapse" for="c-42347280">[-]</label><label class="expand" for="c-42347280">[1 more]</label></div><br/><div class="children"><div class="content">Proving that there exists an algorithm that results in an eventually consistent view of the document is trivial.  However, that&#x27;s not what we&#x27;re talking about.  Instead, researchers define a specific algorithm (e.g., involving CRDT&#x27;s or OT&#x27;s or something else), then prove that their algorithm results in an eventually consistent state.     This reminds me a little of the relationship between proving that there exists an algorithm to factor all positive integers (this is trivial) and proving there exists a subexponential time algorithm to factor integers, which is much less trivial (see <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lenstra_elliptic-curve_factorization" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lenstra_elliptic-curve_factori...</a>).</div><br/></div></div></div></div></div></div></div></div><div id="42345835" class="c"><input type="checkbox" id="c-42345835" checked=""/><div class="controls bullet"><span class="by">klntsky</span><span>|</span><a href="#42344495">prev</a><span>|</span><a href="#42351448">next</a><span>|</span><label class="collapse" for="c-42345835">[-]</label><label class="expand" for="c-42345835">[5 more]</label></div><br/><div class="children"><div class="content">Looks like a good use case for LLMs!<p><a href="https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;67538beb-73e8-800a-b602-fe26b131e543" rel="nofollow">https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;67538beb-73e8-800a-b602-fe26b131e5...</a><p>HMU if interested in building it</div><br/><div id="42348685" class="c"><input type="checkbox" id="c-42348685" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42345835">parent</a><span>|</span><a href="#42348972">next</a><span>|</span><label class="collapse" for="c-42348685">[-]</label><label class="expand" for="c-42348685">[1 more]</label></div><br/><div class="children"><div class="content">Author here! We have experimented with building this, see my comment elsewhere here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42348651">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42348651</a><p>One of the surprising things is that LLMs regularly &quot;fix&quot; things that no other system can fix. Like if we both add the same sentence to a doc. It&#x27;s interesting stuff.<p>With that said I am not sure that this specific LLM is providing the &quot;right&quot; answer. It seems like <i>AN</i> answer! But I think the real solution might be to ask the user what to do.</div><br/></div></div><div id="42348972" class="c"><input type="checkbox" id="c-42348972" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#42345835">parent</a><span>|</span><a href="#42348685">prev</a><span>|</span><a href="#42346925">next</a><span>|</span><label class="collapse" for="c-42348972">[-]</label><label class="expand" for="c-42348972">[1 more]</label></div><br/><div class="children"><div class="content">Take what you wrote and flip it and you get a different answer:<p><a href="https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;67542c95-fea8-8008-8749-7b7daf355c54" rel="nofollow">https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;67542c95-fea8-8008-8749-7b7daf355c...</a><p>Here is the resulting semantically meaningful diff that reconciles the edits:<p>- The color of orange is orange<p>+ The colour of orange is orange<p>This reflects the change in spelling from &quot;color&quot; to &quot;colour,&quot; which is the only meaningful difference between the two edits.</div><br/></div></div><div id="42346925" class="c"><input type="checkbox" id="c-42346925" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#42345835">parent</a><span>|</span><a href="#42348972">prev</a><span>|</span><a href="#42348378">next</a><span>|</span><label class="collapse" for="c-42346925">[-]</label><label class="expand" for="c-42346925">[1 more]</label></div><br/><div class="children"><div class="content">Hardly.  That just threw away Edit1, failing to follow instructions even in this very simple case.</div><br/></div></div><div id="42348378" class="c"><input type="checkbox" id="c-42348378" checked=""/><div class="controls bullet"><span class="by">tags2k</span><span>|</span><a href="#42345835">parent</a><span>|</span><a href="#42346925">prev</a><span>|</span><a href="#42351448">next</a><span>|</span><label class="collapse" for="c-42348378">[-]</label><label class="expand" for="c-42348378">[1 more]</label></div><br/><div class="children"><div class="content">o1 gets the original article question correct: <a href="https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;675410c1-22c4-8001-b36a-24425127cc10" rel="nofollow">https:&#x2F;&#x2F;chatgpt.com&#x2F;share&#x2F;675410c1-22c4-8001-b36a-24425127cc...</a></div><br/></div></div></div></div><div id="42351448" class="c"><input type="checkbox" id="c-42351448" checked=""/><div class="controls bullet"><span class="by">jFriedensreich</span><span>|</span><a href="#42345835">prev</a><span>|</span><a href="#42351602">next</a><span>|</span><label class="collapse" for="c-42351448">[-]</label><label class="expand" for="c-42351448">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree with this article, and this is about collaborative text editing, which is something these solutions and algorithms are actually good at. Looking at everything from crdt fanboys applying this to application data and ignoring the UI&#x2F;UX aspects about conflict resolution makes my neck hair stand up. This is how we end up with linear giving talks about their &quot;sync engine&quot; and happily deleting other users changes with last write wins.</div><br/></div></div><div id="42351602" class="c"><input type="checkbox" id="c-42351602" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42351448">prev</a><span>|</span><a href="#42344933">next</a><span>|</span><label class="collapse" for="c-42351602">[-]</label><label class="expand" for="c-42351602">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s ironic how js-experts could not make examples work on the article page.</div><br/></div></div><div id="42344933" class="c"><input type="checkbox" id="c-42344933" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#42351602">prev</a><span>|</span><a href="#42345474">next</a><span>|</span><label class="collapse" for="c-42344933">[-]</label><label class="expand" for="c-42344933">[2 more]</label></div><br/><div class="children"><div class="content">Just use git (:
(Half joking)</div><br/><div id="42348659" class="c"><input type="checkbox" id="c-42348659" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42344933">parent</a><span>|</span><a href="#42345474">next</a><span>|</span><label class="collapse" for="c-42348659">[-]</label><label class="expand" for="c-42348659">[1 more]</label></div><br/><div class="children"><div class="content">Author here! I think you&#x27;re going to like one of the upcoming posts in this series. :)</div><br/></div></div></div></div><div id="42345474" class="c"><input type="checkbox" id="c-42345474" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#42344933">prev</a><span>|</span><a href="#42346714">next</a><span>|</span><label class="collapse" for="c-42345474">[-]</label><label class="expand" for="c-42345474">[8 more]</label></div><br/><div class="children"><div class="content">Now that there are LLMs available, why is this still a problem? You just have to detect the conflicts and show a powerful enough LLM the two versions and tell it to do its best job at merging. This solves exactly the kind of issue described in the post. Oh, bonus point: you don&#x27;t have to take any metadata.</div><br/><div id="42345957" class="c"><input type="checkbox" id="c-42345957" checked=""/><div class="controls bullet"><span class="by">miltonlost</span><span>|</span><a href="#42345474">parent</a><span>|</span><a href="#42348651">next</a><span>|</span><label class="collapse" for="c-42345957">[-]</label><label class="expand" for="c-42345957">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You just have to detect the conflicts and show a powerful enough LLM the two versions and tell it to do its best job at merging. This solves exactly the kind of issue described in the post.<p>How does &quot;LLM tries its best&quot; solve the problem of exactly syncing documents offline? &quot;Tries its best&quot; implies it could fail which is what the problem already is. An LLM only adds a new layer of abstraction, but now the downside is it&#x27;s impossible to analyze.<p>Maybe I just have a much higher threshold of &quot;solved&quot; than you do, but anything non-deterministic (without some human judgment a la git) is not a good solve for document syncing.<p>A &quot;powerful enough LLM&quot; is the equivalent of &quot;and a wizard does it&quot;.</div><br/><div id="42346007" class="c"><input type="checkbox" id="c-42346007" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#42345474">root</a><span>|</span><a href="#42345957">parent</a><span>|</span><a href="#42348651">next</a><span>|</span><label class="collapse" for="c-42346007">[-]</label><label class="expand" for="c-42346007">[1 more]</label></div><br/><div class="children"><div class="content">LLMs at t=0 are predictable (will produce the same output starting from the same input) and do a much better merge work than any other non ML based algorithm.<p>Cut &amp; paste all the examples you can come up to Claude and tell me if LLMs are not able to do this kind of merging.</div><br/></div></div></div></div><div id="42348651" class="c"><input type="checkbox" id="c-42348651" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42345474">parent</a><span>|</span><a href="#42345957">prev</a><span>|</span><a href="#42346304">next</a><span>|</span><label class="collapse" for="c-42348651">[-]</label><label class="expand" for="c-42348651">[1 more]</label></div><br/><div class="children"><div class="content">Author here! This comment is kind of getting dragged here and elsewhere but I actually think it&#x27;s not completely ridiculous. You can (and we have) presented git-style merge conflicts to an LLM and it will mostly fix them in ways that no algorithm can.<p>One example of this is if you and I both add a similar sentence in different spots in the document, asking an LLM to merge this will often result in only one of the sentences being accepted. It&#x27;s not perfect but it&#x27;s the kind of thing you can&#x27;t get in any other technology!<p>With that all said I don&#x27;t think LLMs <i>REPLACE</i> merge algorithms. For one, to get sensible output from the LLMs you generally need a diff of some kind, either git style or as the trace ouput of something like eg-walker.</div><br/></div></div><div id="42346304" class="c"><input type="checkbox" id="c-42346304" checked=""/><div class="controls bullet"><span class="by">jakelazaroff</span><span>|</span><a href="#42345474">parent</a><span>|</span><a href="#42348651">prev</a><span>|</span><a href="#42347269">next</a><span>|</span><label class="collapse" for="c-42346304">[-]</label><label class="expand" for="c-42346304">[3 more]</label></div><br/><div class="children"><div class="content">If there are only two conflicting updates, sure, maybe that would work. But there might be more than two peers, and their updates might arrive in any order. That&#x27;s why CRDT merges must be both commutative and associative.<p>Can we guarantee that an LLM will get exactly the same result merging (A ∨ B) ∨ C as it would merging A ∨ (B ∨ C)? Even when the temperature is 0?</div><br/><div id="42347227" class="c"><input type="checkbox" id="c-42347227" checked=""/><div class="controls bullet"><span class="by">mweidner</span><span>|</span><a href="#42345474">root</a><span>|</span><a href="#42346304">parent</a><span>|</span><a href="#42347269">next</a><span>|</span><label class="collapse" for="c-42347227">[-]</label><label class="expand" for="c-42347227">[2 more]</label></div><br/><div class="children"><div class="content">You could avoid the CRDT rules if you only use the LLM on the server. I.e., user comes online and sends their diff to the server, which LLM-merges it into the latest state and then sends that back to all clients.<p>This doesn&#x27;t help you do merges client-side during live collaboration (for showing your optimistic local updates), but there the low latency reduces conflicts anyway, so you can fall back on a semantically-imperfect CRDT.</div><br/><div id="42347262" class="c"><input type="checkbox" id="c-42347262" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42345474">root</a><span>|</span><a href="#42347227">parent</a><span>|</span><a href="#42347269">next</a><span>|</span><label class="collapse" for="c-42347262">[-]</label><label class="expand" for="c-42347262">[1 more]</label></div><br/><div class="children"><div class="content">If you have a central server, you don&#x27;t need CRDTs, which are designed to work even in pure peer-to-peer scenarios. Figma is one example of this [0]:<p>&gt; <i>Figma isn&#x27;t using true CRDTs though. CRDTs are designed for decentralized systems where there is no single central authority to decide what the final state should be. There is some unavoidable performance and memory overhead with doing this. Since Figma is centralized (our server is the central authority), we can simplify our system by removing this extra overhead and benefit from a faster and leaner implementation.</i><p>&gt; <i>It’s also worth noting that Figma&#x27;s data structure isn&#x27;t a single CRDT. Instead it&#x27;s inspired by multiple separate CRDTs and uses them in combination to create the final data structure that represents a Figma document (described below).</i><p>[0] <a href="https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology-works&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.figma.com&#x2F;blog&#x2F;how-figmas-multiplayer-technology...</a></div><br/></div></div></div></div></div></div><div id="42347269" class="c"><input type="checkbox" id="c-42347269" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42345474">parent</a><span>|</span><a href="#42346304">prev</a><span>|</span><a href="#42346714">next</a><span>|</span><label class="collapse" for="c-42347269">[-]</label><label class="expand" for="c-42347269">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly how I see it too, true intelligent merging algorithms are, at the limit, going to be basically LLMs because only something that powerful can understand user intent in a way that non-ML algorithms cannot.</div><br/></div></div></div></div><div id="42346714" class="c"><input type="checkbox" id="c-42346714" checked=""/><div class="controls bullet"><span class="by">smoyer</span><span>|</span><a href="#42345474">prev</a><span>|</span><a href="#42344421">next</a><span>|</span><label class="collapse" for="c-42346714">[-]</label><label class="expand" for="c-42346714">[2 more]</label></div><br/><div class="children"><div class="content">I miss Google Wave.</div><br/><div id="42346828" class="c"><input type="checkbox" id="c-42346828" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#42346714">parent</a><span>|</span><a href="#42344421">next</a><span>|</span><label class="collapse" for="c-42346828">[-]</label><label class="expand" for="c-42346828">[1 more]</label></div><br/><div class="children"><div class="content">Oh! Now I remember the name of the tool that came before Google wave and (I think) inspired it.<p>Etherpad.</div><br/></div></div></div></div><div id="42344421" class="c"><input type="checkbox" id="c-42344421" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#42346714">prev</a><span>|</span><a href="#42344506">next</a><span>|</span><label class="collapse" for="c-42344421">[-]</label><label class="expand" for="c-42344421">[5 more]</label></div><br/><div class="children"><div class="content">The example seems like it would be easier if we’d gone in the direction of allowing more complex commands, like vim does. Imagine if real editors had been developed for the last 30 years or however long, instead of stagnating at vim (which is clearly a nice text editor, but it could be nice to have an editor designed around writing prose). Maybe neovim will save us. Some day.<p>Bob’s intent is to edit the word color, and inserting a u. But, he is limited to just expressing “put u here,” which is not at all what he wants to <i>achieve</i> it is just a mechanical description of what operations need to occur.<p>Alice’s intent is to delete the whole sentence, but she’s similarly limited to just saying “delete delete deleted delete delete…” to a bunch of letters.<p>Ending up with a u is the obvious dumb result of treating language as a pile  of characters. The correct behavior is to say: because the world Bob has edited no longer exists, his edit is clearly nonsense, don’t apply it. Which editor does that?</div><br/><div id="42344500" class="c"><input type="checkbox" id="c-42344500" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#42344421">parent</a><span>|</span><a href="#42344506">next</a><span>|</span><label class="collapse" for="c-42344500">[-]</label><label class="expand" for="c-42344500">[4 more]</label></div><br/><div class="children"><div class="content">Considering that software can only guess the intent if it&#x27;s not declared explicitly, I&#x27;m curious what such an &quot;intent declaration&quot; language would look like.</div><br/><div id="42344759" class="c"><input type="checkbox" id="c-42344759" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42344421">root</a><span>|</span><a href="#42344500">parent</a><span>|</span><a href="#42351888">next</a><span>|</span><label class="collapse" for="c-42344759">[-]</label><label class="expand" for="c-42344759">[2 more]</label></div><br/><div class="children"><div class="content">At the limit, it would probably look like an LLM, because it&#x27;s akin to rules-based AI in the &#x27;90s vs neural network AI today. Expert systems had programmers write many rules in order to process information, which is what this &quot;intent declaration&quot; language would also be like, users writing many rules that would be followed. But this approach didn&#x27;t work because even humans didn&#x27;t even know all of the rules needed, therefore we turned to the statistical approaches of current neural network AI.</div><br/><div id="42349694" class="c"><input type="checkbox" id="c-42349694" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#42344421">root</a><span>|</span><a href="#42344759">parent</a><span>|</span><a href="#42351888">next</a><span>|</span><label class="collapse" for="c-42349694">[-]</label><label class="expand" for="c-42349694">[1 more]</label></div><br/><div class="children"><div class="content">We are aligned. Software cannot identify intentions.<p>Heck, even person A cannot identify intentions of person B in a systematic way.<p>Hence it&#x27;s a non-solvable problem.</div><br/></div></div></div></div><div id="42351888" class="c"><input type="checkbox" id="c-42351888" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#42344421">root</a><span>|</span><a href="#42344500">parent</a><span>|</span><a href="#42344759">prev</a><span>|</span><a href="#42344506">next</a><span>|</span><label class="collapse" for="c-42351888">[-]</label><label class="expand" for="c-42351888">[1 more]</label></div><br/><div class="children"><div class="content">s&#x2F;color&#x2F;colour&#x2F;g</div><br/></div></div></div></div></div></div><div id="42344506" class="c"><input type="checkbox" id="c-42344506" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42344421">prev</a><span>|</span><label class="collapse" for="c-42344506">[-]</label><label class="expand" for="c-42344506">[2 more]</label></div><br/><div class="children"><div class="content">This is so, so, sooo good. I&#x27;ve never been brave enough to say it out loud, but this is 110% my experience.<p>I imagine it is somewhat a consequence of the divide between engineering and product.<p>It <i>can</i> resolve all conflicts, and it&#x27;s such a holy grail to go decentralized &#x2F; get Google Docs-like editing down to a a package in your favorite language. But, in practice, its intractable for arbitrary data, even just an arbitrary string.<p>I do wish there was a formal proof that showed &#x2F; proved this to share in HN discussions re: CRDTs...but hey, this is great! The &quot;it left a u&quot; example is simple, intuitive, and with a charitable listener, I doubt they&#x27;d argue we can&#x27;t figure out a string unambiguously, but we can figure out JSON unmabiguously.</div><br/><div id="42348612" class="c"><input type="checkbox" id="c-42348612" checked=""/><div class="controls bullet"><span class="by">antics</span><span>|</span><a href="#42344506">parent</a><span>|</span><label class="collapse" for="c-42348612">[-]</label><label class="expand" for="c-42348612">[1 more]</label></div><br/><div class="children"><div class="content">Author here, thanks for the kind words! I think one reason we ended up here is that it is a genuinely difficult technical problem even to <i>analyze the solutions.</i> One of my hopes for this series of posts is that it makes the evaluation process more straightforward, particularly for people who do not have a strong background in distributed systems algorithms.</div><br/></div></div></div></div></div></div></div></div></div></body></html>