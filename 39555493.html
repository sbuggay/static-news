<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709283672982" as="style"/><link rel="stylesheet" href="styles.css?v=1709283672982"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://maximullaris.com/gc_less_java.html">Experimenting with GC-less (heap-less) Java</a> <span class="domain">(<a href="https://maximullaris.com">maximullaris.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>3 comments</span></div><br/><div><div id="39559259" class="c"><input type="checkbox" id="c-39559259" checked=""/><div class="controls bullet"><span class="by">_nalply</span><span>|</span><label class="collapse" for="c-39559259">[-]</label><label class="expand" for="c-39559259">[2 more]</label></div><br/><div class="children"><div class="content">From my experience from more than a dozen years ago:<p>To avoid allocation churn, one can use a big array of objects and for each index a flag whether the array element contains an object or not. Today I would say I used an arena. Combined with the fly-weight pattern in some use cases you don&#x27;t need to reach for unsafe at all. For me it was about a visual simulation of chemical reactions. In each frame iteration an array was held and even this long time ago it was fast enough to allow smooth animation with tens of thousands of possibly colliding particles.<p>I respect research out of curiousity. This way we learn what works and what doesn&#x27;t work. So keep up this work but I just wanted to tell about the boring alternative.</div><br/><div id="39559820" class="c"><input type="checkbox" id="c-39559820" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39559259">parent</a><span>|</span><label class="collapse" for="c-39559820">[-]</label><label class="expand" for="c-39559820">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a big array of objects for each index a flag whether the array element contains an object or not.<p>Typically, you never need to iterate through all used objects. Also, all unused objects are interchangeable from the program’s view. Each just is a chunk of memory that you can use to write a Foo to.<p>That leads to the standard way to do this for objects that are at least as large as a pointer: make the array an array of <i>union{Foo, Foo*}</i>, and, at allocation, create a linked list through all the unused entries. Getting memory for a new <i>Foo</i> then is just a matter of removing the head of the list, freeing a <i>Foo</i> a matter of appending it to the head of the list.<p>That means you don’t need <i>n</i> flags (one for each entry, but only a single <i>Foo*</i> pointing to the head of the free list. That’s a big gain if <i>n</i> is large.<p>(Doing that in Java is left as an exercise. It may not be possible)</div><br/></div></div></div></div></div></div></div></div></div></body></html>