<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688115646420" as="style"/><link rel="stylesheet" href="styles.css?v=1688115646420"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://abstractexpr.com/2023/06/29/structures-in-c-from-basics-to-memory-alignment/">Structures in C: From Basics to Memory Alignment</a> <span class="domain">(<a href="https://abstractexpr.com">abstractexpr.com</a>)</span></div><div class="subtext"><span>aheck</span> | <span>49 comments</span></div><br/><div><div id="36528155" class="c"><input type="checkbox" id="c-36528155" checked=""/><div class="controls bullet"><span class="by">defen</span><span>|</span><a href="#36530383">next</a><span>|</span><label class="collapse" for="c-36528155">[-]</label><label class="expand" for="c-36528155">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In C99 it is allowed to declare the last member of a structure as an array with no number of elements specified. The size of the struct will then be as if the last member did not exist.<p>There&#x27;s one gotcha here, which is that the alignment requirements of the flexible array member can change the size of the struct. For example the following fails on x86_64-linux-gnu:<p><pre><code>    struct flexible_char {
        char c;
        char arr[];
    };
    
    struct flexible_int {
        char c;
        int arr[];
    };
    
    _Static_assert(sizeof(struct flexible_char) == sizeof(struct flexible_int), &quot;size mismatch&quot;);

</code></pre>
Because `struct flexible_int` needs to be 4-byte aligned but `struct flexible_char` only needs to be 1-byte aligned.</div><br/></div></div><div id="36530383" class="c"><input type="checkbox" id="c-36530383" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#36528155">prev</a><span>|</span><a href="#36528328">next</a><span>|</span><label class="collapse" for="c-36530383">[-]</label><label class="expand" for="c-36530383">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But what if we want a struct to feel like a real C type?<p>Remove this; it&#x27;s already a real type. You could go over the two namespaces and why you need to type &#x27;struct&#x27; otherwise, but I wouldn&#x27;t present a false dichotomy of real and &quot;unreal&quot; types.<p>&gt; Declaring a Struct as a New Type<p>It&#x27;s not really a new type. It&#x27;s a type alias, and the two names can be used interchangeably. I would just call it a type alias.<p><a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;typedef" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;typedef</a><p>&gt; If we declare a structure variable without initializing it, like any other variable in C, it will be uninitialized at first and may contain random values.<p>I also see no mention of = {} or = {0} (I forget which is Standard C and which is C++). Since you already talk about &quot;random values&quot;, you might as well explain how to 0-initialize a struct.</div><br/><div id="36530619" class="c"><input type="checkbox" id="c-36530619" checked=""/><div class="controls bullet"><span class="by">dropbear3</span><span>|</span><a href="#36530383">parent</a><span>|</span><a href="#36528328">next</a><span>|</span><label class="collapse" for="c-36530619">[-]</label><label class="expand" for="c-36530619">[2 more]</label></div><br/><div class="children"><div class="content">{0} is standard C. {} is currently a (common) compiler extension but will be standard C23: <a href="https:&#x2F;&#x2F;open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG14&#x2F;www&#x2F;docs&#x2F;n2900.htm" rel="nofollow noreferrer">https:&#x2F;&#x2F;open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG14&#x2F;www&#x2F;docs&#x2F;n2900.htm</a></div><br/><div id="36530793" class="c"><input type="checkbox" id="c-36530793" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#36530383">root</a><span>|</span><a href="#36530619">parent</a><span>|</span><a href="#36528328">next</a><span>|</span><label class="collapse" for="c-36530793">[-]</label><label class="expand" for="c-36530793">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s a bit frustrating, especially for headers with inline&#x2F;macro code. And for headers, requiring C23 doesn&#x27;t seem sensible for quite some time. I define a macro:<p><pre><code>    #ifdef __cplusplus
    # define ZERO_INIT {}
    #else
    # define ZERO_INIT {0}
    #endif
</code></pre>
Works for arrays, aggregates, scalars, etc., but I just use it for arrays and aggregates: `char buf[32] = ZERO_INIT; struct X x = ZERO_INIT;`</div><br/></div></div></div></div></div></div><div id="36528328" class="c"><input type="checkbox" id="c-36528328" checked=""/><div class="controls bullet"><span class="by">somenits</span><span>|</span><a href="#36530383">prev</a><span>|</span><a href="#36527116">next</a><span>|</span><label class="collapse" for="c-36528328">[-]</label><label class="expand" for="c-36528328">[7 more]</label></div><br/><div class="children"><div class="content">Good article, a couple nits&#x2F;additional notes:<p>1. The article points out you should compare structs field by field, but it doesn&#x27;t explain why memcmp wouldn&#x27;t work. The reason is that the padding between the fields might not necessarily be zeroed in all cases. Field by field comparison is resilient to this.<p>2. The article proposes this for dynamic allocation:<p><pre><code>    struct Vector2D *vec = malloc(sizeof(struct Vector2D));
</code></pre>
I think it&#x27;s better to use the variable name inside sizeof, so like this:<p><pre><code>    struct Vector2D *vec = malloc(sizeof(*vec));
</code></pre>
This helps you in the case where you change the type of the variable to different kind of struct. If you change the variable name, you&#x27;re probably doing a find&#x2F;replace anyway, and it will almost certainly fail to compile even if you miss it.</div><br/><div id="36529644" class="c"><input type="checkbox" id="c-36529644" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36528328">parent</a><span>|</span><a href="#36529761">next</a><span>|</span><label class="collapse" for="c-36529644">[-]</label><label class="expand" for="c-36529644">[1 more]</label></div><br/><div class="children"><div class="content">But if you change the type name, you are probably also doing a search and replace.<p>In the end, the only justification for the latter rather than the former is that the pointer name is often a short name like <i>vec</i>, and so <i>sizeof *vec</i> is shorter than the alternative.<p>That has advantages.<p>If there is a typo in a short name, you&#x27;re more likely to see it.<p>I can easily miss the typo:<p><pre><code>  struct Vector3D *vec = malloc(sizeof(struct Vector2D));
</code></pre>
The sizeof &lt;object-expr&gt; also doesn&#x27;t require parentheses, so it&#x27;s shorter by two characters right off the bat.</div><br/></div></div><div id="36529761" class="c"><input type="checkbox" id="c-36529761" checked=""/><div class="controls bullet"><span class="by">throwaway894345</span><span>|</span><a href="#36528328">parent</a><span>|</span><a href="#36529644">prev</a><span>|</span><a href="#36527116">next</a><span>|</span><label class="collapse" for="c-36529761">[-]</label><label class="expand" for="c-36529761">[5 more]</label></div><br/><div class="children"><div class="content">I’ve been wondering about (1) recently—is there a way to memset the entire stack frame at the start of a function such that memcmp works as expected? Also, what are the performance implications of comparing a padded struct member-by-member vs a single big memcmp? Is member-by-member faster because you’re comparing less in total, or is memcmp faster because it’s one big contiguous compare? Or is it more complicated?<p>Regarding (2), sizeof(*x) doesn’t actually dereference x, right? The dereference isn’t evaluated—it’s all calculated at compile time, right?</div><br/><div id="36532201" class="c"><input type="checkbox" id="c-36532201" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#36528328">root</a><span>|</span><a href="#36529761">parent</a><span>|</span><a href="#36530951">next</a><span>|</span><label class="collapse" for="c-36532201">[-]</label><label class="expand" for="c-36532201">[1 more]</label></div><br/><div class="children"><div class="content">If you really wanted to memcmp a padded struct, you could declare it as packed and define the padding yourself.</div><br/></div></div><div id="36530951" class="c"><input type="checkbox" id="c-36530951" checked=""/><div class="controls bullet"><span class="by">DSMan195276</span><span>|</span><a href="#36528328">root</a><span>|</span><a href="#36529761">parent</a><span>|</span><a href="#36532201">prev</a><span>|</span><a href="#36530053">next</a><span>|</span><label class="collapse" for="c-36530951">[-]</label><label class="expand" for="c-36530951">[2 more]</label></div><br/><div class="children"><div class="content">&gt; is there a way to memset the entire stack frame at the start of a function such that memcmp works as expected?<p>I&#x27;d argue no simply because the value of the padding bytes is always unspecified. A compiler that sees such a `memset` is (IMO) perfectly free to not zero known padding bytes since it knows their value should not matter to the program. Compilers might not currently do that but you can already see this kind of behavior in other situations - C compilers will happily throw out `memset` calls if it knows the result won&#x27;t be used.<p>But also beyond that, it probably doesn&#x27;t matter anyway because there&#x27;s no way to _use_ the `struct` which won&#x27;t leave the padding bytes with unspecified values. `memset` might reliably zero the padding bytes for you, but writing to the struct will randomly screw up the padding bytes depending on what the compiler feels is the best way to do things, so then you&#x27;re back at `memcmp` no longer working. The only real way to make `memcmp` work is to ensure you have no padding bytes to begin with.</div><br/><div id="36531433" class="c"><input type="checkbox" id="c-36531433" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36528328">root</a><span>|</span><a href="#36530951">parent</a><span>|</span><a href="#36530053">next</a><span>|</span><label class="collapse" for="c-36531433">[-]</label><label class="expand" for="c-36531433">[1 more]</label></div><br/><div class="children"><div class="content">Compiles are free to not zero padding bytes if a struct is passed to memset but there are some situations where padding is not unspecified, for example if you do partial initialization of it.</div><br/></div></div></div></div><div id="36530053" class="c"><input type="checkbox" id="c-36530053" checked=""/><div class="controls bullet"><span class="by">cmovq</span><span>|</span><a href="#36528328">root</a><span>|</span><a href="#36529761">parent</a><span>|</span><a href="#36530951">prev</a><span>|</span><a href="#36527116">next</a><span>|</span><label class="collapse" for="c-36530053">[-]</label><label class="expand" for="c-36530053">[1 more]</label></div><br/><div class="children"><div class="content">(1) If the pointers you pass to memcmp are know to the compiler, then memcmp will be treated as an intrinsic, and generally the compiler generates the optimal set of instructions for a given struct.<p>(2) Correct. The expression is only evaluated at compile time.</div><br/></div></div></div></div></div></div><div id="36527116" class="c"><input type="checkbox" id="c-36527116" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#36528328">prev</a><span>|</span><a href="#36530326">next</a><span>|</span><label class="collapse" for="c-36527116">[-]</label><label class="expand" for="c-36527116">[20 more]</label></div><br/><div class="children"><div class="content">&gt; The only good reason to use packed structures is when you need to map some memory (e.g. hardware registers exposed to memory) bit by bit to a structure.<p>Another common reason is when two CPUs of different architecture need to access the same structure in memory. E.g. you have a RiscV and an Arm64 processor in the same system, sharing memory. Or you read structured binary data from disk and need to specify an exact layout.</div><br/><div id="36528330" class="c"><input type="checkbox" id="c-36528330" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#36527116">parent</a><span>|</span><a href="#36529775">next</a><span>|</span><label class="collapse" for="c-36528330">[-]</label><label class="expand" for="c-36528330">[2 more]</label></div><br/><div class="children"><div class="content">&quot;The only good reason to &quot;<p>The word opinionated was coined and adopted in English to describe a certain attitude.  It has functioned fine for (probably) centuries (who knows, and I can&#x27;t be bothered to research too far). Then came the age of IT and blow me, are we not opinionated to the point of ridiculousness.<p>A sentence construction along the lines of &quot;The only good reason to&quot; [do x] &quot;is&quot; [y], seems to invite a negation, quite aggressively.  You might as well stand in the rain, wearing steel armour, and holding a long copper rod ... and shout &quot;All Gods are bastards&quot; (as a Knight of the Realm, sadly deceased, from hereabouts suggested might be an unwise life shortening decision).<p>I&#x27;m pretty sure packed structures have other uses.</div><br/><div id="36530407" class="c"><input type="checkbox" id="c-36530407" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36528330">parent</a><span>|</span><a href="#36529775">next</a><span>|</span><label class="collapse" for="c-36530407">[-]</label><label class="expand" for="c-36530407">[1 more]</label></div><br/><div class="children"><div class="content">Good call. Such statement implies that there is no other reason, as obvious as that might sound. Just say &quot;One reason to&quot; to avoid implying that&#x27;s the only one.<p>&gt; I&#x27;m pretty sure packed structures have other uses.<p>Like reducing memory footprint.</div><br/></div></div></div></div><div id="36529775" class="c"><input type="checkbox" id="c-36529775" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36527116">parent</a><span>|</span><a href="#36528330">prev</a><span>|</span><a href="#36531299">next</a><span>|</span><label class="collapse" for="c-36529775">[-]</label><label class="expand" for="c-36529775">[1 more]</label></div><br/><div class="children"><div class="content">Unless you&#x27;re using weird C compilers, you shouldn&#x27;t need to pack structures in order to have RiscV and Arm64 access the same structure. Packing structures will be detrimental in a situation where any of the processors have alignment requirements for accessing words. Extra instructions may be required to access that four byte member at offset 13, by using two accesses and some shifting and masking. Atomicity has gone out the window.<p>If we look at, say, GCC, the structure layout rules are very consistent across the targets. They are not absolutely the same, but consistent enough to work with.<p>Packing won&#x27;t take care of byte order, though it&#x27;s not super common to have a system where hosts of opposite byte order are accessing the same buses, and sharing memory. (I&#x27;ve worked on systems where a DPS had &quot;weird order&quot;, like opposite endian from the host, but in 16 bit units. Not DCBA but CDBA or something like that.)<p>You may be tempted to use a packed structure for conforming to some layout in a network packet or on disk, but it leaves the code nonportable and slow. In between the time the packed structure is read from the file and written again, it might be accessed many times. All those times may be slowed down due to the packing. You may be better off writing proper serializing and deserializing.  That can also help if there are multiple versions of the format, or some optional fields and other crap. You may be able to map all the variants onto a single in-memory structure, dealing with the differences only in the serializing and deserializing routines.<p>I&#x27;m skeptical of how common it is to need packing in order to map hardware registers bit-by-bit. Hardware registers tend to be very regularly sized and spaced. If you&#x27;re literally mapping bit-by-bit, the language extension that is most beneficial is the ability to declare a bitfield to be of any integer type. E.g. if registers are consecutive 32 bit words:<p><pre><code>   &#x2F;&#x2F; Register AREG (32 bits)
   uint32_t AREG_foo_field : 13;
   uint32_t AREG_bar_bit : 1;

   uint32_t : 0;  &#x2F;&#x2F; done with this cell: go to next

   &#x2F;&#x2F; Register BREG
   uint32_t BREG_bozo_bit : 1;
</code></pre>
Bitfield allocation is endian-dependent. In the end, for utmost portability, you want to access the 32 bit word as a word, and do the shifting and masking, where you can add a byte swap, if necessary.</div><br/></div></div><div id="36531299" class="c"><input type="checkbox" id="c-36531299" checked=""/><div class="controls bullet"><span class="by">scoutt</span><span>|</span><a href="#36527116">parent</a><span>|</span><a href="#36529775">prev</a><span>|</span><a href="#36529133">next</a><span>|</span><label class="collapse" for="c-36531299">[-]</label><label class="expand" for="c-36531299">[1 more]</label></div><br/><div class="children"><div class="content">Or you have to transmit a struct as a network packet &quot;as is&quot;, between different architectures.</div><br/></div></div><div id="36529133" class="c"><input type="checkbox" id="c-36529133" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36527116">parent</a><span>|</span><a href="#36531299">prev</a><span>|</span><a href="#36527237">next</a><span>|</span><label class="collapse" for="c-36529133">[-]</label><label class="expand" for="c-36529133">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Another common reason is when two CPUs of different architecture need to access the same structure in memory.<p>That sounds like mapping memory <i>and</i> something you could avoid with the right compiler flags.<p>&gt; Or you read structured binary data from disk and need to specify an exact layout.<p>If you need it stay in the same form it has on the disk, I think it&#x27;s fair to call that a concern in the category of &quot;map some memory&quot;.  Edit: And other spots in the text explicitly include file formats.<p>Basically I think you&#x27;re giving examples rather than exceptions.</div><br/></div></div><div id="36527237" class="c"><input type="checkbox" id="c-36527237" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36527116">parent</a><span>|</span><a href="#36529133">prev</a><span>|</span><a href="#36529844">next</a><span>|</span><label class="collapse" for="c-36527237">[-]</label><label class="expand" for="c-36527237">[12 more]</label></div><br/><div class="children"><div class="content">All of these sound weird to me—most non-stupid (hello 802.2) protocols and hardware are going to have natural-aligned structure fields, so basically any mainstream (8-bit-byte, two’s complement, etc.) ABI is going to lay them out the same way, packed or not.<p>As for RV64 and Arm64, the layout rules for same-size scalar types in their common ABIs are outright identical aren’t they?<p>We’re (most of us) a long way away from the time where each DOS compiler had its own opinions on whether long double should be 8-, 16-, 32-, or 64-bit aligned and 80 or 128 bits long.</div><br/><div id="36527601" class="c"><input type="checkbox" id="c-36527601" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36527237">parent</a><span>|</span><a href="#36527867">next</a><span>|</span><label class="collapse" for="c-36527601">[-]</label><label class="expand" for="c-36527601">[8 more]</label></div><br/><div class="children"><div class="content">&gt; All of these sound weird to me—most non-stupid (hello 802.2) protocols and hardware are going to have natural-aligned structure fields, so basically any mainstream (8-bit-byte, two’s complement, etc.) ABI is going to lay them out the same way, packed or not.<p>In the long ago year of 2015 I worked on a project where the same binary packet was:<p>1. Generated by an 8 bit micro controller<p>2. Consumed by a 32bit Cortex M3<p>3. Passed onto iPhones, Androids, Windows Phones, and Windows PCs running ObjC, Java, C#, and C++ respectively<p>4. Uploaded to a cloud provider<p>The phrase &quot;natural aligned&quot; has no meaning in that context.</div><br/><div id="36527979" class="c"><input type="checkbox" id="c-36527979" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36527601">parent</a><span>|</span><a href="#36527867">next</a><span>|</span><label class="collapse" for="c-36527979">[-]</label><label class="expand" for="c-36527979">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The phrase &quot;natural aligned&quot; has no meaning in that context.<p>The phrase “naturally aligned” as I’m accustomed to seeing it used refers to the alignment of a power-of-two-sized type (usually a scalar one) being equal to its size. Unless you’re working with, say, 18-bit or 24-bit integers (that do exist in obscure places), it does have a meaning, and unless you’re using non-eight-bit bytes that meaning is fairly universal (and if you’re not, your I&#x2F;O is probably screwed up in hard-to-predict ways[1]).<p>At least for your items 2, 3, and 4—excluding Java and C# which are not relevant to TFA about C and are likely to use manual packing code—you have, let’s see,<p>- The bytes are eight bits wide, and ASCII byte strings have their usual meaning;<p>- The integer types are wraparound unsigned and two’s complement signed least-endian with no padding bits or trap representations and come in 8-bit, 16-bit, 32-bit, and 64-bit sizes and identical alignments;<p>- The floating-point types are IEEE 754 single and double precision floats, little endian, respectively 32 bits and 64 bits in size and of identical alignment, though you should probably avoid relying on subnormals or the exact choice of NaNs;<p>- Structures and unions have the alignment requirement of their most strictly aligned member;<p>- The members of a structure are laid out at increasing offsets, with each member starting at the earliest offset permitted by its alignment (while the members of a union all start at offset zero as the standard requires);<p>- The structure or union is then padded at the end so that its alignment divides its size.<p>If you avoid extended precision and SIMD types, the default ABI settings should get you completely compatible layouts here. (On an earlier ARM you might’ve run into mixed-endian floats, but not on any Cortex flavour.) Even bitfields would be entirely fine, except Microsoft <i>bloody</i> Windows had to be stupid there.<p>Honestly the only potential problem is 1, an unspecified 8-bit controller, and that only because the implicit integer promotions of standard C make getting decent performance out of those a bit of a crapshoot, leading to noncompliant hacks like 8-bit ints or 48-bit long longs. Still, if the usual complement of 8&#x2F;16&#x2F;32&#x2F;64-bit integers is available, the worst you’re likely to have to do is spell out any structure padding explicitly.<p>[1] <a href="https:&#x2F;&#x2F;thephd.dev&#x2F;conformance-should-mean-something-fputc-and-freestanding" rel="nofollow noreferrer">https:&#x2F;&#x2F;thephd.dev&#x2F;conformance-should-mean-something-fputc-a...</a></div><br/><div id="36528431" class="c"><input type="checkbox" id="c-36528431" checked=""/><div class="controls bullet"><span class="by">owalt</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36527979">parent</a><span>|</span><a href="#36529236">next</a><span>|</span><label class="collapse" for="c-36528431">[-]</label><label class="expand" for="c-36528431">[1 more]</label></div><br/><div class="children"><div class="content">I do my current work (embedded) on an architecture with the following properties:<p>- 8-bit bytes<p>- 16-bit aligned accesses to 32-bit types<p>- 32-bit aligned accesses to 64-bit types.<p>- Struct alignment depends on the size of the struct (32-bit aligned for &gt;= 64-bit structs)<p>It&#x27;s a pretty common architecture in the automotive industry, though probably would be considered esoteric for other applications.<p>This is not the first platform I&#x27;ve encountered with &quot;unnatural&quot; alignment rules in the embedded space, and I&#x27;m sure it won&#x27;t be the last. (The extra packing this allows is actually quite handy.)</div><br/></div></div><div id="36529236" class="c"><input type="checkbox" id="c-36529236" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36527979">parent</a><span>|</span><a href="#36528431">prev</a><span>|</span><a href="#36528060">next</a><span>|</span><label class="collapse" for="c-36529236">[-]</label><label class="expand" for="c-36529236">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the default ABI settings should get you completely compatible layouts here<p>That&#x27;s not true! You must not assume that the alignment always equals the size of a type. For example, the SysV i386 ABI uses 32-bit alignment for 64-bit types (double, int64_t). The Microsoft x86 ABI, however, uses 64-bit alignment, as do all 64-bit ABIs (See <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;11110283" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;11110283</a>.)
If you want to share structs directly between different machines, you should use appropriate struct packing directives - unless you really know what you are doing.</div><br/><div id="36531465" class="c"><input type="checkbox" id="c-36531465" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36529236">parent</a><span>|</span><a href="#36528060">next</a><span>|</span><label class="collapse" for="c-36531465">[-]</label><label class="expand" for="c-36531465">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s worse, MSVC&#x27;s 32-bit x86 ABI reports an 8-byte alignment requirement (via __alignof) for 64-bit integer types, and its struct layout algorithm uses that alignment to determine padding, but those integers and structs are only aligned to 4 bytes when allocated on the stack! This has caused issues with Rust code trying to link with MSVC code [0], since Rust&#x27;s standard library documentation asserts that properly aligned pointers have addresses that are always a multiple of the alignment used for struct layout.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;112480">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;112480</a></div><br/></div></div></div></div><div id="36528060" class="c"><input type="checkbox" id="c-36528060" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36527979">parent</a><span>|</span><a href="#36529236">prev</a><span>|</span><a href="#36527867">next</a><span>|</span><label class="collapse" for="c-36528060">[-]</label><label class="expand" for="c-36528060">[3 more]</label></div><br/><div class="children"><div class="content">I think we agree that this makes sense on some metaphysical level. The problem is that there are definitely platforms where the normal alignment isn&#x27;t what you describe above. And there isn&#x27;t to my knowledge a switch in GCC to force it to follow these rules on any given platform. There isn&#x27;t __attribute__((natural_alignment)). But there is __attribute__((packed)).</div><br/><div id="36529504" class="c"><input type="checkbox" id="c-36529504" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36528060">parent</a><span>|</span><a href="#36527867">next</a><span>|</span><label class="collapse" for="c-36529504">[-]</label><label class="expand" for="c-36529504">[2 more]</label></div><br/><div class="children"><div class="content">Since C11 there is _Alignas(sizeof T), forcing one of the proposed meanings for alignment, and _Alignof(T), which queries actual (i.e. natural, per another meaning) alignment. But, yeah, the argument upthread seems more about the implicit meaning of natural than anything else.</div><br/><div id="36531467" class="c"><input type="checkbox" id="c-36531467" checked=""/><div class="controls bullet"><span class="by">lsof</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36529504">parent</a><span>|</span><a href="#36527867">next</a><span>|</span><label class="collapse" for="c-36531467">[-]</label><label class="expand" for="c-36531467">[1 more]</label></div><br/><div class="children"><div class="content">On that note, something that caught me off guard once is that C11 _Alignof and GCC __alignof__ can differ: for example in 32-bit x86 __alignof__(double) == 8 but _Alignof(double) == 4; however __alignof__(struct { double d; }) == 4. Apparently __alignof__ gives the preferred alignment whereas _Alignof gives the alignment required by ABI.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36527867" class="c"><input type="checkbox" id="c-36527867" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36527237">parent</a><span>|</span><a href="#36527601">prev</a><span>|</span><a href="#36527729">next</a><span>|</span><label class="collapse" for="c-36527867">[-]</label><label class="expand" for="c-36527867">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As for RV64 and Arm64<p>This was just a placeholder, perhaps a bad example. I program a proprietary CPU architecture which does not require alignment. And for which the compiler naturally prefers to pack structs. Getting it to mimick Arm style struct padding is much harder and error prone than just having the Arm pack everything.<p>Maybe you are right and we are heading for a One True Struct Layout in the future. Today I think it is still too scary to pass the same unpacked struct declaration to various compiler archs and hope they come up with the same interpretation.</div><br/></div></div><div id="36527729" class="c"><input type="checkbox" id="c-36527729" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36527237">parent</a><span>|</span><a href="#36527867">prev</a><span>|</span><a href="#36529844">next</a><span>|</span><label class="collapse" for="c-36527729">[-]</label><label class="expand" for="c-36527729">[2 more]</label></div><br/><div class="children"><div class="content">You assume it was RV64. It could have easily been RV32</div><br/><div id="36528007" class="c"><input type="checkbox" id="c-36528007" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36527729">parent</a><span>|</span><a href="#36529844">next</a><span>|</span><label class="collapse" for="c-36528007">[-]</label><label class="expand" for="c-36528007">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think RV32 actually differs re alignment or struct layout, it’s just that with RV64 and Arm64 even the non-fixed-width names for the integer types are the same (LP64) except for Windows-on-ARM.</div><br/></div></div></div></div></div></div><div id="36529844" class="c"><input type="checkbox" id="c-36529844" checked=""/><div class="controls bullet"><span class="by">throwaway894345</span><span>|</span><a href="#36527116">parent</a><span>|</span><a href="#36527237">prev</a><span>|</span><a href="#36530326">next</a><span>|</span><label class="collapse" for="c-36529844">[-]</label><label class="expand" for="c-36529844">[2 more]</label></div><br/><div class="children"><div class="content">Whoa, I didn’t know there were systems where two different CPUs shared memory… How does that work? Any examples I might recognize of such systems?</div><br/><div id="36531171" class="c"><input type="checkbox" id="c-36531171" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#36527116">root</a><span>|</span><a href="#36529844">parent</a><span>|</span><a href="#36530326">next</a><span>|</span><label class="collapse" for="c-36531171">[-]</label><label class="expand" for="c-36531171">[1 more]</label></div><br/><div class="children"><div class="content">It is common for small CPUs to be embedded inside of various hardware devices. For instance, your GPU might have one or more control CPUs embedded inside. These CPUs would have either direct or at least DMA access to main memory. If you have heard about &quot;firmware&quot; being necessary for a hardware device to function, that &quot;firmware&quot; is really just software that runs on one of these auxiliary CPUs.<p>Suppose you want to send a command from the main CPU to this subprocessor. For efficiency and simplicity, that command might be defined as a C struct, in a common header. In that case it can be good to use packed alignment so you don&#x27;t have to worry about possible layout differences between CPUs.</div><br/></div></div></div></div></div></div><div id="36530326" class="c"><input type="checkbox" id="c-36530326" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#36527116">prev</a><span>|</span><a href="#36528032">next</a><span>|</span><label class="collapse" for="c-36530326">[-]</label><label class="expand" for="c-36530326">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One might assume that the compiler puts all its members directly behind each other in memory with no gaps in between and that the size of each structure is exactly the same as the sum of the sizes of all of its members. Such a structure is called a packed structure:<p>&gt; This is NOT how a compiler usually lays out a structure in memory.<p>Just explain how it works instead of assuming that the reader is making an (incorrect) assumption. I think you&#x27;re caught making that assumption because you&#x27;ve introduced the topics in a non-optimal order.<p>I would split up &quot;Element Order and Addressing&quot; and remove the picture there because it&#x27;s misleading. You can talk about addressing without explaining how the struct is laid out in memory. You don&#x27;t even need structs to explain addressing (&quot;&amp; takes the address of an object&quot;). Then, once you&#x27;ve introduced basic addressing and struct alignment&#x2F;padding, you could introduce addressing of struct fields. But I suspect it won&#x27;t have much value at that point because the logistics will be a natural consequence of the earlier topics.</div><br/></div></div><div id="36528032" class="c"><input type="checkbox" id="c-36528032" checked=""/><div class="controls bullet"><span class="by">eska</span><span>|</span><a href="#36530326">prev</a><span>|</span><a href="#36528034">next</a><span>|</span><label class="collapse" for="c-36528032">[-]</label><label class="expand" for="c-36528032">[1 more]</label></div><br/><div class="children"><div class="content">Good article. 2 suggestions:<p>1. you mention that passing by value may be faster. The Vector2D function would be a good example for this, because the floats may be passed through registers instead of memory in certain ABIs. It’s a common mistake in linear algebra libraries. It also creates pure functions which leads to nicer to use APIs.<p>2. memset is strictly speaking not correct due to padding and null pointers not necessarily being 0. The newer = {} syntax solves this.</div><br/></div></div><div id="36528034" class="c"><input type="checkbox" id="c-36528034" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#36528032">prev</a><span>|</span><a href="#36530572">next</a><span>|</span><label class="collapse" for="c-36528034">[-]</label><label class="expand" for="c-36528034">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  ...
  } __attribute__((packed));
</code></pre>
I would encourage the placement of attributes <i>before</i> the objects they apply to. This has been allowed by GCC since the standardized attribute syntax was added to C++. It is a more natural fit for code that will eventually be upgraded to C23 attribute syntax in the future and is more prominently visible to a reader. It also avoids the sometimes awkward GCC rules for postfix attributes.</div><br/></div></div><div id="36530572" class="c"><input type="checkbox" id="c-36530572" checked=""/><div class="controls bullet"><span class="by">eating555</span><span>|</span><a href="#36528034">prev</a><span>|</span><a href="#36527123">next</a><span>|</span><label class="collapse" for="c-36530572">[-]</label><label class="expand" for="c-36530572">[1 more]</label></div><br/><div class="children"><div class="content">Also &quot;The lost art of structure packing&quot; is a good read<p><a href="https:&#x2F;&#x2F;www.catb.org&#x2F;esr&#x2F;structure-packing&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.catb.org&#x2F;esr&#x2F;structure-packing&#x2F;</a></div><br/></div></div><div id="36527123" class="c"><input type="checkbox" id="c-36527123" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#36530572">prev</a><span>|</span><a href="#36528315">next</a><span>|</span><label class="collapse" for="c-36527123">[-]</label><label class="expand" for="c-36527123">[5 more]</label></div><br/><div class="children"><div class="content">pretty cool, love anything related to C.<p>might want to add anonymous struct.<p>also put function pointers inside struct for simple object-oriented-programming in C.<p>flexible array is handy, you do one malloc for all, but pointers inside struct is more &#x27;flexible&#x27;, for example you can put a &#x27;void *&#x27; and cast it to various data types. for flexible array, the data types must be chosen first.</div><br/><div id="36527980" class="c"><input type="checkbox" id="c-36527980" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#36527123">parent</a><span>|</span><a href="#36528418">next</a><span>|</span><label class="collapse" for="c-36527980">[-]</label><label class="expand" for="c-36527980">[1 more]</label></div><br/><div class="children"><div class="content">In passing, there is no version of myself that hasn&#x27;t shot himself in the foot using `void *` at some point :)</div><br/></div></div><div id="36528418" class="c"><input type="checkbox" id="c-36528418" checked=""/><div class="controls bullet"><span class="by">atahanacar</span><span>|</span><a href="#36527123">parent</a><span>|</span><a href="#36527980">prev</a><span>|</span><a href="#36528315">next</a><span>|</span><label class="collapse" for="c-36528418">[-]</label><label class="expand" for="c-36528418">[3 more]</label></div><br/><div class="children"><div class="content">&gt;but pointers inside struct is more &#x27;flexible&#x27;, for example you can put a &#x27;void *&#x27; and cast it to various data types.<p>But then the array and other members won&#x27;t be next to each other in memory.</div><br/><div id="36528694" class="c"><input type="checkbox" id="c-36528694" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#36527123">root</a><span>|</span><a href="#36528418">parent</a><span>|</span><a href="#36528315">next</a><span>|</span><label class="collapse" for="c-36528694">[-]</label><label class="expand" for="c-36528694">[2 more]</label></div><br/><div class="children"><div class="content">the cache subsystem might be smart enough to cache the first line, e.g. the size of the array etc, then pull the rest of array content from heap and cache the array as needed, should be fine to me, yes two cache misses instead of one at the beginning.</div><br/><div id="36531298" class="c"><input type="checkbox" id="c-36531298" checked=""/><div class="controls bullet"><span class="by">stefncb</span><span>|</span><a href="#36527123">root</a><span>|</span><a href="#36528694">parent</a><span>|</span><a href="#36528315">next</a><span>|</span><label class="collapse" for="c-36531298">[-]</label><label class="expand" for="c-36531298">[1 more]</label></div><br/><div class="children"><div class="content">The CPU cache simply pulls the memory next to what you loaded. It doesn&#x27;t interpret what it sees.</div><br/></div></div></div></div></div></div></div></div><div id="36528315" class="c"><input type="checkbox" id="c-36528315" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36527123">prev</a><span>|</span><a href="#36530276">next</a><span>|</span><label class="collapse" for="c-36528315">[-]</label><label class="expand" for="c-36528315">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The only good reason to use packed structures is when you need to map some memory (e.g. hardware registers exposed to memory) bit by bit to a structure.<p>Although unaligned access isn&#x27;t <i>fast</i> especially if it&#x27;s not directly hardware supported, it&#x27;s still much faster than all the options where there just isn&#x27;t enough memory.<p>It&#x27;s... unfortunate that C doesn&#x27;t standardize any of this.</div><br/></div></div><div id="36530276" class="c"><input type="checkbox" id="c-36530276" checked=""/><div class="controls bullet"><span class="by">juunpp</span><span>|</span><a href="#36528315">prev</a><span>|</span><a href="#36529012">next</a><span>|</span><label class="collapse" for="c-36530276">[-]</label><label class="expand" for="c-36530276">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The memory is uninitialized so it is a good idea to initialize it to zero bytes. We can do this by calling the memset function with the pointer to our new struct, the initialization value 0, and the size of our structure:<p>Or just calloc(), which also takes a count and an element size, convenient when you&#x27;re allocating arrays.</div><br/><div id="36530409" class="c"><input type="checkbox" id="c-36530409" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#36530276">parent</a><span>|</span><a href="#36529012">next</a><span>|</span><label class="collapse" for="c-36530409">[-]</label><label class="expand" for="c-36530409">[1 more]</label></div><br/><div class="children"><div class="content">I thought the same thing. Why is calloc not widely used?<p>That said, when initializing structs `= { 0 }` can be used to set all members 0. And at least in more recent compilers you can used the designated initializer with dynamic allocation by casting:<p><pre><code>    Foo* f = malloc(sizeof(Foo));
    *f = (Foo) { .bar = 1, .baz = “car” };
</code></pre>
If a member is missed, it will be set to zero (the value for uninitialized static storage).</div><br/></div></div></div></div><div id="36529012" class="c"><input type="checkbox" id="c-36529012" checked=""/><div class="controls bullet"><span class="by">Pesthuf</span><span>|</span><a href="#36530276">prev</a><span>|</span><a href="#36528068">next</a><span>|</span><label class="collapse" for="c-36529012">[-]</label><label class="expand" for="c-36529012">[1 more]</label></div><br/><div class="children"><div class="content">I always thought memory alignment would be black magic nonsense I would never get.
But no, it actually makes a lot of sense now.</div><br/></div></div><div id="36528068" class="c"><input type="checkbox" id="c-36528068" checked=""/><div class="controls bullet"><span class="by">Arch-TK</span><span>|</span><a href="#36529012">prev</a><span>|</span><a href="#36526902">next</a><span>|</span><label class="collapse" for="c-36528068">[-]</label><label class="expand" for="c-36528068">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll try not to be too pedantic.<p>&gt; If we declare a structure variable without initializing it, like any other variable in C, it will be uninitialized at first and may contain random values.<p>Really, it&#x27;s important to stress that as far as you are concerned, uninitialized things don&#x27;t contain values, they only contain undefined behavior.<p>&gt; But in complex programs, a structure can easily have 20 members and more.<p>Mostly in poorly designed programs.<p>&gt; The only reason not to use it is if you are forced to work with a C89 compiler and can’t upgrade.<p>Or if you have a Vector2D and don&#x27;t need to be constantly reminded what comes after x.<p>&gt; But what if we want a struct to feel like a real C type?<p>It&#x27;s already a real type. The reason people typedef structs is to save typing 7 characters.<p><pre><code>    #include &lt;stdlib.h&gt;
    
    ...
    
    struct Vector2D *vec;
    vec = malloc(sizeof(struct Vector2D));
    if (sec == NULL) {
        &#x2F;&#x2F; handle allocation failure
    }
</code></pre>
I recommend using sizeof *vec here, instead of sizeof (struct Vector2D), it&#x27;s much harder to screw up and mix up types in my experience.<p>&gt; The memory is uninitialized so it is a good idea to initialize it to zero bytes. We can do this by calling the memset function with the pointer to our new struct, the initialization value 0, and the size of our structure:<p>Don&#x27;t do this by calling memset. There&#x27;s no guarantee that memsetting a pointer, float or double to all bytes zero will actually produce things which equal zero. On implementations where null pointers are not all bits zero (rare but they do exist) you will not get a null pointer.<p>&gt; The great thing about this is that it allows us to omit to allocate structs with malloc on the heap.<p>Nothing stops you from using pointers to struct typed objects with automatic storage duration when calling functions:<p><pre><code>    struct Vector2D vec;
    foo(&amp;vec);
 
</code></pre>
&gt; This macro is useful to check if the compiler added any padding in between the members of the structure.<p>I would say this is hardly a use, more of a curiosity, really you shouldn&#x27;t write code which relies on the presence or absence or width of padding, you can&#x27;t even reliably store information in padding (the value is free to change due to you writing to an unrelated member). The only situation where this makes any sense is when using packed structs, and those almost never make sense except for some very specific circumstances.<p>&gt; It can also be used to get the memory address of the structure if you only have the address of one of its members and know what type of struct it is a member of.<p>I haven&#x27;t been able to gather agreement on whether this is something actually allowed by the C standard. There are two main schools of thought about this and one allows it, the other prohibits it, it&#x27;s an extreme example of a total grey area in the C standard.<p>&gt; This is used in some advanced code e.g. the OOP implementation of the Linux Kernel.<p>I think calling what Linux does OOP is misleading. The kernel just has lots of vtables, I disagree that OOP is just about vtables (or the effect they give).<p>&gt; The most general reason is that one of the design goals of C was to be a language that can be implemented on as many hardware platforms as possible. Therefore the standard needs to be flexible to allow compilers to adapt the actual implementation to the specialties and quirks of their hardware respective platforms.<p>I mean, it&#x27;s actually more about ABI than hardware. You can have two ABIs with different padding requirements on the same hardware platform. It just so happens that ABIs are themselves usually designed with hardware in mind.<p>&gt; And here we already see the solution. A structure has to get enough trailing padding to align with its biggest data type.<p>While this is not a bad way of thinking about it, again, really, it&#x27;s important to stress that while developing code in C, you should NOT be relying on this for anything other than performance optimisations for a particular platform.<p>&gt; (e.g. because you want to map a file format or some hardware registers exposed in memory)<p>While using struct packing to deal with hardware registers is forgivable (although, rare, given that hardware registers will often likely be aligned the same as in the ABI), you really shouldn&#x27;t use it for any file format you want to be portable outside a single machine. With modern compilers there&#x27;s effectively no penalty to doing this properly (i.e. defining functions like uint_least32_t read32le(void *p) which read byte by byte and de-serialize the number using shifts and ORs). Yes I have tested this. Not only will your code not be cryptic and broken the moment you find yourself on a big endian machine, it also won&#x27;t be unnecessarily portable for no good reason.<p>&gt; Thankfully, C supports so-called bitfields.<p>You make it sound like an array&#x2F;struct of bools or a bitfield are the only two options.</div><br/><div id="36530360" class="c"><input type="checkbox" id="c-36530360" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#36528068">parent</a><span>|</span><a href="#36526902">next</a><span>|</span><label class="collapse" for="c-36530360">[-]</label><label class="expand" for="c-36530360">[1 more]</label></div><br/><div class="children"><div class="content">Why would you heap allocate the struct? You will just have to heap allocate again for the actual data structure.</div><br/></div></div></div></div><div id="36526902" class="c"><input type="checkbox" id="c-36526902" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36528068">prev</a><span>|</span><a href="#36529743">next</a><span>|</span><label class="collapse" for="c-36526902">[-]</label><label class="expand" for="c-36526902">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Using a Structure via a Pointer<p>code that sets the array doesn&#x27;t use the pointer.</div><br/></div></div><div id="36529743" class="c"><input type="checkbox" id="c-36529743" checked=""/><div class="controls bullet"><span class="by">throwaway894345</span><span>|</span><a href="#36526902">prev</a><span>|</span><label class="collapse" for="c-36529743">[-]</label><label class="expand" for="c-36529743">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The great thing about [passing structs by copy] is that it allows us to omit to allocate structs with malloc on the heap. Instead, we could create a struct on the stack and pass it around by copying it. This opens the door to new approaches for writing safer C code.<p>You don’t have to heap-allocate structs to pass by pointer; you can pass a pointer to a struct living on the stack. Even if you are talking about returning a struct, you can just take a pointer to memory allocated in some previous stack frame and mutate it—this avoids the allocation and thus preserves safety and performance. But yes, being able to pass structs by copy is nice too.</div><br/></div></div></div></div></div></div></div></body></html>