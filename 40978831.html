<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721206870077" as="style"/><link rel="stylesheet" href="styles.css?v=1721206870077"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://austinhenley.com/blog/bignum2.html">Optimizing a bignum library for fun</a> <span class="domain">(<a href="https://austinhenley.com">austinhenley.com</a>)</span></div><div class="subtext"><span>azhenley</span> | <span>42 comments</span></div><br/><div><div id="40980568" class="c"><input type="checkbox" id="c-40980568" checked=""/><div class="controls bullet"><span class="by">worstspotgain</span><span>|</span><a href="#40981501">next</a><span>|</span><label class="collapse" for="c-40980568">[-]</label><label class="expand" for="c-40980568">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had to implement BigNum on an embedded system that had very little RAM and where the initial <i>optimized</i> version of ModExp took many minutes to complete. After much hair-pulling, the final version took 40 seconds.<p>First, you should work with unsigned numbers, and use a power of 2 as your word size. The fastest choice for a word size is very operation- and CPU-dependent.<p>A key trick is to lay out your bignums in the same order as the endianity of each word in memory, e.g. least-significant word first on little-endian systems. This will allow you to choose your word size dynamically for each operation: in memory, a number with M words of N bits each is identical to a number with M &#x2F; 2 words of N * 2 bits each.<p>For multiplication, identify the CPU instruction with the widest result, then use half that size as your word size. Each step through the arrays generates a word result in the low half and a word carry in the top half. The carry gets added to the result of the next step, possibly overflowing.<p>For addition, use the widest result as your word size. This can also overflow.<p>How you deal with overflows is very CPU-dependent. You can use adc&#x2F;addc as someone else mentioned, which will be faster on embedded and <i>may</i> be faster on fatter chips. Alternatively, you can halve the word size and use the top half as the carry.<p>If addc is not available, you can test for overflows as follows:<p><pre><code>    uint32_t a = ..., b = ...;
    uint32_t res = a + b;
    uint32_t carry = res &lt; a;
</code></pre>
On overflow, res must necessarily be less than both a and b, so no need to check b.<p>If SIMD instructions are available, that will almost always be the fastest choice by far. While it doesn&#x27;t change the above guidelines in principle, there are often e.g. optimized overflow mechanisms.</div><br/></div></div><div id="40981501" class="c"><input type="checkbox" id="c-40981501" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#40980568">prev</a><span>|</span><a href="#40925061">next</a><span>|</span><label class="collapse" for="c-40981501">[-]</label><label class="expand" for="c-40981501">[2 more]</label></div><br/><div class="children"><div class="content">Coincidentally I was just writing a bignum library from scratch two weeks ago.<p>A few interesting things I learned:<p>1. Knuth volume 2 has an extensive discussion of the problem space.  I&#x27;ve only gotten a chance to skim it so far, but it looks interesting and approachable.<p>2. I need to support bitwise operations, which operate on a two&#x27;s complement representation, so I figured it would be simpler to use two&#x27;s complement internally, despite seeing that most (all?) bignum libraries use signed magnitude.  I&#x27;m starting to regret this: two&#x27;s complement introduces a lot of complexity.<p>The most fun thing about working on a bignum library is that it makes the algorithms you learned in grade school for add&#x2F;subtract&#x2F;multiply&#x2F;divide relevant again.  The basic (&quot;classical&quot;) algorithms on bignum are basically exactly the same thing you learned in grade school, except on a much larger base than base-10.</div><br/><div id="40982953" class="c"><input type="checkbox" id="c-40982953" checked=""/><div class="controls bullet"><span class="by">vintermann</span><span>|</span><a href="#40981501">parent</a><span>|</span><a href="#40925061">next</a><span>|</span><label class="collapse" for="c-40982953">[-]</label><label class="expand" for="c-40982953">[1 more]</label></div><br/><div class="children"><div class="content">Knuth has a &quot;hugenum&quot; scheme, TCALC, which is based on trees rather than byte arrays. There are many ways to do it, depending on which type of numbers you need most - for TCALC, it&#x27;s numbers close to towers of exponents.<p>Of course for every big number encoding that can beat an array of bytes for some numbers, it also has to lose to byte arrays for some numbers... But it&#x27;s possible to bound this inefficiency, so that it&#x27;s never more than twice as bad as byte arrays, but potentially exponentially more efficient for the favoured numbers.</div><br/></div></div></div></div><div id="40925061" class="c"><input type="checkbox" id="c-40925061" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40981501">prev</a><span>|</span><a href="#40981493">next</a><span>|</span><label class="collapse" for="c-40925061">[-]</label><label class="expand" for="c-40925061">[5 more]</label></div><br/><div class="children"><div class="content">Modulo is surprisingly expensive even when you combine it with a quotient. It is almost always better to use binary &quot;limbs&quot;, in this case 31 or 32 bits wide, because decimal parsing and printing should be much rarer than individual operations in general.</div><br/><div id="40980656" class="c"><input type="checkbox" id="c-40980656" checked=""/><div class="controls bullet"><span class="by">colonwqbang</span><span>|</span><a href="#40925061">parent</a><span>|</span><a href="#40981493">next</a><span>|</span><label class="collapse" for="c-40980656">[-]</label><label class="expand" for="c-40980656">[4 more]</label></div><br/><div class="children"><div class="content">This is a bit misleading. Quotient and modulo with constant right-hand side is readily optimised into faster operations, like multiplication and bit shifts. &quot;All&quot; optimising compilers do this and don&#x27;t emit a true divide instruction in such cases. See for instance: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;vxnTPvY6M" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;vxnTPvY6M</a><p>Quotient and modulo with a variable RHS is expensive, but this isn&#x27;t necessary for the algorithm showed in the article. Although I agree that binary wins over decimal anyway. We are using binary computers after all, for the last 50 years or so.</div><br/><div id="40981451" class="c"><input type="checkbox" id="c-40981451" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#40925061">root</a><span>|</span><a href="#40980656">parent</a><span>|</span><a href="#40980846">next</a><span>|</span><label class="collapse" for="c-40981451">[-]</label><label class="expand" for="c-40981451">[1 more]</label></div><br/><div class="children"><div class="content">The oldish version of gcc used by highload.fun seems to stop performing this optimization after the 5th or so constant divisor within a small function body. Always good to double check :(</div><br/></div></div><div id="40980846" class="c"><input type="checkbox" id="c-40980846" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#40925061">root</a><span>|</span><a href="#40980656">parent</a><span>|</span><a href="#40981451">prev</a><span>|</span><a href="#40980848">next</a><span>|</span><label class="collapse" for="c-40980846">[-]</label><label class="expand" for="c-40980846">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Quotient and modulo with a variable RHS is expensive<p>For dividing ‘big’ bignums by ‘small’ divisors, I would use&#x2F;tweak <i>libdivide</i> (<a href="https:&#x2F;&#x2F;libdivide.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;libdivide.com&#x2F;</a>), and spend the time to optimize the division.<p>For dividing ‘big’ bignums by ‘big’ divisors, that may not be worth it.<p>(Determining the correct values of the various ‘big’ and ‘small’ values left as an exercise for the reader. Those will depend on the hardware at hand)</div><br/></div></div><div id="40980848" class="c"><input type="checkbox" id="c-40980848" checked=""/><div class="controls bullet"><span class="by">worstspotgain</span><span>|</span><a href="#40925061">root</a><span>|</span><a href="#40980656">parent</a><span>|</span><a href="#40980846">prev</a><span>|</span><a href="#40981493">next</a><span>|</span><label class="collapse" for="c-40980848">[-]</label><label class="expand" for="c-40980848">[1 more]</label></div><br/><div class="children"><div class="content">The reason a division by 1000000 can be efficiently turned into a multiplication is because you&#x27;re targeting a system that has a 32x32-&gt;64 multiplication instruction, which has plenty of room to spare. But if you have that, you would be better off using e.g. 2^32 as your modulo.</div><br/></div></div></div></div></div></div><div id="40981493" class="c"><input type="checkbox" id="c-40981493" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40925061">prev</a><span>|</span><a href="#40979333">next</a><span>|</span><label class="collapse" for="c-40981493">[-]</label><label class="expand" for="c-40981493">[1 more]</label></div><br/><div class="children"><div class="content">LOL, I&#x27;ve been there: <a href="https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;commit&#x2F;mpi?id=98dedd310b1d5d876b0fbb0ebd6c4df9bd7b2d88" rel="nofollow">https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;commit&#x2F;mpi?id=98dedd310b1d5...</a><p>(Patch was originally from 2011; it was bugfixed once, and then in 2015 converted to git commit:<p><a href="https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;commit&#x2F;mpi-patches&#x2F;faster-square-root?id=ef47dfe4fcb7c1be369ae83221386b9da6474a1e" rel="nofollow">https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;commit&#x2F;mpi-patches&#x2F;faster-s...</a> )<p>Another one: faster highest-bit search:<p><a href="https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;tree&#x2F;mpi-patches&#x2F;bit-search-optimizations?id=124e7dd6977a0853d7a8399921e31fd1ccde2dcb" rel="nofollow">https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;tree&#x2F;mpi-patches&#x2F;bit-search...</a><p>That does use GCC built-ins today: <a href="https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;commit&#x2F;?id=15b7c542dc44899e8db7addfcc2f1c1c4a188b49" rel="nofollow">https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;commit&#x2F;?id=15b7c542dc44899e...</a></div><br/></div></div><div id="40979333" class="c"><input type="checkbox" id="c-40979333" checked=""/><div class="controls bullet"><span class="by">minimize</span><span>|</span><a href="#40981493">prev</a><span>|</span><a href="#40983327">next</a><span>|</span><label class="collapse" for="c-40979333">[-]</label><label class="expand" for="c-40979333">[6 more]</label></div><br/><div class="children"><div class="content">For maximum efficiency, you should work in binary instead of base 10. Handling carries becomes more straightforward with the right primitives, for example __builtin_addc with GCC: <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Integer-Overflow-Builtins.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Integer-Overflow-Builtins...</a><p>You can also implement it in C if you want a more portable solution: <a href="https:&#x2F;&#x2F;github.com&#x2F;983&#x2F;bigint&#x2F;blob&#x2F;ee0834c65a27d18fa628e6c526a0b83b24db90f9&#x2F;bigint.c#L27">https:&#x2F;&#x2F;github.com&#x2F;983&#x2F;bigint&#x2F;blob&#x2F;ee0834c65a27d18fa628e6c52...</a><p>If you scroll around, you can also find my implementations for multiplication and such.</div><br/><div id="40979508" class="c"><input type="checkbox" id="c-40979508" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40979333">parent</a><span>|</span><a href="#40983327">next</a><span>|</span><label class="collapse" for="c-40979508">[-]</label><label class="expand" for="c-40979508">[5 more]</label></div><br/><div class="children"><div class="content">For maximum efficiency you&#x27;d avoid addc like hell, because it blocks internal precomputation, and use guarantees like he did, avoiding overflow better. Better use int128 types though.<p>I&#x27;d just just stack objects for small typical sizes. And esp. do formal proofs than the random test joke.</div><br/><div id="40979882" class="c"><input type="checkbox" id="c-40979882" checked=""/><div class="controls bullet"><span class="by">minimize</span><span>|</span><a href="#40979333">root</a><span>|</span><a href="#40979508">parent</a><span>|</span><a href="#40979884">next</a><span>|</span><label class="collapse" for="c-40979882">[-]</label><label class="expand" for="c-40979882">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For maximum efficiency you&#x27;d avoid addc like hell, because it blocks internal precomputation, and use guarantees like he did, avoiding overflow better.<p>Whether that is the case depends on the CPU. I hit memory bandwidth limits before adc becomes a problem. But I concede that you have a valid point and that there are definitely cases where leaving sufficient space for carries is the better strategy.<p>Anyway, we can probably both agree that &quot;% 1000000000&quot; is not the best way to do it.</div><br/></div></div><div id="40979884" class="c"><input type="checkbox" id="c-40979884" checked=""/><div class="controls bullet"><span class="by">koverstreet</span><span>|</span><a href="#40979333">root</a><span>|</span><a href="#40979508">parent</a><span>|</span><a href="#40979882">prev</a><span>|</span><a href="#40983327">next</a><span>|</span><label class="collapse" for="c-40979884">[-]</label><label class="expand" for="c-40979884">[3 more]</label></div><br/><div class="children"><div class="content">addc makes all your adds serialize on the flags register, which is really painful.<p>more modern approach is to reserve some bits out of every word for carries, but that drastically complicates things.</div><br/><div id="40981477" class="c"><input type="checkbox" id="c-40981477" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#40979333">root</a><span>|</span><a href="#40979884">parent</a><span>|</span><a href="#40980900">next</a><span>|</span><label class="collapse" for="c-40981477">[-]</label><label class="expand" for="c-40981477">[1 more]</label></div><br/><div class="children"><div class="content">Is this really true?  I would intuitively expect that register renaming would apply to eflags too, so that reads from flags don&#x27;t truly need to be serialized despite nominally writing a bunch of things to the same register.<p>EDIT: this paper (linked in another comment) seems to indicate that this is possible:<p>&gt; An out-of-order machine can look ahead and
process the accumulation pass in parallel with the partial sum pass using a renamed eFlags register.<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150131061304&#x2F;http:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;white-papers&#x2F;ia-large-integer-arithmetic-paper.pdf" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150131061304&#x2F;http:&#x2F;&#x2F;www.intel....</a></div><br/></div></div><div id="40980900" class="c"><input type="checkbox" id="c-40980900" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40979333">root</a><span>|</span><a href="#40979884">parent</a><span>|</span><a href="#40981477">prev</a><span>|</span><a href="#40983327">next</a><span>|</span><label class="collapse" for="c-40980900">[-]</label><label class="expand" for="c-40980900">[1 more]</label></div><br/><div class="children"><div class="content">I remembered and ultimately found a source for a workaround for the serialising on flags problem, intel paper at <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150131061304&#x2F;http:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;white-papers&#x2F;ia-large-integer-arithmetic-paper.pdf" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150131061304&#x2F;http:&#x2F;&#x2F;www.intel....</a> amounts to new instructions with better behaviour for ILP</div><br/></div></div></div></div></div></div></div></div><div id="40983327" class="c"><input type="checkbox" id="c-40983327" checked=""/><div class="controls bullet"><span class="by">parentheses</span><span>|</span><a href="#40979333">prev</a><span>|</span><a href="#40981002">next</a><span>|</span><label class="collapse" for="c-40983327">[-]</label><label class="expand" for="c-40983327">[2 more]</label></div><br/><div class="children"><div class="content">I am so surprised that there&#x27;s no exploration of Karatsuba&#x27;s algorithm. That&#x27;s what makes the Python implementation perform.<p>I actually came here hoping to find discussion on Karatsuba.
 <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Karatsuba_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Karatsuba_algorithm</a></div><br/><div id="40983391" class="c"><input type="checkbox" id="c-40983391" checked=""/><div class="controls bullet"><span class="by">jmts</span><span>|</span><a href="#40983327">parent</a><span>|</span><a href="#40981002">next</a><span>|</span><label class="collapse" for="c-40983391">[-]</label><label class="expand" for="c-40983391">[1 more]</label></div><br/><div class="children"><div class="content">Please see the section titled &quot;Faster multiplication&quot;</div><br/></div></div></div></div><div id="40981002" class="c"><input type="checkbox" id="c-40981002" checked=""/><div class="controls bullet"><span class="by">nj5rq</span><span>|</span><a href="#40983327">prev</a><span>|</span><a href="#40982161">next</a><span>|</span><label class="collapse" for="c-40981002">[-]</label><label class="expand" for="c-40981002">[2 more]</label></div><br/><div class="children"><div class="content">Fascinating article, I have always been wondering how these big number libraries worked.<p>As a side question, does anyone the program that the author used when making that &quot;addition&quot; and &quot;multiplication&quot; performance graph? Thanks.</div><br/><div id="40981150" class="c"><input type="checkbox" id="c-40981150" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#40981002">parent</a><span>|</span><a href="#40982161">next</a><span>|</span><label class="collapse" for="c-40981150">[-]</label><label class="expand" for="c-40981150">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know for sure, but you can do that kind of thing pretty easily with Matplotlib in Python. Or in R base graphics, with more effort to get it looking pretty.</div><br/></div></div></div></div><div id="40982161" class="c"><input type="checkbox" id="c-40982161" checked=""/><div class="controls bullet"><span class="by">tgot</span><span>|</span><a href="#40981002">prev</a><span>|</span><a href="#40983466">next</a><span>|</span><label class="collapse" for="c-40982161">[-]</label><label class="expand" for="c-40982161">[3 more]</label></div><br/><div class="children"><div class="content">I think that your description is almost excellent, but that you&#x27;re fundamentally misleading in describing what you are doing as a &quot;30-bit&quot; digit.<p>It&#x27;s a 10^9 digit mathematically, occupying 30 bits of storage.  You do briefly mention that it&#x27;s 10^9, but repeatedly say 30-bits.</div><br/><div id="40982511" class="c"><input type="checkbox" id="c-40982511" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40982161">parent</a><span>|</span><a href="#40983466">next</a><span>|</span><label class="collapse" for="c-40982511">[-]</label><label class="expand" for="c-40982511">[2 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t misleading at all.<p>A hexadecimal digit has 4 bits of entropy. You can guess it correctly by chance one in sixteen times. Calling that a four-bit digit is correct. Same with a 30 bit digit, all that changes is the magnitude.<p>The &quot;storage bits&quot; aren&#x27;t a detail, they&#x27;re an essential property. Stored in balanced ternary it would still have 30 bits of entropy.</div><br/><div id="40982913" class="c"><input type="checkbox" id="c-40982913" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#40982161">root</a><span>|</span><a href="#40982511">parent</a><span>|</span><a href="#40983466">next</a><span>|</span><label class="collapse" for="c-40982913">[-]</label><label class="expand" for="c-40982913">[1 more]</label></div><br/><div class="children"><div class="content">I think you misunderstood the parent. If you speak of a number in the range 0-15 stored in 4 bits, we can all agree that &quot;4 bit digit&quot; is the appropriate term for it. But what about a number also stored in 4 bits but restricted to the range 0-13? It&#x27;s a digit that fits in 4 bits, but calling it a &quot;4 bit digit&quot; without further qualification would omit relevant information.</div><br/></div></div></div></div></div></div><div id="40983466" class="c"><input type="checkbox" id="c-40983466" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#40982161">prev</a><span>|</span><a href="#40983354">next</a><span>|</span><label class="collapse" for="c-40983466">[-]</label><label class="expand" for="c-40983466">[1 more]</label></div><br/><div class="children"><div class="content">Very useful post!  Also it&#x27;s cool to see how many people in this thread have worked on this problem -- lots of new info here I haven&#x27;t seen<p>I wonder if anyone is interested in implementing a big numbers in Oils?  It&#x27;s a Unix shell with TWO complete implementations - the &quot;executable spec&quot; in Python, and an automatic translation to pure C++ (which is 30x-50x faster)<p>We currently use 64-bit integers in C++, but big nums are a better semantic.  Some trivia about bad shell semantics here:<p><i>Integers - Don&#x27;t do whatever Python or C++ does</i> -  <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2024&#x2F;03&#x2F;release-0.21.0.html#integers-dont-do-whatever-python-or-c-does" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2024&#x2F;03&#x2F;release-0.21.0.html#in...</a><p>This is a very self-contained project: the interface is defined by 200 lines of Python:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;oilshell&#x2F;oil&#x2F;blob&#x2F;master&#x2F;mycpp&#x2F;mops.py">https:&#x2F;&#x2F;github.com&#x2F;oilshell&#x2F;oil&#x2F;blob&#x2F;master&#x2F;mycpp&#x2F;mops.py</a><p>and the trivial 64-bit overflowing implementation is also about 200 lines:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;oilshell&#x2F;oil&#x2F;blob&#x2F;master&#x2F;mycpp&#x2F;gc_mops.h">https:&#x2F;&#x2F;github.com&#x2F;oilshell&#x2F;oil&#x2F;blob&#x2F;master&#x2F;mycpp&#x2F;gc_mops.h</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;oilshell&#x2F;oil&#x2F;blob&#x2F;master&#x2F;mycpp&#x2F;gc_mops.cc">https:&#x2F;&#x2F;github.com&#x2F;oilshell&#x2F;oil&#x2F;blob&#x2F;master&#x2F;mycpp&#x2F;gc_mops.cc</a><p>(We have a fast Ninja-based build system, so you can probably iterate on this in 100 milliseconds or less -- it should be fun for the right person)<p>---<p>I think the main reason it is specific to Oils is that the bigger number should become GC objects.  Details on our GC here:<p><i>Pictures of a Working Garbage Collector</i> - <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2023&#x2F;01&#x2F;garbage-collector.html" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2023&#x2F;01&#x2F;garbage-collector.html</a><p>It&#x27;s been very solid for the last 18 months, basically because it&#x27;s well tested by ASAN and #ifdef testing modes.<p>The main thing I&#x27;d be concerned with is how to TEST that big number operations are correct.  I think there are probably some interesting strategies, which I&#x27;d love to discuss.<p>You&#x27;re of course welcome to adapt existing open source code, including code you&#x27;ve already written -- I probably even prefer that, i.e. something that has had some real world testing.  We want all the operations in that file, and it should be integrated with our GC.<p>---<p>We&#x27;ve had ~6 contributors funded by grants from <a href="https:&#x2F;&#x2F;nlnet.nl" rel="nofollow">https:&#x2F;&#x2F;nlnet.nl</a> for the past couple years, so you can even be paid (there&#x27;s a chance it  depends on the country you live in, but generally a wide range of situations is OK).<p>Contact me at andy at oilshell.org or <a href="https:&#x2F;&#x2F;oilshell.zulipchat.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;oilshell.zulipchat.com&#x2F;</a> if interested!</div><br/></div></div><div id="40983354" class="c"><input type="checkbox" id="c-40983354" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40983466">prev</a><span>|</span><a href="#40979416">next</a><span>|</span><label class="collapse" for="c-40983354">[-]</label><label class="expand" for="c-40983354">[1 more]</label></div><br/><div class="children"><div class="content">Funny, I did this myself 10 years ago. Shit, it&#x27;s been that long..?<p>For my undergrad project I wrote a computer algebra system to do symbolic integration. The supervisor was a hardcore, old school C guy, so naturally I was going to just use C and no libraries. He told me I&#x27;d need bignums first, so I got to work (this is because many algorithms like polynomial GCD create massive numbers as they go, even if the inputs and final outputs are generally very small).<p>I just couldn&#x27;t figure out how to do better than the largest power of 10 per digit at the time. Working with non base 10 arithmetic was a mind fuck for me at the time. So I did it with digits holding 10^9 and the classical algorithms from Knuth. Division is the hardest!<p>At some point I discovered the GNU multiple precision library (GMP) and made my program work with that instead of mine. I was shocked at how much faster GMP was! I finished my project with my own code, but I knew I had to come back to do it better.<p>The breakthrough came when I got a copy of <i>Hacker&#x27;s Delight</i>. It has stuff like how to detect overflow after it&#x27;s happened (in C). Something twigged and then I just understood how to fill each word completely rather than use a power of 10. I don&#x27;t know what confused me before.<p>But, of course, the real way to do it is to use assembly. You can&#x27;t get close to high performance in C alone. In assembly you get the overflow bit. It&#x27;s actually easier in a way! So you write tiny platform specific bits for the digits and build on that in C. My add and subtract were then as fast as GMP. I lost interest when it came to implement faster multiplication algorithms.<p>Code in case anyone is interested: <a href="https:&#x2F;&#x2F;github.com&#x2F;georgek&#x2F;bignums">https:&#x2F;&#x2F;github.com&#x2F;georgek&#x2F;bignums</a></div><br/></div></div><div id="40979416" class="c"><input type="checkbox" id="c-40979416" checked=""/><div class="controls bullet"><span class="by">paldepind2</span><span>|</span><a href="#40983354">prev</a><span>|</span><a href="#40978839">next</a><span>|</span><label class="collapse" for="c-40979416">[-]</label><label class="expand" for="c-40979416">[16 more]</label></div><br/><div class="children"><div class="content">Speaking of bignum libraries, I recently watched a talk with Rob Pike where he mentioned that one thing he regretted about Go was not making the default integer implementation arbitrary precision. Supposedly the performance overhead for normal numbers is very small, and you avoid the weirdness and complicated semantics of fixed precision integers. I found that to be quite fascinating, especially coming from a &quot;low-level guy&quot; like Rob Pike. Ever since I&#x27;ve been wanting a language with that feature and to understand how bignum implementations work.</div><br/><div id="40980315" class="c"><input type="checkbox" id="c-40980315" checked=""/><div class="controls bullet"><span class="by">epidemian</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40980287">next</a><span>|</span><label class="collapse" for="c-40980315">[-]</label><label class="expand" for="c-40980315">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a pretty common feature on high-level languages. Python, Ruby, Lisp(s), Haskell, etc, all use arbitrary-precision integers by default. Even JavaScript has integers now (since 2020), not as the default number type, but with the `n` suffix, like `42n`.</div><br/><div id="40982939" class="c"><input type="checkbox" id="c-40982939" checked=""/><div class="controls bullet"><span class="by">paldepind2</span><span>|</span><a href="#40979416">root</a><span>|</span><a href="#40980315">parent</a><span>|</span><a href="#40980287">next</a><span>|</span><label class="collapse" for="c-40982939">[-]</label><label class="expand" for="c-40982939">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s cool. I didn&#x27;t realize that those languages used arbitrary-precision integers by default. I know that many language offer a bigint but to me the difference between having bigints and them being the default seems significant. For instance, in JavaScript the `n` notation and them being called `bigint` (and not just `int`) is going to mean that they will get used very rarely.</div><br/></div></div></div></div><div id="40980287" class="c"><input type="checkbox" id="c-40980287" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40980315">prev</a><span>|</span><a href="#40980082">next</a><span>|</span><label class="collapse" for="c-40980287">[-]</label><label class="expand" for="c-40980287">[1 more]</label></div><br/><div class="children"><div class="content">Smalltalk is another language that has had this feature since forever.<p>Tagged pointers &#x2F; SmallInteger encodings make the memory overhead zero to negligible, and with the CPU &#x2F; memory-bandwidth gap being what it is, the few extra CPU operations rarely matter.<p>Daniel Bernstein made the argument that integers should default to these semantics for security reasons:<p><a href="https:&#x2F;&#x2F;css.csail.mit.edu&#x2F;6.858&#x2F;2018&#x2F;readings&#x2F;qmail.pdf" rel="nofollow">https:&#x2F;&#x2F;css.csail.mit.edu&#x2F;6.858&#x2F;2018&#x2F;readings&#x2F;qmail.pdf</a></div><br/></div></div><div id="40980082" class="c"><input type="checkbox" id="c-40980082" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40980287">prev</a><span>|</span><a href="#40980742">next</a><span>|</span><label class="collapse" for="c-40980082">[-]</label><label class="expand" for="c-40980082">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp has been like this forever.  It makes testing the language much easier, as you don&#x27;t have to check for overflows when constructing test code.<p>A dynamic language like CL has the added requirement that the integers fit with everything else under a single top type, which in practice limits fixnums to a few bits less than the word size.</div><br/></div></div><div id="40980742" class="c"><input type="checkbox" id="c-40980742" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40980082">prev</a><span>|</span><a href="#40979511">next</a><span>|</span><label class="collapse" for="c-40980742">[-]</label><label class="expand" for="c-40980742">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m &quot;low-level guy, like Pike&quot;, yet I wouldn&#x27;t have integers any other way in an application language.<p>Nobody uses Go for ethernet card drivers. Dealing with machine integers is just mental overhead for Go programmers, and a source of bugs.</div><br/></div></div><div id="40979511" class="c"><input type="checkbox" id="c-40979511" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40980742">prev</a><span>|</span><a href="#40979566">next</a><span>|</span><label class="collapse" for="c-40979511">[-]</label><label class="expand" for="c-40979511">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, Haskell&#x27;s <i>Integer</i> type is that way.<p><i>edit</i> To be clear, in Haskell you &#x27;default&#x27; to using its arbitrary-precision type, unlike say Java where they&#x27;re available in the standard library but not in the core primitive types.</div><br/></div></div><div id="40979566" class="c"><input type="checkbox" id="c-40979566" checked=""/><div class="controls bullet"><span class="by">vient</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40979511">prev</a><span>|</span><a href="#40980046">next</a><span>|</span><label class="collapse" for="c-40979566">[-]</label><label class="expand" for="c-40979566">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve been wanting a language with that feature<p>Python, which realization CPython is mentioned in the article, has arbitrary precision integers.</div><br/></div></div><div id="40980046" class="c"><input type="checkbox" id="c-40980046" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40979566">prev</a><span>|</span><a href="#40980198">next</a><span>|</span><label class="collapse" for="c-40980046">[-]</label><label class="expand" for="c-40980046">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve been wanting a language with that feature<p>GNU MP&#x27;s C++ interface makes this mostly transparent, expressions like &quot;x = y * z&quot; just work due to operator overloading.  The only time you need to know that the underlying class is &quot;mpz_class&quot; instead of &quot;int&quot; is at input&#x2F;output.</div><br/></div></div><div id="40980198" class="c"><input type="checkbox" id="c-40980198" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40980046">prev</a><span>|</span><a href="#40982532">next</a><span>|</span><label class="collapse" for="c-40980198">[-]</label><label class="expand" for="c-40980198">[1 more]</label></div><br/><div class="children"><div class="content">Rexx (EDIT: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rexx" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rexx</a> )</div><br/></div></div><div id="40982532" class="c"><input type="checkbox" id="c-40982532" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40980198">prev</a><span>|</span><a href="#40981217">next</a><span>|</span><label class="collapse" for="c-40982532">[-]</label><label class="expand" for="c-40982532">[1 more]</label></div><br/><div class="children"><div class="content">Zig isn&#x27;t quite <i>arbitrary</i> precision, but it supports integer widths up to u65536. I&#x27;ve found this quite handy.</div><br/></div></div><div id="40981217" class="c"><input type="checkbox" id="c-40981217" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40982532">prev</a><span>|</span><a href="#40981098">next</a><span>|</span><label class="collapse" for="c-40981217">[-]</label><label class="expand" for="c-40981217">[2 more]</label></div><br/><div class="children"><div class="content">eh, I disagree. It&#x27;s not massive overhead, but it turns literally every integer operation into a branch. Sure the branch is going to get ~100% prediction accuracy if you aren&#x27;t using bigints, but that&#x27;s still a pretty big cost especially since the branches inserted make all sorts of compiler optimizations illegal.</div><br/></div></div><div id="40981098" class="c"><input type="checkbox" id="c-40981098" checked=""/><div class="controls bullet"><span class="by">aag</span><span>|</span><a href="#40979416">parent</a><span>|</span><a href="#40981217">prev</a><span>|</span><a href="#40980490">next</a><span>|</span><label class="collapse" for="c-40981098">[-]</label><label class="expand" for="c-40981098">[2 more]</label></div><br/><div class="children"><div class="content">Do you remember where you saw that talk?  I&#x27;d like to watch it.<p>Thanks.</div><br/><div id="40982954" class="c"><input type="checkbox" id="c-40982954" checked=""/><div class="controls bullet"><span class="by">paldepind2</span><span>|</span><a href="#40979416">root</a><span>|</span><a href="#40981098">parent</a><span>|</span><a href="#40980490">next</a><span>|</span><label class="collapse" for="c-40982954">[-]</label><label class="expand" for="c-40982954">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the talk is called &quot;What We Got Right, What We Got Wrong&quot; from GopherConAU 2023. It&#x27;s available on YouTube: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yE5Tpp2BSGw" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yE5Tpp2BSGw</a></div><br/></div></div></div></div></div></div><div id="40978839" class="c"><input type="checkbox" id="c-40978839" checked=""/><div class="controls bullet"><span class="by">styczen</span><span>|</span><a href="#40979416">prev</a><span>|</span><label class="collapse" for="c-40978839">[-]</label><label class="expand" for="c-40978839">[1 more]</label></div><br/><div class="children"><div class="content">not + -</div><br/></div></div></div></div></div></div></div></body></html>