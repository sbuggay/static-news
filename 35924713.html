<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684054842543" as="style"/><link rel="stylesheet" href="styles.css?v=1684054842543"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://madebyevan.com/algos/log-spaced-snapshots/">Logarithmically-Spaced Snapshots</a>Â <span class="domain">(<a href="https://madebyevan.com">madebyevan.com</a>)</span></div><div class="subtext"><span>luu</span> | <span>8 comments</span></div><br/><div><div id="35936282" class="c"><input type="checkbox" id="c-35936282" checked=""/><div class="controls bullet"><span class="by">dorgo</span><span>|</span><a href="#35935502">next</a><span>|</span><label class="collapse" for="c-35936282">[-]</label><label class="expand" for="c-35936282">[1 more]</label></div><br/><div class="children"><div class="content">I solved this problem in a similar way some time ago. It was impractical to assign numbers to snapshots but each snapshot had a date assigned to it. So I computed the number of days since Unix epoch for each snapshot = n. Then the largest power of 2 which divides n. m = n &amp;(~(n-1)) I think. Then I computed the date after which I wanted to delete a snapshot n +f*m. The factor f contros the density. I chose f = 2.<p>Every day there is exactly one date for which a snapshot needs to be deleted and it can be computed directly. If there is no snapshot for this date nothing needs to be done.</div><br/></div></div><div id="35935502" class="c"><input type="checkbox" id="c-35935502" checked=""/><div class="controls bullet"><span class="by">repsilat</span><span>|</span><a href="#35936282">prev</a><span>|</span><a href="#35936193">next</a><span>|</span><label class="collapse" for="c-35935502">[-]</label><label class="expand" for="c-35935502">[1 more]</label></div><br/><div class="children"><div class="content">I guess a funny randomized algorithm is just &quot;if snapshots.size() &gt; capacity delete random snapshot&quot; (depending on complexity of random deletions.) If they&#x27;re in a B-tree not bad. Snapshots have a half life so they fall off exponentially.<p>Maybe not hard to get a deterministically good distribution (haven&#x27;t properly read TFA) but I guess you&#x27;d be sad if you didn&#x27;t do better than the most obvious thing.<p>I guess also an algorithm like &quot;delete the (i mod n)th oldest element once you hit the capacity&quot; also deletes every second element every n iterations, though maybe a bit uneven as it prefers to thin things out in quite local ways.</div><br/></div></div><div id="35936193" class="c"><input type="checkbox" id="c-35936193" checked=""/><div class="controls bullet"><span class="by">flipperhero</span><span>|</span><a href="#35935502">prev</a><span>|</span><a href="#35935337">next</a><span>|</span><label class="collapse" for="c-35936193">[-]</label><label class="expand" for="c-35936193">[2 more]</label></div><br/><div class="children"><div class="content">Is there a similarly simple scheme that works even if you decouple the snapshot phase from the GC phase.<p>Use case: I already have a list of equally spaced snapshots that I&#x27;d like to logarithmically space.<p>Also, it occurs to me that this (and other grandfather snapshot schemes) ultimately derive from the generational hypothesis: users want files for either a short time (transient files, tarballs, PDFs, checkouts) or a long time (photos).</div><br/><div id="35936251" class="c"><input type="checkbox" id="c-35936251" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#35936193">parent</a><span>|</span><a href="#35935337">next</a><span>|</span><label class="collapse" for="c-35936251">[-]</label><label class="expand" for="c-35936251">[1 more]</label></div><br/><div class="children"><div class="content">You mean, you want to get rid of some (most) of your linearly spaced snapshots, so that the remainder are logarithmically spaced?  Not too difficult:<p>- Start with the most recent snapshot; keep it<p>- Go on to the next snapshot; keep it, and then drop the next 2^1 - 1 = 1 snapshot<p>- Go on to the next snapshot; keep it, and then drop the next 2^2 - 1 = 3 snapshots<p>- Go on to the next snapshot; keep it, and then drop the next 2^3 - 1 = 7 snapshots<p>Etc.<p>Alternately (if it&#x27;s easier to model or implement it thus), the snapshots that you keep are the ones at power-of-two indices, plus 0 (starting again from the most recent snapshot): snapshot 0, snapshot 1, snapshot 2, snapshot 4...</div><br/></div></div></div></div><div id="35935337" class="c"><input type="checkbox" id="c-35935337" checked=""/><div class="controls bullet"><span class="by">zargon</span><span>|</span><a href="#35936193">prev</a><span>|</span><a href="#35935490">next</a><span>|</span><label class="collapse" for="c-35935337">[-]</label><label class="expand" for="c-35935337">[1 more]</label></div><br/><div class="children"><div class="content">At first glance this looks to me like it is the so-called Tower of Hanoi method of maintaining tape backups. If you have x sets of tapes, you can keep backups weighted towards more recent copies while also having some old ones by using set 1 every other day, set 2 every 4 days, set 3 every 8 days, etc.</div><br/></div></div><div id="35935490" class="c"><input type="checkbox" id="c-35935490" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#35935337">prev</a><span>|</span><a href="#35935497">next</a><span>|</span><label class="collapse" for="c-35935490">[-]</label><label class="expand" for="c-35935490">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve often wondered whether you could effectively use this strategy to optimize a (braces for impact) blockchain. Presumably there are some relevant time spans:<p>- how long ago you need blocks for preventing alternate-history shenanigans<p>- how long ago you need blocks for nodes that may go offline for a while and come back confused<p>- how long ago you need fine granularity of records for accounting reasons<p>If none of those timespans are &quot;forever&quot; then maybe there could be agreement between nodes that at some point we start summarizing.  So instead of deleting snapshots, you&#x27;re merging adjacent blocks and purging transitional states that are not required to tell a consistent story.</div><br/></div></div><div id="35935497" class="c"><input type="checkbox" id="c-35935497" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#35935490">prev</a><span>|</span><label class="collapse" for="c-35935497">[-]</label><label class="expand" for="c-35935497">[1 more]</label></div><br/><div class="children"><div class="content">this is a very nice family of structures; perhaps you could use it to choose which previous line in a poem to rhyme with, or which previous day to reflect on</div><br/></div></div></div></div></div></div></div></body></html>