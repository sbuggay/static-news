<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729242071367" as="style"/><link rel="stylesheet" href="styles.css?v=1729242071367"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/Articles/992055/">Smart pointers for the kernel</a> <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>signa11</span> | <span>65 comments</span></div><br/><div><div id="41875908" class="c"><input type="checkbox" id="c-41875908" checked=""/><div class="controls bullet"><span class="by">smodo</span><span>|</span><a href="#41876106">next</a><span>|</span><label class="collapse" for="c-41875908">[-]</label><label class="expand" for="c-41875908">[51 more]</label></div><br/><div class="children"><div class="content">I’m not very well versed in kernel development. But I am a Rust dev and have observed the discussion about Rust in Linux with interest… Having said that, this part of the article has me baffled:<p>&gt;&gt; implementing these features for a smart-pointer type with a malicious or broken Deref (the trait that lets a programmer dereference a value) implementation could break the guarantees Rust relies on to determine when objects can be moved in memory. (…) [In] keeping with Rust&#x27;s commitment to ensuring safe code cannot cause memory-safety problems, the RFC also requires programmers to use unsafe (specifically, implementing an unsafe marker trait) as a promise that they&#x27;ve read the relevant documentation and are not going to break Pin.<p>To the uninformed this seems like crossing the very boundary that you wanted Rust to uphold? Yes it’s only an impl Trait but still… I can hear the C devs now. ‘We pinky promise to clean up after our mallocs too!’</div><br/><div id="41876426" class="c"><input type="checkbox" id="c-41876426" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#41875908">parent</a><span>|</span><a href="#41876088">next</a><span>|</span><label class="collapse" for="c-41876426">[-]</label><label class="expand" for="c-41876426">[1 more]</label></div><br/><div class="children"><div class="content">Try imagining trait AlwaysIndexableUnder100. There&#x27;s a generic codebase&#x2F;library that takes in types that implement that trait, and do indexing with indexes that are always below 100. Like `usersCustomSliceA[4] = usersCustomSliceB[5];`<p>You&#x27;d be tempted, for performance, to use `get_unchecked` methods that skip the boundary checks. After all, the trait says that this should always succeed.<p>However, if the user passes in a type that is not indexable with integers smaller than 100, whose fault it is if the program segfaults? The users? But they managed to get the program to segfault _without_ writing unsafe code. The provider of the library? They are using `unsafe` to call `get_unchecked` after all.<p>Bingo. It&#x27;s the library dev&#x27;s fault. The API they provide is not sound. However, they can make it sound by marking the _trait_ unsafe to implement. Then the user needs to type `unsafe` when implementing the trait for their type. &quot;I solemnly swear that this type is actually indexable with all integers smaller than 100.&quot; That shifts the blame to the mistaken implementation, and the user is to blame.<p>It&#x27;s the same situation here. Deref is not unsafe to implement. That&#x27;s why if you need to uphold a trust boundary, you need an unsafe trait.<p>So, the whole thing doesn&#x27;t account to crossing the boundary willy nilly, a big point of Rust&#x27;s unsafe is for the compiler to force documenting and checking for accountability: who is required to do what, and who is allowed to rely on that.</div><br/></div></div><div id="41876088" class="c"><input type="checkbox" id="c-41876088" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#41875908">parent</a><span>|</span><a href="#41876426">prev</a><span>|</span><a href="#41875965">next</a><span>|</span><label class="collapse" for="c-41876088">[-]</label><label class="expand" for="c-41876088">[1 more]</label></div><br/><div class="children"><div class="content">This kind of use of unsafe has been in rust forever, for example with `Sync`, `Send`. Implementing an unsafe marker trait to promise to the compiler that other methods on the structure act a certain way.<p>The scope of an unsafe block has always been interpreted to include guaranteeing things about it&#x27;s surroundings up to other things in the same module. E.g. if I&#x27;m implementing `Vector::push` I&#x27;m going to rely on the fact that `self.capacity` really is the size of the allocation behind `self.ptr` without verifying it, and I&#x27;m going to feel good about that because those fields aren&#x27;t public and everything within the module doesn&#x27;t let you violate that constraint, so it&#x27;s not possible for external safe code to violate it.<p>The same applies to marker traits. If I&#x27;m writing `unsafe impl Send for MyStruct {}` I&#x27;m promising that the module exposes an interface where `MyStruct` with will always comply with the requirements of `Send` no matter what safe external code does (i.e. sending MyStructs across threads is safe given the exposed API). With this proposal if I write `unsafe impl PinCoerceUnsized for MyStruct {}` I&#x27;m promising the same with respect to that (whatever the documentation for that trait ends up saying, which should essentially be that I&#x27;ve implemented `Deref for MyStruct` in the same module and I don&#x27;t expose any way for safe external code to change what reference `Deref` returns).</div><br/></div></div><div id="41875965" class="c"><input type="checkbox" id="c-41875965" checked=""/><div class="controls bullet"><span class="by">foundry27</span><span>|</span><a href="#41875908">parent</a><span>|</span><a href="#41876088">prev</a><span>|</span><a href="#41877004">next</a><span>|</span><label class="collapse" for="c-41875965">[-]</label><label class="expand" for="c-41875965">[44 more]</label></div><br/><div class="children"><div class="content">Rust’s whole premise of guaranteed memory safety through compiletime checks has always been undermined when confronted with the reality that certain foundational operations must still be implemented using unsafe. Inevitably folks concede that lower level libraries will have these unsafe blocks and still expect higher level code to trust them, and at that point we’ve essentially recreated the core paradigm of C: trust in the programmer’s diligence. Yeah Rust makes this trust visible, but it doesn’t actually eliminate it in “hard” code.<p>The punchline here, so to speak, is that for all Rust’s claims to revolutionize safety, it simply(!) formalizes the same unwritten social contract C developers have been meandering along with for decades. The uniqueness boils down to “we still trust the devs, but at least now we’ve made them swear on it in writing”.</div><br/><div id="41876042" class="c"><input type="checkbox" id="c-41876042" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41875965">parent</a><span>|</span><a href="#41876303">next</a><span>|</span><label class="collapse" for="c-41876042">[-]</label><label class="expand" for="c-41876042">[18 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you&#x27;re giving Rust enough credit here.<p>For those projects that don&#x27;t use any unsafe, we can say -- absent compiler bugs or type system unsoundness -- that there will be no memory leaks or data races or undefined behavior.  That&#x27;s useful!  Very useful!<p>For projects that <i>do</i> need unsafe, that unsafe code can be cordoned off into a corner where it can be made as small as possible, and can be audited.  The rest of the code base is just as safe as one with no unsafe at all.  This is also very useful!<p>Now, sure, if most projects needed to use unsafe, and&#x2F;or if most projects had to write a significant amount of unsafe, then sure, I&#x27;d agree with you.  But that&#x27;s just not the reality for nearly all projects.<p>With C, everything is unsafe.  Everything can have memory leaks or data races or undefined behavior.  Audits for these issues need to examine every single line of code.  Compilers and linters and sanitizers can help you here, but they can never be comprehensive or guarantee the absence of problems.<p>I&#x27;ve been writing C for more than 20 years now.  I still write memory leaks.  I still write NULL pointer dereferences.  I still struggle sometimes to get my data ownership (and&#x2F;or locking) right when I have to write multithreaded code.  When I get to write Rust, I&#x27;m <i>so happy</i> that I don&#x27;t have to worry about those things, or spend time with valgrind or ASAN or clang&#x27;s scan-build to figure out what I&#x27;ve done wrong.  Rust lets me focus more on what I actually care about, the actual code and algorithms and structure of my program.</div><br/><div id="41876895" class="c"><input type="checkbox" id="c-41876895" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876042">parent</a><span>|</span><a href="#41877492">next</a><span>|</span><label class="collapse" for="c-41876895">[-]</label><label class="expand" for="c-41876895">[1 more]</label></div><br/><div class="children"><div class="content"><i>&quot;For projects that do need unsafe, that unsafe code can be cordoned off into a corner, where it can be made as small as possible, and can be audited. The rest of the code base is just as safe as one with no unsafe at all. This is also very useful!&quot;</i><p>Exactly this, and very well put!<p>I&#x27;d just like to add one small but important detail. It&#x27;s one of the things that is so obvious to one group that they rarely even mention it, but at the same time so obscure to the others that they are completely oblivious to it.<p>While the unsafe code is cordoned off into a corner its effects are not. A bug in an unsafe block in one part of your program can trigger an outcome in a completely different and safe part of your program, that normally safe Rust should prevent.<p>To put it more metaphorically, Rust restricts the places where bombs can be placed, it does not limit the blast radius in case a bomb goes off.<p>This is still <i>huge</i> progress compared to C&#x2F;C++, where the bombs can and usually are everywhere and trying to write it safely feels a lot like playing minesweeper.</div><br/></div></div><div id="41876102" class="c"><input type="checkbox" id="c-41876102" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876042">parent</a><span>|</span><a href="#41877492">prev</a><span>|</span><a href="#41876214">next</a><span>|</span><label class="collapse" for="c-41876102">[-]</label><label class="expand" for="c-41876102">[2 more]</label></div><br/><div class="children"><div class="content">Yes, the drawback of unsafe is one single goof in just one unsafe block can blow your entire program wide open. The advantage is that your entire program isn&#x27;t one gigantic unsafe block (like C).<p>The magnitude matters.</div><br/><div id="41876201" class="c"><input type="checkbox" id="c-41876201" checked=""/><div class="controls bullet"><span class="by">gauge_field</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876102">parent</a><span>|</span><a href="#41876214">next</a><span>|</span><label class="collapse" for="c-41876201">[-]</label><label class="expand" for="c-41876201">[1 more]</label></div><br/><div class="children"><div class="content">Also, in my experience, the locality and unsafe api is better for testing purposes compared to unsafe language.
If I have an unsafe code that provides safe api with certain safety conditions.<p>1) I have a more ergonomic&#x2F;precise&#x2F;local contract to satisfy safety<p>2) Since this unsafe block is local, it is easier to set up its testing conditions for various scenarios. Otherwise, testing for bigger unsafe block (e.g. unsafe language) would also have to handle coupling between api from which ub originates and the rest of the code.</div><br/></div></div></div></div><div id="41876214" class="c"><input type="checkbox" id="c-41876214" checked=""/><div class="controls bullet"><span class="by">foundry27</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876042">parent</a><span>|</span><a href="#41876102">prev</a><span>|</span><a href="#41876335">next</a><span>|</span><label class="collapse" for="c-41876214">[-]</label><label class="expand" for="c-41876214">[6 more]</label></div><br/><div class="children"><div class="content">I’ll propose that most Rust projects that do useful work (in the potential energy sense?) depend on unsafe code, and it’s likely going to be found in the codebases of their dependencies and transitive dependencies. But I agree with almost all of what you’re saying about C and Rust; I work on a C operating system professionally, and I know those same pain points intimately. I program in Rust for fun, and it’s great to use.<p>At the end of the day this isn’t a technical argument I’m trying to make, it’s a philosophical one. I think that the more we normalize eroding the core benefits the language safety features provide, one enhancement proposal at a time, one escape hatch added each year for special interfaces, the less implicit trust you can have in rust projects without reviewing them and their dependencies for correctness.<p>I think that trust has enormous value, and I think it would suck to lose it. (reflect: what does seeing “written in rust” as a suffix make you think about a project’s qualities before you ever read the code)</div><br/><div id="41876350" class="c"><input type="checkbox" id="c-41876350" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876214">parent</a><span>|</span><a href="#41877241">next</a><span>|</span><label class="collapse" for="c-41876350">[-]</label><label class="expand" for="c-41876350">[3 more]</label></div><br/><div class="children"><div class="content">I’ll propose that ALL Rust projects that do useful work depend on unsafe code.<p>If one claims otherwise, I say they have no understanding of Rust. But also, if one helds that against Rust&#x27;s value promise, I, again, say that they have no understanding of Rust.</div><br/><div id="41877122" class="c"><input type="checkbox" id="c-41877122" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876350">parent</a><span>|</span><a href="#41877027">next</a><span>|</span><label class="collapse" for="c-41877122">[-]</label><label class="expand" for="c-41877122">[1 more]</label></div><br/><div class="children"><div class="content">I get the impression they&#x27;re only counting code outside the standard library, in which case tons of useful programs are fully safe.</div><br/></div></div><div id="41877027" class="c"><input type="checkbox" id="c-41877027" checked=""/><div class="controls bullet"><span class="by">I_AM_A_SMURF</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876350">parent</a><span>|</span><a href="#41877122">prev</a><span>|</span><a href="#41877241">next</a><span>|</span><label class="collapse" for="c-41877027">[-]</label><label class="expand" for="c-41877027">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely all of them. Even HashMap uses unsafe.</div><br/></div></div></div></div><div id="41877241" class="c"><input type="checkbox" id="c-41877241" checked=""/><div class="controls bullet"><span class="by">jdiez17</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876214">parent</a><span>|</span><a href="#41876350">prev</a><span>|</span><a href="#41876614">next</a><span>|</span><label class="collapse" for="c-41877241">[-]</label><label class="expand" for="c-41877241">[1 more]</label></div><br/><div class="children"><div class="content">Of course all software ultimately runs on hardware, which has things like registers and hidden internal state which affect how that hardware accesses or writes to physical memory and all sorts of other &quot;unsafe&quot; things.<p>In a more practical sense, all software, even Python programs, ultimately call C functions that are unsafe.<p>It&#x27;s like that saying &quot;all abstractions are wrong, some are useful&quot;.<p>&gt; what does seeing “written in rust” as a suffix make you think about a project’s qualities before you ever read the code<p>By itself, that tells me very little about a project. Same thing if I see a project written in Python or Go, which are nominally memory safe programming languages. 
I perceive a statistically significant likelihood that software written in these languages will not segfault on me, but it&#x27;s no guarantee. 
If I see two programs with the same functionality, where one is written in Python and another one in Rust, I also have some expectation that the one written in Rust will be more performant.<p>But you cannot draw general conclusions from that piece of information alone.<p>However, as a programmer, Rust is a tool that makes it easier for me to write code that will not segfault or cause data races.</div><br/></div></div><div id="41876614" class="c"><input type="checkbox" id="c-41876614" checked=""/><div class="controls bullet"><span class="by">kloop</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876214">parent</a><span>|</span><a href="#41877241">prev</a><span>|</span><a href="#41876335">next</a><span>|</span><label class="collapse" for="c-41876614">[-]</label><label class="expand" for="c-41876614">[1 more]</label></div><br/><div class="children"><div class="content">&gt; reflect: what does seeing “written in rust” as a suffix make you think about a project’s qualities before you ever read the code<p>That the community is going to be significantly more dramatic than average</div><br/></div></div></div></div><div id="41876335" class="c"><input type="checkbox" id="c-41876335" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876042">parent</a><span>|</span><a href="#41876214">prev</a><span>|</span><a href="#41876080">next</a><span>|</span><label class="collapse" for="c-41876335">[-]</label><label class="expand" for="c-41876335">[2 more]</label></div><br/><div class="children"><div class="content">Also Rust is far from the only language that gives you escape-hatches out of the safety sandbox where you can make a mess if you&#x27;re reckless. Java, Python, Go, C#... (heck, C# also has an `unsafe` keyword) but hardly anyone would argue those languages have the same safety issues that C has.</div><br/><div id="41877474" class="c"><input type="checkbox" id="c-41877474" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876335">parent</a><span>|</span><a href="#41876080">next</a><span>|</span><label class="collapse" for="c-41877474">[-]</label><label class="expand" for="c-41877474">[1 more]</label></div><br/><div class="children"><div class="content">In C unsafe code is typically marked by surrounding it with {braces}.</div><br/></div></div></div></div><div id="41876080" class="c"><input type="checkbox" id="c-41876080" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876042">parent</a><span>|</span><a href="#41876335">prev</a><span>|</span><a href="#41876602">next</a><span>|</span><label class="collapse" for="c-41876080">[-]</label><label class="expand" for="c-41876080">[3 more]</label></div><br/><div class="children"><div class="content">nit - Rust does allow memory leaks in safe code. <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;mem&#x2F;fn.forget.html#safety" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;mem&#x2F;fn.forget.html#safety</a></div><br/><div id="41877088" class="c"><input type="checkbox" id="c-41877088" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876080">parent</a><span>|</span><a href="#41876601">next</a><span>|</span><label class="collapse" for="c-41877088">[-]</label><label class="expand" for="c-41877088">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also possible to leak memory in languages with tracing garbage collection, just create a data structure that holds strong references to objects that are no longer needed, which commonly happens when using something like a HashMap as a cache without any kind of expiration.</div><br/></div></div><div id="41876601" class="c"><input type="checkbox" id="c-41876601" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876080">parent</a><span>|</span><a href="#41877088">prev</a><span>|</span><a href="#41876602">next</a><span>|</span><label class="collapse" for="c-41876601">[-]</label><label class="expand" for="c-41876601">[1 more]</label></div><br/><div class="children"><div class="content">Yes, memory leaks are rarer in Rust than in C, but they are an entirely different topic that &#x27;unsafe&#x27; blocks.</div><br/></div></div></div></div><div id="41876602" class="c"><input type="checkbox" id="c-41876602" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876042">parent</a><span>|</span><a href="#41876080">prev</a><span>|</span><a href="#41876303">next</a><span>|</span><label class="collapse" for="c-41876602">[-]</label><label class="expand" for="c-41876602">[2 more]</label></div><br/><div class="children"><div class="content">This is giving Rust a bit too much credit though.<p>- Memory leaks are not just possible in Rust, they&#x27;re easy to write and mildly encouraged by the constraints the language places on you. IME I see more leaks in Rust in the wild than in C, C#, Python, C++, ...<p>- You can absolutely have data races in a colloquial sense in Rust, just not in the sense of the narrower definition they created to be able to say they don&#x27;t have data races. An easy way to do so is choosing the wrong memory ordering for atomic loads and stores, including subtle issues like those arising from mixing `seq_cst` and `acquire`. I think those kinds of bugs are rare in the wild, but one project I inherited was riddled with data races in Safe rust.<p>- Unsafe is a kind of super-unsafe that&#x27;s harder to write correctly than C or C++, limiting its utility as an escape hatch. It&#x27;ll trigger undefined behavior in surprising ways if you don&#x27;t adhere to a long list of rules in your unsafe code blocks (in a way which safe code can detect). The list changes between Rust versions, requiring re-audits. Some algorithms (especially multi-threaded ones) simply can&#x27;t even be written in small, easily verifiable unsafe blocks without causing UB. The unsafeness colors surrounding code.</div><br/><div id="41877210" class="c"><input type="checkbox" id="c-41877210" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876602">parent</a><span>|</span><a href="#41876303">next</a><span>|</span><label class="collapse" for="c-41877210">[-]</label><label class="expand" for="c-41877210">[1 more]</label></div><br/><div class="children"><div class="content">Wait, when exactly did the soundness rules change since 1.0? When have you had to re-audit unsafe code?<p>The Rustonomicon [1] serves as a decent introduction to what you can or can&#x27;t do in unsafe code, and none of that changed to my knowledge.<p>I agree that it&#x27;s sometimes challenging to contain `unsafe` in a small blast zone, but it&#x27;s pretty rare IME.<p>[1]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;intro.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;intro.html</a></div><br/></div></div></div></div></div></div><div id="41876303" class="c"><input type="checkbox" id="c-41876303" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41875965">parent</a><span>|</span><a href="#41876042">prev</a><span>|</span><a href="#41876016">next</a><span>|</span><label class="collapse" for="c-41876303">[-]</label><label class="expand" for="c-41876303">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the same unwritten social contract: in Rust even the unsafe code has the same stricter type signatures as the safe code, so there is a formal way to judge which part of the program is at fault when the contract is broken. You might say the contract is now written. :-)<p>In C, the type system does not express things like pointer validity, so you have to consider the system as a whole every time something goes wrong. In Rust, because the type system is <i>sound</i>, you can consider each part of the program in isolation, and know that the type system will prevent their composition from introducing any memory safety problems.<p>This has major implications in the other direction as well: soundness means that unsafe code can be given a type signature that prevents its clients from using it incorrectly. This means the set of things the compiler can verify can be extended by libraries.<p>The actual practice of writing memory-safe C vs memory-safe Rust is qualitatively different.</div><br/><div id="41876940" class="c"><input type="checkbox" id="c-41876940" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876303">parent</a><span>|</span><a href="#41876016">next</a><span>|</span><label class="collapse" for="c-41876940">[-]</label><label class="expand" for="c-41876940">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In Rust, because the type system is sound<p>Unfortunately, it&#x27;s not. Now I do think it will be eventually fixed, but given how long it has taken it must be thorny. <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;25860">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;25860</a></div><br/><div id="41877225" class="c"><input type="checkbox" id="c-41877225" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876940">parent</a><span>|</span><a href="#41877526">next</a><span>|</span><label class="collapse" for="c-41877225">[-]</label><label class="expand" for="c-41877225">[1 more]</label></div><br/><div class="children"><div class="content">In practice this is a compiler bug, though, and is treated as such, and not a soundness hole in the abstract design of the type system.<p>There has also not been a single case of this bug being triggered in the wild by accident.</div><br/></div></div><div id="41877526" class="c"><input type="checkbox" id="c-41877526" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876940">parent</a><span>|</span><a href="#41877225">prev</a><span>|</span><a href="#41876016">next</a><span>|</span><label class="collapse" for="c-41877526">[-]</label><label class="expand" for="c-41877526">[1 more]</label></div><br/><div class="children"><div class="content">That code looks horrendous.</div><br/></div></div></div></div></div></div><div id="41876016" class="c"><input type="checkbox" id="c-41876016" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41875965">parent</a><span>|</span><a href="#41876303">prev</a><span>|</span><a href="#41876891">next</a><span>|</span><label class="collapse" for="c-41876016">[-]</label><label class="expand" for="c-41876016">[5 more]</label></div><br/><div class="children"><div class="content">The difference is every line of C can do something wrong while very few lines of Rust can. It&#x27;s much easier to scrutinize a small well contained class with tools like formal methods than a sprawling codebase.</div><br/><div id="41877544" class="c"><input type="checkbox" id="c-41877544" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876016">parent</a><span>|</span><a href="#41876538">next</a><span>|</span><label class="collapse" for="c-41877544">[-]</label><label class="expand" for="c-41877544">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div><div id="41876538" class="c"><input type="checkbox" id="c-41876538" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876016">parent</a><span>|</span><a href="#41877544">prev</a><span>|</span><a href="#41876891">next</a><span>|</span><label class="collapse" for="c-41876538">[-]</label><label class="expand" for="c-41876538">[3 more]</label></div><br/><div class="children"><div class="content">If you limited wrong to &quot;memory safe&quot; and also ignore that unsafe parts violating invariants can make safe parts of Rust to be wrong.</div><br/><div id="41876669" class="c"><input type="checkbox" id="c-41876669" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876538">parent</a><span>|</span><a href="#41876891">next</a><span>|</span><label class="collapse" for="c-41876669">[-]</label><label class="expand" for="c-41876669">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you limited wrong to &quot;memory safe&quot;<p>Yes, because this is a discussion about the value of &quot;unsafe&quot;, so we&#x27;re only talking about the wrongs that are enabled by &quot;unsafe&quot;.<p>&gt; and also ignore that unsafe parts violating invariants can make safe parts of Rust to be wrong.<p>If I run a line of code that corrupts memory, and the program crashes 400 lines later, I don&#x27;t say the spot where it crashes is wrong, I say the memory corrupting line is wrong.  So I disagree with you here.</div><br/><div id="41877536" class="c"><input type="checkbox" id="c-41877536" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876669">parent</a><span>|</span><a href="#41876891">next</a><span>|</span><label class="collapse" for="c-41877536">[-]</label><label class="expand" for="c-41877536">[1 more]</label></div><br/><div class="children"><div class="content">It does not invalidate an argument that you do not want to talk about it.<p>Regarding the second point: yes, you can then blame the &quot;unsafe&quot; part but the issue is that the problem might not be so localized as the notion of &quot;only auditing unsafe blocks is sufficient&quot; implies.  You may need to understand the subtle interaction of unsafe blocks with the rest of the program.</div><br/></div></div></div></div></div></div></div></div><div id="41876891" class="c"><input type="checkbox" id="c-41876891" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41875965">parent</a><span>|</span><a href="#41876016">prev</a><span>|</span><a href="#41876330">next</a><span>|</span><label class="collapse" for="c-41876891">[-]</label><label class="expand" for="c-41876891">[1 more]</label></div><br/><div class="children"><div class="content">It is literally impossible to build systems where you never at any point trust that underlying systems work correctly. This is a boring and uninformative criticism. It is the case for every language ever invented.</div><br/></div></div><div id="41876330" class="c"><input type="checkbox" id="c-41876330" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41875965">parent</a><span>|</span><a href="#41876891">prev</a><span>|</span><a href="#41876352">next</a><span>|</span><label class="collapse" for="c-41876330">[-]</label><label class="expand" for="c-41876330">[1 more]</label></div><br/><div class="children"><div class="content">Would you similarly say that Russian Roulette is the same game whether the revolver has two chambers or ten thousand?</div><br/></div></div><div id="41876352" class="c"><input type="checkbox" id="c-41876352" checked=""/><div class="controls bullet"><span class="by">sqeaky</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41875965">parent</a><span>|</span><a href="#41876330">prev</a><span>|</span><a href="#41876128">next</a><span>|</span><label class="collapse" for="c-41876352">[-]</label><label class="expand" for="c-41876352">[1 more]</label></div><br/><div class="children"><div class="content">Constrained and minimized trust in programmer diligence is better than unconstrained and omnipresent trust in the same.</div><br/></div></div><div id="41876128" class="c"><input type="checkbox" id="c-41876128" checked=""/><div class="controls bullet"><span class="by">stackghost</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41875965">parent</a><span>|</span><a href="#41876352">prev</a><span>|</span><a href="#41876122">next</a><span>|</span><label class="collapse" for="c-41876128">[-]</label><label class="expand" for="c-41876128">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a rust fanboy but isn&#x27;t the point of rust to dramatically decrease the area in which null pointer dereferences and friends can occur, and thus make them more likely to be spotted?</div><br/></div></div><div id="41876122" class="c"><input type="checkbox" id="c-41876122" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41875965">parent</a><span>|</span><a href="#41876128">prev</a><span>|</span><a href="#41876459">next</a><span>|</span><label class="collapse" for="c-41876122">[-]</label><label class="expand" for="c-41876122">[7 more]</label></div><br/><div class="children"><div class="content">I think when people come to these conclusions it&#x27;s largely due to a misunderstanding of what exactly the point of most programming language safety measures are and why they make sense.<p>Something that people often ponder is why you can&#x27;t just solve the null safety problem by forcing every pointer dereference to be checked, with no other changes. Well of course, you <i>can</i> do that. But actually, simply checking to make sure the pointer is non-null at the point of dereference gets you surprisingly little. When you do this, what you&#x27;re (ostencibly) trying to do is reduce the number of null pointer dereferences, but in practice what happens now is that you just have to explicitly handle them. But, in a lot of cases, there&#x27;s really nothing particularly sensible to do: the pointer not being null is an invariant that was supposed to be upheld and it wasn&#x27;t, and now at the point of dereference, at runtime, there&#x27;s nothing to do except crash. Which is what would&#x27;ve happened <i>anyways</i>, so what&#x27;s the point? What you really want to do isn&#x27;t actually prevent null pointer dereferences, it&#x27;s to uphold the invariants that the pointer is non-null in the first place, ideally before you leave compile time.<p>Disallowing &quot;unsafe&quot; operations without marking them explicitly unsafe doesn&#x27;t give you a whole lot, but what you <i>can</i> do is expand the number of explicitly <i>safe</i> operations to cover more of what you want to do. How Rust, and many other programming languages, have been accomplishing this is by expanding the type system, and combining this with control flow analysis. Lifetimes in Rust are a prime example, but there are many more such examples. Nullability, for example, in languages like TypeScript. When you do it <i>this</i> way, the safety of such &quot;safe&quot; operations can be guaranteed, and while these guarantees do have some caveats, they are very strong to a lot of different situations that human code reviews are not, such as an unsafe combination of two otherwise-safe changesets.<p>It&#x27;s actually totally fine that some code will probably remain unable to be easily statically verified, the point is that we want to reduce the amount of code that can&#x27;t be easily statically verified to be as small as possible. In the future we can use much less easy approaches to statically verify unsafe blocks, such as using theorem provers to try to prove the correctness of &quot;unsafe&quot; code. But even just reducing the amount of not-necessarily-memory-safe code is an enormous win, for obvious reasons: it dramatically reduces the surface area for vulnerabilities. Moreover, time and time again, it is validated that most new vulnerabilities come from relatively recent changes in code, which is another huge win: a lot of the unsafe foundations actually don&#x27;t need to be changed very often.<p>There is absolutely nothing special about code written in Rust, it&#x27;s doing the same shit that C code has been doing for decades (well, on the abstract anyway; I&#x27;m not trying to downplay how much more expressive it is by any means). What Rust mainly offers is a significantly more advanced type system that allows validating many more invariants at compile-time. God knows C developers on large projects like the Linux kernel care about validating invariants: large amounts of effort have been poured into static checking tools for C that do exactly this. Rust is a step further though, as the safe subset of Rust provides guarantees that you basically can&#x27;t just tack onto C with only more static checking tools.</div><br/><div id="41876308" class="c"><input type="checkbox" id="c-41876308" checked=""/><div class="controls bullet"><span class="by">sfvisser</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876122">parent</a><span>|</span><a href="#41876615">next</a><span>|</span><label class="collapse" for="c-41876308">[-]</label><label class="expand" for="c-41876308">[5 more]</label></div><br/><div class="children"><div class="content">Isn’t the argument that by checking for NULL you can now safely crash&#x2F;panic instead of going into undefined behavior and being a potential security hazard?</div><br/><div id="41876394" class="c"><input type="checkbox" id="c-41876394" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876308">parent</a><span>|</span><a href="#41877163">next</a><span>|</span><label class="collapse" for="c-41876394">[-]</label><label class="expand" for="c-41876394">[3 more]</label></div><br/><div class="children"><div class="content">The potential for undefined behavior is, I will agree, potentially fairly serious, especially depending on specific circumstances... (In most cases it should reliably hit an unmapped page and cause an exception, but there are exceptions on weird targets or with huge offsets.) But, you can pretty much entirely ignore it if you can just guarantee that the pointer isn&#x27;t NULL in the first place, which not only prevents you from needing to worry about the undefined behavior, but also about incorrect code that might violate the invariant in the first place, since it is statically-checked.<p>If you were only afraid of the undefined behavior, you could augment the compiler to insert runtime checks anywhere undefined behavior could occur (which obviously can be done with Clang sanitizers.) However, the undefined behavior problem is really just a symptom of incorrect code, so it&#x27;d be even better if we could just prevent that instead.<p>In high level languages like Java and Python there is just as much, if not more, interest in preventing null reference exceptions, even though they are &quot;safe&quot;.</div><br/><div id="41877503" class="c"><input type="checkbox" id="c-41877503" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876394">parent</a><span>|</span><a href="#41876616">next</a><span>|</span><label class="collapse" for="c-41877503">[-]</label><label class="expand" for="c-41877503">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In most cases it should reliably hit an unmapped page and cause an exception, but there are exceptions on weird targets or with huge offsets<p>Perhaps the most important exception is when the optimizer assumed the pointer was non-null, so optimized it in a way that produces completely unexpected behavior when it is null.<p>Also use-after-free and use of uninitialized pointers is more likely to point to incorrect, but mapped, locations.</div><br/></div></div><div id="41876616" class="c"><input type="checkbox" id="c-41876616" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876394">parent</a><span>|</span><a href="#41877503">prev</a><span>|</span><a href="#41877163">next</a><span>|</span><label class="collapse" for="c-41876616">[-]</label><label class="expand" for="c-41876616">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (In most cases it should reliably hit an unmapped page and cause an exception, but there are exceptions on weird targets or with huge offsets.)<p>The kernel is one such exception.</div><br/></div></div></div></div><div id="41877163" class="c"><input type="checkbox" id="c-41877163" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876308">parent</a><span>|</span><a href="#41876394">prev</a><span>|</span><a href="#41876615">next</a><span>|</span><label class="collapse" for="c-41877163">[-]</label><label class="expand" for="c-41877163">[1 more]</label></div><br/><div class="children"><div class="content">If that was the only point, we could simply add a compiler flag to make null pointer deref defined behaviour (raise SIGSEGV). It&#x27;s already defined behaviour everywhere except the compiler&#x27;s optimizer - unlike say a use after free.</div><br/></div></div></div></div><div id="41876615" class="c"><input type="checkbox" id="c-41876615" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876122">parent</a><span>|</span><a href="#41876308">prev</a><span>|</span><a href="#41876459">next</a><span>|</span><label class="collapse" for="c-41876615">[-]</label><label class="expand" for="c-41876615">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But, in a lot of cases, there&#x27;s really nothing particularly sensible to do: the pointer not being null is an invariant that was supposed to be upheld and it wasn&#x27;t, and now at the point of dereference, at runtime, there&#x27;s nothing to do except crash. Which is what would&#x27;ve happened anyways, so what&#x27;s the point?<p>Crashing is the lucky case!  Specifically in the kernel, there can be valid memory at address 0, and there are exploits that capitalise on the friction between memory address 0 sometimes being and C&#x27;s null pointer being full of undefined behaviour.</div><br/></div></div></div></div><div id="41876459" class="c"><input type="checkbox" id="c-41876459" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41875965">parent</a><span>|</span><a href="#41876122">prev</a><span>|</span><a href="#41877004">next</a><span>|</span><label class="collapse" for="c-41876459">[-]</label><label class="expand" for="c-41876459">[5 more]</label></div><br/><div class="children"><div class="content">This is nonsense. Just because some small parts of the code are must be annotated as unsafe doesn’t mean that we’re suddenly back to C land. in comparison, with C the <i>entire</i> codebase is basically wrapped in a big unsafe. That difference is important, because in Rust you can focus your auditing and formal verification efforts on just those small unsafe blocks, whereas with C <i>everything</i> requires that same attention.<p>Furthermore, Rust doesn’t turn off <i>all</i> checks in unsafe, only certain ones.<p>,</div><br/><div id="41876544" class="c"><input type="checkbox" id="c-41876544" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876459">parent</a><span>|</span><a href="#41877004">next</a><span>|</span><label class="collapse" for="c-41876544">[-]</label><label class="expand" for="c-41876544">[4 more]</label></div><br/><div class="children"><div class="content">If you think correctness is only about memory safety, only then you can you can &quot;focus your auditing and formal efforts on just those small unsafe blocks&quot;.  And this is a core problem of Rust that people think they can do this.</div><br/><div id="41876573" class="c"><input type="checkbox" id="c-41876573" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876544">parent</a><span>|</span><a href="#41877228">next</a><span>|</span><label class="collapse" for="c-41876573">[-]</label><label class="expand" for="c-41876573">[1 more]</label></div><br/><div class="children"><div class="content">Memory and concurrency safety need to be the first steps, because how can you analyze results when the computer might not have executed your code correctly as written?</div><br/></div></div><div id="41877228" class="c"><input type="checkbox" id="c-41877228" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41876544">parent</a><span>|</span><a href="#41876573">prev</a><span>|</span><a href="#41877004">next</a><span>|</span><label class="collapse" for="c-41877228">[-]</label><label class="expand" for="c-41877228">[2 more]</label></div><br/><div class="children"><div class="content">my comment (and indeed in this entire comment chain) is within the context of memory safety. This should have been clear because of the focus on unsafe, which, compared to normal Rust, relaxes <i>only</i> memory safety.<p>Obviously if you want to get formal guarantees beyond that property, you have to reason about safe code also.<p>(Also, the comparison in this entire chain is against C, and the latter is better than Rust in this regard… how?)</div><br/><div id="41877502" class="c"><input type="checkbox" id="c-41877502" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41875908">root</a><span>|</span><a href="#41877228">parent</a><span>|</span><a href="#41877004">next</a><span>|</span><label class="collapse" for="c-41877502">[-]</label><label class="expand" for="c-41877502">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this discussion is about memory safety, but this does not invalidate my argument. There is no point in only auditing your code with respect to memory safety, so the argument that you can simply ignore everything outside &quot;unsafe&quot; blocks is simply wrong.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41877004" class="c"><input type="checkbox" id="c-41877004" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#41875908">parent</a><span>|</span><a href="#41875965">prev</a><span>|</span><a href="#41876213">next</a><span>|</span><label class="collapse" for="c-41877004">[-]</label><label class="expand" for="c-41877004">[1 more]</label></div><br/><div class="children"><div class="content">Rust is all about ring-fencing the scary parts in unsafe. A rust program that doesn&#x27;t use unsafe, and only uses dependencies that are sound with respect to unsafe, is guaranteed to be fine. And it is very easy to write code without using unsafe. Unlike C, where code style that is guaranteed to be memory safe is nigh impossible.<p>The difficult bit with Rust is still the sound use of unsafe, but it is quite feasible to do that by hand. It does, sadly, require looking at the entire module that contains the unsafe code.</div><br/></div></div><div id="41876213" class="c"><input type="checkbox" id="c-41876213" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#41875908">parent</a><span>|</span><a href="#41877004">prev</a><span>|</span><a href="#41876177">next</a><span>|</span><label class="collapse" for="c-41876213">[-]</label><label class="expand" for="c-41876213">[1 more]</label></div><br/><div class="children"><div class="content">I think the part that uses `unsafe` and can break Pin if done wrong is <i>the implementation of the smart-pointer type</i>, not its use.</div><br/></div></div><div id="41876177" class="c"><input type="checkbox" id="c-41876177" checked=""/><div class="controls bullet"><span class="by">mise_en_place</span><span>|</span><a href="#41875908">parent</a><span>|</span><a href="#41876213">prev</a><span>|</span><a href="#41876037">next</a><span>|</span><label class="collapse" for="c-41876177">[-]</label><label class="expand" for="c-41876177">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced you can have your cake and eat it too. Not a dig at Rust specifically; it&#x27;s more like, you can have managed memory, or manually manage it yourself. There is no in-between. The implementation ends up being a kludge. Terry had it right, just put everything in the lower 2 GB and DMA it.</div><br/></div></div></div></div><div id="41876106" class="c"><input type="checkbox" id="c-41876106" checked=""/><div class="controls bullet"><span class="by">acbits</span><span>|</span><a href="#41875908">prev</a><span>|</span><a href="#41875994">next</a><span>|</span><label class="collapse" for="c-41876106">[-]</label><label class="expand" for="c-41876106">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;acbits&#x2F;reftrack-plugin">https:&#x2F;&#x2F;github.com&#x2F;acbits&#x2F;reftrack-plugin</a><p>I wrote this GCC plugin for this exact reason. Let&#x27;s see whether the kernel team is interested in adopting it.</div><br/><div id="41876354" class="c"><input type="checkbox" id="c-41876354" checked=""/><div class="controls bullet"><span class="by">brenns10</span><span>|</span><a href="#41876106">parent</a><span>|</span><a href="#41875994">next</a><span>|</span><label class="collapse" for="c-41876354">[-]</label><label class="expand" for="c-41876354">[2 more]</label></div><br/><div class="children"><div class="content">I searched lore.kernel.org and couldn&#x27;t find any postings that propose using this in the kernel. I&#x27;d encourage you to share a proposal, otherwise the &quot;kernel team&quot; will never be interested, because they&#x27;ll never hear of it.</div><br/><div id="41876996" class="c"><input type="checkbox" id="c-41876996" checked=""/><div class="controls bullet"><span class="by">acbits</span><span>|</span><a href="#41876106">root</a><span>|</span><a href="#41876354">parent</a><span>|</span><a href="#41875994">next</a><span>|</span><label class="collapse" for="c-41876996">[-]</label><label class="expand" for="c-41876996">[1 more]</label></div><br/><div class="children"><div class="content">I will send it again. It probably got lost in the high traffic volume of LKML last year.</div><br/></div></div></div></div></div></div><div id="41875994" class="c"><input type="checkbox" id="c-41875994" checked=""/><div class="controls bullet"><span class="by">DoubleDecoded</span><span>|</span><a href="#41876106">prev</a><span>|</span><a href="#41876123">next</a><span>|</span><label class="collapse" for="c-41875994">[-]</label><label class="expand" for="c-41875994">[2 more]</label></div><br/><div class="children"><div class="content">&quot;could break the guarantees&quot; is a weak guarantee then.</div><br/><div id="41876027" class="c"><input type="checkbox" id="c-41876027" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#41875994">parent</a><span>|</span><a href="#41876123">next</a><span>|</span><label class="collapse" for="c-41876027">[-]</label><label class="expand" for="c-41876027">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still a guarantee. The point of the guarantee isn&#x27;t that <i>no</i> code can cause certain kinds of problems, but rather that any code that can must be marked unsafe.</div><br/></div></div></div></div><div id="41876123" class="c"><input type="checkbox" id="c-41876123" checked=""/><div class="controls bullet"><span class="by">stonethrowaway</span><span>|</span><a href="#41875994">prev</a><span>|</span><label class="collapse" for="c-41876123">[-]</label><label class="expand" for="c-41876123">[8 more]</label></div><br/><div class="children"><div class="content">Anyone who wants to do kernel-level development should first do Embedded hardware&#x2F;software interfacing. No RTOS, plain “Embedded C”, with some bit banging and dealing with voltage spikesc transients and people doing stupid shit to hardware (yes, really) and other things. Know the memory map and recite it from memory. Some might think I’m joking or being facetious - no, I’m pretty serious actually. I’d rather have an embedded person writing kernel drivers in slapped-together C than a Rustacian that complains about unsafe code and being an idiot about it. See [0] for detailed explanation.<p>People need to learn the niceness of safety and perfect execution is a continuum of tolerances and flimsy guarantees from unmarked silicon that could be made in US, but is most likely a knock off made in China that will fail in 1&#x2F;3rd of the expected time and gives a false reading if you so much as look at it the wrong way.<p>[0] <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;1311_05-08_mickens.pdf" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;1311_05-08_mickens.pdf</a></div><br/><div id="41877525" class="c"><input type="checkbox" id="c-41877525" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#41876123">parent</a><span>|</span><a href="#41876437">next</a><span>|</span><label class="collapse" for="c-41877525">[-]</label><label class="expand" for="c-41877525">[1 more]</label></div><br/><div class="children"><div class="content">Plenty of people writing rust are coming from that background. And a substantial part of the reason for wanting it in linux is that the slapped-together C in linux drivers is often awful, both in terms of understanding of the hardware and in terms of the quality of the software. Rust can at least help the poor quality of the latter not affect the security and stability of the kernel so much.</div><br/></div></div><div id="41876437" class="c"><input type="checkbox" id="c-41876437" checked=""/><div class="controls bullet"><span class="by">sureglymop</span><span>|</span><a href="#41876123">parent</a><span>|</span><a href="#41877525">prev</a><span>|</span><a href="#41876508">next</a><span>|</span><label class="collapse" for="c-41876437">[-]</label><label class="expand" for="c-41876437">[1 more]</label></div><br/><div class="children"><div class="content">You can do that in rust. Yes, you probably will have unsafe blocks. You can even write &quot;C like&quot; rust code that has a bunch of unsafe blocks but you&#x27;ll benefit from better tooling. But maybe I misunderstand the article and there is somehow an implication that unsafe blocks are bad?<p>When I was doing some embedded development using rust it was actually a great experience, with hal and pac crates available already for a lot of hardware or easy to generate.</div><br/></div></div><div id="41876508" class="c"><input type="checkbox" id="c-41876508" checked=""/><div class="controls bullet"><span class="by">jendjdndn</span><span>|</span><a href="#41876123">parent</a><span>|</span><a href="#41876437">prev</a><span>|</span><label class="collapse" for="c-41876508">[-]</label><label class="expand" for="c-41876508">[5 more]</label></div><br/><div class="children"><div class="content">You sound a lot like &quot;kids these days!&quot;<p>What applicable skills would someone writing a kernel driver gain from reciting a memory map? Abstractions exist for a reason.<p>The skill is in creating useful an performant abstractions.</div><br/><div id="41876670" class="c"><input type="checkbox" id="c-41876670" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41876123">root</a><span>|</span><a href="#41876508">parent</a><span>|</span><a href="#41877153">next</a><span>|</span><label class="collapse" for="c-41876670">[-]</label><label class="expand" for="c-41876670">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You sound a lot like &quot;kids these days!&quot;<p>Exactly!  Kids like stonethrowaway with their C.  Real engineers write their compilers in assembly.<p>(Less snarky, why stop at C, and not complain about even lower level stuff?)</div><br/><div id="41876725" class="c"><input type="checkbox" id="c-41876725" checked=""/><div class="controls bullet"><span class="by">stonethrowaway</span><span>|</span><a href="#41876123">root</a><span>|</span><a href="#41876670">parent</a><span>|</span><a href="#41877153">next</a><span>|</span><label class="collapse" for="c-41876725">[-]</label><label class="expand" for="c-41876725">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Real engineers write their compilers in assembly.<p>Not sure where this misconception comes from. The engineering department mostly relies on Verilog twiddling, shoddy Spice models, debugging prototype boards with poorly crimped jumper wires, charged capacitors scattered around with no adults in the room, and freshly minted junior EEs who forget spice models and Verilog hacks aren’t the real thing.<p>You have the wrong department. Software development is down the hall to the left. Those folks down there don’t even have an engineering degree.</div><br/><div id="41877038" class="c"><input type="checkbox" id="c-41877038" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41876123">root</a><span>|</span><a href="#41876725">parent</a><span>|</span><a href="#41877153">next</a><span>|</span><label class="collapse" for="c-41877038">[-]</label><label class="expand" for="c-41877038">[1 more]</label></div><br/><div class="children"><div class="content">In any case, you might like <a href="https:&#x2F;&#x2F;docs.rust-embedded.org&#x2F;book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rust-embedded.org&#x2F;book&#x2F;</a><p>I&#x27;ve recently done a bit of work on Rust in something like embedded systems.  Only instead of real hardware, we are running our software on Zero Knowledge VMs, ie on math.</div><br/></div></div></div></div></div></div><div id="41877153" class="c"><input type="checkbox" id="c-41877153" checked=""/><div class="controls bullet"><span class="by">exmadscientist</span><span>|</span><a href="#41876123">root</a><span>|</span><a href="#41876508">parent</a><span>|</span><a href="#41876670">prev</a><span>|</span><label class="collapse" for="c-41877153">[-]</label><label class="expand" for="c-41877153">[1 more]</label></div><br/><div class="children"><div class="content">See, I read the parent post&#x27;s point not as &quot;abstractions are bad&quot; but as &quot;it&#x27;s much better to be someone who doesn&#x27;t <i>need</i> the abstraction, but <i>chooses</i> to use it&quot;.  I have worked with a number of crappy embedded developers in my career. Somehow, the ones who are capable of going beneath the many levels of abstraction are always really, really good at their jobs.<p>So it&#x27;s not that embedded Rust is bad. It&#x27;s that developers who can&#x27;t do their jobs without embedded Rust are usually very bad indeed. It&#x27;s great when it&#x27;s a choice. It&#x27;s terrible when you lack the skills or perspective to work with what&#x27;s under the hood.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>