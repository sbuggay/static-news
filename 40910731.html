<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720774863287" as="style"/><link rel="stylesheet" href="styles.css?v=1720774863287"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dizzy.zone/2024/01/26/Enums-in-Go/">Enums in Go</a> <span class="domain">(<a href="https://dizzy.zone">dizzy.zone</a>)</span></div><div class="subtext"><span>dizzyVik</span> | <span>18 comments</span></div><br/><div><div id="40943861" class="c"><input type="checkbox" id="c-40943861" checked=""/><div class="controls bullet"><span class="by">weavie</span><span>|</span><a href="#40943734">next</a><span>|</span><label class="collapse" for="c-40943861">[-]</label><label class="expand" for="c-40943861">[1 more]</label></div><br/><div class="children"><div class="content">The problem isn&#x27;t so much the lack of enums, it&#x27;s more that there is no way to do exhaustive pattern matching at compile time. I have seen production systems go down because someone added a variant to an &#x27;enum&#x27; but failed to handle that new variant everywhere.</div><br/></div></div><div id="40943734" class="c"><input type="checkbox" id="c-40943734" checked=""/><div class="controls bullet"><span class="by">barnabee</span><span>|</span><a href="#40943861">prev</a><span>|</span><a href="#40943843">next</a><span>|</span><label class="collapse" for="c-40943734">[-]</label><label class="expand" for="c-40943734">[1 more]</label></div><br/><div class="children"><div class="content">I’ve found the enumer [0] library does the job of generating usable helpers without too much pain or any obvious downsides. The ability to generate JSON [un]marshallers is particularly handy.<p>Still, the lack of enums and enum&#x2F;sum types remains by far my biggest gripe about Go.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;dmarkham&#x2F;enumer">https:&#x2F;&#x2F;github.com&#x2F;dmarkham&#x2F;enumer</a></div><br/></div></div><div id="40943843" class="c"><input type="checkbox" id="c-40943843" checked=""/><div class="controls bullet"><span class="by">nikolayasdf123</span><span>|</span><a href="#40943734">prev</a><span>|</span><a href="#40943697">next</a><span>|</span><label class="collapse" for="c-40943843">[-]</label><label class="expand" for="c-40943843">[1 more]</label></div><br/><div class="children"><div class="content">+1. Here is another alternative. I find this generator more lightweight and better syntax (generated benchmarks and tests are also nice):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nikolaydubina&#x2F;go-enum-encoding">https:&#x2F;&#x2F;github.com&#x2F;nikolaydubina&#x2F;go-enum-encoding</a></div><br/></div></div><div id="40943697" class="c"><input type="checkbox" id="c-40943697" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#40943843">prev</a><span>|</span><a href="#40943551">next</a><span>|</span><label class="collapse" for="c-40943697">[-]</label><label class="expand" for="c-40943697">[1 more]</label></div><br/><div class="children"><div class="content">I recently wrote a little tokenizer in Go.<p>The data structure for a token that makes most intuitive sense to me is a tagged union.<p>So I defined an „const iota“-style enum. Stuck it into a struct that has the appropriate fields to cover all the cases and it was fine.<p>Having some syntax sugar for tagged unions would be nice. Having exhaustiveness checks if you switch over them, could be useful in some cases.<p>But that’s not where my mental energy went at all.<p>Reading the bytes (runes) efficiently and correctly into the data structure however is the part that needs focus. Once the data is in shape, I‘m not „worried“ at all anymore. Sure a bit of extra support is nice, but also kind of superficial.<p>Also going further, dispatching on them is again never the tricky part. It’s handling the cases correctly and efficiently that has my focus.<p>In Clojure, a common thing is to write multimethods that dispatch on (namespaced) keywords. Similar in spirit and structure, but each method might now reside in a different namespace or not even be written by you. But I have never worried about exhaustive matching or similar. What’s in the method bodies is the important part.</div><br/></div></div><div id="40943551" class="c"><input type="checkbox" id="c-40943551" checked=""/><div class="controls bullet"><span class="by">daghamm</span><span>|</span><a href="#40943697">prev</a><span>|</span><a href="#40943624">next</a><span>|</span><label class="collapse" for="c-40943551">[-]</label><label class="expand" for="c-40943551">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m implementing a somewhat complex software in both Go and Rust.<p>The Rust version is bith shorter and more readable - and probably more efficient - thanks to Rust enums and Rust error handling. I don&#x27;t understand why golang doesn&#x27;t copy Rust here. The error handling in particular could be a very simple change.<p>I am not a huge fan of go:generate and similar projects. They add a level of unknown that goes against the core Golang design values.</div><br/></div></div><div id="40943624" class="c"><input type="checkbox" id="c-40943624" checked=""/><div class="controls bullet"><span class="by">altug</span><span>|</span><a href="#40943551">prev</a><span>|</span><a href="#40943679">next</a><span>|</span><label class="collapse" for="c-40943624">[-]</label><label class="expand" for="c-40943624">[1 more]</label></div><br/><div class="children"><div class="content">I really miss value enums from Rust while working with Go, but overall I find Go more intuitive. Didn&#x27;t know there was a way of auto-generating with stringer, so thanks for the information!</div><br/></div></div><div id="40943679" class="c"><input type="checkbox" id="c-40943679" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40943624">prev</a><span>|</span><a href="#40943369">next</a><span>|</span><label class="collapse" for="c-40943679">[-]</label><label class="expand" for="c-40943679">[3 more]</label></div><br/><div class="children"><div class="content">Use a slice of strings?<p><pre><code>    type Color int
    const (
        Red Color = iota
        Green
        Blue
    )

    var Colors = []string{ &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot; }
</code></pre>
Now (Colors[Red] == &quot;Red&quot;) and (slices.Index(Colors, &quot;Green&quot;) == Green).</div><br/><div id="40943820" class="c"><input type="checkbox" id="c-40943820" checked=""/><div class="controls bullet"><span class="by">JyB</span><span>|</span><a href="#40943679">parent</a><span>|</span><a href="#40943772">next</a><span>|</span><label class="collapse" for="c-40943820">[-]</label><label class="expand" for="c-40943820">[1 more]</label></div><br/><div class="children"><div class="content">Compile-time safety is not achieved which is the point.</div><br/></div></div><div id="40943772" class="c"><input type="checkbox" id="c-40943772" checked=""/><div class="controls bullet"><span class="by">slekker</span><span>|</span><a href="#40943679">parent</a><span>|</span><a href="#40943820">prev</a><span>|</span><a href="#40943369">next</a><span>|</span><label class="collapse" for="c-40943772">[-]</label><label class="expand" for="c-40943772">[1 more]</label></div><br/><div class="children"><div class="content">You could do the same with a map[Color]struct{} and the lookup would be &quot;if _, ok := Colors[Green]; ok {&quot;</div><br/></div></div></div></div><div id="40943369" class="c"><input type="checkbox" id="c-40943369" checked=""/><div class="controls bullet"><span class="by">asabla</span><span>|</span><a href="#40943679">prev</a><span>|</span><a href="#40943520">next</a><span>|</span><label class="collapse" for="c-40943369">[-]</label><label class="expand" for="c-40943369">[7 more]</label></div><br/><div class="children"><div class="content">I wonder if go ever will get some sort of enum type? Or if int&#x2F;string based types will be the goto way?</div><br/><div id="40943422" class="c"><input type="checkbox" id="c-40943422" checked=""/><div class="controls bullet"><span class="by">stpedgwdgfhgdd</span><span>|</span><a href="#40943369">parent</a><span>|</span><a href="#40943520">next</a><span>|</span><label class="collapse" for="c-40943422">[-]</label><label class="expand" for="c-40943422">[6 more]</label></div><br/><div class="children"><div class="content">If there is one thing that I find missing is proper enum support in the Go language.<p>There are quite a few subtle caveats you can run into without proper support in the language like the article mentions. (E.g. Using iota, passing in an undefined enum)</div><br/><div id="40943438" class="c"><input type="checkbox" id="c-40943438" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#40943369">root</a><span>|</span><a href="#40943422">parent</a><span>|</span><a href="#40943520">next</a><span>|</span><label class="collapse" for="c-40943438">[-]</label><label class="expand" for="c-40943438">[5 more]</label></div><br/><div class="children"><div class="content">This might be a very simple and ignorant thought, but I&#x27;d be fine if they completely worked the same as Rust&#x27;s enum&#x27;s. [if let] is such a powerful feature, along with match arms.</div><br/><div id="40943559" class="c"><input type="checkbox" id="c-40943559" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40943369">root</a><span>|</span><a href="#40943438">parent</a><span>|</span><a href="#40943492">next</a><span>|</span><label class="collapse" for="c-40943559">[-]</label><label class="expand" for="c-40943559">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but &quot;the same as Rust&#x27;s enums&quot; including a mention of pattern matching, is a really big expenditure on the novelty budget from the point of view of Go. What Rust does there is perfectly normal... for an ML. But before Rust you didn&#x27;t really see an ML down there counting CPU cycles, so this wasn&#x27;t even on the radar when Go was invented.<p>I think to do that you&#x27;d probably give up a lot of the simplicity Go is aiming for. I personally think that simplicity is somewhat illusion (Amos&#x27; &quot;I want off Mr. Golang&#x27;s Wild Ride&quot; <a href="https:&#x2F;&#x2F;fasterthanli.me&#x2F;articles&#x2F;i-want-off-mr-golangs-wild-ride" rel="nofollow">https:&#x2F;&#x2F;fasterthanli.me&#x2F;articles&#x2F;i-want-off-mr-golangs-wild-...</a> says it better than I could) but we should be clear that it&#x27;s not that Go aimed to do what I want and missed but that it was never interested in that at all. An F1 car doesn&#x27;t <i>want</i> to be useful for taking the kids to school, so it&#x27;s silly if we&#x27;re scoring it poorly for lack of child seat fixtures.</div><br/></div></div><div id="40943492" class="c"><input type="checkbox" id="c-40943492" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#40943369">root</a><span>|</span><a href="#40943438">parent</a><span>|</span><a href="#40943559">prev</a><span>|</span><a href="#40943529">next</a><span>|</span><label class="collapse" for="c-40943492">[-]</label><label class="expand" for="c-40943492">[2 more]</label></div><br/><div class="children"><div class="content">That’s not an enumeration like the parent and grandparent are discussing (think of a collection of consts), that’s a tagged union you’re talking about. Confusing because rust used the name enum in their syntax for  this (Haskell calls it data - well, Haskell uses data in their syntax for both product and sum types).</div><br/><div id="40943648" class="c"><input type="checkbox" id="c-40943648" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40943369">root</a><span>|</span><a href="#40943492">parent</a><span>|</span><a href="#40943529">next</a><span>|</span><label class="collapse" for="c-40943648">[-]</label><label class="expand" for="c-40943648">[1 more]</label></div><br/><div class="children"><div class="content">What we&#x27;re discussing here is always an actual sum type though, it&#x27;s just a question of whether you&#x27;re interested in half-assing it, and Rust is not.<p>There are people who want C&#x27;s &quot;surprise it&#x27;s actually just an integer&quot; which lets them use C&#x27;s enums as bit flags, and that I agree isn&#x27;t just a sum type, but the fact that Rust will let you sum things which aren&#x27;t units isn&#x27;t that this is &quot;really&quot; a tagged union, that&#x27;s a possible implementation detail but not the core idea.<p>This is not C++ std::variant which really is just a tagged union. Option&lt;OwnedFd&gt; isn&#x27;t a tagged union, it&#x27;s &quot;just&quot; much nicer sugar for C&#x27;s signed integer type. Option&lt;&amp;str&gt; isn&#x27;t a tagged union it&#x27;s sugar for a fat pointer which can be null. And so on.</div><br/></div></div></div></div><div id="40943529" class="c"><input type="checkbox" id="c-40943529" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#40943369">root</a><span>|</span><a href="#40943438">parent</a><span>|</span><a href="#40943492">prev</a><span>|</span><a href="#40943520">next</a><span>|</span><label class="collapse" for="c-40943529">[-]</label><label class="expand" for="c-40943529">[1 more]</label></div><br/><div class="children"><div class="content">Rust got those basic type system and pattern matching things so incredibly right it’s not even funny. I even like Go more for other reasons but I still cringe every time I have to use the error prone hacks mentioned in this post. Not to mention the largest source of noise: `if err != nil`, which Rust solved so elegantly using partly their enum types.</div><br/></div></div></div></div></div></div></div></div><div id="40943520" class="c"><input type="checkbox" id="c-40943520" checked=""/><div class="controls bullet"><span class="by">techn00</span><span>|</span><a href="#40943369">prev</a><span>|</span><label class="collapse" for="c-40943520">[-]</label><label class="expand" for="c-40943520">[1 more]</label></div><br/><div class="children"><div class="content">I use <a href="https:&#x2F;&#x2F;github.com&#x2F;orsinium-labs&#x2F;enum">https:&#x2F;&#x2F;github.com&#x2F;orsinium-labs&#x2F;enum</a></div><br/></div></div></div></div></div></div></div></body></html>