<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710234066489" as="style"/><link rel="stylesheet" href="styles.css?v=1710234066489"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mark-burgess-oslo-mb.medium.com/using-promise-theory-to-solve-the-distributed-consensus-problem-4cc2116f24e1">Using Promise Theory to solve the distributed consensus problem</a> <span class="domain">(<a href="https://mark-burgess-oslo-mb.medium.com">mark-burgess-oslo-mb.medium.com</a>)</span></div><div class="subtext"><span>andras_gerlits</span> | <span>3 comments</span></div><br/><div><div id="39677279" class="c"><input type="checkbox" id="c-39677279" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#39676494">next</a><span>|</span><label class="collapse" for="c-39677279">[-]</label><label class="expand" for="c-39677279">[1 more]</label></div><br/><div class="children"><div class="content">As far as I can read into it, this is 95% metaphor and 5% &quot;use a master database but call it a distributed system&quot;.<p>&gt; What replica sets using Paxos and Raft propose is that you will literally deal with one master server and try to keep backup copies of an entire database aligned independently. When a master dies or fails, the clients try to decide on a new leader so that they are all talking to the same server. This leads to a delay in which no one can write.<p>No comment on Raft, but &quot;a master&quot; only exists in Paxos if you invent one.  Any client can talk to any Proposer (which will then try to reach a <i>quorum</i> of Acceptors &amp; Learners).  Losing just one Paxos node will not result in a partition, so you can still operate happily with availability and consistency.<p>&gt; There&#x27;s no particular need to replicate a whole database if we only want to share a few records. Granularity is the answer to scalability and reliability.<p>Lots of data, lots of CAP tradeoff.  Not much data, not much CAP tradeoff.<p>&gt; In IT, correct values are assumed to be the latest values. It’s a race to be last, because the last value wins by overwriting and obliterating what came before. So if you have an evil demon flooding the system with nonsense, you’re in trouble.<p>Paxos itself does not allow for overwriting of values (Learners do not change their mind about the value of a given key.)  In order for &#x27;obliteration&#x27; to occur, you need to augment your key with a version number or timestamp - something that a downstream system could interpret to mean as &quot;happened after&quot;.</div><br/></div></div><div id="39676494" class="c"><input type="checkbox" id="c-39676494" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39677279">prev</a><span>|</span><label class="collapse" for="c-39676494">[-]</label><label class="expand" for="c-39676494">[1 more]</label></div><br/><div class="children"><div class="content">How to decentralise and scale distributed consistency beyond the commonly accepted limits</div><br/></div></div></div></div></div></div></div></body></html>