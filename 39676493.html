<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710320462169" as="style"/><link rel="stylesheet" href="styles.css?v=1710320462169"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mark-burgess-oslo-mb.medium.com/using-promise-theory-to-solve-the-distributed-consensus-problem-4cc2116f24e1">Using Promise Theory to solve the distributed consensus problem</a> <span class="domain">(<a href="https://mark-burgess-oslo-mb.medium.com">mark-burgess-oslo-mb.medium.com</a>)</span></div><div class="subtext"><span>andras_gerlits</span> | <span>33 comments</span></div><br/><div><div id="39678591" class="c"><input type="checkbox" id="c-39678591" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39677279">next</a><span>|</span><label class="collapse" for="c-39678591">[-]</label><label class="expand" for="c-39678591">[10 more]</label></div><br/><div class="children"><div class="content">This post never actually delivers on its claims.  What about CAP or FLP does this resolve in a new way?<p>The author, additionally, seems to not be well-versed in the existing distributed database literature.<p>Essentially they have added a queue in-front of all database operations.  That queue is totally ordered, so you can&#x27;t have consistent issues.  That queue apparently does all operations via a two-phase commit (without calling it that and being unclear on semantics, so I am not 100% sure).<p>Ok.  So you&#x27;ve moved the question of availability and consistency to your queue.  Is that a single queue?  If so, then it&#x27;s a liability.  Why not just use a single database at that point.  Is it multiple queues?  Then you still have a consensus problem to solve.  Are you using two-phase commit?  Well, now your availability is seriously impacted.<p>There is nothing there.<p>It&#x27;s a shame because there are models that are much more interesting that provide a useful mental model for this.  PACELC is my favorite.  The essence is that when everything is going fine, your decision is around latency and consistency.  When there is a partition, your question is between availability and consistency.</div><br/><div id="39688573" class="c"><input type="checkbox" id="c-39688573" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#39678591">parent</a><span>|</span><a href="#39679408">next</a><span>|</span><label class="collapse" for="c-39688573">[-]</label><label class="expand" for="c-39688573">[1 more]</label></div><br/><div class="children"><div class="content">Near as I can tell this system&#x2F;paper&#x2F;post thing is a hybrid between a database proxy and an (allegedly) strictly serializable log tailer sitting squarely at “CP” in conventional nomenclature, e.g.<p><a href="https:&#x2F;&#x2F;mark-burgess-oslo-mb.medium.com&#x2F;using-promise-theory-to-solve-the-distributed-consensus-problem-4cc2116f24e1" rel="nofollow">https:&#x2F;&#x2F;mark-burgess-oslo-mb.medium.com&#x2F;using-promise-theory...</a><p>I haven’t done heavyweight distributed systems theory in a few years, and so who knows, maybe @aphyr shows up and Jepsen-stamps this thing, but after reading the paper and going over the commercial website personally I’m a pass. I’m one of about a zillion people on HN who have dealt in petabyte and trillion event days on logs as mundane subsystems for years on end and it’s just almost always: “there’s the lock, didn’t see it right away because of the bespoke nomenclature”.<p>History is replete with misunderstood geniuses who weren’t appreciated because they were so far ahead of everyone else (Galois is my favorite example personally), and we might all end up eating crow over it, but this has a wink and a grin vibe that I’m going to regard as great satire rather than hyperventilating. I suspect the object of the satire would be blockchain.</div><br/></div></div><div id="39679408" class="c"><input type="checkbox" id="c-39679408" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39678591">parent</a><span>|</span><a href="#39688573">prev</a><span>|</span><a href="#39677279">next</a><span>|</span><label class="collapse" for="c-39679408">[-]</label><label class="expand" for="c-39679408">[8 more]</label></div><br/><div class="children"><div class="content">PACELC is an extension of CAP, so it suffers from the same problem of trying to apply a universal clock to the whole system. If you do that, you will suffer these limitations. With client-centric consistency, you can work around these problems and global order &quot;unfolds&quot; in a &quot;just in time&quot; manner.<p>The consistency-levels can go all the way to SNAPSHOT.</div><br/><div id="39689092" class="c"><input type="checkbox" id="c-39689092" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#39678591">root</a><span>|</span><a href="#39679408">parent</a><span>|</span><a href="#39679607">next</a><span>|</span><label class="collapse" for="c-39689092">[-]</label><label class="expand" for="c-39689092">[1 more]</label></div><br/><div class="children"><div class="content">Ultimately the problem we care about is very simple, and there is no way to solve it, despite your claims.<p>Say we have a database of customers, with two replicas - one in the USA, one in Europe. Say a customer in Europe wants to update their shipping address. We ship products every month to this customer from the USA to their current shipping address, on the 10th of that month.<p>The customer is updating their address on the 9th at 10 AM PST. However, we are in the midst of a massive network partition that started on the 9th at 02 AM PST and is expected to last until the 11th.<p>Do we perform the update in the European replica and tell the customer it succeeded (giving up consistency)? If we do, the US side of the business will ship the products to the old address, even though the update happened a full day earlier.<p>Alternatively, do we tell the customer the update failed (giving up availability)? If we do, then the customer can&#x27;t even let the European side of the business know of their new address.<p>This is the CAP theorem in a nutshell, and it is obviously inescapable. It doesn&#x27;t require appeals to immediacy that are anywhere close to the bounds of relativity. And while 3-day long network partitions are quite rare, partitions that last for many hours are not.</div><br/></div></div><div id="39679607" class="c"><input type="checkbox" id="c-39679607" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39678591">root</a><span>|</span><a href="#39679408">parent</a><span>|</span><a href="#39689092">prev</a><span>|</span><a href="#39677279">next</a><span>|</span><label class="collapse" for="c-39679607">[-]</label><label class="expand" for="c-39679607">[6 more]</label></div><br/><div class="children"><div class="content">CAP says nothing about a &quot;universal clock over the whole system&quot;.  CAP is about the decision that has to be made in some unit of the system, it could be the whole system or it could be a bit, at the point of an operation.  It&#x27;s physics, there is no way around it.  You can make different decisions on the semantics your system needs, but if you have two nodes that physically cannot communicate but need to be consistent for a client to move forward, the client cannot move forward.  Full stop.<p>Could you please show a failure mode that this system can handle that CAP says is not possible?</div><br/><div id="39679635" class="c"><input type="checkbox" id="c-39679635" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39678591">root</a><span>|</span><a href="#39679607">parent</a><span>|</span><a href="#39677279">next</a><span>|</span><label class="collapse" for="c-39679635">[-]</label><label class="expand" for="c-39679635">[5 more]</label></div><br/><div class="children"><div class="content">Sure. Here:
<a href="https:&#x2F;&#x2F;medium.com&#x2F;p&#x2F;5e397cb12e63#04a5" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;p&#x2F;5e397cb12e63#04a5</a></div><br/><div id="39679726" class="c"><input type="checkbox" id="c-39679726" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39678591">root</a><span>|</span><a href="#39679635">parent</a><span>|</span><a href="#39677279">next</a><span>|</span><label class="collapse" for="c-39679726">[-]</label><label class="expand" for="c-39679726">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if you gave the wrong link or not but this link doesn&#x27;t describe any failure modes and how OmniLedger allegedly resolves them.</div><br/><div id="39679824" class="c"><input type="checkbox" id="c-39679824" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39678591">root</a><span>|</span><a href="#39679726">parent</a><span>|</span><a href="#39677279">next</a><span>|</span><label class="collapse" for="c-39679824">[-]</label><label class="expand" for="c-39679824">[3 more]</label></div><br/><div class="children"><div class="content">This section discusses some failure modes (the first one is about the failure of a specific node):
<a href="https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and-fulfil-the-promise-of-microservices-5e397cb12e63#373c" rel="nofollow">https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and...</a><p>This section discusses latency-spike mitigation (which is how Brewer defines CAP colloquially):
<a href="https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and-fulfil-the-promise-of-microservices-5e397cb12e63#7df1" rel="nofollow">https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and...</a><p>This section dissects the problem when trying to apply CAP to non-linearizable systems like SQL:
<a href="https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and-fulfil-the-promise-of-microservices-5e397cb12e63#04a5" rel="nofollow">https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and...</a><p>Again, if you&#x27;re not happy with the lack of scientific rigour in this technical article (ie: not science-paper), you can connect the dots in this one:
<a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;359578461_Continuous_Integration_of_Data_Histories_into_Consistent_Namespaces" rel="nofollow">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;359578461_Continuou...</a></div><br/><div id="39689293" class="c"><input type="checkbox" id="c-39689293" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#39678591">root</a><span>|</span><a href="#39679824">parent</a><span>|</span><a href="#39680453">next</a><span>|</span><label class="collapse" for="c-39689293">[-]</label><label class="expand" for="c-39689293">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; if you have two nodes that physically cannot communicate but need to be consistent for a client to move forward, the client cannot move forward. Full stop.<p>&gt; This section discusses some failure modes (the first one is about the failure of a specific node): <a href="https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and" rel="nofollow">https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and</a>...<p>&gt; In this setup, a copy of the node is replaceable by taking a (potentially days old) backup copy of it and replaying the events that happened since the time the backup was established.<p>The replaced node does NOT have access to the events that happened <i>after the partition</i>.<p>* If the replaced node serves up stale data anyway, you built an AP system.<p>* If the replaced node refuses to serve up stale data, you built a CP system.<p>* If you&#x27;re pretending it has access to the latest events, there&#x27;s no partition and you built a CA system.</div><br/></div></div><div id="39680453" class="c"><input type="checkbox" id="c-39680453" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39678591">root</a><span>|</span><a href="#39679824">parent</a><span>|</span><a href="#39689293">prev</a><span>|</span><a href="#39677279">next</a><span>|</span><label class="collapse" for="c-39680453">[-]</label><label class="expand" for="c-39680453">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve read all this and I saw no description of failure modes and operationally how they are resolved.  &quot;If a node disappears just replace it with a new one&quot;.  Ok, how?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39677279" class="c"><input type="checkbox" id="c-39677279" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#39678591">prev</a><span>|</span><a href="#39688891">next</a><span>|</span><label class="collapse" for="c-39677279">[-]</label><label class="expand" for="c-39677279">[4 more]</label></div><br/><div class="children"><div class="content">As far as I can read into it, this is 95% metaphor and 5% &quot;use a master database but call it a distributed system&quot;.<p>&gt; What replica sets using Paxos and Raft propose is that you will literally deal with one master server and try to keep backup copies of an entire database aligned independently. When a master dies or fails, the clients try to decide on a new leader so that they are all talking to the same server. This leads to a delay in which no one can write.<p>No comment on Raft, but &quot;a master&quot; only exists in Paxos if you invent one.  Any client can talk to any Proposer (which will then try to reach a <i>quorum</i> of Acceptors &amp; Learners).  Losing just one Paxos node will not result in a partition, so you can still operate happily with availability and consistency.<p>&gt; There&#x27;s no particular need to replicate a whole database if we only want to share a few records. Granularity is the answer to scalability and reliability.<p>Lots of data, lots of CAP tradeoff.  Not much data, not much CAP tradeoff.<p>&gt; In IT, correct values are assumed to be the latest values. It’s a race to be last, because the last value wins by overwriting and obliterating what came before. So if you have an evil demon flooding the system with nonsense, you’re in trouble.<p>Paxos itself does not allow for overwriting of values (Learners do not change their mind about the value of a given key.)  In order for &#x27;obliteration&#x27; to occur, you need to augment your key with a version number or timestamp - something that a downstream system could interpret to mean as &quot;happened after&quot;.</div><br/><div id="39679350" class="c"><input type="checkbox" id="c-39679350" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39677279">parent</a><span>|</span><a href="#39688891">next</a><span>|</span><label class="collapse" for="c-39679350">[-]</label><label class="expand" for="c-39679350">[3 more]</label></div><br/><div class="children"><div class="content">The CAP argument falls apart as soon as you decouple consistency from wall-clocks. Consistent systems only suffer from CAP limitations if they need strict serializability.<p>The point is that if you only look at the order of the data and not the wall-clock of some actor in the system, you can &quot;calibrate&quot; these separate ordering mechanisms together into a coherent whole and from that, you can build up all of the SQL guarantees.<p>Linearizability makes systems suffer because it tries to enforce a Newtonian model in a relativistic world. Order will naturally emerge faster when you&#x27;re closer to the data than if you&#x27;re farther. Measuring these with the same clock is what causes CAP, not some inherent property of distributed consistency.</div><br/><div id="39684668" class="c"><input type="checkbox" id="c-39684668" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#39677279">root</a><span>|</span><a href="#39679350">parent</a><span>|</span><a href="#39683058">next</a><span>|</span><label class="collapse" for="c-39684668">[-]</label><label class="expand" for="c-39684668">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The CAP argument falls apart as soon as you decouple consistency from wall-clocks<p>Hogwash<p>Five friends are seated at a restaurant, about to agree on a flavour of pizza via a simple majority quorum.  Before they do so, the three girls excuse themselves to the restroom while the two boys remain at the table.  The waiter arrives and asks what flavour pizza they&#x27;ll have.<p>Do the two boys answer on behalf of all five friends, or do they wait for the girls to return?<p>No-one checked their own watch.</div><br/></div></div><div id="39683058" class="c"><input type="checkbox" id="c-39683058" checked=""/><div class="controls bullet"><span class="by">heavenlyblue</span><span>|</span><a href="#39677279">root</a><span>|</span><a href="#39679350">parent</a><span>|</span><a href="#39684668">prev</a><span>|</span><a href="#39688891">next</a><span>|</span><label class="collapse" for="c-39683058">[-]</label><label class="expand" for="c-39683058">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s 0 relativity involved in distributed databases</div><br/></div></div></div></div></div></div><div id="39688891" class="c"><input type="checkbox" id="c-39688891" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#39677279">prev</a><span>|</span><a href="#39677918">next</a><span>|</span><label class="collapse" for="c-39688891">[-]</label><label class="expand" for="c-39688891">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried to follow this blog post, but when it gets to the nitty gritty of the solution, it seems self-contradictory. There are constant claims that this presents a solution to have all three items of CAP - exciting. But then the solution seems to only have consistency.<p>First, there is no Availability, because the solution requires a centralized Interloper service. There is some handwaving that the Interloper is distributed, but all of the arguments about maintaining the three databases consistent with each other only work if the Interloper can be assumed to have (distributed) consistency. Which is of course obvious - if you&#x27;ve solved distributed consistency, you can use it to make other things consistent. But this doesn&#x27;t explain how to solve distributed consistency in the slightest.<p>Secondly, the described system doesn&#x27;t actually offer partition tolerance:<p>&gt; If one of the databases becomes unavailable (e.g. if it loses power or its network connection creating a “partition”) no harmful misalignment can be observed by any client, because the interloper disallows reads until everything is reported to be back in sync.<p>So if one database goes down&#x2F;is disconnected, the whole system grinds to a halt. So, no partition tolerance.<p>The paper has a different problem. It seems you are redefining the notion of consistency because you don&#x27;t like the definition used in the CAP theorem. But you don&#x27;t actually disagree that no system can display what the CAP theorem calls &quot;consistency&quot; at the same time as availability and partition tolerance, you just don&#x27;t think it&#x27;s necessary. This is a defensible position (and one often taken by many distributed databases), but there is no reason to undermine others&#x27; work instead of simply saying so.<p>As more of a side note, the paper you wrote keeps referring to the CAP theorem as a conjecture, but it has in fact been formally proven in 2002 by Gilbert and Lynch. You don&#x27;t seem to have a refutation of their proof, which you don&#x27;t even cite.</div><br/></div></div><div id="39677918" class="c"><input type="checkbox" id="c-39677918" checked=""/><div class="controls bullet"><span class="by">danbruc</span><span>|</span><a href="#39688891">prev</a><span>|</span><a href="#39679912">next</a><span>|</span><label class="collapse" for="c-39677918">[-]</label><label class="expand" for="c-39677918">[3 more]</label></div><br/><div class="children"><div class="content">Compared to the mathematical rigor that gets usually thrown at such problems, this is all pretty vague, but maybe this is just the informal version. I admittedly did not completely understand the idea, but I of course have thoughts about it.<p><i>Instead of “equality at all times” we should be asking “alignment whenever someone actually looks”, because this is all we can promise about someone else’s state.</i><p>It seems to me that we generally do not know when and where someone will look, so we will still have to be consistent at all times and all places because all times and all places is when and where someone could look. If the idea is to delay consensus from the write to reads, then I do not see how this makes things any easier. Instead of ensuring that everyone receives a write when it happens, you now have to ensure that you can gather all the writes that happened when a read occurs.</div><br/><div id="39679366" class="c"><input type="checkbox" id="c-39679366" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39677918">parent</a><span>|</span><a href="#39679912">next</a><span>|</span><label class="collapse" for="c-39679366">[-]</label><label class="expand" for="c-39679366">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I ever heard people accuse our paper of not being rigorous enough, but more than happy to listen to specific problems with it:
<a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;359578461_Continuous_Integration_of_Data_Histories_into_Consistent_Namespaces" rel="nofollow">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;359578461_Continuou...</a></div><br/><div id="39686859" class="c"><input type="checkbox" id="c-39686859" checked=""/><div class="controls bullet"><span class="by">danbruc</span><span>|</span><a href="#39677918">root</a><span>|</span><a href="#39679366">parent</a><span>|</span><a href="#39679912">next</a><span>|</span><label class="collapse" for="c-39686859">[-]</label><label class="expand" for="c-39686859">[1 more]</label></div><br/><div class="children"><div class="content">I completely read the first half of it, hoping that everything would eventually make sense, that the pieces would fall into place, but that never happened. I only skimmed the second half and everything seems to just become more and more incoherent. There are some recognizable underlying themes but nothing of it makes really any sense. If I would have to guess, I would guess that ChatGPT generated that gibberish. For large section I could at least imagine that the ideas are just way over my head, especially since I have never heard anything about promise theory and did not read the references. But page 16 really convinced me, that it all is just nonsense - how on earth do we suddenly and out of nowhere end up with differentials, Fourier series, and Heisenberg&#x27;s uncertainty relation? And while the paper superficially looks sophisticated and scientific with all the symbols and notation, there is no substance behind it. The symbols are really only used for providing short labels for all kinds of things but they are [essentially] never used to relate anythings, let alone to derive or prove something.</div><br/></div></div></div></div></div></div><div id="39679912" class="c"><input type="checkbox" id="c-39679912" checked=""/><div class="controls bullet"><span class="by">dustingetz</span><span>|</span><a href="#39677918">prev</a><span>|</span><a href="#39679265">next</a><span>|</span><label class="collapse" for="c-39679912">[-]</label><label class="expand" for="c-39679912">[2 more]</label></div><br/><div class="children"><div class="content">As I understand it, Omniledger retrofits highly available multi-master writes, across your existing SQL tables on existing databases, in a way that is transparent to application devs, by intercepting JDBC API calls. This approach of intercepting JDBC calls allows an enterprise to unify 100s of siloed SQL instances across the enterprise into a single globally consistent enterpriser view, without changing any application, simply by intercepting JDBC. To do this without requiring all txns to go through a single master authority, which would obviously be too slow, with OmniLedger the sysadmin must supply a configuration that maps a single authority (i.e. single database), for each topic (i.e. table). Therefore, &quot;wide&quot; transactions (e.g. &quot;change email for user&quot;, where user table is repeated 100s of times for each database in your enterprise) may need to coordinate with many databases before committing and the txn will be delayed as it negotiates with the user table authority (which OmniLedger coordinates transparently to the application via JDBC interception). And &quot;narrow&quot; transactions, say to a single application-specific topic&#x2F;table, are routed to that single authority, which is likely co-located with the application, giving local performance for this narrow transaction (i.e. no routing it through a central master db). The difference between this and say Spanner, is that you don&#x27;t have to <i>migrate&#x2F;rewrite your entire enterprise of applications to integrate Spanner</i> – OmniLedger intercepts the JDBC calls your applications are already making, with no application source code changes needed!!<p>Source: I&#x27;ve met with the founder. Andras, how did I do?</div><br/><div id="39680029" class="c"><input type="checkbox" id="c-39680029" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39679912">parent</a><span>|</span><a href="#39679265">next</a><span>|</span><label class="collapse" for="c-39680029">[-]</label><label class="expand" for="c-39680029">[1 more]</label></div><br/><div class="children"><div class="content">Almost there Dustin, thank you. This article is about the mental model behind scaling consistency across arbitrary geographical distances and how this model allows us to communicate time-information the same way we now communicate data. It&#x27;s an intro to the science-paper, not the implementation.<p>With regards to the implementation (which is omniledger.io): We basically make SQL scale via Kafka by piggybacking on the semantics of both technologies.<p>There&#x27;s no central authority for any of the tables. The version-ledger is totally schema-agnostic, only the clients understand it. In fact, it federates schemas the same way it does records. Tables are not topics either, in fact, we scale by importing namespaces via a command-line interface, which specifies a schema. Any database can register to this namespace after which they become as much of the &quot;master&quot; to the namespace as any other. There&#x27;s no hierarchy between them, the ledger does everything for them. Since the ledger itself is deterministically replicated, a separate instance of it can be co-located with each instance that runs the JDBC-connections to the database, raising availability of it to the availability of the whole system. Each component in the setup scales with the number of partitions created for it.</div><br/></div></div></div></div><div id="39679265" class="c"><input type="checkbox" id="c-39679265" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39679912">prev</a><span>|</span><a href="#39679169">next</a><span>|</span><label class="collapse" for="c-39679265">[-]</label><label class="expand" for="c-39679265">[7 more]</label></div><br/><div class="children"><div class="content">I also have a demo here where I show transactionality between two SQL-databases, a MySQL and a Postgres instance:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=XJSSjY4szZE" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=XJSSjY4szZE</a><p>And another, where I show loose coupling, ie: that the system continues even when an instance goes down and that it catches up once restarted.
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=R4_phLs4d_M" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=R4_phLs4d_M</a></div><br/><div id="39688961" class="c"><input type="checkbox" id="c-39688961" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#39679265">parent</a><span>|</span><a href="#39679686">next</a><span>|</span><label class="collapse" for="c-39688961">[-]</label><label class="expand" for="c-39688961">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I also have a demo here where I show transactionality between two SQL-databases<p>If you&#x27;re not constrained by CAP, I&#x27;d hardly expect you to be constrained by Two Generals either.<p>&gt; And another, where I show loose coupling, ie: that the system continues even when an instance goes down and that it catches up once restarted<p>I&#x27;ve built one of those, it&#x27;s fun!  But I digress.  Back to CAP.<p>1) How many instances do you have?<p>2) What is your quorum (simple majority?)<p>3) How many instances can go down before the system stops serving consumers?</div><br/></div></div><div id="39679686" class="c"><input type="checkbox" id="c-39679686" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39679265">parent</a><span>|</span><a href="#39688961">prev</a><span>|</span><a href="#39679169">next</a><span>|</span><label class="collapse" for="c-39679686">[-]</label><label class="expand" for="c-39679686">[5 more]</label></div><br/><div class="children"><div class="content">No-one doubts if you put a message queue in front of your database, you can do what these videos show.  The doubt is if this says anything interesting about distributed systems.  At least these videos don&#x27;t demonstrate that.</div><br/><div id="39679769" class="c"><input type="checkbox" id="c-39679769" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39679265">root</a><span>|</span><a href="#39679686">parent</a><span>|</span><a href="#39679169">next</a><span>|</span><label class="collapse" for="c-39679769">[-]</label><label class="expand" for="c-39679769">[4 more]</label></div><br/><div class="children"><div class="content">Sure, there are other ways of doing this, the demos don&#x27;t prove what I say, they only show that the theory works on a practical level. The science-paper however, does show how this mechanism can scale consistency.<p>Think about it this way: Our system simplifies running inter-system consistency and makes it much faster. Considering that Spanner exists, what proof would you accept to validate our claims?<p>I understand that reading all the material and putting them together isn&#x27;t a small ask, but no new tech is easy to understand at first. Anyway, the material is there for anyone who cares to look and the system does what we claim it does.<p>I don&#x27;t think anyone owes us their time to check our claims, but I don&#x27;t think the fact that not lot of people will do this changes anything either.</div><br/><div id="39682067" class="c"><input type="checkbox" id="c-39682067" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39679265">root</a><span>|</span><a href="#39679769">parent</a><span>|</span><a href="#39679169">next</a><span>|</span><label class="collapse" for="c-39682067">[-]</label><label class="expand" for="c-39682067">[3 more]</label></div><br/><div class="children"><div class="content">We already know this technique works, it&#x27;s how any asynchronous database replication is implemented.<p>I&#x27;ve read all of your content and I can see nothing even close to, for example, the Spanner or Amazon Dynamo paper which go through the operation details of how the systems work.  Literally your articles are just a bunch of metaphors followed by hand waving.  No operational details.<p>I don&#x27;t know if you know you&#x27;re selling snake oil or just don&#x27;t understand what you&#x27;re implementing, but even in this thread you&#x27;ve gotten plenty of feedback that how you describe what you&#x27;re doing is not coherent, you might want to address that.  Or not, I don&#x27;t know, if you&#x27;re selling like hot cakes then keep doing it.</div><br/><div id="39682546" class="c"><input type="checkbox" id="c-39682546" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39679265">root</a><span>|</span><a href="#39682067">parent</a><span>|</span><a href="#39679169">next</a><span>|</span><label class="collapse" for="c-39682546">[-]</label><label class="expand" for="c-39682546">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s fine to not understand things. Being condescending is a natural reaction to feeling challenged, I really do understand where you&#x27;re coming from. It&#x27;s not even your fault, really. Anyway, when you&#x27;re ready, feel free to pick it up again, the material doesn&#x27;t take things personally and neither do I.</div><br/><div id="39684467" class="c"><input type="checkbox" id="c-39684467" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39679265">root</a><span>|</span><a href="#39682546">parent</a><span>|</span><a href="#39679169">next</a><span>|</span><label class="collapse" for="c-39684467">[-]</label><label class="expand" for="c-39684467">[1 more]</label></div><br/><div class="children"><div class="content">Or I guess just not responding to any of the technical questions that have been brought to you.  That&#x27;s an option too.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39679169" class="c"><input type="checkbox" id="c-39679169" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39679265">prev</a><span>|</span><a href="#39676494">next</a><span>|</span><label class="collapse" for="c-39679169">[-]</label><label class="expand" for="c-39679169">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s ironic that so many of you are missing the rigour, as that is exactly the thing that &quot;undoes&quot; the CAP arguments.<p>Anyway, if math is what you guys are missing, it&#x27;s in this science-paper linked in the article:
<a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;359578461_Continuous_Integration_of_Data_Histories_into_Consistent_Namespaces" rel="nofollow">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;359578461_Continuou...</a><p>This is a gentler intro to the concepts. You can also read my essay on why this setup works better than the often used semantics:
<a href="https:&#x2F;&#x2F;medium.com&#x2F;p&#x2F;5e397cb12e63" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;p&#x2F;5e397cb12e63</a><p>There&#x27;s a specific section at the end on why CAP only applies to a very specific subset of SQL databases.</div><br/><div id="39679562" class="c"><input type="checkbox" id="c-39679562" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39679169">parent</a><span>|</span><a href="#39676494">next</a><span>|</span><label class="collapse" for="c-39679562">[-]</label><label class="expand" for="c-39679562">[3 more]</label></div><br/><div class="children"><div class="content">Math isn&#x27;t what&#x27;s missing, but Mark&#x27;s post is just a bunch of metaphor and no rigor.  At the very least it could go over failure modes and shows how it alleviates them but other databases fail.</div><br/><div id="39679598" class="c"><input type="checkbox" id="c-39679598" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39679169">root</a><span>|</span><a href="#39679562">parent</a><span>|</span><a href="#39676494">next</a><span>|</span><label class="collapse" for="c-39679598">[-]</label><label class="expand" for="c-39679598">[2 more]</label></div><br/><div class="children"><div class="content">We do you one better. We show how all information can be made redundant via determinism and how that means you can supply multiple copies of them across parallel, redundant channels.<p>My essay talks about this in detail around the latency-mitigation section and the failure-modes part, but these are questions much closer to the actual implementation. Mark discusses the new mental model behind it, I talk about technology.<p><a href="https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and-fulfil-the-promise-of-microservices-5e397cb12e63#7df1" rel="nofollow">https:&#x2F;&#x2F;itnext.io&#x2F;how-simple-can-scale-your-sql-beat-cap-and...</a></div><br/><div id="39679751" class="c"><input type="checkbox" id="c-39679751" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39679169">root</a><span>|</span><a href="#39679598">parent</a><span>|</span><a href="#39676494">next</a><span>|</span><label class="collapse" for="c-39679751">[-]</label><label class="expand" for="c-39679751">[1 more]</label></div><br/><div class="children"><div class="content">This post has no rigor.  &quot;What happens if a node dies? Well another takes its place&quot;.  Ok, show me.  This is hand waving.</div><br/></div></div></div></div></div></div></div></div><div id="39676494" class="c"><input type="checkbox" id="c-39676494" checked=""/><div class="controls bullet"><span class="by">andras_gerlits</span><span>|</span><a href="#39679169">prev</a><span>|</span><label class="collapse" for="c-39676494">[-]</label><label class="expand" for="c-39676494">[1 more]</label></div><br/><div class="children"><div class="content">How to decentralise and scale distributed consistency beyond the commonly accepted limits</div><br/></div></div></div></div></div></div></div></body></html>