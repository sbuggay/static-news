<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716022854490" as="style"/><link rel="stylesheet" href="styles.css?v=1716022854490"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/google/wuffs">Wuffs: Wrangling Untrusted File Formats Safely</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>nequo</span> | <span>46 comments</span></div><br/><div><div id="40395593" class="c"><input type="checkbox" id="c-40395593" checked=""/><div class="controls bullet"><span class="by">Ono-Sendai</span><span>|</span><a href="#40394091">next</a><span>|</span><label class="collapse" for="c-40395593">[-]</label><label class="expand" for="c-40395593">[3 more]</label></div><br/><div class="children"><div class="content">Wuffs is great.  I use it in Substrata (<a href="https:&#x2F;&#x2F;substrata.info&#x2F;" rel="nofollow">https:&#x2F;&#x2F;substrata.info&#x2F;</a>) for loading PNGs.  It is both faster and safer than LibPNG.
It&#x27;s something around 2x faster than LibPNG in my tests (depending on the PNG file), see timings here: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;wuffs&#x2F;issues&#x2F;13#issuecomment-1732575707">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;wuffs&#x2F;issues&#x2F;13#issuecomment-17325...</a><p>So generally Wuffs is great and you should use it to decode your PNGs.  There are some downsides: not all of the obscure bit depths and formats that PNG supports are loaded as-is, some are converted to more standard formats.<p>Also the Wuffs documentation is a bit hard to understand.  It&#x27;s a litle bit of a mission getting PNG decoding working.  You can see my code for that here though: 
<a href="https:&#x2F;&#x2F;github.com&#x2F;glaretechnologies&#x2F;glare-core&#x2F;blob&#x2F;2c7174ca95c68bfc4cea982ec12ac60db0bfd61d&#x2F;graphics&#x2F;PNGDecoder.cpp#L175">https:&#x2F;&#x2F;github.com&#x2F;glaretechnologies&#x2F;glare-core&#x2F;blob&#x2F;2c7174c...</a></div><br/><div id="40396139" class="c"><input type="checkbox" id="c-40396139" checked=""/><div class="controls bullet"><span class="by">repsilat</span><span>|</span><a href="#40395593">parent</a><span>|</span><a href="#40396802">next</a><span>|</span><label class="collapse" for="c-40396139">[-]</label><label class="expand" for="c-40396139">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;mango&quot; lib [1] claims to be even faster for PNGs. Actively maintained but doesn&#x27;t have as much buzz, I think the devs haven&#x27;t advertised it as much on places like this.<p>Also, it has the funniest testimonials.<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;t0rakka&#x2F;mango">https:&#x2F;&#x2F;github.com&#x2F;t0rakka&#x2F;mango</a></div><br/></div></div><div id="40396802" class="c"><input type="checkbox" id="c-40396802" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#40395593">parent</a><span>|</span><a href="#40396139">prev</a><span>|</span><a href="#40394091">next</a><span>|</span><label class="collapse" for="c-40396802">[-]</label><label class="expand" for="c-40396802">[1 more]</label></div><br/><div class="children"><div class="content">Where does the extra speed come from?</div><br/></div></div></div></div><div id="40394091" class="c"><input type="checkbox" id="c-40394091" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40395593">prev</a><span>|</span><a href="#40394377">next</a><span>|</span><label class="collapse" for="c-40394091">[-]</label><label class="expand" for="c-40394091">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Wuffs the Language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26731305">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26731305</a> - April 2021 (75 comments)<p><i>Wuffs’ PNG image decoder</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26714831">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26714831</a> - April 2021 (138 comments)</div><br/></div></div><div id="40394377" class="c"><input type="checkbox" id="c-40394377" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40394091">prev</a><span>|</span><a href="#40397306">next</a><span>|</span><label class="collapse" for="c-40394377">[-]</label><label class="expand" for="c-40394377">[11 more]</label></div><br/><div class="children"><div class="content">This is one of my favorite attempts at better programming language safety, because it compiles down to C that can then be shipped like normal C, so you don&#x27;t get the ecosystem friction like with ex. Rust.</div><br/><div id="40394573" class="c"><input type="checkbox" id="c-40394573" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40394377">parent</a><span>|</span><a href="#40397217">next</a><span>|</span><label class="collapse" for="c-40394573">[-]</label><label class="expand" for="c-40394573">[9 more]</label></div><br/><div class="children"><div class="content">It’s an interesting idea for sure but it isn’t a general purpose language, so the problem domains it can solve is very very different vs what Rust is trying to do.</div><br/><div id="40394633" class="c"><input type="checkbox" id="c-40394633" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40394377">root</a><span>|</span><a href="#40394573">parent</a><span>|</span><a href="#40397217">next</a><span>|</span><label class="collapse" for="c-40394633">[-]</label><label class="expand" for="c-40394633">[8 more]</label></div><br/><div class="children"><div class="content">Nigel has said that emitting &quot;unsafe&quot; Rust is a reasonable thing for a hypothetical WUFFS 1.0 to be able to do as an alternative to C. As with good &quot;unsafe&quot; Rust written by humans WUFFS would know exactly why what it&#x27;s doing is fine, it&#x27;s just that the Rust compiler can&#x27;t necessarily see that, hence the need to label it &quot;unsafe&quot;.<p>Today C makes most sense given the WUFFS language is still in flux.<p>[Edited to fix a serious typo]</div><br/><div id="40394978" class="c"><input type="checkbox" id="c-40394978" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40394377">root</a><span>|</span><a href="#40394633">parent</a><span>|</span><a href="#40395012">next</a><span>|</span><label class="collapse" for="c-40394978">[-]</label><label class="expand" for="c-40394978">[4 more]</label></div><br/><div class="children"><div class="content">What would be the primary benefit of emitting Rust rather than C? Both would be considered safe (assuming Wuffs generates correct code), and Rust could access the C code via FFI. Is there something I’m missing?</div><br/><div id="40395156" class="c"><input type="checkbox" id="c-40395156" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40394377">root</a><span>|</span><a href="#40394978">parent</a><span>|</span><a href="#40395047">next</a><span>|</span><label class="collapse" for="c-40395156">[-]</label><label class="expand" for="c-40395156">[1 more]</label></div><br/><div class="children"><div class="content">I expect that the Rust emitted by a hypothetical future WUFFS transpiler would be <i>much</i> easier to just drop into an existing Rust project than some C via a C FFI.<p>It&#x27;s common for C libraries that do get wrapped today (e.g. openssl) to have a two phase wrapping, a -sys crate which turns the C into Rust C FFI and then another crate to turn the Rust C FFI into something actually palatable to ordinary people.</div><br/></div></div><div id="40395047" class="c"><input type="checkbox" id="c-40395047" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40394377">root</a><span>|</span><a href="#40394978">parent</a><span>|</span><a href="#40395156">prev</a><span>|</span><a href="#40396511">next</a><span>|</span><label class="collapse" for="c-40395047">[-]</label><label class="expand" for="c-40395047">[1 more]</label></div><br/><div class="children"><div class="content">Nominally it can safely elide bounds checks via unsafe that it has proved are actually safe within the constraints of Wuffs, which is what it does for C (+ the language is built for more easy translation to  vectorizated than something like llvm is able to do for general purpose languages).<p>So basically higher performance.<p>FFI nominally has a runtime and compile time cost - whether that matters for you in particular will depend on your needs, but being able to publish a very simple crate without a build.rs to manage can have an attraction.</div><br/></div></div><div id="40396511" class="c"><input type="checkbox" id="c-40396511" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40394377">root</a><span>|</span><a href="#40394978">parent</a><span>|</span><a href="#40395047">prev</a><span>|</span><a href="#40395012">next</a><span>|</span><label class="collapse" for="c-40396511">[-]</label><label class="expand" for="c-40396511">[1 more]</label></div><br/><div class="children"><div class="content">The C abstract machine is slightly funkier than unsafe Rust (things like C lacking a way to do signed integer overflow without UB or needing to adhere to strict aliasing in C), so I would expect that lowering to unsafe Rust would be slightly more likely to be correct.</div><br/></div></div></div></div><div id="40395012" class="c"><input type="checkbox" id="c-40395012" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40394377">root</a><span>|</span><a href="#40394633">parent</a><span>|</span><a href="#40394978">prev</a><span>|</span><a href="#40397217">next</a><span>|</span><label class="collapse" for="c-40395012">[-]</label><label class="expand" for="c-40395012">[3 more]</label></div><br/><div class="children"><div class="content">I’m responding to this:<p>&gt; that can then be shipped like normal C, so you don&#x27;t get the ecosystem friction like with ex. Rust.<p>Emitting Rust doesn’t help with this.</div><br/><div id="40395821" class="c"><input type="checkbox" id="c-40395821" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#40394377">root</a><span>|</span><a href="#40395012">parent</a><span>|</span><a href="#40397217">next</a><span>|</span><label class="collapse" for="c-40395821">[-]</label><label class="expand" for="c-40395821">[2 more]</label></div><br/><div class="children"><div class="content">it helps in the other direction: less friction to use from rust</div><br/><div id="40397143" class="c"><input type="checkbox" id="c-40397143" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#40394377">root</a><span>|</span><a href="#40395821">parent</a><span>|</span><a href="#40397217">next</a><span>|</span><label class="collapse" for="c-40397143">[-]</label><label class="expand" for="c-40397143">[1 more]</label></div><br/><div class="children"><div class="content">But more friction to use from just about every other language.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40397217" class="c"><input type="checkbox" id="c-40397217" checked=""/><div class="controls bullet"><span class="by">andrepd</span><span>|</span><a href="#40394377">parent</a><span>|</span><a href="#40394573">prev</a><span>|</span><a href="#40397306">next</a><span>|</span><label class="collapse" for="c-40397217">[-]</label><label class="expand" for="c-40397217">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the difference vs compiling down to machine code and linking it with your program?</div><br/></div></div></div></div><div id="40397306" class="c"><input type="checkbox" id="c-40397306" checked=""/><div class="controls bullet"><span class="by">who-shot-jr</span><span>|</span><a href="#40394377">prev</a><span>|</span><a href="#40395992">next</a><span>|</span><label class="collapse" for="c-40397306">[-]</label><label class="expand" for="c-40397306">[1 more]</label></div><br/><div class="children"><div class="content">Could you use this to make sure users uploading files to your website are correct (i.e only jpegs and valid image data)? But in a fast and safe way, or is this overkill?</div><br/></div></div><div id="40395992" class="c"><input type="checkbox" id="c-40395992" checked=""/><div class="controls bullet"><span class="by">refibrillator</span><span>|</span><a href="#40397306">prev</a><span>|</span><a href="#40394652">next</a><span>|</span><label class="collapse" for="c-40395992">[-]</label><label class="expand" for="c-40395992">[2 more]</label></div><br/><div class="children"><div class="content">Can Wuffs provide stronger safety guarantees than techniques like WasmBoxC?<p>My understanding is that compiling unsafe C to WASM and back would also guarantee safety with respect to buffer overflows, integer arithmetic overflows and null pointer dereferences.<p>It’s nice not annotating code to explicitly prove invariants to the compiler like you would in say Wuffs or Rust, but I suppose that’s what limits performance.</div><br/><div id="40396255" class="c"><input type="checkbox" id="c-40396255" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#40395992">parent</a><span>|</span><a href="#40394652">next</a><span>|</span><label class="collapse" for="c-40396255">[-]</label><label class="expand" for="c-40396255">[1 more]</label></div><br/><div class="children"><div class="content">Doesn’t wasm have a memory model as well? So unless you sandbox certain parts of it you can still in theory have access across different C functions, within the same wasm module?<p>What seems nice about wuffs is that it has no side effects and a clear project scope. Deserialization is so riddled with severe issues that it does kind of warrant its own DSL. OTOH, some legacy formats will probably never be ported.</div><br/></div></div></div></div><div id="40394652" class="c"><input type="checkbox" id="c-40394652" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#40395992">prev</a><span>|</span><a href="#40395897">next</a><span>|</span><label class="collapse" for="c-40394652">[-]</label><label class="expand" for="c-40394652">[1 more]</label></div><br/><div class="children"><div class="content">Related, in the sense of solving the same problem in a different manner: <a href="https:&#x2F;&#x2F;rlbox.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rlbox.dev&#x2F;</a></div><br/></div></div><div id="40395897" class="c"><input type="checkbox" id="c-40395897" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40394652">prev</a><span>|</span><a href="#40395744">next</a><span>|</span><label class="collapse" for="c-40395897">[-]</label><label class="expand" for="c-40395897">[5 more]</label></div><br/><div class="children"><div class="content">Wuffs is cool, but you can get similar results writing normal C library code, compiling it into a .wasm binary via Clang, and then running the .wasm binary through the `wasm2c` tool of the WebAssembly Binary Toolkit [0]. I personally prefer this method, although Wuffs will usually produce faster code.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;wabt&#x2F;tree&#x2F;44837a7236e85c048de3214fd2ae4c37d3a034ce&#x2F;wasm2c">https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;wabt&#x2F;tree&#x2F;44837a7236e85c048de...</a></div><br/><div id="40396167" class="c"><input type="checkbox" id="c-40396167" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#40395897">parent</a><span>|</span><a href="#40396390">next</a><span>|</span><label class="collapse" for="c-40396167">[-]</label><label class="expand" for="c-40396167">[2 more]</label></div><br/><div class="children"><div class="content">It is not obvious to me why this should guarantee safety.</div><br/><div id="40396245" class="c"><input type="checkbox" id="c-40396245" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40395897">root</a><span>|</span><a href="#40396167">parent</a><span>|</span><a href="#40396390">next</a><span>|</span><label class="collapse" for="c-40396245">[-]</label><label class="expand" for="c-40396245">[1 more]</label></div><br/><div class="children"><div class="content">`wasm2c` fully implements the WebAssembly sandbox execution environment [0][1] and has the passing tests to prove it. To be a bit more specific, the .wasm binary you generate initially already has the WebAssembly semantics baked in (obviously) and `wasm2c` creates a portable C translation of the WebAssembly while also ensuring that the execution environment is sandboxed (e.g., the code traps when attempting out-of-bounds memory accesses).<p>[0]: <a href="https:&#x2F;&#x2F;webassembly.org" rel="nofollow">https:&#x2F;&#x2F;webassembly.org</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;wabt&#x2F;issues&#x2F;2289#issuecomment-1709207053">https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;wabt&#x2F;issues&#x2F;2289#issuecomment...</a></div><br/></div></div></div></div><div id="40396390" class="c"><input type="checkbox" id="c-40396390" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#40395897">parent</a><span>|</span><a href="#40396167">prev</a><span>|</span><a href="#40395744">next</a><span>|</span><label class="collapse" for="c-40396390">[-]</label><label class="expand" for="c-40396390">[2 more]</label></div><br/><div class="children"><div class="content">How much faster (say, for something like an image codec)</div><br/><div id="40396720" class="c"><input type="checkbox" id="c-40396720" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40395897">root</a><span>|</span><a href="#40396390">parent</a><span>|</span><a href="#40395744">next</a><span>|</span><label class="collapse" for="c-40396720">[-]</label><label class="expand" for="c-40396720">[1 more]</label></div><br/><div class="children"><div class="content">This might not be what you want to hear (and I might get downvoted for it), but it’s what I consider the best answer: Implement something minimal but useful (and realistic) using both methods and benchmark them yourself.<p>Even if I told you some of the numbers I’ve seen in my experiments and usage, it wouldn’t be wise to trust them or let them taint your opinion.</div><br/></div></div></div></div></div></div><div id="40395744" class="c"><input type="checkbox" id="c-40395744" checked=""/><div class="controls bullet"><span class="by">YoshiRulz</span><span>|</span><a href="#40395897">prev</a><span>|</span><a href="#40394306">next</a><span>|</span><label class="collapse" for="c-40395744">[-]</label><label class="expand" for="c-40395744">[1 more]</label></div><br/><div class="children"><div class="content">Superior in every sense to that Magicka garbage they released a couple months ago. I&#x27;m excited to see its via-Rust codegen.</div><br/></div></div><div id="40394306" class="c"><input type="checkbox" id="c-40394306" checked=""/><div class="controls bullet"><span class="by">newman314</span><span>|</span><a href="#40395744">prev</a><span>|</span><a href="#40394479">next</a><span>|</span><label class="collapse" for="c-40394306">[-]</label><label class="expand" for="c-40394306">[19 more]</label></div><br/><div class="children"><div class="content">Does anyone know of a tool that can do this for PDFs instead?</div><br/><div id="40397484" class="c"><input type="checkbox" id="c-40397484" checked=""/><div class="controls bullet"><span class="by">trustno2</span><span>|</span><a href="#40394306">parent</a><span>|</span><a href="#40394786">next</a><span>|</span><label class="collapse" for="c-40397484">[-]</label><label class="expand" for="c-40397484">[1 more]</label></div><br/><div class="children"><div class="content">pdfs are really really hard. the only viewer that parses them semi-correctly is ... Acrobat Reader.<p>try to ever read any code for PDFs and see all the horrors.<p>Google gave up and just bought the code from foxit.</div><br/></div></div><div id="40394417" class="c"><input type="checkbox" id="c-40394417" checked=""/><div class="controls bullet"><span class="by">warkdarrior</span><span>|</span><a href="#40394306">parent</a><span>|</span><a href="#40394786">prev</a><span>|</span><a href="#40394622">next</a><span>|</span><label class="collapse" for="c-40394417">[-]</label><label class="expand" for="c-40394417">[6 more]</label></div><br/><div class="children"><div class="content">As soon as someone writes a Javascript interpreter in Wuffs..</div><br/><div id="40394593" class="c"><input type="checkbox" id="c-40394593" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40394417">parent</a><span>|</span><a href="#40394622">next</a><span>|</span><label class="collapse" for="c-40394593">[-]</label><label class="expand" for="c-40394593">[5 more]</label></div><br/><div class="children"><div class="content">Do you ever need a JS interpreter to <i>parse</i> a PDF? That&#x27;s horrifying.<p>I understand PDF has a bunch of limbs, but I always assumed the JS stuff was at least separate from the parsing. (I am familiar with the PDF format at a lower level but I never touched any of the weird features.)</div><br/><div id="40394989" class="c"><input type="checkbox" id="c-40394989" checked=""/><div class="controls bullet"><span class="by">timschmidt</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40394593">parent</a><span>|</span><a href="#40394622">next</a><span>|</span><label class="collapse" for="c-40394989">[-]</label><label class="expand" for="c-40394989">[4 more]</label></div><br/><div class="children"><div class="content">I wrote an SVG that&#x27;s all javascript, no elements.  All the graphics are generated dynamically at runtime by the javascript.  It&#x27;s SVG standards compliant, but only opens correctly in browsers, not in inkscape or other desktop publishing apps.<p>I work a lot in OpenSCAD, and had a need to design some custom graph paper.  So I found the subset of SVG which was similar to OpenSCAD.  :)</div><br/><div id="40395347" class="c"><input type="checkbox" id="c-40395347" checked=""/><div class="controls bullet"><span class="by">jszymborski</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40394989">parent</a><span>|</span><a href="#40394622">next</a><span>|</span><label class="collapse" for="c-40395347">[-]</label><label class="expand" for="c-40395347">[3 more]</label></div><br/><div class="children"><div class="content">Frankly, I wouldn&#x27;t begrudge a website for not correctly parsing an svg I composed entirely with javascript.<p>It&#x27;s annoying you can&#x27;t just &quot;flatten&quot; or &quot;bake&quot; such an svg like yours into one composed entirely of elements (unless one exists?)</div><br/><div id="40395771" class="c"><input type="checkbox" id="c-40395771" checked=""/><div class="controls bullet"><span class="by">csande17</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40395347">parent</a><span>|</span><a href="#40394622">next</a><span>|</span><label class="collapse" for="c-40395771">[-]</label><label class="expand" for="c-40395771">[2 more]</label></div><br/><div class="children"><div class="content">Often you can open the SVG in a browser and then use the developer tools to copy out the resulting nodes as &quot;flat&quot; SVG source code.<p>Chrome even includes a --dump-dom flag you can use to do this on the command line, although I haven&#x27;t tested it with an SVG.</div><br/><div id="40397455" class="c"><input type="checkbox" id="c-40397455" checked=""/><div class="controls bullet"><span class="by">jszymborski</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40395771">parent</a><span>|</span><a href="#40394622">next</a><span>|</span><label class="collapse" for="c-40397455">[-]</label><label class="expand" for="c-40397455">[1 more]</label></div><br/><div class="children"><div class="content">Clever!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40394622" class="c"><input type="checkbox" id="c-40394622" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40394306">parent</a><span>|</span><a href="#40394417">prev</a><span>|</span><a href="#40395126">next</a><span>|</span><label class="collapse" for="c-40394622">[-]</label><label class="expand" for="c-40394622">[9 more]</label></div><br/><div class="children"><div class="content">There are PDF readers that do not support the scripting format extensions.<p>Note this does not prevent unscrupulous companies abusing dominant market positions to voluntarily embed machine and serial hash watermarks.<p>To be clear:  formats like pdf, ps, webp, svg, and tiff are so badly implemented in some ecosystems... they can&#x27;t _ever_ be assumed safe input formats.  Thus, at some point people need to spin up an actual VM to transcode a &quot;web&quot; version, and scrub each stage of the rendering pipeline like a virus or header injection is already present.<p>&quot;I never play where nice things are, and don&#x27;t break things&quot; (Eliza Mowry Blven, The Humanitarian Review, Volume 3, March, 1905)<p>Cheers =3</div><br/><div id="40394669" class="c"><input type="checkbox" id="c-40394669" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40394622">parent</a><span>|</span><a href="#40396440">next</a><span>|</span><label class="collapse" for="c-40394669">[-]</label><label class="expand" for="c-40394669">[6 more]</label></div><br/><div class="children"><div class="content">I worked with TIFF pretty extensively, it&#x27;s a mess but I don&#x27;t see why a WUFFS TIFF codec can&#x27;t be fine. What makes you say you need &quot;an actual VM to transcode&quot; a TIFF ?</div><br/><div id="40395118" class="c"><input type="checkbox" id="c-40395118" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40394669">parent</a><span>|</span><a href="#40396440">next</a><span>|</span><label class="collapse" for="c-40395118">[-]</label><label class="expand" for="c-40395118">[5 more]</label></div><br/><div class="children"><div class="content">The complex formats of tiff and tga specifications makes it nearly impossible to span all the edge-cases with unit-tests.   A VM can be in a known-state snapshot, process pre&#x2F;post signature logged&#x2F;compared with a scripted debugger, and binary input&#x2F;output stripped of non-compliant metadata&#x2F;blobs at each stage of the pipeline if the process behaves as expected.<p>I&#x27;ve yet to find a better method than Honeypots to sustainably mitigate the complex leaky dependency mess on traditional architectures. It has been my experience that &quot;all software is terrible, but some of it is useful&quot;.<p>It may just be my bias, but I see code smell getting worse in recent decades...<p>Have a nice day, =3<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aCbfMkh940Q" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aCbfMkh940Q</a></div><br/><div id="40395226" class="c"><input type="checkbox" id="c-40395226" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40395118">parent</a><span>|</span><a href="#40396440">next</a><span>|</span><label class="collapse" for="c-40395226">[-]</label><label class="expand" for="c-40395226">[4 more]</label></div><br/><div class="children"><div class="content">So, there&#x27;s actually no particular reason and if somebody cares to write one then yup, TIFF codec in WUFFS would in fact be safer and faster than your uh, approach.</div><br/><div id="40395300" class="c"><input type="checkbox" id="c-40395300" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40395226">parent</a><span>|</span><a href="#40396440">next</a><span>|</span><label class="collapse" for="c-40395300">[-]</label><label class="expand" for="c-40395300">[3 more]</label></div><br/><div class="children"><div class="content">One does not rely on the persistent competence of the coders, and will tell you when something has gone wrong.<p>And walking a binary object store to ban problem users is not always necessary... depending what you are doing.<p>Most other approaches makes the same predictable assumptions:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_cognitive_biases" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_cognitive_biases</a><p>Despite popular belief, shitty design does not usually get better in another language. Rather, people just feel more confident it isn&#x27;t shit anymore.<p>I have yet to see evidence to the contrary. =3</div><br/><div id="40396201" class="c"><input type="checkbox" id="c-40396201" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40395300">parent</a><span>|</span><a href="#40396440">next</a><span>|</span><label class="collapse" for="c-40396201">[-]</label><label class="expand" for="c-40396201">[2 more]</label></div><br/><div class="children"><div class="content">Wait, you believe that somehow one of these approaches doesn&#x27;t rely on competence from programmers? How do you figure?<p>Have you been imagining that sandboxes are some sort of fairy dust we just stumbled onto one day, supernatural in nature and not, in fact, just software written by people you&#x27;re hoping are competent and haven&#x27;t left any holes?</div><br/><div id="40396336" class="c"><input type="checkbox" id="c-40396336" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40396201">parent</a><span>|</span><a href="#40396440">next</a><span>|</span><label class="collapse" for="c-40396336">[-]</label><label class="expand" for="c-40396336">[1 more]</label></div><br/><div class="children"><div class="content">The point was... one is testing parser&#x2F;OS integrity via a debugging interface over an expectation of an unchanging emulated environment state...  there is nothing particularly special about the approach.  Even Qubes OS and RancherVM is not perfect in this regard friend.<p>Or put another way, the available attack surface of a bare-minimum fixed environment is much easier to auto-audit, than a pile of daily permuted binaries and self-delusion approach. i.e. if it fails to behave in an expected way, or is modified in any way... the host audit process doesn&#x27;t have to care why or how it is broken to maintain a service queue as the guest is culled.<p>Perhaps I am wrong about exchanging 15% of raw performance for reliability, but things can get complicated with licenses and multiple OS specific platforms.<p>You seem to be getting emotional about this subject, presenting secondary and tertiary straw-man arguments. So I&#x27;m going to go eat some Cheese Goldfish crackers... and just agree that your beliefs are interesting.<p>Have a fantastic weekend...   =3</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40396440" class="c"><input type="checkbox" id="c-40396440" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40394306">root</a><span>|</span><a href="#40394622">parent</a><span>|</span><a href="#40394669">prev</a><span>|</span><a href="#40395126">next</a><span>|</span><label class="collapse" for="c-40396440">[-]</label><label class="expand" for="c-40396440">[2 more]</label></div><br/><div class="children"><div class="content">WUFFS is provably safe - that&#x27;s the whole schtick. If a WUFFS kernel exists, you can assume it is safe. If it&#x27;s not proven safe, it doesn&#x27;t compile. The reason everyone doesn&#x27;t program in WUFFS is that you have to write a proof that your kernel is safe, which takes a very very very long time.</div><br/></div></div></div></div><div id="40395126" class="c"><input type="checkbox" id="c-40395126" checked=""/><div class="controls bullet"><span class="by">ThePowerOfFuet</span><span>|</span><a href="#40394306">parent</a><span>|</span><a href="#40394622">prev</a><span>|</span><a href="#40394479">next</a><span>|</span><label class="collapse" for="c-40395126">[-]</label><label class="expand" for="c-40395126">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;dangerzone.rocks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dangerzone.rocks&#x2F;</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>