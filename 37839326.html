<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697014864179" as="style"/><link rel="stylesheet" href="styles.css?v=1697014864179"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://voidstar.tech/code_duplication/">Going faster by duplicating code</a>Â <span class="domain">(<a href="https://voidstar.tech">voidstar.tech</a>)</span></div><div class="subtext"><span>voidstarcpp</span> | <span>23 comments</span></div><br/><div><div id="37841441" class="c"><input type="checkbox" id="c-37841441" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37839958">next</a><span>|</span><label class="collapse" for="c-37841441">[-]</label><label class="expand" for="c-37841441">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Compilers try to hoist constant conditions outside of loops but they&#x27;re bad at it. Even in the trivial example above, on -O2 gcc does a redundant check with every loop iteration.<p>GCC is actually good at that, -O3 has no issue recognizing it. In fact there even is a very explicit option (-funswitch-loops) responsible for extracting loop invariants. It is not enabled on -O2 because it has a space-speed tradeoff. If this optimization is truly desirable even on -O2, `#pragma GCC optimize(&quot;-funswitch-loops&quot;)` can be used to force it.</div><br/></div></div><div id="37839958" class="c"><input type="checkbox" id="c-37839958" checked=""/><div class="controls bullet"><span class="by">drmikeando</span><span>|</span><a href="#37841441">prev</a><span>|</span><a href="#37840054">next</a><span>|</span><label class="collapse" for="c-37839958">[-]</label><label class="expand" for="c-37839958">[8 more]</label></div><br/><div class="children"><div class="content">IMO the reason the compiler doesn&#x27;t add special cases for the simplest version is that it doesn&#x27;t know which of its _many_ special cases to use. If you actually use the unoptimised version of the code like<p><pre><code>    void withSwitch(vector&lt;int&gt;&amp; Values, bool v) {
      if (v) {
        multiply1(Values, 2.0);
      } else {
        multiply1(Values, 3.0);
      }
    }
</code></pre>
Then it actually inlines the code and optimises each one correctly, as it has context about which special cases are available. (Doesn&#x27;t even need the `inline` keyword for this at `-O2`)<p>You can see the code here: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;5beeYe77a" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;5beeYe77a</a></div><br/><div id="37840057" class="c"><input type="checkbox" id="c-37840057" checked=""/><div class="controls bullet"><span class="by">voidstarcpp</span><span>|</span><a href="#37839958">parent</a><span>|</span><a href="#37840823">next</a><span>|</span><label class="collapse" for="c-37840057">[-]</label><label class="expand" for="c-37840057">[4 more]</label></div><br/><div class="children"><div class="content">This is possible if the call site can see the implementation, but you can&#x27;t count on it for separate translation units or larger functions.<p>My goal was to not rely on site-specific optimization and instead have one separately compiled function body that can be improved for common cases. Certainly, once the compiler has a full view of everything it can take advantage of information as it pleases but this is less controllable. If I were really picky about optimizing for each use I would make it a template.<p>&gt;Doesn&#x27;t even need the `inline` keyword for this at `-O2`<p>The inline keyword means little in terms of actually causing inlining to happen. I would expect the majority of inlining compilers do happens automatically on functions that lack the &quot;inline&quot; keyword. Conversely, programmers probably add &quot;inline&quot; as an incantation all over the place not knowing that compilers often ignore it.</div><br/><div id="37840571" class="c"><input type="checkbox" id="c-37840571" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#37839958">root</a><span>|</span><a href="#37840057">parent</a><span>|</span><a href="#37840290">next</a><span>|</span><label class="collapse" for="c-37840571">[-]</label><label class="expand" for="c-37840571">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Conversely, programmers probably add &quot;inline&quot; as an incantation all over the place not knowing that compilers often ignore it.<p>Funnily, the inline keyword actually has a use, but that use isn&#x27;t to tell the compiler to inline a function. The use is to allow a function (or variable) to be defined in multiple translations units without being an ODR violation.</div><br/><div id="37842056" class="c"><input type="checkbox" id="c-37842056" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37839958">root</a><span>|</span><a href="#37840571">parent</a><span>|</span><a href="#37840290">next</a><span>|</span><label class="collapse" for="c-37842056">[-]</label><label class="expand" for="c-37842056">[1 more]</label></div><br/><div class="children"><div class="content">Msvc treats inline as a hint [0] , GCC is ambiguous [1] but I read it as utilising the hint. My under of clang [2] is that it tries to match GCC.<p>[0] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;ob-inline-function-expansion?view=msvc-170" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;ob-inl...</a><p>[1] <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Inline.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Inline.html</a><p>[2] <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;compatibility.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;clang.llvm.org&#x2F;compatibility.html</a></div><br/></div></div></div></div><div id="37840290" class="c"><input type="checkbox" id="c-37840290" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#37839958">root</a><span>|</span><a href="#37840057">parent</a><span>|</span><a href="#37840571">prev</a><span>|</span><a href="#37840823">next</a><span>|</span><label class="collapse" for="c-37840290">[-]</label><label class="expand" for="c-37840290">[1 more]</label></div><br/><div class="children"><div class="content">would it have made a difference if the function was static? The compiler would then be able to deduce that it isn&#x27;t used anywhere else, and thus could do this inline optimization.</div><br/></div></div></div></div><div id="37840823" class="c"><input type="checkbox" id="c-37840823" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37839958">parent</a><span>|</span><a href="#37840057">prev</a><span>|</span><a href="#37841008">next</a><span>|</span><label class="collapse" for="c-37840823">[-]</label><label class="expand" for="c-37840823">[1 more]</label></div><br/><div class="children"><div class="content">You can also force it by using extensions like `[[gnu::always_inline]]` or `__forceinline`. I&#x27;ve actually used this technique to generate an auto-vectorizable function whenever it&#x27;s possible, without any code duplication [1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;lifthrasiir&#x2F;j40&#x2F;blob&#x2F;252e7987d36d50f617f29e94eeeb741198adc617&#x2F;j40.h#L5764-L5856">https:&#x2F;&#x2F;github.com&#x2F;lifthrasiir&#x2F;j40&#x2F;blob&#x2F;252e7987d36d50f617f2...</a></div><br/></div></div><div id="37841008" class="c"><input type="checkbox" id="c-37841008" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#37839958">parent</a><span>|</span><a href="#37840823">prev</a><span>|</span><a href="#37840054">next</a><span>|</span><label class="collapse" for="c-37841008">[-]</label><label class="expand" for="c-37841008">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the reason the compiler doesn&#x27;t add special cases for the simplest version is that it doesn&#x27;t know which of its _many_ special cases to use<p>This is a fact claim.  I&#x27;m having trouble parsing the &quot;IMO&quot; that&#x27;s a preface to your comment.</div><br/><div id="37841459" class="c"><input type="checkbox" id="c-37841459" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#37839958">root</a><span>|</span><a href="#37841008">parent</a><span>|</span><a href="#37840054">next</a><span>|</span><label class="collapse" for="c-37841459">[-]</label><label class="expand" for="c-37841459">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;IMO&quot; here is used instead of &quot;I think&quot; or &quot;I believe&quot; to indicate that this is not a fact claim but a (presumably educated) guess. Not a very correct use of &quot;IMO&quot;, technically, but a fairly common one nonetheless.</div><br/></div></div></div></div></div></div><div id="37840054" class="c"><input type="checkbox" id="c-37840054" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#37839958">prev</a><span>|</span><a href="#37839327">next</a><span>|</span><label class="collapse" for="c-37840054">[-]</label><label class="expand" for="c-37840054">[2 more]</label></div><br/><div class="children"><div class="content">OP â If this comp_nearest is still a hot path for you or if you want to generate more articles, consider testing:<p>1. using `restrict` to tell that compiler that src and dest are sure not to overlap<p>2. Converting your two increment and test blocks to add+mod to allow for uninterrupted pipelining<p>Neither might make a difference, but either could.</div><br/><div id="37840112" class="c"><input type="checkbox" id="c-37840112" checked=""/><div class="controls bullet"><span class="by">voidstarcpp</span><span>|</span><a href="#37840054">parent</a><span>|</span><a href="#37839327">next</a><span>|</span><label class="collapse" for="c-37840112">[-]</label><label class="expand" for="c-37840112">[1 more]</label></div><br/><div class="children"><div class="content">Addressing the aliasing concern would be the easiest improvement. I observed in the assembly that the source pixel is being re-read all four times it is used, which could be fixed.<p>Writing an optimal composite function is of course not really the goal, nor of much educational&#x2F;entertainment value. For any additional speed I already have a function which slices up compositing tasks into chunks and puts them on a thread pool.</div><br/></div></div></div></div><div id="37839327" class="c"><input type="checkbox" id="c-37839327" checked=""/><div class="controls bullet"><span class="by">voidstarcpp</span><span>|</span><a href="#37840054">prev</a><span>|</span><a href="#37840419">next</a><span>|</span><label class="collapse" for="c-37839327">[-]</label><label class="expand" for="c-37839327">[7 more]</label></div><br/><div class="children"><div class="content">TL;DR: If you copy paste the same implementation code in different branches, you give the compiler opportunities to generate faster code for each case it wouldn&#x27;t have otherwise generated, without you having to do any manual optimization work.</div><br/><div id="37841705" class="c"><input type="checkbox" id="c-37841705" checked=""/><div class="controls bullet"><span class="by">jrumbut</span><span>|</span><a href="#37839327">parent</a><span>|</span><a href="#37839756">next</a><span>|</span><label class="collapse" for="c-37841705">[-]</label><label class="expand" for="c-37841705">[1 more]</label></div><br/><div class="children"><div class="content">This is really an excellent programming technique article.<p>I think what makes it so great is that your examples hit a sweet spot of simplicity while still being motivating and you show how to get a &quot;good enough&quot; solution very quickly.</div><br/></div></div><div id="37839756" class="c"><input type="checkbox" id="c-37839756" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#37839327">parent</a><span>|</span><a href="#37841705">prev</a><span>|</span><a href="#37839689">next</a><span>|</span><label class="collapse" for="c-37839756">[-]</label><label class="expand" for="c-37839756">[4 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s the case, then I imagine the inline keyword would have the same effect?</div><br/><div id="37839994" class="c"><input type="checkbox" id="c-37839994" checked=""/><div class="controls bullet"><span class="by">voidstarcpp</span><span>|</span><a href="#37839327">root</a><span>|</span><a href="#37839756">parent</a><span>|</span><a href="#37839976">next</a><span>|</span><label class="collapse" for="c-37839994">[-]</label><label class="expand" for="c-37839994">[1 more]</label></div><br/><div class="children"><div class="content">You need to use a compiler specific &quot;always inline&quot; directive if you want macro-like functionality of actually inlining code.<p>On its own, the C++ &quot;inline&quot; keyword does not cause inlining to happen, although compilers may treat it like a hint depending on optimization level. GCC does not inline an &quot;inline&quot; function on O0.<p>&quot;Inline&quot; in the C++ standard means &quot;multiple definitions permitted&quot; so the same entity can exist in multiple translation units without upsetting the linker. This is why C++17 added &quot;inline&quot; variables, which can be initialized in a header that&#x27;s included in multiple places, even though the inlining concept has no applicability to a variable. The keyword was adopted for this purpose because of the primary association with affecting linkage behavior.</div><br/></div></div><div id="37839976" class="c"><input type="checkbox" id="c-37839976" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#37839327">root</a><span>|</span><a href="#37839756">parent</a><span>|</span><a href="#37839994">prev</a><span>|</span><a href="#37839773">next</a><span>|</span><label class="collapse" for="c-37839976">[-]</label><label class="expand" for="c-37839976">[1 more]</label></div><br/><div class="children"><div class="content">This isnât an optimization you should consider without insight into your <i>actual</i> bottlenecks, but compilers <i>can be</i> even more aggressive with code thatâs strictly local to one translation unit (i.e. inside an anonymous namespace in a cpp file) than they <i>typically</i> would be when seeing an inline hint elsewhere.<p>Itâs not <i>quite</i> the same.<p>Plus, another benefit of duplication is that you can more freely hand-tune your implementation once youâve decided its private. Memory alignment, pointer aliasing hints, clever loop structures, SSE stuff, etc can all be used more freely when you know nothing else needs to use this version.<p>The article is a good teaser around how unintuitive optimization can be, but it only scratches the surface.</div><br/></div></div><div id="37839773" class="c"><input type="checkbox" id="c-37839773" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37839327">root</a><span>|</span><a href="#37839756">parent</a><span>|</span><a href="#37839976">prev</a><span>|</span><a href="#37839689">next</a><span>|</span><label class="collapse" for="c-37839773">[-]</label><label class="expand" for="c-37839773">[1 more]</label></div><br/><div class="children"><div class="content">yeah, languages which can do inking optimizations do this for you, sometimes even without you knowing.</div><br/></div></div></div></div><div id="37839689" class="c"><input type="checkbox" id="c-37839689" checked=""/><div class="controls bullet"><span class="by">spiritplumber</span><span>|</span><a href="#37839327">parent</a><span>|</span><a href="#37839756">prev</a><span>|</span><a href="#37840419">next</a><span>|</span><label class="collapse" for="c-37839689">[-]</label><label class="expand" for="c-37839689">[1 more]</label></div><br/><div class="children"><div class="content">thank you</div><br/></div></div></div></div><div id="37840419" class="c"><input type="checkbox" id="c-37840419" checked=""/><div class="controls bullet"><span class="by">ape4</span><span>|</span><a href="#37839327">prev</a><span>|</span><label class="collapse" for="c-37840419">[-]</label><label class="expand" for="c-37840419">[4 more]</label></div><br/><div class="children"><div class="content">Honest question, would `V *= Factor` be faster?</div><br/><div id="37840609" class="c"><input type="checkbox" id="c-37840609" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#37840419">parent</a><span>|</span><label class="collapse" for="c-37840609">[-]</label><label class="expand" for="c-37840609">[3 more]</label></div><br/><div class="children"><div class="content">In almost all cases: no.<p>&quot;A compound assignment of the form E1 op= E2 differs from the simple assignment expression E1 = E1 op (E2) only in that the lvalue E1 is evaluated only once.&quot; (C99, 6.5.16.2p3)<p>It only matters when evaluating E1 has side effects. For example, `a[i++] += 1;` which is equivalent to `a[i] = a[i] + 1; i++;` rather than `a[i++] = a[i++] + 1;`.</div><br/><div id="37841534" class="c"><input type="checkbox" id="c-37841534" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#37840419">root</a><span>|</span><a href="#37840609">parent</a><span>|</span><label class="collapse" for="c-37841534">[-]</label><label class="expand" for="c-37841534">[2 more]</label></div><br/><div class="children"><div class="content">&gt; `a[i++] = a[i++] + 1;`<p>This is probably not what you want, as &quot;i&quot; is increased twice.</div><br/><div id="37841650" class="c"><input type="checkbox" id="c-37841650" checked=""/><div class="controls bullet"><span class="by">jrumbut</span><span>|</span><a href="#37840419">root</a><span>|</span><a href="#37841534">parent</a><span>|</span><label class="collapse" for="c-37841650">[-]</label><label class="expand" for="c-37841650">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why it matters in that situation, because it changes what actually happens (not just the performance).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>