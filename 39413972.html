<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708246851043" as="style"/><link rel="stylesheet" href="styles.css?v=1708246851043"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://shekhargulati.com/2022/07/08/my-notes-on-gitlabs-postgres-schema-design/">My notes on Gitlab&#x27;s Postgres schema design (2022)</a> <span class="domain">(<a href="https://shekhargulati.com">shekhargulati.com</a>)</span></div><div class="subtext"><span>daigoba66</span> | <span>81 comments</span></div><br/><div><div id="39416986" class="c"><input type="checkbox" id="c-39416986" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#39414424">next</a><span>|</span><label class="collapse" for="c-39416986">[-]</label><label class="expand" for="c-39416986">[7 more]</label></div><br/><div class="children"><div class="content">&gt; It is generally a good practice to not expose your primary keys to the external world. This is especially important when you use sequential auto-incrementing identifiers with type integer or bigint since they are guessable.<p>What value would there be in preventing guessing?  How would that even be possible if requests have to be authenticated in the first place?<p>I see this &quot;best practice&quot; advocated often, but to me it reeks of security theater.  If an attacker is able to do anything useful with a guessed ID without being authenticated and authorized to do so, then something else has gone horribly, horribly, <i>horribly</i> wrong and <i>that</i> should be the focus of one&#x27;s energy instead of adding needless complexity to the schema.<p>The only case I know of where this might be valuable is from a business intelligence standpoint, i.e. you don&#x27;t want competitors to know how many customers you have.  My sympathy for such concerns is quite honestly pretty low, and I highly doubt GitLab cares much about that.<p>In GitLab&#x27;s case, I&#x27;m reasonably sure the decision to use id + iid is less driven by &quot;we don&#x27;t want people guessing internal IDs&quot; and more driven by query performance needs.</div><br/><div id="39417397" class="c"><input type="checkbox" id="c-39417397" checked=""/><div class="controls bullet"><span class="by">remus</span><span>|</span><a href="#39416986">parent</a><span>|</span><a href="#39417350">next</a><span>|</span><label class="collapse" for="c-39417397">[-]</label><label class="expand" for="c-39417397">[1 more]</label></div><br/><div class="children"><div class="content">In general it&#x27;s a defense-in-depth thing. You definitely shouldn&#x27;t be relying on it, but as an attacker it just makes your life a bit harder if it&#x27;s not straightforward to work out object IDs.<p>For example, imagine you&#x27;re poking around a system that uses incrementing ints as public identifiers. Immediately, you can make a good guess that there&#x27;s probably going to be some high privileged users with user_id=1..100 so you can start probing around those accounts. If you used UUIDs or similar then you&#x27;re not leaking that info.<p>In gitlabs case this is much less relevant, and it&#x27;s more fo a cosmetic thing.</div><br/></div></div><div id="39417350" class="c"><input type="checkbox" id="c-39417350" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#39416986">parent</a><span>|</span><a href="#39417397">prev</a><span>|</span><a href="#39417009">next</a><span>|</span><label class="collapse" for="c-39417350">[-]</label><label class="expand" for="c-39417350">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I see this &quot;best practice&quot; advocated often, but to me it reeks of security theater. If an attacker is able to do anything useful with a guessed ID without being authenticated and authorized to do so, then something else has gone horribly, horribly, horribly wrong and that should be the focus of one&#x27;s energy instead of adding needless complexity to the schema.<p>Yes, but the ability to guess IDs can make this security issue horrible, or much much worse.<p>If you had such a vulnerability and you are exposing the users to UUIDs, now people have to guess UUIDs. Even a determined attacker will have a hard time doing that or they would need secondary sources to get the IDs. You have a data breach, but you most likely have time to address it and then you can assess the amount of data lost.<p>If you can just &lt;seq 0 10000 | xargs -I ID curl service&#x2F;ticket&#x2F;ID&gt; the security issue is instantly elevated onto a whole new level. Suddenly all data is leaked without further effort and we&#x27;re looking at mandatory report to data protection agencies with a massive loss of data.<p>To me, this is one of these defense in depth things that should be useless. And it has no effect in many, many cases.<p>But there is truely horrid software out there that has been popped in exactly the described way.</div><br/></div></div><div id="39417009" class="c"><input type="checkbox" id="c-39417009" checked=""/><div class="controls bullet"><span class="by">s4i</span><span>|</span><a href="#39416986">parent</a><span>|</span><a href="#39417350">prev</a><span>|</span><a href="#39417201">next</a><span>|</span><label class="collapse" for="c-39417009">[-]</label><label class="expand" for="c-39417009">[1 more]</label></div><br/><div class="children"><div class="content">It’s mentioned in the article. It’s more to do with business intelligence than security. A simple auto-incrementing ID will reveal how many total records you have in a table and&#x2F;or their growth rate.<p>&gt; If you expose the issues table primary key id then when you create an issue in your project it will not start with 1 and you can easily guess how many issues exist in the GitLab.</div><br/></div></div><div id="39417201" class="c"><input type="checkbox" id="c-39417201" checked=""/><div class="controls bullet"><span class="by">lordgrenville</span><span>|</span><a href="#39416986">parent</a><span>|</span><a href="#39417009">prev</a><span>|</span><a href="#39417043">next</a><span>|</span><label class="collapse" for="c-39417201">[-]</label><label class="expand" for="c-39417201">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The only case where this might be valuable is business intelligence<p>Nitpick: I would not call this &quot;business intelligence&quot; (which usually refers to internal use of the company&#x27;s own data) but &quot;competitive intelligence&quot;. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Competitive_intelligence" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Competitive_intelligence</a></div><br/></div></div><div id="39417043" class="c"><input type="checkbox" id="c-39417043" checked=""/><div class="controls bullet"><span class="by">JimBlackwood</span><span>|</span><a href="#39416986">parent</a><span>|</span><a href="#39417201">prev</a><span>|</span><a href="#39417321">next</a><span>|</span><label class="collapse" for="c-39417043">[-]</label><label class="expand" for="c-39417043">[1 more]</label></div><br/><div class="children"><div class="content">I follow this best practice, there’s a few reasons why I do this. It doesn’t have to do with using a guessed primary ID for some sort of privilege escalation, though. It has more to do with not leaking any company information.<p>When I worked for an e-commerce company, one of our biggest competitors used an auto-incrementing integer as primary key on their “orders” table. Yeah… You can figure out how this was used. Not very smart by them, extremely useful for my employer. Neither of these will allow security holes or leak customer info&#x2F;payment info, but you’d still rather not leak this.</div><br/></div></div><div id="39417321" class="c"><input type="checkbox" id="c-39417321" checked=""/><div class="controls bullet"><span class="by">mnahkies</span><span>|</span><a href="#39416986">parent</a><span>|</span><a href="#39417043">prev</a><span>|</span><a href="#39414424">next</a><span>|</span><label class="collapse" for="c-39417321">[-]</label><label class="expand" for="c-39417321">[1 more]</label></div><br/><div class="children"><div class="content">It can be really handy for scraping&#x2F;archiving websites if they&#x27;re kind enough to use a guessable id</div><br/></div></div></div></div><div id="39414424" class="c"><input type="checkbox" id="c-39414424" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39416986">prev</a><span>|</span><a href="#39415231">next</a><span>|</span><label class="collapse" for="c-39414424">[-]</label><label class="expand" for="c-39414424">[22 more]</label></div><br/><div class="children"><div class="content">&gt; <i>For example, Github had 128 million public repositories in 2020. Even with 20 issues per repository it will cross the serial range. Also changing the type of the table is expensive.</i><p>I expect the majority of those public repositories are forks of other repositories, and those forks only exist so someone could create pull requests against the main repository.  As such, they won&#x27;t ever have any issues, unless someone makes a mistake.<p>Beyond that, there are probably a lot of small, toy projects that have no issues at all, or at most a few.  Quickly-abandoned projects will suffer the same fate.<p>I suspect that even though there are certainly some projects with hundreds and thousands of issues, the average across all 128M of those repos is likely pretty small, probably keeping things well under the 2B limit.<p>Having said that, I agree that using a 4-byte type (well, 31-bit, really) for that table is a ticking time bomb for some orgs, github.com included.</div><br/><div id="39414873" class="c"><input type="checkbox" id="c-39414873" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#39414424">parent</a><span>|</span><a href="#39414594">next</a><span>|</span><label class="collapse" for="c-39414873">[-]</label><label class="expand" for="c-39414873">[5 more]</label></div><br/><div class="children"><div class="content">It is still under the limit today with 362,107,148 repositories and 818,516,506 unique issues and pull requests:<p><a href="https:&#x2F;&#x2F;play.clickhouse.com&#x2F;play?user=play#U0VMRUNUIHVuaXEocmVwb19uYW1lKSBBUyByZXBvcywgdW5pcShyZXBvX25hbWUsIG51bWJlcikgQVMgaXNzdWVzX2FuZF9wdWxsX3JlcXVlc3RzLCBpc3N1ZXNfYW5kX3B1bGxfcmVxdWVzdHMgLyByZXBvcyBGUk9NIGdpdGh1Yl9ldmVudHM=" rel="nofollow">https:&#x2F;&#x2F;play.clickhouse.com&#x2F;play?user=play#U0VMRUNUIHVuaXEoc...</a></div><br/><div id="39415984" class="c"><input type="checkbox" id="c-39415984" checked=""/><div class="controls bullet"><span class="by">ssalka</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39414873">parent</a><span>|</span><a href="#39415849">next</a><span>|</span><label class="collapse" for="c-39415984">[-]</label><label class="expand" for="c-39415984">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing this won&#x27;t be including issues &amp; PRs from private repos, which could be substantial</div><br/></div></div><div id="39415849" class="c"><input type="checkbox" id="c-39415849" checked=""/><div class="controls bullet"><span class="by">zx8080</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39414873">parent</a><span>|</span><a href="#39415984">prev</a><span>|</span><a href="#39414947">next</a><span>|</span><label class="collapse" for="c-39415849">[-]</label><label class="expand" for="c-39415849">[2 more]</label></div><br/><div class="children"><div class="content">Elapsed: 12.618 sec, read 7.13 billion rows, 42.77 GB<p>This is too long, seems the ORDER BY is not set up correctly for the table.</div><br/><div id="39415858" class="c"><input type="checkbox" id="c-39415858" checked=""/><div class="controls bullet"><span class="by">zx8080</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39415849">parent</a><span>|</span><a href="#39414947">next</a><span>|</span><label class="collapse" for="c-39415858">[-]</label><label class="expand" for="c-39415858">[1 more]</label></div><br/><div class="children"><div class="content">Also,<p>&gt; `repo_name` LowCardinality(String),<p>This is not a low cardinality:<p>7133122498 = 7.1B<p>Don&#x27;t use low cardinality for such columns!</div><br/></div></div></div></div><div id="39414947" class="c"><input type="checkbox" id="c-39414947" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39414873">parent</a><span>|</span><a href="#39415849">prev</a><span>|</span><a href="#39414594">next</a><span>|</span><label class="collapse" for="c-39414947">[-]</label><label class="expand" for="c-39414947">[1 more]</label></div><br/><div class="children"><div class="content">That query took a long time</div><br/></div></div></div></div><div id="39414594" class="c"><input type="checkbox" id="c-39414594" checked=""/><div class="controls bullet"><span class="by">rapfaria</span><span>|</span><a href="#39414424">parent</a><span>|</span><a href="#39414873">prev</a><span>|</span><a href="#39416867">next</a><span>|</span><label class="collapse" for="c-39414594">[-]</label><label class="expand" for="c-39414594">[11 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Having said that, I agree that using a 4-byte type (well, 31-bit, really) for that table is a ticking time bomb for some orgs</i><p>A bomb defused in a migration that takes eleven seconds</div><br/><div id="39414761" class="c"><input type="checkbox" id="c-39414761" checked=""/><div class="controls bullet"><span class="by">aeyes</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39414594">parent</a><span>|</span><a href="#39415049">next</a><span>|</span><label class="collapse" for="c-39414761">[-]</label><label class="expand" for="c-39414761">[6 more]</label></div><br/><div class="children"><div class="content">The migration has to rewrite the whole table, bigint needs 8 bytes so you have to make room for that.<p>I have done several such primary key migrations on tables with 500M+ records, they took anywhere from 30 to 120 minutes depending on the amount of columns and indexes. If you have foreign keys it can be even longer.<p>Edit: But there is another option which is logical replication. Change the type on your logical replica, then switch over. This way the downtime can be reduced to minutes.</div><br/><div id="39415338" class="c"><input type="checkbox" id="c-39415338" checked=""/><div class="controls bullet"><span class="by">semiquaver</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39414761">parent</a><span>|</span><a href="#39414848">next</a><span>|</span><label class="collapse" for="c-39415338">[-]</label><label class="expand" for="c-39415338">[2 more]</label></div><br/><div class="children"><div class="content">In practice the only option that I’ve seen work for very large teams and very large relational databases is online schema change tools like <a href="https:&#x2F;&#x2F;github.com&#x2F;shayonj&#x2F;pg-osc">https:&#x2F;&#x2F;github.com&#x2F;shayonj&#x2F;pg-osc</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;gh-ost">https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;gh-ost</a> (the latter developed for GitHub’s monolith). It’s just too difficult to model what migrations will cause problems under load. Using a binlog&#x2F;shadowtable approach for all migrations mostly obviates the problem.</div><br/><div id="39415736" class="c"><input type="checkbox" id="c-39415736" checked=""/><div class="controls bullet"><span class="by">CubsFan1060</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39415338">parent</a><span>|</span><a href="#39414848">next</a><span>|</span><label class="collapse" for="c-39415736">[-]</label><label class="expand" for="c-39415736">[1 more]</label></div><br/><div class="children"><div class="content">You can also migrate it using logical replication.</div><br/></div></div></div></div><div id="39414848" class="c"><input type="checkbox" id="c-39414848" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39414761">parent</a><span>|</span><a href="#39415338">prev</a><span>|</span><a href="#39415049">next</a><span>|</span><label class="collapse" for="c-39414848">[-]</label><label class="expand" for="c-39414848">[3 more]</label></div><br/><div class="children"><div class="content">This largely depends on the disk. I wouldn&#x27;t expect that to take 30mins on a modern NVME drive, but of course it depends on table size.</div><br/><div id="39415063" class="c"><input type="checkbox" id="c-39415063" checked=""/><div class="controls bullet"><span class="by">aeyes</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39414848">parent</a><span>|</span><a href="#39415049">next</a><span>|</span><label class="collapse" for="c-39415063">[-]</label><label class="expand" for="c-39415063">[2 more]</label></div><br/><div class="children"><div class="content">Disk wasn&#x27;t the limit in my case, index creation is single threaded.</div><br/><div id="39415431" class="c"><input type="checkbox" id="c-39415431" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39415063">parent</a><span>|</span><a href="#39415049">next</a><span>|</span><label class="collapse" for="c-39415431">[-]</label><label class="expand" for="c-39415431">[1 more]</label></div><br/><div class="children"><div class="content">Which is still very IO bound... Wonder what kinda IOPS you were observing? Also they make pretty fast CPUs these days :)</div><br/></div></div></div></div></div></div></div></div><div id="39415049" class="c"><input type="checkbox" id="c-39415049" checked=""/><div class="controls bullet"><span class="by">tengbretson</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39414594">parent</a><span>|</span><a href="#39414761">prev</a><span>|</span><a href="#39415955">next</a><span>|</span><label class="collapse" for="c-39415049">[-]</label><label class="expand" for="c-39415049">[3 more]</label></div><br/><div class="children"><div class="content">In JavaScript land, postgres bigints deserialize as strings. Is your application resilient to this? Are your downstream customers ready to handle that sort of schema change?<p>Running the db migration is the easy part.</div><br/><div id="39415191" class="c"><input type="checkbox" id="c-39415191" checked=""/><div class="controls bullet"><span class="by">Rapzid</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39415049">parent</a><span>|</span><a href="#39415955">next</a><span>|</span><label class="collapse" for="c-39415191">[-]</label><label class="expand" for="c-39415191">[2 more]</label></div><br/><div class="children"><div class="content">Depends on the lib. Max safe int size is like 9 quadrillion. You can safely deserialize serial bigints to this without ever worrying about hitting that limit in many domains.</div><br/><div id="39416414" class="c"><input type="checkbox" id="c-39416414" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39415191">parent</a><span>|</span><a href="#39415955">next</a><span>|</span><label class="collapse" for="c-39416414">[-]</label><label class="expand" for="c-39416414">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Max safe int size is like 9 quadrillion.<p>2^53, to be precise. If your application involves assigning a unique identifier to every ant on the planet Earth (approx. 10^15 ≈ 2^50), you might need to think about this. Otherwise, I wouldn&#x27;t worry about it.</div><br/></div></div></div></div></div></div><div id="39415955" class="c"><input type="checkbox" id="c-39415955" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39414594">parent</a><span>|</span><a href="#39415049">prev</a><span>|</span><a href="#39416867">next</a><span>|</span><label class="collapse" for="c-39415955">[-]</label><label class="expand" for="c-39415955">[1 more]</label></div><br/><div class="children"><div class="content">11 seconds won&#x27;t fix all your foreign keys. And all the code written against it that assumes an int type will accommodate the value.</div><br/></div></div></div></div><div id="39416867" class="c"><input type="checkbox" id="c-39416867" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#39414424">parent</a><span>|</span><a href="#39414594">prev</a><span>|</span><a href="#39415447">next</a><span>|</span><label class="collapse" for="c-39416867">[-]</label><label class="expand" for="c-39416867">[1 more]</label></div><br/><div class="children"><div class="content">Being two orders of magnitude away from running out of ids is too close for comfort anyway.</div><br/></div></div><div id="39415447" class="c"><input type="checkbox" id="c-39415447" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#39414424">parent</a><span>|</span><a href="#39416867">prev</a><span>|</span><a href="#39414547">next</a><span>|</span><label class="collapse" for="c-39415447">[-]</label><label class="expand" for="c-39415447">[3 more]</label></div><br/><div class="children"><div class="content">Do we know for sure if gitlab cloud uses a multi-tenanted database, or a db per user&#x2F;customer&#x2F;org? In my experience products that offer both a self hosted and cloud product tend to prefer a database per customer, as this greatly simplifies the shared parts of the codebase, which can use the same queries regardless of the hosting type.<p>If they use a db per customer then no one will ever approach those usage limits and if they do they would be better suited to a self hosted solution.</div><br/><div id="39417149" class="c"><input type="checkbox" id="c-39417149" checked=""/><div class="controls bullet"><span class="by">tcnj</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39415447">parent</a><span>|</span><a href="#39417049">next</a><span>|</span><label class="collapse" for="c-39417149">[-]</label><label class="expand" for="c-39417149">[1 more]</label></div><br/><div class="children"><div class="content">Unless something has substantially changed since I last checked, gitlab.com is essentially self-hosted gitlab ultimate with a few feature flags to enable some marginally different behaviour. That is, it uses one multitennant DB for the whole platform.</div><br/></div></div><div id="39417049" class="c"><input type="checkbox" id="c-39417049" checked=""/><div class="controls bullet"><span class="by">Maxion</span><span>|</span><a href="#39414424">root</a><span>|</span><a href="#39415447">parent</a><span>|</span><a href="#39417149">prev</a><span>|</span><a href="#39414547">next</a><span>|</span><label class="collapse" for="c-39417049">[-]</label><label class="expand" for="c-39417049">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve toyed with various SaaS designs and multi tenanted databses always come to th forefront of my mind. It seems to simplify the architecture a lot.</div><br/></div></div></div></div><div id="39414547" class="c"><input type="checkbox" id="c-39414547" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#39414424">parent</a><span>|</span><a href="#39415447">prev</a><span>|</span><a href="#39415231">next</a><span>|</span><label class="collapse" for="c-39414547">[-]</label><label class="expand" for="c-39414547">[1 more]</label></div><br/><div class="children"><div class="content">&gt; github.com included<p>Typo?</div><br/></div></div></div></div><div id="39415231" class="c"><input type="checkbox" id="c-39415231" checked=""/><div class="controls bullet"><span class="by">zetalyrae</span><span>|</span><a href="#39414424">prev</a><span>|</span><a href="#39416813">next</a><span>|</span><label class="collapse" for="c-39415231">[-]</label><label class="expand" for="c-39415231">[9 more]</label></div><br/><div class="children"><div class="content">The point about the storage size of UUID columns is unconvincing. 128 bits vs. 64 bits doesn&#x27;t matter much when the table has five other columns.<p>A much more salient concern for me is performance. UUIDv4 is widely supported but is completely random, which is not ideal for index performance. UUIDv7[0] is closer to Snowflake[1] and has some temporal locality but is less widely implemented.<p>There&#x27;s an orthogonal approach which is using bigserial and encrypting the keys: <a href="https:&#x2F;&#x2F;github.com&#x2F;abevoelker&#x2F;gfc64">https:&#x2F;&#x2F;github.com&#x2F;abevoelker&#x2F;gfc64</a><p>But this means 1) you can&#x27;t rotate the secret and 2) if it&#x27;s ever leaked everyone can now Fermi-estimate your table sizes.<p>Having separate public and internal IDs seems both tedious and sacrifices performance (if the public-facing ID is a UUIDv4).<p>I think UUIDv7 is the solution that checks the most boxes.<p>[0]: <a href="https:&#x2F;&#x2F;uuid7.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;uuid7.com&#x2F;</a><p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Snowflake_ID" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Snowflake_ID</a></div><br/><div id="39417394" class="c"><input type="checkbox" id="c-39417394" checked=""/><div class="controls bullet"><span class="by">s4i</span><span>|</span><a href="#39415231">parent</a><span>|</span><a href="#39415960">next</a><span>|</span><label class="collapse" for="c-39417394">[-]</label><label class="expand" for="c-39417394">[1 more]</label></div><br/><div class="children"><div class="content">The v7 isn’t a silver bullet. In many cases you don’t want to leak the creation time of a resource. E.g. you want to upload a video a month before making it public to your audience without them knowing.</div><br/></div></div><div id="39415960" class="c"><input type="checkbox" id="c-39415960" checked=""/><div class="controls bullet"><span class="by">Merad</span><span>|</span><a href="#39415231">parent</a><span>|</span><a href="#39417394">prev</a><span>|</span><a href="#39415747">next</a><span>|</span><label class="collapse" for="c-39415960">[-]</label><label class="expand" for="c-39415960">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The point about the storage size of UUID columns is unconvincing. 128 bits vs. 64 bits doesn&#x27;t matter much when the table has five other columns.<p>But it&#x27;s not just the size of that one column, it&#x27;s also the size of all the places that id is used as a FK and the indexes that may be needed on those FK columns.  Think about something like a user id that might be referenced by dozens or even hundreds of FKs throughout your database.</div><br/></div></div><div id="39415747" class="c"><input type="checkbox" id="c-39415747" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#39415231">parent</a><span>|</span><a href="#39415960">prev</a><span>|</span><a href="#39416821">next</a><span>|</span><label class="collapse" for="c-39415747">[-]</label><label class="expand" for="c-39415747">[1 more]</label></div><br/><div class="children"><div class="content">think of the primary keys in a database like typedef void* ie it&#x27;s your fundamental pointer and the size of it will impact every aspect of performance throughout - memory&#x2F;disk footprint and corresponding throughput bottlenecks, cpu time comparing keys which is what every operation reduces to in the deepest inner-most loops of joins and lookups etc.<p>when x86-64 cpus were new the performance impact from switching to 64-bit pointers was so bad we had to create x32&#x2F;ilp32 and the reason .NET still has &quot;prefer 32-bit&quot; as a default even today.<p>using 128-bit uuids as PKs in a database is an awful mistake</div><br/></div></div><div id="39416821" class="c"><input type="checkbox" id="c-39416821" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#39415231">parent</a><span>|</span><a href="#39415747">prev</a><span>|</span><a href="#39415580">next</a><span>|</span><label class="collapse" for="c-39416821">[-]</label><label class="expand" for="c-39416821">[1 more]</label></div><br/><div class="children"><div class="content">It very much does when you have a ton of FKs (enforced or not) using such a column, and thus indexed and used in many joins. Making it twice as hard for the hot part of an index to fit to RAM is never good for performance, nor for the cloud bill.<p>If you have a column that is used in many joins, there are performance reasons to make it as compact as possible (but not smaller).</div><br/></div></div><div id="39415580" class="c"><input type="checkbox" id="c-39415580" checked=""/><div class="controls bullet"><span class="by">canadiantim</span><span>|</span><a href="#39415231">parent</a><span>|</span><a href="#39416821">prev</a><span>|</span><a href="#39415254">next</a><span>|</span><label class="collapse" for="c-39415580">[-]</label><label class="expand" for="c-39415580">[3 more]</label></div><br/><div class="children"><div class="content">Would it ever make sense to have a uuidv7 as primary key but then anther slug field for a public-id, e.g. one that is shorter and better in a url or even allowing user to customize it?</div><br/><div id="39415790" class="c"><input type="checkbox" id="c-39415790" checked=""/><div class="controls bullet"><span class="by">Horffupolde</span><span>|</span><a href="#39415231">root</a><span>|</span><a href="#39415580">parent</a><span>|</span><a href="#39415254">next</a><span>|</span><label class="collapse" for="c-39415790">[-]</label><label class="expand" for="c-39415790">[2 more]</label></div><br/><div class="children"><div class="content">Yes sure but now you have to handle two ids and guaranteeing uniqueness across machines or clusters becomes hard.</div><br/><div id="39415933" class="c"><input type="checkbox" id="c-39415933" checked=""/><div class="controls bullet"><span class="by">vrosas</span><span>|</span><a href="#39415231">root</a><span>|</span><a href="#39415790">parent</a><span>|</span><a href="#39415254">next</a><span>|</span><label class="collapse" for="c-39415933">[-]</label><label class="expand" for="c-39415933">[1 more]</label></div><br/><div class="children"><div class="content">That and a uuid is going to be unique across all tables and objects, whereas a slug will only be unique within a certain subset e.g. users within an organization. I’ve seen a production issue IRL where someone (definitely not me) wrote a query fetching objects by slug and forgot to include the ‘AND parent_slug = xxx’</div><br/></div></div></div></div></div></div></div></div><div id="39416813" class="c"><input type="checkbox" id="c-39416813" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#39415231">prev</a><span>|</span><a href="#39415351">next</a><span>|</span><label class="collapse" for="c-39416813">[-]</label><label class="expand" for="c-39416813">[1 more]</label></div><br/><div class="children"><div class="content">Foreign keys are expensive is an oft repeated rarely benched claim. There are tons of ways to do it incorrectly. But in your stack you are always enforcing integrity _somewhere_ anyway. Leveraging the database instead of reimplementing it requires knowledge and experimentation, and it more often than not it will save your bacon.</div><br/></div></div><div id="39415351" class="c"><input type="checkbox" id="c-39415351" checked=""/><div class="controls bullet"><span class="by">bluerooibos</span><span>|</span><a href="#39416813">prev</a><span>|</span><a href="#39414952">next</a><span>|</span><label class="collapse" for="c-39415351">[-]</label><label class="expand" for="c-39415351">[6 more]</label></div><br/><div class="children"><div class="content">Has anyone written about or noticed the performance differences between Gitlab and GitHub?<p>They&#x27;re both Rails-based applications but I find page load times on Gitlab in general to be horrific compared to GitHub.</div><br/><div id="39415637" class="c"><input type="checkbox" id="c-39415637" checked=""/><div class="controls bullet"><span class="by">heyoni</span><span>|</span><a href="#39415351">parent</a><span>|</span><a href="#39416788">prev</a><span>|</span><a href="#39416871">next</a><span>|</span><label class="collapse" for="c-39415637">[-]</label><label class="expand" for="c-39415637">[3 more]</label></div><br/><div class="children"><div class="content">I mean GitHub in general has been pretty reliable minus the two outages they had last year and is usually pretty performant or I wouldn’t use their keyboard shortcuts.<p>There are some complaints here from a former dev about gitlab that might provide insight into its culture and lack of regard for performance: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39303323">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39303323</a><p>Ps: I do not use gitlab enough to notice performance issues but thought you might appreciate the article</div><br/><div id="39417227" class="c"><input type="checkbox" id="c-39417227" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#39415351">root</a><span>|</span><a href="#39415637">parent</a><span>|</span><a href="#39415855">next</a><span>|</span><label class="collapse" for="c-39417227">[-]</label><label class="expand" for="c-39417227">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I mean GitHub in general has been pretty reliable minus the two outages they had last year<p>Huh? GitHub has had major outages practically every other week for a few years now. There are pages of HN threads[1].<p>There&#x27;s a reason why githubstatus.com doesn&#x27;t show historical metrics and uptime percentages: it would make them look incompetent. Many outages aren&#x27;t even officially reported there.<p>I do agree that when it&#x27;s up, performance is typically better than Gitlab&#x27;s. But describing GH as reliable is delusional.<p>[1]: <a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=false&amp;query=&quot;Github%20is%20down&quot;&amp;sort=byDate&amp;type=story" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=false&amp;qu...</a></div><br/></div></div><div id="39415855" class="c"><input type="checkbox" id="c-39415855" checked=""/><div class="controls bullet"><span class="by">anoopelias</span><span>|</span><a href="#39415351">root</a><span>|</span><a href="#39415637">parent</a><span>|</span><a href="#39417227">prev</a><span>|</span><a href="#39416871">next</a><span>|</span><label class="collapse" for="c-39415855">[-]</label><label class="expand" for="c-39415855">[1 more]</label></div><br/><div class="children"><div class="content">More comments on this submission: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39333220">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39333220</a></div><br/></div></div></div></div><div id="39416871" class="c"><input type="checkbox" id="c-39416871" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#39415351">parent</a><span>|</span><a href="#39415637">prev</a><span>|</span><a href="#39414952">next</a><span>|</span><label class="collapse" for="c-39416871">[-]</label><label class="expand" for="c-39416871">[1 more]</label></div><br/><div class="children"><div class="content">I used Gitlab a few years ago, but then it had severe client-side performance problems on large pull requests. Github isn&#x27;t ideal with them too, but it manages to be decent.</div><br/></div></div></div></div><div id="39414952" class="c"><input type="checkbox" id="c-39414952" checked=""/><div class="controls bullet"><span class="by">vinnymac</span><span>|</span><a href="#39415351">prev</a><span>|</span><a href="#39416881">next</a><span>|</span><label class="collapse" for="c-39414952">[-]</label><label class="expand" for="c-39414952">[1 more]</label></div><br/><div class="children"><div class="content">I always wondered what the purpose of that extra “I” was in the CI variables `CI_PIPELINE_IID` and `CI_MERGE_REQUEST_IID` were for. Always assumed it was a database related choice, but this article confirms it.</div><br/></div></div><div id="39416881" class="c"><input type="checkbox" id="c-39416881" checked=""/><div class="controls bullet"><span class="by">rob137</span><span>|</span><a href="#39414952">prev</a><span>|</span><a href="#39415579">next</a><span>|</span><label class="collapse" for="c-39416881">[-]</label><label class="expand" for="c-39416881">[1 more]</label></div><br/><div class="children"><div class="content">I found this post very useful. I&#x27;m wondering where I could find others like it?</div><br/></div></div><div id="39415579" class="c"><input type="checkbox" id="c-39415579" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#39416881">prev</a><span>|</span><a href="#39414627">next</a><span>|</span><label class="collapse" for="c-39415579">[-]</label><label class="expand" for="c-39415579">[4 more]</label></div><br/><div class="children"><div class="content">&gt; 1 quintillion is equal to 1000000000 billions<p>it is pretty wild that we generally choose between int32 and int64. we really ought to have a 5 byte integer type which would support cardinalities of ~1T</div><br/><div id="39415697" class="c"><input type="checkbox" id="c-39415697" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#39415579">parent</a><span>|</span><a href="#39414627">next</a><span>|</span><label class="collapse" for="c-39415697">[-]</label><label class="expand" for="c-39415697">[3 more]</label></div><br/><div class="children"><div class="content">Yeah it doesn&#x27;t make sense to pick something that&#x27;s not a power of 2 unless you are packing it.</div><br/><div id="39415757" class="c"><input type="checkbox" id="c-39415757" checked=""/><div class="controls bullet"><span class="by">postalrat</span><span>|</span><a href="#39415579">root</a><span>|</span><a href="#39415697">parent</a><span>|</span><a href="#39415801">next</a><span>|</span><label class="collapse" for="c-39415757">[-]</label><label class="expand" for="c-39415757">[1 more]</label></div><br/><div class="children"><div class="content">I guess that depends on how the index works.</div><br/></div></div><div id="39415801" class="c"><input type="checkbox" id="c-39415801" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#39415579">root</a><span>|</span><a href="#39415697">parent</a><span>|</span><a href="#39415757">prev</a><span>|</span><a href="#39414627">next</a><span>|</span><label class="collapse" for="c-39415801">[-]</label><label class="expand" for="c-39415801">[1 more]</label></div><br/><div class="children"><div class="content">we usually work with some page size anyways, 64 5-byte ints fit nicely into 5 512-bit registers, and ~1T is a pretty flexible cardinality limit after ~2B</div><br/></div></div></div></div></div></div><div id="39414627" class="c"><input type="checkbox" id="c-39414627" checked=""/><div class="controls bullet"><span class="by">martinald</span><span>|</span><a href="#39415579">prev</a><span>|</span><a href="#39414646">next</a><span>|</span><label class="collapse" for="c-39414627">[-]</label><label class="expand" for="c-39414627">[20 more]</label></div><br/><div class="children"><div class="content">Is it just me that thinks in general schema design and development is stuck in the stone ages?<p>I mainly know dotnet stuff, which does have migrations in EF (I note the point about gitlab not using this kind of thing because of database compatibility). It can point out common data loss while doing them.<p>However, it still is always quite scary doing migrations, especially bigger ones refactoring something. Throw into this jsonb columns and I feel it is really easy to screw things up and suffer bad data loss.<p>For example, renaming a column (at least in EF) will result in a column drop and column create on the autogenerated migrations. Why can&#x27;t I give the compiler&#x2F;migration tool more context on this easily?<p>Also the point about external IDs and internal IDs - why can&#x27;t the database&#x2F;ORM do this more automatically?<p>I feel there really hasn&#x27;t been much progress on this since migration tooling came around 10+ years ago. I know ORMs are leaky abstractions, but I feel everyone reinvents this stuff themselves and every project does these common things a different way.<p>Are there any tools people use for this?</div><br/><div id="39414700" class="c"><input type="checkbox" id="c-39414700" checked=""/><div class="controls bullet"><span class="by">sjwhevvvvvsj</span><span>|</span><a href="#39414627">parent</a><span>|</span><a href="#39415910">next</a><span>|</span><label class="collapse" for="c-39414700">[-]</label><label class="expand" for="c-39414700">[7 more]</label></div><br/><div class="children"><div class="content">One thing I like about hand designing schema is it makes you sit down and make very clear choices about what your data is, how it interrelates, and how you’ll use it.  You understand your own goals more clearly.</div><br/><div id="39414978" class="c"><input type="checkbox" id="c-39414978" checked=""/><div class="controls bullet"><span class="by">nly</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39414700">parent</a><span>|</span><a href="#39415415">next</a><span>|</span><label class="collapse" for="c-39414978">[-]</label><label class="expand" for="c-39414978">[2 more]</label></div><br/><div class="children"><div class="content">Exactly that. Sitting down and thinking about your data structures and APIs before you start writing code seems to be a fading skill.</div><br/><div id="39415041" class="c"><input type="checkbox" id="c-39415041" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39414978">parent</a><span>|</span><a href="#39415415">next</a><span>|</span><label class="collapse" for="c-39415041">[-]</label><label class="expand" for="c-39415041">[1 more]</label></div><br/><div class="children"><div class="content">It absolutely shows in the final product, too.<p>I wish more companies evaluated the suitability of software based on reviewing the back-end data storage schema. A lot of sins can be hidden in the application layer but many become glaringly obvious when you look at how the data is represented and stored.</div><br/></div></div></div></div><div id="39415415" class="c"><input type="checkbox" id="c-39415415" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39414700">parent</a><span>|</span><a href="#39414978">prev</a><span>|</span><a href="#39415910">next</a><span>|</span><label class="collapse" for="c-39415415">[-]</label><label class="expand" for="c-39415415">[4 more]</label></div><br/><div class="children"><div class="content">So many people I encounter seem to think it’s the code that’s important when building the back end of an application. You see this when people discussing database schemas start comparing, say, rails to hibernate. But ORMs emphasise code instead of data, which in my experience is a big mistake.<p>In my experience, getting the data structures right is 99% of the battle. If you get that right, the code that follows is simple and obvious.<p>For database applications, this means getting the schema right. To this end, I always start with the underlying table structures, and only start coding once I understand how the various tables are going to interact.<p>Sadly, too many people think of the database as the annoying hoops we jump through in order to store the results of our code. In my world, the code I write is the minimum required to safely manipulate the database; it’s the data that counts.<p>Some people seem to think I’m weird for starting with the database (and for using plpgsql), but I think it’s actually a superpower.</div><br/><div id="39416212" class="c"><input type="checkbox" id="c-39416212" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39415415">parent</a><span>|</span><a href="#39416275">next</a><span>|</span><label class="collapse" for="c-39416212">[-]</label><label class="expand" for="c-39416212">[1 more]</label></div><br/><div class="children"><div class="content">This is true for in memory data as well. Object oriented programming is great for some problems, but it&#x27;s also limiting the way we think about data by putting it close to the code operating on it. ORMs do the same to databases by pretending that rows are objects when that&#x27;s only one way of modeling your problem.</div><br/></div></div><div id="39416275" class="c"><input type="checkbox" id="c-39416275" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39415415">parent</a><span>|</span><a href="#39416212">prev</a><span>|</span><a href="#39416235">next</a><span>|</span><label class="collapse" for="c-39416275">[-]</label><label class="expand" for="c-39416275">[1 more]</label></div><br/><div class="children"><div class="content">It’s part of the dirty little secret of why document databases and other NoSQL systems became popular.<p>Required even less up front thinking about how to model your data.  Throw some blobs of JSON into Mongo or whatever, and worry about the rest later.</div><br/></div></div><div id="39416235" class="c"><input type="checkbox" id="c-39416235" checked=""/><div class="controls bullet"><span class="by">sjwhevvvvvsj</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39415415">parent</a><span>|</span><a href="#39416275">prev</a><span>|</span><a href="#39415910">next</a><span>|</span><label class="collapse" for="c-39416235">[-]</label><label class="expand" for="c-39416235">[1 more]</label></div><br/><div class="children"><div class="content">Yup - and you can’t code your way to real scale either. At real scale the game is all about data structures. Code just gets them from A to B.<p>Or as they say at Google, the job of SWE is “moving protos”.</div><br/></div></div></div></div></div></div><div id="39415910" class="c"><input type="checkbox" id="c-39415910" checked=""/><div class="controls bullet"><span class="by">timacles</span><span>|</span><a href="#39414627">parent</a><span>|</span><a href="#39414700">prev</a><span>|</span><a href="#39416038">next</a><span>|</span><label class="collapse" for="c-39415910">[-]</label><label class="expand" for="c-39415910">[1 more]</label></div><br/><div class="children"><div class="content">Theres no right abstraction for it because everyones data is different. From my experience what most developers dont realize is that data is more complex than code. Code is merely the stuff that sits on top of the data, shuffling it around... but designing and handling the data in an efficient way is the real engineering problem.<p>Any abstraction you could come up with wouldnt fit 90% of the other cases</div><br/></div></div><div id="39416038" class="c"><input type="checkbox" id="c-39416038" checked=""/><div class="controls bullet"><span class="by">Merad</span><span>|</span><a href="#39414627">parent</a><span>|</span><a href="#39415910">prev</a><span>|</span><a href="#39414768">next</a><span>|</span><label class="collapse" for="c-39416038">[-]</label><label class="expand" for="c-39416038">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also the point about external IDs and internal IDs - why can&#x27;t the database&#x2F;ORM do this more automatically?<p>It has pretty big implications for how your application code interacts with the database.  Queries that involve id&#x27;s will need to perform joins in order to check the external id.  Inserts or updates that need to set a foreign key need to perform an extra lookup to map the external id to the correct FK value (whether it&#x27;s literally a separate query or a CTE&#x2F;subquery).  Those are things that are way outside the realm of what EF can handle automatically, at least as it exists today.</div><br/></div></div><div id="39414768" class="c"><input type="checkbox" id="c-39414768" checked=""/><div class="controls bullet"><span class="by">Atotalnoob</span><span>|</span><a href="#39414627">parent</a><span>|</span><a href="#39416038">prev</a><span>|</span><a href="#39414854">next</a><span>|</span><label class="collapse" for="c-39414768">[-]</label><label class="expand" for="c-39414768">[1 more]</label></div><br/><div class="children"><div class="content">EF core doesn’t to drop&#x2F;create for columns in db providers that support renaming columns. It only does it for ones that don’t like MySQL or SQLite</div><br/></div></div><div id="39414854" class="c"><input type="checkbox" id="c-39414854" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#39414627">parent</a><span>|</span><a href="#39414768">prev</a><span>|</span><a href="#39416240">next</a><span>|</span><label class="collapse" for="c-39414854">[-]</label><label class="expand" for="c-39414854">[7 more]</label></div><br/><div class="children"><div class="content">Not a silver bullet for every project but the Django ORM largely solves this with its migrations. You define your table classes and it just generates the migrations.<p>Throw in a type checker and you&#x27;re in pretty good shape.<p>Rust also has sqlx which will type check your code against the DB.</div><br/><div id="39414986" class="c"><input type="checkbox" id="c-39414986" checked=""/><div class="controls bullet"><span class="by">dxdm</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39414854">parent</a><span>|</span><a href="#39415476">next</a><span>|</span><label class="collapse" for="c-39414986">[-]</label><label class="expand" for="c-39414986">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m assuming this is why you say it&#x27;s not a silver bullet, but to make it more explicit: the Django ORM will happily generate migrations that will lock crucial tables for long amounts of time and bring down your production application in the process.<p>You still need to know what SQL the migration will run (take a look at  `manage.py sqlmigrate`) and most importantly how your database will apply it.</div><br/><div id="39415045" class="c"><input type="checkbox" id="c-39415045" checked=""/><div class="controls bullet"><span class="by">basil-rash</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39414986">parent</a><span>|</span><a href="#39415476">next</a><span>|</span><label class="collapse" for="c-39415045">[-]</label><label class="expand" for="c-39415045">[2 more]</label></div><br/><div class="children"><div class="content">Dealing with a bunch of automigrate headaches in the Prisma ORM convinced me to just drop the layer entirely and write plain old SQL everywhere. It’s forced me to learn a bunch of new stuff, but the app runs faster now that I can optimize every query and migrations are much simpler with a single idempotent SQL setup script I can run to provision whatever deployment of the DB I need. I’m sure some problem spaces might benefit from all the additional complexity and abstraction, but the average app certainly can make do without for a long time.</div><br/><div id="39417098" class="c"><input type="checkbox" id="c-39417098" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39415045">parent</a><span>|</span><a href="#39415476">next</a><span>|</span><label class="collapse" for="c-39417098">[-]</label><label class="expand" for="c-39417098">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a tradeoff! I think using the ORM to start and then move off it later is valid, depending on how much time you have to get an MVP out.</div><br/></div></div></div></div></div></div><div id="39415476" class="c"><input type="checkbox" id="c-39415476" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39414854">parent</a><span>|</span><a href="#39414986">prev</a><span>|</span><a href="#39416240">next</a><span>|</span><label class="collapse" for="c-39415476">[-]</label><label class="expand" for="c-39415476">[3 more]</label></div><br/><div class="children"><div class="content">An ORM is NEVER the solution, ever ever ever. Repeat after me: ORMs are not the solution to this problem. They work in your little toy apps with 4 customers but they are nothing but pain on real enterprise grade software.</div><br/><div id="39416515" class="c"><input type="checkbox" id="c-39416515" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39415476">parent</a><span>|</span><a href="#39416463">next</a><span>|</span><label class="collapse" for="c-39416515">[-]</label><label class="expand" for="c-39416515">[1 more]</label></div><br/><div class="children"><div class="content">also, every company I&#x27;ve worked at used ORMs in some capacity. Sometimes, not always.<p>Also, I don&#x27;t really work on any apps with only four customers. either they have almost a million or zero :P Try again. :)</div><br/></div></div><div id="39416463" class="c"><input type="checkbox" id="c-39416463" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#39414627">root</a><span>|</span><a href="#39415476">parent</a><span>|</span><a href="#39416515">prev</a><span>|</span><a href="#39416240">next</a><span>|</span><label class="collapse" for="c-39416463">[-]</label><label class="expand" for="c-39416463">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think insults are really necessary here.<p>Also ORMs can be very useful, just don&#x27;t do dumb stuff, like with any technology.<p>I use them when appropriate.</div><br/></div></div></div></div></div></div><div id="39416240" class="c"><input type="checkbox" id="c-39416240" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#39414627">parent</a><span>|</span><a href="#39414854">prev</a><span>|</span><a href="#39414707">next</a><span>|</span><label class="collapse" for="c-39416240">[-]</label><label class="expand" for="c-39416240">[1 more]</label></div><br/><div class="children"><div class="content">I think that stuff works about as well as it possibly could.  If you think that&#x27;s painful think about something like DynamoDB where if you didn&#x27;t really think through the access patterns up front you&#x27;re in for a world of pain.</div><br/></div></div><div id="39414707" class="c"><input type="checkbox" id="c-39414707" checked=""/><div class="controls bullet"><span class="by">cschmatzler</span><span>|</span><a href="#39414627">parent</a><span>|</span><a href="#39416240">prev</a><span>|</span><a href="#39414646">next</a><span>|</span><label class="collapse" for="c-39414707">[-]</label><label class="expand" for="c-39414707">[1 more]</label></div><br/><div class="children"><div class="content">If you use MySQL, Planetscale’s branching is really amazing. Not using them, but wish I could for that. Gives you a complete diff of what you’re doing, and can also pre-plan migrations and only apply them when you need with their gating.</div><br/></div></div></div></div><div id="39414646" class="c"><input type="checkbox" id="c-39414646" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#39414627">prev</a><span>|</span><a href="#39416706">next</a><span>|</span><label class="collapse" for="c-39414646">[-]</label><label class="expand" for="c-39414646">[4 more]</label></div><br/><div class="children"><div class="content">&gt; As I discussed in an earlier post[3] when you use Postgres native UUID v4 type instead of bigserial table size grows by 25% and insert rate drops to 25% of bigserial. This is a big difference.<p>Does anyone know why UUIDv4 is so much worse than bigserial? UUIDs are just 128 bit numbers. Are they super expensive to generate or something? Whats going on here?</div><br/><div id="39414747" class="c"><input type="checkbox" id="c-39414747" checked=""/><div class="controls bullet"><span class="by">AprilArcus</span><span>|</span><a href="#39414646">parent</a><span>|</span><a href="#39416674">next</a><span>|</span><label class="collapse" for="c-39414747">[-]</label><label class="expand" for="c-39414747">[1 more]</label></div><br/><div class="children"><div class="content">UUIDv4s are fully random, and btree indices expect &quot;right-leaning&quot; values with a sensible ordering. This makes indexing operations on UUIDv4 columns slow, and was the motivation for the development of UUIDv6 and UUIDv7.</div><br/></div></div><div id="39416674" class="c"><input type="checkbox" id="c-39416674" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#39414646">parent</a><span>|</span><a href="#39414747">prev</a><span>|</span><a href="#39414754">next</a><span>|</span><label class="collapse" for="c-39416674">[-]</label><label class="expand" for="c-39416674">[1 more]</label></div><br/><div class="children"><div class="content">Random distribution in the sort order mean the cache locality of a btree is poor - instead of inserts going to the last page, they go all over the place. Locality of batch inserts is also then bad at retrieval time, where related records are looked up randomly later.<p>So you pay taxes at both insert time and later during selection.</div><br/></div></div><div id="39414754" class="c"><input type="checkbox" id="c-39414754" checked=""/><div class="controls bullet"><span class="by">stephen123</span><span>|</span><a href="#39414646">parent</a><span>|</span><a href="#39416674">prev</a><span>|</span><a href="#39416706">next</a><span>|</span><label class="collapse" for="c-39414754">[-]</label><label class="expand" for="c-39414754">[1 more]</label></div><br/><div class="children"><div class="content">I think its because of btrees. Btrees and the pages work better if only the last page is getting lots of writes.
Iuids cause lots of un ordered writes leading to page bloat.</div><br/></div></div></div></div><div id="39416706" class="c"><input type="checkbox" id="c-39416706" checked=""/><div class="controls bullet"><span class="by">sidcool</span><span>|</span><a href="#39414646">prev</a><span>|</span><a href="#39415657">next</a><span>|</span><label class="collapse" for="c-39416706">[-]</label><label class="expand" for="c-39416706">[1 more]</label></div><br/><div class="children"><div class="content">Great read!  And even better comments here.</div><br/></div></div></div></div></div></div></div></body></html>