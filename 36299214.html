<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686733268785" as="style"/><link rel="stylesheet" href="styles.css?v=1686733268785"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://typex.fly.dev">Elixir&#x27;s “Set Theoretical Type System” prototype/demo/showcase</a> <span class="domain">(<a href="https://typex.fly.dev">typex.fly.dev</a>)</span></div><div class="subtext"><span>weatherlight</span> | <span>20 comments</span></div><br/><div><div id="36323239" class="c"><input type="checkbox" id="c-36323239" checked=""/><div class="controls bullet"><span class="by">commitpizza</span><span>|</span><a href="#36320627">next</a><span>|</span><label class="collapse" for="c-36323239">[-]</label><label class="expand" for="c-36323239">[1 more]</label></div><br/><div class="children"><div class="content">I watch elixir from a distance and don&#x27;t have that much practical experience in it but this looks like it&#x27;s too hard to read in order to be that useful imo.<p>At least I wouldn&#x27;t use it mostly because of the paranthesis and I really do hope that it&#x27;s going to be optional if it were to be implemented. I do write code in typed languages on a daily basis but I do think it&#x27;s overrated especially here on HN. I like that Elixir is dynamically typed and I think that it&#x27;s just something that&#x27;s not really in fashion at the moment but it will come around, eventually.</div><br/></div></div><div id="36320627" class="c"><input type="checkbox" id="c-36320627" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#36323239">prev</a><span>|</span><a href="#36321876">next</a><span>|</span><label class="collapse" for="c-36320627">[-]</label><label class="expand" for="c-36320627">[7 more]</label></div><br/><div class="children"><div class="content">We were 100% not expecting this to show up on HN front page. :)<p>In any case, the title is accurate in that it is only a prototype and it was built by Guillaume to explore how Elixir idioms map to set-theoretic types. The UX and syntax do not reflect how the type system would look in Elixir itself (if we get a type system at all).<p>You can find more context in Guillaume’s talk: <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=gJJH7a2J9O8">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=gJJH7a2J9O8</a><p>The initial research announcement: <a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2022&#x2F;10&#x2F;05&#x2F;my-future-with-elixir-set-theoretic-types&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2022&#x2F;10&#x2F;05&#x2F;my-future-with-elixi...</a><p>And the paper as an accurate and in-depth resource: <a href="https:&#x2F;&#x2F;www.irif.fr&#x2F;_media&#x2F;users&#x2F;gduboc&#x2F;elixir-types.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.irif.fr&#x2F;_media&#x2F;users&#x2F;gduboc&#x2F;elixir-types.pdf</a></div><br/><div id="36320783" class="c"><input type="checkbox" id="c-36320783" checked=""/><div class="controls bullet"><span class="by">lambdasquirrel</span><span>|</span><a href="#36320627">parent</a><span>|</span><a href="#36320969">next</a><span>|</span><label class="collapse" for="c-36320783">[-]</label><label class="expand" for="c-36320783">[2 more]</label></div><br/><div class="children"><div class="content">I took a quick glance at the paper. It sounds like initial efforts on a type system focused on trying to capture the whole space of programs that could be expressed? Whereas later efforts have focused more on how modern functional languages are meant to be used? (e.g. there’s an exhaustivity checker)<p>This seems like really good news. It’s exciting to see where this goes.</div><br/><div id="36322866" class="c"><input type="checkbox" id="c-36322866" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#36320627">root</a><span>|</span><a href="#36320783">parent</a><span>|</span><a href="#36320969">next</a><span>|</span><label class="collapse" for="c-36322866">[-]</label><label class="expand" for="c-36322866">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. It was very important for us to figure out how well Elixir fits the type system, otherwise we would either get false positives or we would end-up relying too much on gradual typing. The other effort was to make sure we can lift as much information from pattern matching and guards.</div><br/></div></div></div></div><div id="36320969" class="c"><input type="checkbox" id="c-36320969" checked=""/><div class="controls bullet"><span class="by">bongobingo1</span><span>|</span><a href="#36320627">parent</a><span>|</span><a href="#36320783">prev</a><span>|</span><a href="#36322812">next</a><span>|</span><label class="collapse" for="c-36320969">[-]</label><label class="expand" for="c-36320969">[3 more]</label></div><br/><div class="children"><div class="content">My understanding is (from your twitch stream), that the type system will <i>initially</i> be obscured from developers. I guess this means it&#x27;s going to hook into the existing `type` and `spec` features of elixir?<p>Do you think we&#x27;ll end up writing<p><pre><code>    $ integer() -&gt; integer()
    @spec inc(integer) :: integer()
    def inc(i), do: i + 1
</code></pre>
or can the new type system be entirely expressed in `@spec` (perhaps with a slightly upgraded syntax), or perhaps we&#x27;ll have the choice of @spec <i>or</i> $ (or @spec2.0, whatever).<p>Additionally, do you feel there is any chance&#x2F;desire&#x2F;need of this bleeding up into Erlang? I can only assume the work done mapping the type system onto elixir would not require <i>as</i> much work to then map to Erlang if there were any interest.</div><br/><div id="36322885" class="c"><input type="checkbox" id="c-36322885" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#36320627">root</a><span>|</span><a href="#36320969">parent</a><span>|</span><a href="#36321959">next</a><span>|</span><label class="collapse" for="c-36322885">[-]</label><label class="expand" for="c-36322885">[1 more]</label></div><br/><div class="children"><div class="content">Initially we will only leverage information from pattern matching and guards. There are no plans to leverage typespecs for now (as someone said below, they likely won&#x27;t be as precise).<p>And yes, the semantics should map 100% cleanly to Erlang.</div><br/></div></div><div id="36321959" class="c"><input type="checkbox" id="c-36321959" checked=""/><div class="controls bullet"><span class="by">manusachi</span><span>|</span><a href="#36320627">root</a><span>|</span><a href="#36320969">parent</a><span>|</span><a href="#36322885">prev</a><span>|</span><a href="#36322812">next</a><span>|</span><label class="collapse" for="c-36321959">[-]</label><label class="expand" for="c-36321959">[1 more]</label></div><br/><div class="children"><div class="content">AFAIR, it should be possible to convert dialyzer specs to that new type system annotations. It would probably be not as precise, but could be a good enough starting point to then gradually make them more precise</div><br/></div></div></div></div><div id="36322812" class="c"><input type="checkbox" id="c-36322812" checked=""/><div class="controls bullet"><span class="by">asymmetric</span><span>|</span><a href="#36320627">parent</a><span>|</span><a href="#36320969">prev</a><span>|</span><a href="#36321876">next</a><span>|</span><label class="collapse" for="c-36322812">[-]</label><label class="expand" for="c-36322812">[1 more]</label></div><br/><div class="children"><div class="content">Just wanted to say that the paper is extremely readable and well-written. Congrats to the authors!</div><br/></div></div></div></div><div id="36321876" class="c"><input type="checkbox" id="c-36321876" checked=""/><div class="controls bullet"><span class="by">some_thoughts</span><span>|</span><a href="#36320627">prev</a><span>|</span><a href="#36308415">next</a><span>|</span><label class="collapse" for="c-36321876">[-]</label><label class="expand" for="c-36321876">[6 more]</label></div><br/><div class="children"><div class="content">So I have very little experience with elixir, but I appreciate the effort to bring static typing. With that said, I find the use of parenthesis pretty hard to read. As in I need to spend more time than a quick glance to grok what&#x27;s going on. Maybe it&#x27;s because I&#x27;m not familiar with the ecosystem, but coming from a typescript, python, and go background mostly, I find this<p>negate :: ((integer() -&gt; integer()) and
           (true -&gt; false) and (false -&gt; true) and 
           (a -&gt; a) when a: not(integer() or boolean()))<p>harder to reason about quickly than say this<p>negate :: (int -&gt; int) &amp; (true -&gt; false) &amp; (false -&gt; true) &amp; (a -&gt; a)
            when a: ~(int | boolean)<p>Is there a reason that syntax was chosen? Is it just for showcasing purposes or is that basically just how the language works?</div><br/><div id="36322927" class="c"><input type="checkbox" id="c-36322927" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#36321876">parent</a><span>|</span><a href="#36322027">next</a><span>|</span><label class="collapse" for="c-36322927">[-]</label><label class="expand" for="c-36322927">[1 more]</label></div><br/><div class="children"><div class="content">For the paper, we have decided to go as precise as possible, since its goal is to discuss the type-system semantics and not its syntax, so parentheses are everywhere.<p>You will for sure be able to drop the outer parens in your case and you _may_ be able to drop them on the function types too (to be decided). Ending up with something like this:<p><pre><code>    $ (integer -&gt; integer) and (true -&gt; false) and (false -&gt; true) and (a -&gt; a) when a: not(integer or boolean)
    def negate(arg)
</code></pre>
We will also allow intersections to be broken across multiple declarations:<p><pre><code>    $ integer -&gt; integer
    $ true -&gt; false
    $ false -&gt; true
    $ a -&gt; a when a: not(integer or boolean)
    def negate(arg)</code></pre></div><br/></div></div><div id="36322027" class="c"><input type="checkbox" id="c-36322027" checked=""/><div class="controls bullet"><span class="by">MartinMond</span><span>|</span><a href="#36321876">parent</a><span>|</span><a href="#36322927">prev</a><span>|</span><a href="#36322615">next</a><span>|</span><label class="collapse" for="c-36322027">[-]</label><label class="expand" for="c-36322027">[2 more]</label></div><br/><div class="children"><div class="content">In your example, how can the compiler (or a human) know that int is a concrete type as opposed to an unconstrained type variable?<p>Consider these two function signatures:<p>map :: ([a] -&gt; [a])<p>map :: ([int] -&gt; [int])<p>Furthermore the syntax that Elixir uses here let&#x27;s you do something like<p>map :: (list(a) -&gt; list(b))<p>list_to_other_data_structure :: (list(a) -&gt; other_data_structure(a))<p>It all reminds me a bit of how Haskell does it <a href="https:&#x2F;&#x2F;medium.com&#x2F;functional&#x2F;haskell-basic-types-and-type-variables-dbb8efa86288" rel="nofollow noreferrer">https:&#x2F;&#x2F;medium.com&#x2F;functional&#x2F;haskell-basic-types-and-type-v...</a><p>I&#x27;m now curious to know if&#x2F;how the above &#x27;generics&#x27; would be expressed in TypeScript&#x2F;Python&#x2F;Go without a similar &#x27;type constructor&#x27; syntax construct?</div><br/><div id="36322972" class="c"><input type="checkbox" id="c-36322972" checked=""/><div class="controls bullet"><span class="by">laszlokorte</span><span>|</span><a href="#36321876">root</a><span>|</span><a href="#36322027">parent</a><span>|</span><a href="#36322615">next</a><span>|</span><label class="collapse" for="c-36322972">[-]</label><label class="expand" for="c-36322972">[1 more]</label></div><br/><div class="children"><div class="content">A simple syntax would be something like<p>map :: forall a. ([a] -&gt; [a])<p>or<p>map :: &lt;a&gt; ([a] -&gt; [a])</div><br/></div></div></div></div><div id="36322615" class="c"><input type="checkbox" id="c-36322615" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36321876">parent</a><span>|</span><a href="#36322027">prev</a><span>|</span><a href="#36323087">next</a><span>|</span><label class="collapse" for="c-36322615">[-]</label><label class="expand" for="c-36322615">[1 more]</label></div><br/><div class="children"><div class="content">It’s how types have been specified in erlang for 20+ years: <a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;reference_manual&#x2F;typespec.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;reference_manual&#x2F;typespec.html</a><p>If you look at any erlang api doc, you’ll see predicate-like type specs. Conveniently, it naturally supports generics by just adding “parameters” to the predicates, so a dict would have type.<p>It works fine, and makes things less ambiguous, as erlang “types” can contain enumerations of values, in the original spec it’s clear that `integer()` is a type and `false` is a value, in your version not so much.</div><br/></div></div><div id="36323087" class="c"><input type="checkbox" id="c-36323087" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#36321876">parent</a><span>|</span><a href="#36322615">prev</a><span>|</span><a href="#36308415">next</a><span>|</span><label class="collapse" for="c-36323087">[-]</label><label class="expand" for="c-36323087">[1 more]</label></div><br/><div class="children"><div class="content">At least in the current system I think the parens are optional if it doesn&#x27;t have arguments so if you really need to leave them off when writing the type you probably can. But like someone said it&#x27;s erlang convention going back decades.<p>Anyway coming from ocaml I don&#x27;t aesthetically <i>like</i> this but coming from ocaml I have no grounds to talk shit about any language&#x27;s aesthetic choices. The parens make sense to me when I think of them as type <i>constructors</i>, rather than concrete expressions of the type itself.</div><br/></div></div></div></div><div id="36308415" class="c"><input type="checkbox" id="c-36308415" checked=""/><div class="controls bullet"><span class="by">olafura</span><span>|</span><a href="#36321876">prev</a><span>|</span><a href="#36321952">next</a><span>|</span><label class="collapse" for="c-36308415">[-]</label><label class="expand" for="c-36308415">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;elixirforum.com&#x2F;t&#x2F;any-update-on-the-set-theoretic-types&#x2F;55553&#x2F;4" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixirforum.com&#x2F;t&#x2F;any-update-on-the-set-theoretic-ty...</a></div><br/><div id="36319738" class="c"><input type="checkbox" id="c-36319738" checked=""/><div class="controls bullet"><span class="by">bradrn</span><span>|</span><a href="#36308415">parent</a><span>|</span><a href="#36321952">next</a><span>|</span><label class="collapse" for="c-36319738">[-]</label><label class="expand" for="c-36319738">[1 more]</label></div><br/><div class="children"><div class="content">And a direct link to the paper: <a href="https:&#x2F;&#x2F;www.irif.fr&#x2F;_media&#x2F;users&#x2F;gduboc&#x2F;elixir-types.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.irif.fr&#x2F;_media&#x2F;users&#x2F;gduboc&#x2F;elixir-types.pdf</a></div><br/></div></div></div></div><div id="36321952" class="c"><input type="checkbox" id="c-36321952" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36308415">prev</a><span>|</span><a href="#36308497">next</a><span>|</span><label class="collapse" for="c-36321952">[-]</label><label class="expand" for="c-36321952">[1 more]</label></div><br/><div class="children"><div class="content">A gradual inferred type system that is both sound and fast :) a dream come true honestly. I hope it works out.</div><br/></div></div><div id="36308497" class="c"><input type="checkbox" id="c-36308497" checked=""/><div class="controls bullet"><span class="by">brainbag</span><span>|</span><a href="#36321952">prev</a><span>|</span><label class="collapse" for="c-36308497">[-]</label><label class="expand" for="c-36308497">[2 more]</label></div><br/><div class="children"><div class="content">The get_age example uses `dynamic()` to accept any type, but I&#x27;m wondering if there will be a way to structurally type it as `%{age: number()}` or equivalent. I didn&#x27;t see anything comparable in the other examples.</div><br/><div id="36320176" class="c"><input type="checkbox" id="c-36320176" checked=""/><div class="controls bullet"><span class="by">bhaney</span><span>|</span><a href="#36308497">parent</a><span>|</span><label class="collapse" for="c-36320176">[-]</label><label class="expand" for="c-36320176">[1 more]</label></div><br/><div class="children"><div class="content">Did you check out the example named &quot;result&#x2F;handle (precise intersection)&quot;?</div><br/></div></div></div></div></div></div></div></div></div></body></html>