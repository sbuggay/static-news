<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734339678010" as="style"/><link rel="stylesheet" href="styles.css?v=1734339678010"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/JanNeuendorf/SVC16">SVC16: Simplest Virtual Computer</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>57 comments</span></div><br/><div><div id="42426455" class="c"><input type="checkbox" id="c-42426455" checked=""/><div class="controls bullet"><span class="by">machinestops</span><span>|</span><a href="#42425815">next</a><span>|</span><label class="collapse" for="c-42426455">[-]</label><label class="expand" for="c-42426455">[1 more]</label></div><br/><div class="children"><div class="content">The ISA leaves something to be desired for &quot;simplest&quot;. Simple, sure, but parameters (and unused ones, at that!)? Memory copy instructions? Multiply and no shifts? Addition _and_ subtraction?<p>Others have mentioned Subleq (Subtract And Branch If Less Than Or Equal To), but there&#x27;s more useful designs that meet all the design constraints. They state that &quot;It is also not intended to be as simple and elegant as it could possibly be.&quot;, but it&#x27;s called &quot;The Simplest Virtual Computer&quot; - that kind of name is a challenge.</div><br/></div></div><div id="42425815" class="c"><input type="checkbox" id="c-42425815" checked=""/><div class="controls bullet"><span class="by">mechagodzilla</span><span>|</span><a href="#42426455">prev</a><span>|</span><a href="#42424859">next</a><span>|</span><label class="collapse" for="c-42425815">[-]</label><label class="expand" for="c-42425815">[9 more]</label></div><br/><div class="children"><div class="content">It took me about 20 minutes to make a basic FPGA-friendly implementation of the CPU core in Verilog, but the 256KB of ram is pretty expensive (16-bit color seems excessive for such a simple core!).</div><br/><div id="42426307" class="c"><input type="checkbox" id="c-42426307" checked=""/><div class="controls bullet"><span class="by">mechagodzilla</span><span>|</span><a href="#42425815">parent</a><span>|</span><a href="#42426253">next</a><span>|</span><label class="collapse" for="c-42426307">[-]</label><label class="expand" for="c-42426307">[3 more]</label></div><br/><div class="children"><div class="content">Ugh, I just noticed it&#x27;s even worse - the display is double-buffered, so you actually need 384KB of ram (128KB for system RAM and 2 x 128KB display buffers!).</div><br/><div id="42426826" class="c"><input type="checkbox" id="c-42426826" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#42425815">root</a><span>|</span><a href="#42426307">parent</a><span>|</span><a href="#42426253">next</a><span>|</span><label class="collapse" for="c-42426826">[-]</label><label class="expand" for="c-42426826">[2 more]</label></div><br/><div class="children"><div class="content">Out of curiosity - why do you care? Do you want to run this thing on a calculator from the 90s or something like that?</div><br/><div id="42426903" class="c"><input type="checkbox" id="c-42426903" checked=""/><div class="controls bullet"><span class="by">mechagodzilla</span><span>|</span><a href="#42425815">root</a><span>|</span><a href="#42426826">parent</a><span>|</span><a href="#42426253">next</a><span>|</span><label class="collapse" for="c-42426903">[-]</label><label class="expand" for="c-42426903">[1 more]</label></div><br/><div class="children"><div class="content">Block RAM in FPGAs is very limited and adding something like a DDR3 controller is a hassle - of the dev boards I have lying around, they have between 48KB and 200KB of block RAM. The actual CPU logic is probably &lt;5% of those chips. I have a board with a 16-bit, 16MB PSRAM interface, but then the memory interface is shared between the video generation and the CPU. Going with 4-bit colors or something seems like it would be more in-line with the design philosophy (but it was targeted to be emulated on a modern PC, where memory and color depth are largely free).</div><br/></div></div></div></div></div></div><div id="42426253" class="c"><input type="checkbox" id="c-42426253" checked=""/><div class="controls bullet"><span class="by">boutell</span><span>|</span><a href="#42425815">parent</a><span>|</span><a href="#42426307">prev</a><span>|</span><a href="#42427276">next</a><span>|</span><label class="collapse" for="c-42426253">[-]</label><label class="expand" for="c-42426253">[2 more]</label></div><br/><div class="children"><div class="content">I wondered how long it would take for someone to do this. An amount of time approaching zero apparently. Nice.</div><br/><div id="42426282" class="c"><input type="checkbox" id="c-42426282" checked=""/><div class="controls bullet"><span class="by">mechagodzilla</span><span>|</span><a href="#42425815">root</a><span>|</span><a href="#42426253">parent</a><span>|</span><a href="#42427276">next</a><span>|</span><label class="collapse" for="c-42426282">[-]</label><label class="expand" for="c-42426282">[1 more]</label></div><br/><div class="children"><div class="content">Implementing a CPU, if you&#x27;re not trying to hyper-optimize it, is reasonably straightforward. This is a very simple design. It would take a little bit more work to add proper video output and mouse input, but those blocks are easy to find for VGA and PS&#x2F;2 mice. I think this would run &gt; 100 MHz very easily on anything made in the last decade.</div><br/></div></div></div></div><div id="42427276" class="c"><input type="checkbox" id="c-42427276" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#42425815">parent</a><span>|</span><a href="#42426253">prev</a><span>|</span><a href="#42428333">next</a><span>|</span><label class="collapse" for="c-42427276">[-]</label><label class="expand" for="c-42427276">[2 more]</label></div><br/><div class="children"><div class="content">Have FPGAs been evolving very slowly? Modern CPUs have some 20 billion transistors and these limitations don&#x27;t seem to have grown at the same rate since the &#x27;90s the last time I looked at them.</div><br/><div id="42427586" class="c"><input type="checkbox" id="c-42427586" checked=""/><div class="controls bullet"><span class="by">rdc12</span><span>|</span><a href="#42425815">root</a><span>|</span><a href="#42427276">parent</a><span>|</span><a href="#42428333">next</a><span>|</span><label class="collapse" for="c-42427586">[-]</label><label class="expand" for="c-42427586">[1 more]</label></div><br/><div class="children"><div class="content">FPGA&#x27;s also have billions of transistors now, but adding more block memory means removing transistors from something else, such as LUT&#x27;s, registers, DSP blocks etc.<p>As always it is a tradeoff, and given many designs don&#x27;t need much block memory, or need so much memory that external memory is a better choice anyway.</div><br/></div></div></div></div><div id="42428333" class="c"><input type="checkbox" id="c-42428333" checked=""/><div class="controls bullet"><span class="by">naitgacem</span><span>|</span><a href="#42425815">parent</a><span>|</span><a href="#42427276">prev</a><span>|</span><a href="#42424859">next</a><span>|</span><label class="collapse" for="c-42428333">[-]</label><label class="expand" for="c-42428333">[1 more]</label></div><br/><div class="children"><div class="content">Hi. Care to share the source code perhaps?</div><br/></div></div></div></div><div id="42424859" class="c"><input type="checkbox" id="c-42424859" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#42425815">prev</a><span>|</span><a href="#42425547">next</a><span>|</span><label class="collapse" for="c-42424859">[-]</label><label class="expand" for="c-42424859">[2 more]</label></div><br/><div class="children"><div class="content">That instruction set looks <i>really</i> weird, like some sort of obscure and long-forgotten 1960s experimental architecture.<p>If I understand it correctly, the entire register file except for PC is effectively memory-mapped, it uses 16-bit word addressing and the peripherals (framebuffer + mouse) are accessed through dedicated instructions. Instructions are four words long, the first one only having 16 valid opcodes and the rest referencing either direct memory addresses or raw word values.</div><br/><div id="42425155" class="c"><input type="checkbox" id="c-42425155" checked=""/><div class="controls bullet"><span class="by">adonovan</span><span>|</span><a href="#42424859">parent</a><span>|</span><a href="#42425547">next</a><span>|</span><label class="collapse" for="c-42425155">[-]</label><label class="expand" for="c-42425155">[1 more]</label></div><br/><div class="children"><div class="content">&gt; forgotten 1960s architecture… the entire register file is memory-mapped<p>1830s, in fact—the original computer, Babbage’s Analytical Engine!</div><br/></div></div></div></div><div id="42425547" class="c"><input type="checkbox" id="c-42425547" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#42424859">prev</a><span>|</span><a href="#42427120">next</a><span>|</span><label class="collapse" for="c-42425547">[-]</label><label class="expand" for="c-42425547">[4 more]</label></div><br/><div class="children"><div class="content">I like toys like this.  I even have made a few of my own, doodled instruction set ideas on many scraps of paper,  and so forth.<p>It&#x27;s a bit weird that this particular instruction set annoys me so much.  Perhaps annoys is the wrong word,  maybe irritates is better.   The entire thing I can get behind except for the instruction encoding.   The instructions are too large for the space available.  128k of ram for programs and 128k for screen (and workspace area, given sync),  but at 8 bytes per instruction it eats up the limited resource too quickly.<p>I guess that irritation comes from the efficiency hacks that these constrained environments encourage.  It revives an age of clever tricks to get the most of of a little.  The instruction size pokes at that aesthetic like a lump in a pillow.<p>I&#x27;m not sure what would be a better solution while preserving simplicity.   maybe a single extra dereference to turn<p><pre><code>    opcode arg1 arg2 arg3
    @(IP) @(IP+1) @(IP+2) @(IP+3)   ;; IP+=4
</code></pre>
into<p><pre><code>    @(@IP) @(@IP+1) @(@IP+2) @(@IP+3)   ;; IP+=1
       </code></pre>
which would be one system word per instruction lookup, from a dictionary of instructions in RAM (coders would have to be careful not to lose the ability to generate all constant values if they eliminated certain dictionary entries(<p>Tiny programs would get bigger ,  Larger programs would be smaller when they reuse instructions.<p>If you wanted to work against the idea of &#x27;simplest&#x27; and embrace the notion of  weird-features-because-of-technical-debt, you could make an &#x27;upgraded&#x27; machine that has a second bank of 128k (64k words) as dedicated program memory, that is initialized at startup with the numbers 0x0000 to 0xffff.    This would make the machine run SVC16 programs unmodified.  You could then either have it use program ROMs or add a single instruction<p><pre><code>    StoreProgMem @progMem(@arg1+@arg3) =(@arg2+@arg3)
 </code></pre>
Which would enable writing the program space.<p>Egads,  I&#x27;ve been nerd sniped!</div><br/><div id="42425989" class="c"><input type="checkbox" id="c-42425989" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42425547">parent</a><span>|</span><a href="#42428074">next</a><span>|</span><label class="collapse" for="c-42425989">[-]</label><label class="expand" for="c-42425989">[2 more]</label></div><br/><div class="children"><div class="content">Why, there is a well-known approach to having constant-size, small opcodes: a data stack. The only non-constant size instruction would be the one that puts an immediate argument onto the stack. Jumps would pop the target address off the stack, too. The stack should be the width of the ALU, say, 32 bit, while the machine codes could be half a byte, like here.<p>I&#x27;m very surprised this smallest machine is not a stack machine.</div><br/><div id="42426777" class="c"><input type="checkbox" id="c-42426777" checked=""/><div class="controls bullet"><span class="by">ant6n</span><span>|</span><a href="#42425547">root</a><span>|</span><a href="#42425989">parent</a><span>|</span><a href="#42428074">next</a><span>|</span><label class="collapse" for="c-42426777">[-]</label><label class="expand" for="c-42426777">[1 more]</label></div><br/><div class="children"><div class="content">I feel similar about the instruction encoding.<p>Another way could be to use registers, possibly just one register. Like in old machines that had an accumulator, which was implied. So „Add x“ adds x to the accumulator.<p>In some sense, there is already a register file in the proposed VM, the whole memory.<p>Another, related way, to reduce instruction size is to not allow all operands to be 16 bit, that is, have some registers that are more „special“ than others. For example, say the first 16 memory locations are special. Then it’s possible to have a<p><pre><code>    Opcode, arg1, arg2, arg3
</code></pre>
Encoding using 4 bits each, for 16 bit instructions. The problem is that some instructions will need a full 16 bit argument, for example some load immediate, or goto.<p>Common ways to deal with that:<p>1) variable width instructions (16&#x2F;32 bit) -  makes machine less simple.<p>2) always use 32 bit instructions, meaning instructions are<p><pre><code>    opcode, arg4bit, arg4bit, arg16bit.
</code></pre>
This is simpler, but still pretty wasteful for instruction length. Could also use<p><pre><code>    opcode4bit, arg6bit, arg6bit, arg16bit
</code></pre>
This turns the first 64 memory locations into special registers, but uses awkward 6bit values.<p>3) use 8 bit immediates with hi&#x2F;lo access (like arm). So then u have instructions like<p><pre><code>    mov_hi dest4, imm8
    nov_lo dest4, imm8
</code></pre>
Setting the hi&#x2F;lo byte of the register file (I.e. the first 16 memory locations). This in turn means there will be more instructions, they will not work directly on memory (like goto needs 2 loads). So while there is the nice property that instruction length equals word length, it also means more kinds of instructions (perhaps, like jump relative), more complicated instructions, and more instructions needing to be executed to accomplish similar tasks (eg 3 instructions for arbitrary jump).<p>All these considerations are probably counter to wanting a maximally simple machine.</div><br/></div></div></div></div><div id="42428074" class="c"><input type="checkbox" id="c-42428074" checked=""/><div class="controls bullet"><span class="by">zellyn</span><span>|</span><a href="#42425547">parent</a><span>|</span><a href="#42425989">prev</a><span>|</span><a href="#42427120">next</a><span>|</span><label class="collapse" for="c-42428074">[-]</label><label class="expand" for="c-42428074">[1 more]</label></div><br/><div class="children"><div class="content">Do what Woz did and write a Sweet16 interpreter for the machine!<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SWEET16" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SWEET16</a></div><br/></div></div></div></div><div id="42427120" class="c"><input type="checkbox" id="c-42427120" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#42425547">prev</a><span>|</span><a href="#42424471">next</a><span>|</span><label class="collapse" for="c-42427120">[-]</label><label class="expand" for="c-42427120">[1 more]</label></div><br/><div class="children"><div class="content">I give you the worlds simplest physical computer:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CARDboard_Illustrative_Aid_to_Computation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CARDboard_Illustrative_Aid_to_...</a></div><br/></div></div><div id="42424471" class="c"><input type="checkbox" id="c-42424471" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42427120">prev</a><span>|</span><a href="#42425033">next</a><span>|</span><label class="collapse" for="c-42424471">[-]</label><label class="expand" for="c-42424471">[6 more]</label></div><br/><div class="children"><div class="content">It is like the PDP-8 (tiny instruction set) and the TMS 9900 (no registers) but the 16-bit word size for memory did not catch on for real hardware.</div><br/><div id="42425053" class="c"><input type="checkbox" id="c-42425053" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#42424471">parent</a><span>|</span><a href="#42424760">next</a><span>|</span><label class="collapse" for="c-42425053">[-]</label><label class="expand" for="c-42425053">[2 more]</label></div><br/><div class="children"><div class="content">8086, 80286, 680[01]0 all had a 16-bit word size and could only access RAM at 16-bit granularity (I&#x2F;O is a different story). Of course they had the ability to extract just a byte as well.<p>68000 generates a bus error if you try unaligned 16&#x2F;32-bit access.</div><br/><div id="42425328" class="c"><input type="checkbox" id="c-42425328" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42424471">root</a><span>|</span><a href="#42425053">parent</a><span>|</span><a href="#42424760">next</a><span>|</span><label class="collapse" for="c-42425328">[-]</label><label class="expand" for="c-42425328">[1 more]</label></div><br/><div class="children"><div class="content">But you could have had a system with 64k 16-bit words that gives 128k bytes.</div><br/></div></div></div></div><div id="42424760" class="c"><input type="checkbox" id="c-42424760" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#42424471">parent</a><span>|</span><a href="#42425053">prev</a><span>|</span><a href="#42425653">next</a><span>|</span><label class="collapse" for="c-42424760">[-]</label><label class="expand" for="c-42424760">[2 more]</label></div><br/><div class="children"><div class="content">16 bit microcontrollers are a $25 billion market.</div><br/><div id="42424871" class="c"><input type="checkbox" id="c-42424871" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#42424471">root</a><span>|</span><a href="#42424760">parent</a><span>|</span><a href="#42425653">next</a><span>|</span><label class="collapse" for="c-42424871">[-]</label><label class="expand" for="c-42424871">[1 more]</label></div><br/><div class="children"><div class="content">Those are usually supporting byte accesses, not limited to word accesses.</div><br/></div></div></div></div><div id="42425653" class="c"><input type="checkbox" id="c-42425653" checked=""/><div class="controls bullet"><span class="by">Tor3</span><span>|</span><a href="#42424471">parent</a><span>|</span><a href="#42424760">prev</a><span>|</span><a href="#42425033">next</a><span>|</span><label class="collapse" for="c-42425653">[-]</label><label class="expand" for="c-42425653">[1 more]</label></div><br/><div class="children"><div class="content">I worked with a 16-bit minicomputer as late as 1995..
word addressable, not byte addressable.</div><br/></div></div></div></div><div id="42425033" class="c"><input type="checkbox" id="c-42425033" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#42424471">prev</a><span>|</span><a href="#42425573">next</a><span>|</span><label class="collapse" for="c-42425033">[-]</label><label class="expand" for="c-42425033">[4 more]</label></div><br/><div class="children"><div class="content">This is really simple and approachable. Reminds me slightly of Forth or subleq.<p><a href="https:&#x2F;&#x2F;colorforth.github.io&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;colorforth.github.io&#x2F;index.html</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Forth_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Forth_(programming_language)</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;davidar&#x2F;subleq&#x2F;blob&#x2F;master&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;davidar&#x2F;subleq&#x2F;blob&#x2F;master&#x2F;README.md</a></div><br/><div id="42425230" class="c"><input type="checkbox" id="c-42425230" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#42425033">parent</a><span>|</span><a href="#42426237">next</a><span>|</span><label class="collapse" for="c-42425230">[-]</label><label class="expand" for="c-42425230">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t not mention a great game about programming a SIC using subleq called SIC-1: <a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;2124440&#x2F;SIC1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;2124440&#x2F;SIC1&#x2F;</a><p>Second part of the game requires writing self-modifying code which is quite mindboggling!</div><br/></div></div><div id="42427006" class="c"><input type="checkbox" id="c-42427006" checked=""/><div class="controls bullet"><span class="by">howerj</span><span>|</span><a href="#42425033">parent</a><span>|</span><a href="#42426237">prev</a><span>|</span><a href="#42425573">next</a><span>|</span><label class="collapse" for="c-42427006">[-]</label><label class="expand" for="c-42427006">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a Forth that runs on SUBLEQ <a href="https:&#x2F;&#x2F;github.com&#x2F;howerj&#x2F;subleq">https:&#x2F;&#x2F;github.com&#x2F;howerj&#x2F;subleq</a>, there&#x27;s also a file system for it <a href="https:&#x2F;&#x2F;github.com&#x2F;howerj&#x2F;ffs">https:&#x2F;&#x2F;github.com&#x2F;howerj&#x2F;ffs</a>.</div><br/></div></div></div></div><div id="42425573" class="c"><input type="checkbox" id="c-42425573" checked=""/><div class="controls bullet"><span class="by">jonjacky</span><span>|</span><a href="#42425033">prev</a><span>|</span><a href="#42425834">next</a><span>|</span><label class="collapse" for="c-42425573">[-]</label><label class="expand" for="c-42425573">[1 more]</label></div><br/><div class="children"><div class="content">Compare this to the LGP-30, a &quot;small&quot; (desk-sized) vacuum tube computer of the 1950s.   It also had just 16 instructions.   It nominally had some registers, but these were just locations on the same magnetic drum that stored all the other data.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;LGP-30" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;LGP-30</a></div><br/></div></div><div id="42425834" class="c"><input type="checkbox" id="c-42425834" checked=""/><div class="controls bullet"><span class="by">gnarbarian</span><span>|</span><a href="#42425573">prev</a><span>|</span><a href="#42425084">next</a><span>|</span><label class="collapse" for="c-42425834">[-]</label><label class="expand" for="c-42425834">[3 more]</label></div><br/><div class="children"><div class="content">I like nock.<p>the official specification for Nock, the assembly language used by the Urbit virtual machine, fits on a t-shirt:
The Nock specification is only 200 words long
It can be compressed to 371 bytes 
Nock is a low-level, homoiconic combinator language that&#x27;s similar to JVM code. It&#x27;s designed to be simple, and is interpreted by Vere. Hoon is the practical layer of Urbit, and it compiles itself to Nock, the simple layer.</div><br/><div id="42427466" class="c"><input type="checkbox" id="c-42427466" checked=""/><div class="controls bullet"><span class="by">pcmoore</span><span>|</span><a href="#42425834">parent</a><span>|</span><a href="#42425842">next</a><span>|</span><label class="collapse" for="c-42427466">[-]</label><label class="expand" for="c-42427466">[1 more]</label></div><br/><div class="children"><div class="content">A more concise and less opaque alternative <a href="https:&#x2F;&#x2F;github.com&#x2F;tibru&#x2F;tibru">https:&#x2F;&#x2F;github.com&#x2F;tibru&#x2F;tibru</a></div><br/></div></div><div id="42425842" class="c"><input type="checkbox" id="c-42425842" checked=""/><div class="controls bullet"><span class="by">gnarbarian</span><span>|</span><a href="#42425834">parent</a><span>|</span><a href="#42427466">prev</a><span>|</span><a href="#42425084">next</a><span>|</span><label class="collapse" for="c-42425842">[-]</label><label class="expand" for="c-42425842">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;docs.urbit.org&#x2F;language&#x2F;nock&#x2F;reference&#x2F;specification" rel="nofollow">https:&#x2F;&#x2F;docs.urbit.org&#x2F;language&#x2F;nock&#x2F;reference&#x2F;specification</a></div><br/></div></div></div></div><div id="42425084" class="c"><input type="checkbox" id="c-42425084" checked=""/><div class="controls bullet"><span class="by">d3VwsX</span><span>|</span><a href="#42425834">prev</a><span>|</span><a href="#42427196">next</a><span>|</span><label class="collapse" for="c-42425084">[-]</label><label class="expand" for="c-42425084">[3 more]</label></div><br/><div class="children"><div class="content">A bit confused by the goto and skip instructions. Why multiply by 4 in one, but not the other? Sounds reasonable that both keep the target address a valid instruction pointer (aligned to 4 words)?<p>Adding two words to create an address is a fun variation of segment pointers, but even more wasteful than x86 16-bit segment+offset pointers (not a complaint, just an observation).</div><br/><div id="42427127" class="c"><input type="checkbox" id="c-42427127" checked=""/><div class="controls bullet"><span class="by">RaftPeople</span><span>|</span><a href="#42425084">parent</a><span>|</span><a href="#42425158">next</a><span>|</span><label class="collapse" for="c-42427127">[-]</label><label class="expand" for="c-42427127">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Adding two words to create an address is a fun variation of segment pointers, but even more wasteful than x86 16-bit segment+offset pointers (not a complaint, just an observation)</i><p>I&#x27;m curious why you think it&#x27;s wasteful?<p>It seems similar to the 6809 indexed addressing modes which I liked (a long time ago).</div><br/></div></div></div></div><div id="42427196" class="c"><input type="checkbox" id="c-42427196" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#42425084">prev</a><span>|</span><a href="#42424507">next</a><span>|</span><label class="collapse" for="c-42427196">[-]</label><label class="expand" for="c-42427196">[1 more]</label></div><br/><div class="children"><div class="content">Funny, I&#x27;ve been working on a similar project, inspired by uxn. Initially, mine was also going to use 16-bit words, but I&#x27;ve since moved to 32-bit signed words. It&#x27;ll be a bit heftier than this project in other ways, too, but not by much.</div><br/></div></div><div id="42424507" class="c"><input type="checkbox" id="c-42424507" checked=""/><div class="controls bullet"><span class="by">max_</span><span>|</span><a href="#42427196">prev</a><span>|</span><a href="#42424612">next</a><span>|</span><label class="collapse" for="c-42424507">[-]</label><label class="expand" for="c-42424507">[3 more]</label></div><br/><div class="children"><div class="content">I remember coming across a JS repo that had lots of minimum viable implementations.<p>It has simple processors, simple compilers etc.<p>I wish I could find it.</div><br/><div id="42424624" class="c"><input type="checkbox" id="c-42424624" checked=""/><div class="controls bullet"><span class="by">nroize</span><span>|</span><a href="#42424507">parent</a><span>|</span><a href="#42424612">next</a><span>|</span><label class="collapse" for="c-42424624">[-]</label><label class="expand" for="c-42424624">[2 more]</label></div><br/><div class="children"><div class="content">Not JS but there&#x27;s Build Your Own X <a href="https:&#x2F;&#x2F;github.com&#x2F;codecrafters-io&#x2F;build-your-own-x">https:&#x2F;&#x2F;github.com&#x2F;codecrafters-io&#x2F;build-your-own-x</a></div><br/><div id="42424920" class="c"><input type="checkbox" id="c-42424920" checked=""/><div class="controls bullet"><span class="by">azinman2</span><span>|</span><a href="#42424507">root</a><span>|</span><a href="#42424624">parent</a><span>|</span><a href="#42424612">next</a><span>|</span><label class="collapse" for="c-42424920">[-]</label><label class="expand" for="c-42424920">[1 more]</label></div><br/><div class="children"><div class="content">This is super cool. Thanks for posting it. I dream of being retired and being able to go through each one.</div><br/></div></div></div></div></div></div><div id="42424612" class="c"><input type="checkbox" id="c-42424612" checked=""/><div class="controls bullet"><span class="by">nefarious_ends</span><span>|</span><a href="#42424507">prev</a><span>|</span><a href="#42424724">next</a><span>|</span><label class="collapse" for="c-42424612">[-]</label><label class="expand" for="c-42424612">[1 more]</label></div><br/><div class="children"><div class="content">Wow this looks cool, I’m going to try writing a program. I have recently been learning about computer architecture (specifically older 8 bit CPUs) so when I read “There are no CPU registers” I was very intrigued.</div><br/></div></div><div id="42424724" class="c"><input type="checkbox" id="c-42424724" checked=""/><div class="controls bullet"><span class="by">bbminner</span><span>|</span><a href="#42424612">prev</a><span>|</span><a href="#42426739">next</a><span>|</span><label class="collapse" for="c-42424724">[-]</label><label class="expand" for="c-42424724">[4 more]</label></div><br/><div class="children"><div class="content">Can someone explain to me the appeal of these virtual console projects? Is it like lock picking or demoscene in a sense that you need to figure how to achieve impressive things under tight constraints?</div><br/><div id="42425525" class="c"><input type="checkbox" id="c-42425525" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42424724">parent</a><span>|</span><a href="#42425709">next</a><span>|</span><label class="collapse" for="c-42425525">[-]</label><label class="expand" for="c-42425525">[1 more]</label></div><br/><div class="children"><div class="content">I enjoy implementing these sorts of things from a spec. It&#x27;s very rewarding to have other peoples&#x27; games boot up in your emulator.</div><br/></div></div><div id="42425709" class="c"><input type="checkbox" id="c-42425709" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#42424724">parent</a><span>|</span><a href="#42425525">prev</a><span>|</span><a href="#42425485">next</a><span>|</span><label class="collapse" for="c-42425709">[-]</label><label class="expand" for="c-42425709">[1 more]</label></div><br/><div class="children"><div class="content">I feel like it is the same form of intellectual stimulation that one gets from crosswords or sudoku but with an added creative dimension.   Where crosswords and sudoku present a challenge with a fixed target goal, the demo scene and virtual consoles give you the difficulty with an open ended goal.<p>Code golf is somewhere in the middle,  Often you have a fixed goal, but there is no one &#x27;right&#x27; solution,  creativity can find many paths to achieve the desired output while reducing line or character count.<p>So I do<p>Dweets <a href="https:&#x2F;&#x2F;beta.dwitter.net&#x2F;u&#x2F;lerc&#x2F;top" rel="nofollow">https:&#x2F;&#x2F;beta.dwitter.net&#x2F;u&#x2F;lerc&#x2F;top</a><p>My own fantasy console <a href="https:&#x2F;&#x2F;k8.fingswotidun.com&#x2F;static&#x2F;ide&#x2F;?gist=ad96329670965dc023c5ae740b433ad6" rel="nofollow">https:&#x2F;&#x2F;k8.fingswotidun.com&#x2F;static&#x2F;ide&#x2F;?gist=ad96329670965dc...</a><p>A stack machine image generator limited to 50 characters of program code <a href="https:&#x2F;&#x2F;c50.fingswotidun.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;c50.fingswotidun.com&#x2F;</a><p>Why do it?  Why play with Lego?  It&#x27;s interesting and you get to see what you make.<p>The proliferation of fantasy consoles is simply because making a fantasy console  appeals to the same aesthetic.  See what you can make.</div><br/></div></div><div id="42425485" class="c"><input type="checkbox" id="c-42425485" checked=""/><div class="controls bullet"><span class="by">ktpsns</span><span>|</span><a href="#42424724">parent</a><span>|</span><a href="#42425709">prev</a><span>|</span><a href="#42426739">next</a><span>|</span><label class="collapse" for="c-42425485">[-]</label><label class="expand" for="c-42425485">[1 more]</label></div><br/><div class="children"><div class="content">Purpose, my guess: Fun, joy of understanding, tinkering, learning and education.<p>Such projects can grow and eventually somebody learning on this builds the next Language or Qemu.</div><br/></div></div></div></div><div id="42426739" class="c"><input type="checkbox" id="c-42426739" checked=""/><div class="controls bullet"><span class="by">gustavopezzi</span><span>|</span><a href="#42424724">prev</a><span>|</span><a href="#42424866">next</a><span>|</span><label class="collapse" for="c-42426739">[-]</label><label class="expand" for="c-42426739">[1 more]</label></div><br/><div class="children"><div class="content">I like this. Thanks for sharing.</div><br/></div></div><div id="42424866" class="c"><input type="checkbox" id="c-42424866" checked=""/><div class="controls bullet"><span class="by">otaka</span><span>|</span><a href="#42426739">prev</a><span>|</span><a href="#42424984">next</a><span>|</span><label class="collapse" for="c-42424866">[-]</label><label class="expand" for="c-42424866">[3 more]</label></div><br/><div class="children"><div class="content">As for me, it is bad that there is no any permanent storage like disk. Also the lack of keyboard is a big limitation</div><br/><div id="42425131" class="c"><input type="checkbox" id="c-42425131" checked=""/><div class="controls bullet"><span class="by">catlifeonmars</span><span>|</span><a href="#42424866">parent</a><span>|</span><a href="#42425094">next</a><span>|</span><label class="collapse" for="c-42425131">[-]</label><label class="expand" for="c-42425131">[1 more]</label></div><br/><div class="children"><div class="content">You could memory map additional device drivers at the end of the memory as a way to extend with arbitrary peripherals</div><br/></div></div><div id="42425094" class="c"><input type="checkbox" id="c-42425094" checked=""/><div class="controls bullet"><span class="by">d3VwsX</span><span>|</span><a href="#42424866">parent</a><span>|</span><a href="#42425131">prev</a><span>|</span><a href="#42424984">next</a><span>|</span><label class="collapse" for="c-42425094">[-]</label><label class="expand" for="c-42425094">[1 more]</label></div><br/><div class="children"><div class="content">To keep things simple maybe just handle that using emulator save-states instead?</div><br/></div></div></div></div><div id="42425005" class="c"><input type="checkbox" id="c-42425005" checked=""/><div class="controls bullet"><span class="by">ljlolel</span><span>|</span><a href="#42424984">prev</a><span>|</span><a href="#42424646">next</a><span>|</span><label class="collapse" for="c-42425005">[-]</label><label class="expand" for="c-42425005">[1 more]</label></div><br/><div class="children"><div class="content">Worse is better</div><br/></div></div><div id="42424646" class="c"><input type="checkbox" id="c-42424646" checked=""/><div class="controls bullet"><span class="by">joshu</span><span>|</span><a href="#42425005">prev</a><span>|</span><a href="#42425227">next</a><span>|</span><label class="collapse" for="c-42424646">[-]</label><label class="expand" for="c-42424646">[1 more]</label></div><br/><div class="children"><div class="content">stack pointer? offset addressing mode?</div><br/></div></div><div id="42425227" class="c"><input type="checkbox" id="c-42425227" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#42424646">prev</a><span>|</span><a href="#42426409">next</a><span>|</span><label class="collapse" for="c-42425227">[-]</label><label class="expand" for="c-42425227">[1 more]</label></div><br/><div class="children"><div class="content">I thought it is excel.</div><br/></div></div><div id="42426409" class="c"><input type="checkbox" id="c-42426409" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#42425227">prev</a><span>|</span><a href="#42424679">next</a><span>|</span><label class="collapse" for="c-42426409">[-]</label><label class="expand" for="c-42426409">[1 more]</label></div><br/><div class="children"><div class="content">subleq can be done in few lines of AWK, you could just use busybox instead of a huge Rust toolchain.</div><br/></div></div><div id="42424679" class="c"><input type="checkbox" id="c-42424679" checked=""/><div class="controls bullet"><span class="by">anfilt</span><span>|</span><a href="#42426409">prev</a><span>|</span><label class="collapse" for="c-42424679">[-]</label><label class="expand" for="c-42424679">[4 more]</label></div><br/><div class="children"><div class="content">The ISA is a bit complex for the simplest Virtual Computer. One Instruction computers are a thing: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;One-instruction_set_computer#Instruction_types" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;One-instruction_set_computer#I...</a></div><br/><div id="42425245" class="c"><input type="checkbox" id="c-42425245" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#42424679">parent</a><span>|</span><a href="#42425906">next</a><span>|</span><label class="collapse" for="c-42425245">[-]</label><label class="expand" for="c-42425245">[1 more]</label></div><br/><div class="children"><div class="content">Readme mentioned that creating the simplest possible computer wasn&#x27;t the goal</div><br/></div></div><div id="42425906" class="c"><input type="checkbox" id="c-42425906" checked=""/><div class="controls bullet"><span class="by">ks2048</span><span>|</span><a href="#42424679">parent</a><span>|</span><a href="#42425245">prev</a><span>|</span><a href="#42424698">next</a><span>|</span><label class="collapse" for="c-42425906">[-]</label><label class="expand" for="c-42425906">[1 more]</label></div><br/><div class="children"><div class="content">I had a similar thought. Better name is SVC16: Simple Virtual Computer</div><br/></div></div></div></div></div></div></div></div></div></body></html>