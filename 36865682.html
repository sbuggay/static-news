<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690362058948" as="style"/><link rel="stylesheet" href="styles.css?v=1690362058948"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/o8vm/octox">Octox: Unix-like OS in Rust inspired by xv6-riscv</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>o8vm</span> | <span>98 comments</span></div><br/><div><div id="36868620" class="c"><input type="checkbox" id="c-36868620" checked=""/><div class="controls bullet"><span class="by">bakul</span><span>|</span><a href="#36873589">next</a><span>|</span><label class="collapse" for="c-36868620">[-]</label><label class="expand" for="c-36868620">[8 more]</label></div><br/><div class="children"><div class="content">How does this compare with <a href="https:&#x2F;&#x2F;github.com&#x2F;dancrossnyc&#x2F;rxv64">https:&#x2F;&#x2F;github.com&#x2F;dancrossnyc&#x2F;rxv64</a> ? From its README.md:<p>rxv64 is a pedagogical operating system written in Rust that targets multiprocessor x86_64 machines. It is a reimplementation of the xv6 operating system from MIT.</div><br/><div id="36868926" class="c"><input type="checkbox" id="c-36868926" checked=""/><div class="controls bullet"><span class="by">o8vm</span><span>|</span><a href="#36868620">parent</a><span>|</span><a href="#36868728">next</a><span>|</span><label class="collapse" for="c-36868926">[-]</label><label class="expand" for="c-36868926">[3 more]</label></div><br/><div class="children"><div class="content">octox is also different in that the kernel, userland, mkfs, and build system are all implemented in Rust, and I think it is also different at the type level, for example, octox using mpmc for Pipe, and using OnceLock and LazyLock for static variable initialization.</div><br/><div id="36869149" class="c"><input type="checkbox" id="c-36869149" checked=""/><div class="controls bullet"><span class="by">bakul</span><span>|</span><a href="#36868620">root</a><span>|</span><a href="#36868926">parent</a><span>|</span><a href="#36868728">next</a><span>|</span><label class="collapse" for="c-36869149">[-]</label><label class="expand" for="c-36869149">[2 more]</label></div><br/><div class="children"><div class="content">Thanks. rxv64 kernel (the much harder part), syslib and ulib are in rust. Replacing userland C with rust would not be hard. Ideally a general purpose OS should support programs written in any of the common programming languages so it would make sense to have some programs in another language to keep the OS API &quot;honest&quot;!</div><br/><div id="36874214" class="c"><input type="checkbox" id="c-36874214" checked=""/><div class="controls bullet"><span class="by">o8vm</span><span>|</span><a href="#36868620">root</a><span>|</span><a href="#36869149">parent</a><span>|</span><a href="#36868728">next</a><span>|</span><label class="collapse" for="c-36874214">[-]</label><label class="expand" for="c-36874214">[1 more]</label></div><br/><div class="children"><div class="content">octox aims to provide a user library similar to Rust’s std, but implementing it is somewhat difficult.</div><br/></div></div></div></div></div></div><div id="36868728" class="c"><input type="checkbox" id="c-36868728" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#36868620">parent</a><span>|</span><a href="#36868926">prev</a><span>|</span><a href="#36873589">next</a><span>|</span><label class="collapse" for="c-36868728">[-]</label><label class="expand" for="c-36868728">[4 more]</label></div><br/><div class="children"><div class="content">I immediately notice that o8vm targets RISC-V, whereas rxv64 targets a legacy ISA.</div><br/><div id="36872367" class="c"><input type="checkbox" id="c-36872367" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36868620">root</a><span>|</span><a href="#36868728">parent</a><span>|</span><a href="#36873589">next</a><span>|</span><label class="collapse" for="c-36872367">[-]</label><label class="expand" for="c-36872367">[3 more]</label></div><br/><div class="children"><div class="content">Is it really a &quot;legacy&quot; ISA if it&#x27;s actively developed by two different companies (and will be for a long time to come) and is utterly dominant in servers, desktops, and laptops today?</div><br/><div id="36873263" class="c"><input type="checkbox" id="c-36873263" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#36868620">root</a><span>|</span><a href="#36872367">parent</a><span>|</span><a href="#36873589">next</a><span>|</span><label class="collapse" for="c-36873263">[-]</label><label class="expand" for="c-36873263">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right in that it is still actively developed by two different companies, and that it is still utterly dominant in servers, desktops, and laptops... today.<p>Perhaps you would prefer &quot;incumbent ISA&quot;? But that would be a pointless exercise, because RISC-V is inevitable, and the new industry standard.<p>The intent was to express &quot;not RISC-V&quot; anyway. The parent already specifies which.</div><br/><div id="36873868" class="c"><input type="checkbox" id="c-36873868" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36868620">root</a><span>|</span><a href="#36873263">parent</a><span>|</span><a href="#36873589">next</a><span>|</span><label class="collapse" for="c-36873868">[-]</label><label class="expand" for="c-36873868">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Perhaps you would prefer &quot;incumbent ISA&quot;?<p>I wouldn&#x27;t mind that.<p>&gt; But that would be a pointless exercise, because RISC-V is inevitable, and the new industry standard.<p>Er. So even <i>if</i> the second part of the sentence were true, calling out the current leader isn&#x27;t pointless. And the second part of your claim is very much not a foregone conclusion; RISC-V is a standard, and used by the industry, but it&#x27;s not in anything like a dominant enough position to call it &quot;<i>the</i> industry standard&quot;, and its success is certainly not inevitable - RISC-V is today where MIPS was a decade ago (cheap, modestly popular in embedded, lacking in high-end parts, not popular outside of embedded). Now, its trajectory is upwards, it has enough going for it that it <i>could</i> become extremely popular, and certainly I&#x27;d <i>like</i> an Open Source option to win - but that&#x27;s just one possibility, and history is littered with ISAs that were supposed to be the Next Big Thing.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36873589" class="c"><input type="checkbox" id="c-36873589" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#36868620">prev</a><span>|</span><a href="#36867643">next</a><span>|</span><label class="collapse" for="c-36873589">[-]</label><label class="expand" for="c-36873589">[1 more]</label></div><br/><div class="children"><div class="content">Oh you have did what I did in the shadow...I wonder if I later GPL&#x27;d it the license won&#x27;t be compatible to take the code in...But I runs in x86_64 with custom QEMU UEFI loader anyway</div><br/></div></div><div id="36867643" class="c"><input type="checkbox" id="c-36867643" checked=""/><div class="controls bullet"><span class="by">Santosh83</span><span>|</span><a href="#36873589">prev</a><span>|</span><a href="#36869399">next</a><span>|</span><label class="collapse" for="c-36867643">[-]</label><label class="expand" for="c-36867643">[71 more]</label></div><br/><div class="children"><div class="content">Why does it seem like 80 to 90% of hobby OS projects that are started are &quot;Unix-like?&quot; Don&#x27;t we already have a huge variety of Unix-like OSes out there? Why not explore new models?</div><br/><div id="36868507" class="c"><input type="checkbox" id="c-36868507" checked=""/><div class="controls bullet"><span class="by">linguae</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36868390">next</a><span>|</span><label class="collapse" for="c-36868507">[-]</label><label class="expand" for="c-36868507">[14 more]</label></div><br/><div class="children"><div class="content">Through various market forces, Unix (and its descendants&#x2F;clones) and Windows killed most of the rest of the OS ecosystem over 20 years ago.  There are generations of software engineers and computer scientists who’ve never studied operating systems that weren’t Unix- or Windows-based.  Most leading OS textbooks (Tanenbaum’s books, the dinosaur book, Three Easy Pieces) have a Unix slant.  Even the systems software research community is heavily Unix-centric; I say that as someone who used to be immersed in the research storage systems community.  The only non-Unix or Windows operating systems many practitioners and even researchers may have used in their lives are MS-DOS and the classic Mac OS, and there’s a growing number of people who weren’t even born yet by the time these systems fell out of common use.<p>However, the history of computing contains examples of other operating systems that didn’t survive the marketplace but have interesting lessons that can apply to improving today’s operating systems.  <i>The Unix Hater’s Handbook</i> is a nice example of alternative worlds of computing that were still alive in the 1980s and early 1990s.  VMS, IBM mainframe systems, Smalltalk, Symbolics Genera, Xerox Mesa and Cedar, Xerox Interlisp-D, and the Apple Newton were all real-world systems that demonstrate alternatives to the Unix and Windows ways of thinking.  Project Oberon is an entire system developed by Wirth (of Pascal fame) whose design goal is to build a complete OS and development environment that is small enough to be understood for pedagogical purposes, similar to MINIX but without any Unix compatibility.  Reading the history of failed Apple projects such as the planned Lisp OS for the Newton and the ill-fated Pink&#x2F;Taligent project are also instructive.  Microsoft Research did a lot of interesting research in the 2000s on operating systems implemented in memory-safe languages, notably Singularity and Midori.<p>From learning about these past projects, we can then imagine future directions for OS design.</div><br/><div id="36871417" class="c"><input type="checkbox" id="c-36871417" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868507">parent</a><span>|</span><a href="#36870277">next</a><span>|</span><label class="collapse" for="c-36871417">[-]</label><label class="expand" for="c-36871417">[3 more]</label></div><br/><div class="children"><div class="content">So far, historically, no OS has been successful unless (in addition to whatever whiz bang funtionality it had to offer) it provided a process abstraction in which the application thinks it has the real hardware machine to itself. This is the big thing in Unix and others: not how the file system is, or that there are pipes and whatnot: but that you get an address space in which you run machine code for the Intel, SPARC, PPC or whatever. The machine isn&#x27;t hidden. The OS is in the background; you tap into it via some privileged instruction or trap.<p>It was not possible to develop just an OS which does this; it needs hardware support. There has to be virtual memory if there is a requirement to juggle multiple such applications each of which thinks it has a whole machine all to itself. There has to be protection: user&#x2F;supervisor separation, and that protection cannot depend on a trusted compiler, because the application can execute arbitrary machine code produced by a compiler of the developer&#x27;s choosing (or even by hand). It has to be hardware.<p>Okay, so successful OSs so far have been ones that provide decent multiprogramming, by following the hardware&#x27;s model for virtual memory and privilege separation. What about the rest of the shape of the OS; the environment? Like files being just arrays of bytes?<p>Files being arrays of bytes is a form of democracy. Any sort of structured storage introduced on one OS will look indistinguishable from a proprietary file format which silos your data.<p>Files are exchanged between operating systems in bytes. No matter what you do, that&#x27;s not going to go away.<p>Even some modern enhancements and complications in file representation cause interoperability headaches for the users, when they need to take their files to a different system.<p>The rich object features are provided by applications. For instance, an object-oriented database can just store its stuff in a block of bytes. Same with a graphical office suite, or a Lisp system saving its image.<p>Nobody wants an opinionated operating system in which files are fancy trees of objects done in One Way that everyone has to follow who codes for that operating system.</div><br/><div id="36874618" class="c"><input type="checkbox" id="c-36874618" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36871417">parent</a><span>|</span><a href="#36872353">next</a><span>|</span><label class="collapse" for="c-36874618">[-]</label><label class="expand" for="c-36874618">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Nobody wants an opinionated operating system in which files are fancy trees of objects done in One Way that everyone has to follow who codes for that operating system.</i><p>And yet there is ChromeOS. There is iOS. There is Android. These are highly opinionated platforms. So I think that yes, people do want these things. Developers in particular want lots of high level APIs because it makes software production easier, which is why so much software targets the web (effectively an &quot;OS&quot; these days). The web follows implements zero of the standard UNIX API primitives yet is very successful.<p>There&#x27;s a lot of stuff that can be done with operating systems research, I&#x27;m really pretty sure of it. That doesn&#x27;t mean you can&#x27;t layer things properly, or that you can&#x27;t implement your &quot;OS&quot; also as an app in the same way that Chrome is both an app and an OS. We&#x27;re constrained by lack of imagination and the difficulties in getting market adoption for new approaches. Developers prefer to be locked in to a multi-vendor API with open source implementations, than a single vendor API with a proprietary implementation, even though they&#x27;ll do it when a market is there (mobile apps). But that preference kills the commercial incentives to innovate, and open source devs just won&#x27;t do it, which is why every new OS project you see is a clone of commercial operating systems from the past.</div><br/></div></div><div id="36872353" class="c"><input type="checkbox" id="c-36872353" checked=""/><div class="controls bullet"><span class="by">abnry</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36871417">parent</a><span>|</span><a href="#36874618">prev</a><span>|</span><a href="#36870277">next</a><span>|</span><label class="collapse" for="c-36872353">[-]</label><label class="expand" for="c-36872353">[1 more]</label></div><br/><div class="children"><div class="content">When I realized that the linux operating system had to have hardware support (traps for syscalls and interrupts), it was eye opening.<p>I guess your post highlights how operating systems and hardware developed together, and to innovate outside of what we currently have there is a need to somehow jump outside of this loop.<p>What are the hardware features are modern operating systems reliant on and the hardware features they aren&#x27;t reliant on?</div><br/></div></div></div></div><div id="36870277" class="c"><input type="checkbox" id="c-36870277" checked=""/><div class="controls bullet"><span class="by">flyinghamster</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868507">parent</a><span>|</span><a href="#36871417">prev</a><span>|</span><a href="#36869419">next</a><span>|</span><label class="collapse" for="c-36870277">[-]</label><label class="expand" for="c-36870277">[4 more]</label></div><br/><div class="children"><div class="content">Another key issue: the concept of open source barely existed. Sure, you got a copy of the source code used to SYSGEN your RT-11 or RSTS&#x2F;E system, but it had comments removed and was not for redistribution. In the end, the closest in feel to the old DEC world today would be the traditional Windows command line (not PowerShell).<p>The rise of GNU and the general open source movement was a reaction to the rug-pull when access to Unix source was restricted, and that gave us Linux (MINIX wasn&#x27;t initially open source, but could be put into a state that made Linux possible).<p>The Unix paradigm stuck with us, IMO, because Unix (and later Linux and BSDs) have been ported to so many vastly different architectures. So many other operating systems have never moved beyond (and often died with) their initial platforms.</div><br/><div id="36871924" class="c"><input type="checkbox" id="c-36871924" checked=""/><div class="controls bullet"><span class="by">Aloha</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36870277">parent</a><span>|</span><a href="#36869419">next</a><span>|</span><label class="collapse" for="c-36871924">[-]</label><label class="expand" for="c-36871924">[3 more]</label></div><br/><div class="children"><div class="content">Thats not really fair to DCL - cmd is much more.. lacking in facilities than DCL is. Nor is it fair to DCL as an interactive environment either.</div><br/><div id="36872552" class="c"><input type="checkbox" id="c-36872552" checked=""/><div class="controls bullet"><span class="by">flyinghamster</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36871924">parent</a><span>|</span><a href="#36869419">next</a><span>|</span><label class="collapse" for="c-36872552">[-]</label><label class="expand" for="c-36872552">[2 more]</label></div><br/><div class="children"><div class="content">True enough. CP&#x2F;M and MS-DOS (which give us the old-school Windows command shell) predate DCL, though; it was a fairly late addition to the PDP-11 operating systems, after it was rolled out in VMS. RSTS&#x2F;E up to version 8 logged users into BASIC by default, while version 9 made DCL the default run-time system.</div><br/><div id="36873073" class="c"><input type="checkbox" id="c-36873073" checked=""/><div class="controls bullet"><span class="by">Aloha</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36872552">parent</a><span>|</span><a href="#36869419">next</a><span>|</span><label class="collapse" for="c-36873073">[-]</label><label class="expand" for="c-36873073">[1 more]</label></div><br/><div class="children"><div class="content">DCL to my eyes at least clearly inherited some ideas from TOPS-20.<p>cmd for all of its braindead nature is surprisingly usable for complex tasks though. I have to use it often, tbh.</div><br/></div></div></div></div></div></div></div></div><div id="36869419" class="c"><input type="checkbox" id="c-36869419" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868507">parent</a><span>|</span><a href="#36870277">prev</a><span>|</span><a href="#36869261">next</a><span>|</span><label class="collapse" for="c-36869419">[-]</label><label class="expand" for="c-36869419">[4 more]</label></div><br/><div class="children"><div class="content">How would one go about exploring “other” real-world systems? I’ve read some old OS textbooks, poked at Symbian and OS&#x2F;2 books some, and have texts on Oberon and Symbolics in my queue, but the docs for RSX-11 and VMS seem to bury me in operational minutiae without really explaining the design choices, and the Multics docs look like a huge pile of research notes, which is going a bit too far in the other direction. The current bytecode on IBM i is apparentily outright NDA’d, and the RPG docs are eager to presume I know how to operate the original punch-card tabulators. Any pointers?</div><br/><div id="36869900" class="c"><input type="checkbox" id="c-36869900" checked=""/><div class="controls bullet"><span class="by">linguae</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869419">parent</a><span>|</span><a href="#36873936">next</a><span>|</span><label class="collapse" for="c-36869900">[-]</label><label class="expand" for="c-36869900">[1 more]</label></div><br/><div class="children"><div class="content">Depending on the system this could range from an easy project that one can do in a few hours to a very long quest.  For some research systems (particularly those implemented in the pre-FOSS era or those from companies) it may be impossible to try out the systems without attempting to implement them yourself.  However, there are other systems that are available to try out.  The ideal situation is a FOSS release, like the MIT CADR Lisp machine code and Interlisp-D.  Barring that, the next best thing is some type of freeware or non-commercial license; I think this is the case for OpenVMS, though I could be mistaken.  Some systems cannot be obtained easily without traveling the high seas, if you catch my drift, matey (cough Open Genera cough).<p>I think a lot of value can be gained from not only using software, but by reading papers and manuals, especially when the software is unavailable or unattainable.  There’s a site called Bitsavers that is a treasure trove of old documents.<p>Come to think of it, a significant reason for Unix’s dominance in research and education is its availability, going all the way back to the 1970s when Bell Labs sold licenses to universities at very low prices.  Even when licensing became more restrictive in the 1980s, this spurred the development of MINIX, GNU, later BSDs, and finally the Linux kernel, in order to recreate the environment students enjoyed with 1970s Unix.  This openness is a far cry from the work of Xerox and Lisp machine vendors, where one needed to have been privileged enough to work for one of these vendors or their customers to use these environments, which were far more expensive than Unix workstations and especially personal computers.  Thankfully there’s a wealth of documentation about these non-Unix systems, as well as testimony from their users.  In addition, some systems were open sourced.  But we must remember the times that these systems emerged, and we must remember why Unix became so dominant in the first place; its openness and availability set it apart from its competitors.</div><br/></div></div><div id="36873936" class="c"><input type="checkbox" id="c-36873936" checked=""/><div class="controls bullet"><span class="by">mighmi</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869419">parent</a><span>|</span><a href="#36869900">prev</a><span>|</span><a href="#36870415">next</a><span>|</span><label class="collapse" for="c-36873936">[-]</label><label class="expand" for="c-36873936">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Introduction to Operating System Abstractions using Plan 9 from Bell Labs&quot; is the best operating system book I&#x27;ve seen - and it works through Plan9: <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;plan9designintro" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;plan9designintro</a> It isn&#x27;t quite real world as Plan9 was never used for serious production, but it is mind opening and doesn&#x27;t wallow in minutiae.</div><br/></div></div><div id="36870415" class="c"><input type="checkbox" id="c-36870415" checked=""/><div class="controls bullet"><span class="by">jjjfdjunnmko</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869419">parent</a><span>|</span><a href="#36873936">prev</a><span>|</span><a href="#36869261">next</a><span>|</span><label class="collapse" for="c-36870415">[-]</label><label class="expand" for="c-36870415">[1 more]</label></div><br/><div class="children"><div class="content">Your best bet is probably the old MVS that was open sourced back in the 70s or 80s and lives on via an emulator called Hercules. Its sufficiently different to be worth a look, it&#x27;s got a living direct descendent (although that has become increasingly turned into a Unix over the years), and there is enough of a community around it due to it having a very expensive direct descendent that the docs and other tools necessary for working with it are relatively high quality and up to date in comparison to most long dead operating systems.<p>The issue with it is that there is no way around having to do some pretty serious assembly language work for an instruction set that no longer exists and whose modern descendents probably microcode to hell in order to run some of the old instructions.</div><br/></div></div></div></div><div id="36869261" class="c"><input type="checkbox" id="c-36869261" checked=""/><div class="controls bullet"><span class="by">amedvednikov</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868507">parent</a><span>|</span><a href="#36869419">prev</a><span>|</span><a href="#36868886">next</a><span>|</span><label class="collapse" for="c-36869261">[-]</label><label class="expand" for="c-36869261">[1 more]</label></div><br/><div class="children"><div class="content">Project Oberon is amazing. Shame it isn&#x27;t more popular.</div><br/></div></div><div id="36868886" class="c"><input type="checkbox" id="c-36868886" checked=""/><div class="controls bullet"><span class="by">lproven</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868507">parent</a><span>|</span><a href="#36869261">prev</a><span>|</span><a href="#36868390">next</a><span>|</span><label class="collapse" for="c-36868886">[-]</label><label class="expand" for="c-36868886">[1 more]</label></div><br/><div class="children"><div class="content">Beautifully put. I couldn&#x27;t have said it better myself.</div><br/></div></div></div></div><div id="36868390" class="c"><input type="checkbox" id="c-36868390" checked=""/><div class="controls bullet"><span class="by">sneed_chucker</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36868507">prev</a><span>|</span><a href="#36867863">next</a><span>|</span><label class="collapse" for="c-36868390">[-]</label><label class="expand" for="c-36868390">[1 more]</label></div><br/><div class="children"><div class="content">Because we effectively live in a Unix monoculture world, in terms of operating systems that you can actually use and study the inner workings of.<p>It was a legal anomaly that resulted in early Unix (aka Research Unix) being distributed with its source code for free to universities, which was enough to get the ball rolling on stuff like BSD and Lion&#x27;s annotated V6 source code, that by the time AT&amp;T decided that closed source commercial Unix was the game it wanted to play, the cat was already out of the bag.<p>By the time the free software and open source movements had gained some ground, enough people had studied or worked on some kind of Unix kernel and Userland source code that projects like Linux, Minix, and Free&#x2F;Net&#x2F;Open BSD were feasible. The fact that Linux running on x86 subsequently ate the world was probably something few people saw coming.<p>The other lineages of operating systems, e.g. Windows NT, OpenVMS, IBM&#x27;s various offerings, either never have their source released or only have their source released long after they&#x27;re obsolete.</div><br/></div></div><div id="36867863" class="c"><input type="checkbox" id="c-36867863" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36868390">prev</a><span>|</span><a href="#36867695">next</a><span>|</span><label class="collapse" for="c-36867863">[-]</label><label class="expand" for="c-36867863">[5 more]</label></div><br/><div class="children"><div class="content">What is an OS good for if not to run programs? You either port existing programs to your API (lots of work) or design the OS with an existing API in mind. Or forget about existing programs and write entirely new programs<p>&quot;Unix-like&quot; describes the second approach, you provide a POSIX API but can have different internals<p>Now, maybe you wanted to have two APIs: one native API for the apps you write, and a translator from another, more popular API to your native API. Sounds like a lot of work when almost all software that will ever run on your OS will the translator</div><br/><div id="36868383" class="c"><input type="checkbox" id="c-36868383" checked=""/><div class="controls bullet"><span class="by">vilunov</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36867863">parent</a><span>|</span><a href="#36867695">next</a><span>|</span><label class="collapse" for="c-36868383">[-]</label><label class="expand" for="c-36868383">[4 more]</label></div><br/><div class="children"><div class="content">Often the user-space API limits the design of internals and available features. I for one would like to see the classical hierarchical filesystem gone, but POSIX (and UNIX) at its core is about the filesystem.<p>If you need to run the existing programs, feel free to develop a translation layer, at the same time allowing a new type of OS paradigm to emerge.</div><br/><div id="36874470" class="c"><input type="checkbox" id="c-36874470" checked=""/><div class="controls bullet"><span class="by">drpixie</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868383">parent</a><span>|</span><a href="#36873651">next</a><span>|</span><label class="collapse" for="c-36874470">[-]</label><label class="expand" for="c-36874470">[1 more]</label></div><br/><div class="children"><div class="content">Yes please, something that doesn&#x27;t have files, or processes. Both are too low level and require us to write or use enormous amounts of code to do very simple tasks that are performed by almost all applications. Very wasteful.<p>But lets stay away from adding another layer for our nice new abstraction. A new layer means the old ones are still there are will be used because programmers are lazy. It&#x27;s usually easier to reuse someone else&#x27;s code (that access the old layers) or reuse old methods and algorithms. In both cases, we&#x27;re moving back towards the old stuff, the stuff we want to leave behind.</div><br/></div></div><div id="36873651" class="c"><input type="checkbox" id="c-36873651" checked=""/><div class="controls bullet"><span class="by">huhlig</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868383">parent</a><span>|</span><a href="#36874470">prev</a><span>|</span><a href="#36869646">next</a><span>|</span><label class="collapse" for="c-36873651">[-]</label><label class="expand" for="c-36873651">[1 more]</label></div><br/><div class="children"><div class="content">Curious, what would you replace the classic
Hierarchical File System with? A flat key value store? We’ve tried that and it’s a nightmare.</div><br/></div></div><div id="36869646" class="c"><input type="checkbox" id="c-36869646" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868383">parent</a><span>|</span><a href="#36873651">prev</a><span>|</span><a href="#36867695">next</a><span>|</span><label class="collapse" for="c-36869646">[-]</label><label class="expand" for="c-36869646">[1 more]</label></div><br/><div class="children"><div class="content">Nobody&#x27;s stopping you from slapping on a compat layer, and ex. Haiku does that, but it&#x27;s more work than just being unixy to start with.</div><br/></div></div></div></div></div></div><div id="36867695" class="c"><input type="checkbox" id="c-36867695" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36867863">prev</a><span>|</span><a href="#36869355">next</a><span>|</span><label class="collapse" for="c-36867695">[-]</label><label class="expand" for="c-36867695">[16 more]</label></div><br/><div class="children"><div class="content">We need more Plan 9-likes!<p>But more seriously, the Unix&#x2F;POSIX-like OS is a pretty good model, but IMO we could do better, especially in the microkernel front.</div><br/><div id="36869213" class="c"><input type="checkbox" id="c-36869213" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36867695">parent</a><span>|</span><a href="#36873557">next</a><span>|</span><label class="collapse" for="c-36869213">[-]</label><label class="expand" for="c-36869213">[9 more]</label></div><br/><div class="children"><div class="content">There are a lot of things wrong with plain standard POSIX:<p>- it&#x27;s hopelessly out of date and incomplete w.r.t. modern expectations<p>- fork() is very problematic for multiple reasons, especially in a modern environment (<a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2019&#x2F;04&#x2F;fork-hotos19.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;uploads&#x2F;prod&#x2F;2019&#x2F;0...</a>)<p>- process management functions take PIDs and not capabilities, which can cause race conditions<p>- POSIX hasn&#x27;t standardized anything better than poll(), yes it works fine in a hobby context but it&#x27;s not 1987 anymore (and don&#x27;t get me started on select(): <a href="https:&#x2F;&#x2F;github.com&#x2F;SerenityOS&#x2F;serenity&#x2F;pull&#x2F;11229">https:&#x2F;&#x2F;github.com&#x2F;SerenityOS&#x2F;serenity&#x2F;pull&#x2F;11229</a>)<p>- signals are a mess<p>- Unix processes have a huge amount of ambient authority, which is problematic when trying to isolate them (chroot(), <a href="https:&#x2F;&#x2F;fuchsia.dev&#x2F;fuchsia-src&#x2F;concepts&#x2F;filesystems&#x2F;dotdot" rel="nofollow noreferrer">https:&#x2F;&#x2F;fuchsia.dev&#x2F;fuchsia-src&#x2F;concepts&#x2F;filesystems&#x2F;dotdot</a>, ...)<p>- the C POSIX library has a lot of cruft while also missing stuff what programmers actually need (for example, POSIX took nearly 6 years to standardize strlcat()&#x2F;strlcpy(), the process itself starting 17 years after OpenBSD introduced those functions: <a href="https:&#x2F;&#x2F;www.austingroupbugs.net&#x2F;view.php?id=986" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.austingroupbugs.net&#x2F;view.php?id=986</a>)<p>- ...<p>Granted, modern production-grade Unix-like operating systems have extensions to deal with most of these issues (posix_spawn, kqueue, pidfd_open...), but they are often non-standard and can be quite janky at times (dnotify, SIGIO...). It also doesn&#x27;t fix the huge amount of code out there using the legacy facilities like it&#x27;s still the 1980s.<p>There are other models out there (Plan 9, Windows, Fuchsia...), but what we really need is to stop putting Unix&#x2F;POSIX on a pedestal like some holy scripture that shall not be questioned. It&#x27;s the pinnacle of 1970s operating system designs and it has fossilized so much it&#x27;s actively turning into oil.<p>Or at the very least, please stop teaching the next generation that fork() is the greatest thing ever. It&#x27;s a 50 year old hack kept alive through gratuitous amounts of copy-on-write that should&#x27;ve been scrapped the day Unix was ported to computers with virtual memory and paging.</div><br/><div id="36871620" class="c"><input type="checkbox" id="c-36871620" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869213">parent</a><span>|</span><a href="#36869809">next</a><span>|</span><label class="collapse" for="c-36871620">[-]</label><label class="expand" for="c-36871620">[2 more]</label></div><br/><div class="children"><div class="content">At this point UNIX == Linux for the overwhelming vast majority of users&#x2F;systems out there. I&#x27;m really not a fan of this monoculture, but Linux is quite efficient and there are benefits to everyone using more or less the same platform.<p>POSIX isn&#x27;t a great standard at all, but it doesn&#x27;t really <i>have</i> to be. It&#x27;s more or less been the &quot;lowest common denominator&quot; for a system for awhile, and it&#x27;s &quot;ok&quot; at that.</div><br/><div id="36873819" class="c"><input type="checkbox" id="c-36873819" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36871620">parent</a><span>|</span><a href="#36869809">next</a><span>|</span><label class="collapse" for="c-36873819">[-]</label><label class="expand" for="c-36873819">[1 more]</label></div><br/><div class="children"><div class="content">And then they try to program on macOS....</div><br/></div></div></div></div><div id="36869809" class="c"><input type="checkbox" id="c-36869809" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869213">parent</a><span>|</span><a href="#36871620">prev</a><span>|</span><a href="#36869915">next</a><span>|</span><label class="collapse" for="c-36869809">[-]</label><label class="expand" for="c-36869809">[1 more]</label></div><br/><div class="children"><div class="content">This feels contradictory; unix isn&#x27;t good enough, so nobody implements standard unix, but people need to stop putting unix on a pedestal?</div><br/></div></div><div id="36869915" class="c"><input type="checkbox" id="c-36869915" checked=""/><div class="controls bullet"><span class="by">cdcarter</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869213">parent</a><span>|</span><a href="#36869809">prev</a><span>|</span><a href="#36873557">next</a><span>|</span><label class="collapse" for="c-36869915">[-]</label><label class="expand" for="c-36869915">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Or at the very least, please stop teaching the next generation that fork() is the greatest thing ever.<p>Who is saying this? fork() is widely maligned.</div><br/><div id="36869984" class="c"><input type="checkbox" id="c-36869984" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869915">parent</a><span>|</span><a href="#36869975">next</a><span>|</span><label class="collapse" for="c-36869984">[-]</label><label class="expand" for="c-36869984">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not my experience as a French student in the early 2010s. At the very least, I remember that the only process creation model I saw in class was fork()+exec() and there were no disclaimers about it.</div><br/><div id="36872360" class="c"><input type="checkbox" id="c-36872360" checked=""/><div class="controls bullet"><span class="by">abnry</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869984">parent</a><span>|</span><a href="#36869975">next</a><span>|</span><label class="collapse" for="c-36872360">[-]</label><label class="expand" for="c-36872360">[2 more]</label></div><br/><div class="children"><div class="content">I found it so strange that to start a child process you had to fork your current process. Not an intuitive idea to me at all.</div><br/><div id="36872450" class="c"><input type="checkbox" id="c-36872450" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36872360">parent</a><span>|</span><a href="#36869975">next</a><span>|</span><label class="collapse" for="c-36872450">[-]</label><label class="expand" for="c-36872450">[1 more]</label></div><br/><div class="children"><div class="content">I think it makes more sense when you consider that fork was originally <i>the</i> concurrency primitive in Unix. Threads came later. If you want to make some concurrent program, it makes sense to fork without exec. The fact that you <i>can</i> spawn an entirely distinct process with the fork+exec pattern is kind of a coincidence.</div><br/></div></div></div></div></div></div><div id="36869975" class="c"><input type="checkbox" id="c-36869975" checked=""/><div class="controls bullet"><span class="by">howinteresting</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869915">parent</a><span>|</span><a href="#36869984">prev</a><span>|</span><a href="#36873557">next</a><span>|</span><label class="collapse" for="c-36869975">[-]</label><label class="expand" for="c-36869975">[1 more]</label></div><br/><div class="children"><div class="content">My OS class definitely didn&#x27;t characterize fork() as maligned, just as a powerful building block (which it is). It took me professional experience to realize it sucks.</div><br/></div></div></div></div></div></div><div id="36873557" class="c"><input type="checkbox" id="c-36873557" checked=""/><div class="controls bullet"><span class="by">pkphilip</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36867695">parent</a><span>|</span><a href="#36869213">prev</a><span>|</span><a href="#36869204">next</a><span>|</span><label class="collapse" for="c-36873557">[-]</label><label class="expand" for="c-36873557">[1 more]</label></div><br/><div class="children"><div class="content">Redox OS implemented in Rust aims to be Plan-9-like:<p><a href="https:&#x2F;&#x2F;www.redox-os.org&#x2F;faq&#x2F;#how-redox-is-inspired-by-other-systems" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.redox-os.org&#x2F;faq&#x2F;#how-redox-is-inspired-by-other...</a></div><br/></div></div><div id="36869204" class="c"><input type="checkbox" id="c-36869204" checked=""/><div class="controls bullet"><span class="by">bakul</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36867695">parent</a><span>|</span><a href="#36873557">prev</a><span>|</span><a href="#36869164">next</a><span>|</span><label class="collapse" for="c-36869204">[-]</label><label class="expand" for="c-36869204">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to see an OS with a Unix API but plan9 like kernel! I will never get around to writing one myself though!</div><br/><div id="36871059" class="c"><input type="checkbox" id="c-36871059" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869204">parent</a><span>|</span><a href="#36869164">next</a><span>|</span><label class="collapse" for="c-36871059">[-]</label><label class="expand" for="c-36871059">[3 more]</label></div><br/><div class="children"><div class="content">I got <i>very</i> close to that.</div><br/><div id="36871193" class="c"><input type="checkbox" id="c-36871193" checked=""/><div class="controls bullet"><span class="by">bakul</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36871059">parent</a><span>|</span><a href="#36869164">next</a><span>|</span><label class="collapse" for="c-36871193">[-]</label><label class="expand" for="c-36871193">[2 more]</label></div><br/><div class="children"><div class="content">Which part? Designing or implementing or something else?</div><br/><div id="36871290" class="c"><input type="checkbox" id="c-36871290" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36871193">parent</a><span>|</span><a href="#36869164">next</a><span>|</span><label class="collapse" for="c-36871290">[-]</label><label class="expand" for="c-36871290">[1 more]</label></div><br/><div class="children"><div class="content">Implementing. I wrote a QnX clone and it has a lot of parallels with plan9.</div><br/></div></div></div></div></div></div></div></div><div id="36869164" class="c"><input type="checkbox" id="c-36869164" checked=""/><div class="controls bullet"><span class="by">o8vm</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36867695">parent</a><span>|</span><a href="#36869204">prev</a><span>|</span><a href="#36869355">next</a><span>|</span><label class="collapse" for="c-36869164">[-]</label><label class="expand" for="c-36869164">[1 more]</label></div><br/><div class="children"><div class="content">I would like to implement a plan9-like OS someday!</div><br/></div></div></div></div><div id="36869355" class="c"><input type="checkbox" id="c-36869355" checked=""/><div class="controls bullet"><span class="by">im_down_w_otp</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36867695">prev</a><span>|</span><a href="#36871260">next</a><span>|</span><label class="collapse" for="c-36869355">[-]</label><label class="expand" for="c-36869355">[4 more]</label></div><br/><div class="children"><div class="content">We created a funky little OS on top of seL4 &amp; Rust that&#x27;s most certainly not Unix-like, and is more akin to an RTOS-like approach to building &amp; bundling software. More for purpose-built appliances than a general purpose OS.</div><br/><div id="36871304" class="c"><input type="checkbox" id="c-36871304" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869355">parent</a><span>|</span><a href="#36871260">next</a><span>|</span><label class="collapse" for="c-36871304">[-]</label><label class="expand" for="c-36871304">[3 more]</label></div><br/><div class="children"><div class="content">Tell us more.  Who is we?</div><br/><div id="36871687" class="c"><input type="checkbox" id="c-36871687" checked=""/><div class="controls bullet"><span class="by">im_down_w_otp</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36871304">parent</a><span>|</span><a href="#36871260">next</a><span>|</span><label class="collapse" for="c-36871687">[-]</label><label class="expand" for="c-36871687">[2 more]</label></div><br/><div class="children"><div class="content">My company, <a href="https:&#x2F;&#x2F;www.auxon.io" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.auxon.io</a>. We created <a href="https:&#x2F;&#x2F;github.com&#x2F;auxoncorp&#x2F;ferros">https:&#x2F;&#x2F;github.com&#x2F;auxoncorp&#x2F;ferros</a> originally to enable a customer project early in the company&#x27;s life cycle.<p>Some time later we had another customer interested in using it and having us add some features to it (e.g. some device drivers and a persistence layer utilizing <a href="https:&#x2F;&#x2F;docs.rs&#x2F;tickv&#x2F;latest&#x2F;tickv&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;tickv&#x2F;latest&#x2F;tickv&#x2F;</a>). It was becoming a massive pain in the neck to work out source code sharing agreements with them, so we decided to just open source it.<p>There are quite a number of things that we would do differently if we had to build it again, and at some point will likely do that work to revise it. The biggest one of those is root task synthesis. The other is to build and bring in facilities for running tasks that are compiled to WASM.<p>Somewhat humorously, the fact that doing system &amp; integration testing was irritatingly challenging with a combination of FerrOS (which locks down as much as possible at runtime), and black-box binaries that couldn&#x27;t be changed, played a role in us leaning pretty hard into using trace-based testing &amp; verification techniques for our distributed systems &amp; robotics testing products.</div><br/><div id="36871724" class="c"><input type="checkbox" id="c-36871724" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36871687">parent</a><span>|</span><a href="#36871260">next</a><span>|</span><label class="collapse" for="c-36871724">[-]</label><label class="expand" for="c-36871724">[1 more]</label></div><br/><div class="children"><div class="content">Nice. I like.</div><br/></div></div></div></div></div></div></div></div><div id="36871260" class="c"><input type="checkbox" id="c-36871260" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36869355">prev</a><span>|</span><a href="#36870284">next</a><span>|</span><label class="collapse" for="c-36871260">[-]</label><label class="expand" for="c-36871260">[1 more]</label></div><br/><div class="children"><div class="content">Is it perhaps interoperability?<p>If you&#x27;re not <i>that</i> serious about it, it&#x27;s a way to get a bit more for free?<p>Contrast Redux, which is quite a serious (not in the &#x27;we compete with Windows&#x27; sense, but still) project I gather, which... I don&#x27;t know how they describe it, but it&#x27;s sort of Unix-ish, Unix-rethought? I&#x27;ve never actually played with it, but loved the idea of &#x27;everything is a url&#x27; (not file) when I heard it described &amp; explained on <i>The Bike Shed</i> podcast I think.</div><br/></div></div><div id="36870284" class="c"><input type="checkbox" id="c-36870284" checked=""/><div class="controls bullet"><span class="by">smasher164</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36871260">prev</a><span>|</span><a href="#36873787">next</a><span>|</span><label class="collapse" for="c-36870284">[-]</label><label class="expand" for="c-36870284">[1 more]</label></div><br/><div class="children"><div class="content">It’s hard enough to learn osdev. If you have a concrete design to fall back on, you can focus on implementation.<p>Coming up with an original design for OSes is like a 3rd project thing.</div><br/></div></div><div id="36873787" class="c"><input type="checkbox" id="c-36873787" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36870284">prev</a><span>|</span><a href="#36867733">next</a><span>|</span><label class="collapse" for="c-36873787">[-]</label><label class="expand" for="c-36873787">[1 more]</label></div><br/><div class="children"><div class="content">Because it is less effort to copy already existing stacks, than be creative in trailing not yet discovered paths.</div><br/></div></div><div id="36867733" class="c"><input type="checkbox" id="c-36867733" checked=""/><div class="controls bullet"><span class="by">crickey</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36873787">prev</a><span>|</span><a href="#36870012">next</a><span>|</span><label class="collapse" for="c-36867733">[-]</label><label class="expand" for="c-36867733">[2 more]</label></div><br/><div class="children"><div class="content">What is even Unix-like ? I usually associate it with POSIX but maybe thats naive</div><br/><div id="36871308" class="c"><input type="checkbox" id="c-36871308" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36867733">parent</a><span>|</span><a href="#36870012">next</a><span>|</span><label class="collapse" for="c-36871308">[-]</label><label class="expand" for="c-36871308">[1 more]</label></div><br/><div class="children"><div class="content">The general design of users, processes, files, etc.<p>It&#x27;s obviously not that well-defined since it&#x27;s implicitly &#x27;not Unix&#x27;, so can diverge. Just anything that&#x27;s subjectively similar to that OS design.</div><br/></div></div></div></div><div id="36870012" class="c"><input type="checkbox" id="c-36870012" checked=""/><div class="controls bullet"><span class="by">zvmaz</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36867733">prev</a><span>|</span><a href="#36873706">next</a><span>|</span><label class="collapse" for="c-36870012">[-]</label><label class="expand" for="c-36870012">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s XINU (Xinu&#x27;s Not Unix). There&#x27;s a book that walks you through the complete implementation of the OS in C [1].<p>[1] <a href="https:&#x2F;&#x2F;xinu.cs.purdue.edu&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xinu.cs.purdue.edu&#x2F;</a></div><br/></div></div><div id="36873706" class="c"><input type="checkbox" id="c-36873706" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36870012">prev</a><span>|</span><a href="#36870376">next</a><span>|</span><label class="collapse" for="c-36873706">[-]</label><label class="expand" for="c-36873706">[1 more]</label></div><br/><div class="children"><div class="content">It is only marketing. It does not seem to implement anything from POSIX or SUS.</div><br/></div></div><div id="36870376" class="c"><input type="checkbox" id="c-36870376" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36873706">prev</a><span>|</span><a href="#36869985">next</a><span>|</span><label class="collapse" for="c-36870376">[-]</label><label class="expand" for="c-36870376">[1 more]</label></div><br/><div class="children"><div class="content">Unix is a lot more amenable than most older OSes to being implemented by a disparate group of people with limited communication, hence why GNU was originally set up as a reimplementation of unix.</div><br/></div></div><div id="36869985" class="c"><input type="checkbox" id="c-36869985" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36870376">prev</a><span>|</span><a href="#36871054">next</a><span>|</span><label class="collapse" for="c-36869985">[-]</label><label class="expand" for="c-36869985">[2 more]</label></div><br/><div class="children"><div class="content">I think the main selling point for Unix-like OS, but in Rust, is focused on Rust.  It&#x27;s to ensure that the memory related errors are less likely, and hopefully with enough work, the system can be essentially what we have today, but with less CVEs.<p>It&#x27;s honestly a decent goal and I&#x27;m in support of it.<p>I know that there will inevitably be many now that come to state the obvious &quot;well it doesn&#x27;t <i>guarantee</i> safety&quot; and &quot;there are other reasons for CVE&quot;, etc.  Nonetheless, it&#x27;s not a bad idea.</div><br/></div></div><div id="36871054" class="c"><input type="checkbox" id="c-36871054" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36869985">prev</a><span>|</span><a href="#36872691">next</a><span>|</span><label class="collapse" for="c-36871054">[-]</label><label class="expand" for="c-36871054">[1 more]</label></div><br/><div class="children"><div class="content">Because if you manage to get to some level of POSIX compatibility you can leverage that into having a whole toolchain and lots of other goodies up and running in a relatively short time. This limits the amount of effort required to get to &#x27;first base&#x27;, a self hosting environment.</div><br/></div></div><div id="36872691" class="c"><input type="checkbox" id="c-36872691" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36871054">prev</a><span>|</span><a href="#36871824">next</a><span>|</span><label class="collapse" for="c-36872691">[-]</label><label class="expand" for="c-36872691">[1 more]</label></div><br/><div class="children"><div class="content">At both extreme opposite ends of the scale&#x2F;funding&#x2F;people spectrum we already have TempleOS and Fuscia, and probably countless in between. You tell me why they aren&#x27;t going anywhere even though any properties you might say about one, the other has the opposite quality and is also going nowhere.<p>Maybe &quot;unix-like&quot; is really just a principle that has no expiration date, like &quot;murder is wrong&quot;.<p>Depending on how slavishly you define &quot;unix-like&quot;, for instance, I would not say that the principle philosophy dictates there shall always be a command named &quot;rm&quot; that takes these options and does this task a la posix specs.<p>But for today and certainly any forseeable time, it&#x27;s perfectly useful to &quot;merely&quot; reimplement posix.</div><br/></div></div><div id="36871824" class="c"><input type="checkbox" id="c-36871824" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36872691">prev</a><span>|</span><a href="#36870189">next</a><span>|</span><label class="collapse" for="c-36871824">[-]</label><label class="expand" for="c-36871824">[1 more]</label></div><br/><div class="children"><div class="content">Because of the availability of the source code under a permissive licence that UNIX has been distributed under for a long time. Other operating systems source code still remains unavailable, sometimes decades after the hardware they used to run on had disappeared.<p>The second reason is the simplicity of abstractions and the ease of their implementation. In the original DEC documentation on RSX-11M (the predecessor of VAX VMS), for example, there is <i>a whole chapter</i> describing how to create <i>and</i> fill in a file descriptor block (a complex record data structure) required <i>just to open a file</i> where the user has to decide beforehand where to locate the file, whether they want to access the data [blocks] randomly or sequentially, whether the file is being opened merely for updating the data but not extending the file size or for updating the data <i>and</i> extending the file, whether allow or not other processes to access the same file whilst it is open, the number of in-memory buffers for the kernel to allocate for file access etc etc. Many complex decisions have to be made <i>before</i> a file can be opened. In UNIX, on the other hand, it is a mere «int fd = open (&quot;myfile&quot;, O_RDONLY);», the end.<p>Granted, not every OS has had such complexities (the opposite is also true, tho). Yet, the simplified (one can argue that it has been oversimplified) UNIX abstractions have been influential for a reason.</div><br/></div></div><div id="36870189" class="c"><input type="checkbox" id="c-36870189" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36871824">prev</a><span>|</span><a href="#36868520">next</a><span>|</span><label class="collapse" for="c-36870189">[-]</label><label class="expand" for="c-36870189">[1 more]</label></div><br/><div class="children"><div class="content">Because the only large, available, free ecosystem of software (both applications and hardware drivers) is completely built around the Unix abstractions.<p>If you don&#x27;t want to do Unix, you have to reduplicate <i>ALL</i> of it.  And that&#x27;s like trying to boil the ocean.</div><br/></div></div><div id="36868520" class="c"><input type="checkbox" id="c-36868520" checked=""/><div class="controls bullet"><span class="by">guerrilla</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36870189">prev</a><span>|</span><a href="#36867999">next</a><span>|</span><label class="collapse" for="c-36868520">[-]</label><label class="expand" for="c-36868520">[13 more]</label></div><br/><div class="children"><div class="content">If it ain&#x27;t broke, don&#x27;t fix it.<p>All kinds of new OS ideas can be implemented on UNIX like Mach[1], FLASK[2] and 9P[3] while internally a UNIX-like system doesn&#x27;t need to be anything like a UNIX[4]... So who cares? What are you worried about losing? What can&#x27;t be implemented on a UNIX-like system?<p>1. see MacOS<p>2. see SELinux<p>3. see v9fs<p>4. see Windows and BeOS which both have POSIX APIs</div><br/><div id="36869253" class="c"><input type="checkbox" id="c-36869253" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868520">parent</a><span>|</span><a href="#36871382">next</a><span>|</span><label class="collapse" for="c-36869253">[-]</label><label class="expand" for="c-36869253">[9 more]</label></div><br/><div class="children"><div class="content">The problem is that anything you build on top of Unix will always be a second class citizen in the Unix world.<p>For example, suppose you want a database-like filesystem. Either you implement it in the kernel, and now your special apps barely work on anyone’s computers. Or you implement it in userspace - preferably as a library. And now your apps can run anywhere without special kernel features but the terminal, and all the other applications on the computer can’t &#x2F; won’t understand your new abstraction. And you’ll be fighting an uphill battle to get anyone to care about your new thing, let alone integrate it.<p>It’s like saying - why rust? Why not just add a borrow checker to C? Why didn’t C# just add a garbage collector to C++? Sometimes starting fresh and establishing a clear, clean environment with different norms is the most effective way to make something new. You don’t have to fight as many battles. You can remove obsolete things. You don’t have to fight with the platform conventions, or fight the old guard who like things as they are.<p>It’s a shame with operating systems that modern device drivers are so complicated. Hobbyist operating systems seem inordinately difficult to make these days as a result, and that’s a pity. There’s all sorts of good ideas out there that I’d love to see explored.</div><br/><div id="36874004" class="c"><input type="checkbox" id="c-36874004" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869253">parent</a><span>|</span><a href="#36873665">next</a><span>|</span><label class="collapse" for="c-36874004">[-]</label><label class="expand" for="c-36874004">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The problem is that anything you build on top of Unix will always be a second class citizen in the Unix world.<p>Is first-class support required? Even things as fundamental as executing programs (the elf loader, for example) can be a second-class citizen without users noticing.<p>&gt; For example, suppose you want a database-like filesystem. Either you implement it in the kernel, and now your special apps barely work on anyone’s computers. Or you implement it in userspace - preferably as a library. And now your apps can run anywhere without special kernel features but the terminal, and all the other applications on the computer can’t &#x2F; won’t understand your new abstraction.<p>So implement it in the kernel anyway (write the driver). How does having a whole new OS in which <i>this particular</i> filesystem is first-class help? It doesn&#x27;t help your argument that all filesystem drivers, by your definitions, are second-class citizens, and no one cares.<p>I&#x27;m actually rather keen to know what downside there is for not trying out your new idea in an existing OS.<p>After all, if your new idea is any good the existing OSes will adopt it anyway making it pointless for newcomers to try your new OS.</div><br/><div id="36874276" class="c"><input type="checkbox" id="c-36874276" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36874004">parent</a><span>|</span><a href="#36873665">next</a><span>|</span><label class="collapse" for="c-36874276">[-]</label><label class="expand" for="c-36874276">[1 more]</label></div><br/><div class="children"><div class="content">This conversation is tricky because there are technical questions (what is in userland vs in kernel?). But the real question of whether something is a first class citizen is whether it’s part of the ecosystem, such that essentially all software can depend on it being available. The elf loader is clearly part of the Linux ecosystem, regardless of whether it’s in userland or kernel space. All shipped Linux software just assumes elf is part of the system. Zfs is not, even though you can apparently get it to run as a kernel module.<p>&gt; I&#x27;m actually rather keen to know what downside there is for not trying out your new idea in an existing OS.<p>It might be more fun. It might be easier to experiment, since you don’t need to read or change as much code. And it might be easier to make a new community than it is to convince people in the existing community to take your patches seriously. - Eg like what happens in programming languages.<p>Long running software projects like Linux are conservative - and for good reason. But the result is that there’s a lot of potentially good OS ideas that Linux will never adopt at this point its lifecycle. (Eg, “What if everything <i>wasn’t</i> a file?” &#x2F; “what if we formally verified all the code in the kernel?” &#x2F; etc.)</div><br/></div></div></div></div><div id="36873665" class="c"><input type="checkbox" id="c-36873665" checked=""/><div class="controls bullet"><span class="by">midoridensha</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869253">parent</a><span>|</span><a href="#36874004">prev</a><span>|</span><a href="#36869534">next</a><span>|</span><label class="collapse" for="c-36873665">[-]</label><label class="expand" for="c-36873665">[3 more]</label></div><br/><div class="children"><div class="content">&gt;For example, suppose you want a database-like filesystem. Either you implement it in the kernel, and now your special apps barely work on anyone’s computers.<p>Filesystems already are databases.  They organize and catalog data, and provide various other metadata about the data stored in them (creation and modification times, permissions, etc.).<p>Many people have invented various other databases, some SQL, others noSQL, which all require special apps to use.  Many of these have been successful.</div><br/><div id="36873807" class="c"><input type="checkbox" id="c-36873807" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36873665">parent</a><span>|</span><a href="#36869534">next</a><span>|</span><label class="collapse" for="c-36873807">[-]</label><label class="expand" for="c-36873807">[2 more]</label></div><br/><div class="children"><div class="content">The filesystem is a crappy database. Its purely hierarchical nature requires dirty compromises for things like music libraries, where you want songs to be indexed both by song name and by album. Filesystems are also lacking atomic update mechanisms (transactions). There’s no way to enforce data integrity - files are weakly typed. You need fsync on linux to know that your data has been written at all - but fsync is horribly slow. And even fsync doesn&#x27;t save you from data corruption due to skewed writes.<p>You can use a userland database on top of linux. But that has different properties from the OS’s actual filesystem for ecosystem reasons. A Postgres instance will never be a first class citizen on Unix. I can’t “cd” into a sql table in my terminal, or use sql queries to query procfs or &#x2F;etc. What would it mean to pipe into a table? Does that abstraction even make sense? An operating system built on top of a database would be different from unix because the ecosystem of userland applications would evolve in a different direction. See, for example, HaikuOS.<p>I’m not saying it’s a good or a bad idea. But simply firing up mongodb on a Linux server isn’t the same thing as building the whole OS with a real database at its core.</div><br/><div id="36874566" class="c"><input type="checkbox" id="c-36874566" checked=""/><div class="controls bullet"><span class="by">midoridensha</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36873807">parent</a><span>|</span><a href="#36869534">next</a><span>|</span><label class="collapse" for="c-36874566">[-]</label><label class="expand" for="c-36874566">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The filesystem is a crappy database. Its purely hierarchical nature<p>You realize the first databases were hierarchical, not relational, right?  Filesystems do well enough in this regard.  They&#x27;re not meant to store tons of metadata, which varies depending on your application.<p>&gt;requires dirty compromises for things like music libraries, where songs should be indexed both by song name and by album.<p>What about songs that aren&#x27;t on albums?  What about live performances?  What about cover songs?  Who gets the credit, the performer or the composer?  People&#x27;s opinions about these things keep changing, which is why the original MP3 tag format was so bad, and had to be replaced by a newer format.  Imagine if we were all stuck, forever, with what some clueless people in 1995 thought was good enough for MP3 tag info, for all digital music.<p>And why should this info be in a filesystem anyway?  Most files are not digital music.<p>&gt;A Postgres instance will never be a first class citizen on Unix, so I can’t “cd” into a sql table in my terminal, or use sql queries to query procfs or &#x2F;etc.<p>Right, because then the OS would have had to be designed for that kind of thing from the start, and you&#x27;d never be able to change it afterwards.  This is why we keep things minimal at the lower levels, because then you can change things easily at the higher levels later on as needs change.  Postgres itself has changed a lot in the last 10 years, adding lots of capabilities; if that were baked into the OS, that wouldn&#x27;t have been so easy.  And what if you decide you want something different from SQL?  Sorry, you&#x27;re stuck with it because it&#x27;s baked into the OS, so now someone else is going to complain about how our ecosystem could evolve in a different way if we adopted some other type of database paradigm.<p>The benefits you claim just aren&#x27;t worth the cost.  It&#x27;s easy enough to implement a database on top of a modern OS, and then use tools and applications designed for it to interact with it.</div><br/></div></div></div></div></div></div><div id="36869534" class="c"><input type="checkbox" id="c-36869534" checked=""/><div class="controls bullet"><span class="by">guerrilla</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869253">parent</a><span>|</span><a href="#36873665">prev</a><span>|</span><a href="#36871382">next</a><span>|</span><label class="collapse" for="c-36869534">[-]</label><label class="expand" for="c-36869534">[3 more]</label></div><br/><div class="children"><div class="content">Nobody&#x27;s stopping you from doing that but apparently none of OP&#x27;s ideas required that, nor has it been worth it for anyone else&#x27;s yet either. If it ain&#x27;t broke, don&#x27;t fix it. Let me know when it&#x27;s actually broke in this actual reality. Then we can start over*.<p>Also all those languages are Cs in the same way BSD and Linux are UNIXs. Same family. You should have mentioned Haskell or APL instead.<p>* Note that many experiments did start over, e.g. Plan9, but were then integrated into a UNIX.</div><br/><div id="36873282" class="c"><input type="checkbox" id="c-36873282" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36869534">parent</a><span>|</span><a href="#36871382">next</a><span>|</span><label class="collapse" for="c-36873282">[-]</label><label class="expand" for="c-36873282">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Also all those languages are Cs in the same way BSD and Linux are UNIXs. Same family. You should have mentioned Haskell or APL instead.<p>But look! Even though those programming languages are in the same family, it was still worth starting over when they were made! Zig and C are incredibly similar languages, but Andrew Kelly didn’t try and convince the C standards committee to adopt his ideas. He just went and made Zig from scratch. And I’m glad he did! It would have taken decades to drag C in that direction - if it’s possible at all.<p>Another example: Khtml wasn’t based on Firefox (the big contemporary opensource browser). It was a new browser engine with new ideas. And the design was so good it was used as the basis of Chrome.<p>Don’t get me wrong - I think it’s great that plan9 experiments did eventually make it back into Linux. But doing the experiments in a separate kernel &#x2F; OS still makes a lot of sense to me. Old, established technology like linux, FreeBSD, the C programming language, or something like the HTTP spec all need to move slowly because they’re depended on by so many people and companies. That is anathema to wild, new ideas.</div><br/><div id="36873638" class="c"><input type="checkbox" id="c-36873638" checked=""/><div class="controls bullet"><span class="by">guerrilla</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36873282">parent</a><span>|</span><a href="#36871382">next</a><span>|</span><label class="collapse" for="c-36873638">[-]</label><label class="expand" for="c-36873638">[1 more]</label></div><br/><div class="children"><div class="content">Nobody&#x27;s forking UNIXs or convincing UNIX standards committees (if they still exist?) of anything...</div><br/></div></div></div></div></div></div></div></div><div id="36871382" class="c"><input type="checkbox" id="c-36871382" checked=""/><div class="controls bullet"><span class="by">flykespice</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868520">parent</a><span>|</span><a href="#36869253">prev</a><span>|</span><a href="#36869004">next</a><span>|</span><label class="collapse" for="c-36871382">[-]</label><label class="expand" for="c-36871382">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If it ain&#x27;t broke, don&#x27;t fix it.<p>I always hated this caveman mentality.<p>So should we hinder progress&#x2F;try out new ideas because things as is aren&#x27;t broke?</div><br/><div id="36873648" class="c"><input type="checkbox" id="c-36873648" checked=""/><div class="controls bullet"><span class="by">midoridensha</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36871382">parent</a><span>|</span><a href="#36869004">next</a><span>|</span><label class="collapse" for="c-36873648">[-]</label><label class="expand" for="c-36873648">[1 more]</label></div><br/><div class="children"><div class="content">No one is stopping you from spending your time reinventing the wheel.  Many people have tried; a few succeeded and made better wheels.</div><br/></div></div></div></div><div id="36869004" class="c"><input type="checkbox" id="c-36869004" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36868520">parent</a><span>|</span><a href="#36871382">prev</a><span>|</span><a href="#36867999">next</a><span>|</span><label class="collapse" for="c-36869004">[-]</label><label class="expand" for="c-36869004">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t Windows drop the POSIX APIs and then eventually introduce WSL instead?</div><br/></div></div></div></div><div id="36867999" class="c"><input type="checkbox" id="c-36867999" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36868520">prev</a><span>|</span><a href="#36867868">next</a><span>|</span><label class="collapse" for="c-36867999">[-]</label><label class="expand" for="c-36867999">[1 more]</label></div><br/><div class="children"><div class="content">Why does it seem like 80 to 90% of hobby OS projects that are announced here as &quot;Unix-like&quot; invariably get <i>someone</i> who replies with &quot;that thing you&#x27;re doing as a hobby, for fun...you&#x27;re doing it wrong and I don&#x27;t approve&quot;.  Zero content, zero insight posts about someones else&#x27;s toy aren&#x27;t useful.  You want a &#x27;new model&#x27;, start coding.</div><br/></div></div><div id="36867868" class="c"><input type="checkbox" id="c-36867868" checked=""/><div class="controls bullet"><span class="by">jijji</span><span>|</span><a href="#36867643">parent</a><span>|</span><a href="#36867999">prev</a><span>|</span><a href="#36869399">next</a><span>|</span><label class="collapse" for="c-36867868">[-]</label><label class="expand" for="c-36867868">[2 more]</label></div><br/><div class="children"><div class="content">its better than being OS400-like, isnt it?</div><br/><div id="36868044" class="c"><input type="checkbox" id="c-36868044" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#36867643">root</a><span>|</span><a href="#36867868">parent</a><span>|</span><a href="#36869399">next</a><span>|</span><label class="collapse" for="c-36868044">[-]</label><label class="expand" for="c-36868044">[1 more]</label></div><br/><div class="children"><div class="content">OS&#x2F;400 is actually really interesting and very well thought out, particularly as an example of &quot;Not Unix&quot;.  I wouldn&#x27;t want to make my living there, but lots of people do.</div><br/></div></div></div></div></div></div><div id="36869399" class="c"><input type="checkbox" id="c-36869399" checked=""/><div class="controls bullet"><span class="by">xolve</span><span>|</span><a href="#36867643">prev</a><span>|</span><a href="#36868587">next</a><span>|</span><label class="collapse" for="c-36869399">[-]</label><label class="expand" for="c-36869399">[4 more]</label></div><br/><div class="children"><div class="content">OP, would be nice if you add a license to the repo.</div><br/><div id="36869576" class="c"><input type="checkbox" id="c-36869576" checked=""/><div class="controls bullet"><span class="by">o8vm</span><span>|</span><a href="#36869399">parent</a><span>|</span><a href="#36868587">next</a><span>|</span><label class="collapse" for="c-36869576">[-]</label><label class="expand" for="c-36869576">[3 more]</label></div><br/><div class="children"><div class="content">Thanks! Is this notation in the README not enough: <a href="https:&#x2F;&#x2F;github.com&#x2F;o8vm&#x2F;octox#license">https:&#x2F;&#x2F;github.com&#x2F;o8vm&#x2F;octox#license</a> ?</div><br/><div id="36871725" class="c"><input type="checkbox" id="c-36871725" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#36869399">root</a><span>|</span><a href="#36869576">parent</a><span>|</span><a href="#36868587">next</a><span>|</span><label class="collapse" for="c-36871725">[-]</label><label class="expand" for="c-36871725">[2 more]</label></div><br/><div class="children"><div class="content">Both those licenses require you to add the license text as a file to the codebase. Eg see the &quot;How to apply the Apache License to your work&quot; section in the Apache license link that you have there.<p>Since it&#x27;s dual-licensed you can add one as LICENSE-MIT and the other as LICENSE-APACHE.</div><br/><div id="36872171" class="c"><input type="checkbox" id="c-36872171" checked=""/><div class="controls bullet"><span class="by">o8vm</span><span>|</span><a href="#36869399">root</a><span>|</span><a href="#36871725">parent</a><span>|</span><a href="#36868587">next</a><span>|</span><label class="collapse" for="c-36872171">[-]</label><label class="expand" for="c-36872171">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I see! Thank you very much. I&#x27;ll add both later!</div><br/></div></div></div></div></div></div></div></div><div id="36868587" class="c"><input type="checkbox" id="c-36868587" checked=""/><div class="controls bullet"><span class="by">prydt</span><span>|</span><a href="#36869399">prev</a><span>|</span><a href="#36867889">next</a><span>|</span><label class="collapse" for="c-36868587">[-]</label><label class="expand" for="c-36868587">[2 more]</label></div><br/><div class="children"><div class="content">Awesome! What are some good resources on making a simple UNIX like operating system? I know osdev wiki exists, anything else?</div><br/><div id="36869041" class="c"><input type="checkbox" id="c-36869041" checked=""/><div class="controls bullet"><span class="by">o8vm</span><span>|</span><a href="#36868587">parent</a><span>|</span><a href="#36867889">next</a><span>|</span><label class="collapse" for="c-36869041">[-]</label><label class="expand" for="c-36869041">[1 more]</label></div><br/><div class="children"><div class="content">Thanks！For me <a href="https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.S081&#x2F;2020&#x2F;xv6&#x2F;book-riscv-rev1.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.S081&#x2F;2020&#x2F;xv6&#x2F;book-riscv-rev1.p...</a> was quite helpful! but Someday I will write a book on how to implement this OS step by step in Japanese.</div><br/></div></div></div></div><div id="36867889" class="c"><input type="checkbox" id="c-36867889" checked=""/><div class="controls bullet"><span class="by">mysterydip</span><span>|</span><a href="#36868587">prev</a><span>|</span><a href="#36868533">next</a><span>|</span><label class="collapse" for="c-36867889">[-]</label><label class="expand" for="c-36867889">[7 more]</label></div><br/><div class="children"><div class="content">What does &quot;written in safe Rust as much as possible&quot; mean? Are there functions with no equivalent in rust?</div><br/><div id="36867914" class="c"><input type="checkbox" id="c-36867914" checked=""/><div class="controls bullet"><span class="by">OtomotO</span><span>|</span><a href="#36867889">parent</a><span>|</span><a href="#36868533">next</a><span>|</span><label class="collapse" for="c-36867914">[-]</label><label class="expand" for="c-36867914">[6 more]</label></div><br/><div class="children"><div class="content">Interfacing with hardware means you have to drop to &quot;unsafe&quot; rust at some (few) points.<p>&quot;Unsafe&quot; rust isn&#x27;t named good, because it&#x27;s still safer than e.g. C.<p>Some invariants you cannot break in rust, no matter if &quot;safe&quot; or &quot;unsafe&quot;</div><br/><div id="36870613" class="c"><input type="checkbox" id="c-36870613" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36867889">root</a><span>|</span><a href="#36867914">parent</a><span>|</span><a href="#36870671">next</a><span>|</span><label class="collapse" for="c-36870613">[-]</label><label class="expand" for="c-36870613">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s still safer than e.g. C.<p>This is arguable and I think overall it&#x27;s actually harder to correctly write unsafe Rust, even if sometimes maybe in some sense safer than C when you screw up.<p>In Rust everything has to obey Rust&#x27;s semantic constraints. For <i>safe</i> Rust that&#x27;s fine because the language itself promises you&#x27;re obeying. You can&#x27;t introduce anything which would be a problem, so you needn&#x27;t even care what those problems are.<p>But in <i>unsafe</i> Rust you are responsible for the same guarantees that safe Rust gave everybody. And the rules you&#x27;re responsible for obeying are <i>truly difficult</i> so that you may not properly understand them. If you screw up, that&#x27;s instantly Undefined Behaviour.<p>Let&#x27;s take a fairly old but brutal real example from Rust&#x27;s standard library. core::mem::uninitialized&lt;T&gt;(). This function is labelled deprecated (as well as unsafe) in your Rust, but once upon a time it was the usual way to make some uninitialized buffer in which to construct something.<p>But it was actually UB almost always†. Because what it says is, OK, I know I didn&#x27;t initialize a T, but trust me, I&#x27;ll sort that out later, lets say this is a T anyway. And for a time people persuaded themselves that this is OK for at least some types. After all, if T was u8 (a byte) then who cares what its value is, any value is valid, isn&#x27;t it? Well, yes, but &quot;uninitialized&quot; isn&#x27;t a value, it&#x27;s a 257th possible state, the compiler <i>knows</i> we didn&#x27;t initialize this, and therefore all optimisations are valid even if they wouldn&#x27;t be valid for <i>any</i> possible initialized state of the memory - we didn&#x27;t initialize it so we&#x27;re not entitled to assume it had any of those values.<p>In C you will get away with this but in Rust you&#x27;ve created Undefined Behaviour, which is not OK. Today you would use the MaybeUninit&lt;T&gt; type so that you can explicitly initialize it (once you have something to initialize it with) and <i>then</i> MaybeUninit::assume_init() to get your T instead now that it&#x27;s initialized, and (if you did it correctly) <i>that</i> is safe.<p>† If T is a Zero Size Type then this function isn&#x27;t dangerous, because it makes nothing and then says this nothing is actually a T, and the compiler says well, thanks for telling me, I don&#x27;t really care but whatever. No UB. Likely this only happens in generic code, but it&#x27;s safe.</div><br/><div id="36870873" class="c"><input type="checkbox" id="c-36870873" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#36867889">root</a><span>|</span><a href="#36870613">parent</a><span>|</span><a href="#36870671">next</a><span>|</span><label class="collapse" for="c-36870873">[-]</label><label class="expand" for="c-36870873">[1 more]</label></div><br/><div class="children"><div class="content">part of the problem is that rust has not yet a standardized memory model (there are candidates, wip)<p>this means there are limits to soundness analysis tools and guardrails you can provide ins table rust<p>through there had been pretty convincing examples about how under some of the (more promising) memory model candidates you can provide additional&#x2F;different functions which are much harder to accidentally misuse<p>and soundness analysis tools do already exist, too<p>I believe that rust has the _potential_ to make it easier to write a lot of unsafe code correctly in rust then in C -- in the future.<p>Through the issue with people using a &quot;it&#x27;s only bits&quot; mind set when doing unsafe code stays around, and is wrong, not just in rust but in C, too. No matter how much some people try to pretend C is a high level assembly.</div><br/></div></div></div></div><div id="36870671" class="c"><input type="checkbox" id="c-36870671" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#36867889">root</a><span>|</span><a href="#36867914">parent</a><span>|</span><a href="#36870613">prev</a><span>|</span><a href="#36869167">next</a><span>|</span><label class="collapse" for="c-36870671">[-]</label><label class="expand" for="c-36870671">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some invariants you cannot break in rust, no matter if &quot;safe&quot; or &quot;unsafe&quot;<p>a better description IMHO is that unsafe rust enables additional functions which are normally not usable as they can create unsoundness if used incorrectly<p>because this are just additional functions it means also the checks and type safety of all other code is still always there and normally sound, as long as you don&#x27;t misuse the additional functions to brake invariants<p>I do count pointer dereferencing as a function converting a pointer to a reference in this context, it&#x27;s technically not quite right, but conceptually not really wrong either.<p>So e.g. unsafe rust don&#x27;t allow you to write to a &amp;T (immutable reference), but using unsafe you could technically bit-wise transmute the &amp;T into a &amp;mut T (100% guaranteed unsound!!!) and write to that.  Still at any point all constraints when handling &amp;T did still apply and so do constraints of handling &amp;mut T, you just (unsoundly) converted one into another using an additional function unlocked by using unsafe.</div><br/></div></div><div id="36869167" class="c"><input type="checkbox" id="c-36869167" checked=""/><div class="controls bullet"><span class="by">xeonmc</span><span>|</span><a href="#36867889">root</a><span>|</span><a href="#36867914">parent</a><span>|</span><a href="#36870671">prev</a><span>|</span><a href="#36868533">next</a><span>|</span><label class="collapse" for="c-36869167">[-]</label><label class="expand" for="c-36869167">[2 more]</label></div><br/><div class="children"><div class="content">Would it be more aptly named “risky rust”?</div><br/><div id="36869797" class="c"><input type="checkbox" id="c-36869797" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36867889">root</a><span>|</span><a href="#36869167">parent</a><span>|</span><a href="#36868533">next</a><span>|</span><label class="collapse" for="c-36869797">[-]</label><label class="expand" for="c-36869797">[1 more]</label></div><br/><div class="children"><div class="content">Yes! Another apt name would be &quot;trustme&quot;. (The normal case in Rust is trust the compiler - and all the people who wrote &quot;trustme&quot; code that you depend on!)</div><br/></div></div></div></div></div></div></div></div><div id="36868533" class="c"><input type="checkbox" id="c-36868533" checked=""/><div class="controls bullet"><span class="by">cnuts</span><span>|</span><a href="#36867889">prev</a><span>|</span><a href="#36865850">next</a><span>|</span><label class="collapse" for="c-36868533">[-]</label><label class="expand" for="c-36868533">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s really cool, great job!</div><br/></div></div><div id="36871839" class="c"><input type="checkbox" id="c-36871839" checked=""/><div class="controls bullet"><span class="by">freecodyx</span><span>|</span><a href="#36865850">prev</a><span>|</span><label class="collapse" for="c-36871839">[-]</label><label class="expand" for="c-36871839">[2 more]</label></div><br/><div class="children"><div class="content">Not related to the project. Most of the code is unsafe. I really find rust counterintuitive.<p>This is just a note to myself.
* rust uses llvm as a backend
* rust tries to solve the memory issues commonly found in C bu enforcing a programming paradigm which allow the compiler to detect them at compile time.
* it tries to provide 0 cost abstractions<p>It works but the code is ugly</div><br/><div id="36872118" class="c"><input type="checkbox" id="c-36872118" checked=""/><div class="controls bullet"><span class="by">segfaltnh</span><span>|</span><a href="#36871839">parent</a><span>|</span><label class="collapse" for="c-36872118">[-]</label><label class="expand" for="c-36872118">[1 more]</label></div><br/><div class="children"><div class="content">Wait, most of _what_ code is unsafe? Aside from this one comment it sounds like you just came here to shit on Rust, lol.</div><br/></div></div></div></div></div></div></div></div></div></body></html>