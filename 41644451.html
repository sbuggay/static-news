<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727686865557" as="style"/><link rel="stylesheet" href="styles.css?v=1727686865557"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoAndPromisesPattern">Go and my realization about what I&#x27;ll call the &#x27;Promises&#x27; pattern</a>Â <span class="domain">(<a href="https://utcc.utoronto.ca">utcc.utoronto.ca</a>)</span></div><div class="subtext"><span>ingve</span> | <span>40 comments</span></div><br/><div><div id="41693988" class="c"><input type="checkbox" id="c-41693988" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41693781">next</a><span>|</span><label class="collapse" for="c-41693988">[-]</label><label class="expand" for="c-41693988">[6 more]</label></div><br/><div class="children"><div class="content">I love how most of the responses to this article here blame the author for wanting the wrong thing. One could implement a future struct that is awaitable and then the scaffolding to wait on a bunch of them. I have done things like this in other languages, it can be immensely useful. Similarly, when some wanted generics, they were bemoaned for wanting the wrong thing. Go is a wonderful language, even if it is not my cup of tea. But must its users be this defensive?</div><br/><div id="41694197" class="c"><input type="checkbox" id="c-41694197" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41693988">parent</a><span>|</span><a href="#41694748">next</a><span>|</span><label class="collapse" for="c-41694197">[-]</label><label class="expand" for="c-41694197">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is defensiveness so much as that attempting to model promises in languages like Go will result in bad, nonidiomatic code, and that is a thing that happens semiregularly with Go in particular, as it has so many refugees from other languages with sharply different idioms.<p>Here, we&#x27;re discussing <i>implementing future structs</i> just to print DNS results in order. I don&#x27;t think the UX proposed in the post is good, but stipulate that it is; this is not a hard problem to solve in idiomatic Go.</div><br/><div id="41694651" class="c"><input type="checkbox" id="c-41694651" checked=""/><div class="controls bullet"><span class="by">arethuza</span><span>|</span><a href="#41693988">root</a><span>|</span><a href="#41694197">parent</a><span>|</span><a href="#41694658">next</a><span>|</span><label class="collapse" for="c-41694651">[-]</label><label class="expand" for="c-41694651">[1 more]</label></div><br/><div class="children"><div class="content">&quot;refugees from other languages with sharply different idioms&quot;<p>Reminds me of the time I had to decipher some numerical analysis code written in Common Lisp but in the style of Occam...</div><br/></div></div><div id="41694658" class="c"><input type="checkbox" id="c-41694658" checked=""/><div class="controls bullet"><span class="by">surfingdino</span><span>|</span><a href="#41693988">root</a><span>|</span><a href="#41694197">parent</a><span>|</span><a href="#41694651">prev</a><span>|</span><a href="#41694748">next</a><span>|</span><label class="collapse" for="c-41694658">[-]</label><label class="expand" for="c-41694658">[1 more]</label></div><br/><div class="children"><div class="content">&gt; refugees from other languages with sharply different idioms<p>Mostly Java or JavaScript devs unable to make a dent in their main programming language space looking for a shortcut to jump to a better paying job by pretending to make a huge difference to the other programming language. I cringe every time a frontend dev who hasn&#x27;t fully grasped React yet utters the words &quot;I hear Rust is the future. I am going to port a JS package to it...&quot; They have already started making inroads into Golang with half-implemented modules.</div><br/></div></div></div></div><div id="41694748" class="c"><input type="checkbox" id="c-41694748" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#41693988">parent</a><span>|</span><a href="#41694197">prev</a><span>|</span><a href="#41694189">next</a><span>|</span><label class="collapse" for="c-41694748">[-]</label><label class="expand" for="c-41694748">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But must its users be this defensive?<p>Go is to programing what Brutalism is to Architecture. It is striped bare of everything down to the most basic of forms. It is structure is laid bare, put on display and free of decoration.<p>If you come in and try to write Golang like other languages your going to be unhappy, your going to tell us how go sucks because NPM&#x2F;PIP&#x2F;Gems is better (a common lament). It&#x27;s not defensive rolling up the news paper and wacking new devs to Golang and telling them &quot;don&#x27;t do it like its java&#x2F;c&#x2F;ruby&#x2F;js&#x2F;python do it like this...&quot;<p>Embrace the less is more of Go and it makes more sense and gets much more pleasant.</div><br/></div></div><div id="41694189" class="c"><input type="checkbox" id="c-41694189" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#41693988">parent</a><span>|</span><a href="#41694748">prev</a><span>|</span><a href="#41693781">next</a><span>|</span><label class="collapse" for="c-41694189">[-]</label><label class="expand" for="c-41694189">[1 more]</label></div><br/><div class="children"><div class="content">it is possible they fear being replaced with a few lines of erlang</div><br/></div></div></div></div><div id="41693781" class="c"><input type="checkbox" id="c-41693781" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41693988">prev</a><span>|</span><a href="#41693339">next</a><span>|</span><label class="collapse" for="c-41693781">[-]</label><label class="expand" for="c-41693781">[14 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why you would want an entire new execution scheduling mechanism just to print results in a specific order. The post dismisses the idea of including an index (a &quot;sequence number&quot; if you really want to be snooty about the idea of counting your requests), but &quot;asynchronously waitable objects&quot; is much, much more mechanism than that.<p>The irony of all of this is that the core thing the post wants to do, of posting results in order to reduce confusion for users, is also probably (I don&#x27;t know the complete use case, but in general) wrong! Print when you get the results back! Don&#x27;t block results behind a slow early request! It&#x27;s a command line program, what&#x27;s the virtue of queueing fast responses? The only point of the program is to print the output.</div><br/><div id="41694079" class="c"><input type="checkbox" id="c-41694079" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41693781">parent</a><span>|</span><a href="#41693891">next</a><span>|</span><label class="collapse" for="c-41694079">[-]</label><label class="expand" for="c-41694079">[5 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; (The specific context is that I&#x27;ve got a little Go program to do IP to name DNS lookups (it&#x27;s in Go for reasons), and on the one hand it would be handy to do several DNS lookups in parallel because sometimes they take a while, but on the other hand I want to print the results in command line order because otherwise it gets confusing.)<p>If I was using this program, I too would appreciate ordered results <i>and</i> an early return where possible without breaking the ordering.<p>Edit: and other similar programs might use a limited pool of workers, in which case the user would want to see ordered results as they came in <i>and</i> they would be expected to complete roughly in the same order they were started in.</div><br/><div id="41694097" class="c"><input type="checkbox" id="c-41694097" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41694079">parent</a><span>|</span><a href="#41693891">next</a><span>|</span><label class="collapse" for="c-41694097">[-]</label><label class="expand" for="c-41694097">[4 more]</label></div><br/><div class="children"><div class="content">To be clear: you can still easily get this result without anything nearly as complex as promises. But as someone who has written this program many times in many languages, I&#x27;m not so sure you&#x27;re right that this behavior is desirable. People go out of their way to install CLI network tools that <i>don&#x27;t</i> do this.</div><br/><div id="41694298" class="c"><input type="checkbox" id="c-41694298" checked=""/><div class="controls bullet"><span class="by">da_chicken</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41694097">parent</a><span>|</span><a href="#41694166">next</a><span>|</span><label class="collapse" for="c-41694298">[-]</label><label class="expand" for="c-41694298">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s safe to assume that it&#x27;s a toy problem. A simple example. Picking apart the example is a poor counterargument. It might be difficult to imagine a specific trivial example, but expressing a convincing example concretely can itself be a major diversion. Unless you&#x27;re saying you can guarantee that your alternative is always better in all conceivable cases?<p>Similarly, the existence of others wanting different behavior is also a poor counterargument. The fact that someone wants a Bag doesn&#x27;t mean that someone else is wrong for wanting an Ordered Set.</div><br/><div id="41694372" class="c"><input type="checkbox" id="c-41694372" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41694298">parent</a><span>|</span><a href="#41694166">next</a><span>|</span><label class="collapse" for="c-41694372">[-]</label><label class="expand" for="c-41694372">[1 more]</label></div><br/><div class="children"><div class="content">As you can see upthread, it&#x27;s not my only argument, just the one responders locked in on. But the problem here is also not lack of an ordered set!</div><br/></div></div></div></div><div id="41694166" class="c"><input type="checkbox" id="c-41694166" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41694097">parent</a><span>|</span><a href="#41694298">prev</a><span>|</span><a href="#41693891">next</a><span>|</span><label class="collapse" for="c-41694166">[-]</label><label class="expand" for="c-41694166">[1 more]</label></div><br/><div class="children"><div class="content">I agree that it seems a bit pointless unless you&#x27;re running a huge batch and that I don&#x27;t think reading from channels in a for loop should be referred to as promises, but I&#x27;ve written CLI tools where running batches of jobs in parallel and printing the results in order is desirable. I don&#x27;t think it&#x27;s a generally undesirable thing.<p>Edit: not quite parallel: I mean with a limited pool of workers, or a partial ordering, or something else that means there&#x27;s a reason to return results early.</div><br/></div></div></div></div></div></div><div id="41693891" class="c"><input type="checkbox" id="c-41693891" checked=""/><div class="controls bullet"><span class="by">alexjurkiewicz</span><span>|</span><a href="#41693781">parent</a><span>|</span><a href="#41694079">prev</a><span>|</span><a href="#41694160">next</a><span>|</span><label class="collapse" for="c-41693891">[-]</label><label class="expand" for="c-41693891">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The only point of the program is to print the output.<p>A consistent structure helps humans parse the output. I have host(1)&#x27;s output order in my mental memory.</div><br/><div id="41693921" class="c"><input type="checkbox" id="c-41693921" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41693891">parent</a><span>|</span><a href="#41694160">next</a><span>|</span><label class="collapse" for="c-41693921">[-]</label><label class="expand" for="c-41693921">[3 more]</label></div><br/><div class="children"><div class="content">Another way to think about this: if the only point of the program is to print the output, why not just serialize, or pipeline only one request past the current one?<p>Or you could just use a sync.WaitGroup and not print anything until all the results are in, which is what the proposed design does <i>anyways</i> in the case where an early request is the slowest to resolve.</div><br/><div id="41694074" class="c"><input type="checkbox" id="c-41694074" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41693921">parent</a><span>|</span><a href="#41694160">next</a><span>|</span><label class="collapse" for="c-41694074">[-]</label><label class="expand" for="c-41694074">[2 more]</label></div><br/><div class="children"><div class="content">Why not serialize &#x2F; just print one? Parallel is faster.<p>Why not wait? Because itâs nice to see results as they come in.<p>Yes, there are pathological possibilities here, if an early request is slow. But this complaint sounds like a complaint about the authorâs goals, which are stated clearly enough. âThe author has the wrong desires or goalsâ, your comment seems to say.</div><br/><div id="41694100" class="c"><input type="checkbox" id="c-41694100" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41694074">parent</a><span>|</span><a href="#41694160">next</a><span>|</span><label class="collapse" for="c-41694100">[-]</label><label class="expand" for="c-41694100">[1 more]</label></div><br/><div class="children"><div class="content">Is it faster? The design proposed deliberately withholds fast results in order to ensure they&#x27;re printed in sequence. Anybody who has ever run &quot;traceroute&quot; knows what this UX is like. If I wasn&#x27;t going full TUI, I would just print the results as they come in, on stderr (with an index number).<p>A sync.WaitGroup is <i>as fast</i> as the proposed behavior, for what it&#x27;s worth, and doesn&#x27;t have the ordering complexity.</div><br/></div></div></div></div></div></div></div></div><div id="41694160" class="c"><input type="checkbox" id="c-41694160" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41693781">parent</a><span>|</span><a href="#41693891">prev</a><span>|</span><a href="#41693339">next</a><span>|</span><label class="collapse" for="c-41694160">[-]</label><label class="expand" for="c-41694160">[4 more]</label></div><br/><div class="children"><div class="content">You can print the results when you get them back but also print them in order too. Youâll need a little bit of ANSI escape magic to do it but itâs not a complicated problem to solve. An example of this done well is docker-compose.<p>Personally, Iâd have written this code using a sequence number as well. Albeit Iâd have attached the sequence number to a context. To me, this sound like the kind of problem that contexts do well.</div><br/><div id="41694326" class="c"><input type="checkbox" id="c-41694326" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41694160">parent</a><span>|</span><a href="#41694185">next</a><span>|</span><label class="collapse" for="c-41694326">[-]</label><label class="expand" for="c-41694326">[1 more]</label></div><br/><div class="children"><div class="content">This depends on your definition of âprintâ.  What if your stdout is not a TTY?<p>Also, if your stdout <i>is</i> a TTY, but your terminal is not ANSI X3.64?  You might be able to look up the corresponding escape codes in terminfo based on $TERM (or simply use tput(1)), but the terminal might not even be able to perform those operations.  What do you do then?</div><br/></div></div><div id="41694185" class="c"><input type="checkbox" id="c-41694185" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41694160">parent</a><span>|</span><a href="#41694326">prev</a><span>|</span><a href="#41693339">next</a><span>|</span><label class="collapse" for="c-41694185">[-]</label><label class="expand" for="c-41694185">[2 more]</label></div><br/><div class="children"><div class="content">The ironic thing about the docker-compose UX, which I agree is probably the optimum here, is that it doesn&#x27;t benefit from promises.</div><br/><div id="41694198" class="c"><input type="checkbox" id="c-41694198" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41693781">root</a><span>|</span><a href="#41694185">parent</a><span>|</span><a href="#41693339">next</a><span>|</span><label class="collapse" for="c-41694198">[-]</label><label class="expand" for="c-41694198">[1 more]</label></div><br/><div class="children"><div class="content">Iâm not going to defend the authors desire for promises because itâs a pattern Iâve never liked in any language. But thatâs just my personal preferences.</div><br/></div></div></div></div></div></div></div></div><div id="41693339" class="c"><input type="checkbox" id="c-41693339" checked=""/><div class="controls bullet"><span class="by">davery22</span><span>|</span><a href="#41693781">prev</a><span>|</span><a href="#41693334">next</a><span>|</span><label class="collapse" for="c-41693339">[-]</label><label class="expand" for="c-41693339">[3 more]</label></div><br/><div class="children"><div class="content">So: A channel with buffer size 1, so long as it is only written to once and read from once, feels a lot like a Promise.</div><br/><div id="41693415" class="c"><input type="checkbox" id="c-41693415" checked=""/><div class="controls bullet"><span class="by">teraflop</span><span>|</span><a href="#41693339">parent</a><span>|</span><a href="#41693334">next</a><span>|</span><label class="collapse" for="c-41693415">[-]</label><label class="expand" for="c-41693415">[2 more]</label></div><br/><div class="children"><div class="content">A variable you can only read once is a lot less useful than a variable you can read as many times as you want. Same goes for promises.</div><br/><div id="41693623" class="c"><input type="checkbox" id="c-41693623" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41693339">root</a><span>|</span><a href="#41693415">parent</a><span>|</span><a href="#41693334">next</a><span>|</span><label class="collapse" for="c-41693623">[-]</label><label class="expand" for="c-41693623">[1 more]</label></div><br/><div class="children"><div class="content">I donât think Iâve seen a promise implementation that canât handle multiple reads after the resolve for many years.<p>It would not take a lot of glue code to alter the contract to make that happen here.</div><br/></div></div></div></div></div></div><div id="41693334" class="c"><input type="checkbox" id="c-41693334" checked=""/><div class="controls bullet"><span class="by">ekimekim</span><span>|</span><a href="#41693339">prev</a><span>|</span><a href="#41693396">next</a><span>|</span><label class="collapse" for="c-41693334">[-]</label><label class="expand" for="c-41693334">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a while since I did much Go, but I think you can handle this cleanly by making one channel per task, and having an array of channels similar to the array of promises. Each channel takes that task&#x27;s result, then closes. The caller waits on each channel in sequence.</div><br/><div id="41693464" class="c"><input type="checkbox" id="c-41693464" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41693334">parent</a><span>|</span><a href="#41693396">next</a><span>|</span><label class="collapse" for="c-41693464">[-]</label><label class="expand" for="c-41693464">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what the author ends up with, too. It&#x27;s also how you might handle this in any other language that allows for some form of &quot;join&quot;, either intended or usable as a join. Waiting on promises, thread joins, channels (as a signal mechanism), it&#x27;s all the same pattern: Instantiate a bunch of asynchronous activities and queue up a &quot;handler&quot; corresponding to it, wait on the handlers in your desired order.</div><br/></div></div></div></div><div id="41693396" class="c"><input type="checkbox" id="c-41693396" checked=""/><div class="controls bullet"><span class="by">caleblloyd</span><span>|</span><a href="#41693334">prev</a><span>|</span><a href="#41693737">next</a><span>|</span><label class="collapse" for="c-41693396">[-]</label><label class="expand" for="c-41693396">[1 more]</label></div><br/><div class="children"><div class="content">Shortcut could be to create an array of sync.OnceValue, immediately invoking each element in a goroutine. Then iterate through the array and call each function again.</div><br/></div></div><div id="41693737" class="c"><input type="checkbox" id="c-41693737" checked=""/><div class="controls bullet"><span class="by">sandreas</span><span>|</span><a href="#41693396">prev</a><span>|</span><a href="#41693416">next</a><span>|</span><label class="collapse" for="c-41693737">[-]</label><label class="expand" for="c-41693737">[1 more]</label></div><br/><div class="children"><div class="content">.NET 9 solves this with<p><pre><code>  Task.WhenEach
</code></pre>
where you had to use some boilerplate before .NET 9. Nick Chapsas has an interesting youtube video on this explaining what&#x27;s the problem and what Microsoft did to solve this[1].<p>1: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WqXgl8EZzcs" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WqXgl8EZzcs</a></div><br/></div></div><div id="41693416" class="c"><input type="checkbox" id="c-41693416" checked=""/><div class="controls bullet"><span class="by">pbnjay</span><span>|</span><a href="#41693737">prev</a><span>|</span><a href="#41693770">next</a><span>|</span><label class="collapse" for="c-41693416">[-]</label><label class="expand" for="c-41693416">[7 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it even simpler in Go? No channels necessary, Each goroutine gets an index or slice, and writes the results to a shared array.<p>All you need is the goroutines to report when done via a WaitGroup.</div><br/><div id="41693427" class="c"><input type="checkbox" id="c-41693427" checked=""/><div class="controls bullet"><span class="by">teraflop</span><span>|</span><a href="#41693416">parent</a><span>|</span><a href="#41693770">next</a><span>|</span><label class="collapse" for="c-41693427">[-]</label><label class="expand" for="c-41693427">[6 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t satisfy the &quot;report the results as they become available&quot; requirement.<p>The desired behavior is that printing the first result should only wait for the first result to be available, not for all the results to be available.</div><br/><div id="41694149" class="c"><input type="checkbox" id="c-41694149" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#41693416">root</a><span>|</span><a href="#41693427">parent</a><span>|</span><a href="#41693473">next</a><span>|</span><label class="collapse" for="c-41694149">[-]</label><label class="expand" for="c-41694149">[3 more]</label></div><br/><div class="children"><div class="content">Modified the above to <a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;DRXyvRHsuAH" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;DRXyvRHsuAH</a>
You get the first result in results[0] thanks to `atomic.Int32`.<p><pre><code>    package main

    import (
     &quot;fmt&quot;
     &quot;math&#x2F;rand&quot;
     &quot;sync&#x2F;atomic&quot;
     &quot;time&quot;
    )

    func main() {
     args := []int{5, 2, 4, 1, 8}
     var indexGen atomic.Int32
     indexGen.Store(-1)
     results := make([]int, len(args))
     finished := make(chan bool)

     slowSquare := func(arg int, index int) {
      randomMilliseconds := rand.Intn(1000)
      blockDuration := time.Duration(randomMilliseconds) * time.Millisecond
      fmt.Printf(&quot;Squaring %d, Blocking for %d milliseconds...\n&quot;, arg, randomMilliseconds)
      &lt;-time.After(blockDuration)
      idx := indexGen.Add(1)
      results[idx] = arg * arg
      fmt.Printf(&quot;Squared %d: results[%d]=%d\n&quot;, arg, idx, results[idx])
      finished &lt;- true
     }

     prettyPrinter := func() {
      for range time.NewTicker(time.Second).C {
       fmt.Println(&quot;Results: &quot;, results)
      }
     }
     go prettyPrinter()
     for idx, x := range args {
      go slowSquare(x, idx)
     }
     &lt;-finished

     fmt.Println(&quot;First Result: &quot;, results[0])
     fmt.Println(&quot;So-far Results: &quot;, results)

    }</code></pre></div><br/><div id="41694347" class="c"><input type="checkbox" id="c-41694347" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#41693416">root</a><span>|</span><a href="#41694149">parent</a><span>|</span><a href="#41693473">next</a><span>|</span><label class="collapse" for="c-41694347">[-]</label><label class="expand" for="c-41694347">[2 more]</label></div><br/><div class="children"><div class="content">This will wait up to 1 second before showing a result when a result comes in. I&#x27;m pretty sure Chris doesn&#x27;t want any waiting like that.<p>This will also print some results multiple times. I think Chris wants to print each result once.</div><br/><div id="41694982" class="c"><input type="checkbox" id="c-41694982" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#41693416">root</a><span>|</span><a href="#41694347">parent</a><span>|</span><a href="#41693473">next</a><span>|</span><label class="collapse" for="c-41694982">[-]</label><label class="expand" for="c-41694982">[1 more]</label></div><br/><div class="children"><div class="content">It is utterly clear that the wait is not intrinsic to the logic - it was only added for demonstration to simulate a blocking call.<p>You can simply comment out the println and just pick the first results[0]. Again, the repeated println for all results was only added for demonstrative clarity.<p>Frankly, the above satisfies all primary goals. The rest is just nitpicking - without a formal specification of the problem one can argue all day.</div><br/></div></div></div></div></div></div><div id="41693473" class="c"><input type="checkbox" id="c-41693473" checked=""/><div class="controls bullet"><span class="by">pbnjay</span><span>|</span><a href="#41693416">root</a><span>|</span><a href="#41693427">parent</a><span>|</span><a href="#41694149">prev</a><span>|</span><a href="#41693770">next</a><span>|</span><label class="collapse" for="c-41693473">[-]</label><label class="expand" for="c-41693473">[2 more]</label></div><br/><div class="children"><div class="content">Would be trivial to show the results live though, especially for atomic values:
<a href="https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;PRzzO_skWoJ" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;play&#x2F;p&#x2F;PRzzO_skWoJ</a></div><br/><div id="41693604" class="c"><input type="checkbox" id="c-41693604" checked=""/><div class="controls bullet"><span class="by">valleyer</span><span>|</span><a href="#41693416">root</a><span>|</span><a href="#41693473">parent</a><span>|</span><a href="#41693770">next</a><span>|</span><label class="collapse" for="c-41693604">[-]</label><label class="expand" for="c-41693604">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not &quot;live&quot;; that&#x27;s just polling.</div><br/></div></div></div></div></div></div></div></div><div id="41693770" class="c"><input type="checkbox" id="c-41693770" checked=""/><div class="controls bullet"><span class="by">kimi</span><span>|</span><a href="#41693416">prev</a><span>|</span><a href="#41693398">next</a><span>|</span><label class="collapse" for="c-41693770">[-]</label><label class="expand" for="c-41693770">[3 more]</label></div><br/><div class="children"><div class="content">Had a similar problem in Elixir - spawn a pool of HTTP requests and notify immediately of the first one that completes with a status of &quot;ok&quot;.<p><pre><code>   Task.Supervisor.async_stream(
        My.TaskSupervisor,
        my_list_of_urls,
        &amp;assess_url_exists&#x2F;1,
        ordered: false,
        max_concurrency: 100,
        timeout: 30_000
      )
      |&gt; Enum.find(fn
        {:ok, {:ok, _url}} -&gt; true
        _ -&gt; false
      end)
</code></pre>
And - that&#x27;s it. Do I want it ordered? just change the &quot;ordered&quot; flag. Tweaking concurrency? it&#x27;s there.<p>But the really best part is that any pending computation at the point when the correct result is found, it is automatically cancelled. No waiting for its completion. No memory leaks, no file descriptors left open. It just goes away. Boom.<p>Just sayin&#x27;...</div><br/><div id="41694569" class="c"><input type="checkbox" id="c-41694569" checked=""/><div class="controls bullet"><span class="by">mathw</span><span>|</span><a href="#41693770">parent</a><span>|</span><a href="#41693398">next</a><span>|</span><label class="collapse" for="c-41694569">[-]</label><label class="expand" for="c-41694569">[2 more]</label></div><br/><div class="children"><div class="content">Just sayin&#x27;... you have solved a different problem to the one the author describes in the article.</div><br/><div id="41694852" class="c"><input type="checkbox" id="c-41694852" checked=""/><div class="controls bullet"><span class="by">kimi</span><span>|</span><a href="#41693770">root</a><span>|</span><a href="#41694569">parent</a><span>|</span><a href="#41693398">next</a><span>|</span><label class="collapse" for="c-41694852">[-]</label><label class="expand" for="c-41694852">[1 more]</label></div><br/><div class="children"><div class="content">Weird. I thought that &quot;similar&quot; meant &quot;different, but kind of&quot;.</div><br/></div></div></div></div></div></div><div id="41693398" class="c"><input type="checkbox" id="c-41693398" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#41693770">prev</a><span>|</span><a href="#41694322">next</a><span>|</span><label class="collapse" for="c-41693398">[-]</label><label class="expand" for="c-41693398">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;in-order&quot; requirement makes this a weird problem to think you have. There&#x27;s no situation where the channels are going to be heavier then the go-routines you&#x27;re spawning to handle the processing: in fact the last line lamenting leaving blocked go-routines around is weird, because a blocked go-routine is still using less resources then one actually doing things - it&#x27;s totally fine for them to block waiting to write to the channel because of the &quot;in-order&quot; requirement.<p>Your worst case scenario is you spawn N go-routines, and they complete 1 by 1 in reverse order from N so your entire dataset is waiting in memory for in-order completion - so no other concern here matters at all.</div><br/></div></div><div id="41694322" class="c"><input type="checkbox" id="c-41694322" checked=""/><div class="controls bullet"><span class="by">carpdiem</span><span>|</span><a href="#41693398">prev</a><span>|</span><label class="collapse" for="c-41694322">[-]</label><label class="expand" for="c-41694322">[1 more]</label></div><br/><div class="children"><div class="content">Lordy, I clicked on this, fully expecting a discussion of a shape-pattern in the board game of Go, and somehow didn&#x27;t have a thought in my mind for the real, completely different, meaning.<p>This reminds me of &quot;trompe l&#x27;oeil foods&quot;... dishes that appear to be one thing, but are another entirely. Or maybe optical illusions more generally.</div><br/></div></div></div></div></div></div></div></body></html>