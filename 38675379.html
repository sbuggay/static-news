<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702890066737" as="style"/><link rel="stylesheet" href="styles.css?v=1702890066737"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nullprogram.com/blog/2023/12/17/">So you want custom allocator support in your C library</a> <span class="domain">(<a href="https://nullprogram.com">nullprogram.com</a>)</span></div><div class="subtext"><span>nalgeon</span> | <span>62 comments</span></div><br/><div><div id="38679420" class="c"><input type="checkbox" id="c-38679420" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38679536">next</a><span>|</span><label class="collapse" for="c-38679420">[-]</label><label class="expand" for="c-38679420">[8 more]</label></div><br/><div class="children"><div class="content">&gt; When an application frees an object it always has the original, requested allocation size on hand. After all, it’s a necessary condition to use the object correctly.<p>This is quite untrue in real-world C codebases unless you have a lot of discipline. I know from reading a previous article (<a href="https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2023&#x2F;10&#x2F;08&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2023&#x2F;10&#x2F;08&#x2F;</a>) by this author that they hate null-terminated strings. But in your typical C code, you often allocate a bunch of memory to be used as a null-terminated string, return it or pass it to another function transferring ownership, and expect a different function to free() it. The length of the string is not necessarily the allocation size! The code could have allocated some predetermined max size for the buffer, build up the string gradually, and then add a null terminator. Thus, the function doing the free() can&#x27;t pass the right size.</div><br/><div id="38679752" class="c"><input type="checkbox" id="c-38679752" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38679420">parent</a><span>|</span><a href="#38679536">next</a><span>|</span><label class="collapse" for="c-38679752">[-]</label><label class="expand" for="c-38679752">[7 more]</label></div><br/><div class="children"><div class="content">if i have a function foo which calls functions bar and baz to build up a dynamically allocated string (using a custom allocator), then calls function quux to transfer ownership of the string, foo needs to store the information about how big the allocation currently is, and how to allocate more of it, in a place where functions bar and baz can access it.  if it doesn&#x27;t do that, bar or baz can easily overflow the buffer because they don&#x27;t know how big it is.  this is a particular case of &#x27;having the requested allocation size on hand is a necessary condition to use the object correctly&#x27;<p>but if foo is passing this data structure to bar and baz, it can pass it to quux too, so the problem as you described it just doesn&#x27;t exist<p>(unless your code is only working by the merest of chances and will have some cves later this year the first time some competent programmers look at it)<p>&#x27;bar or baz can easily overflow the buffer because they don&#x27;t know how big it is&#x27; is a particular case of &#x27;having the requested allocation size on hand is a necessary condition to use the object correctly&#x27;</div><br/><div id="38680065" class="c"><input type="checkbox" id="c-38680065" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38679420">root</a><span>|</span><a href="#38679752">parent</a><span>|</span><a href="#38679847">next</a><span>|</span><label class="collapse" for="c-38680065">[-]</label><label class="expand" for="c-38680065">[2 more]</label></div><br/><div class="children"><div class="content">You are describing an ideal scenario where code is written by experts and those experts did not take any shortcuts. Real world C code is unfortunately anything but that. I haven&#x27;t had the luxury of only working on expertly-written C code which frankly also makes me hate C code.<p>What if the function bar only appends a number to a string? Then the maximum length it needs could become embedded knowledge by the foo function (&quot;10 characters is enough to store this uint32_t so no need to pass anything related to the allocation&quot; thought the programmer who hated tedium).<p>What if bar and baz are not allowed to grow the allocation because foo has already enough buffer to store the maximum possible size (say a path on Windows, 260 bytes)?<p>What if the function quux is in a different third-party library whose API cannot be modified to take the allocation size?</div><br/><div id="38680146" class="c"><input type="checkbox" id="c-38680146" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38679420">root</a><span>|</span><a href="#38680065">parent</a><span>|</span><a href="#38679847">next</a><span>|</span><label class="collapse" for="c-38680146">[-]</label><label class="expand" for="c-38680146">[1 more]</label></div><br/><div class="children"><div class="content">well, i do agree that there&#x27;s a lot of code out there that only works by the merest of chances and will have several cves opened the first time a competent programmer looks at it; the kinds of implicit thoughts and prayers you&#x27;re describing (sweet jesus, pvg, that isn&#x27;t a uint32_t you&#x27;re formatting) are precisely what i was talking about<p>but i&#x27;m not talking about code where the authors didn&#x27;t take any shortcuts, just boringly competent c code with the regular quantity of bugs in it.  i&#x27;m sorry you&#x27;ve been subjected to such torments as you report.  but the author of this article isn&#x27;t talking about how to write such astoundingly shitty code; he&#x27;s talking about how to write good code<p>if the function quux is in a different third-party library, its api probably cannot be modified to call the custom allocator either (my initial comment draft suggested that you might be talking about such a case, but then i realized that didn&#x27;t make any sense and so i deleted it)</div><br/></div></div></div></div><div id="38679847" class="c"><input type="checkbox" id="c-38679847" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#38679420">root</a><span>|</span><a href="#38679752">parent</a><span>|</span><a href="#38680065">prev</a><span>|</span><a href="#38679536">next</a><span>|</span><label class="collapse" for="c-38679847">[-]</label><label class="expand" for="c-38679847">[4 more]</label></div><br/><div class="children"><div class="content">There are many reasons it might be inconvenient for foo to pass that data to quux.  Perhaps it’s actually quux that called foo rather than the other way around (in other words, foo is passing ownership through its return value rather than through a function argument), in which case C makes it easier to return one value than two.  Or perhaps there’s just a lot of existing logic that passes owned strings around without an accompanying size parameter, which is perfectly safe to do if you’re not planning to ever mutate them.<p>Of course you could easily design your codebase to not have that issue, if you’re writing it from scratch.  But that’s not the question.</div><br/><div id="38680133" class="c"><input type="checkbox" id="c-38680133" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38679420">root</a><span>|</span><a href="#38679847">parent</a><span>|</span><a href="#38679536">next</a><span>|</span><label class="collapse" for="c-38680133">[-]</label><label class="expand" for="c-38680133">[3 more]</label></div><br/><div class="children"><div class="content">i agree that parts of the code that are not changing the length of the string can use it safely without knowing the buffer size<p>it&#x27;s been easy to return a struct by value in c for over 30 years, though in very early versions of c, structs in rvalue context implicitly decayed to pointers, like arrays.  it&#x27;s been efficient for about 20 years<p>so it&#x27;s not easier to return one value than two if you&#x27;ve already defined the struct type, which is presumably the case here<p>there&#x27;s people who avoid it because they&#x27;re imitating c code from the 01980s (or, charitably, performance-sensitive c code from the 01990s), or because they&#x27;re using some horrible abomination like common lisp&#x27;s cffi, but that&#x27;s really quite marginal<p>and even if you didn&#x27;t originally design your codebase that way, you can certainly fix the design.  it&#x27;ll probably even make it easier to understand and maintain, because you&#x27;re always passing around a stralloc or whatever, instead of sometimes passing around a stralloc and other times passing around a raw buffer pointer</div><br/><div id="38680168" class="c"><input type="checkbox" id="c-38680168" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38679420">root</a><span>|</span><a href="#38680133">parent</a><span>|</span><a href="#38679536">next</a><span>|</span><label class="collapse" for="c-38680168">[-]</label><label class="expand" for="c-38680168">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re going to go to all the effort of rewriting your codebase anyway, why would you keep it in C?</div><br/><div id="38680187" class="c"><input type="checkbox" id="c-38680187" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38679420">root</a><span>|</span><a href="#38680168">parent</a><span>|</span><a href="#38679536">next</a><span>|</span><label class="collapse" for="c-38680187">[-]</label><label class="expand" for="c-38680187">[1 more]</label></div><br/><div class="children"><div class="content">you can change the calling interface of a single function without rewriting your entire codebase<p>also there are a lot of things for which c is still the best option, though rust is becoming appealing for more of them all the time</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38679536" class="c"><input type="checkbox" id="c-38679536" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#38679420">prev</a><span>|</span><a href="#38678227">next</a><span>|</span><label class="collapse" for="c-38679536">[-]</label><label class="expand" for="c-38679536">[2 more]</label></div><br/><div class="children"><div class="content">The fact that zig&#x27;s standard library design (and general code guidelines) makes you always carry allocator with you, makes it very easy to manage memory overall. Most of time I set up arena allocator and then I don&#x27;t even have to care about clean up unless it&#x27;s something holding a OS resource.</div><br/><div id="38679628" class="c"><input type="checkbox" id="c-38679628" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#38679536">parent</a><span>|</span><a href="#38678227">next</a><span>|</span><label class="collapse" for="c-38679628">[-]</label><label class="expand" for="c-38679628">[1 more]</label></div><br/><div class="children"><div class="content">The article presents essentially the same view, for a language which doesn&#x27;t have that convention, and doesn&#x27;t have slices (pointers that also contain size information). Zig allocators check all three requirements illustrated here. As do most modern allocator interfaces.</div><br/></div></div></div></div><div id="38678227" class="c"><input type="checkbox" id="c-38678227" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#38679536">prev</a><span>|</span><a href="#38677532">next</a><span>|</span><label class="collapse" for="c-38678227">[-]</label><label class="expand" for="c-38678227">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The standard library allocator keeps its state in global variables. This makes for a simple interface, but comes with significant performance and complexity costs<p>Thread local allocation buffers?</div><br/><div id="38678786" class="c"><input type="checkbox" id="c-38678786" checked=""/><div class="controls bullet"><span class="by">MereInterest</span><span>|</span><a href="#38678227">parent</a><span>|</span><a href="#38677532">next</a><span>|</span><label class="collapse" for="c-38678786">[-]</label><label class="expand" for="c-38678786">[3 more]</label></div><br/><div class="children"><div class="content">Unfortunately, because a buffer may be allocated in one thread but freed in another, you can&#x27;t have purely thread-local state for the allocator.</div><br/><div id="38678965" class="c"><input type="checkbox" id="c-38678965" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#38678227">root</a><span>|</span><a href="#38678786">parent</a><span>|</span><a href="#38677532">next</a><span>|</span><label class="collapse" for="c-38678965">[-]</label><label class="expand" for="c-38678965">[2 more]</label></div><br/><div class="children"><div class="content">snmalloc batches up cross-thread frees, though generally any thread-local stuff is better than none.</div><br/><div id="38679758" class="c"><input type="checkbox" id="c-38679758" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38678227">root</a><span>|</span><a href="#38678965">parent</a><span>|</span><a href="#38677532">next</a><span>|</span><label class="collapse" for="c-38679758">[-]</label><label class="expand" for="c-38679758">[1 more]</label></div><br/><div class="children"><div class="content">how simple can that be and still get reasonable scaling?</div><br/></div></div></div></div></div></div></div></div><div id="38677532" class="c"><input type="checkbox" id="c-38677532" checked=""/><div class="controls bullet"><span class="by">ghostpepper</span><span>|</span><a href="#38678227">prev</a><span>|</span><a href="#38678603">next</a><span>|</span><label class="collapse" for="c-38677532">[-]</label><label class="expand" for="c-38677532">[10 more]</label></div><br/><div class="children"><div class="content">I wonder how many security-critical memory vulnerabilities would&#x27;ve been avoided over the decades if glibc had been designed with this API instead of the one that became the de-facto standard.</div><br/><div id="38677733" class="c"><input type="checkbox" id="c-38677733" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#38677532">parent</a><span>|</span><a href="#38677895">next</a><span>|</span><label class="collapse" for="c-38677733">[-]</label><label class="expand" for="c-38677733">[8 more]</label></div><br/><div class="children"><div class="content">Or introduced. I would think that trusting the (possibly compromised) caller to pass the correct size of a to be freed or resized object opens up new possibilities for security vulnerabilities.</div><br/><div id="38678249" class="c"><input type="checkbox" id="c-38678249" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38677532">root</a><span>|</span><a href="#38677733">parent</a><span>|</span><a href="#38677895">next</a><span>|</span><label class="collapse" for="c-38678249">[-]</label><label class="expand" for="c-38678249">[7 more]</label></div><br/><div class="children"><div class="content">Note that libc-style `free` often has to do work to walk through all possible arenas&#x2F;buckets&#x2F;whatever to see which one contains the given pointer. If given a size (even just a hint) it can do a <i>much</i> shorter walk without reducing security.</div><br/><div id="38678481" class="c"><input type="checkbox" id="c-38678481" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#38677532">root</a><span>|</span><a href="#38678249">parent</a><span>|</span><a href="#38678798">next</a><span>|</span><label class="collapse" for="c-38678481">[-]</label><label class="expand" for="c-38678481">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Even just a hint&quot; doesn&#x27;t deserve to be squirreled away in a mere paranthetical. It&#x27;s what distinguishes some bullshit (the article&#x27;s suggestion, whereby the allocator carefully checks that you supplied the right value <i>that it already knows</i> and barfs if not) from the actually potentially useful improvement to the API that you suggest.<p>The code that frees very often does not know how much was allocated.</div><br/><div id="38678517" class="c"><input type="checkbox" id="c-38678517" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38677532">root</a><span>|</span><a href="#38678481">parent</a><span>|</span><a href="#38678798">next</a><span>|</span><label class="collapse" for="c-38678517">[-]</label><label class="expand" for="c-38678517">[1 more]</label></div><br/><div class="children"><div class="content">An allocator that fully trusts the size provided to `free` is hugely unsafe when the size turns out to be incorrect. As an extreme example, the allocator may know that every 4-byte allocation is put into the arena that is aligned to 0x1000-byte block, so it may jump straight into the arena header which won&#x27;t be there if the size was incorrect. So a real-life allocator is likely to do some checking even when the size is provided, but that checking can be much more simplified in that case.</div><br/></div></div></div></div><div id="38678798" class="c"><input type="checkbox" id="c-38678798" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38677532">root</a><span>|</span><a href="#38678249">parent</a><span>|</span><a href="#38678481">prev</a><span>|</span><a href="#38677895">next</a><span>|</span><label class="collapse" for="c-38678798">[-]</label><label class="expand" for="c-38678798">[4 more]</label></div><br/><div class="children"><div class="content">Most allocators can do this lookup quickly, sometimes by placing the size next to the allocation or by encoding it into the returned pointer.</div><br/><div id="38678887" class="c"><input type="checkbox" id="c-38678887" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38677532">root</a><span>|</span><a href="#38678798">parent</a><span>|</span><a href="#38677895">next</a><span>|</span><label class="collapse" for="c-38678887">[-]</label><label class="expand" for="c-38678887">[3 more]</label></div><br/><div class="children"><div class="content">&gt; by encoding it into the returned pointer<p>More accurately speaking though, this information is not directly available from the pointer (unless we have a universal pointer tagging support today...) and should be mapped via the allocator internal data structure. This is what o11c referred by &quot;arenas&#x2F;buckets&#x2F;whatever&quot;, and having a size information does simplify this process.<p>The metadata around the allocation is comparably expensive especially for smaller allocations anyway, so modern allocators would have at least two classes of memory depending on the size. So even when the allocator doesn&#x27;t make use of any other size information, it is possible that the size information can still be helpful.</div><br/><div id="38679302" class="c"><input type="checkbox" id="c-38679302" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38677532">root</a><span>|</span><a href="#38678887">parent</a><span>|</span><a href="#38679516">next</a><span>|</span><label class="collapse" for="c-38679302">[-]</label><label class="expand" for="c-38679302">[1 more]</label></div><br/><div class="children"><div class="content">Having the size is definitely useful, because you can skip the metadata. But since needing this information in some form or the other is very important it is generally easy to derive-no walks or anything, because that would be slow.</div><br/></div></div><div id="38679516" class="c"><input type="checkbox" id="c-38679516" checked=""/><div class="controls bullet"><span class="by">jaywee</span><span>|</span><a href="#38677532">root</a><span>|</span><a href="#38678887">parent</a><span>|</span><a href="#38679302">prev</a><span>|</span><a href="#38677895">next</a><span>|</span><label class="collapse" for="c-38679516">[-]</label><label class="expand" for="c-38679516">[1 more]</label></div><br/><div class="children"><div class="content">It can be - the allocator just needs to mmap() different bucket pools to different base addresses.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38677895" class="c"><input type="checkbox" id="c-38677895" checked=""/><div class="controls bullet"><span class="by">hollimolli</span><span>|</span><a href="#38677532">parent</a><span>|</span><a href="#38677733">prev</a><span>|</span><a href="#38678603">next</a><span>|</span><label class="collapse" for="c-38677895">[-]</label><label class="expand" for="c-38677895">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with the one from glib?</div><br/></div></div></div></div><div id="38678603" class="c"><input type="checkbox" id="c-38678603" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#38677532">prev</a><span>|</span><a href="#38678065">next</a><span>|</span><label class="collapse" for="c-38678603">[-]</label><label class="expand" for="c-38678603">[1 more]</label></div><br/><div class="children"><div class="content">Good article. The caller can also pass arguments hinting whether the requested allocation will be long or short lived, zero allocated, etc... You can also go beyond the realloc&#x2F;free idiom and into specialized interfaces, like a push&#x2F;pop stack allocator.</div><br/></div></div><div id="38678065" class="c"><input type="checkbox" id="c-38678065" checked=""/><div class="controls bullet"><span class="by">habibur</span><span>|</span><a href="#38678603">prev</a><span>|</span><a href="#38677809">next</a><span>|</span><label class="collapse" for="c-38678065">[-]</label><label class="expand" for="c-38678065">[17 more]</label></div><br/><div class="children"><div class="content">The hint in OP&#x27;s last line, when you are passing around function pointers to allocators, you just need only one standard function interface.<p><pre><code>    allocate(void\* ptr, size_t size);

    ptr == NULL : alloc()
    size == 0 : free()
    both ptr and size sent : realloc()
</code></pre>
That way it&#x27;s simpler on the API stage. I prefer to keep it like that in my code.</div><br/><div id="38678224" class="c"><input type="checkbox" id="c-38678224" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38678065">parent</a><span>|</span><a href="#38678387">next</a><span>|</span><label class="collapse" for="c-38678224">[-]</label><label class="expand" for="c-38678224">[4 more]</label></div><br/><div class="children"><div class="content">A good API <i>can</i> use only a single ABI-level function, but it needs more parameters than that. I imagine 4 arguments, at least 2 of which are themselves composite:<p><pre><code>    auto utopia_alloc(Allocation, AlignAndSkew, Size, Flags) -&gt; Allocation;
</code></pre>
That said, while &quot;one function&quot; makes interposing easy, it does mean significant branching cost compared to single functions. There&#x27;s probably a way to get the best of both worlds (support several functions in the ABI, but forward them all to `utopia_alloc` if interposed).<p>more details at <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;o11c&#x2F;6b08643335388bbab0228db763f99219#file-memory-allocation-api-md" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;o11c&#x2F;6b08643335388bbab0228db763f9921...</a><p>Aside: I <i>really</i> hate how the nullprogram site linked seems allergic to type-safety.</div><br/><div id="38678423" class="c"><input type="checkbox" id="c-38678423" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38678224">parent</a><span>|</span><a href="#38678387">next</a><span>|</span><label class="collapse" for="c-38678423">[-]</label><label class="expand" for="c-38678423">[3 more]</label></div><br/><div class="children"><div class="content">Oh that is indeed a good list, you should submit that gist independently. That said, I believe alignments should be a suggestion and not a mandatory request, mainly because the library can fix a bad alignment by overallocation. Charles Bloom has suggested a similar thing in the past [1].<p>Out of possible flags the zeroing flag is probably the most used and possibly only flag needed for library uses; others are also important but only a small number of libraries will ever want them. Again, a failure to do so should ideally be somehow detected and fixed, but that detection can&#x27;t be actually checking for non-zeros, so the provided function should somehow return whether the memory was actually zeroed or not.<p>(I also share the same concern about the site, by the way.)<p>[1] <a href="https:&#x2F;&#x2F;cbloomrants.blogspot.com&#x2F;2015&#x2F;09&#x2F;library-writing-realizations.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;cbloomrants.blogspot.com&#x2F;2015&#x2F;09&#x2F;library-writing-rea...</a> (specifically the &quot;Simplicity is better&quot; point)</div><br/><div id="38678735" class="c"><input type="checkbox" id="c-38678735" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38678423">parent</a><span>|</span><a href="#38678387">next</a><span>|</span><label class="collapse" for="c-38678735">[-]</label><label class="expand" for="c-38678735">[2 more]</label></div><br/><div class="children"><div class="content">Alignment has to be mandatory because otherwise `free` breaks.</div><br/><div id="38678833" class="c"><input type="checkbox" id="c-38678833" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38678735">parent</a><span>|</span><a href="#38678387">next</a><span>|</span><label class="collapse" for="c-38678833">[-]</label><label class="expand" for="c-38678833">[1 more]</label></div><br/><div class="children"><div class="content">I think you are imagining an aligned allocator out of an unaligned allocator, where the misalignment should be stored somewhere around the actual memory block, but if the main allocator itself is aware of aligned allocations it is not necessary.<p>I can still imagine the case where allocation bins are structured by the allocation size <i>and</i> alignment size and an incorrect alignment will result in an incorrect bin, but such bins are only beneficial when the alignment itself is too large compared to allocation sizes, and I&#x27;m not sure who really wants them in the first place.</div><br/></div></div></div></div></div></div></div></div><div id="38678387" class="c"><input type="checkbox" id="c-38678387" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38678065">parent</a><span>|</span><a href="#38678224">prev</a><span>|</span><a href="#38679362">next</a><span>|</span><label class="collapse" for="c-38678387">[-]</label><label class="expand" for="c-38678387">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a pet peeve of mine that C people seem to think that 0 isn&#x27;t a number.  Or that 0 (or -1) mean infinity.  (Like a timeout of 0 meaning an infinite timeout, instead of failing immediately.)<p>I guess it&#x27;s mostly a consequence of C having such poor support for data types.<p>For a low-level allocator interface this might be an acceptable compromise, but C people also tend to use this kind of mangling when it&#x27;s not warranted.</div><br/><div id="38678807" class="c"><input type="checkbox" id="c-38678807" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38678387">parent</a><span>|</span><a href="#38679362">next</a><span>|</span><label class="collapse" for="c-38678807">[-]</label><label class="expand" for="c-38678807">[6 more]</label></div><br/><div class="children"><div class="content">An allocation of size zero cannot be used for anything useful.</div><br/><div id="38679559" class="c"><input type="checkbox" id="c-38679559" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38678807">parent</a><span>|</span><a href="#38679810">next</a><span>|</span><label class="collapse" for="c-38679559">[-]</label><label class="expand" for="c-38679559">[1 more]</label></div><br/><div class="children"><div class="content">You could definitely use it for something useful; you can&#x27;t store anything through it, but if an allocator supports allocations of size 0 with the same semantics of non-zero allocations, you get a &quot;unique&quot; ptr from the allocator dynamically.<p>Anywhere you need a dynamic list identifier this would suit (yes, a counter could do this too, this would be effectively a globally unique token)</div><br/></div></div><div id="38679810" class="c"><input type="checkbox" id="c-38679810" checked=""/><div class="controls bullet"><span class="by">optimiz3</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38678807">parent</a><span>|</span><a href="#38679559">prev</a><span>|</span><a href="#38679065">next</a><span>|</span><label class="collapse" for="c-38679810">[-]</label><label class="expand" for="c-38679810">[1 more]</label></div><br/><div class="children"><div class="content">One example is a non-null sentinel&#x2F;oracle allocation.  Often you see this in lockless data structures where you don&#x27;t want to do a null check.</div><br/></div></div><div id="38679065" class="c"><input type="checkbox" id="c-38679065" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38678807">parent</a><span>|</span><a href="#38679810">prev</a><span>|</span><a href="#38679362">next</a><span>|</span><label class="collapse" for="c-38679065">[-]</label><label class="expand" for="c-38679065">[3 more]</label></div><br/><div class="children"><div class="content">The caller may still want to distingish a successful yet useless allocation from an unsuccessful allocation, which resulted in the current situation.</div><br/><div id="38679360" class="c"><input type="checkbox" id="c-38679360" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38679065">parent</a><span>|</span><a href="#38679306">next</a><span>|</span><label class="collapse" for="c-38679360">[-]</label><label class="expand" for="c-38679360">[1 more]</label></div><br/><div class="children"><div class="content">Zero bytes are always allocatable.<p>Unless you need zero byte (and other) pointers to be consistently unique.<p>But that would mean allocating and deallocating some memory for zero byte requests, to provide unique addresses. Or some reserved memory address span, outside of available (real and virtual) RAM, for zero byte pointers.</div><br/></div></div><div id="38679306" class="c"><input type="checkbox" id="c-38679306" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38679065">parent</a><span>|</span><a href="#38679360">prev</a><span>|</span><a href="#38679362">next</a><span>|</span><label class="collapse" for="c-38679306">[-]</label><label class="expand" for="c-38679306">[1 more]</label></div><br/><div class="children"><div class="content">How would you tell?</div><br/></div></div></div></div></div></div></div></div><div id="38679362" class="c"><input type="checkbox" id="c-38679362" checked=""/><div class="controls bullet"><span class="by">jstarks</span><span>|</span><a href="#38678065">parent</a><span>|</span><a href="#38678387">prev</a><span>|</span><a href="#38679890">next</a><span>|</span><label class="collapse" for="c-38679362">[-]</label><label class="expand" for="c-38679362">[3 more]</label></div><br/><div class="children"><div class="content">I can’t agree. Combining alloc and free into one API is a false economy. You’re not really going to save any significant amount of space, and at best you’ll have an extra predictable branch or two (but probably unpredictable, I’d guess).<p>More importantly, it’s harder to interpret the calling code’s intent in the edge cases. What does alloc(NULL, 0) mean? Did the caller try to free a null pointer, or allocate a zero-byte object? With separate functions, you can support either or both or neither, but with the combined model the only safe thing is to support neither and panic, lest you interpret an alloc as a free or vice versa.</div><br/><div id="38679661" class="c"><input type="checkbox" id="c-38679661" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38679362">parent</a><span>|</span><a href="#38679712">next</a><span>|</span><label class="collapse" for="c-38679661">[-]</label><label class="expand" for="c-38679661">[1 more]</label></div><br/><div class="children"><div class="content">Depends on your goals. Lua aimed to be an incredibly tiny language with a very low footprint. The wanted you to need to implement very few functions if you needed to integrate it in your codebase. It has very few data types and function calls for that purpose.<p>The goals of lua may not align with the goals of most projects, but it does make sense to have a single allocator function there, the same way it makes sense to have a single array&#x2F;set&#x2F;hash table data type (what lua calls a Table).</div><br/></div></div><div id="38679712" class="c"><input type="checkbox" id="c-38679712" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#38678065">root</a><span>|</span><a href="#38679362">parent</a><span>|</span><a href="#38679661">prev</a><span>|</span><a href="#38679890">next</a><span>|</span><label class="collapse" for="c-38679712">[-]</label><label class="expand" for="c-38679712">[1 more]</label></div><br/><div class="children"><div class="content">Alloc(null, 0) can be implementation defined. It could be a noop in release builds and a panic in debug builds. Just how certain allocators do extra work in debug builds to detect leaks anyway.<p>Keep in mind this is an allocator interface. Behavior is supposed to change and the allocator maker has control over that. Likewise free() doesn&#x27;t always actually release memory (arena allocators for example), and that&#x27;s the whole point.</div><br/></div></div></div></div><div id="38679890" class="c"><input type="checkbox" id="c-38679890" checked=""/><div class="controls bullet"><span class="by">wolfspaw</span><span>|</span><a href="#38678065">parent</a><span>|</span><a href="#38679362">prev</a><span>|</span><a href="#38678199">next</a><span>|</span><label class="collapse" for="c-38679890">[-]</label><label class="expand" for="c-38679890">[1 more]</label></div><br/><div class="children"><div class="content">Really liked that single-alloc-function strategy.<p>Minimalist and Elegant.</div><br/></div></div><div id="38678199" class="c"><input type="checkbox" id="c-38678199" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38678065">parent</a><span>|</span><a href="#38679890">prev</a><span>|</span><a href="#38677809">next</a><span>|</span><label class="collapse" for="c-38678199">[-]</label><label class="expand" for="c-38678199">[1 more]</label></div><br/><div class="children"><div class="content">Plus a context pointer and old size, as the OP pointed out.</div><br/></div></div></div></div><div id="38679038" class="c"><input type="checkbox" id="c-38679038" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38678551">prev</a><span>|</span><a href="#38677608">next</a><span>|</span><label class="collapse" for="c-38679038">[-]</label><label class="expand" for="c-38679038">[1 more]</label></div><br/><div class="children"><div class="content">This is great!! I learned a lot from this post. I&#x27;m working on a freestanding C project and had to write my own allocator. I ended up replicating the libc design with a doubly linked list of sized blocks which get merged with free neighbors when deallocated.<p>Never occurred to me to pass the object sizes to the deallocation and reallocation functions, even though such sizes are passed around everywhere in other parts of the code. Redesigning the whole thing would be a big effort but it might be worth it.</div><br/></div></div><div id="38677608" class="c"><input type="checkbox" id="c-38677608" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38679038">prev</a><span>|</span><a href="#38679498">next</a><span>|</span><label class="collapse" for="c-38677608">[-]</label><label class="expand" for="c-38677608">[15 more]</label></div><br/><div class="children"><div class="content">No mention of just having the caller do allocation?</div><br/><div id="38677798" class="c"><input type="checkbox" id="c-38677798" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#38677608">parent</a><span>|</span><a href="#38677854">next</a><span>|</span><label class="collapse" for="c-38677798">[-]</label><label class="expand" for="c-38677798">[10 more]</label></div><br/><div class="children"><div class="content">That isn’t efficient in cases where the caller cannot know the size to allocate up front. For example:<p>To use <i>sprintf</i>, you’d have to guess at the buffer size to pass in, or suffer a buffer overflow.<p><i>snprintf</i> is a bit better in that you can recover from passing a buffer that’s too small, but still either requires you to be generous in sizing the buffer, or accept that you often call <i>snprintf</i> twice, doing double work.<p>The way around that is to pass a pointer to an allocation routine, but that’s a simple form of the allocator interface that this article favors.</div><br/><div id="38678008" class="c"><input type="checkbox" id="c-38678008" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38677798">parent</a><span>|</span><a href="#38677854">next</a><span>|</span><label class="collapse" for="c-38678008">[-]</label><label class="expand" for="c-38678008">[9 more]</label></div><br/><div class="children"><div class="content">&gt;That isn’t efficient in cases where the caller cannot know the size to allocate up front<p>This can typically be avoided though. With your sprintf example you could have one function that does the first half that calculates the size and then a second function that does the second half that actually copies into the destination buffer. Alternatively if you want to use realloc you could have a function like snprintf which allows resuming from where it ran out of space.</div><br/><div id="38678191" class="c"><input type="checkbox" id="c-38678191" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38678008">parent</a><span>|</span><a href="#38678392">next</a><span>|</span><label class="collapse" for="c-38678191">[-]</label><label class="expand" for="c-38678191">[1 more]</label></div><br/><div class="children"><div class="content">This strategy, while is worth mentioning as <i>another</i> separate post, can only be applied to simple interfaces. A whole API can be much larger and can&#x27;t avoid allocations inside. There are some cases where the whole API was carefully designed to avoid such allocations, but it is difficult and not always suitable for users.</div><br/></div></div><div id="38678392" class="c"><input type="checkbox" id="c-38678392" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38678008">parent</a><span>|</span><a href="#38678191">prev</a><span>|</span><a href="#38677854">next</a><span>|</span><label class="collapse" for="c-38678392">[-]</label><label class="expand" for="c-38678392">[7 more]</label></div><br/><div class="children"><div class="content">For the first idea: Yes, but both of those would have to interpret the format string and determine the character lengths of the arguments which is duplicated work. I&#x27;d imagine its a large portion of the work. I&#x27;m not convinced its any more efficient than snprintf.<p>The second idea is neat though... it could return an extra argument which is a pointer to the first part of the format string that wasn&#x27;t printed</div><br/><div id="38678547" class="c"><input type="checkbox" id="c-38678547" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38678392">parent</a><span>|</span><a href="#38678527">next</a><span>|</span><label class="collapse" for="c-38678547">[-]</label><label class="expand" for="c-38678547">[3 more]</label></div><br/><div class="children"><div class="content">A more realistic version of the former is that the call is opportunistically given a buffer and returns an error with the required buffer size if the buffer is too small. If the buffer is big enough you only need a single call, otherwise you need two calls with a redundant processing, which is better then the original version---this even works when the caller can&#x27;t preallocate a buffer. This approach is pretty common in the Windows API.<p>----<p>ADDED: I thought charcircuit was talking about always calling two functions in a row, missing the original comment that charcircuit was replying to. My bad, so I&#x27;d like to update this comment as follows...<p>I think the former approach would indeed work if the first call is always given a pointer to the space that can be used to record what has been done so far. Like, `snprintf(ptr, n, &amp;recover, &quot;format&quot;, ...)`, and `recover` can be relatively small, like 16 bytes. I would record original `ptr` and `format` arguments to be safe, and largest offsets to `ptr` and `format` that are known to be written and synchronized to each other. Of course this is just a workaround for C&#x27;s inability to construct and return a sum type.</div><br/><div id="38678567" class="c"><input type="checkbox" id="c-38678567" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38678547">parent</a><span>|</span><a href="#38678527">next</a><span>|</span><label class="collapse" for="c-38678567">[-]</label><label class="expand" for="c-38678567">[2 more]</label></div><br/><div class="children"><div class="content">? This is exactly how snprintf works, which is what we&#x27;re discussing.</div><br/><div id="38678589" class="c"><input type="checkbox" id="c-38678589" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38678567">parent</a><span>|</span><a href="#38678527">next</a><span>|</span><label class="collapse" for="c-38678589">[-]</label><label class="expand" for="c-38678589">[1 more]</label></div><br/><div class="children"><div class="content">Oh wait, I missed the original comment. I see what did you actually mean there.</div><br/></div></div></div></div></div></div><div id="38678527" class="c"><input type="checkbox" id="c-38678527" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38678392">parent</a><span>|</span><a href="#38678547">prev</a><span>|</span><a href="#38677854">next</a><span>|</span><label class="collapse" for="c-38678527">[-]</label><label class="expand" for="c-38678527">[3 more]</label></div><br/><div class="children"><div class="content">&gt;which is duplicated work<p>The caller can allocate memory to be shared between the 2 function calls to avoid needing duplicate work</div><br/><div id="38679365" class="c"><input type="checkbox" id="c-38679365" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38678527">parent</a><span>|</span><a href="#38677854">next</a><span>|</span><label class="collapse" for="c-38679365">[-]</label><label class="expand" for="c-38679365">[2 more]</label></div><br/><div class="children"><div class="content">How do you know how much memory you need to allocate when you need to do the work in the first place to determine it? Maybe if snprintf was resumable by supplying a larger buffer while it was doing its work, but this seems like a lot of complexity.</div><br/><div id="38679480" class="c"><input type="checkbox" id="c-38679480" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38679365">parent</a><span>|</span><a href="#38677854">next</a><span>|</span><label class="collapse" for="c-38679480">[-]</label><label class="expand" for="c-38679480">[1 more]</label></div><br/><div class="children"><div class="content">In this case the state takes a constant amount of space so it is just a matter of allocating a single struct.<p>With the approach of having the caller allocate you have carefully design the API to make it possible.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38677854" class="c"><input type="checkbox" id="c-38677854" checked=""/><div class="controls bullet"><span class="by">eska</span><span>|</span><a href="#38677608">parent</a><span>|</span><a href="#38677798">prev</a><span>|</span><a href="#38678636">next</a><span>|</span><label class="collapse" for="c-38677854">[-]</label><label class="expand" for="c-38677854">[2 more]</label></div><br/><div class="children"><div class="content">This is about the case when the caller can’t know how much memory to allocate but is able to provide an estimate for most cases. Either it becomes possible to avoid repeated allocation and make deallocation faster, or another classic dynamic allocator can be asked for additional memory for outlier cases.</div><br/><div id="38679720" class="c"><input type="checkbox" id="c-38679720" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#38677608">root</a><span>|</span><a href="#38677854">parent</a><span>|</span><a href="#38678636">next</a><span>|</span><label class="collapse" for="c-38679720">[-]</label><label class="expand" for="c-38679720">[1 more]</label></div><br/><div class="children"><div class="content">If the lifetime of the allocation works out this can end up with a nice pattern of &quot;try to use a cheap stack buffer, and fall back to a more expensive heap allocation when that fails&quot;</div><br/></div></div></div></div><div id="38678636" class="c"><input type="checkbox" id="c-38678636" checked=""/><div class="controls bullet"><span class="by">cmiller1</span><span>|</span><a href="#38677608">parent</a><span>|</span><a href="#38677854">prev</a><span>|</span><a href="#38677640">next</a><span>|</span><label class="collapse" for="c-38678636">[-]</label><label class="expand" for="c-38678636">[1 more]</label></div><br/><div class="children"><div class="content">If you click the link in the first sentence it brings you to an article about that.</div><br/></div></div><div id="38677640" class="c"><input type="checkbox" id="c-38677640" checked=""/><div class="controls bullet"><span class="by">ooterness</span><span>|</span><a href="#38677608">parent</a><span>|</span><a href="#38678636">prev</a><span>|</span><a href="#38679498">next</a><span>|</span><label class="collapse" for="c-38677640">[-]</label><label class="expand" for="c-38677640">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Just&quot;</div><br/></div></div></div></div><div id="38679498" class="c"><input type="checkbox" id="c-38679498" checked=""/><div class="controls bullet"><span class="by">Woodi</span><span>|</span><a href="#38677608">prev</a><span>|</span><label class="collapse" for="c-38679498">[-]</label><label class="expand" for="c-38679498">[1 more]</label></div><br/><div class="children"><div class="content">Umm, C looks like nice language...<p>Then maybe that so-so-problematic stringZ are too just bad convention ? Maybe put some intern to try other implementation ? ;)</div><br/></div></div></div></div></div></div></div></body></html>