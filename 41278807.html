<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723971667778" as="style"/><link rel="stylesheet" href="styles.css?v=1723971667778"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.sylver.dev/build-your-own-sqlite-part-1-listing-tables">Build your own SQLite, Part 1: Listing tables</a> <span class="domain">(<a href="https://blog.sylver.dev">blog.sylver.dev</a>)</span></div><div class="subtext"><span>upmind</span> | <span>7 comments</span></div><br/><div><div id="41279864" class="c"><input type="checkbox" id="c-41279864" checked=""/><div class="controls bullet"><span class="by">bluejekyll</span><span>|</span><label class="collapse" for="c-41279864">[-]</label><label class="expand" for="c-41279864">[6 more]</label></div><br/><div class="children"><div class="content">An interesting idea just struck me. If this is all in native Rust then you could do something interesting with macro defined SQL queries, where at compile time, you could output direct bindings from the SQL to the internal DB api. This would skip parsing and building query plans at compile time (for static queries).<p>Anyway, cool project.</div><br/><div id="41280956" class="c"><input type="checkbox" id="c-41280956" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41279864">parent</a><span>|</span><a href="#41280778">next</a><span>|</span><label class="collapse" for="c-41280956">[-]</label><label class="expand" for="c-41280956">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If this is all in native Rust then you could do something interesting with macro defined SQL queries, where at compile time, you could output direct bindings from the SQL to the internal DB api.<p>Aren&#x27;t table references resolved at runtime?</div><br/></div></div><div id="41280778" class="c"><input type="checkbox" id="c-41280778" checked=""/><div class="controls bullet"><span class="by">dymk</span><span>|</span><a href="#41279864">parent</a><span>|</span><a href="#41280956">prev</a><span>|</span><a href="#41280309">next</a><span>|</span><label class="collapse" for="c-41280778">[-]</label><label class="expand" for="c-41280778">[1 more]</label></div><br/><div class="children"><div class="content">Query plans may depend on runtime information about a table’s statistics, though</div><br/></div></div><div id="41280309" class="c"><input type="checkbox" id="c-41280309" checked=""/><div class="controls bullet"><span class="by">khimaros</span><span>|</span><a href="#41279864">parent</a><span>|</span><a href="#41280778">prev</a><span>|</span><a href="#41279960">next</a><span>|</span><label class="collapse" for="c-41280309">[-]</label><label class="expand" for="c-41280309">[1 more]</label></div><br/><div class="children"><div class="content">SQLx seems to do some form of this. though what you&#x27;re suggesting may remove the build time dependency on &quot;connecting&quot; to a SQLite database.<p>&quot;SQLx supports compile-time checked queries. It does not, however, do this by providing a Rust API or DSL (domain-specific language) for building queries. Instead, it provides macros that take regular SQL as input and ensure that it is valid for your database. The way this works is that SQLx connects to your development DB at compile time to have the database itself verify (and return some info on) your SQL queries.&quot;<p><a href="https:&#x2F;&#x2F;github.com&#x2F;launchbadge&#x2F;sqlx">https:&#x2F;&#x2F;github.com&#x2F;launchbadge&#x2F;sqlx</a></div><br/></div></div><div id="41279960" class="c"><input type="checkbox" id="c-41279960" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#41279864">parent</a><span>|</span><a href="#41280309">prev</a><span>|</span><label class="collapse" for="c-41279960">[-]</label><label class="expand" for="c-41279960">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting idea. One problem I see is that conventional query planners use statistics to choose the optimal plan, however the data presumably wouldn&#x27;t be available at compile time. But if you built the database with this approach in mind you might find a different approach to planning.</div><br/><div id="41280303" class="c"><input type="checkbox" id="c-41280303" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#41279864">root</a><span>|</span><a href="#41279960">parent</a><span>|</span><label class="collapse" for="c-41280303">[-]</label><label class="expand" for="c-41280303">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure this is why sql engines normally jit compile to either bytecode or straight to machine code, so that they can easily recompile and replace the query if the statistics or other factors change. So long as you don&#x27;t regularly recompile the query you pay the cost once then reuse the results possibly thousands or even millions of times, but without being forced to keep using the exact same plan until you rebuild the application.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>