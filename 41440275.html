<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725699671405" as="style"/><link rel="stylesheet" href="styles.css?v=1725699671405"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.michaelpj.com/blog/2024/09/03/lsp-good-bad-ugly.html">LSP: The good, the bad, and the ugly</a> <span class="domain">(<a href="https://www.michaelpj.com">www.michaelpj.com</a>)</span></div><div class="subtext"><span>bryjnar</span> | <span>61 comments</span></div><br/><div><div id="41468756" class="c"><input type="checkbox" id="c-41468756" checked=""/><div class="controls bullet"><span class="by">oblio</span><span>|</span><a href="#41470148">next</a><span>|</span><label class="collapse" for="c-41468756">[-]</label><label class="expand" for="c-41468756">[3 more]</label></div><br/><div class="children"><div class="content">Rabbit hole warning (started by the article linked above):<p><a href="https:&#x2F;&#x2F;matklad.github.io&#x2F;2022&#x2F;04&#x2F;25&#x2F;why-lsp.html" rel="nofollow">https:&#x2F;&#x2F;matklad.github.io&#x2F;2022&#x2F;04&#x2F;25&#x2F;why-lsp.html</a><p><a href="https:&#x2F;&#x2F;matklad.github.io&#x2F;2023&#x2F;10&#x2F;12&#x2F;lsp-could-have-been-better.html" rel="nofollow">https:&#x2F;&#x2F;matklad.github.io&#x2F;2023&#x2F;10&#x2F;12&#x2F;lsp-could-have-been-bet...</a></div><br/><div id="41469469" class="c"><input type="checkbox" id="c-41469469" checked=""/><div class="controls bullet"><span class="by">matklad</span><span>|</span><a href="#41468756">parent</a><span>|</span><a href="#41469223">next</a><span>|</span><label class="collapse" for="c-41469469">[-]</label><label class="expand" for="c-41469469">[1 more]</label></div><br/><div class="children"><div class="content">And<p><a href="https:&#x2F;&#x2F;rust-analyzer.github.io&#x2F;blog&#x2F;2020&#x2F;07&#x2F;20&#x2F;three-architectures-for-responsive-ide.html" rel="nofollow">https:&#x2F;&#x2F;rust-analyzer.github.io&#x2F;blog&#x2F;2020&#x2F;07&#x2F;20&#x2F;three-archit...</a><p>Is a must-read if you are to build your own LSP server!</div><br/></div></div><div id="41469223" class="c"><input type="checkbox" id="c-41469223" checked=""/><div class="controls bullet"><span class="by">sestep</span><span>|</span><a href="#41468756">parent</a><span>|</span><a href="#41469469">prev</a><span>|</span><a href="#41470148">next</a><span>|</span><label class="collapse" for="c-41469223">[-]</label><label class="expand" for="c-41469223">[1 more]</label></div><br/><div class="children"><div class="content">That 2022 post is amazing, thanks for the link!</div><br/></div></div></div></div><div id="41470148" class="c"><input type="checkbox" id="c-41470148" checked=""/><div class="controls bullet"><span class="by">ogoffart</span><span>|</span><a href="#41468756">prev</a><span>|</span><a href="#41469087">next</a><span>|</span><label class="collapse" for="c-41470148">[-]</label><label class="expand" for="c-41470148">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve implemented a LSP server (for Slint - <a href="https:&#x2F;&#x2F;slint.dev" rel="nofollow">https:&#x2F;&#x2F;slint.dev</a>) and I agree with this article.<p>The paradox is that it was meant to avoid to write language support for each editor. Yet, if you want to support vscode you must create a specific extension for it and can&#x27;t just have a language client.<p>The article mention the configuration problem, but I&#x27;d add the problem that Microsoft refuses to specify a way for the server to tell the client what are the config options so that the client can show some kind UI showing the possible configuration options with a description of what they do. <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;language-server-protocol&#x2F;issues&#x2F;1640">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;language-server-protocol&#x2F;issues...</a></div><br/><div id="41472554" class="c"><input type="checkbox" id="c-41472554" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#41470148">parent</a><span>|</span><a href="#41472227">next</a><span>|</span><label class="collapse" for="c-41472554">[-]</label><label class="expand" for="c-41472554">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because the LSP makes no assumptions about stuff like (1) what the language server is, (2) how it is launched and managed, (3) how the editor communicates with it, etc. It only defines the <i>format</i> of the communication, nothing else.<p>In the simplest form the entire language extension in VS Code can be ~15 lines of code that forks the server process and talks with it over stdio. But in complex cases you can:<p>- Write the entire language server in the extension itself.<p>- Have your code hosted on a different machine or Docker container.<p>- Run the editor in a browser and get language support though a service worker or a TCP connection to a remote server.<p>LSP supports all of this seamlessly because it is agnostic about the transport layer.</div><br/></div></div><div id="41472227" class="c"><input type="checkbox" id="c-41472227" checked=""/><div class="controls bullet"><span class="by">dualogy</span><span>|</span><a href="#41470148">parent</a><span>|</span><a href="#41472554">prev</a><span>|</span><a href="#41469087">next</a><span>|</span><label class="collapse" for="c-41472227">[-]</label><label class="expand" for="c-41472227">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The paradox is that it was meant to avoid to write language support for each editor. Yet, if you want to support vscode you must create a specific extension for it and can&#x27;t just have a language client.<p>On the one hand, this has always bugged me slightly. But on the other hand, every time when it came down to it in practice, I realized two things: first, a VSC extension that does nothing but wire up the LSP language clienting library is a <i>tiny</i> project with no major maintenance burden; and secondly, more importantly you usually want additional language-extension client-side features that are editor-specific by nature and either couldn&#x27;t or shouldn&#x27;t be abstracted-inside &#x2F; covered-by the language-server &#x2F; lang intel &#x2F; IntelliSense realm. Syntax-coloring and other grammar-describing meta-data come to mind, or custom Notebook, or rich &amp; productive build or debug or pkg-mgmt etc. helpers &amp; tooling UX, etc. Stuff that arguably belongs in one&#x27;s &quot;language extension&quot; but is mostly editor-specific and thus at the same time doesn&#x27;t truly belong in one&#x27;s &quot;language intelligence serving&quot;.</div><br/></div></div></div></div><div id="41469087" class="c"><input type="checkbox" id="c-41469087" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41470148">prev</a><span>|</span><a href="#41470003">next</a><span>|</span><label class="collapse" for="c-41469087">[-]</label><label class="expand" for="c-41469087">[18 more]</label></div><br/><div class="children"><div class="content">RE: &quot;Not a truly open project.&quot;<p>If LSP isn&#x27;t truly open, then neither are most GNU projects.  It was very common for the first 15+ years of GNU&#x27;s existence for the public development process of a project to be &quot;the single maintainer publishes a release archive whenever they feel like it&quot;<p>It&#x27;s a standard freely published and available for all to implement.  If that&#x27;s not &quot;truly open&quot; then we have moved the goalposts way too far.</div><br/><div id="41470057" class="c"><input type="checkbox" id="c-41470057" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41469087">parent</a><span>|</span><a href="#41469998">next</a><span>|</span><label class="collapse" for="c-41470057">[-]</label><label class="expand" for="c-41470057">[9 more]</label></div><br/><div class="children"><div class="content">I think &quot;truly open&quot; is not specific enough. Not being developed &quot;in the open&quot; is one thing, not having &quot;open governance&quot; is another thing.<p>That said, I guess the problem here is that for standards it helps if well, you collaborate with the people for which the standard is meant to be used by, which is presumably a little hard if there&#x27;s a huge asymmetric relationship when it comes to Microsoft&#x27;s concerns vs the rest of the world&#x27;s concerns.<p>This is one of those cases where having a standards committee or consortium is the way to go. Committees have their problems, but I think it&#x27;s only reasonable. If you think about it, doesn&#x27;t it seem inevitable that eventually, big organizations that make editors would want a consortium of some sort to collaborate on protocols like this? LSP is really just the beginning, since there are plenty of things that editors would probably like to integrate deeper with, such as build systems.</div><br/><div id="41471544" class="c"><input type="checkbox" id="c-41471544" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41469087">root</a><span>|</span><a href="#41470057">parent</a><span>|</span><a href="#41470421">next</a><span>|</span><label class="collapse" for="c-41471544">[-]</label><label class="expand" for="c-41471544">[3 more]</label></div><br/><div class="children"><div class="content">&gt; doesn&#x27;t it seem inevitable that eventually, big organizations that make editors would want a consortium of some sort to collaborate on protocols like this?<p>Jetbrains&#x27; main feature are their own engines. And MS still has Visual Studio - without Code ;) - which doesn&#x27;t use LSP. And Apple is Apple. So, who would that be?
On the contrary I&#x27;d say that everybody who want&#x27;s to get &quot;big&quot;, must not use LSP to have something that sets the editor apart.</div><br/><div id="41471926" class="c"><input type="checkbox" id="c-41471926" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41469087">root</a><span>|</span><a href="#41471544">parent</a><span>|</span><a href="#41470421">next</a><span>|</span><label class="collapse" for="c-41471926">[-]</label><label class="expand" for="c-41471926">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Jetbrains&#x27; main feature are their own engines.<p>Jetbrains IntelliJ platform supports language servers and for example, WebStorm will use tsserver for TypeScript code. CLion also uses clangd, and there are also third-party plugins that use the LSP client.<p>&gt; And MS still has Visual Studio - without Code ;) - which doesn&#x27;t use LSP.<p>Microsoft Visual Studio definitely has a built-in LSP client, and yes, I mean &quot;not Code&quot;. By default it will be used for tsserver (regular Visual Studio indeed supports TypeScript), and third-party plugins can use the LSP client too.<p>&gt; And Apple is Apple<p>Of course, <i>we&#x27;ll see</i>. Apple is stubborn yes. If they do LSPs, they&#x27;ll do it their way specifically. That said, I personally think it&#x27;s decent odds to eventually happen, especially seeing as the Swift programming language provides an LSP.<p>&gt; On the contrary I&#x27;d say that everybody who want&#x27;s to get &quot;big&quot;, must not use LSP to have something that sets the editor apart.<p>Well, it&#x27;s certainly possible to build richer features than the LSP can support if you build your code intelligence engine to be tightly integrated with your text editor, and it is true that a huge selling point of IntelliJ is indeed, their own custom code intelligence. However, I think this is a false dichotomy. There is definitely no reason a program that has its own framework for code intelligence systems can&#x27;t also support LSP - I mean, both Visual Studio and IntelliJ do, and IntelliJ has always been mixing multiple sources of code intelligence together, as it still does today with clangd and tsserver, which in IntelliJ get combined with their own analysis and refactoring tools.<p>Modelling code intelligence the way Jetbrains always has probably won&#x27;t go away any time soon, but I think it is pretty clearly not the future. The future is building code intelligence into the compiler, and redesigning the architecture of compilers to better accommodate these interactive, incremental use cases. Jetbrains seems to be a very smart company and I don&#x27;t expect them to continue to cling to outmoded approaches if they prove to be less effective, and I suspect that as LSPs continue to improve Jetbrains will continue to lean on them and probably even contribute to them.<p>I will say though, at this point, not having a built-in LSP client does indeed set your editor apart quite a bit, although definitely not in a way that will be favorable!</div><br/><div id="41472503" class="c"><input type="checkbox" id="c-41472503" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41469087">root</a><span>|</span><a href="#41471926">parent</a><span>|</span><a href="#41470421">next</a><span>|</span><label class="collapse" for="c-41472503">[-]</label><label class="expand" for="c-41472503">[1 more]</label></div><br/><div class="children"><div class="content">I did formulate that badly. 
I did not want to say that Jetbrains and MS do not use LSPs too, but that the most important IDEs do _not_ use an LSP - Java, Kotlin, Python, C#, Rust - or add significant improvement to them - like the debugger and refactoring for C++.<p>And again, while (not-Code) VS may support LSP, it does not use one it for the main languages - C++, C# and F#.</div><br/></div></div></div></div></div></div><div id="41470421" class="c"><input type="checkbox" id="c-41470421" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41469087">root</a><span>|</span><a href="#41470057">parent</a><span>|</span><a href="#41471544">prev</a><span>|</span><a href="#41469998">next</a><span>|</span><label class="collapse" for="c-41470421">[-]</label><label class="expand" for="c-41470421">[5 more]</label></div><br/><div class="children"><div class="content">&gt; This is one of those cases where having a standards committee or consortium is the way to go. Committees have their problems, but I think it&#x27;s only reasonable.<p>I think a committee is a reasonable backup plan, and can even be done without Dirk&#x27;s approval (see e.g. WHATWG done without the W3C&#x27;s approval).  If the LSP continues to be &quot;good enough&quot; then it seems unlikely.<p>&gt; If you think about it, doesn&#x27;t it seem inevitable that eventually, big organizations that make editors would want a consortium of some sort to collaborate on protocols like this?<p>Maybe?  Editors tend to be an afterthought for most companies; JetBrains is the only company I can think of that is big on the LSP and for whom the editor is a primary experience.</div><br/><div id="41470845" class="c"><input type="checkbox" id="c-41470845" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41469087">root</a><span>|</span><a href="#41470421">parent</a><span>|</span><a href="#41470952">next</a><span>|</span><label class="collapse" for="c-41470845">[-]</label><label class="expand" for="c-41470845">[1 more]</label></div><br/><div class="children"><div class="content">Yes I certainly agree, there is not really much of an impetus for this to happen right away or anything. In the long term, though, I do suspect it is inevitable.<p>&gt; Maybe? Editors tend to be an afterthought for most companies; JetBrains is the only company I can think of that is big on the LSP and for whom the editor is a primary experience.<p>I have some thoughts:<p>- I think there will be more. At the very least, I suspect there is a reasonable chance Apple&#x2F;XCode would eventually adopt LSP.<p>- Realistically, there aren&#x27;t that many <i>browser engines</i> either. There&#x27;s really just two truly distinct browser engines, and really only one of them is the main product of the company that produces it. Arguably there are already more distinct text editor engines that have LSP clients built-in today: Neovim, VSCode&#x2F;Monaco, Visual Studio, IntelliJ IDEA, Eclipse, Zed, and probably more I&#x27;m not thinking of.<p>- I think that it is likely LSP clients will continue to appear in more places. In &quot;cloud compute&quot; UIs for things like serverless functions, inside of code forge&#x27;s built-in editors, and so forth. It&#x27;s not that it&#x27;s necessarily that it&#x27;s so easy to do it well, it&#x27;s more that the value:effort ratio of doing it is pretty great, and every time someone develops a new high-quality LSP, it gets even better.</div><br/></div></div><div id="41470952" class="c"><input type="checkbox" id="c-41470952" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41469087">root</a><span>|</span><a href="#41470421">parent</a><span>|</span><a href="#41470845">prev</a><span>|</span><a href="#41469998">next</a><span>|</span><label class="collapse" for="c-41470952">[-]</label><label class="expand" for="c-41470952">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  Editors tend to be an afterthought for most companies; JetBrains is the only company I can think of that is big on the LSP and for whom the editor is a primary experience.<p>Well, expand beyond &quot;big companies&quot;, to include open source prijects, and non-profit foundations, and there are a lot of parties that might be interested in an LSP comity including both groups that develop editors (neovim, emacs, Jetbrains&#x2F;intellij, eclipse, zed, etc.) and makers of lsp servers (ex. Google for gopls, Rust foundation for rust, etc.)</div><br/><div id="41471564" class="c"><input type="checkbox" id="c-41471564" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41469087">root</a><span>|</span><a href="#41470952">parent</a><span>|</span><a href="#41469998">next</a><span>|</span><label class="collapse" for="c-41471564">[-]</label><label class="expand" for="c-41471564">[2 more]</label></div><br/><div class="children"><div class="content">But then there is no reason to use LSP, they could (and should) come up with their own protocol.</div><br/><div id="41471859" class="c"><input type="checkbox" id="c-41471859" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41469087">root</a><span>|</span><a href="#41471564">parent</a><span>|</span><a href="#41469998">next</a><span>|</span><label class="collapse" for="c-41471859">[-]</label><label class="expand" for="c-41471859">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t follow. The reason why you use LSP is because it is a common protocol. LSP is valuable <i>because</i> it is a standard protocol; build an LSP client into your text editor and gain access to the rich ecosystem of existing LSP servers, build an LSP server for your language and get rich code intelligence for your language inside many of the most popular text editors.<p>Of course someone else <i>could</i> just try to make a competing protocol with LSP, but I think that&#x27;s a waste of time when it could most likely be incrementally and backwards compatibly improved quite a lot. And also, any given party only is one side of the equation, so any given entity only has so much sway here.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41469998" class="c"><input type="checkbox" id="c-41469998" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41469087">parent</a><span>|</span><a href="#41470057">prev</a><span>|</span><a href="#41469770">next</a><span>|</span><label class="collapse" for="c-41469998">[-]</label><label class="expand" for="c-41469998">[1 more]</label></div><br/><div class="children"><div class="content">Two things:<p>1. (As another commenter mentioned) Most GNU projects are not standards that are expected to be adopted by a significant number of implementers, and used by a huge number of users.  Most GNU projects are totally fine having a few maintainers.<p>2. I am a lot more comfortable with a GNU project being run by a single maintainer than a public specification being owned by a corporation, where changes to that specification are largely driven by that company&#x27;s product choices and profit motive.<p>And regardless, it seems a little weird to compare the GNU of the 80s and 90s to any public project today.  In GNU&#x27;s first 15 years the internet was nascent (at best!), and the number of people who implemented, used, and cared about these sorts of things were orders of magnitude smaller than they are today.  Needs have changed.</div><br/></div></div><div id="41469770" class="c"><input type="checkbox" id="c-41469770" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41469087">parent</a><span>|</span><a href="#41469998">prev</a><span>|</span><a href="#41469668">next</a><span>|</span><label class="collapse" for="c-41469770">[-]</label><label class="expand" for="c-41469770">[1 more]</label></div><br/><div class="children"><div class="content">Most GNU projects are typically not standards&#x2F;specifications but programs and libraries. That&#x27;s a significant difference IMO.</div><br/></div></div><div id="41469269" class="c"><input type="checkbox" id="c-41469269" checked=""/><div class="controls bullet"><span class="by">aithrowaway1987</span><span>|</span><a href="#41469087">parent</a><span>|</span><a href="#41469668">prev</a><span>|</span><a href="#41469809">next</a><span>|</span><label class="collapse" for="c-41469269">[-]</label><label class="expand" for="c-41469269">[3 more]</label></div><br/><div class="children"><div class="content">But that is not the standard for current GNU projects in large part because of all the easily avoidable friction. &quot;If it was good enough for Richard Stallman in 1987, it&#x27;s good enough for Microsoft in 2024&quot; is just a dumb argument.<p>Not to mention you&#x27;re conflating apples with oranges, since a software <i>standard</i> is very different from an <i>application.</i> POSIX wasn&#x27;t just one Bell Labs employee working by himself.<p>From the article:<p>&gt; The LSP should be an open standard, like HTTP, with an open committee that represents the large community which is invested in LSP, and can offer their insight in how to evolve it.<p>There is no goalpost moving here.</div><br/><div id="41469457" class="c"><input type="checkbox" id="c-41469457" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41469087">root</a><span>|</span><a href="#41469269">parent</a><span>|</span><a href="#41469442">next</a><span>|</span><label class="collapse" for="c-41469457">[-]</label><label class="expand" for="c-41469457">[1 more]</label></div><br/><div class="children"><div class="content">Building and maintaining a community is hard work.  Even just talking to all comers is hard work.  You need a team for that, but if you&#x27;re a team of one then the community is likely going to suffer.  You could find external contributors to promote to committers, but that&#x27;s work too, and maybe LSP&#x27;s maintainer doesn&#x27;t want that (or maybe LSP&#x27;s maintainer&#x27;s employer (MSFT) doesn&#x27;t want that).  Apart from what MSFT wants, the rest is just as likely to happen for small enough projects whether they be GNU projects or not.</div><br/></div></div></div></div><div id="41469809" class="c"><input type="checkbox" id="c-41469809" checked=""/><div class="controls bullet"><span class="by">kayodelycaon</span><span>|</span><a href="#41469087">parent</a><span>|</span><a href="#41469269">prev</a><span>|</span><a href="#41470003">next</a><span>|</span><label class="collapse" for="c-41469809">[-]</label><label class="expand" for="c-41469809">[2 more]</label></div><br/><div class="children"><div class="content">Yeah… this is can be confusing. “Open source”, “open standard”, and “open project” are different concepts.<p>The first two are well-defined and LSP meets the criteria for both.<p>“Open project” doesn’t have a definition or criteria. In this case, it probably means the community using a standard, controls the standard. The http protocol is an example of this.<p>Ultimately, they think the people in charge of the project are not listening to the people using it. This is a serious concern.<p>However, making a project “open” does not fix this problem. See systemd.<p>I hate dropping Wikipedia links but here is open standard:   <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Open_standard" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Open_standard</a></div><br/></div></div></div></div><div id="41470003" class="c"><input type="checkbox" id="c-41470003" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41469087">prev</a><span>|</span><a href="#41470783">next</a><span>|</span><label class="collapse" for="c-41470003">[-]</label><label class="expand" for="c-41470003">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>So I don’t think it’s really a good idea to do a big re-engineering of the protocol just to make it easier for implementers</i><p>I&#x27;m not so sure.  Maybe it&#x27;s not the case today, but if the protocol eventually becomes so large, so crufty, so under-specified that implementers struggle to provide their implementations, then users suffer.</div><br/></div></div><div id="41470783" class="c"><input type="checkbox" id="c-41470783" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#41470003">prev</a><span>|</span><a href="#41469676">next</a><span>|</span><label class="collapse" for="c-41470783">[-]</label><label class="expand" for="c-41470783">[3 more]</label></div><br/><div class="children"><div class="content">The problem that Microsoft is solving is promotion of VsCode and Visual Studio. Making LSP small and easy to implement would go against that. They want LSP to work well only in their IDEs. Yes, this makes implementing LSP for languages harder, but most of those developers are paid by MS directly or indirectly, in fact making LSP hard also works as a filter against unpaid contributors.</div><br/><div id="41471374" class="c"><input type="checkbox" id="c-41471374" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41470783">parent</a><span>|</span><a href="#41470998">next</a><span>|</span><label class="collapse" for="c-41471374">[-]</label><label class="expand" for="c-41471374">[1 more]</label></div><br/><div class="children"><div class="content">When it comes to IDEs, small and easy = uncompetitive.<p>Most users want to use the IDE that saves them the most time and has the features they want, they are not concerned with implementation complexity because that’s someone else’s job.<p>If you reduce all the complexity of a competitive IDE to a protocol then you get something as complicated as LSP. That’s just how it is.</div><br/></div></div><div id="41470998" class="c"><input type="checkbox" id="c-41470998" checked=""/><div class="controls bullet"><span class="by">eropple</span><span>|</span><a href="#41470783">parent</a><span>|</span><a href="#41471374">prev</a><span>|</span><a href="#41469676">next</a><span>|</span><label class="collapse" for="c-41470998">[-]</label><label class="expand" for="c-41470998">[1 more]</label></div><br/><div class="children"><div class="content">Having read the LSP specification, and when I take into account just how many things LSP <i>does</i>, I think a 285-page spec is really tiny. I have specs on my work computer with TMF and CAMARA specs that are nearly 100 pages just to talk about the operation of a half-dozen methods--and there&#x27;s still ambiguity in them at times.<p>Coupling that genuine brevity with the ability to avoid serious backwards-compatibility problems makes this charge feel pretty outlandish, TBH.</div><br/></div></div></div></div><div id="41469676" class="c"><input type="checkbox" id="c-41469676" checked=""/><div class="controls bullet"><span class="by">csb6</span><span>|</span><a href="#41470783">prev</a><span>|</span><a href="#41469317">next</a><span>|</span><label class="collapse" for="c-41469676">[-]</label><label class="expand" for="c-41469676">[1 more]</label></div><br/><div class="children"><div class="content">The article touched on it, but it would be nice if there were a standard way to have extensions for LSP, e.g. a protocol that could be shared by language servers for formal specification languages that need proof obligation support. [0]<p>[0] <a href="http:&#x2F;&#x2F;dx.doi.org&#x2F;10.4204&#x2F;EPTCS.338.3" rel="nofollow">http:&#x2F;&#x2F;dx.doi.org&#x2F;10.4204&#x2F;EPTCS.338.3</a></div><br/></div></div><div id="41469317" class="c"><input type="checkbox" id="c-41469317" checked=""/><div class="controls bullet"><span class="by">kayodelycaon</span><span>|</span><a href="#41469676">prev</a><span>|</span><a href="#41469135">next</a><span>|</span><label class="collapse" for="c-41469317">[-]</label><label class="expand" for="c-41469317">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The LSP specification is big. Really big. Last time I checked it had 90 (!) methods and 407 (!!) types. Printing it to a PDF gives you 285 pages (!!!).<p>Given what it does, that’s pretty dang small. You don’t get all those features across every programming language without some complexity.<p>Compared to the 3,000+ pages specifications I’ve dealt with, this is easy.<p>I have a very tiny violin and a cricket to play it for anyone complaining about a few hundred pages. :)</div><br/><div id="41469893" class="c"><input type="checkbox" id="c-41469893" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41469317">parent</a><span>|</span><a href="#41472304">next</a><span>|</span><label class="collapse" for="c-41469893">[-]</label><label class="expand" for="c-41469893">[3 more]</label></div><br/><div class="children"><div class="content">What sticks out to me is that there&#x27;s less than one method per every four types. Given that, I assume that most of these types are just plain structs or type aliases; in other words, just names for things. I&#x27;m not sure what the author is trying to convey with that; would it be better if there were half as many types but they all had twice as many fields and methods and had to get used for multiple purposes?<p>If the scope of the project is too large, that&#x27;s certainly a valid complaint, but independent of somehow measuring the expected &quot;size&quot; of an API to cover a given scope, I don&#x27;t really see how these raw numbers are particularly concerning. I&#x27;d be more concerned if the ratio of methods to types were reversed, but still a bit skeptical of any significance without more context.</div><br/><div id="41469939" class="c"><input type="checkbox" id="c-41469939" checked=""/><div class="controls bullet"><span class="by">kayodelycaon</span><span>|</span><a href="#41469317">root</a><span>|</span><a href="#41469893">parent</a><span>|</span><a href="#41472304">next</a><span>|</span><label class="collapse" for="c-41469939">[-]</label><label class="expand" for="c-41469939">[2 more]</label></div><br/><div class="children"><div class="content">For comparison, YAML is 77 pages.</div><br/><div id="41472047" class="c"><input type="checkbox" id="c-41472047" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41469317">root</a><span>|</span><a href="#41469939">parent</a><span>|</span><a href="#41472304">next</a><span>|</span><label class="collapse" for="c-41472047">[-]</label><label class="expand" for="c-41472047">[1 more]</label></div><br/><div class="children"><div class="content">YAML is a data serialization language that doesn&#x27;t have any concept of &quot;execution&quot;; LSP needs to encode not just one full programming language semantics, but _arbitrary_ programming language semantics. YAML&#x27;s spec being over 3&#x2F;4 the size of LSP is a lot more damning to YAML to me.</div><br/></div></div></div></div></div></div><div id="41472304" class="c"><input type="checkbox" id="c-41472304" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41469317">parent</a><span>|</span><a href="#41469893">prev</a><span>|</span><a href="#41470557">next</a><span>|</span><label class="collapse" for="c-41472304">[-]</label><label class="expand" for="c-41472304">[1 more]</label></div><br/><div class="children"><div class="content">Your argument basically boils down to &quot;I am cooler than you because I have worked on larger specs&quot;. The fact that there are hilariously larger documents doesn&#x27;t offer any perspective on whether you need 300 pages to describe how to color source code in a text editor.<p>But good for you! Here&#x27;s a very tiny award.</div><br/></div></div><div id="41470557" class="c"><input type="checkbox" id="c-41470557" checked=""/><div class="controls bullet"><span class="by">Uehreka</span><span>|</span><a href="#41469317">parent</a><span>|</span><a href="#41472304">prev</a><span>|</span><a href="#41469135">next</a><span>|</span><label class="collapse" for="c-41470557">[-]</label><label class="expand" for="c-41470557">[1 more]</label></div><br/><div class="children"><div class="content">I was gonna say, I’ve had to pore over 800+ page PDFs from the 3GPP describing like, the possible fields for one particular protocol in the LTE spec. 285 pages for the whole shebang feels Hemingwayesque.</div><br/></div></div></div></div><div id="41469135" class="c"><input type="checkbox" id="c-41469135" checked=""/><div class="controls bullet"><span class="by">pama</span><span>|</span><a href="#41469317">prev</a><span>|</span><a href="#41470423">next</a><span>|</span><label class="collapse" for="c-41469135">[-]</label><label class="expand" for="c-41469135">[5 more]</label></div><br/><div class="children"><div class="content">How much easier is it to get the tree-sitter spec implemented for a new language compared to LSP?  Are there synergies in getting both to work?</div><br/><div id="41471595" class="c"><input type="checkbox" id="c-41471595" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41469135">parent</a><span>|</span><a href="#41469162">next</a><span>|</span><label class="collapse" for="c-41471595">[-]</label><label class="expand" for="c-41471595">[1 more]</label></div><br/><div class="children"><div class="content">Treesitter is the wrong solution anyway. The biggest advantage of LSP is that the parser, type checker,... used by the LSP is (well, can and should be) the same as the one used in the compiler (or at least another _complete_ implementation of the language, like clang for gcc&#x2F;g++).</div><br/></div></div><div id="41469162" class="c"><input type="checkbox" id="c-41469162" checked=""/><div class="controls bullet"><span class="by">kriiuuu</span><span>|</span><a href="#41469135">parent</a><span>|</span><a href="#41471595">prev</a><span>|</span><a href="#41469516">next</a><span>|</span><label class="collapse" for="c-41469162">[-]</label><label class="expand" for="c-41469162">[1 more]</label></div><br/><div class="children"><div class="content">Significantly easier because there is just a lot less surface area.</div><br/></div></div><div id="41469516" class="c"><input type="checkbox" id="c-41469516" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41469135">parent</a><span>|</span><a href="#41469162">prev</a><span>|</span><a href="#41470004">next</a><span>|</span><label class="collapse" for="c-41469516">[-]</label><label class="expand" for="c-41469516">[1 more]</label></div><br/><div class="children"><div class="content">Tree Sitter doesn&#x27;t do a tenth of what most LSP servers do, so it&#x27;s much easier. But they aren&#x27;t really related. Tree Sitter is a parser that you might <i>use</i> in an LSP server (I have done; worked decently).</div><br/></div></div><div id="41470004" class="c"><input type="checkbox" id="c-41470004" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#41469135">parent</a><span>|</span><a href="#41469516">prev</a><span>|</span><a href="#41470423">next</a><span>|</span><label class="collapse" for="c-41470004">[-]</label><label class="expand" for="c-41470004">[1 more]</label></div><br/><div class="children"><div class="content">Apples to Oranges</div><br/></div></div></div></div><div id="41470423" class="c"><input type="checkbox" id="c-41470423" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#41469135">prev</a><span>|</span><a href="#41469596">next</a><span>|</span><label class="collapse" for="c-41470423">[-]</label><label class="expand" for="c-41470423">[1 more]</label></div><br/><div class="children"><div class="content">Not a LSP developer, but spitballing that perhaps you could address causality by tagging document updates&#x2F;versions with numbers and messages&#x2F;replies include the version of the document they correspond to.</div><br/></div></div><div id="41469596" class="c"><input type="checkbox" id="c-41469596" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41470423">prev</a><span>|</span><a href="#41440715">next</a><span>|</span><label class="collapse" for="c-41469596">[-]</label><label class="expand" for="c-41469596">[18 more]</label></div><br/><div class="children"><div class="content">LSP is pretty ok. Better than the before times I suppose. Although C++ has long had good IDE support so it hasn&#x27;t affected me too much.<p>I have a maybe wrong and bad opinion that LSP is actually at the wrong level. Right now every language needs to implement a from scratch implementation of their LSP server. These implementations are HUGE and take YEARS to develop. rust-analyzer is over 365,000 lines of code. And every language has their own massive, independent implementation.<p>When it comes to debugging all native language support common debug symbol formats. PDB for Windows and DWARF for Nixy things. Any compiled language that uses LLVM gets debug symbols and rich debugging &quot;for free&quot;.<p>I think there should be a common Intellisense Database file format for providing LSP or LSP-like capabilities. Ok sure there will still be per-language work to be done to implement the IDB format. But you&#x27;d get like 95% of the implementation for free for any LLVM language. And generating a common IDB format should be a lot simpler than implementing a kajillion LSP protocols.<p>My dream world has a support file that contains: full debug symbols, full source code, and full intellisense data. It should be trivial to debug old binaries with full debugging, source, and intellisense. This world could exist and is within reach!</div><br/><div id="41470482" class="c"><input type="checkbox" id="c-41470482" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41469596">parent</a><span>|</span><a href="#41471682">next</a><span>|</span><label class="collapse" for="c-41470482">[-]</label><label class="expand" for="c-41470482">[2 more]</label></div><br/><div class="children"><div class="content">1. I use zero languages that use either PDB or DWARF that are not named &quot;C&quot;.<p>2. You are either overestimating the level of detail available in PDB&#x2F;DWARF or underestimating the massive amount of language-specific work needed for even basic features (e.g. methods, which lack any cross-language ABI) given just what PDB&#x2F;DWARF give you.<p>3. What LSP provides and what PDB&#x2F;DWARF offer are only very loosely related.  Consider the case of writing function1, then (without compiling) writing function2 that calls function1.  It is typical for an LSP to offer completion and argument information when writing out the call for function1.  That&#x27;s not something you get &quot;for free&quot; with PDB&#x2F;DWARF.</div><br/><div id="41470583" class="c"><input type="checkbox" id="c-41470583" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41470482">parent</a><span>|</span><a href="#41471682">next</a><span>|</span><label class="collapse" for="c-41470583">[-]</label><label class="expand" for="c-41470583">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You are either overestimating the level of detail available in PDB&#x2F;DWARF<p>Uhhh. I didn’t say PDB&#x2F;DWARF already have the necessary information. In fact I even proposed a new file format! I suggest you re-read what I said.<p>&gt; Consider the case of writing function1, then (without compiling) writing function2 that calls function1. It is typical for an LSP to offer completion and argument information when writing out the call for function1. That&#x27;s not something you get &quot;for free&quot; with PDB&#x2F;DWARF.<p>What do you think LSP servers do in the background? They’re effectively compilers that are CONSTANTLY compiling the code.<p>Amusingly rust-analyzer takes longer to bootstrap than a full and complete clean and build. Maybe it’s not as parallel, I’m not sure.</div><br/></div></div></div></div><div id="41471682" class="c"><input type="checkbox" id="c-41471682" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41469596">parent</a><span>|</span><a href="#41470482">prev</a><span>|</span><a href="#41470022">next</a><span>|</span><label class="collapse" for="c-41471682">[-]</label><label class="expand" for="c-41471682">[3 more]</label></div><br/><div class="children"><div class="content">Rust-analýzer is an example of what not to do, which is reimplementing a compiler frontend. Ideálly it should be the samé as the &quot;real&quot; compiler is using. Of course this has it&#x27;s own problems, which the Haskell LSP this post is about, shows. As compilers not written for being used &quot;interactively&quot;.<p>&gt; Any compiled language that uses LLVM gets debug symbols and rich debugging &quot;for free&quot;.<p>That doesn&#x27;t hold for C++ and much less for any language even &quot;less C&quot; than C++. Like languages using a GC, e.g. Roc <a href="https:&#x2F;&#x2F;www.roc-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.roc-lang.org&#x2F;</a></div><br/><div id="41472419" class="c"><input type="checkbox" id="c-41472419" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41471682">parent</a><span>|</span><a href="#41470022">next</a><span>|</span><label class="collapse" for="c-41472419">[-]</label><label class="expand" for="c-41472419">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That doesn&#x27;t hold for C++<p>What do you mean? Why not? Clang PDBs for C++ work great. A GC isn’t particular disruptive to debug symbols afaik.</div><br/><div id="41472581" class="c"><input type="checkbox" id="c-41472581" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41472419">parent</a><span>|</span><a href="#41470022">next</a><span>|</span><label class="collapse" for="c-41472581">[-]</label><label class="expand" for="c-41472581">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What do you mean? Why not?<p>You need support for each language in the debugger, as symbols do not contain semantics. As users we for example know that `foo::bar` and `foo::baz` are methods of the same class `foo`, the debugger doesn&#x27;t.<p>The problem with GCs is that pointers must contain some additional information (like an additional bit for mark and sweep), they are not &quot;just&quot; pointing to some memory. Without &quot;knowing&quot; that, the debugger cannot follow the pointer to its target.</div><br/></div></div></div></div></div></div><div id="41470022" class="c"><input type="checkbox" id="c-41470022" checked=""/><div class="controls bullet"><span class="by">PoignardAzur</span><span>|</span><a href="#41469596">parent</a><span>|</span><a href="#41471682">prev</a><span>|</span><a href="#41469884">next</a><span>|</span><label class="collapse" for="c-41470022">[-]</label><label class="expand" for="c-41470022">[10 more]</label></div><br/><div class="children"><div class="content">&gt; <i>rust-analyzer is over 365,000 lines of code.</i><p>That has nothing to do with LSP.<p>Rust Analyzer is similar in scope to a second implementation of the Rust compiler.</div><br/><div id="41470107" class="c"><input type="checkbox" id="c-41470107" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41470022">parent</a><span>|</span><a href="#41469884">next</a><span>|</span><label class="collapse" for="c-41470107">[-]</label><label class="expand" for="c-41470107">[9 more]</label></div><br/><div class="children"><div class="content">&gt; similar in scope to a second implementation of the Rust compiler.<p>I know. That’s really bad!</div><br/><div id="41470370" class="c"><input type="checkbox" id="c-41470370" checked=""/><div class="controls bullet"><span class="by">nobodywasishere</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41470107">parent</a><span>|</span><a href="#41469884">next</a><span>|</span><label class="collapse" for="c-41470370">[-]</label><label class="expand" for="c-41470370">[8 more]</label></div><br/><div class="children"><div class="content">I disagree. A compiler for batch building programs and a compiler for providing as much semantic information about incomplete&#x2F;incorrect&#x2F;constantly changing programs are completely different tasks that require completely different architectures and design considerations.</div><br/><div id="41471813" class="c"><input type="checkbox" id="c-41471813" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41470370">parent</a><span>|</span><a href="#41472330">next</a><span>|</span><label class="collapse" for="c-41471813">[-]</label><label class="expand" for="c-41471813">[1 more]</label></div><br/><div class="children"><div class="content">No. Actually &quot;interactive&quot; frontends in batch compilation mode generally have better error messages in this mode too. Yes, it may make the batch compilation (the frontend part) sligthly slower, but won&#x27;t turn Go into Rust (or Haskell or C++).<p>And there always is the possibility to stop in batch mode when the first error occured.</div><br/></div></div><div id="41472330" class="c"><input type="checkbox" id="c-41472330" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41470370">parent</a><span>|</span><a href="#41471813">prev</a><span>|</span><a href="#41470473">next</a><span>|</span><label class="collapse" for="c-41472330">[-]</label><label class="expand" for="c-41472330">[1 more]</label></div><br/><div class="children"><div class="content">Nonsense. Given that the end user of both is a human, you want the compiler that builds program to know as much about semantics to aid in fixing buggy&#x2F;incomplete&#x2F;incorrect programs.</div><br/></div></div><div id="41470473" class="c"><input type="checkbox" id="c-41470473" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41470370">parent</a><span>|</span><a href="#41472330">prev</a><span>|</span><a href="#41469884">next</a><span>|</span><label class="collapse" for="c-41470473">[-]</label><label class="expand" for="c-41470473">[5 more]</label></div><br/><div class="children"><div class="content">I don’t think that’s true at all.<p>First of all, a compiler for a 100% correct program definitely has all the necessary information for robust intellisense. They don’t currently save all the data, but it should exist.<p>So the only real question is whether they can support the 0.01% of files that incomplete and changing?<p>I’ll readily admit I am not a compiler expert. So I’m open to being wrong. But I certainly don’t see why not. Compilers already need to support incorrect code so they can print helpful error messages. Including different errors spread through out a single file.<p>It may be that current compilers are badly architected for incremental intellisense generation. But I don’t think that’s an intrinsic difference. I see no reason that the tasks require “completely different architectures”.</div><br/><div id="41471641" class="c"><input type="checkbox" id="c-41471641" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41470473">parent</a><span>|</span><a href="#41469884">next</a><span>|</span><label class="collapse" for="c-41471641">[-]</label><label class="expand" for="c-41471641">[4 more]</label></div><br/><div class="children"><div class="content">&gt; First of all, a compiler for a 100% correct program definitely has all the necessary information for robust intellisense.<p>It doesn&#x27;t. Intellisense is supposed to work on 100% <i>incorrect</i> and incomplete programs. To the point that it should work in <i>syntactically invalid</i> code.</div><br/><div id="41471691" class="c"><input type="checkbox" id="c-41471691" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41471641">parent</a><span>|</span><a href="#41469884">next</a><span>|</span><label class="collapse" for="c-41471691">[-]</label><label class="expand" for="c-41471691">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Intellisense is supposed to work on 100% incorrect and incomplete programs.<p>Correct. I literally discussed this scenario in my comment!<p>If the program compiles successfully then the compiler has all the information it needs for intellisense. If the program does NOT fully compile then the compiler may or may not be able to emit sufficient intellisense information. I assert that compilers should be able to support this common scenario. It is not particularly different from needing to support good, clear error messages in the face of syntactically invalid code.</div><br/><div id="41472512" class="c"><input type="checkbox" id="c-41472512" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41471691">parent</a><span>|</span><a href="#41469884">next</a><span>|</span><label class="collapse" for="c-41472512">[-]</label><label class="expand" for="c-41472512">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I assert that compilers should be able to support this common scenario<p>Not necessarily. These are two <i>very</i> different tasks quite at odds with each other</div><br/><div id="41472565" class="c"><input type="checkbox" id="c-41472565" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41469596">root</a><span>|</span><a href="#41472512">parent</a><span>|</span><a href="#41469884">next</a><span>|</span><label class="collapse" for="c-41472565">[-]</label><label class="expand" for="c-41472565">[1 more]</label></div><br/><div class="children"><div class="content">&gt; These are two very different tasks quite at odds with each other<p>Are they? I feel like intellisense is largely a subset of what a compiler already has to do.<p>I’d say the key features of an LSP are knowing the exact type of all symbols, goto definition, and auto-complete. The compiler has all of that information.<p>Compilers produce debug symbols which include some of the information you need for intellisense. I wrote a PDB-based LSP server that can goto definition on any function call for any language. Worked surprisingly well.<p>If you wanted to argue that intellisense is a subset of compiling and it can be done faster and more efficiently I could buy that argument. But if you’re going to declare the tasks are at odds with one another I’d love to hear specific details!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41469884" class="c"><input type="checkbox" id="c-41469884" checked=""/><div class="controls bullet"><span class="by">nobodywasishere</span><span>|</span><a href="#41469596">parent</a><span>|</span><a href="#41470022">prev</a><span>|</span><a href="#41469957">next</a><span>|</span><label class="collapse" for="c-41469884">[-]</label><label class="expand" for="c-41469884">[1 more]</label></div><br/><div class="children"><div class="content">That sounds similar to LSIF <a href="https:&#x2F;&#x2F;microsoft.github.io&#x2F;language-server-protocol&#x2F;specifications&#x2F;lsif&#x2F;0.6.0&#x2F;specification&#x2F;" rel="nofollow">https:&#x2F;&#x2F;microsoft.github.io&#x2F;language-server-protocol&#x2F;specifi...</a></div><br/></div></div><div id="41469957" class="c"><input type="checkbox" id="c-41469957" checked=""/><div class="controls bullet"><span class="by">Zababa</span><span>|</span><a href="#41469596">parent</a><span>|</span><a href="#41469884">prev</a><span>|</span><a href="#41440715">next</a><span>|</span><label class="collapse" for="c-41469957">[-]</label><label class="expand" for="c-41469957">[1 more]</label></div><br/><div class="children"><div class="content">&quot;any LLVM language&quot; is a lot but also not that much. You&#x27;re missing Python, JS, Go, Ruby, etc.</div><br/></div></div></div></div></div></div></div></div></div></body></html>