<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727859676626" as="style"/><link rel="stylesheet" href="styles.css?v=1727859676626"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.pixelstech.net/article/1727412048-Why-TCP-needs-3-handshakes">Why TCP needs 3 handshakes</a> <span class="domain">(<a href="https://www.pixelstech.net">www.pixelstech.net</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>27 comments</span></div><br/><div><div id="41717410" class="c"><input type="checkbox" id="c-41717410" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41717553">next</a><span>|</span><label class="collapse" for="c-41717410">[-]</label><label class="expand" for="c-41717410">[12 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always considered it one handshake, with 3 packets, which are for some reason then called &quot;3 way&quot;. But it&#x27;s one 3-way-handshake.</div><br/><div id="41717707" class="c"><input type="checkbox" id="c-41717707" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#41717410">parent</a><span>|</span><a href="#41717744">next</a><span>|</span><label class="collapse" for="c-41717707">[-]</label><label class="expand" for="c-41717707">[3 more]</label></div><br/><div class="children"><div class="content">It is only one handshake, with 3 packets.<p>The author made a mistake in the title, but the content is mostly correct (fails at &quot;First Handshake&quot;, &quot;Second Handshake&quot; and &quot;Third Handshake&quot;).<p>He should call them stages, phases or something like that.</div><br/><div id="41718009" class="c"><input type="checkbox" id="c-41718009" checked=""/><div class="controls bullet"><span class="by">AStonesThrow</span><span>|</span><a href="#41717410">root</a><span>|</span><a href="#41717707">parent</a><span>|</span><a href="#41717744">next</a><span>|</span><label class="collapse" for="c-41718009">[-]</label><label class="expand" for="c-41718009">[2 more]</label></div><br/><div class="children"><div class="content">To be really specific, they are not &quot;packets&quot; but at the TCP protocol level, they are &quot;segments&quot;<p>TFA appears to use both terms sort of interchangeably, which is uncool when describing a formalized protocol standard!<p>Segments are encapsulated in IP datagrams, or packets, which are, in turn, encapsulated in other PDU types, such as Ethernet frames.</div><br/><div id="41718212" class="c"><input type="checkbox" id="c-41718212" checked=""/><div class="controls bullet"><span class="by">Ekaros</span><span>|</span><a href="#41717410">root</a><span>|</span><a href="#41718009">parent</a><span>|</span><a href="#41717744">next</a><span>|</span><label class="collapse" for="c-41718212">[-]</label><label class="expand" for="c-41718212">[1 more]</label></div><br/><div class="children"><div class="content">And one could ask are segments without well data segment a segments? As mostly 2 first PDUs in exchange do not contain data...</div><br/></div></div></div></div></div></div><div id="41717744" class="c"><input type="checkbox" id="c-41717744" checked=""/><div class="controls bullet"><span class="by">ddfs123</span><span>|</span><a href="#41717410">parent</a><span>|</span><a href="#41717707">prev</a><span>|</span><a href="#41718380">next</a><span>|</span><label class="collapse" for="c-41717744">[-]</label><label class="expand" for="c-41717744">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve consider it to be 4 handshakes but the middle 2 are merged.</div><br/><div id="41718015" class="c"><input type="checkbox" id="c-41718015" checked=""/><div class="controls bullet"><span class="by">ay</span><span>|</span><a href="#41717410">root</a><span>|</span><a href="#41717744">parent</a><span>|</span><a href="#41718380">next</a><span>|</span><label class="collapse" for="c-41718015">[-]</label><label class="expand" for="c-41718015">[2 more]</label></div><br/><div class="children"><div class="content">There is a scenario called “simultaneous open”, which has 4 packets handshake and is a wonderful source of corner cases and debugging. Mostly doesn’t happen these days, but is possible by standard and is explicitly described.</div><br/><div id="41718517" class="c"><input type="checkbox" id="c-41718517" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#41717410">root</a><span>|</span><a href="#41718015">parent</a><span>|</span><a href="#41718380">next</a><span>|</span><label class="collapse" for="c-41718517">[-]</label><label class="expand" for="c-41718517">[1 more]</label></div><br/><div class="children"><div class="content">It has been used for NAT traversal when both parties are behind NAT, but sadly it doesn&#x27;t work with all routers.</div><br/></div></div></div></div></div></div><div id="41718380" class="c"><input type="checkbox" id="c-41718380" checked=""/><div class="controls bullet"><span class="by">Uptrenda</span><span>|</span><a href="#41717410">parent</a><span>|</span><a href="#41717744">prev</a><span>|</span><a href="#41717475">next</a><span>|</span><label class="collapse" for="c-41718380">[-]</label><label class="expand" for="c-41718380">[2 more]</label></div><br/><div class="children"><div class="content">Its just 1 packet: an RST with a data field containing a swear word.</div><br/><div id="41718403" class="c"><input type="checkbox" id="c-41718403" checked=""/><div class="controls bullet"><span class="by">evilc00kie</span><span>|</span><a href="#41717410">root</a><span>|</span><a href="#41718380">parent</a><span>|</span><a href="#41717475">next</a><span>|</span><label class="collapse" for="c-41718403">[-]</label><label class="expand" for="c-41718403">[1 more]</label></div><br/><div class="children"><div class="content">Jokes like that make me realize I understand the matter more than I want to :&#x27;D</div><br/></div></div></div></div><div id="41717475" class="c"><input type="checkbox" id="c-41717475" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41717410">parent</a><span>|</span><a href="#41718380">prev</a><span>|</span><a href="#41717553">next</a><span>|</span><label class="collapse" for="c-41717475">[-]</label><label class="expand" for="c-41717475">[3 more]</label></div><br/><div class="children"><div class="content">&quot;3 shake handshake&quot;? :)</div><br/><div id="41718259" class="c"><input type="checkbox" id="c-41718259" checked=""/><div class="controls bullet"><span class="by">nasretdinov</span><span>|</span><a href="#41717410">root</a><span>|</span><a href="#41717475">parent</a><span>|</span><a href="#41717482">next</a><span>|</span><label class="collapse" for="c-41718259">[-]</label><label class="expand" for="c-41718259">[1 more]</label></div><br/><div class="children"><div class="content">3 hands handshake, nothing unusual here</div><br/></div></div></div></div></div></div><div id="41717553" class="c"><input type="checkbox" id="c-41717553" checked=""/><div class="controls bullet"><span class="by">krackers</span><span>|</span><a href="#41717410">prev</a><span>|</span><a href="#41717632">next</a><span>|</span><label class="collapse" for="c-41717553">[-]</label><label class="expand" for="c-41717553">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s this interesting comment by &quot;John Day&quot; on that page, does anyone have more context&#x2F;detail?</div><br/><div id="41718046" class="c"><input type="checkbox" id="c-41718046" checked=""/><div class="controls bullet"><span class="by">despair3435</span><span>|</span><a href="#41717553">parent</a><span>|</span><a href="#41717781">next</a><span>|</span><label class="collapse" for="c-41718046">[-]</label><label class="expand" for="c-41718046">[2 more]</label></div><br/><div class="children"><div class="content">You can find the original paper by Watson online which explains it in more detail. The 3 way handshake is in fact not necessary. I believe the delta-t protocol was one of the available protocols in OSI as well. TCP&#x2F;IP being the standard now is not due to the fact that it was technically the best. In fact, there are multiple shortcomings.<p>The delta-t protocol is also used in RINA, which was invented by John Day. It is also used in Ouroboros (<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2001.09707" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2001.09707</a>), and I can confirm it works. ;)</div><br/><div id="41718321" class="c"><input type="checkbox" id="c-41718321" checked=""/><div class="controls bullet"><span class="by">tonyg</span><span>|</span><a href="#41717553">root</a><span>|</span><a href="#41718046">parent</a><span>|</span><a href="#41717781">next</a><span>|</span><label class="collapse" for="c-41718321">[-]</label><label class="expand" for="c-41718321">[1 more]</label></div><br/><div class="children"><div class="content">The actual delta-t protocol spec has historically been quite hard to find, but is freely available from here: <a href="https:&#x2F;&#x2F;www.osti.gov&#x2F;biblio&#x2F;5542785" rel="nofollow">https:&#x2F;&#x2F;www.osti.gov&#x2F;biblio&#x2F;5542785</a><p>Also related and of interest in this connexion: CurveCP and its handshake, <a href="https:&#x2F;&#x2F;curvecp.org&#x2F;packets.html" rel="nofollow">https:&#x2F;&#x2F;curvecp.org&#x2F;packets.html</a></div><br/></div></div></div></div><div id="41717781" class="c"><input type="checkbox" id="c-41717781" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#41717553">parent</a><span>|</span><a href="#41718046">prev</a><span>|</span><a href="#41717632">next</a><span>|</span><label class="collapse" for="c-41717781">[-]</label><label class="expand" for="c-41717781">[1 more]</label></div><br/><div class="children"><div class="content">There were several competing standards on the early networks, and almost every ambitious commercial entity wanted to embed their licensed IP into the webs core transport layer or lower on the OSI stack.<p>We take for granted the inter-connectivity of most modern equipment, but to this day companies still try to create synthetic technology monopolies to cash-in.  i.e. to sustain a tenuous service commodity out of something that has essentially been free since the mid 1990s.<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;</a><p>Philosophically it doesn&#x27;t matter TCP is imperfect, but rather that the inter-connectivity is compatible with the inertia of the installed infrastructure.<p>One can indeed optimistically ignore the TCP connection drop and syn part of standards to tunnel&#x2F;reverse-proxy though certain censorship firewalls... but it still does not make it safe for the people that live under such regimes.<p>Does this make it more or less clear? =3</div><br/></div></div></div></div><div id="41717632" class="c"><input type="checkbox" id="c-41717632" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41717553">prev</a><span>|</span><a href="#41717666">next</a><span>|</span><label class="collapse" for="c-41717632">[-]</label><label class="expand" for="c-41717632">[5 more]</label></div><br/><div class="children"><div class="content">TL;DR: &quot;Because if TCP handshake were 2-way only, the receiver couldn&#x27;t confirm if it could send packets successfully or sender could receive them&quot;.<p>And that sounds bogus to me. Connection initiation isn&#x27;t about testing if packets can reach or not. It&#x27;s about acknowledgement, building a two peer consensus about how to handle upcoming packets from a peer, not reliability checks. In that sense, I don&#x27;t even think the third step is necessary, but apparently, it&#x27;s needed to handle the case of both endpoints going into a timeout loop, this article explains it perfectly: <a href="https:&#x2F;&#x2F;www.baeldung.com&#x2F;cs&#x2F;handshakes" rel="nofollow">https:&#x2F;&#x2F;www.baeldung.com&#x2F;cs&#x2F;handshakes</a></div><br/><div id="41717737" class="c"><input type="checkbox" id="c-41717737" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41717632">parent</a><span>|</span><a href="#41718168">next</a><span>|</span><label class="collapse" for="c-41717737">[-]</label><label class="expand" for="c-41717737">[2 more]</label></div><br/><div class="children"><div class="content">You can only reach consensus if the peers can each receive packets that the other sent.<p>So reaching consensus and testing for reachability in both directions are the same.<p>In a client&#x2F;server scenario, the client knows the connection is good when it receives the SYN+ACK, but the server doesn&#x27;t know until it receives the resulting ACK. So the third packet is necessary to communicate consensus to the server; it doesn&#x27;t need to be a pure ACK though, it can have data, if the client&#x27;s stack makes it possible to queue outgoing data before the SYN+ACK is received.</div><br/><div id="41718041" class="c"><input type="checkbox" id="c-41718041" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41717632">root</a><span>|</span><a href="#41717737">parent</a><span>|</span><a href="#41718168">next</a><span>|</span><label class="collapse" for="c-41718041">[-]</label><label class="expand" for="c-41718041">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can only reach consensus if the peers can each receive packets that the other sent. So reaching consensus and testing for reachability in both directions are the same.<p>No, that&#x27;s not the intent of a handshake. Assume a hypothetical Internet where every node has guaranteed connectivity to every other node that never fails. Do we suddenly lose the need to do a 3-way handshake? No. It&#x27;s not about testing connectivity, that&#x27;s semantically wrong. And what&#x27;s the meaning of testing connectivity for a connection of an arbitrary length and with a quality of unknown degree throughout? It doesn&#x27;t make any sense.<p>There is no &quot;knowing the connection is good&quot;, there is a process of building up consensus. The peers are only interested in an answer to this question: &quot;Does the other party assume a connection?&quot;.<p>If we knew the answer to that question beforehand, we wouldn&#x27;t need a handshake at all. Reachability, transmissibility are all irrelevant. And, UDP actually works like that. Both endpoints assume willingness to connect. That&#x27;s why you don&#x27;t need a handshake with UDP.<p>TCP-FO worked liked that too, removing the need for a TCP handshake completely, because it could persist the consensus information.</div><br/></div></div></div></div><div id="41718168" class="c"><input type="checkbox" id="c-41718168" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#41717632">parent</a><span>|</span><a href="#41717737">prev</a><span>|</span><a href="#41717666">next</a><span>|</span><label class="collapse" for="c-41718168">[-]</label><label class="expand" for="c-41718168">[2 more]</label></div><br/><div class="children"><div class="content">without a 3-way handshake, wouldn&#x27;t it be easier to do spoofing?  or a man-in-the-middle attack?<p>I think now there are ways to do the 3-way handshake in hardware at hardware speeds, and only involve software if the connection has been vetted.  This can protect against Denial-Of-Service attacks.</div><br/><div id="41718266" class="c"><input type="checkbox" id="c-41718266" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41717632">root</a><span>|</span><a href="#41718168">parent</a><span>|</span><a href="#41717666">next</a><span>|</span><label class="collapse" for="c-41718266">[-]</label><label class="expand" for="c-41718266">[1 more]</label></div><br/><div class="children"><div class="content">No and no. IP spoofing was already trivial with 3-way handshake. That&#x27;s why random TCP sequence numbers were introduced. It&#x27;s now harder, but for some scenarios, SYN cookies might also be needed.</div><br/></div></div></div></div></div></div><div id="41717666" class="c"><input type="checkbox" id="c-41717666" checked=""/><div class="controls bullet"><span class="by">teleforce</span><span>|</span><a href="#41717632">prev</a><span>|</span><a href="#41717739">next</a><span>|</span><label class="collapse" for="c-41717666">[-]</label><label class="expand" for="c-41717666">[4 more]</label></div><br/><div class="children"><div class="content">I think the more important question is why TCP only using positive acknowledgement (ACK) but not negative acknowledgement (NACK)?</div><br/><div id="41717692" class="c"><input type="checkbox" id="c-41717692" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41717666">parent</a><span>|</span><a href="#41717772">next</a><span>|</span><label class="collapse" for="c-41717692">[-]</label><label class="expand" for="c-41717692">[1 more]</label></div><br/><div class="children"><div class="content">Selective acknowledgement (SACK) effectively indicates which sequence numbers are missing when there&#x27;s packet loss. It&#x27;s optional, but afaik, used by nearly everything on today&#x27;s internet.</div><br/></div></div><div id="41717772" class="c"><input type="checkbox" id="c-41717772" checked=""/><div class="controls bullet"><span class="by">keeperofdakeys</span><span>|</span><a href="#41717666">parent</a><span>|</span><a href="#41717692">prev</a><span>|</span><a href="#41717739">next</a><span>|</span><label class="collapse" for="c-41717772">[-]</label><label class="expand" for="c-41717772">[2 more]</label></div><br/><div class="children"><div class="content">What would a NACK add? TCP can already send an ACK for the last successful sequence number, telling the sender to retransmit packets after that sequence number. Due to latency and large window sizes, it&#x27;s far more efficient to just resend all the data than NACK individual packets.</div><br/><div id="41718224" class="c"><input type="checkbox" id="c-41718224" checked=""/><div class="controls bullet"><span class="by">retSava</span><span>|</span><a href="#41717666">root</a><span>|</span><a href="#41717772">parent</a><span>|</span><a href="#41717739">next</a><span>|</span><label class="collapse" for="c-41718224">[-]</label><label class="expand" for="c-41718224">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps GP considers a NACK more semantically easier to understand on an intuitive level, instead of the implicit NACK with &quot;I know you sent 8, but we&#x27;re really at 4 so resume from that&quot;. But I do agree that it&#x27;s more efficient for the remote host to just immediately establish &quot;4 was the last point we are ok at&quot;.</div><br/></div></div></div></div></div></div><div id="41717739" class="c"><input type="checkbox" id="c-41717739" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#41717666">prev</a><span>|</span><label class="collapse" for="c-41717739">[-]</label><label class="expand" for="c-41717739">[1 more]</label></div><br/><div class="children"><div class="content">1RTT FTW!</div><br/></div></div></div></div></div></div></div></body></html>