<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690621243288" as="style"/><link rel="stylesheet" href="styles.css?v=1690621243288"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474">Intent to approve PEP 703: making the GIL optional</a> <span class="domain">(<a href="https://discuss.python.org">discuss.python.org</a>)</span></div><div class="subtext"><span>pablogsal</span> | <span>302 comments</span></div><br/><div><div id="36915232" class="c"><input type="checkbox" id="c-36915232" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36917722">next</a><span>|</span><label class="collapse" for="c-36915232">[-]</label><label class="expand" for="c-36915232">[97 more]</label></div><br/><div class="children"><div class="content">Lots of C library code for decades carried man page warnings it was unstable for use in async, re-entrant and recursive contexts. We learned how to cope and incrementally re-entrant safe versions deployed without too much API instability. Maybe time has healed wounds and caused me memory loss of the pain of discovery you&#x27;d tripped over them.<p>String parsing which tokenised in-place. DNS calls which used static buffers. Things which exploited Vax specific stack behaviour.<p>I think the GIL has been a blessing and a curse.</div><br/><div id="36915542" class="c"><input type="checkbox" id="c-36915542" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#36915232">parent</a><span>|</span><a href="#36915561">next</a><span>|</span><label class="collapse" for="c-36915542">[-]</label><label class="expand" for="c-36915542">[22 more]</label></div><br/><div class="children"><div class="content">I remember scouring those C runtime docs, for every non-reentrant function.  It might be what got me in the habit of checking docs when using some API that I know moderately well, just in case there&#x27;s some important detail I missed before, or something had changed.<p>Around that time, doing cross-platform C++, I got an early look at Java, with concurrency built in from the start, along with GC and various other nice features that were easier to use than C++, and I &quot;knew&quot; it was going to be huge.  (But who knew that the MIS people would take over Java, when it seemed clearly targeted at non-MIS programmers, and now MIS people are stuck with the C++ syntax and verbosity, after coming from 4GLs, etc.)<p>Then mainstream programmers picked up Python, which, IIRC, originally was an embeddable extension language, which was why it was simple.  And for which the GIL made more sense.</div><br/><div id="36917869" class="c"><input type="checkbox" id="c-36917869" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915542">parent</a><span>|</span><a href="#36918053">next</a><span>|</span><label class="collapse" for="c-36917869">[-]</label><label class="expand" for="c-36917869">[2 more]</label></div><br/><div class="children"><div class="content">&gt; originally was an embeddable extension language<p>Python was originally a teaching language, to replace BASIC and Pascal for kids and beginners.<p>(Yes, there once was a time when people took teaching programming seriously.)</div><br/><div id="36918005" class="c"><input type="checkbox" id="c-36918005" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917869">parent</a><span>|</span><a href="#36918053">next</a><span>|</span><label class="collapse" for="c-36918005">[-]</label><label class="expand" for="c-36918005">[1 more]</label></div><br/><div class="children"><div class="content">Quoting from [1], section &quot;The ABC Project&quot;<p>&gt; The letter “B” was chosen because it is the first letter of the word “beginner” and because the project was meant to become a language for teaching programming to absolute beginners.<p>[1] <a href="https:&#x2F;&#x2F;inference-review.com&#x2F;article&#x2F;the-origins-of-python" rel="nofollow noreferrer">https:&#x2F;&#x2F;inference-review.com&#x2F;article&#x2F;the-origins-of-python</a></div><br/></div></div></div></div><div id="36918053" class="c"><input type="checkbox" id="c-36918053" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915542">parent</a><span>|</span><a href="#36917869">prev</a><span>|</span><a href="#36917305">next</a><span>|</span><label class="collapse" for="c-36918053">[-]</label><label class="expand" for="c-36918053">[3 more]</label></div><br/><div class="children"><div class="content">That Java had concurrency built in from the start is a blessing mostly, but also a bit of a curse. Most of the Java ecosystem is still in the mindset that threads are cheap and firing up a couple more cannot hurt. So we end up with apps that run thousands of threads and this disease is hard to contain.</div><br/><div id="36918262" class="c"><input type="checkbox" id="c-36918262" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36918053">parent</a><span>|</span><a href="#36918215">next</a><span>|</span><label class="collapse" for="c-36918262">[-]</label><label class="expand" for="c-36918262">[1 more]</label></div><br/><div class="children"><div class="content">Fortunately Virtual Threads have landed, so when the ecosystem finally comes around to adopt it, many things might become faster.</div><br/></div></div><div id="36918215" class="c"><input type="checkbox" id="c-36918215" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36918053">parent</a><span>|</span><a href="#36918262">prev</a><span>|</span><a href="#36917305">next</a><span>|</span><label class="collapse" for="c-36918215">[-]</label><label class="expand" for="c-36918215">[1 more]</label></div><br/><div class="children"><div class="content">Like not everyone toy app isn&#x27;t going to be the next FAANG, there are plenty of workloads where it hardly matters, while 30 years later it is still a mess in C and C++.<p>And between C++ and Rust coroutines, still not sure which one I like less.</div><br/></div></div></div></div><div id="36917305" class="c"><input type="checkbox" id="c-36917305" checked=""/><div class="controls bullet"><span class="by">cjfd</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915542">parent</a><span>|</span><a href="#36918053">prev</a><span>|</span><a href="#36916821">next</a><span>|</span><label class="collapse" for="c-36917305">[-]</label><label class="expand" for="c-36917305">[2 more]</label></div><br/><div class="children"><div class="content">What are &#x27;MIS people&#x27;?</div><br/><div id="36917386" class="c"><input type="checkbox" id="c-36917386" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917305">parent</a><span>|</span><a href="#36916821">next</a><span>|</span><label class="collapse" for="c-36917386">[-]</label><label class="expand" for="c-36917386">[1 more]</label></div><br/><div class="children"><div class="content">Management Information Systems, I think.</div><br/></div></div></div></div><div id="36916821" class="c"><input type="checkbox" id="c-36916821" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915542">parent</a><span>|</span><a href="#36917305">prev</a><span>|</span><a href="#36915809">next</a><span>|</span><label class="collapse" for="c-36916821">[-]</label><label class="expand" for="c-36916821">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I remember scouring those C runtime docs, for every non-reentrant function.<p>hint:<p><pre><code>  % cd &#x2F;usr&#x2F;include
  % ag --no-color &#x27;[^A-Z]_REENTRANT&#x27;</code></pre></div><br/></div></div><div id="36915809" class="c"><input type="checkbox" id="c-36915809" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915542">parent</a><span>|</span><a href="#36916821">prev</a><span>|</span><a href="#36915561">next</a><span>|</span><label class="collapse" for="c-36915809">[-]</label><label class="expand" for="c-36915809">[13 more]</label></div><br/><div class="children"><div class="content">&gt; I got an early look at Java, with concurrency built in from the start, [...] and I &quot;knew&quot; it was going to be huge.<p>And Java doesn&#x27;t even have good (conceptual) support for concurrency.  Compared with eg Erlang, Rust or even Haskell.<p>But Java was still better at it than C or C++ at the time.</div><br/><div id="36917103" class="c"><input type="checkbox" id="c-36917103" checked=""/><div class="controls bullet"><span class="by">pseudocomposer</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915809">parent</a><span>|</span><a href="#36917547">next</a><span>|</span><label class="collapse" for="c-36917103">[-]</label><label class="expand" for="c-36917103">[6 more]</label></div><br/><div class="children"><div class="content">I agree that Rust handles concurrency about as well as Java (in addition to its memory safety). But could you provide docs on Erlang or Haskell concurrent data structures that were better than Java’s, say, 10-20 years ago? Java’s support for concurrent data structures was pretty unprecedented in its heyday.</div><br/><div id="36917905" class="c"><input type="checkbox" id="c-36917905" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917103">parent</a><span>|</span><a href="#36917777">next</a><span>|</span><label class="collapse" for="c-36917905">[-]</label><label class="expand" for="c-36917905">[1 more]</label></div><br/><div class="children"><div class="content">Java still doesn&#x27;t provide persistent data structures out-of-the-box. IMHO these are <i>more</i> important than lock-free mutable data structures.<p>When one really does need shared mutable state, Haskell supports transactional updates to mutable state (STM), with optimistic locking and rollbacks. It&#x27;s awesome, but unfortunately just not practically possible in any language with rampant untracked side-effects.</div><br/></div></div><div id="36917777" class="c"><input type="checkbox" id="c-36917777" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917103">parent</a><span>|</span><a href="#36917905">prev</a><span>|</span><a href="#36917891">next</a><span>|</span><label class="collapse" for="c-36917777">[-]</label><label class="expand" for="c-36917777">[1 more]</label></div><br/><div class="children"><div class="content">The best example of this is probably the “Beautiful Concurrency” paper from Simon Peyton-Jones in 2007 <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;2016&#x2F;02&#x2F;beautiful.pdf?from=https:&#x2F;&#x2F;research.microsoft.com&#x2F;en-us&#x2F;um&#x2F;people&#x2F;simonpj&#x2F;Papers&#x2F;stm&#x2F;beautiful.pdf&amp;type=exact" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;...</a></div><br/></div></div><div id="36917891" class="c"><input type="checkbox" id="c-36917891" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917103">parent</a><span>|</span><a href="#36917777">prev</a><span>|</span><a href="#36917447">next</a><span>|</span><label class="collapse" for="c-36917891">[-]</label><label class="expand" for="c-36917891">[1 more]</label></div><br/><div class="children"><div class="content">Compared to those other languages, Java has no mechanism to enfore the use of concurrent data structures, it&#x27;s entirely up to the programmer to use them.</div><br/></div></div><div id="36917447" class="c"><input type="checkbox" id="c-36917447" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917103">parent</a><span>|</span><a href="#36917891">prev</a><span>|</span><a href="#36917547">next</a><span>|</span><label class="collapse" for="c-36917447">[-]</label><label class="expand" for="c-36917447">[2 more]</label></div><br/><div class="children"><div class="content">STM, 2006? <a href="https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;viewdoc&#x2F;download?doi=10.1.1.67.3686&amp;rep=rep1&amp;type=pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;viewdoc&#x2F;download?doi=10.1.1.67...</a><p>Still way after Java was released I guess</div><br/><div id="36917949" class="c"><input type="checkbox" id="c-36917949" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917447">parent</a><span>|</span><a href="#36917547">next</a><span>|</span><label class="collapse" for="c-36917949">[-]</label><label class="expand" for="c-36917949">[1 more]</label></div><br/><div class="children"><div class="content">Java didn&#x27;t initially ship with lock-free data structures, those came later thanks to Doug Lea.</div><br/></div></div></div></div></div></div><div id="36917547" class="c"><input type="checkbox" id="c-36917547" checked=""/><div class="controls bullet"><span class="by">almostnormal</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915809">parent</a><span>|</span><a href="#36917103">prev</a><span>|</span><a href="#36916468">next</a><span>|</span><label class="collapse" for="c-36917547">[-]</label><label class="expand" for="c-36917547">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But Java was still better at it than C or C++ at the time.<p>That&#x27;s not even a contest. Java was released in 1995. At that time C did not have any kind of support for concurrency, all solutions were platform dependend and not part of the language.</div><br/></div></div><div id="36916468" class="c"><input type="checkbox" id="c-36916468" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915809">parent</a><span>|</span><a href="#36917547">prev</a><span>|</span><a href="#36915561">next</a><span>|</span><label class="collapse" for="c-36916468">[-]</label><label class="expand" for="c-36916468">[5 more]</label></div><br/><div class="children"><div class="content">In your opinion.
Some of us believe the exact opposite.</div><br/><div id="36916607" class="c"><input type="checkbox" id="c-36916607" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916468">parent</a><span>|</span><a href="#36916527">next</a><span>|</span><label class="collapse" for="c-36916607">[-]</label><label class="expand" for="c-36916607">[1 more]</label></div><br/><div class="children"><div class="content">By exact opposite you mean that when Java just came out (&#x27;I got an early look at Java, [...]&#x27;) had good concurrency support?<p>One can make a solid argument that modern Java is adequate.  But I don&#x27;t buy you believe that of early Java?</div><br/></div></div><div id="36916527" class="c"><input type="checkbox" id="c-36916527" checked=""/><div class="controls bullet"><span class="by">soulbadguy</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916468">parent</a><span>|</span><a href="#36916607">prev</a><span>|</span><a href="#36916946">next</a><span>|</span><label class="collapse" for="c-36916527">[-]</label><label class="expand" for="c-36916527">[2 more]</label></div><br/><div class="children"><div class="content">There are a lot of good things about java (and the jvm by some extend), but good concurency is not one of them.</div><br/><div id="36917821" class="c"><input type="checkbox" id="c-36917821" checked=""/><div class="controls bullet"><span class="by">bitcharmer</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916527">parent</a><span>|</span><a href="#36916946">next</a><span>|</span><label class="collapse" for="c-36917821">[-]</label><label class="expand" for="c-36917821">[1 more]</label></div><br/><div class="children"><div class="content">This is not true. JSR-133 was one of the first and most prominent implementation of memory model among general purpose languages. You don&#x27;t seem to know enough about the platform and it&#x27;s history to make definite statements like that, imo.</div><br/></div></div></div></div><div id="36916946" class="c"><input type="checkbox" id="c-36916946" checked=""/><div class="controls bullet"><span class="by">ungamedplayer</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916468">parent</a><span>|</span><a href="#36916527">prev</a><span>|</span><a href="#36915561">next</a><span>|</span><label class="collapse" for="c-36916946">[-]</label><label class="expand" for="c-36916946">[1 more]</label></div><br/><div class="children"><div class="content">Old mate isn&#x27;t alone.</div><br/></div></div></div></div></div></div></div></div><div id="36915561" class="c"><input type="checkbox" id="c-36915561" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36915232">parent</a><span>|</span><a href="#36915542">prev</a><span>|</span><a href="#36918006">next</a><span>|</span><label class="collapse" for="c-36915561">[-]</label><label class="expand" for="c-36915561">[66 more]</label></div><br/><div class="children"><div class="content">No-GIL mode is optional, and libraries will be marked &quot;no-GIL compatible&quot; and the ecosystem will gradually support more and more of these.<p>No one&#x27;s flipping a switch and breaking mountains of sketchy C.</div><br/><div id="36915597" class="c"><input type="checkbox" id="c-36915597" checked=""/><div class="controls bullet"><span class="by">Steltek</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915561">parent</a><span>|</span><a href="#36915829">next</a><span>|</span><label class="collapse" for="c-36915597">[-]</label><label class="expand" for="c-36915597">[13 more]</label></div><br/><div class="children"><div class="content">Well someone has to say it so I might as well: Is this going to be another Python 2 -&gt; 3 cat herding exercise again?<p>I suppose the need to run your app in &quot;no-GIL&quot; mode is less than needing to jump from 2.7 to 3.</div><br/><div id="36915667" class="c"><input type="checkbox" id="c-36915667" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915597">parent</a><span>|</span><a href="#36917432">next</a><span>|</span><label class="collapse" for="c-36915667">[-]</label><label class="expand" for="c-36915667">[3 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t dive deep on this, but I assume that GIL mode can still run anything, including no-GIL code (it is one of their promises, at least). So, unlike 2-&gt;3, there is forwards-compatibility.<p>It also seems like the latter isn&#x27;t meant as a replacement (for the moment), but rather as an option.</div><br/><div id="36915955" class="c"><input type="checkbox" id="c-36915955" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915667">parent</a><span>|</span><a href="#36917432">next</a><span>|</span><label class="collapse" for="c-36915955">[-]</label><label class="expand" for="c-36915955">[2 more]</label></div><br/><div class="children"><div class="content">Presumably C extensions will have a different API name&#x2F;ABI to prevent accidentally calling into GIL code when in non-GIL mode and vice&#x2F;versa so that&#x27;s going to complicate the compatibility story.</div><br/><div id="36916114" class="c"><input type="checkbox" id="c-36916114" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915955">parent</a><span>|</span><a href="#36917432">next</a><span>|</span><label class="collapse" for="c-36916114">[-]</label><label class="expand" for="c-36916114">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  stat = rt_oldFunctionName(&amp;newStateArg, oldarg[,...])
</code></pre>
mostly (again from memory. I&#x27;d not live or die by this)</div><br/></div></div></div></div></div></div><div id="36917432" class="c"><input type="checkbox" id="c-36917432" checked=""/><div class="controls bullet"><span class="by">pyuser583</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915597">parent</a><span>|</span><a href="#36915667">prev</a><span>|</span><a href="#36915964">next</a><span>|</span><label class="collapse" for="c-36917432">[-]</label><label class="expand" for="c-36917432">[1 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; We want to be very careful with backward compatibility. We do not want another Python 3 situation …</div><br/></div></div><div id="36915964" class="c"><input type="checkbox" id="c-36915964" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915597">parent</a><span>|</span><a href="#36917432">prev</a><span>|</span><a href="#36915829">next</a><span>|</span><label class="collapse" for="c-36915964">[-]</label><label class="expand" for="c-36915964">[8 more]</label></div><br/><div class="children"><div class="content">As sibling comments says, GIL mode can run no-GIL code.<p>Entirely different from 2-&gt;3.<p>That analogy is so poorly applicable it&#x27;s laughable.</div><br/><div id="36916133" class="c"><input type="checkbox" id="c-36916133" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915964">parent</a><span>|</span><a href="#36915829">next</a><span>|</span><label class="collapse" for="c-36916133">[-]</label><label class="expand" for="c-36916133">[7 more]</label></div><br/><div class="children"><div class="content">Without the last sentence, your comment would be better.</div><br/><div id="36917076" class="c"><input type="checkbox" id="c-36917076" checked=""/><div class="controls bullet"><span class="by">c-hendricks</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916133">parent</a><span>|</span><a href="#36916584">next</a><span>|</span><label class="collapse" for="c-36917076">[-]</label><label class="expand" for="c-36917076">[2 more]</label></div><br/><div class="children"><div class="content">GP would probably be better if they didn&#x27;t default to snark &#x2F; derision by calling it cat hearding.</div><br/><div id="36917227" class="c"><input type="checkbox" id="c-36917227" checked=""/><div class="controls bullet"><span class="by">pdntspa</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917076">parent</a><span>|</span><a href="#36916584">next</a><span>|</span><label class="collapse" for="c-36917227">[-]</label><label class="expand" for="c-36917227">[1 more]</label></div><br/><div class="children"><div class="content">But the python 2-&gt;3 migration has been exactly that</div><br/></div></div></div></div><div id="36916584" class="c"><input type="checkbox" id="c-36916584" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916133">parent</a><span>|</span><a href="#36917076">prev</a><span>|</span><a href="#36915829">next</a><span>|</span><label class="collapse" for="c-36916584">[-]</label><label class="expand" for="c-36916584">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not nice but it is true.<p>&quot;Dur dur this &lt;insert anything here&gt; is just like 2 -&gt; 3.&quot;<p>HN had always been susceptible to drive-by ignorant comments, but it&#x27;s reaching new levels.<p>There&#x27;s literally nothing of substance to the suggestion. (And if you think there is, present an actual informed argument.)</div><br/><div id="36917037" class="c"><input type="checkbox" id="c-36917037" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916584">parent</a><span>|</span><a href="#36915829">next</a><span>|</span><label class="collapse" for="c-36917037">[-]</label><label class="expand" for="c-36917037">[3 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t a suggestion, they were asking a question.</div><br/><div id="36918177" class="c"><input type="checkbox" id="c-36918177" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917037">parent</a><span>|</span><a href="#36915829">next</a><span>|</span><label class="collapse" for="c-36918177">[-]</label><label class="expand" for="c-36918177">[2 more]</label></div><br/><div class="children"><div class="content">Oh please.  Even if we ignore that any question can have implications, they directly said &quot;someone has to say it&quot;.<p>They were <i>explicitly</i> suggesting something by asking that question.</div><br/><div id="36918298" class="c"><input type="checkbox" id="c-36918298" checked=""/><div class="controls bullet"><span class="by">majewsky</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36918177">parent</a><span>|</span><a href="#36915829">next</a><span>|</span><label class="collapse" for="c-36918298">[-]</label><label class="expand" for="c-36918298">[1 more]</label></div><br/><div class="children"><div class="content">They were suggesting that this is a question that is going to be on people&#x27;s minds, which is very different from suggesting that the answer is yes.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36915829" class="c"><input type="checkbox" id="c-36915829" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915561">parent</a><span>|</span><a href="#36915597">prev</a><span>|</span><a href="#36915598">next</a><span>|</span><label class="collapse" for="c-36915829">[-]</label><label class="expand" for="c-36915829">[47 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the exact attitude that lead to decades of pain with the 2 to 3 transition and libraries though.  There was zero plan for how to help libraries migrate from python 2 to 3, or more importantly how does one library support _both_ python 2 and 3 from one codebase as their users take time to switch their python interpretor.  The attitude of &quot;just turn off GIL if you don&#x27;t need it, just use libraries that support turning it off&quot; means library authors will be asked to provide versions of their library that do and don&#x27;t support non-GIL mode.  That&#x27;s a big burden to dump on library maintainers.</div><br/><div id="36915979" class="c"><input type="checkbox" id="c-36915979" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915829">parent</a><span>|</span><a href="#36917359">next</a><span>|</span><label class="collapse" for="c-36915979">[-]</label><label class="expand" for="c-36915979">[9 more]</label></div><br/><div class="children"><div class="content">I’m no fan of Java, but in comparison with python, Java’s focus on extreme backwards compatibility and their ability to actually execute on this promise year after year stands in stark relief with how python has handled the same challenges. I have low confidence, despite their claims this won’t be python 4, that this will actually be executed well. Looking forward to having homebrew deliver python@3.25_GIL and python@3.25_no_GIL with each flipping package I install.</div><br/><div id="36916104" class="c"><input type="checkbox" id="c-36916104" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915979">parent</a><span>|</span><a href="#36917359">next</a><span>|</span><label class="collapse" for="c-36916104">[-]</label><label class="expand" for="c-36916104">[8 more]</label></div><br/><div class="children"><div class="content">Yep, and you&#x27;ll have pip3-gil and pip3-nogil binaries because each permutation of python has separate and incompatible site-packages folders and libraries.  It could get really ugly.</div><br/><div id="36917453" class="c"><input type="checkbox" id="c-36917453" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916104">parent</a><span>|</span><a href="#36916288">next</a><span>|</span><label class="collapse" for="c-36917453">[-]</label><label class="expand" for="c-36917453">[2 more]</label></div><br/><div class="children"><div class="content">Or it could motivate total abandonment of system-level Python installations in favor of per-app virtualenvs or whatever the new hotness is, and we&#x27;ll finally achieve world peace.</div><br/><div id="36917667" class="c"><input type="checkbox" id="c-36917667" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917453">parent</a><span>|</span><a href="#36916288">next</a><span>|</span><label class="collapse" for="c-36917667">[-]</label><label class="expand" for="c-36917667">[1 more]</label></div><br/><div class="children"><div class="content">I can see system level python installs being abandoned. They seem to be getting progressively harder to use over time. I don&#x27;t see the replacement being virtual env, it&#x27;ll be a different language ecosystem. Whichever one looks like it has remembered &quot;easy to do simple things in&quot; is a feature.</div><br/></div></div></div></div><div id="36916288" class="c"><input type="checkbox" id="c-36916288" checked=""/><div class="controls bullet"><span class="by">kelipso</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916104">parent</a><span>|</span><a href="#36917453">prev</a><span>|</span><a href="#36916640">next</a><span>|</span><label class="collapse" for="c-36916288">[-]</label><label class="expand" for="c-36916288">[2 more]</label></div><br/><div class="children"><div class="content">Lol the correct statement is it <i>will</i> get really ugly. Pretty much no question it will be a bigger mess than 2 to 3 transition. Here&#x27;s hoping my subfield will move to a different language in the meanwhile because I don&#x27;t want to deal with this shit again.</div><br/><div id="36916415" class="c"><input type="checkbox" id="c-36916415" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916288">parent</a><span>|</span><a href="#36916640">next</a><span>|</span><label class="collapse" for="c-36916415">[-]</label><label class="expand" for="c-36916415">[1 more]</label></div><br/><div class="children"><div class="content">All your hopes of GIL free code ruined by a GIL requiring left pad dep buried deep in the dependency tree.</div><br/></div></div></div></div><div id="36916640" class="c"><input type="checkbox" id="c-36916640" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916104">parent</a><span>|</span><a href="#36916288">prev</a><span>|</span><a href="#36917359">next</a><span>|</span><label class="collapse" for="c-36916640">[-]</label><label class="expand" for="c-36916640">[3 more]</label></div><br/><div class="children"><div class="content">Is the situation in rust, where the answer is apparently to vendor the world, much better? Don&#x27;t many of the big rust libraries still depend on nightly, too?</div><br/><div id="36917350" class="c"><input type="checkbox" id="c-36917350" checked=""/><div class="controls bullet"><span class="by">DougBTX</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916640">parent</a><span>|</span><a href="#36917359">next</a><span>|</span><label class="collapse" for="c-36917350">[-]</label><label class="expand" for="c-36917350">[2 more]</label></div><br/><div class="children"><div class="content">The major difference with rust is that the core language has strong backwards compatibility guarantees, and the package manager supports installing multiple versions of transitive dependencies so packages can be updated incrementally.</div><br/><div id="36917380" class="c"><input type="checkbox" id="c-36917380" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917350">parent</a><span>|</span><a href="#36917359">next</a><span>|</span><label class="collapse" for="c-36917380">[-]</label><label class="expand" for="c-36917380">[1 more]</label></div><br/><div class="children"><div class="content">Right. GP was complaint about having a gazillion versions of every dependency sitting around to satisfy various whims.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36917359" class="c"><input type="checkbox" id="c-36917359" checked=""/><div class="controls bullet"><span class="by">smashed</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915829">parent</a><span>|</span><a href="#36915979">prev</a><span>|</span><a href="#36915978">next</a><span>|</span><label class="collapse" for="c-36917359">[-]</label><label class="expand" for="c-36917359">[8 more]</label></div><br/><div class="children"><div class="content">As I understand it, as a library author you either do absolutely nothing and your library will be marked as requiring GIL by default. Nothing to do, you keep on working with that good old GIL and nothing changes.<p>Or you make the extra effort of being thread safe and you can declare your library as not requiring the GIL.<p>Now if a user script mixes your GIL free lib with an older lib that has not been updated, well, too bad for them. Even with your hard work, the code will still operate like before, everything gets the GIL treatment.<p>Normal python devs will need to track down which pesky dependency of their script is causing the GIL slowdown. Kinda sucks but at least nothing breaks.<p>It&#x27;s a sensitive, opt-in, and safe way forward. Hard to argue against it, really..</div><br/><div id="36917467" class="c"><input type="checkbox" id="c-36917467" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917359">parent</a><span>|</span><a href="#36915978">next</a><span>|</span><label class="collapse" for="c-36917467">[-]</label><label class="expand" for="c-36917467">[7 more]</label></div><br/><div class="children"><div class="content">Where can I read up on this planned way of working? This is not what the PEP says</div><br/><div id="36917709" class="c"><input type="checkbox" id="c-36917709" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917467">parent</a><span>|</span><a href="#36915978">next</a><span>|</span><label class="collapse" for="c-36917709">[-]</label><label class="expand" for="c-36917709">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in the &quot;Py_mod_gil Slot&quot; section [0] in the PEP:<p>&gt; In --disable-gil builds, when loading an extension, CPython will check for a new PEP 489-style Py_mod_gil slot. If the slot is set to Py_mod_gil_not_used, then extension loading proceeds as normal. If the slot is not set, the interpreter pauses all threads and enables the GIL before continuing. Additionally, the interpreter will issue a visible warning naming the extension, that the GIL was enabled (and why) and the steps the user can take to override it.<p>[0] <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#py-mod-gil-slot" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#py-mod-gil-slot</a></div><br/><div id="36917822" class="c"><input type="checkbox" id="c-36917822" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917709">parent</a><span>|</span><a href="#36917781">next</a><span>|</span><label class="collapse" for="c-36917822">[-]</label><label class="expand" for="c-36917822">[4 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s what&#x27;s puzzling me about this:<p>Why then is there even a need for a seperate nogil build? If it is like this says, wouldn&#x27;t it be easier to just make the standard build switch to gil or nogil automatically (or honor the users choice).<p>The fact that the SC thinks having two versions suggests there is more complexity involved than this section of the PEP leads readers to believe.</div><br/><div id="36918149" class="c"><input type="checkbox" id="c-36918149" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917822">parent</a><span>|</span><a href="#36917781">next</a><span>|</span><label class="collapse" for="c-36918149">[-]</label><label class="expand" for="c-36918149">[3 more]</label></div><br/><div class="children"><div class="content">You have to recompile your C extensions for the nogil build. Consider an application where one thread is calling xs.append from a C extension and another is calling xs.pop and xs[-1] on the same list object xs. In the nogil build these operations need to use a fine-grained lock on xs, and in the gil build these are thread-safe due to each thread holding the GIL when it does these operations.<p>On top of that, some of the list and dictionary operations are available to extensions as C macros to avoid the overhead of a C function call.<p>However, it looks like the nogil build will be able to run in &quot;GIL mode&quot; for maximum compatibility, including switching to GIL mode partway through execution, but I&#x27;m expecting this to be slower than running the gil build in GIL mode.</div><br/><div id="36918218" class="c"><input type="checkbox" id="c-36918218" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36918149">parent</a><span>|</span><a href="#36917781">next</a><span>|</span><label class="collapse" for="c-36918218">[-]</label><label class="expand" for="c-36918218">[2 more]</label></div><br/><div class="children"><div class="content">&gt; However, it looks like the nogil build will be able to run in &quot;GIL mode&quot; for maximum compatibility, including switching to GIL mode partway through execution<p>Yes, that&#x27;s what they were asking about.  Why have two versions for a mode switch.  Everything you explained before that is irrelevant, I&#x27;m afraid.<p>&gt; but I&#x27;m expecting this to be slower than running the gil build in GIL mode.<p>That <i>could</i> be the answer to their question, but that&#x27;s not definitive enough.</div><br/><div id="36918309" class="c"><input type="checkbox" id="c-36918309" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36918218">parent</a><span>|</span><a href="#36917781">next</a><span>|</span><label class="collapse" for="c-36918309">[-]</label><label class="expand" for="c-36918309">[1 more]</label></div><br/><div class="children"><div class="content">1. The &quot;stable ABI&quot; is broken on nogil, the selling point of the stable ABI was &quot;add this C preprocessor flag and your extension will work on all future CPython versions, after paying a speed penalty&quot;. This is useful for eg closed source extensions. If the nogil build was the only build available, these extensions would require recompilation.<p>2. There are a lot of users that want fast Python and a lot of effort was put in to optimise it. I think the core team wouldn&#x27;t want to release and expect everybody to use a version which regresses in performance, for a feature (nogil) which most won&#x27;t be able to use due to using C extensions which haven&#x27;t had nogil-supporting code changes.</div><br/></div></div></div></div></div></div></div></div><div id="36917781" class="c"><input type="checkbox" id="c-36917781" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917709">parent</a><span>|</span><a href="#36917822">prev</a><span>|</span><a href="#36915978">next</a><span>|</span><label class="collapse" for="c-36917781">[-]</label><label class="expand" for="c-36917781">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. Glad to know now!</div><br/></div></div></div></div></div></div></div></div><div id="36915978" class="c"><input type="checkbox" id="c-36915978" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915829">parent</a><span>|</span><a href="#36917359">prev</a><span>|</span><a href="#36916346">next</a><span>|</span><label class="collapse" for="c-36915978">[-]</label><label class="expand" for="c-36915978">[19 more]</label></div><br/><div class="children"><div class="content">&gt; how does one library support _both_ python 2 and 3 from one codebase<p>How does one library support both GIL and no-GIL?<p>Easy, it supports no-GIL, so it supports both. Done.</div><br/><div id="36916012" class="c"><input type="checkbox" id="c-36916012" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915978">parent</a><span>|</span><a href="#36916346">next</a><span>|</span><label class="collapse" for="c-36916012">[-]</label><label class="expand" for="c-36916012">[18 more]</label></div><br/><div class="children"><div class="content">You&#x27;re saying, &quot;just rewrite and re-release all your dependencies, it&#x27;s easy!&quot; which was exactly what happened disastrously with python 2 to 3.</div><br/><div id="36917299" class="c"><input type="checkbox" id="c-36917299" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916012">parent</a><span>|</span><a href="#36916424">next</a><span>|</span><label class="collapse" for="c-36917299">[-]</label><label class="expand" for="c-36917299">[1 more]</label></div><br/><div class="children"><div class="content">No, I&#x27;m saying that the problem you worry about doesn&#x27;t exist.<p>The problem -- as you point out -- with 2 -&gt; 3 was that supporting both versions was very difficult. Because Python 2 couldn&#x27;t run Python 3 code (and vice versa).<p>And thus libraries existed in awkward states for years.<p>But GIL can run no-GIL code. Supporting both is no harder than supporting one of those options (the no-GIL one).</div><br/></div></div><div id="36916424" class="c"><input type="checkbox" id="c-36916424" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916012">parent</a><span>|</span><a href="#36917299">prev</a><span>|</span><a href="#36916346">next</a><span>|</span><label class="collapse" for="c-36916424">[-]</label><label class="expand" for="c-36916424">[16 more]</label></div><br/><div class="children"><div class="content">You can down vote this til the cows come home but it’s historically what happened.<p>This “that’s not how it went” stuff going down is quite just blatant historical revisionism.<p>Maybe it’s a good idea? Maybe it’s not?<p>…but anyone down voting “this reminds me of the Python 2&#x2F;3” fiasco has no idea what they’re talking about.</div><br/><div id="36916564" class="c"><input type="checkbox" id="c-36916564" checked=""/><div class="controls bullet"><span class="by">ctoth</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916424">parent</a><span>|</span><a href="#36918247">next</a><span>|</span><label class="collapse" for="c-36916564">[-]</label><label class="expand" for="c-36916564">[3 more]</label></div><br/><div class="children"><div class="content">Except they&#x27;re not at all analogous situations.
In python 2 -&gt; 3, if a new version of a library came out Python 3 only, you couldn&#x27;t use both it, and your old Python 2 code at the same time.
Here, you can use the GIL until every one of your dependencies have migrated, even as new versions of your dependencies come out with nogil support until one magical day they all have nogil and you can migrate. But since you have been able to keep up with the library and weren&#x27;t just arbitrarily cut off at their last Python2&#x2F;GIL version, it&#x27;s not a huge breaking change!</div><br/><div id="36917485" class="c"><input type="checkbox" id="c-36917485" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916564">parent</a><span>|</span><a href="#36918247">next</a><span>|</span><label class="collapse" for="c-36917485">[-]</label><label class="expand" for="c-36917485">[2 more]</label></div><br/><div class="children"><div class="content">* removed comment as it was factually false *</div><br/><div id="36917789" class="c"><input type="checkbox" id="c-36917789" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917485">parent</a><span>|</span><a href="#36918247">next</a><span>|</span><label class="collapse" for="c-36917789">[-]</label><label class="expand" for="c-36917789">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If it was like you say there would be no need for the --nogil cli option.<p>Testing the difference between running it with and without `nogil` without having to install 2 different interpreters.<p>Testing libraries during transitions.<p>Simply giving users a choice.<p>Convenience.<p>Almost no one uses pre-Go.1.11 (GOPATH instead of Modules) any more for project organisation, and the transition is trivially easy. And yet, the toolchain still reacts to `GO111MODULE=off`.</div><br/></div></div></div></div></div></div><div id="36918247" class="c"><input type="checkbox" id="c-36918247" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916424">parent</a><span>|</span><a href="#36916564">prev</a><span>|</span><a href="#36917770">next</a><span>|</span><label class="collapse" for="c-36918247">[-]</label><label class="expand" for="c-36918247">[1 more]</label></div><br/><div class="children"><div class="content">&quot;it supports both. Done.&quot; is not how Python 2&#x2F;3 went.  You have no idea what you&#x27;re talking about.</div><br/></div></div><div id="36917770" class="c"><input type="checkbox" id="c-36917770" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916424">parent</a><span>|</span><a href="#36918247">prev</a><span>|</span><a href="#36916481">next</a><span>|</span><label class="collapse" for="c-36917770">[-]</label><label class="expand" for="c-36917770">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t matter if this &quot;happened historically&quot;.<p>Historically, Napoleon lost. That has zero impact on whether I get a promotion.<p>The 2 changes simply have nothing to do with each other. No-GIL python can still run GIL code, it just won&#x27;t be able to run it in parallel.</div><br/></div></div><div id="36916481" class="c"><input type="checkbox" id="c-36916481" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916424">parent</a><span>|</span><a href="#36917770">prev</a><span>|</span><a href="#36916346">next</a><span>|</span><label class="collapse" for="c-36916481">[-]</label><label class="expand" for="c-36916481">[10 more]</label></div><br/><div class="children"><div class="content">It&#x27;s good if there&#x27;s a benefit for everyone, like python 3 fixing the terrible Unicode story.  It&#x27;s not clear non-GIL will even be a net performance improvement for most people--you are effectively moving syncronization from the core runtime to each and every library and program at the edge.  Writing safe code at that level doesn&#x27;t come for free, your basic program will be slower (and likely buggier) if every call into a library is now doing its own little bespoke GIL instead of relying on python&#x27;s global one like now.</div><br/><div id="36916517" class="c"><input type="checkbox" id="c-36916517" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916481">parent</a><span>|</span><a href="#36916346">next</a><span>|</span><label class="collapse" for="c-36916517">[-]</label><label class="expand" for="c-36916517">[9 more]</label></div><br/><div class="children"><div class="content">I’m not gonna argue that point; but it seems massively disingenuous to down vote someone who complains “but now I have to rewrite my library because some people might use it in non-GIL mode”.<p>That’s not whining; it’s just an observation that the committee making these decisions gives zero ducks about the impact this will have for anyone other than the handful of vested parties involved in making the decisions.<p>Pypi has what, 500k projects on it? Many abandoned.<p>Whom <i>exactly</i> is going to update those?<p>Or do packages get an automatic “doesn’t work with no-GIL” unless the author explicitly opts to enable it?<p>Or do we live in a future where any package, with any dependency may or may not have undefined behaviour in no-GIL mode?<p>Like, sure… it’s a good change for many people… <i>once all the hard work is done by the community</i>.<p>Does that remind you of anything?<p>Mmm.</div><br/><div id="36918266" class="c"><input type="checkbox" id="c-36918266" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916517">parent</a><span>|</span><a href="#36917830">next</a><span>|</span><label class="collapse" for="c-36918266">[-]</label><label class="expand" for="c-36918266">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’m not gonna argue that point; but it seems massively disingenuous to down vote someone who complains “but now I have to rewrite my library because some people might use it in non-GIL mode”.<p>1. But they don&#x27;t &quot;have to&quot;.<p>2. Even if they did, why would downvoting be &quot;disingenuous&quot;?</div><br/></div></div><div id="36917830" class="c"><input type="checkbox" id="c-36917830" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916517">parent</a><span>|</span><a href="#36918266">prev</a><span>|</span><a href="#36917530">next</a><span>|</span><label class="collapse" for="c-36917830">[-]</label><label class="expand" for="c-36917830">[3 more]</label></div><br/><div class="children"><div class="content">First of all, these changes are not being introduced because of a committee. They are being introduced because a way to get true thread-based parallelism in Python has been one of THE top priority demands of a huge part of the Python developer community for ages.<p>&gt; “but now I have to rewrite my library because some people might use it in non-GIL mode”.<p>Yes, if library maintainers want their library to remain relevant, they will need to accomodate what the languages developer community uses. This is true for all languages. If they don&#x27;t want to, that&#x27;s okay, the community will come up with new libraries.<p>&gt; the committee making these decisions gives zero ducks about the impact this will have<p>If they were giving zero ducks, they wouldn&#x27;t make it backwards compatible, nor would there be a command line option to control the behavior.<p>&gt;Pypi has what, 500k projects on it? Many abandoned.
&gt;
&gt;Whom exactly is going to update those?<p>Languages that base decisions on the update behavior, or lack thereof, of library maintainers, effectively freeze themselves.<p>And why exactly is the update behavior of abandoned packages a problem? They are abandoned anyway.<p>&gt; Like, sure… it’s a good change for many people… once all the hard work is done by the community.<p>The people who want to get rid of the GIL are part of the Python development community. Many of them are library developers themselves.</div><br/><div id="36918197" class="c"><input type="checkbox" id="c-36918197" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917830">parent</a><span>|</span><a href="#36917530">next</a><span>|</span><label class="collapse" for="c-36918197">[-]</label><label class="expand" for="c-36918197">[2 more]</label></div><br/><div class="children"><div class="content">&gt; They are being introduced because a way to get true thread-based parallelism in Python has been one of THE top priority demands of a huge part of the Python<p>Where is this demand exactly? We hear a lot of complaining but very often this is due to a lack of awareness of available (&amp; often better) alternatives to threading.<p>There is a very small number of use cases that will benefit from free threading.</div><br/><div id="36918250" class="c"><input type="checkbox" id="c-36918250" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36918197">parent</a><span>|</span><a href="#36917530">next</a><span>|</span><label class="collapse" for="c-36918250">[-]</label><label class="expand" for="c-36918250">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Where is this demand exactly?<p>The motivation summary of PEP-703 contains some material on this:<p><a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#motivation" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#motivation</a><p>Further discussions going back years can be found with a brief search. This discussion is almost as old as Python3.<p>&gt; due to a lack of awareness of available (&amp; often better) alternatives to threading.<p>Such as?<p>There are exactly 2: asyncio, which is useless for CPU&#x2F;GPU bound workloads, and multiprocessing with all the pain of relying on expensive spawns, expensive and limited IPC and the joy of having to orchestrate across process boundaries.<p>Guess what the most common advice is for dealing with CPU bound parallelisation problems in Python? &quot;Use another language&quot;. Guess what all the languages recommended (C, C++, Rust, Go, Java) have in common? They have thread-based parallelism.<p>&gt; There is a very small number of use cases that will benefit from free threading.<p>Basically any workload that is CPU bound, which in the day and age of giant data aggragation and running huge ML models at scale is more important than every before, is a use case for this.</div><br/></div></div></div></div></div></div><div id="36917530" class="c"><input type="checkbox" id="c-36917530" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916517">parent</a><span>|</span><a href="#36917830">prev</a><span>|</span><a href="#36916706">next</a><span>|</span><label class="collapse" for="c-36917530">[-]</label><label class="expand" for="c-36917530">[1 more]</label></div><br/><div class="children"><div class="content">At the end of the day,this is the very point the SC and core devs are ignoring in their decision.<p>They do recognize the impact on the ecosystem will be huge, they recognize there will be at least 5 years of parallel gil&#x2F;nogil versions(*), and they say they don&#x27;t want a 2-3 story all over again.<p>Yet they have decided against their own best advise (to avoid such a situation).<p>I find it utterly confusing.<p>(*) not just <i>one</i> parallel version, there will be 2 for <i>every</i> release following the introduction. In reality organisations will have to maintain 4-6 different baselines of Python releases along with a matching (and likely differing) set of libraries. I don&#x27;t mean to fearmonger, I just happen to 
 maintain such environements and I know the effort that goes into this first hand.</div><br/></div></div><div id="36916706" class="c"><input type="checkbox" id="c-36916706" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916517">parent</a><span>|</span><a href="#36917530">prev</a><span>|</span><a href="#36916346">next</a><span>|</span><label class="collapse" for="c-36916706">[-]</label><label class="expand" for="c-36916706">[3 more]</label></div><br/><div class="children"><div class="content">Yep I fully agree.  It&#x27;s going to ultimately mean 99% of people end up running in old GIL mode with deterministic behavior.  Companies will get burned and have to have policies that absolutely under no circumstances will the GIL be disabled in their codebase.  A very small handful of highly skilled and funded teams, probably at big companies only, will have the time and tenacity to make their code AND all their dependencies work in a multithreaded environment without the GIL.</div><br/><div id="36917146" class="c"><input type="checkbox" id="c-36917146" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916706">parent</a><span>|</span><a href="#36916346">next</a><span>|</span><label class="collapse" for="c-36917146">[-]</label><label class="expand" for="c-36917146">[2 more]</label></div><br/><div class="children"><div class="content">I work at a big company. We had probably millions of lines of Python. We migrated to c++ instead of to Python 3.</div><br/><div id="36917902" class="c"><input type="checkbox" id="c-36917902" checked=""/><div class="controls bullet"><span class="by">abdulhaq</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917146">parent</a><span>|</span><a href="#36916346">next</a><span>|</span><label class="collapse" for="c-36917902">[-]</label><label class="expand" for="c-36917902">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really struggling to think of a scenario where that makes sense</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36916346" class="c"><input type="checkbox" id="c-36916346" checked=""/><div class="controls bullet"><span class="by">xmonkee</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915829">parent</a><span>|</span><a href="#36915978">prev</a><span>|</span><a href="#36915875">next</a><span>|</span><label class="collapse" for="c-36916346">[-]</label><label class="expand" for="c-36916346">[5 more]</label></div><br/><div class="children"><div class="content">no-GIL libs will work with the GIL on surely? So you won’t have to support both?</div><br/><div id="36916453" class="c"><input type="checkbox" id="c-36916453" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916346">parent</a><span>|</span><a href="#36915875">next</a><span>|</span><label class="collapse" for="c-36916453">[-]</label><label class="expand" for="c-36916453">[4 more]</label></div><br/><div class="children"><div class="content">Where will you get no-GIL libraries, especially in the early days?  Just yell at the maintainers of core libs like flask and requests until they use their volunteer and spare time to implement incredibly complex and tricky locking semantics all over their codebases, AND test it all with both GIL and non-GIL interpretors at scale to suss out race conditions? That just happens for free and overnight because a lot of people are plus one mashing on GitHub issues I guess?</div><br/><div id="36917744" class="c"><input type="checkbox" id="c-36917744" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916453">parent</a><span>|</span><a href="#36917797">next</a><span>|</span><label class="collapse" for="c-36917744">[-]</label><label class="expand" for="c-36917744">[2 more]</label></div><br/><div class="children"><div class="content">Flask is pure python, isn&#x27;t it?</div><br/><div id="36918272" class="c"><input type="checkbox" id="c-36918272" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917744">parent</a><span>|</span><a href="#36917797">next</a><span>|</span><label class="collapse" for="c-36918272">[-]</label><label class="expand" for="c-36918272">[1 more]</label></div><br/><div class="children"><div class="content">Even pure python code could have race conditions with the GIL disabled.  Stuff like accessing and modifying a dictionary item in python code is assumed and currently guaranteed to be atomic because of the GIL.  Remove the GIL and decades of assumptions break.</div><br/></div></div></div></div><div id="36917797" class="c"><input type="checkbox" id="c-36917797" checked=""/><div class="controls bullet"><span class="by">martijnvds</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36916453">parent</a><span>|</span><a href="#36917744">prev</a><span>|</span><a href="#36915875">next</a><span>|</span><label class="collapse" for="c-36917797">[-]</label><label class="expand" for="c-36917797">[1 more]</label></div><br/><div class="children"><div class="content">If I understand correctly how the GIL works, the change will only affect libraries with native componentsml. Everything that&#x27;s pure python will continue to work unchanged.</div><br/></div></div></div></div></div></div><div id="36915875" class="c"><input type="checkbox" id="c-36915875" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915829">parent</a><span>|</span><a href="#36916346">prev</a><span>|</span><a href="#36915598">next</a><span>|</span><label class="collapse" for="c-36915875">[-]</label><label class="expand" for="c-36915875">[5 more]</label></div><br/><div class="children"><div class="content">Indeed. The burden is 2x at least. They already estimate it&#x27;s going to take 5+ years, so that&#x27;s 10x the cost of a current library. At least.<p>If the burden becomes too big, at some point people may find it is the easier option to switch to a different ecosystem. I hope not.</div><br/><div id="36917676" class="c"><input type="checkbox" id="c-36917676" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915875">parent</a><span>|</span><a href="#36915598">next</a><span>|</span><label class="collapse" for="c-36917676">[-]</label><label class="expand" for="c-36917676">[4 more]</label></div><br/><div class="children"><div class="content">I hope it&#x27;ll be lua. I fear it&#x27;ll be javascript.</div><br/><div id="36918090" class="c"><input type="checkbox" id="c-36918090" checked=""/><div class="controls bullet"><span class="by">concordDance</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917676">parent</a><span>|</span><a href="#36918026">next</a><span>|</span><label class="collapse" for="c-36918090">[-]</label><label class="expand" for="c-36918090">[2 more]</label></div><br/><div class="children"><div class="content">Lua? Really?<p>That&#x27;s by far the most unpleasant language I&#x27;ve coded in.</div><br/><div id="36918160" class="c"><input type="checkbox" id="c-36918160" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36918090">parent</a><span>|</span><a href="#36918026">next</a><span>|</span><label class="collapse" for="c-36918160">[-]</label><label class="expand" for="c-36918160">[1 more]</label></div><br/><div class="children"><div class="content">Lexical scope, first class functions, native coroutines, compiler available at runtime. Trivially extensible. It&#x27;s semantically really close to lisp. Yep, lua&#x27;s one of my favourites. The front end syntax isn&#x27;t what I&#x27;d like but whatever, I can still see the AST through it with a little effort.</div><br/></div></div></div></div><div id="36918026" class="c"><input type="checkbox" id="c-36918026" checked=""/><div class="controls bullet"><span class="by">anyoneamous</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917676">parent</a><span>|</span><a href="#36918090">prev</a><span>|</span><a href="#36915598">next</a><span>|</span><label class="collapse" for="c-36918026">[-]</label><label class="expand" for="c-36918026">[1 more]</label></div><br/><div class="children"><div class="content">I hope it&#x27;ll be Nim, I fear it&#x27;ll be Julia.</div><br/></div></div></div></div></div></div></div></div><div id="36915598" class="c"><input type="checkbox" id="c-36915598" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915561">parent</a><span>|</span><a href="#36915829">prev</a><span>|</span><a href="#36917151">next</a><span>|</span><label class="collapse" for="c-36915598">[-]</label><label class="expand" for="c-36915598">[1 more]</label></div><br/><div class="children"><div class="content">I hope you are right. I fear it will turn out rather painful (I have lived through 10 years of Java multithreading, I don&#x27;t miss it)<p>* update: I have also lived through 10 years of Python 2-3. It was not pretty.</div><br/></div></div><div id="36917151" class="c"><input type="checkbox" id="c-36917151" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915561">parent</a><span>|</span><a href="#36915598">prev</a><span>|</span><a href="#36917020">next</a><span>|</span><label class="collapse" for="c-36917151">[-]</label><label class="expand" for="c-36917151">[2 more]</label></div><br/><div class="children"><div class="content">Coming from a place of total ignorance, it would be nice if you could do this more incrementally, like have it be in no-gil mode by default, but then have a context manager you can use for gil sections, and have the interpreter bomb out if you try to enter gil-required code while still in no-gil mode.</div><br/><div id="36917251" class="c"><input type="checkbox" id="c-36917251" checked=""/><div class="controls bullet"><span class="by">HoppyHaus</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917151">parent</a><span>|</span><a href="#36917020">next</a><span>|</span><label class="collapse" for="c-36917251">[-]</label><label class="expand" for="c-36917251">[1 more]</label></div><br/><div class="children"><div class="content">The issue is when someone&#x27;s unattended-upgrades bumps up the version and causes something to come crashing down.
The people who need to use nogil should know that they need to, and will now have the ability to enable it</div><br/></div></div></div></div><div id="36917020" class="c"><input type="checkbox" id="c-36917020" checked=""/><div class="controls bullet"><span class="by">raverbashing</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915561">parent</a><span>|</span><a href="#36917151">prev</a><span>|</span><a href="#36918006">next</a><span>|</span><label class="collapse" for="c-36917020">[-]</label><label class="expand" for="c-36917020">[2 more]</label></div><br/><div class="children"><div class="content">&gt; marked &quot;no-GIL compatible&quot;<p>Ugh, Nomenclature is hard<p>Because non-GIL compatible doesn&#x27;t mean GIL incompatible</div><br/><div id="36917319" class="c"><input type="checkbox" id="c-36917319" checked=""/><div class="controls bullet"><span class="by">_ZeD_</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36917020">parent</a><span>|</span><a href="#36918006">next</a><span>|</span><label class="collapse" for="c-36917319">[-]</label><label class="expand" for="c-36917319">[1 more]</label></div><br/><div class="children"><div class="content">&quot;requires GIL&quot; for all current projects?</div><br/></div></div></div></div></div></div><div id="36918006" class="c"><input type="checkbox" id="c-36918006" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#36915232">parent</a><span>|</span><a href="#36915561">prev</a><span>|</span><a href="#36915799">next</a><span>|</span><label class="collapse" for="c-36918006">[-]</label><label class="expand" for="c-36918006">[1 more]</label></div><br/><div class="children"><div class="content">I remember these warnings as well from when I started programming C seriously in the 90s. When I first encountered them I was convinced these issues will be resolved in a matter of weeks, maybe a couple of month at worst. Ohh, so little did I know.</div><br/></div></div><div id="36915799" class="c"><input type="checkbox" id="c-36915799" checked=""/><div class="controls bullet"><span class="by">winter_blue</span><span>|</span><a href="#36915232">parent</a><span>|</span><a href="#36918006">prev</a><span>|</span><a href="#36915730">next</a><span>|</span><label class="collapse" for="c-36915799">[-]</label><label class="expand" for="c-36915799">[6 more]</label></div><br/><div class="children"><div class="content">I wonder why so many library developers even chose to build native libraries on the shaky and poorly-architected foundation that Python is.<p>Even writing a JVM native JNI library would have allowed to avoid a lot of that pain (and the library would have been useable from Clojure, Kotlin , Scala, JRuby[1], Jython[2], Java, etc) without any painful threading issues.<p>[1] which I’m aware of having been used in production by companies in the past<p>[2] which I’m aware has been quite a bit under maintained for the last several years</div><br/><div id="36915867" class="c"><input type="checkbox" id="c-36915867" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915799">parent</a><span>|</span><a href="#36918225">next</a><span>|</span><label class="collapse" for="c-36915867">[-]</label><label class="expand" for="c-36915867">[3 more]</label></div><br/><div class="children"><div class="content">Because with the GIL it was dead simple to glue a C library into Python, and also was the canonical way to address hot inner loops in Python: rewrite into C. Nothing fancy but a little trial and error with module loading and you get 30% speed ups without being a great C programmer.<p>I don’t think it’s false to say that the ease of moving hot spots into C is part of the reason Python has been so successful for thirty years.<p>I hope this works, but I am very sceptical about being able to port code that worked with a locking solution provided for the enthusiast trying out C working without running into concurrency bugs.</div><br/><div id="36917543" class="c"><input type="checkbox" id="c-36917543" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915867">parent</a><span>|</span><a href="#36916786">next</a><span>|</span><label class="collapse" for="c-36917543">[-]</label><label class="expand" for="c-36917543">[1 more]</label></div><br/><div class="children"><div class="content">btw, many C extensions release GIL already e.g., one Python thread can do regex work, another some number crunching, yet another waiting IO--all in parallel.</div><br/></div></div><div id="36916786" class="c"><input type="checkbox" id="c-36916786" checked=""/><div class="controls bullet"><span class="by">Cacti</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915867">parent</a><span>|</span><a href="#36917543">prev</a><span>|</span><a href="#36918225">next</a><span>|</span><label class="collapse" for="c-36916786">[-]</label><label class="expand" for="c-36916786">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is the thing about the binding system that drove adoption more than anything was due to how easy it was to generate bindings for an existing C library. This drove stdlib expansion and allowed rapid repurpose of huge amounts of long-standing and popular C libraries, and it also added instant credibility for those that already trusted those libraries. This helped avoid the chicken and egg problem of not enough devs for a serious stdlib, but not serious enough stdlib to draw dev (which is where most languages, even good ones, die).<p>I distinctly remember that during the time period where Python grew from “minor” to “dominate” (roughly 1995-2005), doing Python dev was often a process of answering “are there bindings for that?” And usually _there were_, because of that tooling.</div><br/></div></div></div></div><div id="36918225" class="c"><input type="checkbox" id="c-36918225" checked=""/><div class="controls bullet"><span class="by">gjulianm</span><span>|</span><a href="#36915232">root</a><span>|</span><a href="#36915799">parent</a><span>|</span><a href="#36915867">prev</a><span>|</span><a href="#36915895">next</a><span>|</span><label class="collapse" for="c-36918225">[-]</label><label class="expand" for="c-36918225">[1 more]</label></div><br/><div class="children"><div class="content">I think there are several reasons:<p>- The history is backwards: it isn’t that devs wanted to make a native library and then chose Python, it’s that they chose Python and then they needed a native library.<p>- Python works very well for scripts and small programs, and decently well for medium-size programs. This makes libraries with concrete purposes very useful and productive. If your library, say, helps devs do some basic calculation with time series, the ability to be used in quick scripts is a big plus.<p>- The C API is fairly good, and libraries such as pybind11  make it even better. You don’t need a lot of code or boilerplate for an extension.</div><br/></div></div></div></div></div></div><div id="36917722" class="c"><input type="checkbox" id="c-36917722" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#36915232">prev</a><span>|</span><a href="#36915511">next</a><span>|</span><label class="collapse" for="c-36917722">[-]</label><label class="expand" for="c-36917722">[2 more]</label></div><br/><div class="children"><div class="content">Exciting. Python is mostly written as C shared libraries that knew they had a global lock to rely on.<p>Some of those do sufficiently simple things that they can run without any locking and all will be fine.<p>Others will still need locking, but are now under pressure to run without the gil. Some of those are going to do DIY locking within their own bounds.<p>Maybe what python has really been missing all these years is loads of ad hoc mutex calls scattered across the ecosystem. Data races and deadlocks introduced in the name of performance is not how I expected python to go out.<p>edit: expanding on this pessimism a bit.<p>Making C libraries written assuming a global lock thread safe is the sort of thing I&#x27;d expect concurrency experts to advise against and then make mistakes while implementing it. My working theory is that most people who wrote C extensions for python are <i>not</i> concurrency experts and <i>are</i> great programmers who won&#x27;t back down from a challenge.<p>The data-race&#x2F;hang&#x2F;segfault consequences of this combination look totally inevitable to me. Python application developers are not going to love the new experience and I&#x27;m thankful my products are not built on top of the python ecosystem.</div><br/><div id="36917961" class="c"><input type="checkbox" id="c-36917961" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#36917722">parent</a><span>|</span><a href="#36915511">next</a><span>|</span><label class="collapse" for="c-36917961">[-]</label><label class="expand" for="c-36917961">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re right. Making it an explicit opt-out, as is planned for the first stage, should be fine. Expecting to make it opt-in in 5 years seems too optimistic to me. It relies on <i>all</i> the library developers to fix their libraries (also the Python ones). That&#x27;s tough work, and importantly, if done well, it will even go unappreciated: nobody will notice it.<p>Many libraries have never had a multi-processing use case, others are so big that bugs are bound to happen, many of them subtle, so one guaranteed outcome will be unreproducible complaints and devs throwing in the towel. Opt-in will make people unhappy.</div><br/></div></div></div></div><div id="36915511" class="c"><input type="checkbox" id="c-36915511" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36917722">prev</a><span>|</span><a href="#36916422">next</a><span>|</span><label class="collapse" for="c-36915511">[-]</label><label class="expand" for="c-36915511">[49 more]</label></div><br/><div class="children"><div class="content">Naiive question: Who needs No-GIL when we have asyncio and multiprocessing packages ?<p>never ever had a problem with GIL in python, always found a workaround just by spinning up ThreadPool or ProcessPool, and used async libraries when needed.<p>is there any use case of No-GIL which is not solved by multiprocessing ?<p>I thought Single threaded execution without overhead for concurrency primitives is the best way to high performance computing (as demonstrated by LMAX Disruptor)</div><br/><div id="36915581" class="c"><input type="checkbox" id="c-36915581" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36917862">next</a><span>|</span><label class="collapse" for="c-36915581">[-]</label><label class="expand" for="c-36915581">[16 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only about performance. asyncio is still inherently single-threaded, and hence also single core. multiprocessing is multi-core and hence better for performance, but each process is relatively heavy and there&#x27;s additional overhead to shared memory. GIL multi-threading is both single-core and difficult to use correctly.<p>No-GIL multi-threading is multi-core, though difficult to use. I don&#x27;t know the Python implementation but shared memory should be faster than using multiprocessing.<p>That said, when designing a system from scratch, I completely agree with you that for almost almost almost all Python use cases, threads should never be touched and asyncio&#x2F;multiprocessing is the way to go instead. Most Python programs that need fast multi-threading instead should not have been written in Python. Still, we&#x27;re here now and people did write CPU-intensive code in Python for one reason or another, so no-GIL is practical.<p>In these threads, I also always see a lot of people who simply aren&#x27;t aware of asyncio&#x2F;multiprocessing. I assume these are also a significant share of people asking for no-GIL, though probably not the ones pushing the change in the committee.</div><br/><div id="36917570" class="c"><input type="checkbox" id="c-36917570" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915581">parent</a><span>|</span><a href="#36915610">next</a><span>|</span><label class="collapse" for="c-36917570">[-]</label><label class="expand" for="c-36917570">[9 more]</label></div><br/><div class="children"><div class="content">Even with multithreading Python will still be slow. It&#x27;s not like singlethreaded Python can keep up with singlethreaded C or even JS.<p>This will just allow people to waste even more compute resources to get somewhat quick results from Python instead of doing the right thing.<p>From an ecological viewpoint this PEP will be disastrous and keep entire power plants online.</div><br/><div id="36917757" class="c"><input type="checkbox" id="c-36917757" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917570">parent</a><span>|</span><a href="#36917620">next</a><span>|</span><label class="collapse" for="c-36917757">[-]</label><label class="expand" for="c-36917757">[1 more]</label></div><br/><div class="children"><div class="content">Do you include the man hours in those calculations? Because they pollute a lot between the car, the food, the electricity the computer and internet for devs consumes, etc.</div><br/></div></div><div id="36917620" class="c"><input type="checkbox" id="c-36917620" checked=""/><div class="controls bullet"><span class="by">AlphaSite</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917570">parent</a><span>|</span><a href="#36917757">prev</a><span>|</span><a href="#36917712">next</a><span>|</span><label class="collapse" for="c-36917620">[-]</label><label class="expand" for="c-36917620">[1 more]</label></div><br/><div class="children"><div class="content">Python is also getting a JIT, they’re pursuing performance on all axis.</div><br/></div></div><div id="36917712" class="c"><input type="checkbox" id="c-36917712" checked=""/><div class="controls bullet"><span class="by">hanselot</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917570">parent</a><span>|</span><a href="#36917620">prev</a><span>|</span><a href="#36917606">next</a><span>|</span><label class="collapse" for="c-36917712">[-]</label><label class="expand" for="c-36917712">[4 more]</label></div><br/><div class="children"><div class="content">Sometimes the right thing is writing code in a language that reaches market before runway runs out.</div><br/><div id="36917946" class="c"><input type="checkbox" id="c-36917946" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917712">parent</a><span>|</span><a href="#36917932">next</a><span>|</span><label class="collapse" for="c-36917946">[-]</label><label class="expand" for="c-36917946">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fine for regular Python, but this doesn&#x27;t convince me for multithreaded Python. Most Python modules which are optimized for performance (numpy, pytorch, pandas, and all others built on top of them) are already multithreaded and drop the GIL so you can parallelize your workload with the threading module.<p>If someone really needs several threads of pure python being interpreted, something is afoul imo.</div><br/></div></div><div id="36917932" class="c"><input type="checkbox" id="c-36917932" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917712">parent</a><span>|</span><a href="#36917946">prev</a><span>|</span><a href="#36917606">next</a><span>|</span><label class="collapse" for="c-36917932">[-]</label><label class="expand" for="c-36917932">[2 more]</label></div><br/><div class="children"><div class="content">Ecosystem churn and exposing more issues to python contradicts this.<p>The whole point of using languages like python, js etc. is to not worry about whole classes of problems and intricacies.<p>There are modern languages with great tooling like Go, Rust or Clojure that have excellent support for safe concurrency and parallel execution etc.<p>And there are reliable, well established languages like Java&#x2F;C# that have been doing this forever.</div><br/><div id="36918245" class="c"><input type="checkbox" id="c-36918245" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917932">parent</a><span>|</span><a href="#36917606">next</a><span>|</span><label class="collapse" for="c-36918245">[-]</label><label class="expand" for="c-36918245">[1 more]</label></div><br/><div class="children"><div class="content">This. Python had a unique stance, it was different for a good reason.<p>The seamingly endless attempt to become more likeable to yet another subgroup of needs is not a good development. It started with static typing, it continued with async, and now we have free threading as the final draw.</div><br/></div></div></div></div></div></div><div id="36917606" class="c"><input type="checkbox" id="c-36917606" checked=""/><div class="controls bullet"><span class="by">tjpnz</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917570">parent</a><span>|</span><a href="#36917712">prev</a><span>|</span><a href="#36915610">next</a><span>|</span><label class="collapse" for="c-36917606">[-]</label><label class="expand" for="c-36917606">[2 more]</label></div><br/><div class="children"><div class="content">The text editors people use to write said code will keep even more power plants online.</div><br/><div id="36918253" class="c"><input type="checkbox" id="c-36918253" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917606">parent</a><span>|</span><a href="#36915610">next</a><span>|</span><label class="collapse" for="c-36918253">[-]</label><label class="expand" for="c-36918253">[1 more]</label></div><br/><div class="children"><div class="content">Especially PyCharm with its endless indexing. Have the time its key features are not available bc it has decided to go on another indexing spree. Alas that&#x27;s for another thread ;)</div><br/></div></div></div></div></div></div><div id="36915610" class="c"><input type="checkbox" id="c-36915610" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915581">parent</a><span>|</span><a href="#36917570">prev</a><span>|</span><a href="#36917862">next</a><span>|</span><label class="collapse" for="c-36915610">[-]</label><label class="expand" for="c-36915610">[6 more]</label></div><br/><div class="children"><div class="content">I would argue that if you have large concurrency and shared complex state - you better off use kafka and redis&#x2F;memcached as a shared state - and design proper fan-out.<p>This design scales much better for systems that will eventually overgrow one big machine. the No-GIL pytohn will be of no use, when you need to deploy your app across 100s machines.<p>I understand people want to take advantage of all cores etc, but at large scale - you will eventually need to split computation across machines and will resort to in-memory cache&#x2F;queue anyways - so better just architect your system since day0</div><br/><div id="36915739" class="c"><input type="checkbox" id="c-36915739" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915610">parent</a><span>|</span><a href="#36918181">next</a><span>|</span><label class="collapse" for="c-36915739">[-]</label><label class="expand" for="c-36915739">[1 more]</label></div><br/><div class="children"><div class="content">Stores like that, while scaling well, are orders of magnitudes slower than CPU memory. The kind of application I was thinking of is more compute-intensive, eg. image processing or fancy algorithms.</div><br/></div></div><div id="36918181" class="c"><input type="checkbox" id="c-36918181" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915610">parent</a><span>|</span><a href="#36915739">prev</a><span>|</span><a href="#36917377">next</a><span>|</span><label class="collapse" for="c-36918181">[-]</label><label class="expand" for="c-36918181">[1 more]</label></div><br/><div class="children"><div class="content">PostgreSQL shows how far you can get with a single big box and using multiple cores and shared memory. It&#x27;s incredibly powerful and the vast majority of applications never have data big enough to warrant &quot;100s of machines&quot;.</div><br/></div></div><div id="36917377" class="c"><input type="checkbox" id="c-36917377" checked=""/><div class="controls bullet"><span class="by">pxeger1</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915610">parent</a><span>|</span><a href="#36918181">prev</a><span>|</span><a href="#36917626">next</a><span>|</span><label class="collapse" for="c-36917377">[-]</label><label class="expand" for="c-36917377">[1 more]</label></div><br/><div class="children"><div class="content">But many systems will never need to run at that kind of scale, but could still benefit from better threading performance, so it&#x27;s good to have an &quot;intermediate&quot; choice, if that&#x27;s what you consider it.</div><br/></div></div><div id="36917626" class="c"><input type="checkbox" id="c-36917626" checked=""/><div class="controls bullet"><span class="by">AlphaSite</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915610">parent</a><span>|</span><a href="#36917377">prev</a><span>|</span><a href="#36915899">next</a><span>|</span><label class="collapse" for="c-36917626">[-]</label><label class="expand" for="c-36917626">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of performance sensitive codebases where something like this would destroy performance, it works well for shared nothing parallelism, but the moment you have shared state it kinda falls over.</div><br/></div></div><div id="36915899" class="c"><input type="checkbox" id="c-36915899" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915610">parent</a><span>|</span><a href="#36917626">prev</a><span>|</span><a href="#36917862">next</a><span>|</span><label class="collapse" for="c-36915899">[-]</label><label class="expand" for="c-36915899">[1 more]</label></div><br/><div class="children"><div class="content">sometimes you need all of that data in-process. when you move that state into redis, you still need to perform i&#x2F;o to access it. when speed matters, this is troublesome.</div><br/></div></div></div></div></div></div><div id="36917862" class="c"><input type="checkbox" id="c-36917862" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36915581">prev</a><span>|</span><a href="#36918217">next</a><span>|</span><label class="collapse" for="c-36917862">[-]</label><label class="expand" for="c-36917862">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Naiive question: Who needs No-GIL when we have asyncio and multiprocessing packages ?<p>1. Because asyncio is completely useless when the problem is CPU bound, as the event loop still runs only on a single core. As the name implies, it is really only helpful when problems are IO bound.<p>2. Because sharing data between multiple processes is a giant PITA. Controlling data AND orchestrating processes is an even bigger pain.<p>3. Processes are expensive, and due to the aforementioned pain of sharing data, greenlets are not really a viable solutions.</div><br/></div></div><div id="36918217" class="c"><input type="checkbox" id="c-36918217" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36917862">prev</a><span>|</span><a href="#36915560">next</a><span>|</span><label class="collapse" for="c-36918217">[-]</label><label class="expand" for="c-36918217">[1 more]</label></div><br/><div class="children"><div class="content">LMAX Disruptor is multithreaded.<p>Multithreading is more efficient but more difficult to work with.<p>You share the same address space in threads, so you can communicate any amount of data between threads instantly within a lock. The same cannot be said for network traffic or OS pipes or multiprocessing.<p>Multiprocessing uses pickle to serialize your data and deserialize it in the other python interpreter.<p>If you start a Python Thread, you&#x27;re still single threaded due to the GIL.</div><br/></div></div><div id="36915560" class="c"><input type="checkbox" id="c-36915560" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36918217">prev</a><span>|</span><a href="#36915754">next</a><span>|</span><label class="collapse" for="c-36915560">[-]</label><label class="expand" for="c-36915560">[17 more]</label></div><br/><div class="children"><div class="content">&gt; is there any use case of No-GIL which is not solved by multiprocessing ?<p>Anything that benefits from both parallelism and replacing IPC overhead with shared data between parallel tasks.</div><br/><div id="36915585" class="c"><input type="checkbox" id="c-36915585" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915560">parent</a><span>|</span><a href="#36915754">next</a><span>|</span><label class="collapse" for="c-36915585">[-]</label><label class="expand" for="c-36915585">[16 more]</label></div><br/><div class="children"><div class="content">but it would incur overhead of concurrency control: mutex, locks, semaphores.<p>I dont believe python will ever have atomic operations, even if it had - they still incur significant overhead for concurrency control.<p>sharing state between threads is such a narow niche use case, this pattern is practically solved by memcached&#x2F;redis for larger scale python based systems</div><br/><div id="36915617" class="c"><input type="checkbox" id="c-36915617" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915585">parent</a><span>|</span><a href="#36917655">next</a><span>|</span><label class="collapse" for="c-36915617">[-]</label><label class="expand" for="c-36915617">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but it would incur overhead of concurrency control: mutex, locks, semaphores.<p>Yes, but there are plenty of problems where that is more <i>development</i> overhead, but less <i>runtime</i> overhead than IPC.</div><br/></div></div><div id="36917655" class="c"><input type="checkbox" id="c-36917655" checked=""/><div class="controls bullet"><span class="by">fred123</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915585">parent</a><span>|</span><a href="#36915617">prev</a><span>|</span><a href="#36918061">next</a><span>|</span><label class="collapse" for="c-36917655">[-]</label><label class="expand" for="c-36917655">[1 more]</label></div><br/><div class="children"><div class="content">&gt; sharing state between threads is such a narow niche use case<p>It is the norm. „Kafka scale“ problems are not the norm.</div><br/></div></div><div id="36918061" class="c"><input type="checkbox" id="c-36918061" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915585">parent</a><span>|</span><a href="#36917655">prev</a><span>|</span><a href="#36917878">next</a><span>|</span><label class="collapse" for="c-36918061">[-]</label><label class="expand" for="c-36918061">[1 more]</label></div><br/><div class="children"><div class="content">Relying on Redis for data sharing between concurrent processes seems like a massive overhead to me. You&#x27;ve got network overhead as well as a single threaded data store.<p>I am thinking about multithreading every day to try make it easier to use. I journal about it in my ideas journals.</div><br/></div></div><div id="36917878" class="c"><input type="checkbox" id="c-36917878" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915585">parent</a><span>|</span><a href="#36918061">prev</a><span>|</span><a href="#36915613">next</a><span>|</span><label class="collapse" for="c-36917878">[-]</label><label class="expand" for="c-36917878">[1 more]</label></div><br/><div class="children"><div class="content">&gt; sharing state between threads is such a narow niche use case,<p>Outside of python, no it really isn&#x27;t, it&#x27;s the norm.<p>And even within python itself: That redis connection IS shared state.</div><br/></div></div><div id="36915613" class="c"><input type="checkbox" id="c-36915613" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915585">parent</a><span>|</span><a href="#36917878">prev</a><span>|</span><a href="#36915754">next</a><span>|</span><label class="collapse" for="c-36915613">[-]</label><label class="expand" for="c-36915613">[11 more]</label></div><br/><div class="children"><div class="content">Fully agree. People put far too much emphasis &amp; expectations on the &quot;free&quot; part in &quot;free multithreading&quot;.</div><br/><div id="36915640" class="c"><input type="checkbox" id="c-36915640" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915613">parent</a><span>|</span><a href="#36915754">next</a><span>|</span><label class="collapse" for="c-36915640">[-]</label><label class="expand" for="c-36915640">[10 more]</label></div><br/><div class="children"><div class="content">even if they get &quot;free multithreading&quot; with no-GIL, their system eventually will overgrow one beefy machine and will need to be deployed across a fleet of 10&#x2F;100&#x2F;1000 machines.<p>at which point you lose benefit of no-GIL, because you now have to introduce redis and kafka into the system</div><br/><div id="36918306" class="c"><input type="checkbox" id="c-36918306" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915640">parent</a><span>|</span><a href="#36915689">next</a><span>|</span><label class="collapse" for="c-36918306">[-]</label><label class="expand" for="c-36918306">[1 more]</label></div><br/><div class="children"><div class="content">Most systems don&#x27;t grow forever, and can stay on one machine.<p>And &quot;one beefy machine&quot; has a very high limit, so by the time you actually outgrow it you usually have tons of resources available to help rewrite things.</div><br/></div></div><div id="36915689" class="c"><input type="checkbox" id="c-36915689" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915640">parent</a><span>|</span><a href="#36918306">prev</a><span>|</span><a href="#36917457">next</a><span>|</span><label class="collapse" for="c-36915689">[-]</label><label class="expand" for="c-36915689">[1 more]</label></div><br/><div class="children"><div class="content">&gt; even if they get “free multithreading” with no-GIL, their system eventually will overgrow one beefy machine<p>Why?<p>Yeah, if you are building a system that is, say, serving web requests, and have an internet scale potential market, success might mean that.<p>Not every system works that way. A simulation system with defined parameters doesn’t grow in scale if it becomes more popular, you just have more people running isolated instances that don’t depend on each other. Plenty of other applications scale that way rather than the “SaaS that serves ever more clients” way.</div><br/></div></div><div id="36917457" class="c"><input type="checkbox" id="c-36917457" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915640">parent</a><span>|</span><a href="#36915689">prev</a><span>|</span><a href="#36917623">next</a><span>|</span><label class="collapse" for="c-36917457">[-]</label><label class="expand" for="c-36917457">[1 more]</label></div><br/><div class="children"><div class="content">I think this argument presumes that everything is the sort of problem that maps well to redis and kafka.  Scientific computing doesn&#x27;t.  And while things like numpy might lower contention on the GIL a bit, it&#x27;s not a cure-all.<p>Finely-grained locks are useful.  Even when you end up scaling between machines, it can be useful to have many threads in one memory space to maximize what you get out of one machine.<p>We&#x27;re moving up to hundreds of cores; Python often being stuck only being able to use a couple while tightly coupling state has been unfortunate.</div><br/></div></div><div id="36917623" class="c"><input type="checkbox" id="c-36917623" checked=""/><div class="controls bullet"><span class="by">fred123</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915640">parent</a><span>|</span><a href="#36917457">prev</a><span>|</span><a href="#36915727">next</a><span>|</span><label class="collapse" for="c-36917623">[-]</label><label class="expand" for="c-36917623">[1 more]</label></div><br/><div class="children"><div class="content">Why?
On AWS you can rent a 24 TB, 500 core machine. Almost all problems are smaller than that so don’t need to scale to more than one machine.<p>Building applications that run on multiple machines is at least one order of magnitude more complex and thus slower (in development velocity), so needlessly building an application to work distributedly is just bad engineering.</div><br/></div></div><div id="36915727" class="c"><input type="checkbox" id="c-36915727" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915640">parent</a><span>|</span><a href="#36917623">prev</a><span>|</span><a href="#36915754">next</a><span>|</span><label class="collapse" for="c-36915727">[-]</label><label class="expand" for="c-36915727">[5 more]</label></div><br/><div class="children"><div class="content">I kept making this point as well as the other arguments above (and others did too) in the Core Dev discussion group. Unfortuately to no avail. To be sure I am not a core dev.</div><br/><div id="36917414" class="c"><input type="checkbox" id="c-36917414" checked=""/><div class="controls bullet"><span class="by">matsemann</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915727">parent</a><span>|</span><a href="#36917640">next</a><span>|</span><label class="collapse" for="c-36917414">[-]</label><label class="expand" for="c-36917414">[3 more]</label></div><br/><div class="children"><div class="content">Well I don&#x27;t agree that just because one needs &gt;1 servers, no-gil is suddenly useless.<p>Still lots of complexity and awkwardness that can be avoided if you can do threading instead of processes. Like Promotheus scraping from a non-webserver python app is a pita, as you need a new process and lots of communication, vs just plug and play as in other languages.<p>Or just the insane resource usage. Had a java app serving multiple orders of magnitude more customers running on a few containers. Our current python app needs multiple deployments with different entry points, and about 15x the amount of containers.</div><br/><div id="36917870" class="c"><input type="checkbox" id="c-36917870" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917414">parent</a><span>|</span><a href="#36917640">next</a><span>|</span><label class="collapse" for="c-36917870">[-]</label><label class="expand" for="c-36917870">[2 more]</label></div><br/><div class="children"><div class="content">It is not fair to compare CPython (which is on purpose not optimized, only a reference implementation of interpretable scripting language without any focus on performance) to  OpenJDK - an arguably state of the art compiled bytecode VM with JIT and AOT compilers available, with decades and many $millions poured into runtime&#x2F;JIT&#x2F;GC&#x2F;etc research and optimization</div><br/><div id="36918214" class="c"><input type="checkbox" id="c-36918214" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917870">parent</a><span>|</span><a href="#36917640">next</a><span>|</span><label class="collapse" for="c-36918214">[-]</label><label class="expand" for="c-36918214">[1 more]</label></div><br/><div class="children"><div class="content">&quot;on purpose not optimized, only a reference implementation of interpretable scripting language without any focus on performance&quot;<p>That policy is over.<p>As the last years have shown, no alternative implementation can get off the ground due to C extensions and compatibility concerns, and CPython is now relied on for many large applications. It no longer makes sense to prioritise a simple implementation over performance.</div><br/></div></div></div></div></div></div><div id="36917640" class="c"><input type="checkbox" id="c-36917640" checked=""/><div class="controls bullet"><span class="by">fred123</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915727">parent</a><span>|</span><a href="#36917414">prev</a><span>|</span><a href="#36915754">next</a><span>|</span><label class="collapse" for="c-36917640">[-]</label><label class="expand" for="c-36917640">[1 more]</label></div><br/><div class="children"><div class="content">Do you think Meta (Instagram) are pushing GIL removal and Cinder for no reason? They clearly have that scale and still benefit from faster single machine performance</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36915754" class="c"><input type="checkbox" id="c-36915754" checked=""/><div class="controls bullet"><span class="by">spamizbad</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36915560">prev</a><span>|</span><a href="#36915578">next</a><span>|</span><label class="collapse" for="c-36915754">[-]</label><label class="expand" for="c-36915754">[3 more]</label></div><br/><div class="children"><div class="content">This probably isn&#x27;t going to be that groundbreaking for your average web application. But for several of the niches where Python has a large footprint (AI, Data Science), being able to spin up a pile of cpu&#x2F;gpu-bound threads and let them rip is a huge boon.</div><br/><div id="36917690" class="c"><input type="checkbox" id="c-36917690" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915754">parent</a><span>|</span><a href="#36915578">next</a><span>|</span><label class="collapse" for="c-36917690">[-]</label><label class="expand" for="c-36917690">[2 more]</label></div><br/><div class="children"><div class="content">how likely, the corresponding code doesn&#x27;t release GIL already? Pure Python is 100x slower than native code therefore the number crunching itself happens in C extensions where GIL can be released.</div><br/><div id="36917899" class="c"><input type="checkbox" id="c-36917899" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36917690">parent</a><span>|</span><a href="#36915578">next</a><span>|</span><label class="collapse" for="c-36917899">[-]</label><label class="expand" for="c-36917899">[1 more]</label></div><br/><div class="children"><div class="content">&gt; therefore the number crunching itself happens in C extensions<p>The number crunching does, but distributing the workload, receiving results, storing and retreiving data, etc. doesn&#x27;t. And these are huge losses in performance that could be avoided if we could parallelise them.</div><br/></div></div></div></div></div></div><div id="36915578" class="c"><input type="checkbox" id="c-36915578" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36915754">prev</a><span>|</span><a href="#36916405">next</a><span>|</span><label class="collapse" for="c-36915578">[-]</label><label class="expand" for="c-36915578">[3 more]</label></div><br/><div class="children"><div class="content">Some of the use cases advocating for nogil come from the AI&#x2F;ML group of library builders, stating a need for free threading concurrency.</div><br/><div id="36915703" class="c"><input type="checkbox" id="c-36915703" checked=""/><div class="controls bullet"><span class="by">pama</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915578">parent</a><span>|</span><a href="#36916405">next</a><span>|</span><label class="collapse" for="c-36915703">[-]</label><label class="expand" for="c-36915703">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. Feeding the GPUs with multiple forked memory-hogging processes is no fun and leads to annoying hacks. And, yes, as per your other post, there could have been other solutions to this problem, some of which might have been better.</div><br/><div id="36915749" class="c"><input type="checkbox" id="c-36915749" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915703">parent</a><span>|</span><a href="#36916405">next</a><span>|</span><label class="collapse" for="c-36915749">[-]</label><label class="expand" for="c-36915749">[1 more]</label></div><br/><div class="children"><div class="content">Yes but that&#x27;s a very particular use case that could have been well served with a per gil thread and arena based memory for explicitely shared objects.</div><br/></div></div></div></div></div></div><div id="36916405" class="c"><input type="checkbox" id="c-36916405" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36915578">prev</a><span>|</span><a href="#36915563">next</a><span>|</span><label class="collapse" for="c-36916405">[-]</label><label class="expand" for="c-36916405">[2 more]</label></div><br/><div class="children"><div class="content">The problem with only relying on asyncio and multiprocessing is that they only implement per-process concurrency and parallelization per-process.<p>Threads let you use the same unified abstraction for parallelization and concurrency. They also make it easier to share state with parallelization (no need to go out of your way to do it) at the cost of requiring you to think about and implement thread safety when you do so.<p>Also, with no-GIL + threads the computational costs of creating and maintaining a parallel execution is much less vs multiprocessing. And data sharing and synchronization are less expensive.<p>What LMAX is doing is really just an overhyped way to speed up producer-consumer models. It might apply to your use case but it’s not the only reason you’d use parallelism or concurrency. I don’t even understand why they are claiming it to be an innovation when it’s just using a LockFreeQueue implementation within a pre-allocated arena? You also can’t synchronize with their implementation, which sometimes you really need to do. Not a silver bullet</div><br/><div id="36916539" class="c"><input type="checkbox" id="c-36916539" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36916405">parent</a><span>|</span><a href="#36915563">next</a><span>|</span><label class="collapse" for="c-36916539">[-]</label><label class="expand" for="c-36916539">[1 more]</label></div><br/><div class="children"><div class="content">multithreading with shared state introduces several limitations:<p><pre><code>  1. random jumps in memory and branch misses
  2. L1&#x2F;L2 cache flush
  3. context switch cost
  4. concurrency locks cost
</code></pre>
my understanding is that LMAX eliminated these costs:<p><pre><code>  1. pre-allocated arena ensures cache locality of operations
  2. we dont jump form one sector of memory into another. Algorithm more resembles linear scanning of working memory set, and mostly within L1&#x2F;L2 cache
  3. no context switches, no cache flushes
  4. no concurrency control costs</code></pre></div><br/></div></div></div></div><div id="36915563" class="c"><input type="checkbox" id="c-36915563" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36916405">prev</a><span>|</span><a href="#36917729">next</a><span>|</span><label class="collapse" for="c-36915563">[-]</label><label class="expand" for="c-36915563">[1 more]</label></div><br/><div class="children"><div class="content">Not sure why this is downvoted, I never had much issues with the GIL as well.<p>Multiprocessing does the parallel computation pretty well as long as the granularity is not too small. When smaller chunks are needed most of the time that&#x27;s something better done from an extension.</div><br/></div></div><div id="36917729" class="c"><input type="checkbox" id="c-36917729" checked=""/><div class="controls bullet"><span class="by">influx</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36915563">prev</a><span>|</span><a href="#36915986">next</a><span>|</span><label class="collapse" for="c-36917729">[-]</label><label class="expand" for="c-36917729">[1 more]</label></div><br/><div class="children"><div class="content">AsyncIO is great for IO bound applications, not so much for CPU bound...</div><br/></div></div><div id="36915986" class="c"><input type="checkbox" id="c-36915986" checked=""/><div class="controls bullet"><span class="by">TX81Z</span><span>|</span><a href="#36915511">parent</a><span>|</span><a href="#36917729">prev</a><span>|</span><a href="#36918258">next</a><span>|</span><label class="collapse" for="c-36915986">[-]</label><label class="expand" for="c-36915986">[2 more]</label></div><br/><div class="children"><div class="content">Multiprocessing has a lot of issues, one of which is handling processes that never complete, subprocesses that crash and don’t return, a subprocesses that needs to spawn another subprocesses, etc.</div><br/><div id="36918278" class="c"><input type="checkbox" id="c-36918278" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915511">root</a><span>|</span><a href="#36915986">parent</a><span>|</span><a href="#36918258">next</a><span>|</span><label class="collapse" for="c-36918278">[-]</label><label class="expand" for="c-36918278">[1 more]</label></div><br/><div class="children"><div class="content">Threads can end in limbo too. At least with multiprocessing you get to kill those that hang. Threads, not so much.</div><br/></div></div></div></div></div></div><div id="36916422" class="c"><input type="checkbox" id="c-36916422" checked=""/><div class="controls bullet"><span class="by">raminf</span><span>|</span><a href="#36915511">prev</a><span>|</span><a href="#36915747">next</a><span>|</span><label class="collapse" for="c-36916422">[-]</label><label class="expand" for="c-36916422">[4 more]</label></div><br/><div class="children"><div class="content">Remember the transition of text to Unicode? 32 to 64-bit? Intel to ARM? Y2K?<p>No-GIL is a much smaller shift. It can follow the same transition path without radically breaking things. And if some things do break, there would be a well-defined way to handle those cases.<p>We all somehow survived those. Glad to see forward motion on this. It will open up a lot more terrain that has been marked off as untenable.<p>One of the things about early Swift that they got right was building breaking changes into the promise. Everyone knew where they stood and adjusted just fine. Sometimes I wish Python would take the same path.</div><br/><div id="36916516" class="c"><input type="checkbox" id="c-36916516" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36916422">parent</a><span>|</span><a href="#36917573">next</a><span>|</span><label class="collapse" for="c-36916516">[-]</label><label class="expand" for="c-36916516">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s a bit different. 32 to 64 - you could test whether it works. Same for arm. Same for y2k. Sure, maybe the testing wouldn&#x27;t cover the failing case, but the testing you did would be deterministic. But here? Test all you want and the answer is: it&#x27;s either correct or you haven&#x27;t triggered the right race yet.</div><br/></div></div><div id="36917573" class="c"><input type="checkbox" id="c-36917573" checked=""/><div class="controls bullet"><span class="by">geewee</span><span>|</span><a href="#36916422">parent</a><span>|</span><a href="#36916516">prev</a><span>|</span><a href="#36915747">next</a><span>|</span><label class="collapse" for="c-36917573">[-]</label><label class="expand" for="c-36917573">[2 more]</label></div><br/><div class="children"><div class="content">I mean going from text to unicode did pose a huge problem for python specifically.</div><br/><div id="36918140" class="c"><input type="checkbox" id="c-36918140" checked=""/><div class="controls bullet"><span class="by">asah</span><span>|</span><a href="#36916422">root</a><span>|</span><a href="#36917573">parent</a><span>|</span><a href="#36915747">next</a><span>|</span><label class="collapse" for="c-36918140">[-]</label><label class="expand" for="c-36918140">[1 more]</label></div><br/><div class="children"><div class="content">I have PTSD from that transition.</div><br/></div></div></div></div></div></div><div id="36915747" class="c"><input type="checkbox" id="c-36915747" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#36916422">prev</a><span>|</span><a href="#36914414">next</a><span>|</span><label class="collapse" for="c-36915747">[-]</label><label class="expand" for="c-36915747">[9 more]</label></div><br/><div class="children"><div class="content">This can (and I think will) cause issues for C extensions because many are written without multi-threading in mind. Here is a small example which is unsafe if lst can be accessed from another thread: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36649769">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36649769</a> Note that the code may cause a context switch even today if the C code callbacks into Python bytecode (via a __del__ method) and the bytecode is long enough (100 instructions I think). However, that is extremely unlikely and much C extension code is not written with such situations in mind.<p>People using C extensions may also rely on them executing atomically. For example, you could have a thread pool that posts and receives from a numpy array. Would work fine today but break without the GIL.</div><br/><div id="36918270" class="c"><input type="checkbox" id="c-36918270" checked=""/><div class="controls bullet"><span class="by">smcl</span><span>|</span><a href="#36915747">parent</a><span>|</span><a href="#36915786">next</a><span>|</span><label class="collapse" for="c-36918270">[-]</label><label class="expand" for="c-36918270">[1 more]</label></div><br/><div class="children"><div class="content">I think the CPython core devs of these issues. Otherwise they&#x27;d have announced a plan to suddenly rip out the GIL altogether, rather than a phased approach that allows people to opt-in to the no-GIL mode.</div><br/></div></div><div id="36915786" class="c"><input type="checkbox" id="c-36915786" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915747">parent</a><span>|</span><a href="#36918270">prev</a><span>|</span><a href="#36914414">next</a><span>|</span><label class="collapse" for="c-36915786">[-]</label><label class="expand" for="c-36915786">[7 more]</label></div><br/><div class="children"><div class="content">Yep there are a ton of issues like that to be found, and unfortunately they will manifest as difficult to find and debug race conditions.  This is why the proposal and work is to make non-GIL mode entirely optional and not the default.<p>It just means for the brave few that flip it on and use it, be prepared to spend a huge amount of time finding and fixing subtle race conditions in decades of old python library code.  The early adopters are going to be in for a lot of pain, or more likely they&#x27;ll restrict their use of non-GIL processes to very specialized and dedicated processes that have as few dependencies as possible.</div><br/><div id="36915934" class="c"><input type="checkbox" id="c-36915934" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915747">root</a><span>|</span><a href="#36915786">parent</a><span>|</span><a href="#36916931">next</a><span>|</span><label class="collapse" for="c-36915934">[-]</label><label class="expand" for="c-36915934">[4 more]</label></div><br/><div class="children"><div class="content">The intent is to make no GIL the default eventually.</div><br/><div id="36916089" class="c"><input type="checkbox" id="c-36916089" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36915747">root</a><span>|</span><a href="#36915934">parent</a><span>|</span><a href="#36916931">next</a><span>|</span><label class="collapse" for="c-36916089">[-]</label><label class="expand" for="c-36916089">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is true. There are fairly strong voices on both sides inside the community, at this time it&#x27;s pretty uncertain.<p>To quote Guido:<p><i>&gt;Let’s not blow it this time. If we’re going forward with nogil (and I’m not saying we are, but I can’t exclude it), let’s make sure there is a way to be able to import extensions requiring the GIL in a nogil interpreter without any additional shenanigans</i><p><a href="https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;pep-703-making-the-global-interpreter-lock-optional-3-12-updates&#x2F;26503&#x2F;19" rel="nofollow noreferrer">https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;pep-703-making-the-global-inter...</a></div><br/><div id="36917010" class="c"><input type="checkbox" id="c-36917010" checked=""/><div class="controls bullet"><span class="by">Alphaeus</span><span>|</span><a href="#36915747">root</a><span>|</span><a href="#36916089">parent</a><span>|</span><a href="#36916931">next</a><span>|</span><label class="collapse" for="c-36917010">[-]</label><label class="expand" for="c-36917010">[2 more]</label></div><br/><div class="children"><div class="content">The Steering Council said their intention is to remove the GIL-build in future:<p><i>&gt; Long-term, we want no-GIL to be the default, and to remove any vestiges of the GIL (without unnecessarily breaking backward compatibility). We don’t want to wait too long with this, because having two common build modes may be a heavy burden on the community (as, for example, it can double test resources and debugging scenarios), but we can’t rush it either. We think it may take as much as five years to get to this stage.</i><p><a href="https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython&#x2F;30474" rel="nofollow noreferrer">https:&#x2F;&#x2F;discuss.python.org&#x2F;t&#x2F;a-steering-council-notice-about...</a></div><br/><div id="36917967" class="c"><input type="checkbox" id="c-36917967" checked=""/><div class="controls bullet"><span class="by">toyg</span><span>|</span><a href="#36915747">root</a><span>|</span><a href="#36917010">parent</a><span>|</span><a href="#36916931">next</a><span>|</span><label class="collapse" for="c-36917967">[-]</label><label class="expand" for="c-36917967">[1 more]</label></div><br/><div class="children"><div class="content">By the usual laws of software estimates, if they think it will take 5 years, it&#x27;s going to be more like 10-15.</div><br/></div></div></div></div></div></div></div></div><div id="36916931" class="c"><input type="checkbox" id="c-36916931" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#36915747">root</a><span>|</span><a href="#36915786">parent</a><span>|</span><a href="#36915934">prev</a><span>|</span><a href="#36914414">next</a><span>|</span><label class="collapse" for="c-36916931">[-]</label><label class="expand" for="c-36916931">[2 more]</label></div><br/><div class="children"><div class="content">Does Python have a lot of secondary dependencies? I could see someone pulling in two dependencies, not realize they both use the same unsafe library, and end up having them step all over each other.</div><br/><div id="36916967" class="c"><input type="checkbox" id="c-36916967" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915747">root</a><span>|</span><a href="#36916931">parent</a><span>|</span><a href="#36914414">next</a><span>|</span><label class="collapse" for="c-36916967">[-]</label><label class="expand" for="c-36916967">[1 more]</label></div><br/><div class="children"><div class="content">It does, so much so things like virtualenv were introduced so every program can have its own set of dependencies such that they won&#x27;t clash with other libs on your system.  Something like flask or fastapi pull in a lot of secondary dependencies alone.</div><br/></div></div></div></div></div></div></div></div><div id="36914414" class="c"><input type="checkbox" id="c-36914414" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#36915747">prev</a><span>|</span><a href="#36915059">next</a><span>|</span><label class="collapse" for="c-36914414">[-]</label><label class="expand" for="c-36914414">[10 more]</label></div><br/><div class="children"><div class="content">I know they say specifically that they don&#x27;t want a repeat of the Python3 transition scenario, but the approach they&#x27;re taking now still veers eerily close to that path, at least it looks that way to me.<p>A lot will depend on the Python community and the distribution channels. I could see the community struggling to adopt it in a timely fashion, or distributions jumping the gun (Ubuntu, Fedora, Anaconda). Maybe it&#x27;s too early to make hard decisions, but how much control does the SC really have to avoid such a scenario?</div><br/><div id="36917394" class="c"><input type="checkbox" id="c-36917394" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#36914414">parent</a><span>|</span><a href="#36915807">next</a><span>|</span><label class="collapse" for="c-36917394">[-]</label><label class="expand" for="c-36917394">[3 more]</label></div><br/><div class="children"><div class="content">They say they want no-gil to be the only build mode 5 years from when it becomes available. That is both too long and too short.<p>That is too long for Python to have 2 modes. Half a decade is more than enough time for 2 modes to become the status quo. For one thing, think of all the outdated Stackoverflow threads that will be hanging around after that 5 years. I am not optimistic that 5 years won&#x27;t turn into 10 years of uncertainty and breakage.<p>But 5 years might be too short for everyone to dredge up all that C code, update it, test it, and call it mature.<p>I guess we&#x27;ll see.</div><br/><div id="36917991" class="c"><input type="checkbox" id="c-36917991" checked=""/><div class="controls bullet"><span class="by">toyg</span><span>|</span><a href="#36914414">root</a><span>|</span><a href="#36917394">parent</a><span>|</span><a href="#36915807">next</a><span>|</span><label class="collapse" for="c-36917991">[-]</label><label class="expand" for="c-36917991">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; 5 years might be too short for everyone to dredge up all that C code, update it, test it, and call it mature.</i><p>Developers are lazy. Most people will just do nothing until, 5 years from now, some blog post will go &quot;oh, next month we switch noGil as default, good luck!&quot;. At that point everyone will scramble, rush out buggy releases, and spend 5 years finding all the problems.</div><br/><div id="36918226" class="c"><input type="checkbox" id="c-36918226" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#36914414">root</a><span>|</span><a href="#36917991">parent</a><span>|</span><a href="#36915807">next</a><span>|</span><label class="collapse" for="c-36918226">[-]</label><label class="expand" for="c-36918226">[1 more]</label></div><br/><div class="children"><div class="content">The no-gil &quot;build mode&quot; will still have the ability to switch to GIL &quot;run mode&quot;, it will just be slower than the GIL run mode on the GIL build mode. Hopefully not much slower.</div><br/></div></div></div></div></div></div><div id="36915807" class="c"><input type="checkbox" id="c-36915807" checked=""/><div class="controls bullet"><span class="by">a_nop</span><span>|</span><a href="#36914414">parent</a><span>|</span><a href="#36917394">prev</a><span>|</span><a href="#36914538">next</a><span>|</span><label class="collapse" for="c-36915807">[-]</label><label class="expand" for="c-36915807">[4 more]</label></div><br/><div class="children"><div class="content">They kind of burned a breaking major version transition for no good reason with 2-to-3, now they are prefacing a major change with &quot;it won&#x27;t be like 2-to-3&quot;.  It sounds like they may be maintaining two operating modes in CPython 3 instead of going forward with another major transition, just because of that history.</div><br/><div id="36917760" class="c"><input type="checkbox" id="c-36917760" checked=""/><div class="controls bullet"><span class="by">jborean93</span><span>|</span><a href="#36914414">root</a><span>|</span><a href="#36915807">parent</a><span>|</span><a href="#36914538">next</a><span>|</span><label class="collapse" for="c-36917760">[-]</label><label class="expand" for="c-36917760">[3 more]</label></div><br/><div class="children"><div class="content">&gt; They kind of burned a breaking major version transition for no good reason with 2-to-3<p>The unicode&#x2F;text changes alone were a pretty good reason. Division producing floats are also a nice change IMO. I don’t want to discount the challenges with the transition but saying there was no good reason isn’t right to me.</div><br/><div id="36918234" class="c"><input type="checkbox" id="c-36918234" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#36914414">root</a><span>|</span><a href="#36917760">parent</a><span>|</span><a href="#36918137">next</a><span>|</span><label class="collapse" for="c-36918234">[-]</label><label class="expand" for="c-36918234">[1 more]</label></div><br/><div class="children"><div class="content">There were a lot of bad reasons as well. The removal of the u string prefix in versions 3.0-3.2 was unnecessary and made the transition much more difficult. It kind of gave Python 3 a bad reputation.</div><br/></div></div><div id="36918137" class="c"><input type="checkbox" id="c-36918137" checked=""/><div class="controls bullet"><span class="by">rightbyte</span><span>|</span><a href="#36914414">root</a><span>|</span><a href="#36917760">parent</a><span>|</span><a href="#36918234">prev</a><span>|</span><a href="#36914538">next</a><span>|</span><label class="collapse" for="c-36918137">[-]</label><label class="expand" for="c-36918137">[1 more]</label></div><br/><div class="children"><div class="content">Not good enough reason then?</div><br/></div></div></div></div></div></div><div id="36914538" class="c"><input type="checkbox" id="c-36914538" checked=""/><div class="controls bullet"><span class="by">trwsxcn</span><span>|</span><a href="#36914414">parent</a><span>|</span><a href="#36915807">prev</a><span>|</span><a href="#36915059">next</a><span>|</span><label class="collapse" for="c-36914538">[-]</label><label class="expand" for="c-36914538">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it will resemble the 2to3 scenario. Corporations that pledge support will mechanically convert some projects (pestering the actual developers or threaten with forks?), bugs will be ironed out by the actual, unpaid developers over years.<p>But apparently Python needs some &quot;success&quot; and this makes a good bullet point. Correctness does not really matter in the Python world.</div><br/><div id="36917625" class="c"><input type="checkbox" id="c-36917625" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36914414">root</a><span>|</span><a href="#36914538">parent</a><span>|</span><a href="#36915059">next</a><span>|</span><label class="collapse" for="c-36917625">[-]</label><label class="expand" for="c-36917625">[1 more]</label></div><br/><div class="children"><div class="content">Is it success though?</div><br/></div></div></div></div></div></div><div id="36915059" class="c"><input type="checkbox" id="c-36915059" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#36914414">prev</a><span>|</span><a href="#36915313">next</a><span>|</span><label class="collapse" for="c-36915059">[-]</label><label class="expand" for="c-36915059">[11 more]</label></div><br/><div class="children"><div class="content">I’m glad they’re very conscious about how easily this could turn into a Python 4 debacle.<p>They’ll have to be intensely careful not to accidentally affect yes-GIL behaviour. All kinds of weird cases are possible if any sort of emulated GIL isn’t exactly like with a GIL.</div><br/><div id="36915669" class="c"><input type="checkbox" id="c-36915669" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#36915059">parent</a><span>|</span><a href="#36915324">next</a><span>|</span><label class="collapse" for="c-36915669">[-]</label><label class="expand" for="c-36915669">[7 more]</label></div><br/><div class="children"><div class="content">I’ve seen no description of how this won’t be like 2 -&gt; 3 except:<p>1. We don’t want it to be.<p>2. We’ll give up quickly if it is.<p>Those are both important points. But there seems to be an important missing third piece of “and we’ll achieve this by…”.</div><br/><div id="36915874" class="c"><input type="checkbox" id="c-36915874" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36915059">root</a><span>|</span><a href="#36915669">parent</a><span>|</span><a href="#36915880">next</a><span>|</span><label class="collapse" for="c-36915874">[-]</label><label class="expand" for="c-36915874">[2 more]</label></div><br/><div class="children"><div class="content">Quoting my comment from elsewhere:<p><i>&gt;I didn&#x27;t dive deep on this, but I assume that GIL mode can still run anything, including no-GIL code (it is one of their promises, at least). So, unlike 2-&gt;3, there is forwards-compatibility.</i><p><i>&gt;It also seems like the latter isn&#x27;t meant as a replacement (for the moment), but rather as an option.</i><p>As long as GIL mode remains compatible with both old and new code, I see very little danger in having a no-GIL mode (besides hogging CPython maintainers&#x27; time).</div><br/><div id="36916146" class="c"><input type="checkbox" id="c-36916146" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#36915059">root</a><span>|</span><a href="#36915874">parent</a><span>|</span><a href="#36915880">next</a><span>|</span><label class="collapse" for="c-36916146">[-]</label><label class="expand" for="c-36916146">[1 more]</label></div><br/><div class="children"><div class="content">I under-appreciated the forward comparability. So this partly a framing critique. If you’re going to frame it as “how this won’t be like before”, good to really highlight the <i>how</i>.</div><br/></div></div></div></div><div id="36915880" class="c"><input type="checkbox" id="c-36915880" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915059">root</a><span>|</span><a href="#36915669">parent</a><span>|</span><a href="#36915874">prev</a><span>|</span><a href="#36916074">next</a><span>|</span><label class="collapse" for="c-36915880">[-]</label><label class="expand" for="c-36915880">[1 more]</label></div><br/><div class="children"><div class="content">Agreed--there needs to be discussion and thought about how this impacts library maintainers.  How do they tell users their library supports or doesn&#x27;t support non-GIL mode?  Will pypi have new metadata to specify and enforce projectsdependencies support non-GIL mode, or is it just a chaotic free for all where users have to figure that out themselves?  How will a library author have one codebase that supports both GIL and non-GIL mode--will they effectively fork the code and maintain two codebases (yuck!) or will there be support for detecting GIL mode?  How does this work for C extensions too?  There&#x27;s a ton of work to make this smooth for libraries and I really hope it is being thought through better than the python 2 to 3 story for library authors (which was no story and chaos).</div><br/></div></div><div id="36916074" class="c"><input type="checkbox" id="c-36916074" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36915059">root</a><span>|</span><a href="#36915669">parent</a><span>|</span><a href="#36915880">prev</a><span>|</span><a href="#36915800">next</a><span>|</span><label class="collapse" for="c-36916074">[-]</label><label class="expand" for="c-36916074">[2 more]</label></div><br/><div class="children"><div class="content">quite a large set of users are using default python installation. There is large number of companies and non-trivial codebases that run on default python that comes with the oldest LTS version of Linux distro.<p>currently quite a lot of companies use python3.6 only because it comes standard with the Ubuntu 14.04.6 which happens to be the oldest LTS version - and companies have habit of migrating from out-of-support LTS version to currently-supported-oldest-LTS<p>this can repeat 2-&gt;3 because there will be users stuck with older versions of python and library maintainers will have to maintain both versions: with GIL and without GIL (just like PHP extension developers did with thread safe methods)</div><br/><div id="36917164" class="c"><input type="checkbox" id="c-36917164" checked=""/><div class="controls bullet"><span class="by">vlz</span><span>|</span><a href="#36915059">root</a><span>|</span><a href="#36916074">parent</a><span>|</span><a href="#36915800">next</a><span>|</span><label class="collapse" for="c-36917164">[-]</label><label class="expand" for="c-36917164">[1 more]</label></div><br/><div class="children"><div class="content">But shouldn&#x27;t old GIL python versions be fine running code that is no-GIL compatible (assuming it is otherwise compatible)? Having a thread per process doesn&#x27;t mean you cannot run code which is fine with having n threads per process. So if you maintain code which is otherwise compatible with e.g. python 3.6, after making it no-GIL compatible it should still be compatible to 3.6.</div><br/></div></div></div></div><div id="36915800" class="c"><input type="checkbox" id="c-36915800" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915059">root</a><span>|</span><a href="#36915669">parent</a><span>|</span><a href="#36916074">prev</a><span>|</span><a href="#36915324">next</a><span>|</span><label class="collapse" for="c-36915800">[-]</label><label class="expand" for="c-36915800">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Also once that Genie is out putting it back will be next to impossible.</div><br/></div></div></div></div><div id="36915324" class="c"><input type="checkbox" id="c-36915324" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915059">parent</a><span>|</span><a href="#36915669">prev</a><span>|</span><a href="#36915313">next</a><span>|</span><label class="collapse" for="c-36915324">[-]</label><label class="expand" for="c-36915324">[3 more]</label></div><br/><div class="children"><div class="content">I am sure the intent is good. I am not so sure it is possible to avoid. They already say it could take 5+ years of having gil + nogil exist in parallel.<p>For any tool builder that means their cost has just doubled for the next five years, at least. Why? Because people will want to use tools in either mode, no matter if it is deemed productive or experimental.</div><br/><div id="36916117" class="c"><input type="checkbox" id="c-36916117" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36915059">root</a><span>|</span><a href="#36915324">parent</a><span>|</span><a href="#36915313">next</a><span>|</span><label class="collapse" for="c-36916117">[-]</label><label class="expand" for="c-36916117">[2 more]</label></div><br/><div class="children"><div class="content">essentially the adoption of No-GIL Python will depend on:<p><pre><code>  1. In which version No-GIL will become default option in CPython
  2. When that CPython version will come standard in LTS Linux distro
  3. When all earlier LTS distros will go out of support
  4. When companies switch from outdated to target LTS version of distro
</code></pre>
currently quite a lot of companies use python3.6 only because it comes standard with the Ubuntu 14.04.6 which happens to be the oldest LTS version - and companies have habit of migrating from out-of-support LTS version to currently-supported-oldest-LTS</div><br/><div id="36916934" class="c"><input type="checkbox" id="c-36916934" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#36915059">root</a><span>|</span><a href="#36916117">parent</a><span>|</span><a href="#36915313">next</a><span>|</span><label class="collapse" for="c-36916934">[-]</label><label class="expand" for="c-36916934">[1 more]</label></div><br/><div class="children"><div class="content">A customer on 18.04 just told me to wait another year and migrate their servers to 24.04 so they can stay there until 2029, or will that be 2030? They are on the standard 5 years LTS support, not the extended 10 years one.</div><br/></div></div></div></div></div></div></div></div><div id="36915313" class="c"><input type="checkbox" id="c-36915313" checked=""/><div class="controls bullet"><span class="by">Systemmanic</span><span>|</span><a href="#36915059">prev</a><span>|</span><a href="#36915394">next</a><span>|</span><label class="collapse" for="c-36915313">[-]</label><label class="expand" for="c-36915313">[1 more]</label></div><br/><div class="children"><div class="content">GIL: Global Interpreter Lock.<p>Good explanation here: <a href="https:&#x2F;&#x2F;realpython.com&#x2F;python-gil&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;realpython.com&#x2F;python-gil&#x2F;</a></div><br/></div></div><div id="36915394" class="c"><input type="checkbox" id="c-36915394" checked=""/><div class="controls bullet"><span class="by">jmount</span><span>|</span><a href="#36915313">prev</a><span>|</span><a href="#36918166">next</a><span>|</span><label class="collapse" for="c-36915394">[-]</label><label class="expand" for="c-36915394">[20 more]</label></div><br/><div class="children"><div class="content">Why would you even want a no-GIL Python? Java and C showed how much more effort it takes to maintain slower thread safe code for no real benefit. Parallelize at the fork level or at the isolated numeric library level.</div><br/><div id="36915491" class="c"><input type="checkbox" id="c-36915491" checked=""/><div class="controls bullet"><span class="by">commonlisp94</span><span>|</span><a href="#36915394">parent</a><span>|</span><a href="#36917873">next</a><span>|</span><label class="collapse" for="c-36915491">[-]</label><label class="expand" for="c-36915491">[9 more]</label></div><br/><div class="children"><div class="content">Exactly. I think a lot of the negativity about GIL comes from a misunderstanding about forking processes. If python is being used as a scripting language, and spawning other tools, you&#x27;re already getting free multi-core.<p>A similar misunderstanding exists about SQLite and concurrency.. but that&#x27;s a topic for another time.</div><br/><div id="36917948" class="c"><input type="checkbox" id="c-36917948" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36915491">parent</a><span>|</span><a href="#36917778">next</a><span>|</span><label class="collapse" for="c-36917948">[-]</label><label class="expand" for="c-36917948">[6 more]</label></div><br/><div class="children"><div class="content">&gt; you&#x27;re already getting free multi-core.<p>Please explain: In what sense is the overhead of starting actual OS processes, and relying on IPC &quot;free&quot;, compared to running threads or even greenlets, and using shared process memory?</div><br/><div id="36918093" class="c"><input type="checkbox" id="c-36918093" checked=""/><div class="controls bullet"><span class="by">csmpltn</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36917948">parent</a><span>|</span><a href="#36917778">next</a><span>|</span><label class="collapse" for="c-36918093">[-]</label><label class="expand" for="c-36918093">[5 more]</label></div><br/><div class="children"><div class="content">&gt; In what sense is the overhead of starting actual OS processes, and relying on IPC &quot;free&quot;<p>With Python&#x27;s current multiprocessing utilities - you get a big discount by not having to write thread-safe code, or worry about synchronization, despite the GIL still being there. Very broadly speaking, it&#x27;s &quot;free&quot; in the sense that the OS handles parallelism automatically at the process-level, and provides a simple communication mechanism between those processes through standard APIs. It also reduces potential attack surfaces (although this is a lesser argument).<p>It&#x27;s also &quot;free&quot; in the sense that you don&#x27;t need to re-write large parts of the VM, as-well as all supported libraries, and teach the entire Python community how to safely write and test multi-threaded code (something I bet upwards of 75% of the people using Python today won&#x27;t manage) to support this specific form of parallelism.<p>If your goal is to run code (whether IO bound or CPU bound) in parallel - Python has the means to do that already today, without removing the GIL.</div><br/><div id="36918169" class="c"><input type="checkbox" id="c-36918169" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36918093">parent</a><span>|</span><a href="#36917778">next</a><span>|</span><label class="collapse" for="c-36918169">[-]</label><label class="expand" for="c-36918169">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s &quot;free&quot; in the sense that you don&#x27;t need to re-write large parts of the VM<p>In that sense, never updating python again is &quot;free&quot; as well, because it would save the python devs the trouble of changing the interpreter. And yet I think we can all agree that Python benefits from the fact that we no longer use Python 3.5<p>&gt; and teach the entire Python community how to safely write multi-threaded code<p>People who don&#x27;t write threaded code don&#x27;t need to worry about it. And people who write threaded code in python already need to worry about writing thread-safe code. The GIL doesn&#x27;t prevent race conditions between individual python instructions.<p>&gt; Python has the means to do that already<p>And as outlined above, these means are no suitable replacement for true thread based parallelism.</div><br/><div id="36918275" class="c"><input type="checkbox" id="c-36918275" checked=""/><div class="controls bullet"><span class="by">csmpltn</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36918169">parent</a><span>|</span><a href="#36918305">next</a><span>|</span><label class="collapse" for="c-36918275">[-]</label><label class="expand" for="c-36918275">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;And as outlined above, these means are no suitable replacement for true thread based parallelism.&quot;<p>Your only argument is that &quot;thread-based parallelism can&#x27;t be achieved without threads&quot;, but that&#x27;s not relevant to the conversation whatsoever.<p>The fact of the matter is that Python (already today) allows you to achieve parallelism across both IO-bound and CPU-bound workloads.<p>For CPU-bound workloads, the number of threads you can run in parallel is bound by the number of cores you have. For IO-bound workloads, your threads are just waiting on interrupts.<p>What are concrete use-cases where thread-based parallelism in Python is so desperately needed right now, that can&#x27;t be achieved through process-based parallelism?<p>I&#x27;ll give you one: real-time latency&#x2F;throughput-sensitive DSP. Think real-time audio processing, or real-time algorithmic trading. Python isn&#x27;t used there to begin with (for an entire flurry of reasons) - GIL or no GIL.</div><br/></div></div><div id="36918305" class="c"><input type="checkbox" id="c-36918305" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36918169">parent</a><span>|</span><a href="#36918275">prev</a><span>|</span><a href="#36918297">next</a><span>|</span><label class="collapse" for="c-36918305">[-]</label><label class="expand" for="c-36918305">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The GIL doesn&#x27;t prevent race conditions between individual python instructions<p>Yes it does. Unless we mean something different?</div><br/></div></div><div id="36918297" class="c"><input type="checkbox" id="c-36918297" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36918169">parent</a><span>|</span><a href="#36918305">prev</a><span>|</span><a href="#36917778">next</a><span>|</span><label class="collapse" for="c-36918297">[-]</label><label class="expand" for="c-36918297">[1 more]</label></div><br/><div class="children"><div class="content">Progress in the name if progress is rarely a good choice.<p>The key question that remains unanswered is<p>Why should Python even need a free threading model?<p>There are no good answers afaik.</div><br/></div></div></div></div></div></div></div></div><div id="36917778" class="c"><input type="checkbox" id="c-36917778" checked=""/><div class="controls bullet"><span class="by">kzrdude</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36915491">parent</a><span>|</span><a href="#36917948">prev</a><span>|</span><a href="#36917643">next</a><span>|</span><label class="collapse" for="c-36917778">[-]</label><label class="expand" for="c-36917778">[1 more]</label></div><br/><div class="children"><div class="content">Another new feature for 3.12 is per-subinterpreter GIL which is a middle ground. It would offer isolated interpreter threads without gil.</div><br/></div></div><div id="36917643" class="c"><input type="checkbox" id="c-36917643" checked=""/><div class="controls bullet"><span class="by">AlphaSite</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36915491">parent</a><span>|</span><a href="#36917778">prev</a><span>|</span><a href="#36917873">next</a><span>|</span><label class="collapse" for="c-36917643">[-]</label><label class="expand" for="c-36917643">[1 more]</label></div><br/><div class="children"><div class="content">Forking had a ton of its own downsides, it’s not a free lunch either, from poor ergonomics to communications overhead it works well for somethings and very poorly for others.</div><br/></div></div></div></div><div id="36917873" class="c"><input type="checkbox" id="c-36917873" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#36915394">parent</a><span>|</span><a href="#36915491">prev</a><span>|</span><a href="#36915705">next</a><span>|</span><label class="collapse" for="c-36917873">[-]</label><label class="expand" for="c-36917873">[1 more]</label></div><br/><div class="children"><div class="content">Python gets an absolute kicking for being too slow relative to basically everything else and that performance characteristic is partially attributed to the interpreter lock. Misattributed in my opinion, but there we are.</div><br/></div></div><div id="36915705" class="c"><input type="checkbox" id="c-36915705" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915394">parent</a><span>|</span><a href="#36917873">prev</a><span>|</span><a href="#36917938">next</a><span>|</span><label class="collapse" for="c-36915705">[-]</label><label class="expand" for="c-36915705">[2 more]</label></div><br/><div class="children"><div class="content">Yep I think over the next year a lot of python devs are going to learn threading isn&#x27;t magic pixie dust that makes your code fast, and in reality is starts by making your code very unstable.</div><br/><div id="36915777" class="c"><input type="checkbox" id="c-36915777" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36915705">parent</a><span>|</span><a href="#36917938">next</a><span>|</span><label class="collapse" for="c-36915777">[-]</label><label class="expand" for="c-36915777">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m afraid that&#x27;s exactly what will happen. Unfortunately the overarching sentiment will not be &quot;multithreading is hard&quot; but &quot;Python has become really hard to work with&quot;</div><br/></div></div></div></div><div id="36917938" class="c"><input type="checkbox" id="c-36917938" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915394">parent</a><span>|</span><a href="#36915705">prev</a><span>|</span><a href="#36917618">next</a><span>|</span><label class="collapse" for="c-36917938">[-]</label><label class="expand" for="c-36917938">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Parallelize at the fork level<p>IPC is a PITA, and orchestrating processes is even worse.<p>&gt; or at the isolated numeric library level<p>Not everything I want to parallelise in python runs in numpy. Simple example: WebService Backends. I have a 64 core server running a Werkzeug&#x2F;Gunicorn application. The Service is mostly doing CPU bound tasks (data aggregation and analysis), so asyncio is pointless.<p>What happens is, it runs 60 worker processes. Which puts hefty limitations on any crosstalk and data sharing, because these either require IPC, or using redis&#x2F;sql. Which are nowhere near as performant as actually shared memory would be.</div><br/><div id="36918152" class="c"><input type="checkbox" id="c-36918152" checked=""/><div class="controls bullet"><span class="by">seanthemon</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36917938">parent</a><span>|</span><a href="#36917618">next</a><span>|</span><label class="collapse" for="c-36918152">[-]</label><label class="expand" for="c-36918152">[1 more]</label></div><br/><div class="children"><div class="content">Exactly my thinking, using more cores is exactly your use case and will hopefully make Python superb at large scale data processing with cross-communication.<p>I think, rightfully, the concern is people who will try to use this incorrectly causing major bloat to CPython.</div><br/></div></div></div></div><div id="36917618" class="c"><input type="checkbox" id="c-36917618" checked=""/><div class="controls bullet"><span class="by">r0l1</span><span>|</span><a href="#36915394">parent</a><span>|</span><a href="#36917938">prev</a><span>|</span><a href="#36917496">next</a><span>|</span><label class="collapse" for="c-36917618">[-]</label><label class="expand" for="c-36917618">[3 more]</label></div><br/><div class="children"><div class="content">We are working with a huge Go and Python codebase and Python is just a pain in terms of using all system resources. We moved many parts to C++ which are called and handled by goroutines. The outcome was a big success.
This proposal&#x2F;change is a big step forward, especially for the deep learning community.</div><br/><div id="36917691" class="c"><input type="checkbox" id="c-36917691" checked=""/><div class="controls bullet"><span class="by">csmpltn</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36917618">parent</a><span>|</span><a href="#36917496">next</a><span>|</span><label class="collapse" for="c-36917691">[-]</label><label class="expand" for="c-36917691">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;Python is just a pain in terms of using all system resources&quot;<p>Whatever this comment means (I honestly can&#x27;t properly tell) - removing the GIL will have absolutely no impact on Python&#x27;s resource utilization.</div><br/><div id="36918276" class="c"><input type="checkbox" id="c-36918276" checked=""/><div class="controls bullet"><span class="by">r0l1</span><span>|</span><a href="#36915394">root</a><span>|</span><a href="#36917691">parent</a><span>|</span><a href="#36917496">next</a><span>|</span><label class="collapse" for="c-36918276">[-]</label><label class="expand" for="c-36918276">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;</a><p>Quote: &quot;In PyTorch, Python is commonly used to orchestrate ~8 GPUs and ~64 CPU threads, growing to 4k GPUs and 32k CPU threads for big models. While the heavy lifting is done outside of Python, the speed of GPUs makes even just the orchestration in Python not scalable. We often end up with 72 processes in place of one because of the GIL. Logging, debugging, and performance tuning are orders-of-magnitude more difficult in this regime, continuously causing lower developer productivity.&quot;<p>Quote: &quot;We frequently battle issues with the Python GIL at DeepMind. In many of our applications, we would like to run on the order of 50-100 threads per process. However, we often see that even with fewer than 10 threads the GIL becomes the bottleneck. To work around this problem, we sometimes use subprocesses, but in many cases the inter-process communication becomes too big of an overhead. To deal with the GIL, we usually end up translating large parts of our Python codebase into C++. This is undesirable because it makes the code less accessible to researchers.&quot;</div><br/></div></div></div></div></div></div><div id="36917496" class="c"><input type="checkbox" id="c-36917496" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36915394">parent</a><span>|</span><a href="#36917618">prev</a><span>|</span><a href="#36915519">next</a><span>|</span><label class="collapse" for="c-36917496">[-]</label><label class="expand" for="c-36917496">[1 more]</label></div><br/><div class="children"><div class="content">Well, multithreading in C or Java makes sense because it&#x27;s the only way to increase performance if you&#x27;ve already optimised the single threaded case.<p>In Python there&#x27;s a much better option if you care about performance - use a different language!</div><br/></div></div></div></div><div id="36918166" class="c"><input type="checkbox" id="c-36918166" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#36915394">prev</a><span>|</span><a href="#36914880">next</a><span>|</span><label class="collapse" for="c-36918166">[-]</label><label class="expand" for="c-36918166">[1 more]</label></div><br/><div class="children"><div class="content">Thank you so much Python core developers and steering council. Python is one of my favourite languages along with Java and C.<p>I greatly welcome true multithreading in Python.<p>I use both multiprocessing and multithreading in Python for different projects. See [0] for my multiprocessing example and python Threads for IO heavy tasks in [1]. But it would be far more efficient to use true threads.<p>Threads can communicate any amount of data in a single atomic almost instant operation. Using the local loopback interface or multiprocessing or pipes, this is not possible.<p>I am working on a multithreading architecture I call three tier multithreading architecture<p><a href="https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;three-tier-multithreaded-architecture">https:&#x2F;&#x2F;github.com&#x2F;samsquire&#x2F;three-tier-multithreaded-archit...</a><p>My goal is extremely scalable and performant servers but Python is probably the wrong job for that.<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36897054">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36897054</a> (my description of my use of multiprocessing)
[1]: <a href="https:&#x2F;&#x2F;devops-pipeline.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;devops-pipeline.com&#x2F;</a> (my use of multithreading)</div><br/></div></div><div id="36914880" class="c"><input type="checkbox" id="c-36914880" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36918166">prev</a><span>|</span><a href="#36914451">next</a><span>|</span><label class="collapse" for="c-36914880">[-]</label><label class="expand" for="c-36914880">[45 more]</label></div><br/><div class="children"><div class="content">Unpopular opinion: This is a missed opportunity.<p>What?<p>Python could have been the one language with a sane multithreading model. Now it risks becoming a second version of Java. I fear this will make it a less attractive programming language, not least because it might lose its beginner friendlyness. For example, without the GIL a lot more care must be put into designing your programs. This can be true even though your own code is single threaded, for example when you use a library that is multithreaded and has callbacks to your code<p>Why?<p>Free threading as introduced by PEP 703 is well known to be errorprone, hard to get right and generally advised against, unless you know exactly what you are doing. In other words free threading is for expert (as in very experienced) use only. And Python already has an expert mode - called Cython oer Numba to name just two.<p>Personally I can see no good will come from bringing free threading to the masses. Yes it addresses a common critique (by many) and need (by very few), but it addresses it in a very risky way (for the vast majority of Python users).<p>A better alternative<p>IMHO the far better and still my preferred approach would have been to favor a per-thread GIL with an explicit mode to share particular objects. This would benefit everyone without the risks. It would be consistenly beginner friendly, and above all, offer a safe path to concurrent programming without impacting the whole ecosystem. Heck we could even call it the &quot;Pythonic Threading Model&quot;, and it would be seen as a differentiator.</div><br/><div id="36915102" class="c"><input type="checkbox" id="c-36915102" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36915528">next</a><span>|</span><label class="collapse" for="c-36915102">[-]</label><label class="expand" for="c-36915102">[4 more]</label></div><br/><div class="children"><div class="content">The GIL does very little to protect unexperienced users. It&#x27;s still really easy to run into race conditions, for example, if your thread gets scheduled out in any multi-instruction operation (this is more common than you think [1]). In general, Python code still has to be thread-safe; you get the risks without the benefits.<p>If you don&#x27;t care about CPU performance, instead of threads you should go for an event-loop approach (see asyncio in Python). As soon as you have threads (on a language-level, not implementation-level), there is some notion of implicit switching, and you run into issues. So, the language you&#x27;re looking for is JavaScript, which is single-threaded and every context switch is explicit (in form of `await` or `yield`).<p>[1] <a href="https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;python-data-races" rel="nofollow noreferrer">https:&#x2F;&#x2F;verdagon.dev&#x2F;blog&#x2F;python-data-races</a></div><br/><div id="36915244" class="c"><input type="checkbox" id="c-36915244" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915102">parent</a><span>|</span><a href="#36916577">next</a><span>|</span><label class="collapse" for="c-36915244">[-]</label><label class="expand" for="c-36915244">[1 more]</label></div><br/><div class="children"><div class="content">&gt; this is more common than you think<p>Like, for example,<p><pre><code>  count += 1
</code></pre>
---<p>The GIL primarily protects C code, not Python code.</div><br/></div></div><div id="36916577" class="c"><input type="checkbox" id="c-36916577" checked=""/><div class="controls bullet"><span class="by">asvitkine</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915102">parent</a><span>|</span><a href="#36915244">prev</a><span>|</span><a href="#36915528">next</a><span>|</span><label class="collapse" for="c-36916577">[-]</label><label class="expand" for="c-36916577">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the blog you cite backs up your claim of &quot;it&#x27;s still really easy to run into race conditions&quot;.<p>The author literally says: &quot;This was actually pretty hard to discover. The first few experiments failed, because Python is pretty smart about when it runs each thread.&quot;<p>But I think the main way the GIL protects inexperienced users is that its presence has the effect that Python code using the threading APIs is very uncommon, since those APIs don&#x27;t currently provide parallel computation (only parallel IO). So inexperienced users are protected due to 99% of Python programs not using multithreading as a result (and so likely the one they&#x27;re developing also doesn&#x27;t), whereas this will presumably change when the limitations imposed by the GIL go away.</div><br/><div id="36917494" class="c"><input type="checkbox" id="c-36917494" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36916577">parent</a><span>|</span><a href="#36915528">next</a><span>|</span><label class="collapse" for="c-36917494">[-]</label><label class="expand" for="c-36917494">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t think the blog you cite backs up your claim of &quot;it&#x27;s still really easy to run into race conditions&quot;.<p>&gt; The author literally says: &quot;This was actually pretty hard to discover. The first few experiments failed, because Python is pretty smart about when it runs each thread.&quot;<p>I completely disagree here with your reading.  <i>Rare</i> race conditions are much worse than races you trip over frequently.</div><br/></div></div></div></div></div></div><div id="36915528" class="c"><input type="checkbox" id="c-36915528" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36915102">prev</a><span>|</span><a href="#36915043">next</a><span>|</span><label class="collapse" for="c-36915528">[-]</label><label class="expand" for="c-36915528">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite get your &quot;unpopular opinion&quot;.<p>First, I don&#x27;t see how the GIL would have much to do with free multithreading. The GIL should not have much observable logical impact on multithreaded _Python_ code. It should not make it more or less susceptible to race conditions. It&#x27;s only practical impact should be slowness.<p>Second, your proposed &quot;one GIL per thread&quot; is pretty much the equivalent of the current state of multiprocessing. In that you fork your current interpreter state in an other thread with it&#x27;s own GIL and start from there. This has been used for decades already, nothing new there. Sharing can be done through queues or shared memory.</div><br/><div id="36915643" class="c"><input type="checkbox" id="c-36915643" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915528">parent</a><span>|</span><a href="#36915656">next</a><span>|</span><label class="collapse" for="c-36915643">[-]</label><label class="expand" for="c-36915643">[4 more]</label></div><br/><div class="children"><div class="content">Yes, used for decades - and for good reason and benefit.<p>No, no the same thing. Sharing objects between processes is not easily achieved for various reasons (at least in Python). It would be easier to get it in multithreading with an arena based allocation model where objects live in a shared or non-shared area of memory.<p>Also it&#x27;s not my idea. I am just advocating it as the better model for Python to advance to. It would also not take years to implement and the risks are minimized as there is full compatibility with existing code.</div><br/><div id="36916128" class="c"><input type="checkbox" id="c-36916128" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915643">parent</a><span>|</span><a href="#36915656">next</a><span>|</span><label class="collapse" for="c-36916128">[-]</label><label class="expand" for="c-36916128">[3 more]</label></div><br/><div class="children"><div class="content">&gt; No, no the same thing.<p>Well to me it is the same thing.<p>Two threads sharing state through a common heap, or two processes sharing state through a shared memory is pretty much indistinguishable, at least on Linux.<p>The question is not multithreading or multiprocessing anymore, the difference to me is more semantic than real.<p>The question is then just how these threads&#x2F;processes communicate.<p>I would argue that shared mutable state is rarely a good idea, and an equivalent message based system is often preferable.<p>For the few use cases that remain where you would want shared mutable states, as mentioned in my original answer, Python has shared memory support, though with non-built-in types. Improving these shared types should be the only thing you advocate for.</div><br/><div id="36916930" class="c"><input type="checkbox" id="c-36916930" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36916128">parent</a><span>|</span><a href="#36917665">next</a><span>|</span><label class="collapse" for="c-36916930">[-]</label><label class="expand" for="c-36916930">[1 more]</label></div><br/><div class="children"><div class="content">Right now, you often get stuck on using multiprocessing because you need to share one object that is unpickleable and can&#x27;t be sent over queues.<p>Improving shared types would be a great addition. Problem is the reason for objects being unpicklable in the first place, is often a more underlying thing that can&#x27;t be shared across processes, like open file handles.</div><br/></div></div><div id="36917665" class="c"><input type="checkbox" id="c-36917665" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36916128">parent</a><span>|</span><a href="#36916930">prev</a><span>|</span><a href="#36915656">next</a><span>|</span><label class="collapse" for="c-36917665">[-]</label><label class="expand" for="c-36917665">[1 more]</label></div><br/><div class="children"><div class="content">I agree, actually.<p>It&#x27;s just that (some) people really want multithreading. And with that Python had the rare chance to say, ok you&#x27;ll get it, but we will make it safe by default.<p>Now they said ok you get it, even though it&#x27;s a big risk, we hope it&#x27;ll work. If not, we&#x27;ll  take it back.<p>In what world is &quot;taking back&quot; even an option?</div><br/></div></div></div></div></div></div><div id="36915656" class="c"><input type="checkbox" id="c-36915656" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915528">parent</a><span>|</span><a href="#36915643">prev</a><span>|</span><a href="#36916001">next</a><span>|</span><label class="collapse" for="c-36915656">[-]</label><label class="expand" for="c-36915656">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, multiprocessing with pipes &#x2F; queues and sometimes areas of shared memory is a pretty sane way to do <i>parallel processing</i>, when more than one CPU core works for you at once. It&#x27;s pretty ergonomic, and it&#x27;s largely equivalent to Node&#x27;s workers.<p>It has nothing to do with multithreading or GIL, though, and happily works without threads and with GIL in place.</div><br/></div></div><div id="36916001" class="c"><input type="checkbox" id="c-36916001" checked=""/><div class="controls bullet"><span class="by">TX81Z</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915528">parent</a><span>|</span><a href="#36915656">prev</a><span>|</span><a href="#36915043">next</a><span>|</span><label class="collapse" for="c-36916001">[-]</label><label class="expand" for="c-36916001">[1 more]</label></div><br/><div class="children"><div class="content">Queues are a HUGE pain in the arse though.</div><br/></div></div></div></div><div id="36915043" class="c"><input type="checkbox" id="c-36915043" checked=""/><div class="controls bullet"><span class="by">superjared</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36915528">prev</a><span>|</span><a href="#36915005">next</a><span>|</span><label class="collapse" for="c-36915043">[-]</label><label class="expand" for="c-36915043">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Personally I can see no good will come from bringing free threading to the masses<p>I’ve often thought that proper threading should be learned by the masses, not to be scared of it. This sort of statement does nothing but spread FUD.</div><br/><div id="36915630" class="c"><input type="checkbox" id="c-36915630" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915043">parent</a><span>|</span><a href="#36917935">next</a><span>|</span><label class="collapse" for="c-36915630">[-]</label><label class="expand" for="c-36915630">[1 more]</label></div><br/><div class="children"><div class="content">It’s virtually impossible to do free threading safely, especially with large codebases developed by multiple people. This includes tiny Python scripts that pull in a bunch of dependencies.<p>It’s like saying that C is a safe language, just “get good” at it.<p>There are safe alternatives such as structured concurrency.</div><br/></div></div><div id="36917935" class="c"><input type="checkbox" id="c-36917935" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915043">parent</a><span>|</span><a href="#36915630">prev</a><span>|</span><a href="#36915243">next</a><span>|</span><label class="collapse" for="c-36917935">[-]</label><label class="expand" for="c-36917935">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’ve often thought that proper threading should be learned by the masses, not to be scared of it.<p>... or at least it should be public knowledge that anything prefixed with &quot;async&quot; is windows 3.1 multitasking from the 90s...<p>Why are we getting 64+ core servers to run single threaded cooperative multitasking on them? :)</div><br/></div></div><div id="36915243" class="c"><input type="checkbox" id="c-36915243" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915043">parent</a><span>|</span><a href="#36917935">prev</a><span>|</span><a href="#36915005">next</a><span>|</span><label class="collapse" for="c-36915243">[-]</label><label class="expand" for="c-36915243">[8 more]</label></div><br/><div class="children"><div class="content">How do you suggest we could teach proper threading (what is that?) to the masses?</div><br/><div id="36915368" class="c"><input type="checkbox" id="c-36915368" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915243">parent</a><span>|</span><a href="#36915005">next</a><span>|</span><label class="collapse" for="c-36915368">[-]</label><label class="expand" for="c-36915368">[7 more]</label></div><br/><div class="children"><div class="content">Rust is a brilliant lesson in using traditional threading safely. It uses &amp; for thread-shared types and constrains &amp;mut to a single thread, which naturally causes people to keep single-threaded data on an object only accessible from a single thread, and make multithreaded data either immutable, mutex-protected, or atomic.<p>Alternatively, message-passing isn&#x27;t traditional threading, but Erlang&#x2F;Go-style languages are another way to approach concurrency or parallelism.</div><br/><div id="36916473" class="c"><input type="checkbox" id="c-36916473" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915368">parent</a><span>|</span><a href="#36917959">next</a><span>|</span><label class="collapse" for="c-36916473">[-]</label><label class="expand" for="c-36916473">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite see how Rust approach to multithreading is that amazing.<p>Rust does nothing to magically prevent race conditions for you. Rust safety does not encompass race conditions, starvation, etc.<p>What it does is defensively prevent you from sharing mutable variables without explicitly opting for it.<p>It&#x27;s good for catching careless sharing issues, but not much more.</div><br/><div id="36917004" class="c"><input type="checkbox" id="c-36917004" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36916473">parent</a><span>|</span><a href="#36917959">next</a><span>|</span><label class="collapse" for="c-36917004">[-]</label><label class="expand" for="c-36917004">[2 more]</label></div><br/><div class="children"><div class="content">In my experience with multi-threaded programming, C++ code with &quot;careless sharing issues&quot; is often filled with multiple threads accessing the same object and relying on convention to avoid calling the wrong thread&#x27;s methods, pervasive data races and unsynchronized variable access, mistaken use of mutexes on only one side of shared memory, and logical race conditions that require adding mutexes (risking deadlock) or rewriting code to address. Whereas Rust code tends to not have these issues to begin with (outside of the implementation of synchronization primitives), store reader and writer methods on separate handle objects, use Arc to manage cross-thread shared memory, and similar which makes the code either correct or tractable to learn and make correct.<p>I also struggle to understand the threading model of COM and C libraries like libusb (<a href="https:&#x2F;&#x2F;libusb.sourceforge.io&#x2F;api-1.0&#x2F;libusb_mtasync.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;libusb.sourceforge.io&#x2F;api-1.0&#x2F;libusb_mtasync.html</a>), though that might just be me, and each library tends to have a different threading model. Rust&#x27;s Send&#x2F;Sync is a 90% solution which you can learn upfront, is checked by the compiler, and applies to all libraries and works for most use cases.</div><br/><div id="36917360" class="c"><input type="checkbox" id="c-36917360" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36917004">parent</a><span>|</span><a href="#36917959">next</a><span>|</span><label class="collapse" for="c-36917360">[-]</label><label class="expand" for="c-36917360">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience with multi-threaded programming, C++ code with &quot;careless sharing issues&quot; is often filled with multiple threads accessing the same object and relying on convention to avoid calling the wrong thread&#x27;s methods<p>Right, I can see the kind of codebase you&#x27;re referring to.<p>I don&#x27;t see Rust as a magical weapon solving concurrency issues though. Namely because Rust (the compiler) has a very limited view of what happens in the lifetime of a multithreaded system, and no view at all of the lifetime of a multiprocess system.<p>Even when writing purely single threaded Rust, you quickly end up having to let go of the strictly static memory sharing checks and switch to dynamic ones.<p>I have yet to find a use case where Rust solves anything but the most blatant synchronization issues.</div><br/></div></div></div></div></div></div><div id="36917959" class="c"><input type="checkbox" id="c-36917959" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915368">parent</a><span>|</span><a href="#36916473">prev</a><span>|</span><a href="#36916951">next</a><span>|</span><label class="collapse" for="c-36917959">[-]</label><label class="expand" for="c-36917959">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Alternatively, message-passing isn&#x27;t traditional threading, but Erlang&#x2F;Go-style languages are another way to approach concurrency or parallelism.<p>Qt signals&#x2F;slots across threads is also message passing. Transparent to boot. Too bad you need to afford a lawyer on retainer to use it these days.</div><br/></div></div><div id="36916951" class="c"><input type="checkbox" id="c-36916951" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915368">parent</a><span>|</span><a href="#36917959">prev</a><span>|</span><a href="#36915685">next</a><span>|</span><label class="collapse" for="c-36916951">[-]</label><label class="expand" for="c-36916951">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;marker&#x2F;trait.Send.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;marker&#x2F;trait.Send.html</a></div><br/></div></div><div id="36915685" class="c"><input type="checkbox" id="c-36915685" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915368">parent</a><span>|</span><a href="#36916951">prev</a><span>|</span><a href="#36915005">next</a><span>|</span><label class="collapse" for="c-36915685">[-]</label><label class="expand" for="c-36915685">[1 more]</label></div><br/><div class="children"><div class="content">Great examples. Unfortunately that&#x27;s not what the Python SC has decided to go for.</div><br/></div></div></div></div></div></div></div></div><div id="36915005" class="c"><input type="checkbox" id="c-36915005" checked=""/><div class="controls bullet"><span class="by">banthar</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36915043">prev</a><span>|</span><a href="#36914908">next</a><span>|</span><label class="collapse" for="c-36915005">[-]</label><label class="expand" for="c-36915005">[1 more]</label></div><br/><div class="children"><div class="content">You can pin your JVM process to a single core and will effectively get Python multithreading model.</div><br/></div></div><div id="36914908" class="c"><input type="checkbox" id="c-36914908" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36915005">prev</a><span>|</span><a href="#36915316">next</a><span>|</span><label class="collapse" for="c-36914908">[-]</label><label class="expand" for="c-36914908">[3 more]</label></div><br/><div class="children"><div class="content">Why convince you otherwise? You&#x27;re the one with the weird opinion, you should be convincing us.</div><br/><div id="36915154" class="c"><input type="checkbox" id="c-36915154" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36914908">parent</a><span>|</span><a href="#36915316">next</a><span>|</span><label class="collapse" for="c-36915154">[-]</label><label class="expand" for="c-36915154">[2 more]</label></div><br/><div class="children"><div class="content">Heads-up, the parent edited their comment to remove that sentence and added some &quot;convincing&quot; instead, so that&#x27;s why your comment looks out of place.</div><br/><div id="36915515" class="c"><input type="checkbox" id="c-36915515" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915154">parent</a><span>|</span><a href="#36915316">next</a><span>|</span><label class="collapse" for="c-36915515">[-]</label><label class="expand" for="c-36915515">[1 more]</label></div><br/><div class="children"><div class="content">oh, lol. thanks. guess they agreed with me!</div><br/></div></div></div></div></div></div><div id="36915316" class="c"><input type="checkbox" id="c-36915316" checked=""/><div class="controls bullet"><span class="by">veave</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36914908">prev</a><span>|</span><a href="#36916809">next</a><span>|</span><label class="collapse" for="c-36915316">[-]</label><label class="expand" for="c-36915316">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Free threading as introduced by PEP 703 is well known to be errorprone, hard to get right and generally advised against, unless you know exactly what you are doing.<p>You should hear about async...</div><br/><div id="36915345" class="c"><input type="checkbox" id="c-36915345" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915316">parent</a><span>|</span><a href="#36916809">next</a><span>|</span><label class="collapse" for="c-36915345">[-]</label><label class="expand" for="c-36915345">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. You should hear my opinions on async (in Python).<p>;)</div><br/></div></div></div></div><div id="36916809" class="c"><input type="checkbox" id="c-36916809" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36915316">prev</a><span>|</span><a href="#36916165">next</a><span>|</span><label class="collapse" for="c-36916809">[-]</label><label class="expand" for="c-36916809">[1 more]</label></div><br/><div class="children"><div class="content">&gt; my preferred approach would have been to favor a per-thread GIL with an explicit mode to share particular objects.<p>From what I understand, this is how threading worked in perl. But that functionality is now &quot;discouraged&quot;.<p>I do think that would have been a good way to do it. Especially with an emphasis on message passing.</div><br/></div></div><div id="36916165" class="c"><input type="checkbox" id="c-36916165" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36916809">prev</a><span>|</span><a href="#36916078">next</a><span>|</span><label class="collapse" for="c-36916165">[-]</label><label class="expand" for="c-36916165">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn’t that require running an interpreter in each thread? How on earth could that be a “sane multi threading model”?<p>&gt;offer a safe path to concurrent programming<p>Uh, doesn’t Python support this already? Python has “concurrency” from async and parallelism from multiprocessing. What it doesn’t support is thread-based parallelism. What you’re suggesting (if I understand it) is an implementation of parallelism that is barely different at all from the typical Python parallelism approach of using multiprocessing to achieve parallelism.</div><br/></div></div><div id="36916078" class="c"><input type="checkbox" id="c-36916078" checked=""/><div class="controls bullet"><span class="by">schneems</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36916165">prev</a><span>|</span><a href="#36915869">next</a><span>|</span><label class="collapse" for="c-36916078">[-]</label><label class="expand" for="c-36916078">[2 more]</label></div><br/><div class="children"><div class="content">&gt; IMHO the far better and still my preferred approach would have been to favor a per-thread GIL with an explicit mode to share particular objects.<p>You just described Ractors in Ruby, which didn’t turn out great. The setup cost for either freezing or copying memory to the target ractor to guarantee memory safety is often higher than the perf gains of the parallelism.<p>Not that it can’t work or won’t be improved. But there is a real world case study of what you’re recommending that we can reference without having to guess.</div><br/><div id="36917861" class="c"><input type="checkbox" id="c-36917861" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36916078">parent</a><span>|</span><a href="#36915869">next</a><span>|</span><label class="collapse" for="c-36917861">[-]</label><label class="expand" for="c-36917861">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this. I&#x27;ll read up on that. Any good links pointers to start?</div><br/></div></div></div></div><div id="36915869" class="c"><input type="checkbox" id="c-36915869" checked=""/><div class="controls bullet"><span class="by">xerxes901</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36916078">prev</a><span>|</span><a href="#36915441">next</a><span>|</span><label class="collapse" for="c-36915869">[-]</label><label class="expand" for="c-36915869">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a per-thread GIL with an explicit mode to share particular objects<p>This is like Ruby&#x27;s Ractors and I haven&#x27;t really seen that be super successful so far. The &quot;Objects&quot; that need to be shared are things like class definitions, etc.... there are a ton of subtle issues with objects that are being marked as sharable when they should really not be or vice versa.</div><br/></div></div><div id="36915441" class="c"><input type="checkbox" id="c-36915441" checked=""/><div class="controls bullet"><span class="by">Phil_Latio</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36915869">prev</a><span>|</span><a href="#36915213">next</a><span>|</span><label class="collapse" for="c-36915441">[-]</label><label class="expand" for="c-36915441">[4 more]</label></div><br/><div class="children"><div class="content">&gt; sane multithreading<p>It&#x27;s simply not &quot;sane multithreading&quot; not being able to run Python (byte)code concurrently. It&#x27;s just a huge annoyance.<p>&gt; because it might lose its beginner friendlyness<p>Python is not beginner friendly. It has one of the worst documentations out there. Also it does things very different compared to other languages (C#, PHP, Java, JS, ...) - I would advise anyone against learning Python as their first language, while Python is my favorite language.<p>&gt; And Python already has an expert mode - called Cython oer Numba to name just two.<p>CPython is the &quot;official&quot; Python. How is it beneficial to depend on some 3rd party projects? I don&#x27;t want to use such projects.<p>As to the PEP itself: It&#x27;s optional, with the GIL being enabled by the default. So what&#x27;s the problem...</div><br/><div id="36915530" class="c"><input type="checkbox" id="c-36915530" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915441">parent</a><span>|</span><a href="#36915213">next</a><span>|</span><label class="collapse" for="c-36915530">[-]</label><label class="expand" for="c-36915530">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s simply not &quot;sane multithreading&quot; not being able to run Python (byte)code concurrentltly<p>Please read my post again. I am advocating a GIL per-thread model with an explicit feature for sharing selected objects. This allows for all cores concurrency, essentially like free threading yet with safeguards. I like to call that a sane way because it builds on decades of research and industry experience of the software engineering community.<p>&gt; As to the PEP itself: It&#x27;s optional, with the GIL being enabled by the default.<p>It&#x27;s not optional if you build tools and libraries that need be able to run with both gil and no-gil.</div><br/><div id="36915766" class="c"><input type="checkbox" id="c-36915766" checked=""/><div class="controls bullet"><span class="by">Phil_Latio</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915530">parent</a><span>|</span><a href="#36915213">next</a><span>|</span><label class="collapse" for="c-36915766">[-]</label><label class="expand" for="c-36915766">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I am advocating a GIL per-thread model with an explicit feature for sharing selected objects<p>Is there a PEP or something written about it? I don&#x27;t like this idea at first glance. Feels like another hack. Though I have to admit it sounds better than the annoying multiprocessing approach.<p>&gt; It&#x27;s not optional if you build tools and libraries that need be able to run with both gil and no-gil.<p>Why do they need to? A library dev is free not support one or the other? If a library then does not provide the preferred mode of the user, then that&#x27;s bad, but that&#x27;s life. Ideally most libraries will support a gil version (that&#x27;s still the default anyway!), but provide a no-gil version as a bonus. For example, Pytorch could provide thread-based data loaders if the no-gil version is in use.</div><br/><div id="36915940" class="c"><input type="checkbox" id="c-36915940" checked=""/><div class="controls bullet"><span class="by">lmz</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915766">parent</a><span>|</span><a href="#36915213">next</a><span>|</span><label class="collapse" for="c-36915940">[-]</label><label class="expand" for="c-36915940">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; I am advocating a GIL per-thread model with an explicit feature for sharing selected objects<p>&gt; Is there a PEP or something written about it? I don&#x27;t like this idea at first glance. Feels like another hack. Though I have to admit it sounds better than the annoying multiprocessing approach.<p>This seems very similar to Perl&#x27;s ithreads model: 
<a href="https:&#x2F;&#x2F;perldoc.perl.org&#x2F;perlthrtut#Shared-And-Unshared-Data" rel="nofollow noreferrer">https:&#x2F;&#x2F;perldoc.perl.org&#x2F;perlthrtut#Shared-And-Unshared-Data</a></div><br/></div></div></div></div></div></div></div></div><div id="36915213" class="c"><input type="checkbox" id="c-36915213" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36915441">prev</a><span>|</span><a href="#36916668">next</a><span>|</span><label class="collapse" for="c-36915213">[-]</label><label class="expand" for="c-36915213">[6 more]</label></div><br/><div class="children"><div class="content">Python is already Java but worse.<p>All of the multithreading bugs without any of the multithreading performance.</div><br/><div id="36915261" class="c"><input type="checkbox" id="c-36915261" checked=""/><div class="controls bullet"><span class="by">dpedu</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915213">parent</a><span>|</span><a href="#36916668">next</a><span>|</span><label class="collapse" for="c-36915261">[-]</label><label class="expand" for="c-36915261">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not quite true. For example, most operations on lists and dicts are thread-safe in the current version of python. You can&#x27;t say that about languages with true multithreading.</div><br/><div id="36915289" class="c"><input type="checkbox" id="c-36915289" checked=""/><div class="controls bullet"><span class="by">wtetzner</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915261">parent</a><span>|</span><a href="#36916668">next</a><span>|</span><label class="collapse" for="c-36915289">[-]</label><label class="expand" for="c-36915289">[4 more]</label></div><br/><div class="children"><div class="content">Of course Java has thread safe collections in the standard library. ConcurrentHashMap etc. are popular in multithreaded contexts.</div><br/><div id="36915344" class="c"><input type="checkbox" id="c-36915344" checked=""/><div class="controls bullet"><span class="by">dpedu</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915289">parent</a><span>|</span><a href="#36915594">next</a><span>|</span><label class="collapse" for="c-36915344">[-]</label><label class="expand" for="c-36915344">[2 more]</label></div><br/><div class="children"><div class="content">The difference is that it&#x27;s a language feature in python whereas the java equivalents had to be written with locking or other approaches for handling concurrent access.</div><br/><div id="36916502" class="c"><input type="checkbox" id="c-36916502" checked=""/><div class="controls bullet"><span class="by">wtetzner</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915344">parent</a><span>|</span><a href="#36915594">next</a><span>|</span><label class="collapse" for="c-36916502">[-]</label><label class="expand" for="c-36916502">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a language feature in Python though. The GIL doesn&#x27;t automatically make code thread safe.</div><br/></div></div></div></div><div id="36915594" class="c"><input type="checkbox" id="c-36915594" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36914880">root</a><span>|</span><a href="#36915289">parent</a><span>|</span><a href="#36915344">prev</a><span>|</span><a href="#36916668">next</a><span>|</span><label class="collapse" for="c-36915594">[-]</label><label class="expand" for="c-36915594">[1 more]</label></div><br/><div class="children"><div class="content">It does, but you have to opt into them.</div><br/></div></div></div></div></div></div></div></div><div id="36916668" class="c"><input type="checkbox" id="c-36916668" checked=""/><div class="controls bullet"><span class="by">dingi</span><span>|</span><a href="#36914880">parent</a><span>|</span><a href="#36915213">prev</a><span>|</span><a href="#36914451">next</a><span>|</span><label class="collapse" for="c-36916668">[-]</label><label class="expand" for="c-36916668">[1 more]</label></div><br/><div class="children"><div class="content">I’m genuinely curious, What&#x27;s wrong with Java&#x27;s model?</div><br/></div></div></div></div><div id="36914451" class="c"><input type="checkbox" id="c-36914451" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#36914880">prev</a><span>|</span><a href="#36915721">next</a><span>|</span><label class="collapse" for="c-36914451">[-]</label><label class="expand" for="c-36914451">[4 more]</label></div><br/><div class="children"><div class="content">With PEP703 you would compile Python either for multi or single-threading mode. The mode affects the ABI and therefore which C extensions are available. Eventually all C extensions would have an available port to the new ABI.<p>The chosen solution is similar to how PHP used TSRMLS_ macros in the Zend engine - if threadsafety (ZTS) was #defined, all functions took an extra thread context parameter, breaking ABI.</div><br/><div id="36914894" class="c"><input type="checkbox" id="c-36914894" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36914451">parent</a><span>|</span><a href="#36915721">next</a><span>|</span><label class="collapse" for="c-36914894">[-]</label><label class="expand" for="c-36914894">[3 more]</label></div><br/><div class="children"><div class="content">How did it work out for PHP?</div><br/><div id="36915104" class="c"><input type="checkbox" id="c-36915104" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#36914451">root</a><span>|</span><a href="#36914894">parent</a><span>|</span><a href="#36915922">next</a><span>|</span><label class="collapse" for="c-36915104">[-]</label><label class="expand" for="c-36915104">[1 more]</label></div><br/><div class="children"><div class="content">Honestly it didn&#x27;t. PHP didn&#x27;t get threads. It did eventually get Fibers though, which I suppose may have been in part influenced by this work</div><br/></div></div><div id="36915922" class="c"><input type="checkbox" id="c-36915922" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#36914451">root</a><span>|</span><a href="#36914894">parent</a><span>|</span><a href="#36915104">prev</a><span>|</span><a href="#36915721">next</a><span>|</span><label class="collapse" for="c-36915922">[-]</label><label class="expand" for="c-36915922">[1 more]</label></div><br/><div class="children"><div class="content">The main benefit of the threadsafe builds was reentrancy support for multithreaded web servers (e.g. IIS &#x2F; some apache MPMs). They were only slightly slower for single-threaded code.<p>The new PHP 8 fibers are only coroutines on a single thread, but PHP has had fork&#x2F;join since 2001 (!), which works pretty well with Linux CoW.<p>There has been a pthreads extension since about 2012. However keeping a 1:1 pthreads API prevents some optimization possibilities [1], so the new hotness is php-parallel [2], which will transparently copy closed-over variables to a subinterpreter.<p>1. <a href="https:&#x2F;&#x2F;github.com&#x2F;krakjoe&#x2F;pthreads&#x2F;issues&#x2F;929#issue-410636734">https:&#x2F;&#x2F;github.com&#x2F;krakjoe&#x2F;pthreads&#x2F;issues&#x2F;929#issue-4106367...</a><p>2. <a href="https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;en&#x2F;philosophy.parallel.php" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;en&#x2F;philosophy.parallel.php</a></div><br/></div></div></div></div></div></div><div id="36915721" class="c"><input type="checkbox" id="c-36915721" checked=""/><div class="controls bullet"><span class="by">sheepscreek</span><span>|</span><a href="#36914451">prev</a><span>|</span><a href="#36913671">next</a><span>|</span><label class="collapse" for="c-36915721">[-]</label><label class="expand" for="c-36915721">[1 more]</label></div><br/><div class="children"><div class="content">I do most of my performance coding in Numba which comes with a nogil mode. Still, I have been looking forward to this. The fewer layers we can have in our libraries, the better!</div><br/></div></div><div id="36913671" class="c"><input type="checkbox" id="c-36913671" checked=""/><div class="controls bullet"><span class="by">willm</span><span>|</span><a href="#36915721">prev</a><span>|</span><a href="#36917952">next</a><span>|</span><label class="collapse" for="c-36913671">[-]</label><label class="expand" for="c-36913671">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m looking forward to a GIL-less Python. I think the SC&#x27;s pragmatic approach is the right one.</div><br/></div></div><div id="36917952" class="c"><input type="checkbox" id="c-36917952" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#36913671">prev</a><span>|</span><a href="#36915861">next</a><span>|</span><label class="collapse" for="c-36917952">[-]</label><label class="expand" for="c-36917952">[1 more]</label></div><br/><div class="children"><div class="content">It will be interesting to see <i>how</i> this will be executed. I think many in Ruby land wanted something similar but couldn&#x27;t get some general agreement. Ractors tried and arguably failed. We have Samuel Williams basically the one person pushing <i>very</i> hard for Async changes.<p>Ruby could learn a lot once this is done, but at the moment GIL optional in python seems to be a 2030 goal.</div><br/></div></div><div id="36915861" class="c"><input type="checkbox" id="c-36915861" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#36917952">prev</a><span>|</span><a href="#36916761">next</a><span>|</span><label class="collapse" for="c-36915861">[-]</label><label class="expand" for="c-36915861">[1 more]</label></div><br/><div class="children"><div class="content">I’m not in love with some of the details.<p>PYTHONGIL is an awkward tri-state. 0, 1, and unset all do different things. Wouldn’t some self-explanatory strings be better?  PYTHONGIL=auto for the default, force-gil and force-nogil for the forced modes.</div><br/></div></div><div id="36916761" class="c"><input type="checkbox" id="c-36916761" checked=""/><div class="controls bullet"><span class="by">pyeri</span><span>|</span><a href="#36915861">prev</a><span>|</span><a href="#36917451">next</a><span>|</span><label class="collapse" for="c-36916761">[-]</label><label class="expand" for="c-36916761">[2 more]</label></div><br/><div class="children"><div class="content">Let us wait and watch but I somehow feel that this no-GIL mode is just a band-aid solution to Python&#x27;s performance problem. The cause goes deep inside the core of Python, it gradually came to this stage as more and more features got added to the language since the 3.x transition.<p>I think new language features shouldn&#x27;t just be added to provide syntactic sugars or coding shortcuts to programmers or just because a certain feature has become very cool (like lambda functions, for eg).<p>I&#x27;m glad that the Python community has realized that performance is an issue and started working on things like no-GIL mode.<p>People often say that Python&#x27;s biggest strength is its readability and easy syntax but I disagree. Python&#x27;s real strength is the enormous third party library ecosystem, popular packages like numpy, pandas, scikit, etc. which have almost become addictive in most data science projects. But now, people are thinking of other alternatives to these due to Python&#x27;s performance issues. Other ecosystems like golang and rust are getting built at rapid pace and at some point, they will also have (more performant) equivalents of these packages if public shows enough interest.</div><br/><div id="36916849" class="c"><input type="checkbox" id="c-36916849" checked=""/><div class="controls bullet"><span class="by">ehsankia</span><span>|</span><a href="#36916761">parent</a><span>|</span><a href="#36917451">next</a><span>|</span><label class="collapse" for="c-36916849">[-]</label><label class="expand" for="c-36916849">[1 more]</label></div><br/><div class="children"><div class="content">Hasn&#x27;t python been getting much faster since 3.x? Where is your evidence that new py3 features is making python slower?</div><br/></div></div></div></div><div id="36917451" class="c"><input type="checkbox" id="c-36917451" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#36916761">prev</a><span>|</span><a href="#36916408">next</a><span>|</span><label class="collapse" for="c-36917451">[-]</label><label class="expand" for="c-36917451">[2 more]</label></div><br/><div class="children"><div class="content">Is the following possible?<p>- library author marks their library &quot;no-GIL&quot; after making sure it&#x27;s thread-safe without GIL<p>- if the interpreter sees this metainformation, it temporarily disables GIL for the current OS thread while running the library&#x27;s code<p>- result: old versions of Python can still run no-GIL libraries under GIL, while new versions of Python allow to gradually remove GIL<p>Or it&#x27;s not how CPython works?</div><br/><div id="36917479" class="c"><input type="checkbox" id="c-36917479" checked=""/><div class="controls bullet"><span class="by">BGINBarbarian</span><span>|</span><a href="#36917451">parent</a><span>|</span><a href="#36916408">next</a><span>|</span><label class="collapse" for="c-36917479">[-]</label><label class="expand" for="c-36917479">[1 more]</label></div><br/><div class="children"><div class="content">Afaik, nogil will be a compile flag, which means that when there are two builds, you separately compile Gil and nogil builds. They will be two separate programs&#x2F;binaries&#x2F;packages. It could be possible for something like conda to install both binaries, then run your program with the one that matches the library flags, but python itself could not do this (afaik).</div><br/></div></div></div></div><div id="36916408" class="c"><input type="checkbox" id="c-36916408" checked=""/><div class="controls bullet"><span class="by">ram_rar</span><span>|</span><a href="#36917451">prev</a><span>|</span><a href="#36913871">next</a><span>|</span><label class="collapse" for="c-36916408">[-]</label><label class="expand" for="c-36916408">[2 more]</label></div><br/><div class="children"><div class="content">This seems somewhat delayed, and it may be considered too little, too late. Python community had the chance to leapfrog and embrace alternative concurrency abstractions, such as go routines etc, but it appears that this opportunity was not fully utilized.<p>After enduring the arduous process of migrating from Python 2 -&gt; 3 and navigating the complex world of dependencies, my hope is that we won&#x27;t encounter another nightmare of dependency management, forcing users to choose between GIL and no-GIL builds.</div><br/><div id="36917987" class="c"><input type="checkbox" id="c-36917987" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#36916408">parent</a><span>|</span><a href="#36913871">next</a><span>|</span><label class="collapse" for="c-36917987">[-]</label><label class="expand" for="c-36917987">[1 more]</label></div><br/><div class="children"><div class="content">Something akin to go routines won&#x27;t solve the C-library problem.</div><br/></div></div></div></div><div id="36913871" class="c"><input type="checkbox" id="c-36913871" checked=""/><div class="controls bullet"><span class="by">frfl</span><span>|</span><a href="#36916408">prev</a><span>|</span><a href="#36915871">next</a><span>|</span><label class="collapse" for="c-36913871">[-]</label><label class="expand" for="c-36913871">[6 more]</label></div><br/><div class="children"><div class="content">If I remember Guido van Rossum did mention the status of the GIL in one of the Lex Friedman episodes [1] he was on (it&#x27;s been a while, so I may be misremembering). Surprised to see a big decision like this happen so quickly. Did Meta&#x27;s announcement play a big role in this [2]?<p>[1]: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=-DVyjdw4t9I">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=-DVyjdw4t9I</a><p>[2]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36643670">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36643670</a></div><br/><div id="36914358" class="c"><input type="checkbox" id="c-36914358" checked=""/><div class="controls bullet"><span class="by">shosca</span><span>|</span><a href="#36913871">parent</a><span>|</span><a href="#36914007">next</a><span>|</span><label class="collapse" for="c-36914358">[-]</label><label class="expand" for="c-36914358">[1 more]</label></div><br/><div class="children"><div class="content">Anaconda also has committed engineering resources to assist with the no-GIL transition.</div><br/></div></div><div id="36914007" class="c"><input type="checkbox" id="c-36914007" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#36913871">parent</a><span>|</span><a href="#36914358">prev</a><span>|</span><a href="#36915871">next</a><span>|</span><label class="collapse" for="c-36914007">[-]</label><label class="expand" for="c-36914007">[4 more]</label></div><br/><div class="children"><div class="content">Removing him as BDFL was probably the best thing to have happened to Python. He <i>never</i> prioritized performance as a top priority, at least not the same way Lua, JavaScript and Java did. Even Ruby has a JIT now.</div><br/><div id="36914088" class="c"><input type="checkbox" id="c-36914088" checked=""/><div class="controls bullet"><span class="by">ambivalence</span><span>|</span><a href="#36913871">root</a><span>|</span><a href="#36914007">parent</a><span>|</span><a href="#36914658">next</a><span>|</span><label class="collapse" for="c-36914088">[-]</label><label class="expand" for="c-36914088">[1 more]</label></div><br/><div class="children"><div class="content">You know that people change their minds and now Guido is working as part of a team at Microsoft that is literally called &quot;Faster CPython&quot;?</div><br/></div></div><div id="36914658" class="c"><input type="checkbox" id="c-36914658" checked=""/><div class="controls bullet"><span class="by">v3ss0n</span><span>|</span><a href="#36913871">root</a><span>|</span><a href="#36914007">parent</a><span>|</span><a href="#36914088">prev</a><span>|</span><a href="#36916817">next</a><span>|</span><label class="collapse" for="c-36914658">[-]</label><label class="expand" for="c-36914658">[1 more]</label></div><br/><div class="children"><div class="content">Python had JIT for long, it&#x27;s called PyPy, One of the most ambitious project ever happened to opensource</div><br/></div></div><div id="36916817" class="c"><input type="checkbox" id="c-36916817" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36913871">root</a><span>|</span><a href="#36914007">parent</a><span>|</span><a href="#36914658">prev</a><span>|</span><a href="#36915871">next</a><span>|</span><label class="collapse" for="c-36916817">[-]</label><label class="expand" for="c-36916817">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Removing him as BDFL was probably the best thing to have happened to Python. He never prioritized performance as a top priority<p>That doesn&#x27;t follow; you&#x27;re assuming that Python <i>should</i> prioritize performance as a top priority, which is very much not a given. Python has always excelled at being easy to use, being flexible, being a great glue language - but performant? An interpreted, dynamically typed language? That&#x27;s like making a C interpreter - you <i>can</i> do it, but that doesn&#x27;t make it a good idea.</div><br/></div></div></div></div></div></div><div id="36915871" class="c"><input type="checkbox" id="c-36915871" checked=""/><div class="controls bullet"><span class="by">catnibbler</span><span>|</span><a href="#36913871">prev</a><span>|</span><a href="#36914969">next</a><span>|</span><label class="collapse" for="c-36915871">[-]</label><label class="expand" for="c-36915871">[9 more]</label></div><br/><div class="children"><div class="content">Is it really too late to not do this ? The only reason to get rid of the GIL is to help threading, but that&#x27;s not a thing we <i>should</i> be doing. Threads need to just die, and be replaced by something less idiotic. Seriously, having the CPU run fragments of your program at random, so that all the previously ordered pieces are now contending with each other and even themselves ? How can anyone not see that this is the stupidest idea in the world ?</div><br/><div id="36917975" class="c"><input type="checkbox" id="c-36917975" checked=""/><div class="controls bullet"><span class="by">nottorp</span><span>|</span><a href="#36915871">parent</a><span>|</span><a href="#36918002">next</a><span>|</span><label class="collapse" for="c-36917975">[-]</label><label class="expand" for="c-36917975">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a workaround for not having 1200 Ghz CPUs but instead 128 cores at 3 Ghz...</div><br/></div></div><div id="36918002" class="c"><input type="checkbox" id="c-36918002" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915871">parent</a><span>|</span><a href="#36917975">prev</a><span>|</span><a href="#36917660">next</a><span>|</span><label class="collapse" for="c-36918002">[-]</label><label class="expand" for="c-36918002">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Threads need to just die, and be replaced by something less idiotic.<p>Please tell us: What other solution do you propose for running <i>CPU bound</i> workloads in parallel?<p>There are exactly 2: Multiprocessing and using another language.</div><br/></div></div><div id="36917660" class="c"><input type="checkbox" id="c-36917660" checked=""/><div class="controls bullet"><span class="by">AlphaSite</span><span>|</span><a href="#36915871">parent</a><span>|</span><a href="#36918002">prev</a><span>|</span><a href="#36915972">next</a><span>|</span><label class="collapse" for="c-36917660">[-]</label><label class="expand" for="c-36917660">[1 more]</label></div><br/><div class="children"><div class="content">Python already has threads, they just have huge downsides in their current form, so this ship has long since sailed.</div><br/></div></div><div id="36915972" class="c"><input type="checkbox" id="c-36915972" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915871">parent</a><span>|</span><a href="#36917660">prev</a><span>|</span><a href="#36915873">next</a><span>|</span><label class="collapse" for="c-36915972">[-]</label><label class="expand" for="c-36915972">[1 more]</label></div><br/><div class="children"><div class="content">I was called inconsiderate for essentially asking this very question. I still think it&#x27;s the right question to ask:<p>Why should Python even have a free threading model?</div><br/></div></div><div id="36915873" class="c"><input type="checkbox" id="c-36915873" checked=""/><div class="controls bullet"><span class="by">Jabrov</span><span>|</span><a href="#36915871">parent</a><span>|</span><a href="#36915972">prev</a><span>|</span><a href="#36914969">next</a><span>|</span><label class="collapse" for="c-36915873">[-]</label><label class="expand" for="c-36915873">[4 more]</label></div><br/><div class="children"><div class="content">As opposed to?</div><br/><div id="36915943" class="c"><input type="checkbox" id="c-36915943" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#36915871">root</a><span>|</span><a href="#36915873">parent</a><span>|</span><a href="#36915985">next</a><span>|</span><label class="collapse" for="c-36915943">[-]</label><label class="expand" for="c-36915943">[2 more]</label></div><br/><div class="children"><div class="content">In Python, asyncio and multiprocessing packages can get nearly the same or better performance for IO- and CPU-intensive tasks respectively as no-GIL multithreading (and are more performant than GIL multithreading), with only a tiny fraction of the pitfalls. For any use case where the last few percent matter, consider not using Python (which will be much much more significant).<p>Regardless, we did somehow end up here, and there&#x27;s plenty of multi-threaded Python code that would benefit from no-GIL, so I support the proposal just from a practical perspective. But when designing a new codebase, you&#x27;ll almost almost almost always want to avoid Python threads, even with no-GIL.</div><br/><div id="36918057" class="c"><input type="checkbox" id="c-36918057" checked=""/><div class="controls bullet"><span class="by">usrbinbash</span><span>|</span><a href="#36915871">root</a><span>|</span><a href="#36915943">parent</a><span>|</span><a href="#36915985">next</a><span>|</span><label class="collapse" for="c-36918057">[-]</label><label class="expand" for="c-36918057">[1 more]</label></div><br/><div class="children"><div class="content">&gt; asyncio<p>...is useless for CPU bound tasks. The event loop uses only one core.<p>&gt; multiprocessing<p>...relies on IPC and running actual system processes, both of which have alot more overhead than switching thread context and using shared memory.<p>&gt; For any use case where the last few percent matter, consider not using Python (which will be much much more significant).<p>Here is an interesting question: If asyncio and multiprocessing already give us &quot;nearly the same or better performance&quot;, then why is &quot;use another language&quot; such a common advice to escape parallelism-problems in Python?<p>Because, curiously enough, the languages that are usually recommended for this (C, Go, Rust, C++, Java) all implement thread-based parallelism.</div><br/></div></div></div></div><div id="36915985" class="c"><input type="checkbox" id="c-36915985" checked=""/><div class="controls bullet"><span class="by">catnibbler</span><span>|</span><a href="#36915871">root</a><span>|</span><a href="#36915873">parent</a><span>|</span><a href="#36915943">prev</a><span>|</span><a href="#36914969">next</a><span>|</span><label class="collapse" for="c-36915985">[-]</label><label class="expand" for="c-36915985">[1 more]</label></div><br/><div class="children"><div class="content">Keep the GIL and avoid the problems its removal will cause. Allow parts of your program to run in a separate namespace with explicit passing of objects. No sharing means no contention, so no overhead.</div><br/></div></div></div></div></div></div><div id="36914969" class="c"><input type="checkbox" id="c-36914969" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#36915871">prev</a><span>|</span><a href="#36917505">next</a><span>|</span><label class="collapse" for="c-36914969">[-]</label><label class="expand" for="c-36914969">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if there will ever be Python 4, it seems that the core developers want to avoid bumping the major version number ever again after 3 under any circumstances.</div><br/></div></div><div id="36917505" class="c"><input type="checkbox" id="c-36917505" checked=""/><div class="controls bullet"><span class="by">dotnet00</span><span>|</span><a href="#36914969">prev</a><span>|</span><a href="#36916274">next</a><span>|</span><label class="collapse" for="c-36917505">[-]</label><label class="expand" for="c-36917505">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m looking forward to this, Python plays a fairly significant role in our scientific computing code and not having to have entirely separate processes will be very convenient for cutting down data duplication.</div><br/></div></div><div id="36916274" class="c"><input type="checkbox" id="c-36916274" checked=""/><div class="controls bullet"><span class="by">kalb_almas</span><span>|</span><a href="#36917505">prev</a><span>|</span><a href="#36915210">next</a><span>|</span><label class="collapse" for="c-36916274">[-]</label><label class="expand" for="c-36916274">[2 more]</label></div><br/><div class="children"><div class="content">Even with improved support for parallelism, what role will Python have in the future if Mojo makes good on even half of its promises?</div><br/><div id="36917131" class="c"><input type="checkbox" id="c-36917131" checked=""/><div class="controls bullet"><span class="by">nologic01</span><span>|</span><a href="#36916274">parent</a><span>|</span><a href="#36915210">next</a><span>|</span><label class="collapse" for="c-36917131">[-]</label><label class="expand" for="c-36917131">[1 more]</label></div><br/><div class="children"><div class="content">Mojo is not Python.<p>The underlying pressure on the Python ecosystem is to transition to a post-Moore&#x27;s law era and effectively become a HPC platform where the &quot;same&quot; code runs on a CPU, a GPU, multicore, clusters etc.<p>Python may feel the pressure more than others because of the GIL <i>and</i> the fact it is used in compute intensive tasks more than others.<p>But this major need to transition to easy and seamless HPC&#x2F;heterogeneous computing is the same for all languages. The question is who will get there first.</div><br/></div></div></div></div><div id="36915210" class="c"><input type="checkbox" id="c-36915210" checked=""/><div class="controls bullet"><span class="by">valyagolev</span><span>|</span><a href="#36916274">prev</a><span>|</span><a href="#36917301">next</a><span>|</span><label class="collapse" for="c-36915210">[-]</label><label class="expand" for="c-36915210">[5 more]</label></div><br/><div class="children"><div class="content">there&#x27;s a lot of code I wrote (and saw people write) in Python over the years, conscious that noone will ever run it in threads (ofc it&#x27;s possible, but typically pointless), thus going quite easy on things that wouldn&#x27;t be thread-safe. this used to quite a comfortable stance. community ended up inventing other ways to share state, other ways to vectorize, other ways to avoid blocking on I&#x2F;O, that might sometimes be annoying, but evolved to be quite reasonable for Python.<p>giving up this stance? a lot of code is instantly a legacy, and a lot of it is a legacy people won&#x27;t even know about before they notice the problems. and for what?<p>i must say that i have no experience running Python without GIL so my idea of the ways things can be not thread-safe is purely speculative&#x2F;borrowed from very different languages (that I finally moved on to long ago, thank god). so maybe i&#x27;m wrong, i misunderstand the impact, and all this code is just fine</div><br/><div id="36915314" class="c"><input type="checkbox" id="c-36915314" checked=""/><div class="controls bullet"><span class="by">valyagolev</span><span>|</span><a href="#36915210">parent</a><span>|</span><a href="#36915278">next</a><span>|</span><label class="collapse" for="c-36915314">[-]</label><label class="expand" for="c-36915314">[3 more]</label></div><br/><div class="children"><div class="content">people in this thread mention that, for some reason, &quot;even with GIL you still have to write thread-safe code&quot;, which is an admirable stance, but I don&#x27;t think many people do it, because their webserver or whatever uses the many single-threaded processes model and they don&#x27;t want to waste time on that</div><br/><div id="36915419" class="c"><input type="checkbox" id="c-36915419" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915210">root</a><span>|</span><a href="#36915314">parent</a><span>|</span><a href="#36915278">next</a><span>|</span><label class="collapse" for="c-36915419">[-]</label><label class="expand" for="c-36915419">[2 more]</label></div><br/><div class="children"><div class="content">Indeed. And the reason they use multiprocessing is bc they have learned that Python&#x27;s multithreading is not a good option in cpu bound tasks. The blessing in disguise of course being that multiprocessing is also a shared nothing model, so (mostly) lock free programming is the default. Oth if you have a need for concurrently accessed shared memory&#x2F;resources and need locks, it comes with an explicit cost. I think that&#x27;s a good thing.<p>In the future the default concurrency model will be shared everything free threading, and all hell might break loose. Hopefully not.</div><br/><div id="36915473" class="c"><input type="checkbox" id="c-36915473" checked=""/><div class="controls bullet"><span class="by">valyagolev</span><span>|</span><a href="#36915210">root</a><span>|</span><a href="#36915419">parent</a><span>|</span><a href="#36915278">next</a><span>|</span><label class="collapse" for="c-36915473">[-]</label><label class="expand" for="c-36915473">[1 more]</label></div><br/><div class="children"><div class="content">IMO Python doesn&#x27;t even offer enough in the way of good synchronisation primitives for the async code. I don&#x27;t think the ecosystem is ready for this one.<p>I hope it&#x27;ll be recognised by the most &quot;host&quot; applications (uvicorn or whatever) that multi-threading is not a good idea anyway and they&#x27;ll discourage it. But there&#x27;ll definitely be a macho-land of thread-&quot;safe&quot; programmers whose bugs we&#x27;ll be downstream of</div><br/></div></div></div></div></div></div><div id="36915278" class="c"><input type="checkbox" id="c-36915278" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915210">parent</a><span>|</span><a href="#36915314">prev</a><span>|</span><a href="#36917301">next</a><span>|</span><label class="collapse" for="c-36915278">[-]</label><label class="expand" for="c-36915278">[1 more]</label></div><br/><div class="children"><div class="content">Well said. Thanks</div><br/></div></div></div></div><div id="36917301" class="c"><input type="checkbox" id="c-36917301" checked=""/><div class="controls bullet"><span class="by">dwaite</span><span>|</span><a href="#36915210">prev</a><span>|</span><a href="#36915608">next</a><span>|</span><label class="collapse" for="c-36917301">[-]</label><label class="expand" for="c-36917301">[1 more]</label></div><br/><div class="children"><div class="content">I sure hope they decide to call execution of mixed GIL and no-GIL codebases &quot;amphibious mode&quot;</div><br/></div></div><div id="36915608" class="c"><input type="checkbox" id="c-36915608" checked=""/><div class="controls bullet"><span class="by">nnx</span><span>|</span><a href="#36917301">prev</a><span>|</span><a href="#36915033">next</a><span>|</span><label class="collapse" for="c-36915608">[-]</label><label class="expand" for="c-36915608">[5 more]</label></div><br/><div class="children"><div class="content">I hope this won&#x27;t make Python&#x27;s dependency hell even worse, but I&#x27;m not hopeful.</div><br/><div id="36915687" class="c"><input type="checkbox" id="c-36915687" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915608">parent</a><span>|</span><a href="#36915631">next</a><span>|</span><label class="collapse" for="c-36915687">[-]</label><label class="expand" for="c-36915687">[3 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s going to be weird for some years where some libraries support no-GIL and others don&#x27;t, while folks cry about the ones that don&#x27;t support it holding them back.<p>Like asyncio&#x27;s introduction we&#x27;ll probably see core stuff like http requests, file IO etc. all now have an entirely new permutation of libraries made to support non-GIL mode.  This is going to get pretty spicy as stuff like http already has regular (blocking IO) and asyncio (non blocking IO) versions, so now do they need regular non-GIL and asyncio non-GIL versions too?  Is the default for a library author going forward to be creating four permutations of your library with vastly different behavior in each of them?  Yuck.</div><br/><div id="36916093" class="c"><input type="checkbox" id="c-36916093" checked=""/><div class="controls bullet"><span class="by">ies7</span><span>|</span><a href="#36915608">root</a><span>|</span><a href="#36915687">parent</a><span>|</span><a href="#36915817">next</a><span>|</span><label class="collapse" for="c-36916093">[-]</label><label class="expand" for="c-36916093">[1 more]</label></div><br/><div class="children"><div class="content">&gt; while folks cry about the ones that don&#x27;t support it holding them back.<p>And someone may prefer to make NON GIL wall of shame&#x2F;fame instead of directly contributing to those libraries</div><br/></div></div><div id="36915817" class="c"><input type="checkbox" id="c-36915817" checked=""/><div class="controls bullet"><span class="by">miraculixx</span><span>|</span><a href="#36915608">root</a><span>|</span><a href="#36915687">parent</a><span>|</span><a href="#36916093">prev</a><span>|</span><a href="#36915631">next</a><span>|</span><label class="collapse" for="c-36915817">[-]</label><label class="expand" for="c-36915817">[1 more]</label></div><br/><div class="children"><div class="content">import this<p>;)</div><br/></div></div></div></div><div id="36915631" class="c"><input type="checkbox" id="c-36915631" checked=""/><div class="controls bullet"><span class="by">phkahler</span><span>|</span><a href="#36915608">parent</a><span>|</span><a href="#36915687">prev</a><span>|</span><a href="#36915033">next</a><span>|</span><label class="collapse" for="c-36915631">[-]</label><label class="expand" for="c-36915631">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s optional. Just keep using the GIL.</div><br/></div></div></div></div><div id="36915033" class="c"><input type="checkbox" id="c-36915033" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#36915608">prev</a><span>|</span><a href="#36917388">next</a><span>|</span><label class="collapse" for="c-36915033">[-]</label><label class="expand" for="c-36915033">[5 more]</label></div><br/><div class="children"><div class="content">No-GIL means better performance at the cost of being less beginner-friendly, right?</div><br/><div id="36915124" class="c"><input type="checkbox" id="c-36915124" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#36915033">parent</a><span>|</span><a href="#36915466">next</a><span>|</span><label class="collapse" for="c-36915124">[-]</label><label class="expand" for="c-36915124">[1 more]</label></div><br/><div class="children"><div class="content">Not really. The GIL doesn’t actually make threading easier for a typical developer as they still have to worry about thread safety. You can ignore locks if you know what Python operations are atomic. But that’s incredibly perilous and you really shouldn’t try given that relies on implementation details. Eg. What if you didn’t realize a setter was overridden and setting to a dict-like isn’t atomic anymore?<p>It’ll make the Python source code much more complex and complicated, which is probably not a big deal, though I’ll say the CPython source is quite brilliant.<p>It’ll also mean for C library developers that they can’t assume Python opcodes are atomic. But I’m not sure C library developers will really mind too much because they already worry about this kind of stuff.</div><br/></div></div><div id="36915466" class="c"><input type="checkbox" id="c-36915466" checked=""/><div class="controls bullet"><span class="by">tedivm</span><span>|</span><a href="#36915033">parent</a><span>|</span><a href="#36915124">prev</a><span>|</span><a href="#36915734">next</a><span>|</span><label class="collapse" for="c-36915466">[-]</label><label class="expand" for="c-36915466">[1 more]</label></div><br/><div class="children"><div class="content">Only if the user explicitly uses threads. By default people can still approach their code in the exact same way they do. I imagine most users won&#x27;t think about threads at all, but may relay on frameworks and libraries that take advantage of them under the hood.</div><br/></div></div><div id="36915734" class="c"><input type="checkbox" id="c-36915734" checked=""/><div class="controls bullet"><span class="by">qbasic_forever</span><span>|</span><a href="#36915033">parent</a><span>|</span><a href="#36915466">prev</a><span>|</span><a href="#36915136">next</a><span>|</span><label class="collapse" for="c-36915734">[-]</label><label class="expand" for="c-36915734">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only more performance if you&#x27;re using the threading primitives and spawning new threads, moving work to them to do in parallel, etc.--this isn&#x27;t something any beginner will consciously be doing.  It might actually be slower in regular single process use that 99% of python users use (since the GIL is there for a very good reason and synchronizing access to python&#x27;s internal state doesn&#x27;t just happen for free or without some cost somewhere).</div><br/></div></div><div id="36915136" class="c"><input type="checkbox" id="c-36915136" checked=""/><div class="controls bullet"><span class="by">JamesSwift</span><span>|</span><a href="#36915033">parent</a><span>|</span><a href="#36915734">prev</a><span>|</span><a href="#36917388">next</a><span>|</span><label class="collapse" for="c-36915136">[-]</label><label class="expand" for="c-36915136">[1 more]</label></div><br/><div class="children"><div class="content">I think multi-threadedness is already an intermediate level concept so maybe its not a big downside. In turn, the ones that understand and need the performance get it.</div><br/></div></div></div></div><div id="36917687" class="c"><input type="checkbox" id="c-36917687" checked=""/><div class="controls bullet"><span class="by">lraxny</span><span>|</span><a href="#36917388">prev</a><span>|</span><label class="collapse" for="c-36917687">[-]</label><label class="expand" for="c-36917687">[1 more]</label></div><br/><div class="children"><div class="content">The ruling class in python-dev are populists who are not threading experts. Python is run by the wrong people.<p>They will approve something if it serves a corporation. The submission here is likely CYA, so they can say that &quot;they asked the community&quot;.<p>There is no appreciation for people doing grassroots open source software. If Instagram can add another hack instead of switching to Java, it will be approved.<p>It is important to remember that paid corporate developers will have job security every time new pain is introduced in the Python ecosystem.</div><br/></div></div></div></div></div></div></div></body></html>