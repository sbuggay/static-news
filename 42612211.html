<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736240477098" as="style"/><link rel="stylesheet" href="styles.css?v=1736240477098"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://repository.upenn.edu/entities/publication/72ca3499-c5f6-4fc1-b5a3-9d66d8dd534e">Property-Based Testing for the People</a> <span class="domain">(<a href="https://repository.upenn.edu">repository.upenn.edu</a>)</span></div><div class="subtext"><span>matt_d</span> | <span>51 comments</span></div><br/><div><div id="42612462" class="c"><input type="checkbox" id="c-42612462" checked=""/><div class="controls bullet"><span class="by">cosmic_quanta</span><span>|</span><a href="#42614204">next</a><span>|</span><label class="collapse" for="c-42612462">[-]</label><label class="expand" for="c-42612462">[1 more]</label></div><br/><div class="children"><div class="content">This work was discussed by the author in the Haskell Interlude podcast as well [0]. Highly recommended and probably easier to digest than a whole dissertation.<p>[0]: <a href="https:&#x2F;&#x2F;haskell.foundation&#x2F;podcast&#x2F;59&#x2F;" rel="nofollow">https:&#x2F;&#x2F;haskell.foundation&#x2F;podcast&#x2F;59&#x2F;</a></div><br/></div></div><div id="42614204" class="c"><input type="checkbox" id="c-42614204" checked=""/><div class="controls bullet"><span class="by">tomnicholas1</span><span>|</span><a href="#42612462">prev</a><span>|</span><a href="#42612858">next</a><span>|</span><label class="collapse" for="c-42614204">[-]</label><label class="expand" for="c-42614204">[12 more]</label></div><br/><div class="children"><div class="content">The python package Hypothesis[0] already does a great job bringing property-based testing to the people! I&#x27;ve used it and it&#x27;s extremely powerful.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;HypothesisWorks&#x2F;hypothesis">https:&#x2F;&#x2F;github.com&#x2F;HypothesisWorks&#x2F;hypothesis</a></div><br/><div id="42615811" class="c"><input type="checkbox" id="c-42615811" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#42614204">parent</a><span>|</span><a href="#42612858">next</a><span>|</span><label class="collapse" for="c-42615811">[-]</label><label class="expand" for="c-42615811">[11 more]</label></div><br/><div class="children"><div class="content">I have used Python&#x27;s `hypothesis` as well, and I wish it were better. We had to rip it out at work as we were running into too many issues.<p>I have also used Haskell&#x27;s `QuickCheck` and Clojure&#x27;s `spec` &#x2F; `test.check` and have had a great experience with these. In my experience they &quot;just work&quot;.<p>Conversely, if you&#x27;re trying to generate non-trivial datasets, you will likely run into situations where your specification is correct but Hypothesis&#x27; implementation fails to generate data, or takes an unreasonable amount of time to generate data.<p>Example: Generate a 100x25 array of numeric values, where the only condition is that they must not all be zero simultaneously. [1]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;HypothesisWorks&#x2F;hypothesis&#x2F;issues&#x2F;3493">https:&#x2F;&#x2F;github.com&#x2F;HypothesisWorks&#x2F;hypothesis&#x2F;issues&#x2F;3493</a></div><br/><div id="42616970" class="c"><input type="checkbox" id="c-42616970" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42614204">root</a><span>|</span><a href="#42615811">parent</a><span>|</span><a href="#42618421">next</a><span>|</span><label class="collapse" for="c-42616970">[-]</label><label class="expand" for="c-42616970">[5 more]</label></div><br/><div class="children"><div class="content">I understand your pain in some sense, but on another I feel like people with a decent amount of hypothesis experience &quot;know&quot; how the generator works and would understand that you basically _never_ want to use `filter` if you can avoid it, instead relying on unfalsifiable generation.<p>Silly idea for your generator would to generate an array, and if it&#x27;s zero... draw a random index and a random non-zero number and add it into the array. Leads to some weird non-convexity properties but is a workable hack.<p>In your own example you turned off the &quot;data too slow&quot; issue, probably because building up a dataframe (all to just do a column sum!) is actually kind of costly at large numbers! Your complaint is probably actually meant for the pandas extras (or pandas itself) rather than the concept of hypothesis.</div><br/><div id="42617539" class="c"><input type="checkbox" id="c-42617539" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#42614204">root</a><span>|</span><a href="#42616970">parent</a><span>|</span><a href="#42618421">next</a><span>|</span><label class="collapse" for="c-42617539">[-]</label><label class="expand" for="c-42617539">[4 more]</label></div><br/><div class="children"><div class="content">No, I ran into the same issues with basic data structures. The dataframe wasn’t necessary, it just matched the expected input of some function I wanted to test.</div><br/><div id="42618129" class="c"><input type="checkbox" id="c-42618129" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42614204">root</a><span>|</span><a href="#42617539">parent</a><span>|</span><a href="#42618421">next</a><span>|</span><label class="collapse" for="c-42618129">[-]</label><label class="expand" for="c-42618129">[3 more]</label></div><br/><div class="children"><div class="content">I took your case, I got way better perf just generating a list of numbers and then reshaping it into a dataframe.<p>But! Even though it doesn&#x27;t even get that much slower at a certain number of rows it just starts hanging! Like at 49 rows everything is still fine and at 50 it no longer wants to work. It&#x27;s very bizarre and I&#x27;ll see if I can debug it. But I think your test case isn&#x27;t indicative of some fundamental issue with Hypothesis rather than some sort of bug.</div><br/><div id="42618302" class="c"><input type="checkbox" id="c-42618302" checked=""/><div class="controls bullet"><span class="by">tybug</span><span>|</span><a href="#42614204">root</a><span>|</span><a href="#42618129">parent</a><span>|</span><a href="#42618421">next</a><span>|</span><label class="collapse" for="c-42618302">[-]</label><label class="expand" for="c-42618302">[2 more]</label></div><br/><div class="children"><div class="content">That kind of behavior can happen at the threshold of Hypothesis&#x27; internal limit on entropy - though if you&#x27;re not hitting HealthCheck.data_too_large then this seems unlikely.<p>Let me know if you have a reproducer, I&#x27;d be curious to take a look.</div><br/></div></div></div></div></div></div></div></div><div id="42618421" class="c"><input type="checkbox" id="c-42618421" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#42614204">root</a><span>|</span><a href="#42615811">parent</a><span>|</span><a href="#42616970">prev</a><span>|</span><a href="#42617928">next</a><span>|</span><label class="collapse" for="c-42618421">[-]</label><label class="expand" for="c-42618421">[3 more]</label></div><br/><div class="children"><div class="content">Not weighing in on any particular tech (hypothesis or otherwise), but intrigued by your example...<p>My initial impulse is to pick a random cell which must not be zero, generate a random number for each other cell and a random non-zerp number for that one.  I&#x27;m not immediately decided on whether it&#x27;s uniformly distributed.</div><br/><div id="42619185" class="c"><input type="checkbox" id="c-42619185" checked=""/><div class="controls bullet"><span class="by">eslaught</span><span>|</span><a href="#42614204">root</a><span>|</span><a href="#42618421">parent</a><span>|</span><a href="#42617928">next</a><span>|</span><label class="collapse" for="c-42619185">[-]</label><label class="expand" for="c-42619185">[2 more]</label></div><br/><div class="children"><div class="content">I would pick the number of non-zeros first, assert that it&#x27;s non-zero, then continue filling in the values themselves. And probably not with a uniform distribution.<p>Any algorithm that cares about the number of non-zeros could have non-trivial interactions with their arrangement and count, so picking something that generates non-trivial sparsity (and doesn&#x27;t just make the array look like white noise) is going to have the best chance of exposing interesting behavior. The tricky part is thinking through how to generate &quot;interesting&quot; patterns, which admittedly I haven&#x27;t put enough thought into.</div><br/><div id="42619279" class="c"><input type="checkbox" id="c-42619279" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#42614204">root</a><span>|</span><a href="#42619185">parent</a><span>|</span><a href="#42617928">next</a><span>|</span><label class="collapse" for="c-42619279">[-]</label><label class="expand" for="c-42619279">[1 more]</label></div><br/><div class="children"><div class="content">Ah, yeah, generating for property testing probably doesn&#x27;t want a uniform distribution.  What patterns are interesting will surely depend on what we&#x27;re doing with the array.</div><br/></div></div></div></div></div></div><div id="42617928" class="c"><input type="checkbox" id="c-42617928" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#42614204">root</a><span>|</span><a href="#42615811">parent</a><span>|</span><a href="#42618421">prev</a><span>|</span><a href="#42616518">next</a><span>|</span><label class="collapse" for="c-42617928">[-]</label><label class="expand" for="c-42617928">[1 more]</label></div><br/><div class="children"><div class="content">As the comments on your linked issue point out:<p>(a) Filtering is a last resort and is best avoided. As an example, the Gen type in Haskell&#x27;s falsify package can&#x27;t be filtered, since it&#x27;s a bad idea. As another example, ScalaCheck&#x27;s Gen type <i>can</i> be filtered, but they also allow &quot;retries&quot; (by default, up to 10,000 times), because filtering is very wasteful.<p>(b) If you&#x27;re going to filter, scope it to be as small as possible (e.g. one comment points out that you&#x27;re discarding and regenerating entire dataframes, when the filter only depends on one particular column)<p>(c) Have some vague awareness of how your generators will shrink, to avoid infinite loops. In your case, shrinking will make it more likely to fail your filter; and the &quot;smallest&quot; dataframe (all zeros) will definitely fail.</div><br/></div></div><div id="42616518" class="c"><input type="checkbox" id="c-42616518" checked=""/><div class="controls bullet"><span class="by">mrcsd</span><span>|</span><a href="#42614204">root</a><span>|</span><a href="#42615811">parent</a><span>|</span><a href="#42617928">prev</a><span>|</span><a href="#42612858">next</a><span>|</span><label class="collapse" for="c-42616518">[-]</label><label class="expand" for="c-42616518">[1 more]</label></div><br/><div class="children"><div class="content">Care to expand upon the issues you were running into with hypothesis? I&#x27;m genuinely curious as I may soon be evaluating whether to use it in a professional context.</div><br/></div></div></div></div></div></div><div id="42612858" class="c"><input type="checkbox" id="c-42612858" checked=""/><div class="controls bullet"><span class="by">sunesimonsen</span><span>|</span><a href="#42614204">prev</a><span>|</span><a href="#42620276">next</a><span>|</span><label class="collapse" for="c-42612858">[-]</label><label class="expand" for="c-42612858">[2 more]</label></div><br/><div class="children"><div class="content">I think property based testing becomes a lot easier when you can just use normal asserts like this: <a href="https:&#x2F;&#x2F;github.com&#x2F;unexpectedjs&#x2F;unchecked">https:&#x2F;&#x2F;github.com&#x2F;unexpectedjs&#x2F;unchecked</a></div><br/><div id="42620595" class="c"><input type="checkbox" id="c-42620595" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#42612858">parent</a><span>|</span><a href="#42620276">next</a><span>|</span><label class="collapse" for="c-42620595">[-]</label><label class="expand" for="c-42620595">[1 more]</label></div><br/><div class="children"><div class="content">Not to be too critical but coming from Java&#x2F;C# I‘m not not so hot they are writing their own tests: <a href="https:&#x2F;&#x2F;github.com&#x2F;unexpectedjs&#x2F;unchecked&#x2F;blob&#x2F;master&#x2F;test&#x2F;index.spec.js">https:&#x2F;&#x2F;github.com&#x2F;unexpectedjs&#x2F;unchecked&#x2F;blob&#x2F;master&#x2F;test&#x2F;i...</a><p>Maybe just a matter of familiarity?</div><br/></div></div></div></div><div id="42620276" class="c"><input type="checkbox" id="c-42620276" checked=""/><div class="controls bullet"><span class="by">fouc</span><span>|</span><a href="#42612858">prev</a><span>|</span><a href="#42617923">next</a><span>|</span><label class="collapse" for="c-42620276">[-]</label><label class="expand" for="c-42620276">[1 more]</label></div><br/><div class="children"><div class="content">I read that as &quot;Property-Based Testing of People&quot;</div><br/></div></div><div id="42617923" class="c"><input type="checkbox" id="c-42617923" checked=""/><div class="controls bullet"><span class="by">algorithmsRcool</span><span>|</span><a href="#42620276">prev</a><span>|</span><a href="#42613590">next</a><span>|</span><label class="collapse" for="c-42617923">[-]</label><label class="expand" for="c-42617923">[1 more]</label></div><br/><div class="children"><div class="content">Just going to plug the excellent .NET PBT library, CsCheck [0]. I have used it quite a bit to excersize strange corners of my program logic and found several exotic bugs with it.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;AnthonyLloyd&#x2F;CsCheck">https:&#x2F;&#x2F;github.com&#x2F;AnthonyLloyd&#x2F;CsCheck</a></div><br/></div></div><div id="42613590" class="c"><input type="checkbox" id="c-42613590" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#42617923">prev</a><span>|</span><a href="#42617397">next</a><span>|</span><label class="collapse" for="c-42613590">[-]</label><label class="expand" for="c-42613590">[1 more]</label></div><br/><div class="children"><div class="content">For structure generation I prefer Doug McIlroy&#x27;s approach: pick a tree size (from some arbitrary distribution), and then, of the <i>n</i> possible valid structures of that size, produce the <i>k</i>th one uniformly.<p><a href="https:&#x2F;&#x2F;www.cs.dartmouth.edu&#x2F;~doug&#x2F;nfa.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.dartmouth.edu&#x2F;~doug&#x2F;nfa.pdf</a> gives an nfa variant; extending to a pda is an (interesting, I found) exercise.</div><br/></div></div><div id="42617397" class="c"><input type="checkbox" id="c-42617397" checked=""/><div class="controls bullet"><span class="by">mont_tag</span><span>|</span><a href="#42613590">prev</a><span>|</span><a href="#42612922">next</a><span>|</span><label class="collapse" for="c-42617397">[-]</label><label class="expand" for="c-42617397">[2 more]</label></div><br/><div class="children"><div class="content">&gt; My work is motivated by conversations with real PBT users, accentuating the benefits that they get from PBT and reducing the drawbacks.<p>ISTM that the benefits and drawbacks are just two sides of the same coin.  The benefit is reduced testing effort. The drawback is that savings comes from sacrificing knowledge of exactly what has been tested.<p>&gt; I also observed that PBT users are not always good at evaluating whether their testing was effective.<p>Ah, there&#x27;s the rub. It seems that the benefit of making the tested property explicit is partially offset by not really knowing how much of the search space was explored automatically.</div><br/><div id="42617641" class="c"><input type="checkbox" id="c-42617641" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#42617397">parent</a><span>|</span><a href="#42612922">next</a><span>|</span><label class="collapse" for="c-42617641">[-]</label><label class="expand" for="c-42617641">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The benefit is reduced testing effort.<p>I wouldn&#x27;t agree with this assessment. PBT has <i>frequently</i> surprised me, finding bugs that I never would have thought to test. It&#x27;s not merely a tool for generating the unit tests we would have written anyway; it&#x27;s a way to write down how we <i>think</i> the parts of a system interact, and have the machine show us that we&#x27;re wrong. Crucially, it&#x27;s quite hard to prove <i>ourselves</i> wrong, since it&#x27;s hard to think up scenarios that we hadn&#x27;t considered, so it&#x27;s nice to have the machine help with that part.<p>&gt; The drawback is that savings comes from sacrificing knowledge of exactly what has been tested.<p>I encourage you to use the statistics-gathering features that many (most?) PBT systems provide (e.g. functions with names like &quot;collect&quot;, &quot;label&quot;, etc.). Also, whilst preconditions&#x2F;filtering can be useful in a pinch, it&#x27;s usually a good idea for a property to construct data of the appropriate sort itself (e.g. using arbitrary arguments to fill in an appropriate template); rather than relying on a completely arbitrary generator to hit scenarios you care about.</div><br/></div></div></div></div><div id="42612922" class="c"><input type="checkbox" id="c-42612922" checked=""/><div class="controls bullet"><span class="by">hitchstory</span><span>|</span><a href="#42617397">prev</a><span>|</span><a href="#42613612">next</a><span>|</span><label class="collapse" for="c-42612922">[-]</label><label class="expand" for="c-42612922">[27 more]</label></div><br/><div class="children"><div class="content">Property testing is a lot like formal methods - really cool, but almost entirely useless in ~95% of commercial contexts.<p>They&#x27;re both extremely useful when, say, building a parser, but when the kind of code you write involves displaying custom widgets, taking data and pushing it onto a queue, looking up data in a database, etc. integration tests have a lot more bang for the buck.</div><br/><div id="42614897" class="c"><input type="checkbox" id="c-42614897" checked=""/><div class="controls bullet"><span class="by">choeger</span><span>|</span><a href="#42612922">parent</a><span>|</span><a href="#42613094">next</a><span>|</span><label class="collapse" for="c-42614897">[-]</label><label class="expand" for="c-42614897">[2 more]</label></div><br/><div class="children"><div class="content">Hah! Try to separate your domain logic from your interfaces (e.g., using something like hexagonal architecture) and then say this again.<p>Yes, it&#x27;s a lot of work coming up with good properties, but it <i>massively</i> helps to find gaps in the domain logic. In my experience, these gaps are what&#x27;s typically expensive, not the weird problem a junior had with properly using Redis or S3.</div><br/><div id="42616890" class="c"><input type="checkbox" id="c-42616890" checked=""/><div class="controls bullet"><span class="by">hitchstory</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42614897">parent</a><span>|</span><a href="#42613094">next</a><span>|</span><label class="collapse" for="c-42616890">[-]</label><label class="expand" for="c-42616890">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Hah! Try to separate your domain logic from your interfaces<p>Im not an amateur.<p>The only time I dont do this is when there literally is <i>no</i> domain logic yet (e.g. a CRUD app).<p>&gt;In my experience, these gaps are what&#x27;s typically expensive, not the weird problem a junior had with properly using Redis or S3.<p>What can I say? Your experience might not be as broad as mine.<p>Redis is a source of almost no bugs because it is very well designed, but most interfaces I couple to have design qualities that are the exact opposite of redis&#x27;s.<p>Those interfaces (e.g. wonky payment gateway APIs, weird microservice APIs) are the probably source of most bugs in enterprise systems I work on.<p>#2 is probably simple misspecifications (customer said code should do X, it should actually do Y which is almost the same but very slightly different).<p>#3 would be domain logic errors. And even most of those are uncovered and avoided with saner architecture or a couple of unit tests.<p>For the parsers I write at home, sure, property testing kicks ass. For your college degree algorithm coursework, sure, it helps a lot. For 95% of business logic? Pointless, the complexity isnt buried deep in the business logic.</div><br/></div></div></div></div><div id="42613094" class="c"><input type="checkbox" id="c-42613094" checked=""/><div class="controls bullet"><span class="by">boscillator</span><span>|</span><a href="#42612922">parent</a><span>|</span><a href="#42614897">prev</a><span>|</span><a href="#42618428">next</a><span>|</span><label class="collapse" for="c-42613094">[-]</label><label class="expand" for="c-42613094">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very useful when you&#x27;re working on numerical software. Often, it&#x27;s hard to figure out exactly what output your code should return (because if you knew the answer you wouldn&#x27;t have to write the code), but you can easily list properties you expect.</div><br/><div id="42613548" class="c"><input type="checkbox" id="c-42613548" checked=""/><div class="controls bullet"><span class="by">matt_d</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42613094">parent</a><span>|</span><a href="#42618428">next</a><span>|</span><label class="collapse" for="c-42613548">[-]</label><label class="expand" for="c-42613548">[1 more]</label></div><br/><div class="children"><div class="content">Right, metamorphic testing in particular (which would be a special case of PBT, with metamorphic relations being properties), <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Metamorphic_testing" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Metamorphic_testing</a>, <a href="https:&#x2F;&#x2F;github.com&#x2F;MattPD&#x2F;cpplinks&#x2F;blob&#x2F;master&#x2F;testing.md#property-based-testing-metamorphic">https:&#x2F;&#x2F;github.com&#x2F;MattPD&#x2F;cpplinks&#x2F;blob&#x2F;master&#x2F;testing.md#pr...</a><p>One simple example (from the above) is &quot;sin (π − x) = sin x&quot; for the implementation of the sine function not requiring the knowledge of its specific output values. Naturally, instead of the literal equality &quot;=&quot; one can use a more appropriate accuracy specification as in, say, relative ulp (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unit_in_the_last_place" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unit_in_the_last_place</a>) error bound, cf. <a href="https:&#x2F;&#x2F;members.loria.fr&#x2F;PZimmermann&#x2F;papers&#x2F;accuracy.pdf" rel="nofollow">https:&#x2F;&#x2F;members.loria.fr&#x2F;PZimmermann&#x2F;papers&#x2F;accuracy.pdf</a></div><br/></div></div></div></div><div id="42618428" class="c"><input type="checkbox" id="c-42618428" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#42612922">parent</a><span>|</span><a href="#42613094">prev</a><span>|</span><a href="#42616215">next</a><span>|</span><label class="collapse" for="c-42618428">[-]</label><label class="expand" for="c-42618428">[1 more]</label></div><br/><div class="children"><div class="content">For &quot;business applications,&quot; I much prefer the variant of property testing called model-based testing. This is where your property is &quot;does the implementation behave like some simplified model.&quot; This is the correct way to test such applications in my opinion, because users don&#x27;t care about &quot;custom widgets,&quot; &quot;queues,&quot; or &quot;databases.&quot; They care about business functionality, which is quite easily expressible in model form.<p>I don&#x27;t do much mocking either, because I also prefer integration tests for these types of applications. Here is an example that tests against a database, all the way up to the state management layer of the UI: <a href="https:&#x2F;&#x2F;concerningquality.com&#x2F;model-based-testing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;concerningquality.com&#x2F;model-based-testing&#x2F;</a>.<p>In fairness, people don&#x27;t write about doing this a lot. PBT literature seems to revolve around sorting functions or binary tree operations. But PBT much more powerful than just that.</div><br/></div></div><div id="42616215" class="c"><input type="checkbox" id="c-42616215" checked=""/><div class="controls bullet"><span class="by">thom</span><span>|</span><a href="#42612922">parent</a><span>|</span><a href="#42618428">prev</a><span>|</span><a href="#42612976">next</a><span>|</span><label class="collapse" for="c-42616215">[-]</label><label class="expand" for="c-42616215">[1 more]</label></div><br/><div class="children"><div class="content">I agree, but this is a good thing! My default approach these days is functional tests for everything possible, and property based tests for anything particularly algorithmic or containing lots of edge cases, and no unit tests outside that. This is a great combo, covers all the business value without leaving obscure bugs, and also isn’t a pain every time you refactor.</div><br/></div></div><div id="42612976" class="c"><input type="checkbox" id="c-42612976" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#42612922">parent</a><span>|</span><a href="#42616215">prev</a><span>|</span><a href="#42614178">next</a><span>|</span><label class="collapse" for="c-42612976">[-]</label><label class="expand" for="c-42612976">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found it effective for anything that handles arbitrary input, especially from end-users. But if that data is coming from within your systems where you have full control over everything, less valuable.</div><br/><div id="42617723" class="c"><input type="checkbox" id="c-42617723" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42612976">parent</a><span>|</span><a href="#42613148">next</a><span>|</span><label class="collapse" for="c-42617723">[-]</label><label class="expand" for="c-42617723">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s useful for things that would be too painful to enforce via types. For example, &quot;this list should be non-empty&quot; is pretty easy to enforce via types (use a pair of head element and possibly-empty tail list). On the other hand, something like &quot;map of non-overlapping date ranges to counts, with automatic splitting on insertion&quot; would be pretty tricky. It&#x27;s easier to state the desired properties as universally-quantified functions rather than types, at which point we might as well throw them into a few property checkers to see if they find anything we didn&#x27;t think of.</div><br/></div></div><div id="42613148" class="c"><input type="checkbox" id="c-42613148" checked=""/><div class="controls bullet"><span class="by">hitchstory</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42612976">parent</a><span>|</span><a href="#42617723">prev</a><span>|</span><a href="#42613294">next</a><span>|</span><label class="collapse" for="c-42613148">[-]</label><label class="expand" for="c-42613148">[4 more]</label></div><br/><div class="children"><div class="content">If the arbitrary input is, say, a text box which takes a name and puts it into a database, it probably won&#x27;t uncover any bugs.<p>It has some use if you build something like a complex pricing engine, numerical code or a parser for a mini DSL. I find that problems of this type don&#x27;t crop up a lot though.</div><br/><div id="42613737" class="c"><input type="checkbox" id="c-42613737" checked=""/><div class="controls bullet"><span class="by">IanCal</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42613148">parent</a><span>|</span><a href="#42613294">next</a><span>|</span><label class="collapse" for="c-42613737">[-]</label><label class="expand" for="c-42613737">[3 more]</label></div><br/><div class="children"><div class="content">I disagree.<p>I&#x27;ve used it for things like &quot;regardless of where you are on the page, tab n times and shift tab n times leaves you on the original item&quot;.<p>I found a bug in our tv ui library which was actually a bug in the spec. Regardless of how you built the ui, if you press a direction and focus moves, pressing the opposite direction takes you back - but we had another rule that broke this. We had tests for both, and it was only when I made the general test (for all ui, items in it and directions) it found the inconsistency.<p>It was also pretty easy to write.<p>I&#x27;ve also found issues around text processing due to lowercasing not always resulting in the same length string and more. I found a bug demoing pbt for a contact gig I was going for that was around some versioning.<p>To be honest I&#x27;ve never implemented it, even for a demo, and not found a bug.</div><br/><div id="42615686" class="c"><input type="checkbox" id="c-42615686" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42613737">parent</a><span>|</span><a href="#42613294">next</a><span>|</span><label class="collapse" for="c-42615686">[-]</label><label class="expand" for="c-42615686">[2 more]</label></div><br/><div class="children"><div class="content">&gt; To be honest I&#x27;ve never implemented it, even for a demo, and not found a bug.<p>Me too. I tend to roll my own property testers &#x2F; fuzzers per project instead of using a library. But my experience is similar to yours. Out of maybe 25 testers, I think the only times I didn’t find any bugs was when I messed up the tests themselves.<p>It’s incredibly humbling work.</div><br/><div id="42618667" class="c"><input type="checkbox" id="c-42618667" checked=""/><div class="controls bullet"><span class="by">IanCal</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42615686">parent</a><span>|</span><a href="#42613294">next</a><span>|</span><label class="collapse" for="c-42618667">[-]</label><label class="expand" for="c-42618667">[1 more]</label></div><br/><div class="children"><div class="content">I used to build these too, my example was one in actionscript (always fun on restricted devices) and it was a bug in a library I wrote. I was actually testing the property tester and found the bug then, after realizing it wasn&#x27;t a bug in the new test&#x2F;tester.<p>&gt; It’s incredibly humbling work<p>Absolutely. Glad others feel it too.<p>I almost feel like you need a decent reason why not to use them in places.<p>Ideally to can describe the behaviour of something in general terms around what stays true. If you can&#x27;t, is it too hard for people to understand?<p>I will however say I don&#x27;t usually write pbts but have a strong feeling I should add more.</div><br/></div></div></div></div></div></div></div></div><div id="42613294" class="c"><input type="checkbox" id="c-42613294" checked=""/><div class="controls bullet"><span class="by">jgalt212</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42612976">parent</a><span>|</span><a href="#42613148">prev</a><span>|</span><a href="#42614178">next</a><span>|</span><label class="collapse" for="c-42613294">[-]</label><label class="expand" for="c-42613294">[1 more]</label></div><br/><div class="children"><div class="content">Very true.  For me, fuzzers and property-based tests are two sides of the same coin.  I&#x27;d just use whichever feels more natural.</div><br/></div></div></div></div><div id="42614178" class="c"><input type="checkbox" id="c-42614178" checked=""/><div class="controls bullet"><span class="by">thehappyfellow</span><span>|</span><a href="#42612922">parent</a><span>|</span><a href="#42612976">prev</a><span>|</span><a href="#42619285">next</a><span>|</span><label class="collapse" for="c-42614178">[-]</label><label class="expand" for="c-42614178">[12 more]</label></div><br/><div class="children"><div class="content">How come e.g. Jane Street uses it so much? It’s the second most common type of test I write.</div><br/><div id="42616438" class="c"><input type="checkbox" id="c-42616438" checked=""/><div class="controls bullet"><span class="by">TypingOutBugs</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42614178">parent</a><span>|</span><a href="#42614276">next</a><span>|</span><label class="collapse" for="c-42616438">[-]</label><label class="expand" for="c-42616438">[1 more]</label></div><br/><div class="children"><div class="content">Jane Street uses OCaml and property based tests are easiest when dealing with pure functions, and are taught in FP classes usually, so I assume it’s that. Easier to setup and target audience.<p>Edit: also a numerical domain, which is the easiest type to use them for in my experience!</div><br/></div></div><div id="42614276" class="c"><input type="checkbox" id="c-42614276" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42614178">parent</a><span>|</span><a href="#42616438">prev</a><span>|</span><a href="#42617093">next</a><span>|</span><label class="collapse" for="c-42614276">[-]</label><label class="expand" for="c-42614276">[8 more]</label></div><br/><div class="children"><div class="content">The same reason Google burns $50M+ in electricity each year using protobufs instead of a more efficient format. An individual company having specific needs isn&#x27;t at odds with a general statement being broadly true.</div><br/><div id="42614623" class="c"><input type="checkbox" id="c-42614623" checked=""/><div class="controls bullet"><span class="by">thehappyfellow</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42614276">parent</a><span>|</span><a href="#42614877">next</a><span>|</span><label class="collapse" for="c-42614623">[-]</label><label class="expand" for="c-42614623">[3 more]</label></div><br/><div class="children"><div class="content">How’s that comparable at all? There are no network effects from writing property based tests, people use them if they are helpful - are they testing enough of the code with reasonable amount of effort. Nobody’s forcing people to write tests, unlike Google forces usage of protobuf on all projects there.</div><br/><div id="42616743" class="c"><input type="checkbox" id="c-42616743" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42614623">parent</a><span>|</span><a href="#42614877">next</a><span>|</span><label class="collapse" for="c-42616743">[-]</label><label class="expand" for="c-42616743">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s comparable in the way described in sentence #2:<p>&gt; An individual company having specific needs isn&#x27;t at odds with a general statement being broadly true.<p>Google needs certain things more than reduced carbon emissions, and Jane Street needs certain things more than whatever else they could spend that dev time on.</div><br/><div id="42617638" class="c"><input type="checkbox" id="c-42617638" checked=""/><div class="controls bullet"><span class="by">thehappyfellow</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42616743">parent</a><span>|</span><a href="#42614877">next</a><span>|</span><label class="collapse" for="c-42617638">[-]</label><label class="expand" for="c-42617638">[1 more]</label></div><br/><div class="children"><div class="content">Fine but cutting the thought process at &quot;it depends&quot; is not a great way to understand what&#x27;s happening here. You can explain anything happening at any company by saying &quot;they need certain things more than whatever else they could spend that time on&quot;.<p>Why is PBT useful at Jane Street, at least more than in other places? Is it the use of functional language? Average Jane Street dev being more familiar with PBT? Is the domain particularly suited to this style of testing?<p>Explicitly, my claim is that the biggest bottleneck is education on how to use PBT effectively and Jane Street is not using them to get an extra mile in safety, they use it because it&#x27;s the easiest way to write large chunk of the tests.</div><br/></div></div></div></div></div></div><div id="42614877" class="c"><input type="checkbox" id="c-42614877" checked=""/><div class="controls bullet"><span class="by">cyberpunk</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42614276">parent</a><span>|</span><a href="#42614623">prev</a><span>|</span><a href="#42617093">next</a><span>|</span><label class="collapse" for="c-42614877">[-]</label><label class="expand" for="c-42614877">[4 more]</label></div><br/><div class="children"><div class="content">Not to derail but what’s more efficient in your view? We compared messagepack, standard http&#x2F;json and probufs for an internal service and protobufs came out tops on every measure we had.</div><br/><div id="42617123" class="c"><input type="checkbox" id="c-42617123" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42614877">parent</a><span>|</span><a href="#42617093">next</a><span>|</span><label class="collapse" for="c-42617123">[-]</label><label class="expand" for="c-42617123">[3 more]</label></div><br/><div class="children"><div class="content">The gold standard is a purpose-built protocol for each message, usually coming in ~20x faster and ~2-8x smaller than a comparable proto (it&#x27;s perhaps obvious why Google doesn&#x27;t do this, since the developer workload is increased for every message even in a single language, and it&#x27;s linear in the number of languages you support, without the ability to shove most of the bugginess questions to a single shared library, and backwards compatibility is complicated with custom protocols -- they really do want you to be able to link against most g3 code without interop concerns). I&#x27;ve had a lot of success in my career with custom protocols in performance-sensitive applications, and I wouldn&#x27;t hesitate to do it again.<p>Barring that though, capnproto and flatbuffers (perhaps with compression on slow networks) are usually faster than protos. Other people have observed that performance deficit on many occasions and made smaller moderately general-purpose libraries before too (like SBE). They all have their own flavors of warts, but they&#x27;re all often much faster for normal use cases than protos.<p>As a hybrid, each project defining its own (de)serializer library can work well too. I&#x27;ve done that a few times, and it&#x27;s pretty easy to squeeze out 10x-20x throughput for the serialization features your project actually needs while still only writing the serialization crap once and reusing it for all your data types.<p>Recapping on a few reasons why protos are slow:<p>- There&#x27;s a data dependency built into the wire format which is very hard to work around. It blocks nearly all attempts at CPU pipelining aND vectorization.<p>- Lengths are prefixed (and the data is variable-length), requiring (recursively) you to serialize a submessage before serializing its header -- either requiring copies or undersized syscalls.<p>- Fields are allowed to appear in any order, preventing any sort of code which might make the branch predictor happy.<p>- Some non-&quot;zero-copy&quot; protocols are still quite fast since you can get away with a single allocation. Since several decisions make walking the structure slow, that&#x27;s way more expensive that it should be for protos, requiring either multiple (slow) walks or recursive allocations.<p>- The complexity of the format opens up protos to user error. Nonsense like using a 10-byte slow-to-decode-varint for the constant -1 instead of either 1, 4, or 8 fast-to-decode bytes (which _are_ supported by the wire format, but in the wild I see a lot of poorly suited proto specs).<p>- The premise in the protocol that you&#x27;ll decode the entire type exactly as the proto defines prevents a lot of downstream optimizations. If you want a shared data language (the `.proto` file), you have to modify that language to enforce, e.g., non-nullability constraints (you&#x27;d prefer to quickly short-circuit those as parse errors, but instead you need extra runtime logic to parse the parsed proto). You start having to trade off reusability for performance.<p>And so on. It&#x27;s an elegant format that solves some real problems, but there are precious few cases where it&#x27;s a top contender for performance (those cases tend to look like bulk data in some primitive type protos handle well, as opposed to arbitrary nesting of 1000 unrelated fields).<p>Specific languages might have (of course) failed to optimize other options so much that protos still win. It sounds like you&#x27;re using golang, which I&#x27;ve not done much with (coming from other languages, I&#x27;m mildly surprised that messagepack didn&#x27;t win any of your measurements), and by all means you should choose tools based on the data you have. My complaints are all about what the CPU is capable of for a given protocol, and how optimization looks from a systems language perspective.</div><br/><div id="42618569" class="c"><input type="checkbox" id="c-42618569" checked=""/><div class="controls bullet"><span class="by">achierius</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42617123">parent</a><span>|</span><a href="#42617093">next</a><span>|</span><label class="collapse" for="c-42618569">[-]</label><label class="expand" for="c-42618569">[2 more]</label></div><br/><div class="children"><div class="content">What does a &#x27;purpose-built protocol for each message&#x27; look like? You avoid type&#x2F;tagging overhead, but other than that I&#x27;d expect a &quot;&quot;sufficiently smart&quot;&quot; generic protocol to be able to achieve the same level of e.g. data layout optimization. Obviously ProtoBuf in particular is pessimising for the reasons you describe, but I&#x27;m thinking of other protocols (e.g. Flatbuffers, Cap&#x27;n Proto, etc.)</div><br/><div id="42620038" class="c"><input type="checkbox" id="c-42620038" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42618569">parent</a><span>|</span><a href="#42617093">next</a><span>|</span><label class="collapse" for="c-42620038">[-]</label><label class="expand" for="c-42620038">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that &quot;sufficiently smart&quot; does a lot of heavy lifting.<p>One way to look at the problem is to go build a sufficiently smart generic protocol and write down everything that&#x27;s challenging to support in v1. You have tradeoffs between size (slow for slow networks), data dependencies (slow for modern CPUs), lane segmentation (parallel processing vs cache-friendly single-core access vs code complexity), forward&#x2F;backward compatibility, how much validation should the protocol do, .... Any specific data serialization problem usually has some outside knowledge you can use to remove or simplify a few of those &quot;requirements,&quot; and knowledge of the surrounding system can further guide you to have efficient data representations on _both_ sides of the transfer. Code that&#x27;s less general-purpose tends to have more opportunities fore being small, fast, and explainable.<p>A common source of inefficiencies (protobuf is not unique in this) is the use of a schema language in any capacity as a blunt weapon to bludgeon the m x n problem between producers and consumers. The coding pattern of generating generic producers&#x2F;consumers doesn&#x27;t allow for fine-tuning of any producer&#x2F;consumer pair.<p>Picking on flatbuffers as an example (I _like_ the project, but I&#x27;ll ignore that sentiment for the moment), the vtable approach is smart and flexible, but it&#x27;s poorly suited (compared to a full &quot;parse&quot; step) to data you intend to access frequently, especially when doing narrow operations. It&#x27;s an overhead (one that reduces the ability for the CPU to pipeline your operations) you incur precisely by trying to define a generic format which many people can produce and consume, especially when the tech that produces that generic format is itself generic (operating on any valid schema file). Fully generic code is hard enough to make correct, much less fast, so in the aim of correctness and maintainability you usually compromise on speed somewhere.<p>For that (slightly vague) flatbuffers example, the &quot;purpose-built protocol&quot; could be as simple as almost anything else with a proper parse step. That might even be cap&#x27;n proto, though that also has problems in certain kinds of nested&#x2F;repeated structures because of its arena allocation strategy (better than protobuf, but still more allocations and wasted space than you&#x27;d like).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42617093" class="c"><input type="checkbox" id="c-42617093" checked=""/><div class="controls bullet"><span class="by">hitchstory</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42614178">parent</a><span>|</span><a href="#42614276">prev</a><span>|</span><a href="#42619285">next</a><span>|</span><label class="collapse" for="c-42617093">[-]</label><label class="expand" for="c-42617093">[2 more]</label></div><br/><div class="children"><div class="content">Trading companies are unusual in writing a lot of algo-heavy code. Did you assume every company was like this?<p>I can assure you they arent.</div><br/><div id="42617649" class="c"><input type="checkbox" id="c-42617649" checked=""/><div class="controls bullet"><span class="by">thehappyfellow</span><span>|</span><a href="#42612922">root</a><span>|</span><a href="#42617093">parent</a><span>|</span><a href="#42619285">next</a><span>|</span><label class="collapse" for="c-42617649">[-]</label><label class="expand" for="c-42617649">[1 more]</label></div><br/><div class="children"><div class="content">Even trading companies have a ton of project and code which you&#x27;ll find at any reasonably sized tech company, the algo-heavy code is a small fraction of the total code they write. In this sense, they are not such an outlier just based on the business they are in - I think the use of a functional language, good tooling and education around PBT are much more important factors.</div><br/></div></div></div></div></div></div><div id="42619285" class="c"><input type="checkbox" id="c-42619285" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#42612922">parent</a><span>|</span><a href="#42614178">prev</a><span>|</span><a href="#42613612">next</a><span>|</span><label class="collapse" for="c-42619285">[-]</label><label class="expand" for="c-42619285">[1 more]</label></div><br/><div class="children"><div class="content">I have to admit that after all these years the term &quot;integration tests&quot; is near meaningless me. But proberty based testing is absolutely real. If you can think of one example based test you can probably think of a way to generalise them. It&#x27;s a powerful idea, much more powerful than trying to remember what exactly a &quot;unit&quot; means.</div><br/></div></div></div></div><div id="42613612" class="c"><input type="checkbox" id="c-42613612" checked=""/><div class="controls bullet"><span class="by">dpc_01234</span><span>|</span><a href="#42612922">prev</a><span>|</span><a href="#42614910">next</a><span>|</span><label class="collapse" for="c-42613612">[-]</label><label class="expand" for="c-42613612">[1 more]</label></div><br/><div class="children"><div class="content">Would be very valuable if someone could write a summary of novel ideas for practitioners (if there are any).</div><br/></div></div><div id="42614910" class="c"><input type="checkbox" id="c-42614910" checked=""/><div class="controls bullet"><span class="by">choeger</span><span>|</span><a href="#42613612">prev</a><span>|</span><a href="#42618452">next</a><span>|</span><label class="collapse" for="c-42614910">[-]</label><label class="expand" for="c-42614910">[1 more]</label></div><br/><div class="children"><div class="content">Nice work. I didn&#x27;t yet read it fully, but I love the idea. Looks to be a valuable thesis.</div><br/></div></div><div id="42618452" class="c"><input type="checkbox" id="c-42618452" checked=""/><div class="controls bullet"><span class="by">erichocean</span><span>|</span><a href="#42614910">prev</a><span>|</span><label class="collapse" for="c-42618452">[-]</label><label class="expand" for="c-42618452">[1 more]</label></div><br/><div class="children"><div class="content">LLMs are great at generating property-based tests.</div><br/></div></div></div></div></div></div></div></body></html>