<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704877265414" as="style"/><link rel="stylesheet" href="styles.css?v=1704877265414"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.redplanetlabs.com/2024/01/09/everything-wrong-with-databases-and-why-their-complexity-is-now-unnecessary/">Databases and why their complexity is now unnecessary</a>Â <span class="domain">(<a href="https://blog.redplanetlabs.com">blog.redplanetlabs.com</a>)</span></div><div class="subtext"><span>adamfeldman</span> | <span>170 comments</span></div><br/><div><div id="38937420" class="c"><input type="checkbox" id="c-38937420" checked=""/><div class="controls bullet"><span class="by">register</span><span>|</span><a href="#38936785">next</a><span>|</span><label class="collapse" for="c-38937420">[-]</label><label class="expand" for="c-38937420">[3 more]</label></div><br/><div class="children"><div class="content">Pure B...t.
The title is deceiving and should be instead something along the lines of:
How to architect an application at Mastodon scale without relying on databases.
Also I would be very interested in seeing the actual technology rather than reading sensational claims about the unparalled level of scalability it supports.
What does it provide in order to recover from failure and exceptions and to guarantee consistency of state?<p>Relational databases are and will always be necessary as they provide a convenient model for querying, aggregating, joining and reporting data.<p>Much of the value in a database lies in how it supports extracting value from business information rather  what extreme scalability features it supports.<p>Try to create a decent business report from events and then we can speak again.</div><br/><div id="38937892" class="c"><input type="checkbox" id="c-38937892" checked=""/><div class="controls bullet"><span class="by">vmfunction</span><span>|</span><a href="#38937420">parent</a><span>|</span><a href="#38937878">next</a><span>|</span><label class="collapse" for="c-38937892">[-]</label><label class="expand" for="c-38937892">[1 more]</label></div><br/><div class="children"><div class="content">Many many years ago (maybe middle 2000&#x27;s), while working for a company (Flickr competitor) that has customised a Gallery (an open source PHP photo album online). The version we forked doesn&#x27;t use db, rather a file to keep track of each gallery at the root of the folder.  So technically I told my boss that it is infinitely scalable. However it is really difficult to search and run reports on these databaseless Gallery nodes. Database a long with word processing and spreadsheets are one these early days &#x27;killer apps&#x27; that reflected the usefulness of that type of computing usage for humans.</div><br/></div></div><div id="38937878" class="c"><input type="checkbox" id="c-38937878" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#38937420">parent</a><span>|</span><a href="#38937892">prev</a><span>|</span><a href="#38936785">next</a><span>|</span><label class="collapse" for="c-38937878">[-]</label><label class="expand" for="c-38937878">[1 more]</label></div><br/><div class="children"><div class="content">I mean, AcitivityPub is pretty much the ideal case for this architecture. ActivityPub&#x2F;the underlying ActivityStream consists of activities that manipulates entities. The activities are in principle immutable, even if the entities they may create are not, and you can largely naively serialize them into a log, and partition them naively by actor or by server and actor or any number of schemes, to put them into the initial &quot;depot&quot;.<p>From there, materializing indexes is trivial, and replicating that is also fairly trivial. You &quot;just&quot; need a bunch of workers processing the depot logs into these &quot;P-stores&quot;<p>If your requirements fits that, then recovery from failures &quot;just&quot; requires having replicas of the depots, which is &quot;easy&quot; as you just stream the logs elsewhere, and archive them to, say, a blob store, combined with the ability to reset the &quot;cursors&quot; of the workers populating the P-stores.<p>It&#x27;s an architecture that works very well when you want to index and query large sets of data where the order either doesn&#x27;t matter (much) or you can order &quot;well enough&quot; from the data itself, so you can stream to multiple &quot;depots&quot; without worrying about assigning a global order. Such as ActivityPub.  E.g. it doesn&#x27;t really matter for Mastodon if a reply appears a second before the post its a reply to, because the key linking them together is there and you need to be able to gracefully handle the case where you <i>never</i> get the original or <i>isn&#x27;t even allowed to</i> fetch it.<p>So I don&#x27;t doubt they can achieve this, and a platform that makes that easy would be nice.<p>Their problem is that 1) very few people have data problems that are large enough that it isn&#x27;t easier to &quot;just&quot; buy&#x2F;rent a larger database for the depots, 2) or even that have a dataset large enough that they&#x27;d need a secondary set of servers to handle the materialization of views (or need the views to actually be materialized in the first place), 3) and even if they do, running workers to populate a secondary set isn&#x27;t hard. It&#x27;s also trivial to use tools your devs are already familiar with for the depots and &quot;P-stores&quot;. E.g. Postgres works just fine for both until you have an architecture far larger than most people ever need to deal with, but there are many other options too.<p>Once you start running into challenges with that, the obvious, well-known method is to stream into append-only logs, cut the logs regularly, run the indexers on the new log elements into indexed segments, and zipper merge the log elements and do streaming compression of the values (e.g. arithmetic coding is a common, trivial method) + a skip list. Since the point of these &quot;P-stores&quot; is to reduce the datasets to something where queries are low-complexity, you can generally assume you won&#x27;t need to support much fancy re-ordering and grouping etc., mostly cheap filtering, coupled with streaming merges of query results from multiple P-store partitions. This is the &quot;do it yourself&quot; solution, which you can find &quot;packaged up&quot; in any number of search solutions, like Elasticsearch, Lucene, Sphinx etc., but it&#x27;s also not all that hard to build from scratch for a specific use case.<p>This method has been used for e.g. search engines &quot;forever&quot;. First time any system I worked on actually needed it was ca 2006, and we first used Sphinx, then built a custom one (single developer effort; needed only because Sphinx at the time had only a fraction of the features it has today)<p>Basically, they&#x27;re building a distributed database that just has very opinionated ideas about the type of problems you should be solving and how. If your problem fits in that it&#x27;s very possible they can provide something &quot;turn key&quot; that is more cohesive and better packaged up than picking and choosing your own components for the depot and indexes and writing your own indexing workers, but as you say, to most people the extreme scalability isn&#x27;t the issue and a regular database is enough.<p>Addressing the Twitter and Mastodon cases is kind of a warning here, because both Twitter and Mastodon (the software) started out with a tremendously naive architecture in this respect, so it&#x27;s a low hanging fruit if you want to show off impressive-looking improvements.<p>In terms of reporting, this architecture isn&#x27;t a problem, because you&#x27;d not be working from events, but from the &quot;P-stores&quot; and nothing stops you from ensuring that data is trivially queryable with something reasonable. E.g. either using something like Postgres for the P-stores themselves, or just streaming the data into whatever you want to do reporting from.<p>But again, it doesn&#x27;t need to replace the database.</div><br/></div></div></div></div><div id="38936785" class="c"><input type="checkbox" id="c-38936785" checked=""/><div class="controls bullet"><span class="by">benlivengood</span><span>|</span><a href="#38937420">prev</a><span>|</span><a href="#38930479">next</a><span>|</span><label class="collapse" for="c-38936785">[-]</label><label class="expand" for="c-38936785">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t notice a mention of transactions in the article, nor of constraints.  It&#x27;s all fine to claim that you can compose arbitrary event source domains together and query them but IMHO the biggest power of RDBMS are transactions and constraints for data integrity.  Maybe Rama comes with amazing composability features that ensure cross-domain constraints, but I would be really surprised if they can maintain globally consistent real-time transactions.<p>I&#x27;ve worked on huge ETL pipelines with materialized views (Photon, Ubiq, Mesa) and the business logic in Ubiq to materialize the view updates for Mesa was immense.  None of it was transactional; everything  was for aggregate statistics and so it worked well.  Ads-DB and Payments used Spanner for very good reasons.</div><br/></div></div><div id="38930479" class="c"><input type="checkbox" id="c-38930479" checked=""/><div class="controls bullet"><span class="by">morsecodist</span><span>|</span><a href="#38936785">prev</a><span>|</span><a href="#38937572">next</a><span>|</span><label class="collapse" for="c-38930479">[-]</label><label class="expand" for="c-38930479">[10 more]</label></div><br/><div class="children"><div class="content">This is more an advertisement for a type of database than a statement that they are unnecessary.<p>From what I can tell in the article it seems their differentiator is Event Sourcing and having arbitrary complex index builders on top of the events. It seems similar to EventStoreDB[1].<p>I have always been interested by the concept of an event sourcing database with projections and I want to build one eventually so it is interesting to see how they have approached the problem.<p>Also they mention on their site:<p>&gt; Rama is programmed entirely with a Java API â no custom languages or DSLs.<p>It makes sense why they have gone this route if they want a &quot;Turing-complete dataflow API&quot; but this can be a major barrier to adoption. This is a big challenge with implementing these databases in my opinion because you want to allow for any logic to build out your indexes&#x2F;projections&#x2F;views but then you are stuck between a new complicated DSL or using a particular language.<p>1: <a href="https:&#x2F;&#x2F;developers.eventstore.com&#x2F;server&#x2F;v23.10&#x2F;#getting-started" rel="nofollow">https:&#x2F;&#x2F;developers.eventstore.com&#x2F;server&#x2F;v23.10&#x2F;#getting-sta...</a></div><br/><div id="38937891" class="c"><input type="checkbox" id="c-38937891" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#38930479">parent</a><span>|</span><a href="#38931204">next</a><span>|</span><label class="collapse" for="c-38937891">[-]</label><label class="expand" for="c-38937891">[1 more]</label></div><br/><div class="children"><div class="content">A Java API doesn&#x27;t mean you can only access it from Java. Such APIs can also be accessed from most languages. Obviously bytecode languages like Clojure, Kotlin, Scala, Groovy etc. But also via Truffle languages like JS, Python, Ruby. All without bindings.<p>You can also do C++ and Rust, but that does require a bit of binding work.<p>So it&#x27;s not really limiting you to a single language, or these days, even a single runtime.</div><br/></div></div><div id="38931204" class="c"><input type="checkbox" id="c-38931204" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#38930479">parent</a><span>|</span><a href="#38937891">prev</a><span>|</span><a href="#38937286">next</a><span>|</span><label class="collapse" for="c-38931204">[-]</label><label class="expand" for="c-38931204">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; This is more an advertisement for a type of database than a statement that they are unnecessary.</i><p>That was my reaction as well. The article&#x27;s claimed argument against databases is that they are global mutable state, which is supposed to be bad. But none of what the article advocates for gets rid of global mutable state (which of course you <i>can&#x27;t</i> do in any real world application, because the real world itself is global mutable state and anything that deals with the real world has to deal with that). It&#x27;s just hawking a particular way of storing global mutable state.</div><br/><div id="38937322" class="c"><input type="checkbox" id="c-38937322" checked=""/><div class="controls bullet"><span class="by">a-saleh</span><span>|</span><a href="#38930479">root</a><span>|</span><a href="#38931204">parent</a><span>|</span><a href="#38937286">next</a><span>|</span><label class="collapse" for="c-38937322">[-]</label><label class="expand" for="c-38937322">[1 more]</label></div><br/><div class="children"><div class="content">T.b.h. when looking at things, global mutable state might not be bad, if it is principled?<p>I.e. I did like how Clojure had it&#x27;s atomically updating refs.<p>And you realisticaly won&#x27;t get more principled than with traditional RDBS, with it&#x27;s ability to transactions, rollbacks, e.t.c.<p>Only alternative that I have seen proposed to using DBAS while not relaxing the guaranties, is to double down on event-sourcing and not having mutable-state anymore. Everything could be just a fold over all of the incomming events, right? But I don&#x27;t think I have seen non-toy example of that anywhere I worked at.</div><br/></div></div></div></div><div id="38937286" class="c"><input type="checkbox" id="c-38937286" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#38930479">parent</a><span>|</span><a href="#38931204">prev</a><span>|</span><a href="#38930795">next</a><span>|</span><label class="collapse" for="c-38937286">[-]</label><label class="expand" for="c-38937286">[3 more]</label></div><br/><div class="children"><div class="content">Agreed that this article is an advert for a certain database type, but the advert for red planet labs worked. I certainly read it! :)</div><br/><div id="38937347" class="c"><input type="checkbox" id="c-38937347" checked=""/><div class="controls bullet"><span class="by">andreareina</span><span>|</span><a href="#38930479">root</a><span>|</span><a href="#38937286">parent</a><span>|</span><a href="#38930795">next</a><span>|</span><label class="collapse" for="c-38937347">[-]</label><label class="expand" for="c-38937347">[2 more]</label></div><br/><div class="children"><div class="content">It also turned me off from them so there&#x27;s that.</div><br/><div id="38937367" class="c"><input type="checkbox" id="c-38937367" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#38930479">root</a><span>|</span><a href="#38937347">parent</a><span>|</span><a href="#38930795">next</a><span>|</span><label class="collapse" for="c-38937367">[-]</label><label class="expand" for="c-38937367">[1 more]</label></div><br/><div class="children"><div class="content">Good point. I donât use red planet labs product myself either, but in a world where it is hard to get people to even consider your product the article did work</div><br/></div></div></div></div></div></div><div id="38930795" class="c"><input type="checkbox" id="c-38930795" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930479">parent</a><span>|</span><a href="#38937286">prev</a><span>|</span><a href="#38937572">next</a><span>|</span><label class="collapse" for="c-38930795">[-]</label><label class="expand" for="c-38930795">[3 more]</label></div><br/><div class="children"><div class="content">True, Rama does have a learning curve. It&#x27;s easier to explain why its indexing capabilities are so powerful, as data structures vs. data models is fairly relatable to most devs. But I actually consider its dataflow API to be the bigger breakthrough. Our Twitter-scale Mastodon implementation and examples in rama-demo-gallery are demonstrations of this.<p>Also, Rama has a first-class Clojure API (I should probably update the website).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;twitter-scale-mastodon">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;twitter-scale-mastodon</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery</a></div><br/><div id="38931466" class="c"><input type="checkbox" id="c-38931466" checked=""/><div class="controls bullet"><span class="by">morsecodist</span><span>|</span><a href="#38930479">root</a><span>|</span><a href="#38930795">parent</a><span>|</span><a href="#38937572">next</a><span>|</span><label class="collapse" for="c-38931466">[-]</label><label class="expand" for="c-38931466">[2 more]</label></div><br/><div class="children"><div class="content">Cool on the clojure API. Functional programing really fits with this sort of thing. Does your implementation limit you to the JVM?</div><br/><div id="38931983" class="c"><input type="checkbox" id="c-38931983" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930479">root</a><span>|</span><a href="#38931466">parent</a><span>|</span><a href="#38937572">next</a><span>|</span><label class="collapse" for="c-38931983">[-]</label><label class="expand" for="c-38931983">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s JVM-only for the foreseeable future.</div><br/></div></div></div></div></div></div></div></div><div id="38937572" class="c"><input type="checkbox" id="c-38937572" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#38930479">prev</a><span>|</span><a href="#38937300">next</a><span>|</span><label class="collapse" for="c-38937572">[-]</label><label class="expand" for="c-38937572">[1 more]</label></div><br/><div class="children"><div class="content">I get what they&#x27;re trying to do but I&#x27;m not sure this [0] syntax is the answer.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;twitter-scale-mastodon&#x2F;blob&#x2F;master&#x2F;backend&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;rpl&#x2F;mastodon&#x2F;modules&#x2F;Notifications.java#L70">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;twitter-scale-mastodon&#x2F;blob...</a></div><br/></div></div><div id="38937300" class="c"><input type="checkbox" id="c-38937300" checked=""/><div class="controls bullet"><span class="by">fifticon</span><span>|</span><a href="#38937572">prev</a><span>|</span><a href="#38937676">next</a><span>|</span><label class="collapse" for="c-38937300">[-]</label><label class="expand" for="c-38937300">[2 more]</label></div><br/><div class="children"><div class="content">I work in a shop with about 6 years of event-sourcing experience (as in, our production has run on eventsourcing since 2017).
  My view is, that &#x27;humans are not mature enough for eventsourcing&#x27;. For eventsourcing to work sanely, it must be used responsibly. Reality is, that people make mistakes, and eventsourcing HURTS whenever your developers don&#x27;t act maturely on the common history you have built.
  For us, it has meant a bungee jump of &quot;move ALL the things to eventsourcing&quot;, followed by a long slow painful &#x27;move everything that doesn&#x27;t NEED eventsourcing out of eventsourcing again, into relational database, and only keep the relevant eventsourcing parts in the actual eventsource db&#x27;.<p>The main consequences for us have been &#x27;consume a huge&#x2F;expensive amount of resources&#x27; to do what we already did earlier, with vastly fewer resources, at the benefit of having some things easier to do, and a lot of other things suddenly complex.
In particular, it was not a &#x27;costless abstraction&#x27;, instead it forced us to always consider the consequences for our eventsourcing.</div><br/><div id="38937589" class="c"><input type="checkbox" id="c-38937589" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#38937300">parent</a><span>|</span><a href="#38937676">next</a><span>|</span><label class="collapse" for="c-38937589">[-]</label><label class="expand" for="c-38937589">[1 more]</label></div><br/><div class="children"><div class="content">I know of teams that spent over a year trying to build a generic import system on streams, at multiple companies, and in both cases they should have just stood up a simple service on boxes with a lot of ram and auto scaling. Load CSV into memory. Done.</div><br/></div></div></div></div><div id="38937676" class="c"><input type="checkbox" id="c-38937676" checked=""/><div class="controls bullet"><span class="by">kopos</span><span>|</span><a href="#38937300">prev</a><span>|</span><a href="#38930062">next</a><span>|</span><label class="collapse" for="c-38937676">[-]</label><label class="expand" for="c-38937676">[1 more]</label></div><br/><div class="children"><div class="content">The comments here are needlessly pessimistic and dismissive of a new data flow paradigm. In fact, this looks like the best NoSQL experience there is. SQL while is a standard now, had to prove itself many times over and also was a result of a massive push by few big tech backers.<p>Rama still looks like it needs some starter examples - that is all.<p>From what i could gather reading the documentation over few weeks... Rama is an engine supporting Stored Procedure over NoSQL systems. That point alone is worth a million bucks. I hope it lives up to the promise.<p>Now back to my coding :D</div><br/></div></div><div id="38930062" class="c"><input type="checkbox" id="c-38930062" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38937676">prev</a><span>|</span><a href="#38930378">next</a><span>|</span><label class="collapse" for="c-38930062">[-]</label><label class="expand" for="c-38930062">[66 more]</label></div><br/><div class="children"><div class="content">&gt; No single data model can support all use cases.<p>In theory, there is no domain (or finite set of domains) that cannot be accurately modeled using tuples of things and their relations.<p>Practically speaking, the scope of a given database&#x2F;schema is generally restricted to one business or problem area, but even this doesn&#x27;t matter as long as the types aren&#x27;t aliasing inappropriately. You could put a web retailer and an insurance company in the same schema and it would totally work if you are careful with naming things.<p>Putting everything into exactly one database is a superpower. The #1 reason I push for this is to avoid the need to conduct distributed transactions across multiple datastores. If all business happens in one transactional system, your semantics are dramatically simplified.</div><br/><div id="38930251" class="c"><input type="checkbox" id="c-38930251" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38933339">next</a><span>|</span><label class="collapse" for="c-38930251">[-]</label><label class="expand" for="c-38930251">[31 more]</label></div><br/><div class="children"><div class="content">This this this.<p>&gt; Putting everything into exactly one database is a superpower.<p>Especially this.<p>$1M big iron DB server is much cheaper than a redundant array of inexpensive databases when people come to actually use the data; be it developers, analysts or leadership, everybody saves time, except perhaps a few DBAs.</div><br/><div id="38930307" class="c"><input type="checkbox" id="c-38930307" checked=""/><div class="controls bullet"><span class="by">asah</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930251">parent</a><span>|</span><a href="#38930874">next</a><span>|</span><label class="collapse" for="c-38930307">[-]</label><label class="expand" for="c-38930307">[10 more]</label></div><br/><div class="children"><div class="content">well I dunno, we&#x27;ve only tested this architecture for 60 years and a few million companies...<p>in all seriousness, putting the data in one place also makes it a lot easier to optimize and to amortize the optimization efforts.</div><br/><div id="38930430" class="c"><input type="checkbox" id="c-38930430" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930307">parent</a><span>|</span><a href="#38930780">next</a><span>|</span><label class="collapse" for="c-38930430">[-]</label><label class="expand" for="c-38930430">[7 more]</label></div><br/><div class="children"><div class="content">Is there any medium size company that keeps all its data in 1 place?</div><br/><div id="38937632" class="c"><input type="checkbox" id="c-38937632" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930430">parent</a><span>|</span><a href="#38930634">next</a><span>|</span><label class="collapse" for="c-38937632">[-]</label><label class="expand" for="c-38937632">[2 more]</label></div><br/><div class="children"><div class="content">Amazon&#x27;s entire system ran on a single Oracle cluster up until about 2008 (they were still at the tail end of phasing that out when I was there in 2012).</div><br/><div id="38937763" class="c"><input type="checkbox" id="c-38937763" checked=""/><div class="controls bullet"><span class="by">alexchamberlain</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38937632">parent</a><span>|</span><a href="#38930634">next</a><span>|</span><label class="collapse" for="c-38937763">[-]</label><label class="expand" for="c-38937763">[1 more]</label></div><br/><div class="children"><div class="content">There were no derivative stores (Redis caches? Solr views?) around it?</div><br/></div></div></div></div><div id="38930634" class="c"><input type="checkbox" id="c-38930634" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930430">parent</a><span>|</span><a href="#38937632">prev</a><span>|</span><a href="#38930777">next</a><span>|</span><label class="collapse" for="c-38930634">[-]</label><label class="expand" for="c-38930634">[1 more]</label></div><br/><div class="children"><div class="content">Itâs still fairly common for the majority of critical data to be in a single database. Even if microservice initiatives have moved some data out.</div><br/></div></div><div id="38930777" class="c"><input type="checkbox" id="c-38930777" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930430">parent</a><span>|</span><a href="#38930634">prev</a><span>|</span><a href="#38930780">next</a><span>|</span><label class="collapse" for="c-38930777">[-]</label><label class="expand" for="c-38930777">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked at two of them -- all data, sans pointers to content addressed immutable object storage, is stored in a single database. It worked well for us; it&#x27;s not rainbows and unicorns wow all of our problems disappeared but we got what we needed with sufficient performance for an app that was not well optimized.<p>There were challenges like the difficulty of working with a few huge tables that existed since the company&#x27;s inception and were practically infeasible to do any schema changes on, but that&#x27;s more a modeling issue. It was also a single point of failure service. If the db goes down so to does everything but constant sense of impending doom it was less of a problem than I thought with ndb.</div><br/><div id="38931250" class="c"><input type="checkbox" id="c-38931250" checked=""/><div class="controls bullet"><span class="by">hasty_pudding</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930777">parent</a><span>|</span><a href="#38930780">next</a><span>|</span><label class="collapse" for="c-38931250">[-]</label><label class="expand" for="c-38931250">[2 more]</label></div><br/><div class="children"><div class="content">Y&#x27;all couldn&#x27;t have some read-only clusters that could just take over as the master?</div><br/><div id="38933964" class="c"><input type="checkbox" id="c-38933964" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38931250">parent</a><span>|</span><a href="#38930780">next</a><span>|</span><label class="collapse" for="c-38933964">[-]</label><label class="expand" for="c-38933964">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, I mean a single point of failure <i>service</i>. I guess maybe the term would be large blast radius. The database implementation was HA to almost paranoid degrees but if we lost the database it was a total outage every service down for all customers. If the DB had issues there was really no sense of a partial outage.</div><br/></div></div></div></div></div></div></div></div><div id="38930780" class="c"><input type="checkbox" id="c-38930780" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930307">parent</a><span>|</span><a href="#38930430">prev</a><span>|</span><a href="#38930874">next</a><span>|</span><label class="collapse" for="c-38930780">[-]</label><label class="expand" for="c-38930780">[2 more]</label></div><br/><div class="children"><div class="content">More like 50 years...<p>But yeah.</div><br/><div id="38935788" class="c"><input type="checkbox" id="c-38935788" checked=""/><div class="controls bullet"><span class="by">readthenotes1</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930780">parent</a><span>|</span><a href="#38930874">next</a><span>|</span><label class="collapse" for="c-38935788">[-]</label><label class="expand" for="c-38935788">[1 more]</label></div><br/><div class="children"><div class="content">Or 70, but who can subitize that much?<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Sabre_Corporation" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Sabre_Corporation</a></div><br/></div></div></div></div></div></div><div id="38930874" class="c"><input type="checkbox" id="c-38930874" checked=""/><div class="controls bullet"><span class="by">tomxor</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930251">parent</a><span>|</span><a href="#38930307">prev</a><span>|</span><a href="#38930336">next</a><span>|</span><label class="collapse" for="c-38930874">[-]</label><label class="expand" for="c-38930874">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also entirely practical for everything that&#x27;s not twitter-like, i.e almost everything. But the most noise comes from people with the (admittedly more interesting) use case requirements at the data store level.<p>So long as your application doesn&#x27;t throw space and performance away at every opportunity, vertical scaling goes <i>really</i> far these days.</div><br/></div></div><div id="38930336" class="c"><input type="checkbox" id="c-38930336" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930251">parent</a><span>|</span><a href="#38930874">prev</a><span>|</span><a href="#38930462">next</a><span>|</span><label class="collapse" for="c-38930336">[-]</label><label class="expand" for="c-38930336">[18 more]</label></div><br/><div class="children"><div class="content">As someone bootstrapping a business, my cost structure favors horizontally scaling databases with low&#x2F;no fixed overhead vs vertically scaling databases with high overhead. And I donât think this is exactly an uncommon situation - plenty of people, even within large well-funded organizations, would have a hard time justifying such a large expenditure if it were uncertain that itâd be fully utilized.<p>Itâs also a lot easier for me to handle tenancy&#x2F;isolation&#x2F;different data ârealmsâ this way. And I sleep better at night knowing a mistake (I have no dbas, and I donât have time to invest in tons of safeguards as a solo dev when there are much higher EV tasks) wonât nuke absolutely everything.</div><br/><div id="38930382" class="c"><input type="checkbox" id="c-38930382" checked=""/><div class="controls bullet"><span class="by">smt88</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930336">parent</a><span>|</span><a href="#38930750">next</a><span>|</span><label class="collapse" for="c-38930382">[-]</label><label class="expand" for="c-38930382">[12 more]</label></div><br/><div class="children"><div class="content">For small companies, I&#x27;ve never started with horizontal scaling.<p>With vertical scaling and maybe 2-3 instances, I don&#x27;t have to worry about hasty ORM code that generates suboptimal queries.<p>If I have horizontal scaling, sometimes even a reasonable query that&#x27;s missing an explicit index can turn into a 30s query that I have to spend dev time debugging.</div><br/><div id="38930618" class="c"><input type="checkbox" id="c-38930618" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930382">parent</a><span>|</span><a href="#38930726">next</a><span>|</span><label class="collapse" for="c-38930618">[-]</label><label class="expand" for="c-38930618">[9 more]</label></div><br/><div class="children"><div class="content">I wish I could upvote this more. 95+% of startups will never need to scale past one reasonably sized single-instance database. Maybe they&#x27;ll want to have a couple of replicas running for a fast failover, but from a performance perspective, they should spend their time writing efficient queries instead of horizontally scaling.<p>It&#x27;s good to think about the what-ifs along the way. Can we shard this setup if we land a huge customer, or one that&#x27;s hyper-sensitive about having their data separated? If&#x2F;when that time comes, you&#x27;ll have ideas of what to do about it. But realistically, most companies never hit that point. Every hour spent worrying how to make their product FAANG-scale is an hour spent not making their product.</div><br/><div id="38930754" class="c"><input type="checkbox" id="c-38930754" checked=""/><div class="controls bullet"><span class="by">pi-e-sigma</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930618">parent</a><span>|</span><a href="#38930726">next</a><span>|</span><label class="collapse" for="c-38930754">[-]</label><label class="expand" for="c-38930754">[8 more]</label></div><br/><div class="children"><div class="content">I think most even semi-experienced developers know this. But doing the right thing is against their career grow goals so they overcomplicate the architecture on purpose.</div><br/><div id="38931540" class="c"><input type="checkbox" id="c-38931540" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930754">parent</a><span>|</span><a href="#38931778">next</a><span>|</span><label class="collapse" for="c-38931540">[-]</label><label class="expand" for="c-38931540">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think most even semi-experienced developers know this.<p>I&#x27;ve met plenty of pretty senior people believing the opposite and most of them likely aren&#x27;t good liars.</div><br/></div></div><div id="38931778" class="c"><input type="checkbox" id="c-38931778" checked=""/><div class="controls bullet"><span class="by">wharvle</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930754">parent</a><span>|</span><a href="#38931540">prev</a><span>|</span><a href="#38936967">next</a><span>|</span><label class="collapse" for="c-38931778">[-]</label><label class="expand" for="c-38931778">[5 more]</label></div><br/><div class="children"><div class="content">You also often have to <i>fight for</i> the right thing, then any problems that <i>do</i> happen are <i>your fault</i>.<p>When the dumbshit over engineered &quot;cloud architecture&quot; that was pushed on you (managers don&#x27;t get promoted or switch companies for a big raise by <i>reducing</i> their headcount... no, they get promoted by building a big team for a successful [please don&#x27;t check in on how it was doing two years later...] &quot;cloud transformation&quot;) has all kinds of problems and the costs shoot into the stratosphere, while five servers on a rack would have granted greater uptime and performance <i>in practice</i> for your usage patterns, and lower costs... it&#x27;s not your fault.<p>Have some bad luck and that simple solution you pushed for happens to experience an unlikely failure causing a significant outage in year 1, and your head&#x27;s on the chopping block.</div><br/><div id="38931951" class="c"><input type="checkbox" id="c-38931951" checked=""/><div class="controls bullet"><span class="by">pi-e-sigma</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38931778">parent</a><span>|</span><a href="#38936967">next</a><span>|</span><label class="collapse" for="c-38931951">[-]</label><label class="expand" for="c-38931951">[4 more]</label></div><br/><div class="children"><div class="content">What I experienced is that it doesn&#x27;t matter if I pushed for the right thing or inherited some overcomplicated shit. In case of any problems it&#x27;s always my fault anyway. You just can&#x27;t win.</div><br/><div id="38932330" class="c"><input type="checkbox" id="c-38932330" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38931951">parent</a><span>|</span><a href="#38936967">next</a><span>|</span><label class="collapse" for="c-38932330">[-]</label><label class="expand" for="c-38932330">[3 more]</label></div><br/><div class="children"><div class="content">If you want the latitude to affect meaningful change, then you are also going to have to accept all ownership surrounding that thing and likely far beyond. I know it gets some flak (for good reason), but concepts like extreme ownership are fundamentally how I am able to tolerate this &quot;everything is my fault&quot; experience.<p>If everything will be my fault in the end, then screw it - I will go ahead and take ownership&#x2F;control of <i>all</i> of those things and make sure they don&#x27;t come back around to bite me in the ass. If someone questions my authority, I always cast it in terms of &quot;how many weekends with your family are <i>you</i> willing to sacrifice to support that idea?&quot; Oftentimes this is all it takes to get those idle suggestions put in the bin so we can move forward.<p>Solving database circus in a real business environment requires disengaging all of the safeties and getting very messy with your free time, stress levels and other humans. It&#x27;s a front-loaded suffering though. If you <i>actually</i> know what you are doing and get through the schema refactor (and it sticks), everything is down-hill from that point. Getting one schema to rule them all and then having the team learn that schema == new common language by which you can communicate that did not exist prior. In our business, non-developers are just as aware of our tables, columns and relations as developers &amp; DBAs are. In some cases, they have <i>more</i> detail about how a field is used than I do.</div><br/><div id="38932434" class="c"><input type="checkbox" id="c-38932434" checked=""/><div class="controls bullet"><span class="by">pi-e-sigma</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38932330">parent</a><span>|</span><a href="#38936967">next</a><span>|</span><label class="collapse" for="c-38932434">[-]</label><label class="expand" for="c-38932434">[2 more]</label></div><br/><div class="children"><div class="content">I wish it would work in practice like that. Because in reality you can&#x27;t just start making unapproved changes unless you really want to get fired quickly. But you can&#x27;t get approval either. But you are &#x27;responsible&#x27; for keeping it up and running, too.</div><br/><div id="38933109" class="c"><input type="checkbox" id="c-38933109" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38932434">parent</a><span>|</span><a href="#38936967">next</a><span>|</span><label class="collapse" for="c-38933109">[-]</label><label class="expand" for="c-38933109">[1 more]</label></div><br/><div class="children"><div class="content">any ic engineering role in a big org has just a few ways to leverage change: oratory, effort, expertise, and resignation.<p>use the appropriate tools to solve the problem at hand. it depends.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38936967" class="c"><input type="checkbox" id="c-38936967" checked=""/><div class="controls bullet"><span class="by">fullstackchris</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930754">parent</a><span>|</span><a href="#38931778">prev</a><span>|</span><a href="#38930726">next</a><span>|</span><label class="collapse" for="c-38936967">[-]</label><label class="expand" for="c-38936967">[1 more]</label></div><br/><div class="children"><div class="content">&gt; doing the right thing is against their career growth goals<p>only if the people who are hiring you are just as ignorant</div><br/></div></div></div></div></div></div><div id="38930726" class="c"><input type="checkbox" id="c-38930726" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930382">parent</a><span>|</span><a href="#38930618">prev</a><span>|</span><a href="#38930750">next</a><span>|</span><label class="collapse" for="c-38930726">[-]</label><label class="expand" for="c-38930726">[2 more]</label></div><br/><div class="children"><div class="content">To elaborate, Iâm using managed databases that abstract away scaling so that my UX as a developer is that they are scaling horizontally (in data, and cost).<p>While Iâm pre-launch and doing testing, using a more traditional vertical model is money out of my pocket. And itâs not something I want to maintain after I launch either.<p>Also, Iâm creating something (a freemium game) where as a solo dev it will only be worth it for me to continue working on the business if it sees explosive growth. If Iâm lucky enough for that to materialize, there will be at least a few months before I can hire fulltime help for the product (while also being busy doing tons of other stuff) - it would be terrible to have to handle tons of db operations tasks or re-architect things to support growth during that time.<p>Basically, vertical scaling is optimizing for the wrong level of usage. Itâs actually the same for many of the snarky âyour startup doesnât need horizontal scalingâ comments here - if your states are  {building, huge growth, failure} then horizontal scaling is perfect because it keeps your costs low while youâre building and handles the huge growth phase more gracefully. Yes, maybe youâll never get to the huge growth phase, but the entire business is oriented around either getting there or failing.</div><br/><div id="38931870" class="c"><input type="checkbox" id="c-38931870" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930726">parent</a><span>|</span><a href="#38930750">next</a><span>|</span><label class="collapse" for="c-38931870">[-]</label><label class="expand" for="c-38931870">[1 more]</label></div><br/><div class="children"><div class="content">I certainly didn&#x27;t mean my comment to be snarky. However, I do want to be realistic. There&#x27;s an exception for every guideline. Maybe yours is that exception. I worked at a company like you described, where we had a few tens of thousands of users, but were actively in talks with a partner that would have given us international press, and who would have taken us to about 20 million <i>concurrent</i> users a month later. (Imagine a beer company telling their customers to use our app to interact with the Super Bowl broadcast. That sort of thing.) We spent a <i>lot</i> of time talking about horizontal scaling because that was the whole point of the company. Maybe yours is like that, too.<p>But the vast majority of small companies are <i>not</i> like that. They acquire one customer, then another, and another, and grow N&lt;=50% per year, with tons of headroom on default app configurations. For those companies, worrying about explosive, global scaling instead of, you know, building their business, is time they can&#x27;t get back.</div><br/></div></div></div></div></div></div><div id="38930750" class="c"><input type="checkbox" id="c-38930750" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930336">parent</a><span>|</span><a href="#38930382">prev</a><span>|</span><a href="#38930470">next</a><span>|</span><label class="collapse" for="c-38930750">[-]</label><label class="expand" for="c-38930750">[4 more]</label></div><br/><div class="children"><div class="content">Do you ever get to a place where you actually have to scale it? Like, the PC from my teenager age would probably be more than fast enough for 80% of companies&#x27; data.<p>Also, are you sure your data is actually in a correct view across all these &quot;realms&quot;?</div><br/><div id="38931057" class="c"><input type="checkbox" id="c-38931057" checked=""/><div class="controls bullet"><span class="by">opportune</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930750">parent</a><span>|</span><a href="#38930470">next</a><span>|</span><label class="collapse" for="c-38931057">[-]</label><label class="expand" for="c-38931057">[3 more]</label></div><br/><div class="children"><div class="content">Basically Iâm optimizing for viral growth, otherwise the business probably isnât worth it. I havenât launched yet but I estimate that at 100k DAU vertical scaling&#x2F;using a single instance would become a nightmare because of throughput and latency rather than data size.<p>Iâm admittedly using a strange architecture for my use case and I realize now commenting here opened too big a can of worms as explaining exactly what Iâm doing would derail the thread. Suffice it to say, my db doesnât contain just âBob ordered 5 widgets to Foo Laneâ data.<p>But yes, using a more horizontal database strategy makes it very easy to manage data across realms. Thatâs one of the main benefits. A single DB would be much harder as far as isolation and separating test&#x2F;production traffic (assuming this is what you mean by views) than having multiple separable dbs that only talk to dev&#x2F;staging. And I can easily wipe out and isolate dev and staging this way. Iâm frankly shocked people would advocate a single db that doesnât allow you to do this.</div><br/><div id="38933145" class="c"><input type="checkbox" id="c-38933145" checked=""/><div class="controls bullet"><span class="by">jjav</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38931057">parent</a><span>|</span><a href="#38931480">next</a><span>|</span><label class="collapse" for="c-38933145">[-]</label><label class="expand" for="c-38933145">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Basically Iâm optimizing for viral growth, otherwise the business probably isnât worth it. I havenât launched yet but<p>If you have not launched yet but are optimizing for facebook-scale, that&#x27;s not the optimal approach.<p>I can&#x27;t comment on your database experience since I don&#x27;t know it, but the vast, vast majority of people underestimate by orders of magnitude what a database can handle.<p>If you&#x27;re not a large public company we all know about (and you&#x27;re not, if you haven&#x27;t launched yet), you don&#x27;t need all the horizontal scale you seem to be building.<p>I remember joining one company (still a startup but a large one about to IPO). My day#1 briefing was about how this one database was in urgent need of replacement with a dozen+ node cassandra cluster because it was about to exceed it&#x27;s capacity any second now. That was to be my highest priority project.<p>I took some measurements on usage and capacity and put that project on the backburner. The db was nowhere near capacity on the small machine it was running on. Company grew a lot, did an IPO, grew some more. Years later I left. That db was still handling everything with plenty of headroom left to grow more.</div><br/></div></div><div id="38931480" class="c"><input type="checkbox" id="c-38931480" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38931057">parent</a><span>|</span><a href="#38933145">prev</a><span>|</span><a href="#38930470">next</a><span>|</span><label class="collapse" for="c-38931480">[-]</label><label class="expand" for="c-38931480">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that at 100k DAU vertical<p>That&#x27;s chump change size even for a medium EC2&#x2F;RDS instance, which should be capable of tens of millions of queries a day without the CPU or disk complaining at you (unless all your queries are table scans or unindexed).<p>&gt; my db doesnât contain just âBob ordered 5 widgets to Foo Laneâ data<p>It doesn&#x27;t matter, it&#x27;s still just bytes. What will matter is your query pattern relative to the databases query planner efficacy, and how updates&#x2F;deletes impact this.<p>&gt; makes it very easy to manage data across realms<p>You can just as easily do this at first as separate databases&#x2F;schemas on the same physical server, with different users and permissions to prevent cross-database&#x2F;schema joins so that when you need to move them to different machines it&#x27;s an easier process.<p>Everyone I know that has tested isolated multi-tenancy that wasn&#x27;t dependent on legal needs ended up abandoning this approach and consolidating into as little hardware as possible. Heap Analytics had a blog post a few years ago about this, but I can&#x27;t seem to find it.<p>Regardless, hope you success in your endeavor and that you come back in a few months to prove us all wrong.</div><br/></div></div></div></div></div></div><div id="38930470" class="c"><input type="checkbox" id="c-38930470" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930336">parent</a><span>|</span><a href="#38930750">prev</a><span>|</span><a href="#38930462">next</a><span>|</span><label class="collapse" for="c-38930470">[-]</label><label class="expand" for="c-38930470">[1 more]</label></div><br/><div class="children"><div class="content">One database as source of truth, &amp; backups that are tested. Use replication to run analysis on<p>Citus offered being able to have most of your database be plain postgres &amp; then having the few tables that take up most the database be distributed<p>But for a small company you probably don&#x27;t need scaling period</div><br/></div></div></div></div><div id="38930462" class="c"><input type="checkbox" id="c-38930462" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930251">parent</a><span>|</span><a href="#38930336">prev</a><span>|</span><a href="#38933339">next</a><span>|</span><label class="collapse" for="c-38930462">[-]</label><label class="expand" for="c-38930462">[1 more]</label></div><br/><div class="children"><div class="content">You can never have 1 database.<p>Something operates the database. That thing is going to need a database.<p>Postgres and etcd are very different. SQLite is very different. Look at this microk8s thread - <a href="https:&#x2F;&#x2F;github.com&#x2F;canonical&#x2F;microk8s&#x2F;issues&#x2F;3227">https:&#x2F;&#x2F;github.com&#x2F;canonical&#x2F;microk8s&#x2F;issues&#x2F;3227</a> - as a <i>canonical</i> example. Context is they use dqlite, which is multi-master SQLite with raft. Here people come to actually use the data and itâs a disaster. Just use etcd!<p>Then people will deploy Postgres on top of Kubernetes. Great. Maybe they will deploy it differently, and their database is a bunch of files in &#x2F;etc&#x2F;. Whatever. But you canât run Kubernetes on Postgres, you wouldnât want to anyway, the choice to use etcd is very thoughtful. This is an environment designed to simplify the layers of bootstrapping, Kubernetesâs superpower is that it runs as much of its own stuff on top of itself as safe as it is to do so.<p>It still needs a database that is going to be separate from your applications, and unfortunately, for all interesting applications, the line between deployment and business-logical concerns is blurred.<p>So IMO, you will have multiple databases, because logical and deployment concerns are intertwined; deployment concerns need databases; and thus to solve chicken and egg, youâll have at least 2, hopefully the 1st is super easy to administer.<p>Perhaps you disagree. Maybe you should use dqlite as the only database. Itâs so naive to think anything is CP as long as thereâs consensus in front of it. And if thereâs no strong opinion about the arcane issue I just said, worse if itâs meaningless gobbledygook; or if the strong opinion is âuse Postgres,â the data is screwed and the users are screwed.</div><br/></div></div></div></div><div id="38933339" class="c"><input type="checkbox" id="c-38933339" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38930251">prev</a><span>|</span><a href="#38930367">next</a><span>|</span><label class="collapse" for="c-38933339">[-]</label><label class="expand" for="c-38933339">[1 more]</label></div><br/><div class="children"><div class="content">Big databases are not new. If that was all that was needed, people would have been doing just that for the past 40 years. Turns out it doesn&#x27;t always work, and sometimes (often?) it&#x27;s terrible.<p>Even if <i>theoretically</i> it was all you ever needed, the other constant problem is the implementation. Most developers, today anyway, are morons. They don&#x27;t understand how databases work or how to use them, so they use them poorly. In order to get away from that fact, they invented new databases (like NoSQL) so they could use their brains less and just write more glue code. Turned out that was horrible as well.<p>Pretty soon the tides will turn yet again and &quot;just having a big database&quot; will again be seen as not in vogue and another paradigm of &quot;simplicity&quot; will come around (instead of &quot;one big database&quot; being simple it&#x27;ll be &quot;many small databases&quot; like we had with microservices).<p>Those who don&#x27;t understand history are doomed to repeat it.</div><br/></div></div><div id="38930367" class="c"><input type="checkbox" id="c-38930367" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38933339">prev</a><span>|</span><a href="#38930569">next</a><span>|</span><label class="collapse" for="c-38930367">[-]</label><label class="expand" for="c-38930367">[14 more]</label></div><br/><div class="children"><div class="content">Being able to model a use case with tuples and relations does not mean the database can meet the performance requirements of that use case. If it can&#x27;t meet the performance requirements, then the use case is unsupported. It&#x27;s the same way how no single data structure or combination of data structures can support all regular programming use cases. Sometimes you need a map, sometimes you need a list, sometimes you need a set, sometimes you need a combination, and sometimes you need something completely different.</div><br/><div id="38930433" class="c"><input type="checkbox" id="c-38930433" checked=""/><div class="controls bullet"><span class="by">pi-e-sigma</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930367">parent</a><span>|</span><a href="#38930431">next</a><span>|</span><label class="collapse" for="c-38930433">[-]</label><label class="expand" for="c-38930433">[5 more]</label></div><br/><div class="children"><div class="content">Yep, you need Google-scale for your shitty startup from the get-go. Otherwise why bother? Especially now, when who have single servers with only a few terabytes of RAM at your disposal.</div><br/><div id="38930654" class="c"><input type="checkbox" id="c-38930654" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930433">parent</a><span>|</span><a href="#38930431">next</a><span>|</span><label class="collapse" for="c-38930654">[-]</label><label class="expand" for="c-38930654">[4 more]</label></div><br/><div class="children"><div class="content">Many of the problems with databases that I outlined in that post are about how they create complexity, which is not necessarily related to performance or scale. Complexity kills developer productivity, which reduces iteration speed, which can be the difference between an application succeeding or failing.</div><br/><div id="38937564" class="c"><input type="checkbox" id="c-38937564" checked=""/><div class="controls bullet"><span class="by">puchatek</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930654">parent</a><span>|</span><a href="#38932708">next</a><span>|</span><label class="collapse" for="c-38937564">[-]</label><label class="expand" for="c-38937564">[1 more]</label></div><br/><div class="children"><div class="content">In the experience of my department, event sourcing has brought complexity, not taken it away. Theoretically, when done right, by skilled and disciplined teams and to store the state of one system to build projections off of and not to publish state changes to other systems, I think it might work. But in most cases it&#x27;s overkill. A big investment with an uncertain payoff.</div><br/></div></div><div id="38932708" class="c"><input type="checkbox" id="c-38932708" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930654">parent</a><span>|</span><a href="#38937564">prev</a><span>|</span><a href="#38931739">next</a><span>|</span><label class="collapse" for="c-38932708">[-]</label><label class="expand" for="c-38932708">[1 more]</label></div><br/><div class="children"><div class="content">I can imagine Codd saying the exact inverse: any sufficiently complex data model quickly becomes intractable for developers to assemble ideal indexes and algorithms together each time in response to new queries, which kills productivity and reduces iteration speed. Particularly as the scale and relative distributions of the data changes. The whole idea of declarative 4GLs &#x2F; SQL is that a query engine with cost-based optimization can eliminate an entire class of such work for developers.<p>Undoubtedly the reality of widely available SQL systems today has not lived up to that original relational promise in the context of modern expectations for large-scale reactive applications - maybe (hopefully) that can change - but in the meantime it&#x27;s good to see Rama here with a fresh take on what can be achieved with a modern 3GL approach.</div><br/></div></div><div id="38931739" class="c"><input type="checkbox" id="c-38931739" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930654">parent</a><span>|</span><a href="#38932708">prev</a><span>|</span><a href="#38930431">next</a><span>|</span><label class="collapse" for="c-38931739">[-]</label><label class="expand" for="c-38931739">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, what if one creates multiple databases, but on the same instance (or even process group). Can these conflicting issues resolve somehow? Is there a super-proxy which would only log transaction phases and otherwise offload jobs to database servers (and sqlite wrappers)?<p>Basically striping-mirroring RAID but forâ¦ data.</div><br/></div></div></div></div></div></div><div id="38930431" class="c"><input type="checkbox" id="c-38930431" checked=""/><div class="controls bullet"><span class="by">nineteen999</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930367">parent</a><span>|</span><a href="#38930433">prev</a><span>|</span><a href="#38930435">next</a><span>|</span><label class="collapse" for="c-38930431">[-]</label><label class="expand" for="c-38930431">[6 more]</label></div><br/><div class="children"><div class="content">Sometimes you just need a DBA to help you optimise your DB for your workload and future growth. In general, developers make shitty DBA&#x27;s and vice versa.</div><br/><div id="38930565" class="c"><input type="checkbox" id="c-38930565" checked=""/><div class="controls bullet"><span class="by">sharadov</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930431">parent</a><span>|</span><a href="#38930724">next</a><span>|</span><label class="collapse" for="c-38930565">[-]</label><label class="expand" for="c-38930565">[2 more]</label></div><br/><div class="children"><div class="content">As a DBA, who has managed enough monolithic databases at mid and large sized organizations, there are enough safeguards in today&#x27;s date to avoid the scenario you described - backups, read replicas, replication to avoid the need for unnecessary distributed databases.</div><br/><div id="38931804" class="c"><input type="checkbox" id="c-38931804" checked=""/><div class="controls bullet"><span class="by">nineteen999</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930565">parent</a><span>|</span><a href="#38930724">next</a><span>|</span><label class="collapse" for="c-38931804">[-]</label><label class="expand" for="c-38931804">[1 more]</label></div><br/><div class="children"><div class="content">I suspect you responded to the wrong parent.</div><br/></div></div></div></div><div id="38930724" class="c"><input type="checkbox" id="c-38930724" checked=""/><div class="controls bullet"><span class="by">Foobar8568</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930431">parent</a><span>|</span><a href="#38930565">prev</a><span>|</span><a href="#38930435">next</a><span>|</span><label class="collapse" for="c-38930724">[-]</label><label class="expand" for="c-38930724">[3 more]</label></div><br/><div class="children"><div class="content">Performance tuning is not a skillset enterprise DBAs usually have.</div><br/><div id="38931571" class="c"><input type="checkbox" id="c-38931571" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930724">parent</a><span>|</span><a href="#38931768">next</a><span>|</span><label class="collapse" for="c-38931571">[-]</label><label class="expand" for="c-38931571">[1 more]</label></div><br/><div class="children"><div class="content">Every DBA I&#x27;ve worked with has had performance tuning as one of their top skills, both at the installation-level and query-level. Sometimes it&#x27;s optimizing a query using some hard-earned knowledge of the RDBMS, and sometimes it&#x27;s keeping logs and data on separate storage.</div><br/></div></div><div id="38931768" class="c"><input type="checkbox" id="c-38931768" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930724">parent</a><span>|</span><a href="#38931571">prev</a><span>|</span><a href="#38930435">next</a><span>|</span><label class="collapse" for="c-38931768">[-]</label><label class="expand" for="c-38931768">[1 more]</label></div><br/><div class="children"><div class="content">And devs do?</div><br/></div></div></div></div></div></div><div id="38930435" class="c"><input type="checkbox" id="c-38930435" checked=""/><div class="controls bullet"><span class="by">pixl97</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930367">parent</a><span>|</span><a href="#38930431">prev</a><span>|</span><a href="#38930569">next</a><span>|</span><label class="collapse" for="c-38930435">[-]</label><label class="expand" for="c-38930435">[2 more]</label></div><br/><div class="children"><div class="content">Hell, what about the security requirements?</div><br/><div id="38930916" class="c"><input type="checkbox" id="c-38930916" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930435">parent</a><span>|</span><a href="#38930569">next</a><span>|</span><label class="collapse" for="c-38930916">[-]</label><label class="expand" for="c-38930916">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;security&#x2F;row-level-security?view=sql-server-ver16" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;s...</a></div><br/></div></div></div></div></div></div><div id="38930569" class="c"><input type="checkbox" id="c-38930569" checked=""/><div class="controls bullet"><span class="by">xnx</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38930367">prev</a><span>|</span><a href="#38930539">next</a><span>|</span><label class="collapse" for="c-38930569">[-]</label><label class="expand" for="c-38930569">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Putting everything into exactly one database is a superpower. T<p>Amen. Previous co. had a cargo-cult microservices setup including a separate DB for each app. This made things unnecessarily complicated and expensive for no business benefit (definite resume-padding benefit). Lesson: Don&#x27;t complicate things until you&#x27;re forced to.</div><br/><div id="38937431" class="c"><input type="checkbox" id="c-38937431" checked=""/><div class="controls bullet"><span class="by">zerbinxx</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930569">parent</a><span>|</span><a href="#38930539">next</a><span>|</span><label class="collapse" for="c-38937431">[-]</label><label class="expand" for="c-38937431">[1 more]</label></div><br/><div class="children"><div class="content">The thing with the microservice + do separation problem is that by the time youâre forced to do it,  the cost to migrate and split data out of a single source into many (potentially all at once) is extremely great. Last at work week a trio of services which rely on the same physical db had a problem where they were both locked out because of a problem with the logic in one of them. This caused an outage that lasted 5 hours and resulted in a (possible) loss of several months worth of their dev teamâs funding. At a certain scale you try to proactively lessen the impact of possible events like these because the math works out.<p>If youâre at that scale, then great, do that. But I also fully agree that cargo-culting that kind of decision out of the gate can be a massive waste of money.</div><br/></div></div></div></div><div id="38930539" class="c"><input type="checkbox" id="c-38930539" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38930569">prev</a><span>|</span><a href="#38932309">next</a><span>|</span><label class="collapse" for="c-38930539">[-]</label><label class="expand" for="c-38930539">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a dream, a truly beautiful one, but it never works (does it? has anyone pulled it off?). Taking it to an extreme, the entire world needs one integrated database and user authorizations.<p>Obviously data structures vary, performance is required, and it becomes a bottleneck because it&#x27;s so critical that mortals can&#x27;t touch it and every change must be ultra-safe. And then there&#x27;s security: what if someone finds a way from the development bug section to the HR or executive-only financials sections? Generally, anyone who has tried to implement universal ERM systems knows how difficult and painful integrated systems can be.<p>But those are the extremes. I&#x27;d be interested to know how far people have gotten, and how they did it, pursuing this ideal? I&#x27;ve never seen a business run on one. How about a personal knowledge-management system? Does everything fit? Do you still use spreadsheets for something &#x27;quick&#x27;, text files for free-form, etc.?</div><br/></div></div><div id="38932309" class="c"><input type="checkbox" id="c-38932309" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38930539">prev</a><span>|</span><a href="#38934596">next</a><span>|</span><label class="collapse" for="c-38932309">[-]</label><label class="expand" for="c-38932309">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If all business happens in one transactional system, your semantics are dramatically simplified.<p>100% agreed. One of the biggest issues SQL databases have faced is that the scope &amp; scale of &quot;one transactional system&quot; has evolved a lot more quickly than any off-the-shelf database architecture has been able to keep up with, resulting in an explosion of workaround technologies and approaches that really shouldn&#x27;t need to exist.<p>We&#x27;re now firmly in the cloud database era and can look at things like Spanner to judge how far away Postgres remains from satisfying modern availability &amp; scaling expectations. But it will be great to see OSS close the gap (hopefully soon!).</div><br/><div id="38937711" class="c"><input type="checkbox" id="c-38937711" checked=""/><div class="controls bullet"><span class="by">ddorian43</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38932309">parent</a><span>|</span><a href="#38934596">next</a><span>|</span><label class="collapse" for="c-38937711">[-]</label><label class="expand" for="c-38937711">[1 more]</label></div><br/><div class="children"><div class="content">YugabyteDB has PostgreSQL on top of Spanner architecture and is apache2 licensed (I work there).</div><br/></div></div></div></div><div id="38934596" class="c"><input type="checkbox" id="c-38934596" checked=""/><div class="controls bullet"><span class="by">karencarits</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38932309">prev</a><span>|</span><a href="#38930679">next</a><span>|</span><label class="collapse" for="c-38934596">[-]</label><label class="expand" for="c-38934596">[1 more]</label></div><br/><div class="children"><div class="content">Is there any good opensource software with gui to manage such databases&#x2F;graphs? I guess Wikibase is an alternative, although not very user friendly<p>In contrast, pocketbase [0] was discussed two days ago, and there are many user-friendly alternatives for relational data [e.g. 1-4]<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38898934">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38898934</a><p>[1] <a href="https:&#x2F;&#x2F;www.getgrist.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.getgrist.com&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;nocodb.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nocodb.com&#x2F;</a><p>[3] <a href="https:&#x2F;&#x2F;baserow.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;baserow.io&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;www.rowy.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.rowy.io&#x2F;</a></div><br/></div></div><div id="38930679" class="c"><input type="checkbox" id="c-38930679" checked=""/><div class="controls bullet"><span class="by">samaysharma</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38934596">prev</a><span>|</span><a href="#38935129">next</a><span>|</span><label class="collapse" for="c-38930679">[-]</label><label class="expand" for="c-38930679">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Putting data for all your use cases in a single database is a huge deal. Having different databases for each part of the application bloats so much so easily from a cost, complexity and skill set standpoint. Also, makes it extremely hard to debug issues when you have to chart the path of data through 5 different tools.<p>There is the challenge of workload separation and scaling each component separately but that can be resolved by pulling out challenging workloads into their own &quot;database&quot; albeit on the same stack.</div><br/></div></div><div id="38935129" class="c"><input type="checkbox" id="c-38935129" checked=""/><div class="controls bullet"><span class="by">felipellrocha</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38930679">prev</a><span>|</span><a href="#38930585">next</a><span>|</span><label class="collapse" for="c-38935129">[-]</label><label class="expand" for="c-38935129">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard so many people claim this, but I&#x27;ve never seen this put into practice in production, and at scale.<p>I don&#x27;t even think that that proves that this cannot be done... And I&#x27;ve seen A LOT of people try. But, things invariably start to break down, and at this point I just think that the statement above is more wishy washy than anything, though I want to believe...</div><br/></div></div><div id="38930585" class="c"><input type="checkbox" id="c-38930585" checked=""/><div class="controls bullet"><span class="by">NikolaNovak</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38935129">prev</a><span>|</span><a href="#38930410">next</a><span>|</span><label class="collapse" for="c-38930585">[-]</label><label class="expand" for="c-38930585">[2 more]</label></div><br/><div class="children"><div class="content">I work in ERP space, which is the ultimate uncool from typical HN perspective; but sometimes &quot;uncool&quot; has a Venn diagram overlap with &quot;mature&quot;.<p>A modern top tier RDBMS is an incredibly powerful, fast, mature, stable tool - when wielded wisely by the knowledgeable wizard. To be fair, the developers must have a solid understanding of programming language, <i>and</i> business domain, <i>and</i> SQL &#x2F; data dictionary &#x2F; ERD - which I&#x27;ve always taken for granted but eventually realized is not the norm.</div><br/><div id="38930683" class="c"><input type="checkbox" id="c-38930683" checked=""/><div class="controls bullet"><span class="by">mamcx</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930585">parent</a><span>|</span><a href="#38930410">next</a><span>|</span><label class="collapse" for="c-38930683">[-]</label><label class="expand" for="c-38930683">[1 more]</label></div><br/><div class="children"><div class="content">I also work on this space, and kind of see the value of this idea.<p>Having a log store make sense, and having a super-VIEW replacement that can re-compute the data (so I can denormalize o build secondary tables&#x2F;indexes that could or not be stored) is a common pattern.<p>That is fine.<p>What is NOT fine, and that normal DBS avoid, is to add &quot;eventual consistency&quot;.<p>I NEED to get exact counts, sum, avg, and RIGTH NOW, not a second later.<p>The more &quot;eventual&quot; the data become the worse things are, and that is the <i>major</i> way to add bugs and problems.<p>One of the reasons FK are important is they eliminate the chance of getting the relationships wrong, but also, to get it right NOW.</div><br/></div></div></div></div><div id="38930410" class="c"><input type="checkbox" id="c-38930410" checked=""/><div class="controls bullet"><span class="by">lupusreal</span><span>|</span><a href="#38930062">parent</a><span>|</span><a href="#38930585">prev</a><span>|</span><a href="#38930378">next</a><span>|</span><label class="collapse" for="c-38930410">[-]</label><label class="expand" for="c-38930410">[9 more]</label></div><br/><div class="children"><div class="content">&gt; <i>In theory, there is no domain (or finite set of domains) that cannot be accurately modeled using tuples of things and their relations.</i><p>That <i>seems</i> right to me, but is it really provably true?</div><br/><div id="38930763" class="c"><input type="checkbox" id="c-38930763" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930410">parent</a><span>|</span><a href="#38930665">next</a><span>|</span><label class="collapse" for="c-38930763">[-]</label><label class="expand" for="c-38930763">[1 more]</label></div><br/><div class="children"><div class="content">Provably? I&#x27;ll leave that up to the academics.<p>Practically? I&#x27;ve never had someone throw a problem at me I couldn&#x27;t model in SQL. Not saying I can guarantee performance, but in terms of abstract modeling I&#x27;ve never encountered something that can&#x27;t be done &quot;clean&quot;.<p>I&#x27;d like to use the analogy of painting. What <i>can&#x27;t</i> you paint on that canvas that isn&#x27;t trivially-hindered by the available media? Can you actually describe that space of things?<p>In my estimation, premature optimization is why most people can&#x27;t work in these terms. You wind up with a tuple like WorldObjects and immediately go off the deep end about a billion row scale before you are done naming things.</div><br/></div></div><div id="38930665" class="c"><input type="checkbox" id="c-38930665" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930410">parent</a><span>|</span><a href="#38930763">prev</a><span>|</span><a href="#38930815">next</a><span>|</span><label class="collapse" for="c-38930665">[-]</label><label class="expand" for="c-38930665">[1 more]</label></div><br/><div class="children"><div class="content">At least, if it can be modelled by <i>some</i> type of finite database stored on disk or in memory, then you can store the entire contents of that database as one binary blob.<p>Now you just need one tuple (&quot;our_system&quot;, &quot;the_db&quot;, the_binary_blob)<p>QED :)</div><br/></div></div><div id="38930815" class="c"><input type="checkbox" id="c-38930815" checked=""/><div class="controls bullet"><span class="by">Legend2440</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930410">parent</a><span>|</span><a href="#38930665">prev</a><span>|</span><a href="#38930833">next</a><span>|</span><label class="collapse" for="c-38930815">[-]</label><label class="expand" for="c-38930815">[4 more]</label></div><br/><div class="children"><div class="content">No. Many real domains like natural language are too complex and fuzzy to accurately model with tuples.<p>To be truly universal, your model needs to be computationally stronger - it needs to be turing complete. For example fractals could never be modeled by any number of tuples, but <i>can</i> be perfectly represented by very short computer programs.</div><br/><div id="38931348" class="c"><input type="checkbox" id="c-38931348" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930815">parent</a><span>|</span><a href="#38930833">next</a><span>|</span><label class="collapse" for="c-38931348">[-]</label><label class="expand" for="c-38931348">[3 more]</label></div><br/><div class="children"><div class="content">Can a program be modeled by a finite number of tuples?</div><br/><div id="38936521" class="c"><input type="checkbox" id="c-38936521" checked=""/><div class="controls bullet"><span class="by">Legend2440</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38931348">parent</a><span>|</span><a href="#38932158">next</a><span>|</span><label class="collapse" for="c-38936521">[-]</label><label class="expand" for="c-38936521">[1 more]</label></div><br/><div class="children"><div class="content">The program&#x27;s output and behavior can&#x27;t. The source code can.</div><br/></div></div><div id="38932158" class="c"><input type="checkbox" id="c-38932158" checked=""/><div class="controls bullet"><span class="by">bostik</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38931348">parent</a><span>|</span><a href="#38936521">prev</a><span>|</span><a href="#38930833">next</a><span>|</span><label class="collapse" for="c-38932158">[-]</label><label class="expand" for="c-38932158">[1 more]</label></div><br/><div class="children"><div class="content">Probably yes, but for any program of sufficient complexity, that finite number may have an inconvenient number of digits.</div><br/></div></div></div></div></div></div><div id="38930833" class="c"><input type="checkbox" id="c-38930833" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930410">parent</a><span>|</span><a href="#38930815">prev</a><span>|</span><a href="#38931103">next</a><span>|</span><label class="collapse" for="c-38930833">[-]</label><label class="expand" for="c-38930833">[1 more]</label></div><br/><div class="children"><div class="content">I think there is some &quot;Turing-completeness&quot; for this category as well, that is quite trivial to achieve, though the practical usability may be negligible.<p>One hacky equivalence I can come up with is that you have a tuple with a single string value, and encode something in that string.</div><br/></div></div><div id="38931103" class="c"><input type="checkbox" id="c-38931103" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#38930062">root</a><span>|</span><a href="#38930410">parent</a><span>|</span><a href="#38930833">prev</a><span>|</span><a href="#38930378">next</a><span>|</span><label class="collapse" for="c-38931103">[-]</label><label class="expand" for="c-38931103">[1 more]</label></div><br/><div class="children"><div class="content">Maybe <a href="https:&#x2F;&#x2F;plato.stanford.edu&#x2F;entries&#x2F;relations&#x2F;" rel="nofollow">https:&#x2F;&#x2F;plato.stanford.edu&#x2F;entries&#x2F;relations&#x2F;</a></div><br/></div></div></div></div></div></div><div id="38930378" class="c"><input type="checkbox" id="c-38930378" checked=""/><div class="controls bullet"><span class="by">davedx</span><span>|</span><a href="#38930062">prev</a><span>|</span><a href="#38931002">next</a><span>|</span><label class="collapse" for="c-38930378">[-]</label><label class="expand" for="c-38930378">[16 more]</label></div><br/><div class="children"><div class="content">&gt; The better approach, as weâll get to later in this post, is event sourcing plus materialized views.<p>Right, so the solution is more complexity? Of course it is. Sigh</div><br/><div id="38930475" class="c"><input type="checkbox" id="c-38930475" checked=""/><div class="controls bullet"><span class="by">nineteen999</span><span>|</span><a href="#38930378">parent</a><span>|</span><a href="#38930555">next</a><span>|</span><label class="collapse" for="c-38930475">[-]</label><label class="expand" for="c-38930475">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Right, so the solution is more complexity? Of course it is. Sigh<p>More complexity? The writer makes it very simple. Just use their product Rama.</div><br/></div></div><div id="38930555" class="c"><input type="checkbox" id="c-38930555" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930378">parent</a><span>|</span><a href="#38930475">prev</a><span>|</span><a href="#38930880">next</a><span>|</span><label class="collapse" for="c-38930555">[-]</label><label class="expand" for="c-38930555">[12 more]</label></div><br/><div class="children"><div class="content">Actually, when done right this dramatically simplifies a backend architecture. Even a low-scale application commonly uses multiple databases (e.g. Postgres plus ElasticSearch) and queues+workers for background work.<p>Our Twitter-scale Mastodon implementation is a direct demonstration of this. It&#x27;s literally 100x less code than Twitter had to write to build the equivalent feature-set at scale, and it&#x27;s more than 40% less code than Mastodon&#x27;s official implementation. This isn&#x27;t because of being able to design things better with the same tooling the second time around â it&#x27;s because it&#x27;s built using fundamentally better abstractions.</div><br/><div id="38930844" class="c"><input type="checkbox" id="c-38930844" checked=""/><div class="controls bullet"><span class="by">jddj</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38930555">parent</a><span>|</span><a href="#38930996">next</a><span>|</span><label class="collapse" for="c-38930844">[-]</label><label class="expand" for="c-38930844">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Fundamentally, [the things you deal with] are materialized views over an event sourced log.<p>This is also true of most of the main SQL database engines, no?</div><br/></div></div><div id="38930996" class="c"><input type="checkbox" id="c-38930996" checked=""/><div class="controls bullet"><span class="by">yowlingcat</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38930555">parent</a><span>|</span><a href="#38930844">prev</a><span>|</span><a href="#38931170">next</a><span>|</span><label class="collapse" for="c-38930996">[-]</label><label class="expand" for="c-38930996">[6 more]</label></div><br/><div class="children"><div class="content">Twitter is a simple product that only has value because of the eyeballs that look at it, not the depth of the product.<p>I fundamentally disagree with the premise of your blog post but not the premise of your company, so why don&#x27;t I make an ask for you to write a much more practically useful application. Design a basic shopping cart using your system and compare and contrast it with a well designed relational equivalent. A system that allows products to be purchased and fulfilled is a far closer match to what the majority of companies are using software for compared to writing a Twitter clone.<p>Here&#x27;s my take -- at a certain point in scale and volume using a database, it actually does make sense to rewrite all of the following from scratch:<p>- query planning<p>- indexing (btree vs GIN, etc) and primary&#x2F;foreign&#x2F;unique key structure<p>- persistence layer<p>- locking<p>- enforcing ACID constraints<p>- schema migrations&#x2F;DDL<p>- security, accounts and permissioning<p>- encryption primitives<p>But more crucially, my belief and experience is that most companies making lots of money from software products will NEVER remotely reach that scale -- and prematurely optimizing for that is not just the wrong decision but borderline professional malpractice. You can get very far with Postgres and JSONB if you really need it, and you&#x27;ll spend more time focusing on your business logic than reinventing the wheel.<p>I&#x27;d like to be proven wrong. But I get sinking feeling that I&#x27;m not wrong, and while your product is potentially valuable for a very specific use case, you&#x27;re doing your own company a disservice by distorting reality so strongly to both yourselves and your prospective customers.<p>I&#x27;ll round out this comment by linking another comment in this thread that goes very well into the perils of event sourcing when the juice isn&#x27;t worth the squeeze:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38930591">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38930591</a></div><br/><div id="38932934" class="c"><input type="checkbox" id="c-38932934" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38930996">parent</a><span>|</span><a href="#38931170">next</a><span>|</span><label class="collapse" for="c-38932934">[-]</label><label class="expand" for="c-38932934">[5 more]</label></div><br/><div class="children"><div class="content">Different applications will be more relatable to different developers. And that is the path we are going down, of steadily building up more and more examples of applying Rama towards different use cases. Some developers will get their light-bulb moment on a compare&#x2F;contrast to a shopping cart, others vs. a time-series analytics app, etc. It&#x27;s completely different for different developers, so building up that library of examples will take time. At the moment, we&#x27;re focused on our private beta users who are technically savvy enough to be able to understand Rama through the first principles on which it&#x27;s based.<p>We started with a Twitter demonstration because: a) its implementation at scale is extremely difficult, b) I used to work there and am intimately familiar with what they went through on the technical end, and c) the product is composed of tons of use cases which work completely differently from each other â social graph, timelines, personalized follow suggestions, trends, search, etc. A single platform able to implement such diverse use cases with optimal performance, at scale, and in a comparatively tiny amount of code is simply unprecedented.</div><br/><div id="38933401" class="c"><input type="checkbox" id="c-38933401" checked=""/><div class="controls bullet"><span class="by">SJMG</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38932934">parent</a><span>|</span><a href="#38933709">next</a><span>|</span><label class="collapse" for="c-38933401">[-]</label><label class="expand" for="c-38933401">[2 more]</label></div><br/><div class="children"><div class="content">Most of the comments here bias negative, but you shouldn&#x27;t take that to heart. Hackernews is, in general, conservative when it comes to attempts to displace entrenched, battle-tested solutions (especially when they come wrapped with unfortunate, hyperbolic rhetoric).<p>It&#x27;s a very impressive demo. You should be proud, keep your chin up, and keep us updated as Rama&#x27;s value prop. continues to grow.</div><br/><div id="38934029" class="c"><input type="checkbox" id="c-38934029" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38933401">parent</a><span>|</span><a href="#38933709">next</a><span>|</span><label class="collapse" for="c-38934029">[-]</label><label class="expand" for="c-38934029">[1 more]</label></div><br/><div class="children"><div class="content">Thanks</div><br/></div></div></div></div><div id="38933709" class="c"><input type="checkbox" id="c-38933709" checked=""/><div class="controls bullet"><span class="by">yowlingcat</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38932934">parent</a><span>|</span><a href="#38933401">prev</a><span>|</span><a href="#38931170">next</a><span>|</span><label class="collapse" for="c-38933709">[-]</label><label class="expand" for="c-38933709">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also a write-only workload that doesn&#x27;t have to deal with updates intrinsic money movement, pricing, inventory, and other common workloads where atomicity is not a nice to have but a requirement. Twitter is trivial as a product compared to the most mundane shopping cart. You worked at Twitter? Okay great, I worked at AWS which runs the entire internet.  And it doesn&#x27;t really matter. Even if I am intimately familiar with where naive deployments of relational databases breakdown at scale, as well as mitigating approaches (cellular architecture) that make it possible to keep scaling them.<p>You&#x27;re not really addressing the substance of my comment so I am left to assume that your omission is because you cannot address it. Be that as it may, you&#x27;ll hopefully at least take my final comment at its face value that you do your own product a disservice by overhyping what its use case is towards areas that it is objectively a poor fit. People have tried event sourcing many times and it&#x27;s just not a good fit for many if not most workloads. You can&#x27;t be everything to everyone. There&#x27;s nothing wrong with that.<p>My advice to you is this: call out the elephant in the room and admit that, and focus on workloads where it is a good fit. That extra honesty will go a long way in helping you build a business with sustainable differentiation and product market fit.</div><br/><div id="38936414" class="c"><input type="checkbox" id="c-38936414" checked=""/><div class="controls bullet"><span class="by">yayitswei</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38933709">parent</a><span>|</span><a href="#38931170">next</a><span>|</span><label class="collapse" for="c-38936414">[-]</label><label class="expand" for="c-38936414">[1 more]</label></div><br/><div class="children"><div class="content">What was your role at AWS?</div><br/></div></div></div></div></div></div></div></div><div id="38931170" class="c"><input type="checkbox" id="c-38931170" checked=""/><div class="controls bullet"><span class="by">groovecoder</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38930555">parent</a><span>|</span><a href="#38930996">prev</a><span>|</span><a href="#38930880">next</a><span>|</span><label class="collapse" for="c-38931170">[-]</label><label class="expand" for="c-38931170">[4 more]</label></div><br/><div class="children"><div class="content">Look I don&#x27;t have any reason to praise Twitter, but ...<p>This &quot;Twitter-scale mastadon implementation&quot; is when my red flags went up. It&#x27;s meant to demonstrate a simpler and more performant architecture, but it actually demonstrates &quot;things you should never do&quot; #1: rewrite the code from scratch.<p><a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-never-do-part-i&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-...</a><p>&quot;The idea that new code is better than old is patently absurd. Old code has been used. It has been tested. Lots of bugs have been found, and theyâve been fixed.&quot;<p>The &quot;1M lines of code&quot; and &quot;~200 person-years&quot; of Twitter being trashed on in this article is the outcome of Twitter doing the most important thing that software should do: deliver value to people. Millions of people (real people, not 100M bots) suffered thru YEARS of the fail-whale because Twitter&#x27;s software gave them value.<p>This software has only delivered some artificial numbers in a completely made-up false comparison. Okay it&#x27;s built on &quot;fundamentally better abstractions&quot;, but until it&#x27;s running for people in the real world, that&#x27;s all it is: abstract.<p>Please don&#x27;t tout this as a demonstration of how to re-create all of Twitter with simpler and more performant back-end architecture.</div><br/><div id="38933098" class="c"><input type="checkbox" id="c-38933098" checked=""/><div class="controls bullet"><span class="by">discreteevent</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38931170">parent</a><span>|</span><a href="#38933040">next</a><span>|</span><label class="collapse" for="c-38933098">[-]</label><label class="expand" for="c-38933098">[1 more]</label></div><br/><div class="children"><div class="content">The Joel article is about not rewriting an existing application. TFA is not saying that Twitter should rewrite. It&#x27;s saying that if you don&#x27;t work for Twitter but you want to write something like Twitter maybe this could be a good place to start.<p>At some point in time the same argument was made for relational databases despite there being stable systems built without them based on ISAM. The newer relational systems took a lot less work to implement but that didn&#x27;t imply that it made sense to rewrite the ISAM based systems.</div><br/></div></div><div id="38933040" class="c"><input type="checkbox" id="c-38933040" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38931170">parent</a><span>|</span><a href="#38933098">prev</a><span>|</span><a href="#38930880">next</a><span>|</span><label class="collapse" for="c-38933040">[-]</label><label class="expand" for="c-38933040">[2 more]</label></div><br/><div class="children"><div class="content">By your logic, all testing is invalid except for usage by real users. Two things:<p>- We stress-tested the hell out of our implementation well beyond Twitter-scale, including while inducing chaos (e.g. random worker kills, network partitions).
- We ran it for real when we launched with 100M bots posting 3,500 times &#x2F; second at 403 average fanout. It worked flawlessly with a very snappy UX.<p>The second-system effect is a real thing, but there&#x27;s a difference when you&#x27;re building on radically better tooling. All the complexity that Twitter had to deal with that led to so much code (e.g. needing to make multiple specialized datastores from scratch) just didn&#x27;t exist in our implementation.</div><br/><div id="38933770" class="c"><input type="checkbox" id="c-38933770" checked=""/><div class="controls bullet"><span class="by">yowlingcat</span><span>|</span><a href="#38930378">root</a><span>|</span><a href="#38933040">parent</a><span>|</span><a href="#38930880">next</a><span>|</span><label class="collapse" for="c-38933770">[-]</label><label class="expand" for="c-38933770">[1 more]</label></div><br/><div class="children"><div class="content">&gt; By your logic, all testing is invalid except for usage by real users<p>That is exactly correct. All testing is make believe except for real case studies by real customers with an intent to pay, and barring that, real pilots with real utilization. Otherwise, you run the risk of building a product for a version of yourself that you are pretending is other people.</div><br/></div></div></div></div></div></div></div></div><div id="38930880" class="c"><input type="checkbox" id="c-38930880" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38930378">parent</a><span>|</span><a href="#38930555">prev</a><span>|</span><a href="#38932197">next</a><span>|</span><label class="collapse" for="c-38930880">[-]</label><label class="expand" for="c-38930880">[1 more]</label></div><br/><div class="children"><div class="content">Well, if your program domain requires X level of essential complexity, you <i>will</i> have to achieve that somehow. You can either let it live in someone else&#x27;s code, that&#x27;s already written and battle tested, or you can rewrite it yourself, which is time consuming and the results might be subpar. There is no free lunch.</div><br/></div></div><div id="38932197" class="c"><input type="checkbox" id="c-38932197" checked=""/><div class="controls bullet"><span class="by">lijok</span><span>|</span><a href="#38930378">parent</a><span>|</span><a href="#38930880">prev</a><span>|</span><a href="#38931002">next</a><span>|</span><label class="collapse" for="c-38932197">[-]</label><label class="expand" for="c-38932197">[1 more]</label></div><br/><div class="children"><div class="content">Have a look at binlog, WAL, etc.</div><br/></div></div></div></div><div id="38931002" class="c"><input type="checkbox" id="c-38931002" checked=""/><div class="controls bullet"><span class="by">russdpale</span><span>|</span><a href="#38930378">prev</a><span>|</span><a href="#38930993">next</a><span>|</span><label class="collapse" for="c-38931002">[-]</label><label class="expand" for="c-38931002">[7 more]</label></div><br/><div class="children"><div class="content">Seems like a bunch of buzzwords and such. I&#x27;ve been working with databases for years for one of the largest companies in the world and no one has ever said &quot;topology&quot; before.<p>Any time I would save with this is wasted on learning java and this framework.<p>There isn&#x27;t anything wrong with databases.</div><br/><div id="38931097" class="c"><input type="checkbox" id="c-38931097" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38931002">parent</a><span>|</span><a href="#38933972">next</a><span>|</span><label class="collapse" for="c-38931097">[-]</label><label class="expand" for="c-38931097">[5 more]</label></div><br/><div class="children"><div class="content">Our production-ready, Twitter-scale Mastodon implementation in 100x less code than Twitter wrote to build the equivalent feature-set (just the consumer product) begs to differ that it&#x27;s &quot;a bunch of buzzwords&quot;. <a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;twitter-scale-mastodon">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;twitter-scale-mastodon</a></div><br/><div id="38931225" class="c"><input type="checkbox" id="c-38931225" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38931002">root</a><span>|</span><a href="#38931097">parent</a><span>|</span><a href="#38933972">next</a><span>|</span><label class="collapse" for="c-38931225">[-]</label><label class="expand" for="c-38931225">[4 more]</label></div><br/><div class="children"><div class="content">Is it actually powering a site the scale of twitter? If no, then there is no reason to think its twitter scale.</div><br/><div id="38931590" class="c"><input type="checkbox" id="c-38931590" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#38931002">root</a><span>|</span><a href="#38931225">parent</a><span>|</span><a href="#38933972">next</a><span>|</span><label class="collapse" for="c-38931590">[-]</label><label class="expand" for="c-38931590">[3 more]</label></div><br/><div class="children"><div class="content">Exactly this. Filling some kind of a database with terabytes of data is not the difficult bit, serving it is...<p>To claim that something static is &quot;Twitter-scale&quot; is just misleading IMO.</div><br/><div id="38932279" class="c"><input type="checkbox" id="c-38932279" checked=""/><div class="controls bullet"><span class="by">nchammas</span><span>|</span><a href="#38931002">root</a><span>|</span><a href="#38931590">parent</a><span>|</span><a href="#38933972">next</a><span>|</span><label class="collapse" for="c-38932279">[-]</label><label class="expand" for="c-38932279">[2 more]</label></div><br/><div class="children"><div class="content">They _did_ serve the data. From TFA:<p>&gt; To demonstrate its scale, we operated the instance with 100M bots posting 3,500 times per second at 403 average fanout.<p>The linked post about their demo [1] has more details about the challenges involved, including rendering home timelines.<p>[1]: <a href="https:&#x2F;&#x2F;blog.redplanetlabs.com&#x2F;2023&#x2F;08&#x2F;15&#x2F;how-we-reduced-the-cost-of-building-twitter-at-twitter-scale-by-100x&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.redplanetlabs.com&#x2F;2023&#x2F;08&#x2F;15&#x2F;how-we-reduced-the...</a></div><br/><div id="38933479" class="c"><input type="checkbox" id="c-38933479" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#38931002">root</a><span>|</span><a href="#38932279">parent</a><span>|</span><a href="#38933972">next</a><span>|</span><label class="collapse" for="c-38933479">[-]</label><label class="expand" for="c-38933479">[1 more]</label></div><br/><div class="children"><div class="content">Meh,its better than nothing, but real world traffic is often very different than simulated traffic. If it isn&#x27;t actually working with real traffic than i am not impressed.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38933972" class="c"><input type="checkbox" id="c-38933972" checked=""/><div class="controls bullet"><span class="by">throwaway201606</span><span>|</span><a href="#38931002">parent</a><span>|</span><a href="#38931097">prev</a><span>|</span><a href="#38930993">next</a><span>|</span><label class="collapse" for="c-38933972">[-]</label><label class="expand" for="c-38933972">[1 more]</label></div><br/><div class="children"><div class="content">Amen<p>To me, this looks like an example of those ads that look like this<p>edit ( tried to do a text table right on here but it got really messed up in the page display)<p>here is a screenshot of the effort<p><a href="https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;XtwSkyx" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;XtwSkyx</a></div><br/></div></div></div></div><div id="38930993" class="c"><input type="checkbox" id="c-38930993" checked=""/><div class="controls bullet"><span class="by">pgaddict</span><span>|</span><a href="#38931002">prev</a><span>|</span><a href="#38930948">next</a><span>|</span><label class="collapse" for="c-38930993">[-]</label><label class="expand" for="c-38930993">[1 more]</label></div><br/><div class="children"><div class="content">Did I miss something, or does that post completely omit concepts like concurrency, isolation, constraints and such? And are they really suggesting &quot;query topologies&quot; (which seem very non-declarative and essentially making query planning&#x2F;optimization responsibility of the person writing them) are a superior developer environment?</div><br/></div></div><div id="38930948" class="c"><input type="checkbox" id="c-38930948" checked=""/><div class="controls bullet"><span class="by">big_whack</span><span>|</span><a href="#38930993">prev</a><span>|</span><a href="#38930312">next</a><span>|</span><label class="collapse" for="c-38930948">[-]</label><label class="expand" for="c-38930948">[7 more]</label></div><br/><div class="children"><div class="content">A lot of the commenters seem like database fans instinctively jumping to defend databases. The post is talking about contexts where you are dealing with petabytes of data. Building processing systems for petabytes has a separate set of problems from what most people have experienced. Having a single Postgres for your startup is probably fine, that&#x27;s not the point here.<p>There is no option to just &quot;put it all in a database&quot;. You need to compose a number of different systems. You use your individual databases as indexes, not as primary storage, and the primary storage is probably S3. The post is interesting and the author has been working on this stuff for a while. He wrote Apache Storm and used to promote some of these concepts as the &quot;Lambda architecture&quot; though I haven&#x27;t seen that term in a while.</div><br/><div id="38931184" class="c"><input type="checkbox" id="c-38931184" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#38930948">parent</a><span>|</span><a href="#38931025">next</a><span>|</span><label class="collapse" for="c-38931184">[-]</label><label class="expand" for="c-38931184">[1 more]</label></div><br/><div class="children"><div class="content">So what you&#x27;re saying is that this article is irrelevant for 99.999% of developers.  The instinctive jump to defend databases is completely understandable given that context.<p>&gt; You use your individual databases as indexes, not as primary storage, and the primary storage is probably S3.<p>Which is a perfectly valid use for a database.  Our company&#x27;s document management system uses a big database for metadata and then, of course, stores the actual files on disk.</div><br/></div></div><div id="38931025" class="c"><input type="checkbox" id="c-38931025" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930948">parent</a><span>|</span><a href="#38931184">prev</a><span>|</span><a href="#38932483">next</a><span>|</span><label class="collapse" for="c-38931025">[-]</label><label class="expand" for="c-38931025">[3 more]</label></div><br/><div class="children"><div class="content">I think the complexity gets really crazy at high scale, but the complexity caused by databases is still significant at low scale as well. For example, needing to use an ORM and dealing with all the ways that can leak is pure complexity caused by not being able to index your domain model directly.</div><br/><div id="38931817" class="c"><input type="checkbox" id="c-38931817" checked=""/><div class="controls bullet"><span class="by">big_whack</span><span>|</span><a href="#38930948">root</a><span>|</span><a href="#38931025">parent</a><span>|</span><a href="#38931740">next</a><span>|</span><label class="collapse" for="c-38931817">[-]</label><label class="expand" for="c-38931817">[1 more]</label></div><br/><div class="children"><div class="content">I feel like there are a couple different points -<p>* The immutability, lambda architecture points I agree with. I think the separation of the immutable log from the views is important. Databases are frequently used in ways that go against these principles.<p>* I am not sold that being unable to express the domain model correctly is really a fair criticism of databases. Most businesses in my experience have a domain that is modeled pretty well in a relational DB. I haven&#x27;t seen a better general solution yet, though I haven&#x27;t checked out Rama.<p>At the low end of the scale, there are a lot of companies (or projects) for which the entire dataset fits in a single managed Postgres instance, without any DBA or scalability needs. They still suffer from complexity due to mutable state, but the architectural separation of source of truth vs &quot;views&quot; can be implemented inside the one database, using an append only table and materialized views. There are some kinds of data that are poorly modeled this way (e.g images) but many kinds that work well.<p>So I don&#x27;t really view the architectural ideas as repudiating databases in general, more as repudiating a mutable approach to data management.</div><br/></div></div><div id="38931740" class="c"><input type="checkbox" id="c-38931740" checked=""/><div class="controls bullet"><span class="by">chasd00</span><span>|</span><a href="#38930948">root</a><span>|</span><a href="#38931025">parent</a><span>|</span><a href="#38931817">prev</a><span>|</span><a href="#38932483">next</a><span>|</span><label class="collapse" for="c-38931740">[-]</label><label class="expand" for="c-38931740">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never known anyone to _need_ to use an ORM, it&#x27;s always been out of convenience.</div><br/></div></div></div></div><div id="38932483" class="c"><input type="checkbox" id="c-38932483" checked=""/><div class="controls bullet"><span class="by">jl6</span><span>|</span><a href="#38930948">parent</a><span>|</span><a href="#38931025">prev</a><span>|</span><a href="#38933510">next</a><span>|</span><label class="collapse" for="c-38932483">[-]</label><label class="expand" for="c-38932483">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Having a single Postgres for your startup is probably fine<p>Itâs also probably fine for about 95% of companies, and that figure is rising.</div><br/></div></div><div id="38933510" class="c"><input type="checkbox" id="c-38933510" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#38930948">parent</a><span>|</span><a href="#38932483">prev</a><span>|</span><a href="#38930312">next</a><span>|</span><label class="collapse" for="c-38933510">[-]</label><label class="expand" for="c-38933510">[1 more]</label></div><br/><div class="children"><div class="content">The article should probably just explicitly say that, to avoid all this arguing.</div><br/></div></div></div></div><div id="38930312" class="c"><input type="checkbox" id="c-38930312" checked=""/><div class="controls bullet"><span class="by">shay_ker</span><span>|</span><a href="#38930948">prev</a><span>|</span><a href="#38930532">next</a><span>|</span><label class="collapse" for="c-38930312">[-]</label><label class="expand" for="c-38930312">[18 more]</label></div><br/><div class="children"><div class="content">What&#x27;s an ELI5 of Rama? I found the docs confusing as well: <a href="https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;index.html</a><p>Please no buzzwords like &quot;paradigm shift&quot; or &quot;platform&quot;. If diagrams are necessary, I&#x27;d love to read a post that explains clearer.</div><br/><div id="38930496" class="c"><input type="checkbox" id="c-38930496" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930312">parent</a><span>|</span><a href="#38930393">next</a><span>|</span><label class="collapse" for="c-38930496">[-]</label><label class="expand" for="c-38930496">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a backend development platform that can handle all the data ingestion, processing, indexing, and querying needs of an application, at any scale. Rather than construct your backend using a hodgepodge of databases, processing systems, queues, and schedulers, you can do everything within Rama within a single platform.<p>Rama runs as a cluster, and any number of applications (called &quot;modules&quot;) are deployed onto that cluster. Deep and detailed telemetry is also built-in.<p>The programming model of Rama is event sourcing plus materialized views. When building a Rama application, you materialize as many indexes as you need as whatever shapes you need (different combinations of durable data structures). Indexes are materialized using a distributed dataflow API.<p>Since Rama is so different than anything that&#x27;s existed before, that&#x27;s about as good of a high-level explanation as I can do. The best resource for learning the basics is rama-demo-gallery, which contains short, end-to-end, thoroughly commented examples of applying Rama towards very different use cases (all completely scalable and fault-tolerant): <a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery</a></div><br/><div id="38931272" class="c"><input type="checkbox" id="c-38931272" checked=""/><div class="controls bullet"><span class="by">shay_ker</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38930496">parent</a><span>|</span><a href="#38937246">next</a><span>|</span><label class="collapse" for="c-38931272">[-]</label><label class="expand" for="c-38931272">[2 more]</label></div><br/><div class="children"><div class="content">What do you mean by &quot;platform&quot;? Is this open source? Can I run everything locally?<p>Is this basically an RBDMS and Kafka in one? Can I use SQL?<p>I understand the handwaving around programming semantics, but I&#x27;d like clearer explanations of what it actually is and how it works. Is this a big old Java app? Do you have ACID transactions? How do you handle fault tolerance?<p>It may be early, but I believe folks will be curious about benchmarks. And maybe, someday, Jepsen testing.</div><br/><div id="38933131" class="c"><input type="checkbox" id="c-38933131" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38931272">parent</a><span>|</span><a href="#38937246">next</a><span>|</span><label class="collapse" for="c-38933131">[-]</label><label class="expand" for="c-38933131">[1 more]</label></div><br/><div class="children"><div class="content">Those questions are all answered in the documentation, which we spent a ton of time on. Some available resources:<p>- Public build that you can download and run yourself locally <a href="https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;downloads-maven-local-dev.html" rel="nofollow">https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;downloads-maven-local-dev.h...</a>
- rama-demo-gallery, containing short, thoroughly commented examples in both Java and Clojure <a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery</a>
- Gentle six-part tutorial introducing the concepts and API, including how to run stuff locally <a href="https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;tutorial1.html" rel="nofollow">https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;tutorial1.html</a>
- Introduction to the first-class Clojure API <a href="https:&#x2F;&#x2F;blog.redplanetlabs.com&#x2F;2023&#x2F;10&#x2F;11&#x2F;introducing-ramas-clojure-api&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.redplanetlabs.com&#x2F;2023&#x2F;10&#x2F;11&#x2F;introducing-ramas-...</a><p>Here are a few pages related to fault-tolerance:<p>- <a href="https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;replication.html" rel="nofollow">https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;replication.html</a>
- <a href="https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;microbatch.html#_operation_and_fault_tolerance" rel="nofollow">https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;microbatch.html#_operation_...</a>
- <a href="https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;stream.html#_fault_tolerance_and_retry_modes" rel="nofollow">https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;stream.html#_fault_toleranc...</a></div><br/></div></div></div></div><div id="38937246" class="c"><input type="checkbox" id="c-38937246" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38930496">parent</a><span>|</span><a href="#38931272">prev</a><span>|</span><a href="#38930393">next</a><span>|</span><label class="collapse" for="c-38937246">[-]</label><label class="expand" for="c-38937246">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a backend development platform that can handle all the data ingestion, processing, indexing, and querying needs of an application, at any scale<p>That&#x27;sâ¦ a databaseâ¦<p>I mean, seriously, how is this not a database?</div><br/></div></div></div></div><div id="38930393" class="c"><input type="checkbox" id="c-38930393" checked=""/><div class="controls bullet"><span class="by">pi-e-sigma</span><span>|</span><a href="#38930312">parent</a><span>|</span><a href="#38930496">prev</a><span>|</span><a href="#38930514">next</a><span>|</span><label class="collapse" for="c-38930393">[-]</label><label class="expand" for="c-38930393">[5 more]</label></div><br/><div class="children"><div class="content">Seems like another attempt at No-SQL. &quot;But this time it&#x27;s different!&quot;</div><br/><div id="38931013" class="c"><input type="checkbox" id="c-38931013" checked=""/><div class="controls bullet"><span class="by">archarios</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38930393">parent</a><span>|</span><a href="#38930487">next</a><span>|</span><label class="collapse" for="c-38931013">[-]</label><label class="expand" for="c-38931013">[2 more]</label></div><br/><div class="children"><div class="content">This is completely different from no-sql. Much more than just a different database..</div><br/><div id="38931228" class="c"><input type="checkbox" id="c-38931228" checked=""/><div class="controls bullet"><span class="by">pi-e-sigma</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38931013">parent</a><span>|</span><a href="#38930487">next</a><span>|</span><label class="collapse" for="c-38931228">[-]</label><label class="expand" for="c-38931228">[1 more]</label></div><br/><div class="children"><div class="content">How exactly is it different from No-SQL?
No schema? Check.
No consistency? Check. (eventually consistent)
Key-value store? Check. (because it&#x27;s using ZooKeeper under the hood)
Promising amazing results and freeing you from the chains of the SQL? CHECK!</div><br/></div></div></div></div><div id="38930487" class="c"><input type="checkbox" id="c-38930487" checked=""/><div class="controls bullet"><span class="by">nineteen999</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38930393">parent</a><span>|</span><a href="#38931013">prev</a><span>|</span><a href="#38930514">next</a><span>|</span><label class="collapse" for="c-38930487">[-]</label><label class="expand" for="c-38930487">[2 more]</label></div><br/><div class="children"><div class="content">Negative SQL?</div><br/></div></div></div></div><div id="38930514" class="c"><input type="checkbox" id="c-38930514" checked=""/><div class="controls bullet"><span class="by">morsecodist</span><span>|</span><a href="#38930312">parent</a><span>|</span><a href="#38930393">prev</a><span>|</span><a href="#38930481">next</a><span>|</span><label class="collapse" for="c-38930514">[-]</label><label class="expand" for="c-38930514">[7 more]</label></div><br/><div class="children"><div class="content">It seems like an event sourcing database. Basically, instead of writing you write a message, then you can make read-only tables that update based on those messages. People do this today in certain domains but it is definitely more complicated than traditional databases.</div><br/><div id="38931051" class="c"><input type="checkbox" id="c-38931051" checked=""/><div class="controls bullet"><span class="by">archarios</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38930514">parent</a><span>|</span><a href="#38930481">next</a><span>|</span><label class="collapse" for="c-38931051">[-]</label><label class="expand" for="c-38931051">[6 more]</label></div><br/><div class="children"><div class="content">More complicated in what ways specifically? I think the relevant thing is wether building an app with Rama is more or less complicated. Rama may be more complicated than mysql in implementation, but that doesn&#x27;t affect me as a developer if it makes my job easier overall.</div><br/><div id="38931352" class="c"><input type="checkbox" id="c-38931352" checked=""/><div class="controls bullet"><span class="by">morsecodist</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38931051">parent</a><span>|</span><a href="#38930481">next</a><span>|</span><label class="collapse" for="c-38931352">[-]</label><label class="expand" for="c-38931352">[5 more]</label></div><br/><div class="children"><div class="content">Discussing levels of complexity quickly gets pretty subjective. It is possible that Rama has found good abstractions that hide a lot of the complexity. It is also possible that taking on more complexity in this area saves you from other sorts of complexity you may encounter elsewhere in your application.<p>However, there is just more going on in an event sourcing model. Instead of saving data to a location and retrieving it from that location you save data to one location, read it from another location, and you need to implement some sort of linker between the two (or more).<p>This also comes down to my personal subjective experience. I actually really like event sourcing but I have worked on teams with these systems and I have found that the majority of people find them much harder to reason about than traditional databases.</div><br/><div id="38933211" class="c"><input type="checkbox" id="c-38933211" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38931352">parent</a><span>|</span><a href="#38930481">next</a><span>|</span><label class="collapse" for="c-38933211">[-]</label><label class="expand" for="c-38933211">[4 more]</label></div><br/><div class="children"><div class="content">There can be a lot of integration pain when implementing event sourcing and materialized views by combining individual tools together. However, these are all integrated in Rama, so there&#x27;s nothing you have to glue yourself as a developer. For example, using the Clojure API here&#x27;s how you declare a depot (an event log):<p>(declare-depot setup *my-events (hash-by :user-id))<p>That&#x27;s it, and you can make as many of those as you want. And here&#x27;s how a topology (a streaming computation that materializes indexes based on depots) subscribes to that depot:<p>(source&gt; <i>my-events :&gt; *data)<p>If you want to subscribe to more depots in the topology, then it&#x27;s just another source&gt; call.<p>That these are integrated and colocated also means the performance is excellent.</i></div><br/><div id="38936946" class="c"><input type="checkbox" id="c-38936946" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38933211">parent</a><span>|</span><a href="#38934561">next</a><span>|</span><label class="collapse" for="c-38936946">[-]</label><label class="expand" for="c-38936946">[2 more]</label></div><br/><div class="children"><div class="content">Examples should be in: PHP, NodeJS&#x2F;Typescript, Python.<p>Seeing Closure ironically makes me think of Twitter though.</div><br/><div id="38937128" class="c"><input type="checkbox" id="c-38937128" checked=""/><div class="controls bullet"><span class="by">archarios</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38936946">parent</a><span>|</span><a href="#38934561">next</a><span>|</span><label class="collapse" for="c-38937128">[-]</label><label class="expand" for="c-38937128">[1 more]</label></div><br/><div class="children"><div class="content">well it&#x27;s either going to be Java or Clojure with this framework so those examples would be kind of pointless.</div><br/></div></div></div></div><div id="38934561" class="c"><input type="checkbox" id="c-38934561" checked=""/><div class="controls bullet"><span class="by">archarios</span><span>|</span><a href="#38930312">root</a><span>|</span><a href="#38933211">parent</a><span>|</span><a href="#38936946">prev</a><span>|</span><a href="#38930481">next</a><span>|</span><label class="collapse" for="c-38934561">[-]</label><label class="expand" for="c-38934561">[1 more]</label></div><br/><div class="children"><div class="content">This is what has me excited about Rama. I was very into the idea of event sourcing until I realized how painful it would be to make all the tooling needed.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38930481" class="c"><input type="checkbox" id="c-38930481" checked=""/><div class="controls bullet"><span class="by">fwip</span><span>|</span><a href="#38930312">parent</a><span>|</span><a href="#38930514">prev</a><span>|</span><a href="#38930532">next</a><span>|</span><label class="collapse" for="c-38930481">[-]</label><label class="expand" for="c-38930481">[1 more]</label></div><br/><div class="children"><div class="content">By my reading, it&#x27;s a variant of the &quot;Kappa architecture&quot; (aka &quot;event sourcing&quot;).<p>You have a &quot;Depot&quot;, which is an append-only log of events, and then build arbitrary views on top of it, which they call &quot;P-States&quot;. The Rama software promises low-latency updates of these views.  Applications built on this would query the views, and submit new events&#x2F;commands to the Depot.</div><br/></div></div></div></div><div id="38930532" class="c"><input type="checkbox" id="c-38930532" checked=""/><div class="controls bullet"><span class="by">ram_rar</span><span>|</span><a href="#38930312">prev</a><span>|</span><a href="#38930517">next</a><span>|</span><label class="collapse" for="c-38930532">[-]</label><label class="expand" for="c-38930532">[6 more]</label></div><br/><div class="children"><div class="content">Even after reading this doc [1], I am not clear on who is the target audience and what are you trying to solve? It would be helpful to take a real world example and translate how easy &#x2F;efficient it would be to do this via RAMA.<p>[1] <a href="https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;why-use-rama.html#gsc.tab=0" rel="nofollow">https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;why-use-rama.html#gsc.tab=0</a></div><br/><div id="38930594" class="c"><input type="checkbox" id="c-38930594" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930532">parent</a><span>|</span><a href="#38930621">next</a><span>|</span><label class="collapse" for="c-38930594">[-]</label><label class="expand" for="c-38930594">[4 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve released many examples.<p>The first is our Twitter-scale Mastodon implementation, which is 100x less code than Twitter wrote to build the equivalent at scale (just the consumer product). It&#x27;s also more than 40% less code than Mastodon&#x27;s official implementation (which isn&#x27;t scalable). <a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;twitter-scale-mastodon">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;twitter-scale-mastodon</a><p>The rama-demo-gallery repo also contains many short, self-contained, thoroughly commented examples of applying Rama towards very different use cases. These include user profile management, time-series analytics, atomic and fault-tolerant bank transfers, and more. <a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery</a></div><br/><div id="38931652" class="c"><input type="checkbox" id="c-38931652" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#38930532">root</a><span>|</span><a href="#38930594">parent</a><span>|</span><a href="#38930818">prev</a><span>|</span><a href="#38930621">next</a><span>|</span><label class="collapse" for="c-38931652">[-]</label><label class="expand" for="c-38931652">[2 more]</label></div><br/><div class="children"><div class="content">How do you know if it&#x27;s &quot;twitter-scale&quot; if it&#x27;s a mastodon implementation?</div><br/><div id="38933080" class="c"><input type="checkbox" id="c-38933080" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930532">root</a><span>|</span><a href="#38931652">parent</a><span>|</span><a href="#38930621">next</a><span>|</span><label class="collapse" for="c-38933080">[-]</label><label class="expand" for="c-38933080">[1 more]</label></div><br/><div class="children"><div class="content">Mastodon is extremely similar to the consumer Twitter product, and &quot;Twitter-scale&quot; is a known number that we tested well beyond. Among other things, we verified our timeline delivery latency was at least as good as Twitter&#x27;s number ad that it scaled linearly.</div><br/></div></div></div></div></div></div></div></div><div id="38930517" class="c"><input type="checkbox" id="c-38930517" checked=""/><div class="controls bullet"><span class="by">brianmcc</span><span>|</span><a href="#38930532">prev</a><span>|</span><a href="#38932607">next</a><span>|</span><label class="collapse" for="c-38930517">[-]</label><label class="expand" for="c-38930517">[1 more]</label></div><br/><div class="children"><div class="content">We do go in circles&#x2F;cycles quite a lot as an industry. I wonder if the trend is back towards SQL, right now, too many teams been burned by Event Sourcing when they just needed a decent SQL DB? Just idle conjecture....</div><br/></div></div><div id="38932607" class="c"><input type="checkbox" id="c-38932607" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#38930517">prev</a><span>|</span><a href="#38935139">next</a><span>|</span><label class="collapse" for="c-38932607">[-]</label><label class="expand" for="c-38932607">[2 more]</label></div><br/><div class="children"><div class="content">Pretty interesting once you read past the marketing push.<p>I mostly like the approach, but there are a lot of questions&#x2F;issues that spring to mind (not that some of them don&#x27;t already have answers, but I didn&#x27;t read everything). I&#x27;ll list some of them:<p>* I&#x27;m pretty sure restrictive schemas are a feature not a bug, but I suppose you can add your own in your ETL &quot;microbatch streaming&quot; implementation (if I&#x27;m reading this right, this is where you transform the events&#x2F;data that have been recorded to the indexed form your app wants to query). So you could, e.g., filter out any data with invalid schema, and&#x2F;or record and error about the invalid data, etc. A pain, though, for it to be a separate thing to implement.<p>* I&#x27;m not that excited to have my data source and objects&#x2F;entities be Java.<p>* The Rama business model and sustainability story seem like big question marks that would have to have strong, long-lasting answers&#x2F;guarantees before anyone should invest too much in this. This is pretty different and sits at a fundamental level of abstraction. If you built on this for years (or decades) and then something happened you could be in serious trouble.<p>* Hosting&#x2F;deployment&#x2F;resources-needed is unclear (to me, anyway)<p>* Quibble on &quot;Data models are restrictive&quot;: common databases are pretty flexible these days, supporting different models well.<p>* I&#x27;m thinking a lot of apps won&#x27;t get too much value from keeping their events around forever, so that becomes a kind of anchor around the neck, a cost that apps using Rama have to pay whether they really want it or not. I have questions about how that scales over time. E.g., say my has depot has 20B events and I want to add an index to a p-state or a new value to an enum... do I need to ETL 20 billion events to do routine changes&#x2F;additions? And obviously schema changes get a lot more complicated than that. I get that you could have granular pstates but then I start worrying about the distributed nature of this. I guess you would generally do migrations by creating new pstates with the new structure, take as much time as you need to populate them, then cut over as gradually as you need, and then retire the old pstates on whatever timeline you want.... But that&#x27;s a lot of work you want to avoid doing routinely, I&#x27;d think.<p>I&#x27;m starting to think of more things, but I better stop (my build finished long ago!)</div><br/><div id="38934011" class="c"><input type="checkbox" id="c-38934011" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38932607">parent</a><span>|</span><a href="#38935139">next</a><span>|</span><label class="collapse" for="c-38934011">[-]</label><label class="expand" for="c-38934011">[1 more]</label></div><br/><div class="children"><div class="content">* By &quot;restrictive schemas&quot; I mean being forced to represent your data storage in non-optimal ways â like not being able to have nested objects in a first-class way. Schemas themselves are extremely important, and they should be as tight as possible.<p>* Rama&#x27;s JVM-based, so the entire ecosystem is available to you. You can represent data as primitive types, Java objects, Protobuf, Clojure records, etc.<p>* You deploy and manage your own Rama clusters. The number of nodes &#x2F; instance types depends on the app, but Rama doesn&#x27;t use more resources than traditional architectures combining multiple tools.<p>* Some databases support multiple very specific data models (e.g. Redis). I don&#x27;t consider that flexible compared to Rama, which allows for arbitrary combinations of arbitrarily sized data structures of arbitrary partitioning.<p>* Depots (the &quot;event sourcing&quot; part of Rama) can be optionally trimmed. So you can configure it to only keep the last 2M entries per partition, for example. Some applications need this, while others don&#x27;t.<p>* If you&#x27;re adding a new PState, it&#x27;s up to you how far back in the depot to start. For example, you could say &quot;start from events appended after a specific timestamp&quot; or &quot;start from 10M records ago on each partition&quot;.<p>* We have a first-class PState migrations feature coming very soon. These migrations are lazy, so there&#x27;s no downime. Basically you can specify a migration function at any level of your PStates, and the migration functions are run on read. In the background, it migrates iterates over the PState to migrate every value on disk (throttled so as not to use too many resources).</div><br/></div></div></div></div><div id="38935139" class="c"><input type="checkbox" id="c-38935139" checked=""/><div class="controls bullet"><span class="by">nojvek</span><span>|</span><a href="#38932607">prev</a><span>|</span><a href="#38930807">next</a><span>|</span><label class="collapse" for="c-38935139">[-]</label><label class="expand" for="c-38935139">[1 more]</label></div><br/><div class="children"><div class="content">Read the tutorial<p><a href="https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;tutorial1.html#gsc.tab=0" rel="nofollow">https:&#x2F;&#x2F;redplanetlabs.com&#x2F;docs&#x2F;~&#x2F;tutorial1.html#gsc.tab=0</a><p>This is quite complex compared to setting up Postgres or mysql and sending some sql over some port.<p>Iâm not sure I get what they are selling.</div><br/></div></div><div id="38930807" class="c"><input type="checkbox" id="c-38930807" checked=""/><div class="controls bullet"><span class="by">manicennui</span><span>|</span><a href="#38935139">prev</a><span>|</span><a href="#38930792">next</a><span>|</span><label class="collapse" for="c-38930807">[-]</label><label class="expand" for="c-38930807">[1 more]</label></div><br/><div class="children"><div class="content">A lot of these same problems were solved in a similar way with Datomic and xtdb.<p><a href="https:&#x2F;&#x2F;www.datomic.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.datomic.com&#x2F;</a>
<a href="https:&#x2F;&#x2F;xtdb.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xtdb.com&#x2F;</a></div><br/></div></div><div id="38930792" class="c"><input type="checkbox" id="c-38930792" checked=""/><div class="controls bullet"><span class="by">jakozaur</span><span>|</span><a href="#38930807">prev</a><span>|</span><a href="#38930915">next</a><span>|</span><label class="collapse" for="c-38930792">[-]</label><label class="expand" for="c-38930792">[3 more]</label></div><br/><div class="children"><div class="content">My biggest problem with databases is that they are very hard to evolve. They accumulate a history of decisions and are in a suboptimal state. Legacy is widespread in enterprises. Oracle is still milking $ 50B+ annually, and the databases are the primary driver of why you need Oracle and why they can upsell you other products after a compliance audit.<p>The schema changes are hard (e.g. try to normalize&#x2F;denormalize data), production is the only environment when things go wrong, in-place changes with untested revert options are default, etc.</div><br/><div id="38931055" class="c"><input type="checkbox" id="c-38931055" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#38930792">parent</a><span>|</span><a href="#38930915">next</a><span>|</span><label class="collapse" for="c-38931055">[-]</label><label class="expand" for="c-38931055">[2 more]</label></div><br/><div class="children"><div class="content">Clearly, there&#x27;s some truth to this perspective.  On the other hand, which alternative actually makes this easier? If your schema is non-enforced, and&#x2F;or your data (and its schema) are in loosely coupled distributed silos, and&#x2F;or as in the articles case indexes are essentially little programs...  Then broad scale schema evolution goes from being difficult to often being effectively entirely infeasible.<p>It&#x27;s possible that in turn forces users to adapt and split their changes into smaller chunks, but that&#x27;s pretty speculative and they might simply fail entirely in the attempt.<p>Which data stores are more easily evolved than a relational DB with a fairly restrictive schema?</div><br/><div id="38931208" class="c"><input type="checkbox" id="c-38931208" checked=""/><div class="controls bullet"><span class="by">jakozaur</span><span>|</span><a href="#38930792">root</a><span>|</span><a href="#38931055">parent</a><span>|</span><a href="#38930915">next</a><span>|</span><label class="collapse" for="c-38931208">[-]</label><label class="expand" for="c-38931208">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you that schema has tremendous value. Let&#x27;s store JSON everywhere and infer it on read, backfires in a big way. Even MongoDB added tooling to enforce a schema.<p>I just wish there was a better tooling to evolve schema. Blue&#x2F;green deployments, schema as code (no manual up and down procedures), good backward compatibility story, shadow testing in production, etc.<p>The database still feels like a monolith and did not get the benefits of the microservice revolution.</div><br/></div></div></div></div></div></div><div id="38930915" class="c"><input type="checkbox" id="c-38930915" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38930792">prev</a><span>|</span><a href="#38936836">next</a><span>|</span><label class="collapse" for="c-38930915">[-]</label><label class="expand" for="c-38930915">[1 more]</label></div><br/><div class="children"><div class="content">Well, I guess it&#x27;s official. The belief on software architecture dogma is so strong that we can consider it a church.<p>I imagine that will bring great tax benefits to programing schools.</div><br/></div></div><div id="38936836" class="c"><input type="checkbox" id="c-38936836" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#38930915">prev</a><span>|</span><a href="#38930520">next</a><span>|</span><label class="collapse" for="c-38936836">[-]</label><label class="expand" for="c-38936836">[1 more]</label></div><br/><div class="children"><div class="content">Most SQL RDBMS are a materialised view over a transaction log.</div><br/></div></div><div id="38930520" class="c"><input type="checkbox" id="c-38930520" checked=""/><div class="controls bullet"><span class="by">kevsim</span><span>|</span><a href="#38936836">prev</a><span>|</span><a href="#38930989">next</a><span>|</span><label class="collapse" for="c-38930520">[-]</label><label class="expand" for="c-38930520">[1 more]</label></div><br/><div class="children"><div class="content">Is this Rama solution similar to the kind of thing you can get with Kafka with KTables?<p>If so I&#x27;d be curious how they&#x27;ve solved making it in anyway operational less complex to manage then a database. It&#x27;s been a few years since I&#x27;ve run Kafka but it used to kind of be a beast.</div><br/></div></div><div id="38930989" class="c"><input type="checkbox" id="c-38930989" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38930520">prev</a><span>|</span><a href="#38930591">next</a><span>|</span><label class="collapse" for="c-38930989">[-]</label><label class="expand" for="c-38930989">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However, storing data normalized can increase the work to perform queries by requiring more joins. Oftentimes, that extra work is so much youâre forced to denormalize the database to improve performance.<p>Databases have materialized views though, that solves this problem.</div><br/></div></div><div id="38930591" class="c"><input type="checkbox" id="c-38930591" checked=""/><div class="controls bullet"><span class="by">the_duke</span><span>|</span><a href="#38930989">prev</a><span>|</span><a href="#38930653">next</a><span>|</span><label class="collapse" for="c-38930591">[-]</label><label class="expand" for="c-38930591">[1 more]</label></div><br/><div class="children"><div class="content">Every time I tried to use event sourcing I have regretted it, outside of some narrow and focused use cases.<p>In theory ES is brilliant and offers a lot of great functionality like replaying history to find bugs, going back to any arbitrary point in history, being able to restore just from the event log, diverse and use case tailored projections, scalability, ...<p>In practice it increases the complexity to the point were it&#x27;s a pointless chore.<p>Problems:<p>* the need for events, aggregates and projections increases the boilerplate tremendously. You end up with lots of types and related code representing the same thing. Adding a single field can lead to a 200+ LOC diff<p>* a simple thing like having a unique index becomes a complex architectural decision and problem ... do you have an in-memory aggregate? That doesn&#x27;t scale. Do you use a projection with an external database? well, how do you keep that change ACID? etc<p>* you need to keep support for old event versions forever, and either need code to cast older event versions into newer ones, or have a event log rewrite flow that removes old events before you can remove them from code<p>* if you have bugs in  you can end up needing fixup events &#x2F; event types that only exist to clean up , and as above, you have to keep that around for a long time<p>* similarly, bugs in projection code can mess up the target databases and require cumbersome cleanup &#x2F; rebuilding the whole projection<p>* regulation like GDPR requires deleting user data, but often you can&#x27;t &#x2F; don&#x27;t want to just delete everything, so you need an anonimizing rewrite flow. it can also become quite hard to figure out where the data actually is<p>* the majority of use cases will make little to no use of the actual benefits<p>A lot of the above could be fixed with proper tooling. A powerful ES database that handles event schemas, schema migrations, projections, indexes, etc, maybe with a declarative system that also allows providing custom code where necessary.<p>I&#x27;ll take a look at Rama I guess.</div><br/></div></div><div id="38930951" class="c"><input type="checkbox" id="c-38930951" checked=""/><div class="controls bullet"><span class="by">continuational</span><span>|</span><a href="#38930653">prev</a><span>|</span><a href="#38930661">next</a><span>|</span><label class="collapse" for="c-38930951">[-]</label><label class="expand" for="c-38930951">[4 more]</label></div><br/><div class="children"><div class="content">Does it have ACID transactions?<p>Does the indexes have read after write guarantees?</div><br/><div id="38931046" class="c"><input type="checkbox" id="c-38931046" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930951">parent</a><span>|</span><a href="#38930661">next</a><span>|</span><label class="collapse" for="c-38931046">[-]</label><label class="expand" for="c-38931046">[3 more]</label></div><br/><div class="children"><div class="content">Yes to both. Our bank transfer example in rama-demo-gallery is a good example of this. <a href="https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery">https:&#x2F;&#x2F;github.com&#x2F;redplanetlabs&#x2F;rama-demo-gallery</a></div><br/><div id="38931924" class="c"><input type="checkbox" id="c-38931924" checked=""/><div class="controls bullet"><span class="by">continuational</span><span>|</span><a href="#38930951">root</a><span>|</span><a href="#38931046">parent</a><span>|</span><a href="#38930661">next</a><span>|</span><label class="collapse" for="c-38931924">[-]</label><label class="expand" for="c-38931924">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s very good to hear!<p>I can&#x27;t say I understand the example. It seems to talk a lot about implementation details compared to the naive SQL:<p><pre><code>    create table account (
        account_id bigint primary key,
        balance bigint not null default 0,
        check (balance &gt;= 0)
    );
    
    begin;
    update account set balance = balance - $amount where account_id = $from_id;
    update account set balance = balance + $amount where account_id = $to_id;
    commit;</code></pre></div><br/><div id="38932037" class="c"><input type="checkbox" id="c-38932037" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930951">root</a><span>|</span><a href="#38931924">parent</a><span>|</span><a href="#38930661">next</a><span>|</span><label class="collapse" for="c-38932037">[-]</label><label class="expand" for="c-38932037">[1 more]</label></div><br/><div class="children"><div class="content">The rama-demo-gallery example is distributed, and it&#x27;s also tracking incoming&#x2F;outgoing  transfers for each user.</div><br/></div></div></div></div></div></div></div></div><div id="38930661" class="c"><input type="checkbox" id="c-38930661" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#38930951">prev</a><span>|</span><a href="#38931336">next</a><span>|</span><label class="collapse" for="c-38930661">[-]</label><label class="expand" for="c-38930661">[2 more]</label></div><br/><div class="children"><div class="content">Whatâs micro batch streaming?</div><br/><div id="38931077" class="c"><input type="checkbox" id="c-38931077" checked=""/><div class="controls bullet"><span class="by">nathanmarz</span><span>|</span><a href="#38930661">parent</a><span>|</span><a href="#38931336">next</a><span>|</span><label class="collapse" for="c-38931077">[-]</label><label class="expand" for="c-38931077">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a way of doing stream processing that sacrifices a little bit of update latency for higher throughput and exactly-once processing semantics. Regular streaming has single-digit milli update latency, while microbatching has at least a few hundred millis update latency.<p>By &quot;exactly-once processing semantics&quot;, I mean that regardless of how many failures are on the cluster (e.g. nodes losing power, network partitions), the updates into all partitions of all indexes will be as if there were no failures at all. Pure streaming, on the other hand, has either &quot;at-least once&quot; or &quot;at-most once&quot; semantics.</div><br/></div></div></div></div><div id="38931336" class="c"><input type="checkbox" id="c-38931336" checked=""/><div class="controls bullet"><span class="by">specialist</span><span>|</span><a href="#38930661">prev</a><span>|</span><a href="#38930577">next</a><span>|</span><label class="collapse" for="c-38931336">[-]</label><label class="expand" for="c-38931336">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;blog.redplanetlabs.com&#x2F;2024&#x2F;01&#x2F;09&#x2F;everything-wrong-with-databases-and-why-their-complexity-is-now-unnecessary&#x2F;#Restrictive_schemas" rel="nofollow">https:&#x2F;&#x2F;blog.redplanetlabs.com&#x2F;2024&#x2F;01&#x2F;09&#x2F;everything-wrong-w...</a><p>&gt; <i>Itâs common to instead use adapter libraries that map a domain representation to a database representation, such as ORMs. However, such an abstraction frequently leaks and causes issues. ...</i><p>FWIW, I&#x27;m creating a tool (strategy) that is neither an ORM or an abstraction layer (eg JOOQ) or template-based (eg myBatis). Just type safe adapters for normal SQL statements.<p>Will be announcing an alpha release &quot;Any Week Now&quot;.<p>If anyone has an idea for how to monetize yet another database client library, I&#x27;m all ears. I just need to eat, pay rent, and buy dog kibble.</div><br/><div id="38933250" class="c"><input type="checkbox" id="c-38933250" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#38931336">parent</a><span>|</span><a href="#38930577">next</a><span>|</span><label class="collapse" for="c-38933250">[-]</label><label class="expand" for="c-38933250">[1 more]</label></div><br/><div class="children"><div class="content">put &quot;AI&quot; in the name?</div><br/></div></div></div></div><div id="38930577" class="c"><input type="checkbox" id="c-38930577" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#38931336">prev</a><span>|</span><a href="#38930495">next</a><span>|</span><label class="collapse" for="c-38930577">[-]</label><label class="expand" for="c-38930577">[1 more]</label></div><br/><div class="children"><div class="content">strapping in for the clickbait blog post...<p><i>&quot;Global mutable state is harmful&quot;</i> - well... yes, that&#x27;s totally correct. <i>&quot;The better approach [..] is event sourcing plus materialized views.&quot;</i> .....errr... that&#x27;s <i>one</i> approach. we probably shouldn&#x27;t hitch all our ponies to one post.<p><i>&quot;Data models are restrictive&quot;</i> - well, yes, but that&#x27;s not necessarily a bad thing, it&#x27;s just &quot;a thing&quot;. <i>&quot;If you can specify your indexes in terms of the simpler primitive of data structures, then your datastore can express any data model. Additionally, it can express infinite more by composing data structures in different ways&quot;</i> - perhaps the reader can see where this is a bad idea? by allowing infinite data structures, we now have infinite complexity. great. so rather than 4 restrictive data models, we&#x27;ll have 10,000.<p><i>&quot;Thereâs a fundamental tension between being a source of truth versus being an indexed store that answers queries quickly. The traditional RDBMS architecture conflates these two concepts into the same datastore.&quot;</i> - well, the problem with looking at it this way is, there is no truth. if you give any system enough time to operate, grow and change, eventually the information that was &quot;the truth&quot; eventually receives information back from something that was &quot;indexing&quot; the truth. &quot;truth&quot; is relative. <i>&quot;The solution is to treat these two concepts separately. One subsystem should be used for representing the source of truth, and another should be used for materializing any number of indexed stores off of that source of truth.&quot;</i> this will fail eventually when your source of truth isn&#x27;t as truthy as you&#x27;d like it to be.<p><i>&quot;The restrictiveness of database schemas forces you to twist your application to fit the database in undesirable ways.&quot;</i> - it&#x27;s a tool. it&#x27;s not going to do everything you want, exactly as you want. the tradeoff is that it does one thing really specifically and well.<p><i>&quot;The a la carte model exists because the software industry has operated without a cohesive model for constructing end-to-end application backends.&quot;</i> - but right there you&#x27;re conceding that there has to be a &quot;backend&quot; and &quot;frontend&quot; to software design. your models are restrictive because your paradigms are. <i>&quot;When you use tooling that is built under a truly cohesive model, the complexities of the a la carte model melt away, the opportunity for abstraction, automation, and reuse skyrockets, and the cost of software development drastically decreases.&quot;</i> - but actually it&#x27;s the opposite: a &quot;cohesive model&quot; just means &quot;really opinionated&quot;. a-la-carte is actually a significant improvement over cohesion <i>when it is simple and loosely-coupled</i>. there will always be necessary complexity, but it can be managed easier when individual components maintain their own cohesion, and outside of those components, maintain an extremely simple, easy interface. <i>that</i> is what makes for more composable systems that are easier to think about, not cohesion between all of the components!<p><i>&quot;A cohesive model for building application backends&quot;</i> - some really good thoughts in the article, but ultimately &quot;cohesion&quot; between system components is not going to win out over individual components that maintain their cohesion and join via loosely-coupled interfaces. if you don&#x27;t believe me, look at the whole Internet.</div><br/></div></div><div id="38930495" class="c"><input type="checkbox" id="c-38930495" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38930577">prev</a><span>|</span><a href="#38930677">next</a><span>|</span><label class="collapse" for="c-38930495">[-]</label><label class="expand" for="c-38930495">[6 more]</label></div><br/><div class="children"><div class="content"><i>Data models are restrictive</i><p>That&#x27;s kind of the point. Model your data. Think about it. Don&#x27;t (mis)treat your database as a &quot;persistence layer&quot; -- it&#x27;s not. It&#x27;s a knowledge base.  The &quot;restriction&quot; in the relational model is making you think about knowledge, facts, data, and then structure them in a way that is <i>then</i> more universal and less restrictive for the future.<p>Relations are very expressive and done right is far more flexible than the others named there. That was Codd&#x27;s entire point:<p><a href="https:&#x2F;&#x2F;www.seas.upenn.edu&#x2F;~zives&#x2F;03f&#x2F;cis550&#x2F;codd.pdf" rel="nofollow">https:&#x2F;&#x2F;www.seas.upenn.edu&#x2F;~zives&#x2F;03f&#x2F;cis550&#x2F;codd.pdf</a><p><i>&quot;Future users of large data banks must be protected from
having to know how the data is organized in the machine (the
internal representation) ...&quot;</i> and then goes on to explain how the predicate-logic based relational data model is a more universal and flexible model that protects users&#x2F;developers from the <i>static</i> impositions of tree-structured&#x2F;network structure models.<p>All the other stuff in this article is getting stuck in the technical minutiae of how SQL RDBMSs are implemented (author seems obsessed with indexes). But that&#x27;s somewhat beside the point. A purely relational database that jettisons SQL doesn&#x27;t have to have the limitations the author is poking at.<p>It&#x27;s so frustrating we&#x27;re still going over this stuff decades later. This was a painful read. People developing databases should already be schooled in this stuff.</div><br/><div id="38933034" class="c"><input type="checkbox" id="c-38933034" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#38930495">parent</a><span>|</span><a href="#38932225">next</a><span>|</span><label class="collapse" for="c-38933034">[-]</label><label class="expand" for="c-38933034">[2 more]</label></div><br/><div class="children"><div class="content">If Postgres was already horizontally scalable and supported incrementally maintained recursive CTEs (like Materialize can do) then I could see how Rama would be mostly uninteresting to a seasoned SQL developer, but as it is I think Rama is offering a pretty novel &amp; valuable set of 3GL capabilities for developers who need to build scalable reactive applications as quickly as possible. Capabilities which other SQL databases will struggle to match without also dropping down to 3GL APIs.<p>&gt; A purely relational database that jettisons SQL doesn&#x27;t have to have the limitations the author is poking at.<p>Agreed. Relational databases can take us a lot further yet.</div><br/></div></div><div id="38932225" class="c"><input type="checkbox" id="c-38932225" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#38930495">parent</a><span>|</span><a href="#38933034">prev</a><span>|</span><a href="#38931437">next</a><span>|</span><label class="collapse" for="c-38932225">[-]</label><label class="expand" for="c-38932225">[2 more]</label></div><br/><div class="children"><div class="content">Precisely this. Every âsolutionâ Iâve seen approaches RDBMS as an obviously incorrect kludge that must be done away with in the name of DX.<p>RDBMS hasnât stuck around this long only because itâs good enough. Itâs an incredibly powerful way to model data, for now and the future, but yes, it does require you to think carefully and slow down. These are not things to be avoided.</div><br/><div id="38933977" class="c"><input type="checkbox" id="c-38933977" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38930495">root</a><span>|</span><a href="#38932225">parent</a><span>|</span><a href="#38931437">next</a><span>|</span><label class="collapse" for="c-38933977">[-]</label><label class="expand" for="c-38933977">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the core of the problem with people &quot;getting it&quot; has always been that SQL has been so mediocre, and yet it&#x27;s the only serious option people have.<p>And so people go looking for something with a modern syntax, that&#x27;s properly composable, functional, etc. but because they haven&#x27;t studied the foundations, they reinvent the wheel badly.<p>The Codd paper is so readable, and so persuasive. People need to start there, and <i>then</i> argue why their novel approach is better on first principles, not just because it smells better than SQL.<p>But that it&#x27;s stuck around and done so well for so long tells you that the core foundation is sound.</div><br/></div></div></div></div><div id="38931437" class="c"><input type="checkbox" id="c-38931437" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#38930495">parent</a><span>|</span><a href="#38932225">prev</a><span>|</span><a href="#38930677">next</a><span>|</span><label class="collapse" for="c-38931437">[-]</label><label class="expand" for="c-38931437">[1 more]</label></div><br/><div class="children"><div class="content">&gt; our database as a &quot;persistence layer&quot; -- it&#x27;s not. It&#x27;s a knowledge base.<p>Love this. Your database <i>is</i> your app in my opinion. The data model matters.</div><br/></div></div></div></div><div id="38930677" class="c"><input type="checkbox" id="c-38930677" checked=""/><div class="controls bullet"><span class="by">skywhopper</span><span>|</span><a href="#38930495">prev</a><span>|</span><label class="collapse" for="c-38930677">[-]</label><label class="expand" for="c-38930677">[1 more]</label></div><br/><div class="children"><div class="content">This is marketing spiel masquerading as a bad take. Rama may or may not be cool tech, but the idea that they are anywhere close to being able to get rid of structured database systems for complex systems is absolutely laughable to the point that it makes me uninterested in learning more about the tech. Please tone down the hyperbole if you want serious attention.</div><br/></div></div></div></div></div></div></div></body></html>