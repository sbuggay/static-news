<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705309267003" as="style"/><link rel="stylesheet" href="styles.css?v=1705309267003"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/fwsGonzo/rvscript">Fast RISC-V-based scripting back end for game engines</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>fwsgonzo</span> | <span>73 comments</span></div><br/><div><div id="38998256" class="c"><input type="checkbox" id="c-38998256" checked=""/><div class="controls bullet"><span class="by">kouteiheika</span><span>|</span><a href="#38994335">next</a><span>|</span><label class="collapse" for="c-38998256">[-]</label><label class="expand" for="c-38998256">[1 more]</label></div><br/><div class="children"><div class="content">Nice to see another RISC-V based VM!<p>I&#x27;m working on something similar, but instead of optimizing for low call latency I&#x27;m prioritizing security, execution performance and compilation speed. I&#x27;m currently at roughly the same execution speed as wasmtime, but with over 200x faster compilation, and with significantly better security sandboxing.<p>RISC-V (well, a slightly modified variant) actually makes for a really good VM bytecode!</div><br/></div></div><div id="38994335" class="c"><input type="checkbox" id="c-38994335" checked=""/><div class="controls bullet"><span class="by">dataangel</span><span>|</span><a href="#38998256">prev</a><span>|</span><a href="#38994032">next</a><span>|</span><label class="collapse" for="c-38994335">[-]</label><label class="expand" for="c-38994335">[27 more]</label></div><br/><div class="children"><div class="content">This was posted before and I still have no idea what the rationale is. No desktop PC or game console is RISC-V, so if I&#x27;m going to all the trouble to use a scripting solution that requires me to compile my scripts to machine language, why would I target RISC-V? Why wouldn&#x27;t I just compile to x86-64 directly?<p>Like, what is the vision here, a LuaJIT that targets RISC-V, running inside my x86-64 game, where the emulator translates the RISC-V back into x86-64... for reasons? Just isolation?</div><br/><div id="38998001" class="c"><input type="checkbox" id="c-38998001" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#38994335">parent</a><span>|</span><a href="#38995138">next</a><span>|</span><label class="collapse" for="c-38998001">[-]</label><label class="expand" for="c-38998001">[3 more]</label></div><br/><div class="children"><div class="content">The project explains that the reason is latency.<p>It is indeed true that most VMs, including JavaScript, WebAssembly, the JVM, etc., have significant latency on the boundary. For example, many wasm VMs will install a signal handler, and that needs to be enabled&#x2F;disabled on each entry&#x2F;exit from the VM.<p>But the latency can be fixed. You can sandbox WebAssembly without a signal handler, in particular (at the cost of a few % throughput overhead for bounds checks). I&#x27;m not sure if the author benchmarked that, but it should be very fast.<p>(As for &quot;why RISC-V&quot; in the project, it looks like that&#x27;s because it&#x27;s easy to write an interpreter for, but it could have been any compiler target, it seems.)</div><br/><div id="38998333" class="c"><input type="checkbox" id="c-38998333" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38998001">parent</a><span>|</span><a href="#38995138">next</a><span>|</span><label class="collapse" for="c-38998333">[-]</label><label class="expand" for="c-38998333">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also latencies for arguments into and out from the emulators. I&#x27;m not sure the custom signal handling alone can account for that.<p>I agree that it could as well have been MIPS or ARM.</div><br/><div id="38998411" class="c"><input type="checkbox" id="c-38998411" checked=""/><div class="controls bullet"><span class="by">sspiff</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38998333">parent</a><span>|</span><a href="#38995138">next</a><span>|</span><label class="collapse" for="c-38998411">[-]</label><label class="expand" for="c-38998411">[1 more]</label></div><br/><div class="children"><div class="content">I think there are a couple of reasons for picking RISC-V over others.<p>It is the youngest of the lot, meaning it is carrying around the least legacy compatibility stuff while still incorporating a lot of modern design lessons.<p>Additionally, modern ARM and MIPS are not free and (potentially?) patent encumbered as well.<p>You could go with some old, free MIPS or ARM, but then how good is performance, and how good is compiler support for these nowadays?</div><br/></div></div></div></div></div></div><div id="38995138" class="c"><input type="checkbox" id="c-38995138" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#38994335">parent</a><span>|</span><a href="#38998001">prev</a><span>|</span><a href="#38994363">next</a><span>|</span><label class="collapse" for="c-38995138">[-]</label><label class="expand" for="c-38995138">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ...for reasons?<p>Yes. When something&#x27;s intellectually stimulating you work on it more, that&#x27;s it.<p>Most game development is a grind. These huge distractions, like a scripting backend, well if you spend 100h working on the scripting engine only to spend 1h authoring actual scripts, you still spent 1h authoring scripts those 2 weeks instead of 0h. The game gets delivered sooner even if you spend 10x as long working on it.<p>It&#x27;s a quintessential misunderstanding about indie game development. HN readers think Jonathan Blow is wasting his time writing a whole new programming language and engine, and that&#x27;s why his games take 6 years to make. No: his games would take 20 years to make if they weren&#x27;t intellectually engaging to make. They wouldn&#x27;t be made at all!<p>It&#x27;s the same energy as rewriting everything in another programming language.<p>I think this happens at giant companies too, all the time. So called Not Invented Here syndrome: it&#x27;s as much about laundering open source code as it is about keeping things interesting enough to make the extreme boredom and grind worth it for otherwise smart and healthy people.</div><br/></div></div><div id="38994363" class="c"><input type="checkbox" id="c-38994363" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994335">parent</a><span>|</span><a href="#38995138">prev</a><span>|</span><a href="#38994351">next</a><span>|</span><label class="collapse" for="c-38994363">[-]</label><label class="expand" for="c-38994363">[7 more]</label></div><br/><div class="children"><div class="content">The sandbox is interpreting RISC-V, just very quickly. It&#x27;s platform independent. I am actually making a game with a derivative of this repo, and in the server I am building the programs at the same time as the server. Once the server starts, it loads all the programs, and then sends compressed programs to each client, so that everyone who connects has the same scripts. Easy and convenient, but most likely just that because I did it from the start.</div><br/><div id="38997824" class="c"><input type="checkbox" id="c-38997824" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38994363">parent</a><span>|</span><a href="#38994690">next</a><span>|</span><label class="collapse" for="c-38997824">[-]</label><label class="expand" for="c-38997824">[4 more]</label></div><br/><div class="children"><div class="content">Ok… so why not send llvm bytecode? Or JVM? Or JavaScript? Or WebAssembly?<p>Any of those would be better supported and have a faster, battle tested JIT engine.</div><br/><div id="38998302" class="c"><input type="checkbox" id="c-38998302" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38997824">parent</a><span>|</span><a href="#38998514">next</a><span>|</span><label class="collapse" for="c-38998302">[-]</label><label class="expand" for="c-38998302">[1 more]</label></div><br/><div class="children"><div class="content">Man it&#x27;s so frustrating as an author to explain you you didn&#x27;t just use existing technology X <i>in the linked article</i> but then be met by a flood of HN comments from people asking &quot;but why didn&#x27;t you just use existing technology X?&quot;</div><br/></div></div><div id="38998514" class="c"><input type="checkbox" id="c-38998514" checked=""/><div class="controls bullet"><span class="by">phero_cnstrcts</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38997824">parent</a><span>|</span><a href="#38998302">prev</a><span>|</span><a href="#38997983">next</a><span>|</span><label class="collapse" for="c-38998514">[-]</label><label class="expand" for="c-38998514">[1 more]</label></div><br/><div class="children"><div class="content">For the same reasons that I don’t write my websites in React.</div><br/></div></div></div></div><div id="38994690" class="c"><input type="checkbox" id="c-38994690" checked=""/><div class="controls bullet"><span class="by">speps</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38994363">parent</a><span>|</span><a href="#38997824">prev</a><span>|</span><a href="#38994351">next</a><span>|</span><label class="collapse" for="c-38994690">[-]</label><label class="expand" for="c-38994690">[2 more]</label></div><br/><div class="children"><div class="content">This is an interesting concept, getting the gameplay logic sent to the client this way. I guess it only works for simpler games so far, do you have any code examples?</div><br/><div id="38995041" class="c"><input type="checkbox" id="c-38995041" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38994690">parent</a><span>|</span><a href="#38994351">next</a><span>|</span><label class="collapse" for="c-38995041">[-]</label><label class="expand" for="c-38995041">[1 more]</label></div><br/><div class="children"><div class="content">The game is quite complex actually, but the script is not doing overmuch right now. The script is doing things that makes sense for a growing modding API, while the engine still does the brunt of the work. That said, there are functions that end up being called billions of times simply because you want that flexibility, and that&#x27;s where the low latency script pays off.</div><br/></div></div></div></div></div></div><div id="38994351" class="c"><input type="checkbox" id="c-38994351" checked=""/><div class="controls bullet"><span class="by">nagisa</span><span>|</span><a href="#38994335">parent</a><span>|</span><a href="#38994363">prev</a><span>|</span><a href="#38998332">next</a><span>|</span><label class="collapse" for="c-38994351">[-]</label><label class="expand" for="c-38994351">[5 more]</label></div><br/><div class="children"><div class="content">The answer lies in the reason why you would use an embedded scripting language&#x2F;environment at all, over just loading native code plugins – sandboxing, fault isolation and such.<p>RISC-V seems to be used here more as a bytecode format of sorts, and at least compared to x86_64 it should be much easier to implement (first of all because all of the opcodes have the same size.)</div><br/><div id="38997896" class="c"><input type="checkbox" id="c-38997896" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38994351">parent</a><span>|</span><a href="#38997318">next</a><span>|</span><label class="collapse" for="c-38997896">[-]</label><label class="expand" for="c-38997896">[1 more]</label></div><br/><div class="children"><div class="content">Using a sandboxed bytecode VM has merit, but I would naively expect wasm to be far better at it since RISC-V was designed for hardware and wasm was designed for exactly this usecase (sandboxed code running in another application with good performance and isolation).<p>(Although... I do see value in having a second option. I guess it might be worth seeing if it can actually be better, even though it&#x27;s not the thing I would have written)</div><br/></div></div><div id="38997318" class="c"><input type="checkbox" id="c-38997318" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38994351">parent</a><span>|</span><a href="#38997896">prev</a><span>|</span><a href="#38998332">next</a><span>|</span><label class="collapse" for="c-38997318">[-]</label><label class="expand" for="c-38997318">[3 more]</label></div><br/><div class="children"><div class="content">I mean sure, but virtualization is a very robust (and much lower overhead) technology that is readily available (and supported by the processor). If you just want isolation, why wouldn&#x27;t you use that? You still have to ship a compiled binary after all.</div><br/><div id="38998306" class="c"><input type="checkbox" id="c-38998306" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38997318">parent</a><span>|</span><a href="#38998332">next</a><span>|</span><label class="collapse" for="c-38998306">[-]</label><label class="expand" for="c-38998306">[2 more]</label></div><br/><div class="children"><div class="content">If you just want to run some CPU bound code as fast as possible, virtualisation has low overhead.<p>But if you are doing a lot of communication between the script and the host system, I&#x27;m not sure virtualisation does so well?</div><br/><div id="38998349" class="c"><input type="checkbox" id="c-38998349" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38998306">parent</a><span>|</span><a href="#38998332">next</a><span>|</span><label class="collapse" for="c-38998349">[-]</label><label class="expand" for="c-38998349">[1 more]</label></div><br/><div class="children"><div class="content">No, as the author of TinyKVM, the overheads of entering and leaving KVM is not the same order of magnitude as SFI. TinyKVM requires 2-3 microseconds to enter and leave, which is the lowest I ever managed to get while it still being robust and dependable sandbox. For some, that might seem really low, but keep in mind that libriscv which is the backbone of RVScript has 3 nanoseconds overhead.</div><br/></div></div></div></div></div></div></div></div><div id="38998332" class="c"><input type="checkbox" id="c-38998332" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#38994335">parent</a><span>|</span><a href="#38994351">prev</a><span>|</span><a href="#38996969">next</a><span>|</span><label class="collapse" for="c-38998332">[-]</label><label class="expand" for="c-38998332">[1 more]</label></div><br/><div class="children"><div class="content">The readme literally explains why the author doesn&#x27;t want to use LuaJIT though?</div><br/></div></div><div id="38996969" class="c"><input type="checkbox" id="c-38996969" checked=""/><div class="controls bullet"><span class="by">crq-yml</span><span>|</span><a href="#38994335">parent</a><span>|</span><a href="#38998332">prev</a><span>|</span><a href="#38994797">next</a><span>|</span><label class="collapse" for="c-38996969">[-]</label><label class="expand" for="c-38996969">[1 more]</label></div><br/><div class="children"><div class="content">At large scale, game engines have relatively unsatisfying answers to &quot;what&#x27;s the best way to iterate quickly on the game while supporting all the features we need&quot;.<p>If the scope is small, the answer is easy: write some naive code, incrementally profile. The project isn&#x27;t big so full rebuild times can stay light, and your team isn&#x27;t large so you really can &quot;do whatever&quot; and get somewhere, especially if you take the route of writing in a native language that compiles fast - a Pascal or something more &quot;new and hip&quot; like Beef.<p>But when you are asked to do it on a AAA project you end up with every imaginable kind of feature: it needs to support a team of hundreds, it needs to be fast on console hardware, it needs to be straightforward to debug, it needs to support modding, it needs to be fast to iterate on, it needs to be flexible about the memory layouts of save data or assets.<p>So you do end up in this kind of space where you&#x27;re like, &quot;we&#x27;ll target a VM that is really low level, and that&#x27;ll reduce the friction and granularity of switching between debug and release profiles, and that lets us stay in control of when we want to sandbox and when we want to go fast and we&#x27;ll still be able to control every byte&quot;. That it happens to be RISC-V is not super relevant - it could be WASM or a custom bytecode like the Hashlink target in Haxe. It just needs to be a thing to compile to, that you can reasonably expect to implement and maintain.<p>It&#x27;s not the only approach that could be taken. Downscoping the ambition by 50% and hardcoding a little more of your spec is a good way to get through the technical stuff 10x faster.</div><br/></div></div><div id="38994797" class="c"><input type="checkbox" id="c-38994797" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38994335">parent</a><span>|</span><a href="#38996969">prev</a><span>|</span><a href="#38995393">next</a><span>|</span><label class="collapse" for="c-38994797">[-]</label><label class="expand" for="c-38994797">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, it seems like WASM would be a better choice?</div><br/><div id="38996862" class="c"><input type="checkbox" id="c-38996862" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38994797">parent</a><span>|</span><a href="#38995015">next</a><span>|</span><label class="collapse" for="c-38996862">[-]</label><label class="expand" for="c-38996862">[1 more]</label></div><br/><div class="children"><div class="content">Rationale from the README:<p>&gt; Lua, Luau and even LuaJIT have fairly substantial overheads when making function calls into the script, especially when many arguments are involved. The same is true for WebAssembly emulators that I have measured, eg. wasmtime.</div><br/></div></div><div id="38995015" class="c"><input type="checkbox" id="c-38995015" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38994797">parent</a><span>|</span><a href="#38996862">prev</a><span>|</span><a href="#38995393">next</a><span>|</span><label class="collapse" for="c-38995015">[-]</label><label class="expand" for="c-38995015">[1 more]</label></div><br/><div class="children"><div class="content">Or transpiling to C&#x2F;C++, like Nim.</div><br/></div></div></div></div><div id="38995393" class="c"><input type="checkbox" id="c-38995393" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38994335">parent</a><span>|</span><a href="#38994797">prev</a><span>|</span><a href="#38995855">next</a><span>|</span><label class="collapse" for="c-38995393">[-]</label><label class="expand" for="c-38995393">[4 more]</label></div><br/><div class="children"><div class="content">RISC-V is quite fast as far as whole-platform emulation goes, but yes using it for plugin code is a bit weird, WASM would seem to be preferable for that use case.  The interfacing story of WASM is not quite perfect (you&#x27;re limited to a C-like baseline API&#x2F;ABI, since the WASM components standards is not finished yet) but it&#x27;s not like RISC-V is any better.</div><br/><div id="38995759" class="c"><input type="checkbox" id="c-38995759" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38995393">parent</a><span>|</span><a href="#38997971">next</a><span>|</span><label class="collapse" for="c-38995759">[-]</label><label class="expand" for="c-38995759">[1 more]</label></div><br/><div class="children"><div class="content">This is completely ignoring that RVScript has really nice APIs both ways. While being lower latency.</div><br/></div></div><div id="38997971" class="c"><input type="checkbox" id="c-38997971" checked=""/><div class="controls bullet"><span class="by">ur-whale</span><span>|</span><a href="#38994335">root</a><span>|</span><a href="#38995393">parent</a><span>|</span><a href="#38995759">prev</a><span>|</span><a href="#38995855">next</a><span>|</span><label class="collapse" for="c-38997971">[-]</label><label class="expand" for="c-38997971">[2 more]</label></div><br/><div class="children"><div class="content">&gt; WASM would seem to be preferable for that use case.<p>Doesn&#x27;t he explicitly address WASM as an unfit backend in the article ?</div><br/></div></div></div></div><div id="38995855" class="c"><input type="checkbox" id="c-38995855" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#38994335">parent</a><span>|</span><a href="#38995393">prev</a><span>|</span><a href="#38994032">next</a><span>|</span><label class="collapse" for="c-38995855">[-]</label><label class="expand" for="c-38995855">[1 more]</label></div><br/><div class="children"><div class="content">I wonder whether they&#x27;ve accounted for running it on actual RISC-V hardware.<p>It could definitely still emulate itself, but it&#x27;d be far higher performing to run the code directly in some sort of sandbox.</div><br/></div></div></div></div><div id="38994032" class="c"><input type="checkbox" id="c-38994032" checked=""/><div class="controls bullet"><span class="by">SotCodeLaureate</span><span>|</span><a href="#38994335">prev</a><span>|</span><a href="#38994369">next</a><span>|</span><label class="collapse" for="c-38994032">[-]</label><label class="expand" for="c-38994032">[5 more]</label></div><br/><div class="children"><div class="content">Recently I wrote a simplistic RISC-V interpreter for educational purposes mostly, and a friend was benchmarking it against several scripting system in the context of game-character control routines.
Well, it&#x27;s quite fast for what it is, though Lua is still somewhat faster, heh.<p>Some benchmarking code is here:
<a href="https:&#x2F;&#x2F;github.com&#x2F;glebnovodran&#x2F;roam_bench">https:&#x2F;&#x2F;github.com&#x2F;glebnovodran&#x2F;roam_bench</a></div><br/><div id="38994066" class="c"><input type="checkbox" id="c-38994066" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994032">parent</a><span>|</span><a href="#38994369">next</a><span>|</span><label class="collapse" for="c-38994066">[-]</label><label class="expand" for="c-38994066">[4 more]</label></div><br/><div class="children"><div class="content">Very cool! One tip: Take the execute segment and produce fast bytecodes instead of interpreting each instruction as a bit pattern. Producing faster bytecodes is something that even WASM emulators do, despite it being a bytecode format.</div><br/><div id="38994207" class="c"><input type="checkbox" id="c-38994207" checked=""/><div class="controls bullet"><span class="by">SotCodeLaureate</span><span>|</span><a href="#38994032">root</a><span>|</span><a href="#38994066">parent</a><span>|</span><a href="#38994151">next</a><span>|</span><label class="collapse" for="c-38994207">[-]</label><label class="expand" for="c-38994207">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Yeah, this one is supposed to be a very simple implementation for a kind of &quot;how to write a machine code interpreter&quot; tutorial, but I was looking to experiment with some optimizations if time permits.
Patching with pre-baked alt-bytecode was one of the ideas indeed.</div><br/></div></div><div id="38994151" class="c"><input type="checkbox" id="c-38994151" checked=""/><div class="controls bullet"><span class="by">FPGAhacker</span><span>|</span><a href="#38994032">root</a><span>|</span><a href="#38994066">parent</a><span>|</span><a href="#38994207">prev</a><span>|</span><a href="#38994369">next</a><span>|</span><label class="collapse" for="c-38994151">[-]</label><label class="expand" for="c-38994151">[2 more]</label></div><br/><div class="children"><div class="content">What’s the difference between a bit pattern and a bytecode?</div><br/><div id="38994164" class="c"><input type="checkbox" id="c-38994164" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994032">root</a><span>|</span><a href="#38994151">parent</a><span>|</span><a href="#38994369">next</a><span>|</span><label class="collapse" for="c-38994164">[-]</label><label class="expand" for="c-38994164">[1 more]</label></div><br/><div class="children"><div class="content">The fast bytecode is reduced to a simple operation that excludes certain knowns. For example if you have an instruction that stores A0 = A1 + 0, then knowing the immediate is zero, this can be reduced from reading a complex bit pattern to a bytecode that moves from one register to another, basically MV dst=A0, src=A1.</div><br/></div></div></div></div></div></div></div></div><div id="38994369" class="c"><input type="checkbox" id="c-38994369" checked=""/><div class="controls bullet"><span class="by">logicprog</span><span>|</span><a href="#38994032">prev</a><span>|</span><a href="#38995377">next</a><span>|</span><label class="collapse" for="c-38994369">[-]</label><label class="expand" for="c-38994369">[10 more]</label></div><br/><div class="children"><div class="content">As someone who&#x27;s working on a game engine that&#x27;s designed to be highly data-driven, with only the core game engine itself in a systems programming language and a <i>lot</i> of calls out to scripts, this is very intriguing! C++20 doesn&#x27;t seem like a good candidate for an actual scripting language, so I&#x27;d have to find a suitable scripting language that can compile to RISC-V, though, and of course requiring precompilation is an issue.</div><br/><div id="38994483" class="c"><input type="checkbox" id="c-38994483" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994369">parent</a><span>|</span><a href="#38995377">next</a><span>|</span><label class="collapse" for="c-38994483">[-]</label><label class="expand" for="c-38994483">[9 more]</label></div><br/><div class="children"><div class="content">Yes, precompilation is not optional. I&#x27;ve used many languages in sandboxes over the years developing both this and other emulators.<p>I really like Nim the most. It&#x27;s Python spiritually, but with types. Types just really really necessary, and it does have FFI support so you can forward arguments either from a wrapper or use {.cdecl} directly. It&#x27;s still not a barneskirenn (as we say in Norway), but definitely the most fun I&#x27;ve had using another language in my various sandboxes.<p>Nelua and Zig are close seconds. Both are just so easy to work with C-based FFI. Nelua is probably not safe to use, as it&#x27;s still a work in progress. At least last I checked. Zig is very much ready to use. Maybe not your cup of tea, though.<p>Golang has a complex run-time and I don&#x27;t recommend using it. It&#x27;s definitely possible though as my sandbox does have a full MMU. Just expect integration to be long and ardous. And the ABI changes potentially every version.<p>Rust is one of the easier ones. I didn&#x27;t find it fun to work with though. It has by far the best inline assembly, but too much fighting with the compiler. I know that people love Rust, and it <i>is</i> fully supported in my emulator.<p>C&#x2F;C++ has the benefit of having the ability to have their underlying functions overridden by native helper system calls. Eg. replacing memcpy() with a system call that has native performance. It&#x27;s too long a long topic to talk about here, but Nim and Nelua also falls under this umbrella along with other languages that can compile to C&#x2F;C++.<p>Kotlin is definitely possible to use. A bit hard to understand how the native stuff actually works, but I did manage to run a hello world program in several sandboxes with some effort. I&#x27;m not 100% sure but I think I managed to convert a C API header directly to something kotlin understands using a one-liner in the terminal. I would say it scores high just on that. Again, just a bit hard to understand how to talk to Kotlin from an external FFI looking in.<p>JavaScript is of course possible with both jitless v8 and QuickJS. v8 requires writing some C++ scaffolding + host API functions, and QuickJS requires the same in C. Either works.<p>And I think that&#x27;s all the languages I have tried. If you think there&#x27;s a missing language here, then I would love to try it!</div><br/><div id="38994619" class="c"><input type="checkbox" id="c-38994619" checked=""/><div class="controls bullet"><span class="by">logicprog</span><span>|</span><a href="#38994369">root</a><span>|</span><a href="#38994483">parent</a><span>|</span><a href="#38998054">next</a><span>|</span><label class="collapse" for="c-38994619">[-]</label><label class="expand" for="c-38994619">[7 more]</label></div><br/><div class="children"><div class="content">This is a really interesting list, thank you for replying!<p>(the following are entirely undirected musings on using your technology for my game engine, mostly in case anyone finds them interesting or has something to suggest that I haven&#x27;t thought of since I&#x27;m new at this)<p>At least for my use case C, Zig, Rust, and even probably Nim are out of the question because I&#x27;m not just using scripting for sandboxing capabilities and such, I&#x27;m also using it because I want people to be able to program games and write mods in a high-level language, so using a systems programming language as my scripting language kind of feels like it defeats part of the purpose and I might as well just use dynamic linking with a C ABI or something crazy like that (I&#x27;m new to this so excuse me if that&#x27;s nonsense lol). JavaScript and Kotlin are intriguing though, because they aren&#x27;t systems programming languages, so I&#x27;ll have to think long and hard about those;<p>I&#x27;ve been considering C# for scripting lately (because I like it well enough, it&#x27;s widespread, and known in the gaming world) and I wonder if you can get natively aot compiled Kotlin to work, if you could get natively aot compiled C# to work too... there would probably be similar complications due to the large and complex runtime, but I know you can strip it down so I wonder how that might play in. I also wonder what the performance would be like compared to just hosting the dotnet runtime, which is what I was intending to do before I saw your post. Maybe at some point I should set up a benchmark to compare! Although I have to say the pre-compilation thing is a bit of a deal-breaker for me, since I really want people to be able to put plain text things directly in the game folder and see those changes in the engine without having to do any kind of build process, which is something that is achievable with the regular dotnet runtime using a precompiled assembly bootstraps the rest of the sctipts using dynamic assembly compilation and loading to collect everything else in the script directory.</div><br/><div id="38994903" class="c"><input type="checkbox" id="c-38994903" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994369">root</a><span>|</span><a href="#38994619">parent</a><span>|</span><a href="#38998054">next</a><span>|</span><label class="collapse" for="c-38994903">[-]</label><label class="expand" for="c-38994903">[6 more]</label></div><br/><div class="children"><div class="content">Hm, if you don&#x27;t actually need a sandbox then I think just using the C# run-time makes a lot of sense. I also like C#, but I&#x27;ve never been in a situation to try the fairly new AOT support. Sounds like a good idea, though. C# is a very good language.</div><br/><div id="38995899" class="c"><input type="checkbox" id="c-38995899" checked=""/><div class="controls bullet"><span class="by">brucehoult</span><span>|</span><a href="#38994369">root</a><span>|</span><a href="#38994903">parent</a><span>|</span><a href="#38998054">next</a><span>|</span><label class="collapse" for="c-38995899">[-]</label><label class="expand" for="c-38995899">[5 more]</label></div><br/><div class="children"><div class="content">C# runtime is HUGE and not ported to everything. The compilation step to native code takes a significant amount of time.</div><br/><div id="38996583" class="c"><input type="checkbox" id="c-38996583" checked=""/><div class="controls bullet"><span class="by">Rohansi</span><span>|</span><a href="#38994369">root</a><span>|</span><a href="#38995899">parent</a><span>|</span><a href="#38996303">next</a><span>|</span><label class="collapse" for="c-38996583">[-]</label><label class="expand" for="c-38996583">[3 more]</label></div><br/><div class="children"><div class="content">Do you mean compiling the .NET runtime (CoreCLR) itself or AOT compiling C# code? Because I recently tried AOT compiled C# and that builds quickly. And you don&#x27;t generally need to compile the .NET runtime when embedding it because you can just load the builds they ship.</div><br/><div id="38997067" class="c"><input type="checkbox" id="c-38997067" checked=""/><div class="controls bullet"><span class="by">brucehoult</span><span>|</span><a href="#38994369">root</a><span>|</span><a href="#38996583">parent</a><span>|</span><a href="#38996303">next</a><span>|</span><label class="collapse" for="c-38997067">[-]</label><label class="expand" for="c-38997067">[2 more]</label></div><br/><div class="children"><div class="content">Simply running a DotNET dll.  I just tried a basic &quot;Hello World&quot; program compiled to a CIL .dll and to RV64 machine code, on my x86 Linux machine (original ThreadRipper 2990WX) and then running it through different JIT&#x2F;interpreters. Wall time:<p>DotNET: 0.061s<p>qemu-riscv64: 0.006s<p>Spike: 0.031s<p>Qemu is JIT with Linux syscall layer built in (in native code).<p>Spike is a RISC-V interpreter with Linux syscall layer provided by interpreted RISC-V &quot;pk&quot;<p>So the DotNET JIT has quite a high overhead for startup, or one-time code.<p>For very compute-intensive code DotNet has an advantage. e.g. on my own primes benchmark (<a href="https:&#x2F;&#x2F;hoult.org&#x2F;primes.txt" rel="nofollow">https:&#x2F;&#x2F;hoult.org&#x2F;primes.txt</a>, <a href="https:&#x2F;&#x2F;hoult.org&#x2F;primes.cs" rel="nofollow">https:&#x2F;&#x2F;hoult.org&#x2F;primes.cs</a>)<p>DotNET: 3.5s<p>qemu-riscv64: 10.2s<p>gcc: 9.7s (i.e. defaulting to -O0)<p>gcc -O1: 3.2s<p>DotNET beats emulated RISC-V here, but the RISC-V emulator (with RISC-V code compiled with -O1) is pretty much as fast as a lazy person compiling C to native x86 gets.</div><br/><div id="38997731" class="c"><input type="checkbox" id="c-38997731" checked=""/><div class="controls bullet"><span class="by">Rohansi</span><span>|</span><a href="#38994369">root</a><span>|</span><a href="#38997067">parent</a><span>|</span><a href="#38996303">next</a><span>|</span><label class="collapse" for="c-38997731">[-]</label><label class="expand" for="c-38997731">[1 more]</label></div><br/><div class="children"><div class="content">Oh, so you meant startup time for the runtime, JIT, etc. then. That&#x27;s not exactly relevant to usage in game engines here because it is only done once.<p>If you want to compare startup times you should be using .NET&#x27;s AOT compilation so it doesn&#x27;t need to load the full runtime or do any JIT compilation. See here: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;deploying&#x2F;native-aot&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;core&#x2F;deploying&#x2F;nati...</a></div><br/></div></div></div></div></div></div><div id="38996303" class="c"><input type="checkbox" id="c-38996303" checked=""/><div class="controls bullet"><span class="by">logicprog</span><span>|</span><a href="#38994369">root</a><span>|</span><a href="#38995899">parent</a><span>|</span><a href="#38996583">prev</a><span>|</span><a href="#38998054">next</a><span>|</span><label class="collapse" for="c-38996303">[-]</label><label class="expand" for="c-38996303">[1 more]</label></div><br/><div class="children"><div class="content">Good to know. That solidifies my plan to embed the dotnet runtime in my engine and load JIT code, not compile C# to AOT and then run that through an emulation layer</div><br/></div></div></div></div></div></div></div></div><div id="38998054" class="c"><input type="checkbox" id="c-38998054" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38994369">root</a><span>|</span><a href="#38994483">parent</a><span>|</span><a href="#38994619">prev</a><span>|</span><a href="#38995377">next</a><span>|</span><label class="collapse" for="c-38998054">[-]</label><label class="expand" for="c-38998054">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be interested to see Scala (native).</div><br/></div></div></div></div></div></div><div id="38995377" class="c"><input type="checkbox" id="c-38995377" checked=""/><div class="controls bullet"><span class="by">stefanha</span><span>|</span><a href="#38994369">prev</a><span>|</span><a href="#38995962">next</a><span>|</span><label class="collapse" for="c-38995377">[-]</label><label class="expand" for="c-38995377">[3 more]</label></div><br/><div class="children"><div class="content">Is there a benchmark available where you compared Lua and wasmtime against your interpreter? It would be interesting for Lua and wasmtime developers to chime in on why the world switch overhead is higher and whether there exist configuration settings or APIs that eliminate the overhead for your use case.<p>I&#x27;m curious if there is any fundamental reason why they have to be slower and I suspect the answer is &quot;no&quot;.</div><br/><div id="38995784" class="c"><input type="checkbox" id="c-38995784" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38995377">parent</a><span>|</span><a href="#38995962">next</a><span>|</span><label class="collapse" for="c-38995784">[-]</label><label class="expand" for="c-38995784">[2 more]</label></div><br/><div class="children"><div class="content">Binary translated libriscv vs LuaJIT: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;fwsGonzo&#x2F;9132f0ef7d3f009baa5b222eedf392da" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;fwsGonzo&#x2F;9132f0ef7d3f009baa5b222eedf...</a><p>Interpreted libriscv vs LuaJIT: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;fwsGonzo&#x2F;1af5b2a9b4f38c1f3d3074d78acdf609" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;fwsGonzo&#x2F;1af5b2a9b4f38c1f3d3074d78ac...</a><p>libriscv vs. Luau: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;fwsGonzo&#x2F;5ac8f4d8ca84e97b0c527aec76a86fe9" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;fwsGonzo&#x2F;5ac8f4d8ca84e97b0c527aec76a...</a><p>wasmtime: <a href="https:&#x2F;&#x2F;medium.com&#x2F;@fwsgonzo&#x2F;using-c-as-a-scripting-language-part-10-ad7dd7e4325d" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@fwsgonzo&#x2F;using-c-as-a-scripting-language...</a><p>You&#x27;re probably right that things can be improved. But my implementation has the aforementioned latencies right now.<p>For the benchmarks I did my best writing good Lua, but I am not a pro. Call overhead is also subtracted out of every benchmark after call overhead is measured. So that extra overhead is a permanent feature of these implementations. I also noticed that most of my script functions have at least ~3-4 arguments, which seems like it would be quite costly. Just look at the 8x arg benchmark and divide by 2, I guess. Another 100ns right there. Baseline 150ns on a micro benchmark is going to become at least a microsecond in prod when everything is random and semi-cold.</div><br/><div id="38996065" class="c"><input type="checkbox" id="c-38996065" checked=""/><div class="controls bullet"><span class="by">stefanha</span><span>|</span><a href="#38995377">root</a><span>|</span><a href="#38995784">parent</a><span>|</span><a href="#38995962">next</a><span>|</span><label class="collapse" for="c-38996065">[-]</label><label class="expand" for="c-38996065">[1 more]</label></div><br/><div class="children"><div class="content">Cool, thanks for sharing this information! I&#x27;m not a Lua or wasmtime developer, but I hope to learn from whatever discussion follows.</div><br/></div></div></div></div></div></div><div id="38995962" class="c"><input type="checkbox" id="c-38995962" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#38995377">prev</a><span>|</span><a href="#38996031">next</a><span>|</span><label class="collapse" for="c-38995962">[-]</label><label class="expand" for="c-38995962">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The same is true for WebAssembly emulators that I have measured, eg. wasmtime.<p>Wait, so this claims that it (an interpreter from a cursory akim of the code) is faster than a compiler?</div><br/><div id="38998041" class="c"><input type="checkbox" id="c-38998041" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#38995962">parent</a><span>|</span><a href="#38996031">next</a><span>|</span><label class="collapse" for="c-38998041">[-]</label><label class="expand" for="c-38998041">[1 more]</label></div><br/><div class="children"><div class="content">No, it says that that latency of calling into the VM can be lower in a simple interpreter compared to an optimizing VM (which might need to do things on the call boundary).</div><br/></div></div></div></div><div id="38996031" class="c"><input type="checkbox" id="c-38996031" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#38995962">prev</a><span>|</span><a href="#38993729">next</a><span>|</span><label class="collapse" for="c-38996031">[-]</label><label class="expand" for="c-38996031">[1 more]</label></div><br/><div class="children"><div class="content">License?</div><br/></div></div><div id="38993729" class="c"><input type="checkbox" id="c-38993729" checked=""/><div class="controls bullet"><span class="by">hammyhavoc</span><span>|</span><a href="#38996031">prev</a><span>|</span><a href="#38994006">next</a><span>|</span><label class="collapse" for="c-38993729">[-]</label><label class="expand" for="c-38993729">[3 more]</label></div><br/><div class="children"><div class="content">Genius.</div><br/><div id="38993930" class="c"><input type="checkbox" id="c-38993930" checked=""/><div class="controls bullet"><span class="by">thesnide</span><span>|</span><a href="#38993729">parent</a><span>|</span><a href="#38994006">next</a><span>|</span><label class="collapse" for="c-38993930">[-]</label><label class="expand" for="c-38993930">[2 more]</label></div><br/><div class="children"><div class="content">Yep, I also thought about it to replace wasm to enable secure server side code execution.<p><a href="https:&#x2F;&#x2F;blog.pwkf.org&#x2F;2023&#x2F;07&#x2F;16&#x2F;lambda-mcu.html" rel="nofollow">https:&#x2F;&#x2F;blog.pwkf.org&#x2F;2023&#x2F;07&#x2F;16&#x2F;lambda-mcu.html</a></div><br/><div id="38993977" class="c"><input type="checkbox" id="c-38993977" checked=""/><div class="controls bullet"><span class="by">hammyhavoc</span><span>|</span><a href="#38993729">root</a><span>|</span><a href="#38993930">parent</a><span>|</span><a href="#38994006">next</a><span>|</span><label class="collapse" for="c-38993977">[-]</label><label class="expand" for="c-38993977">[1 more]</label></div><br/><div class="children"><div class="content">This is extremely cool!</div><br/></div></div></div></div></div></div><div id="38994006" class="c"><input type="checkbox" id="c-38994006" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38993729">prev</a><span>|</span><a href="#38994743">next</a><span>|</span><label class="collapse" for="c-38994006">[-]</label><label class="expand" for="c-38994006">[15 more]</label></div><br/><div class="children"><div class="content">When writing a web assembly interpreter I was surprised at how it didn&#x27;t map cleanly to the underlying hardware. The interpreter had to keep track of the types of everything. I can definitely see how a RISC-V based solution would be faster.</div><br/><div id="38994098" class="c"><input type="checkbox" id="c-38994098" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#38994006">parent</a><span>|</span><a href="#38994743">next</a><span>|</span><label class="collapse" for="c-38994098">[-]</label><label class="expand" for="c-38994098">[14 more]</label></div><br/><div class="children"><div class="content">I’m curious what you’re talking about—WASM has different instructions for each of its different types. There are separate instructions for i32, i64, f32, and f64 in the base spec.<p>This seems like a pretty clean map to me—most of the architectures these days have native support for 32-bit and 64-bit types these days. You only get 16-bit and 8-bit support with SIMD or load&#x2F;store, much like how WASM does it.</div><br/><div id="38994141" class="c"><input type="checkbox" id="c-38994141" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994098">parent</a><span>|</span><a href="#38994285">next</a><span>|</span><label class="collapse" for="c-38994141">[-]</label><label class="expand" for="c-38994141">[4 more]</label></div><br/><div class="children"><div class="content">He might be talking about having to implement a register allocator&#x2F;file in order to interpret stack machines faster. Something you get from the compilers on register architectures like RISC-V, ARM and x86.<p>wasmtime uses cranelift, which has a complex register allocator. wasm3 uses a simple register file.<p>&gt; In M3&#x2F;Wasm, the stack machine model is translated into a more direct and efficient &quot;register file&quot; approach.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;wasm3&#x2F;wasm3&#x2F;blob&#x2F;main&#x2F;docs&#x2F;Interpreter.md">https:&#x2F;&#x2F;github.com&#x2F;wasm3&#x2F;wasm3&#x2F;blob&#x2F;main&#x2F;docs&#x2F;Interpreter.md</a></div><br/><div id="38994602" class="c"><input type="checkbox" id="c-38994602" checked=""/><div class="controls bullet"><span class="by">miohtama</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994141">parent</a><span>|</span><a href="#38994285">next</a><span>|</span><label class="collapse" for="c-38994602">[-]</label><label class="expand" for="c-38994602">[3 more]</label></div><br/><div class="children"><div class="content">Because registers on x86 and RISC-V are different, you still need to have a register file to map those, no?</div><br/><div id="38995084" class="c"><input type="checkbox" id="c-38995084" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994602">parent</a><span>|</span><a href="#38994285">next</a><span>|</span><label class="collapse" for="c-38995084">[-]</label><label class="expand" for="c-38995084">[2 more]</label></div><br/><div class="children"><div class="content">Only for binary translation or just-in-time compilation (basically producing native code). If you&#x27;re interpreting RISC-V you can just pretend the registers are an array of register-sized integers. Which is what they are.</div><br/><div id="38995171" class="c"><input type="checkbox" id="c-38995171" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38995084">parent</a><span>|</span><a href="#38994285">next</a><span>|</span><label class="collapse" for="c-38995171">[-]</label><label class="expand" for="c-38995171">[1 more]</label></div><br/><div class="children"><div class="content">&gt;registers are an array of register-sized integers<p>A &quot;register file&quot; is the name of such an array.</div><br/></div></div></div></div></div></div></div></div><div id="38994285" class="c"><input type="checkbox" id="c-38994285" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994098">parent</a><span>|</span><a href="#38994141">prev</a><span>|</span><a href="#38994273">next</a><span>|</span><label class="collapse" for="c-38994285">[-]</label><label class="expand" for="c-38994285">[3 more]</label></div><br/><div class="children"><div class="content">WASM is a stack-machine, so the input code needs to be validated to make sure that the same types gets pop&#x27;ed as has previously been push&#x27;ed. But that can be done ahead of execution.<p>You&#x27;d need to validate function types during runtime though, which is something that a CPU emulator does not need to.</div><br/><div id="38994481" class="c"><input type="checkbox" id="c-38994481" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994285">parent</a><span>|</span><a href="#38995815">next</a><span>|</span><label class="collapse" for="c-38994481">[-]</label><label class="expand" for="c-38994481">[1 more]</label></div><br/><div class="children"><div class="content">WASM is kind of a stack machine, yes, but there are a lot of constraints on the stack machine that are designed to make it easy to translate to registers.<p>If you squint and look sideways, you can think of it as a flattened tree, rather than a stack machine.</div><br/></div></div><div id="38995815" class="c"><input type="checkbox" id="c-38995815" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994285">parent</a><span>|</span><a href="#38994481">prev</a><span>|</span><a href="#38994273">next</a><span>|</span><label class="collapse" for="c-38995815">[-]</label><label class="expand" for="c-38995815">[1 more]</label></div><br/><div class="children"><div class="content">In contrast, RISC-V would be considered a register-based VM here.</div><br/></div></div></div></div><div id="38994273" class="c"><input type="checkbox" id="c-38994273" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994098">parent</a><span>|</span><a href="#38994285">prev</a><span>|</span><a href="#38994370">next</a><span>|</span><label class="collapse" for="c-38994273">[-]</label><label class="expand" for="c-38994273">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with the details, and don&#x27;t have the references to hand, but WASM has been designed in a way that reflects the design choices of Chrome&#x27;s Javascript engine rather than optimizing standalone compilation.</div><br/><div id="38994433" class="c"><input type="checkbox" id="c-38994433" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994273">parent</a><span>|</span><a href="#38996350">next</a><span>|</span><label class="collapse" for="c-38994433">[-]</label><label class="expand" for="c-38994433">[1 more]</label></div><br/><div class="children"><div class="content">Part of optimizing for the design choices of browser engines is to make it easy to emit machine code. The browsers have multiple compilers in them, and one of the compilers has the task of emitting simple machine code quickly, so the code can run immediately (reducing start-up time). In V8, this initial compiler is called <i>Ignition</i>.</div><br/></div></div><div id="38996350" class="c"><input type="checkbox" id="c-38996350" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994273">parent</a><span>|</span><a href="#38994433">prev</a><span>|</span><a href="#38994370">next</a><span>|</span><label class="collapse" for="c-38996350">[-]</label><label class="expand" for="c-38996350">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>WASM has been designed in a way that reflects the design choices of Chrome&#x27;s Javascript engine</i><p>Wasn&#x27;t it based on previous work by the Mozilla team?</div><br/></div></div></div></div><div id="38994370" class="c"><input type="checkbox" id="c-38994370" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994098">parent</a><span>|</span><a href="#38994273">prev</a><span>|</span><a href="#38994743">next</a><span>|</span><label class="collapse" for="c-38994370">[-]</label><label class="expand" for="c-38994370">[3 more]</label></div><br/><div class="children"><div class="content">Take for example i32.add you have to<p>1. Check the type at the top of the stack to make sure it&#x27;s i32 and trap otherwise<p>2. Pop the top of the stack<p>3. Check the top of the stack and make sure it&#x27;s i32 and trap otherwise<p>4. Pop the top of the stack.<p>5. Add the two values together<p>6. Push the result to the top of the stack along with its type.<p>Compare this to ADD from RISC-V where you can just add the contents of 2 source registers and store it in a destination register. There is not a bunch of type book keeping or alignment that you have to worry about.</div><br/><div id="38994463" class="c"><input type="checkbox" id="c-38994463" checked=""/><div class="controls bullet"><span class="by">klodolph</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994370">parent</a><span>|</span><a href="#38994743">next</a><span>|</span><label class="collapse" for="c-38994463">[-]</label><label class="expand" for="c-38994463">[2 more]</label></div><br/><div class="children"><div class="content">Most of this can be done statically. You do the bookkeeping once. There are various approaches—you can try to allocate registers, or you can emit code that loads&#x2F;stores on the stack, or you can just run an interpreter and remove the safety checks from it.<p>The stack isn’t dynamically typed, so it doesn’t make sense to trap.</div><br/><div id="38994740" class="c"><input type="checkbox" id="c-38994740" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38994006">root</a><span>|</span><a href="#38994463">parent</a><span>|</span><a href="#38994743">next</a><span>|</span><label class="collapse" for="c-38994740">[-]</label><label class="expand" for="c-38994740">[1 more]</label></div><br/><div class="children"><div class="content">Looking into it further the type checking is supposed to be done in a dedicated validation step and other than validation using instructions with the wrong type of data seems to work.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38994743" class="c"><input type="checkbox" id="c-38994743" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#38994006">prev</a><span>|</span><a href="#38994582">next</a><span>|</span><label class="collapse" for="c-38994743">[-]</label><label class="expand" for="c-38994743">[2 more]</label></div><br/><div class="children"><div class="content">Funny, I just started (yesterday!!) something similar: a kind of x86_64 (which I call x64) virtual machine for rv64.<p>I am writting this &quot;virtual machine&quot; in x86_64 assembly though (linux ABI). I don&#x27;t plan to have native x86_64 compilation but only an interpreter.<p>This idea is to code rv64 executables(linux) which I could &quot;run-ish&quot; on x86_64(linux).<p>There is also the real machine emulator from M.Bellard : <a href="https:&#x2F;&#x2F;bellard.org&#x2F;tinyemu" rel="nofollow">https:&#x2F;&#x2F;bellard.org&#x2F;tinyemu</a><p>Well, RISC-V is gaining momentum, and transition apparatus from x86_64 is taking shaped from many individuals wishing risc-v to be a success.<p>BTW, if anybody knows about milk-v duo (the one with the SOC free from arm cores) resellers in Europe I can pay without a credit card and I can contact with a self-hosted email... thank you.</div><br/><div id="38995641" class="c"><input type="checkbox" id="c-38995641" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#38994743">parent</a><span>|</span><a href="#38994582">next</a><span>|</span><label class="collapse" for="c-38995641">[-]</label><label class="expand" for="c-38995641">[1 more]</label></div><br/><div class="children"><div class="content">That sounds exciting, please keep us posted.</div><br/></div></div></div></div><div id="38994582" class="c"><input type="checkbox" id="c-38994582" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#38994743">prev</a><span>|</span><label class="collapse" for="c-38994582">[-]</label><label class="expand" for="c-38994582">[3 more]</label></div><br/><div class="children"><div class="content">Long time ago I&#x27;ve used paxCompiler scripting engine. It was made for Delphi &#x2F; FreePascal and supported Delphi input language. Rather than being byte code interpreter &#x2F; JIT it actually generated native code in RAM hence the overhead of calling it was the same as calling regular function. It had lots of other super nice features but that is all in the past anyways.<p>I am curious why such approach is not used for other scripting projects.</div><br/><div id="38996537" class="c"><input type="checkbox" id="c-38996537" checked=""/><div class="controls bullet"><span class="by">SpaghettiCthulu</span><span>|</span><a href="#38994582">parent</a><span>|</span><label class="collapse" for="c-38996537">[-]</label><label class="expand" for="c-38996537">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Rather than being byte code interpreter &#x2F; JIT it actually generated native code in RAM hence the overhead of calling it was the same as calling regular function.<p>I&#x27;m not sure what you mean. What you&#x27;ve just described <i>is</i> a JIT compiler.</div><br/><div id="38997599" class="c"><input type="checkbox" id="c-38997599" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#38994582">root</a><span>|</span><a href="#38996537">parent</a><span>|</span><label class="collapse" for="c-38997599">[-]</label><label class="expand" for="c-38997599">[1 more]</label></div><br/><div class="children"><div class="content">Not in a way V8 does it for example. I would call it AOT (ahead of time). Normally you first compile and initialize scripts and then you can call into their functions and the other way around. But sure you can also compile and execute function in one step so be my guest and call it whatever you want.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>