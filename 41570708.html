<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726650078032" as="style"/><link rel="stylesheet" href="styles.css?v=1726650078032"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.graalvm.org/python/">GraalPy – A high-performance embeddable Python 3 runtime for Java</a> <span class="domain">(<a href="https://www.graalvm.org">www.graalvm.org</a>)</span></div><div class="subtext"><span>fniephaus</span> | <span>122 comments</span></div><br/><div><div id="41573054" class="c"><input type="checkbox" id="c-41573054" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#41576536">next</a><span>|</span><label class="collapse" for="c-41573054">[-]</label><label class="expand" for="c-41573054">[3 more]</label></div><br/><div class="children"><div class="content">In case someone is interested, here are some benchmark results comparing GraalPy and others with JDK8 using the Are-we-fast-yet benchmark suite: <a href="https:&#x2F;&#x2F;stefan-marr.de&#x2F;downloads&#x2F;tmp&#x2F;awfy-bun.html" rel="nofollow">https:&#x2F;&#x2F;stefan-marr.de&#x2F;downloads&#x2F;tmp&#x2F;awfy-bun.html</a><p>And here is a table representation of all benchmarks and the geomean and median overall results: <a href="http:&#x2F;&#x2F;software.rochus-keller.ch&#x2F;awfy-bun-summary.ods" rel="nofollow">http:&#x2F;&#x2F;software.rochus-keller.ch&#x2F;awfy-bun-summary.ods</a><p>The implementation of the same benchmark suite runs around factor 2.4 (geomean) faster on JDK8 than on GraalPython EE 22.3 Hotspot, or 41 times faster than CPython 3.11. GraalPython is thus about 17 times faster than CPython, and about two times faster than PyPy. The Graal Enterprise Edition (EE) seem to be factor 1.31 faster than the Community Edition (CE).</div><br/><div id="41576563" class="c"><input type="checkbox" id="c-41576563" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41573054">parent</a><span>|</span><a href="#41576536">next</a><span>|</span><label class="collapse" for="c-41576563">[-]</label><label class="expand" for="c-41576563">[2 more]</label></div><br/><div class="children"><div class="content">Your mileage may very much vary, much like pypy this is very inconsistent and highly dependent on your workload (as well as your dependencies).<p>My limited experience was that on re-heavy workload pypy is several times slower than cpython (~3x compared to 3.10) and graal is even worse (~6x compared to 3.11).</div><br/><div id="41577113" class="c"><input type="checkbox" id="c-41577113" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41573054">root</a><span>|</span><a href="#41576563">parent</a><span>|</span><a href="#41576536">next</a><span>|</span><label class="collapse" for="c-41577113">[-]</label><label class="expand" for="c-41577113">[1 more]</label></div><br/><div class="children"><div class="content">Which version was that with? GraalVM can JIT compile regular expressions these days, with the same compiler as everything else. They implemented TRegex on top of Truffle so regex can be inlined and optimized like regular code.<p>Performance does indeed depend on workload. There&#x27;s a page that compares GraalPy vs CPython and Jython on the Python Performance Suite which aims to be &quot;real world&quot;:<p><a href="https:&#x2F;&#x2F;www.graalvm.org&#x2F;latest&#x2F;reference-manual&#x2F;python&#x2F;Performance&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.graalvm.org&#x2F;latest&#x2F;reference-manual&#x2F;python&#x2F;Perfo...</a><p>There the speedup is smaller, but this is partly because a lot of real world Python workloads these days spend all their time inside C or the GPU. Having a better implementation is still a good idea though, because it means more stuff can be done by researchers who don&#x27;t know C++ well or at all. The point at which you&#x27;re forced to get dedicated hackers involved to optimize gets pushed backwards if you can rely on a good JIT.</div><br/></div></div></div></div></div></div><div id="41576536" class="c"><input type="checkbox" id="c-41576536" checked=""/><div class="controls bullet"><span class="by">fniephaus</span><span>|</span><a href="#41573054">prev</a><span>|</span><a href="#41576608">next</a><span>|</span><label class="collapse" for="c-41576536">[-]</label><label class="expand" for="c-41576536">[1 more]</label></div><br/><div class="children"><div class="content">OP here.<p>More details about this particular release are in the blog post at <a href="https:&#x2F;&#x2F;medium.com&#x2F;graalvm&#x2F;whats-new-in-graal-languages-24-1-b2452c9debae" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;graalvm&#x2F;whats-new-in-graal-languages-24-1...</a><p>Happy to answer any additional questions!</div><br/></div></div><div id="41576608" class="c"><input type="checkbox" id="c-41576608" checked=""/><div class="controls bullet"><span class="by">jsmeaton</span><span>|</span><a href="#41576536">prev</a><span>|</span><a href="#41571544">next</a><span>|</span><label class="collapse" for="c-41576608">[-]</label><label class="expand" for="c-41576608">[5 more]</label></div><br/><div class="children"><div class="content">Tried to use graalvm (interpreter) to run a fairly large project at my $dayjob$ and ran into a few issues right away.<p><pre><code>  - Maturin doesn&#x27;t support the graal interpreter, so no Py03 packages
  - uv doesn&#x27;t seem to run, as `fork` and `execve` are missing from the os package?
  - Graal seems to have a huge number of patches to popular libraries so that they&#x27;ll run, most seem to be of the form that patch c files to add additional IFDEFs
</code></pre>
I don&#x27;t think Graal is going to be a viable target for large projects with a huge set of dependencies unfortunately, as the risk of not being able to upgrade to different versions or add newer dependencies is going to be too high.<p>It&#x27;s impressive what it does seem to support though, and probably worth looking at if you have a smaller scale project.</div><br/><div id="41577222" class="c"><input type="checkbox" id="c-41577222" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41576608">parent</a><span>|</span><a href="#41577129">next</a><span>|</span><label class="collapse" for="c-41577222">[-]</label><label class="expand" for="c-41577222">[1 more]</label></div><br/><div class="children"><div class="content">The number of patches is going down with time and many are trivial one liners, e.g. uvloop<p><a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython&#x2F;blob&#x2F;b907353de1b72a14ee1c6976c79691b9601c860f&#x2F;graalpython&#x2F;lib-graalpython&#x2F;patches&#x2F;uvloop&#x2F;uvloop.patch">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython&#x2F;blob&#x2F;b907353de1b72a14e...</a><p><pre><code>    -        self.cython_always = False
    +        self.cython_always = True
</code></pre>
That&#x27;s the entire patch. Others are working around bugs in the C extensions themselves that a different implementation happens to expose, and can be upstreamed:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython&#x2F;blob&#x2F;b907353de1b72a14ee1c6976c79691b9601c860f&#x2F;graalpython&#x2F;lib-graalpython&#x2F;patches&#x2F;zstandard&#x2F;zstandard.patch">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython&#x2F;blob&#x2F;b907353de1b72a14e...</a><p>Still others exist for old module versions, but are now obsolete:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython&#x2F;blob&#x2F;b907353de1b72a14ee1c6976c79691b9601c860f&#x2F;graalpython&#x2F;lib-graalpython&#x2F;patches&#x2F;cryptography&#x2F;metadata.toml">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython&#x2F;blob&#x2F;b907353de1b72a14e...</a><p><pre><code>    # None of the patches are needed since 43.0, the pyo3 patches have been upstreamed
</code></pre>
And finally, some are just general portability improvements. Fork doesn&#x27;t exist on Windows. Often it can be replaced with just starting a sub-process.<p>So the patching situation has been getting much better over time, partly due to the GraalPy team actively getting involved with and improving the Python ecosystem as a whole.</div><br/></div></div><div id="41577129" class="c"><input type="checkbox" id="c-41577129" checked=""/><div class="controls bullet"><span class="by">steve_s</span><span>|</span><a href="#41576608">parent</a><span>|</span><a href="#41577222">prev</a><span>|</span><a href="#41576712">next</a><span>|</span><label class="collapse" for="c-41577129">[-]</label><label class="expand" for="c-41577129">[1 more]</label></div><br/><div class="children"><div class="content">There is basic GraalPy support in Maturin[0] and PyO3[1], the problem is often that packages require older Maturin&#x2F;PyO3 versions and&#x2F;or they use CPython-isms, semi-public APIs, etc., but it is getting better, for example [2].<p>It is fair to say that large projects with a huge set of dependencies will likely face some compatibility issues, but we&#x27;re working on ironing this out. There is GraalPy support in setup-python GitHub action. GraalPy is supported in the manylinux image [3]. Hopefully soon also in cibuildwheel [4].<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;maturin&#x2F;pull&#x2F;1645">https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;maturin&#x2F;pull&#x2F;1645</a> (merged)<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;pyo3&#x2F;pull&#x2F;3247">https:&#x2F;&#x2F;github.com&#x2F;PyO3&#x2F;pyo3&#x2F;pull&#x2F;3247</a> (merged)<p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;jiter&#x2F;pull&#x2F;135">https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;jiter&#x2F;pull&#x2F;135</a> (merged)<p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;manylinux&#x2F;pull&#x2F;1520">https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;manylinux&#x2F;pull&#x2F;1520</a> (merged)<p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;cibuildwheel&#x2F;pull&#x2F;1538">https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;cibuildwheel&#x2F;pull&#x2F;1538</a></div><br/></div></div><div id="41576712" class="c"><input type="checkbox" id="c-41576712" checked=""/><div class="controls bullet"><span class="by">nomercy400</span><span>|</span><a href="#41576608">parent</a><span>|</span><a href="#41577129">prev</a><span>|</span><a href="#41576734">next</a><span>|</span><label class="collapse" for="c-41576712">[-]</label><label class="expand" for="c-41576712">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, this also happened when Graal was released for Java. Give it another go in 3-6 months, the Graal team will have improved interoperability massively.<p>It is a chicken (interpreter) and egg (dependencies) problem. You cannot fix the dependency problems without the interpreter. Neither can you release an interpreter with full dependency support.</div><br/></div></div><div id="41576734" class="c"><input type="checkbox" id="c-41576734" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41576608">parent</a><span>|</span><a href="#41576712">prev</a><span>|</span><a href="#41571544">next</a><span>|</span><label class="collapse" for="c-41576734">[-]</label><label class="expand" for="c-41576734">[1 more]</label></div><br/><div class="children"><div class="content">For projects using GraalPy, I&#x27;d wager that most would vendor all their dependencies at the start of the project and upgrade along the way. I have shipped a couple products with Jython, and very little 3rd party code was used and almost none of the standard library, it was all driving Java from the same project.<p>So it does have to do with scale but in the opposite direction. Big long projects will want to adopt something like GraalPy because of how long the project will take.</div><br/></div></div></div></div><div id="41571544" class="c"><input type="checkbox" id="c-41571544" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#41576608">prev</a><span>|</span><a href="#41571220">next</a><span>|</span><label class="collapse" for="c-41571544">[-]</label><label class="expand" for="c-41571544">[35 more]</label></div><br/><div class="children"><div class="content">I guess what makes Python interesting right now is the integration with ML toolchains, CUDA, Metal&#x2F;MLX, pytorch, tensorflow, LLM encoders&#x2F;decoders, etc. more than Python the language. But can GraalVM run those codes meaningfully when Python is merely used for glue code with the important bits implemented in native code?</div><br/><div id="41571660" class="c"><input type="checkbox" id="c-41571660" checked=""/><div class="controls bullet"><span class="by">tln</span><span>|</span><a href="#41571544">parent</a><span>|</span><a href="#41572067">next</a><span>|</span><label class="collapse" for="c-41571660">[-]</label><label class="expand" for="c-41571660">[6 more]</label></div><br/><div class="children"><div class="content">Yes, apparently it can<p><a href="https:&#x2F;&#x2F;www.graalvm.org&#x2F;dev&#x2F;reference-manual&#x2F;python&#x2F;Native-Extensions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.graalvm.org&#x2F;dev&#x2F;reference-manual&#x2F;python&#x2F;Native-E...</a><p>&gt; CPython provides a native extensions API for writing Python extensions in C&#x2F;C++. GraalPy provides experimental support for this API, which allows many packages like NumPy and PyTorch to work well for many use cases. The support extends only to the API, not the binary interface (ABI), so extensions built for CPython are not binary compatible with GraalPy. Packages that use the native API must be built and installed with GraalPy, and the prebuilt wheels for CPython from pypi.org cannot be used. For best results, it is crucial that you only use the pip command that comes preinstalled in GraalPy virtualenvs to install packages. The version of pip shipped with GraalPy applies additional patches to packages upon installation to fix known compatibility issues and it is preconfigured to use an additional repository from graalvm.org where we publish a selection of prebuilt wheels for GraalPy. Please do not update pip or use alternative tools such as uv.</div><br/><div id="41576578" class="c"><input type="checkbox" id="c-41576578" checked=""/><div class="controls bullet"><span class="by">fniephaus</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41571660">parent</a><span>|</span><a href="#41572615">next</a><span>|</span><label class="collapse" for="c-41576578">[-]</label><label class="expand" for="c-41576578">[1 more]</label></div><br/><div class="children"><div class="content">For anyone interested, here&#x27;s the PyPI repository with additional binary wheels for GraalPy:
<a href="https:&#x2F;&#x2F;www.graalvm.org&#x2F;python&#x2F;wheels&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.graalvm.org&#x2F;python&#x2F;wheels&#x2F;</a><p>We also want to make it easy for Python package maintainers to test and build wheels for GraalPy. It&#x27;s already available via setup-python, and we are adding GraalPy support to cibuildwheel. If you need any help, please reach out to us!</div><br/></div></div><div id="41572615" class="c"><input type="checkbox" id="c-41572615" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41571660">parent</a><span>|</span><a href="#41576578">prev</a><span>|</span><a href="#41572067">next</a><span>|</span><label class="collapse" for="c-41572615">[-]</label><label class="expand" for="c-41572615">[4 more]</label></div><br/><div class="children"><div class="content">I wonder if hpy will solve the extension problem.</div><br/><div id="41574349" class="c"><input type="checkbox" id="c-41574349" checked=""/><div class="controls bullet"><span class="by">RMPR</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572615">parent</a><span>|</span><a href="#41577044">next</a><span>|</span><label class="collapse" for="c-41574349">[-]</label><label class="expand" for="c-41574349">[2 more]</label></div><br/><div class="children"><div class="content">While hpy is great and I&#x27;m excited about it, I would rather bet on the limited C API[0] (which is basically what hpy tries to be if I understand correctly).<p>0: <a href="https:&#x2F;&#x2F;devguide.python.org&#x2F;developer-workflow&#x2F;c-api&#x2F;#limited-api" rel="nofollow">https:&#x2F;&#x2F;devguide.python.org&#x2F;developer-workflow&#x2F;c-api&#x2F;#limite...</a></div><br/><div id="41577233" class="c"><input type="checkbox" id="c-41577233" checked=""/><div class="controls bullet"><span class="by">steve_s</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41574349">parent</a><span>|</span><a href="#41577044">next</a><span>|</span><label class="collapse" for="c-41577233">[-]</label><label class="expand" for="c-41577233">[1 more]</label></div><br/><div class="children"><div class="content">Limited C API is not as abstract as HPy. Most notably Limited C API still exposes reference counting as memory management mechanism, HPy abstracts that. However, ecosystem wide adoption of limited C API and stable ABI would already improve things significantly.</div><br/></div></div></div></div><div id="41577044" class="c"><input type="checkbox" id="c-41577044" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572615">parent</a><span>|</span><a href="#41574349">prev</a><span>|</span><a href="#41572067">next</a><span>|</span><label class="collapse" for="c-41577044">[-]</label><label class="expand" for="c-41577044">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s the idea.</div><br/></div></div></div></div></div></div><div id="41572067" class="c"><input type="checkbox" id="c-41572067" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41571544">parent</a><span>|</span><a href="#41571660">prev</a><span>|</span><a href="#41572009">next</a><span>|</span><label class="collapse" for="c-41572067">[-]</label><label class="expand" for="c-41572067">[4 more]</label></div><br/><div class="children"><div class="content">I am willing to live with Python as the Lisp we deserve to have, on this AI wave, when it finally gets a proper JIT story we can rely on, regardless of the workload.<p>Currently it is a mix and match of an herculean engineering effort mostly ignored by the community (PyPy), DSLs for GPGPUs, bunch of C and C++ libraries that people keep referring to as &quot;Python&quot; when any language can have similar bindings, jython, IronPython, GraalPy,...<p>So it isn&#x27;t for lack of trying, at least we finally have CPython folks more welcoming to performance improvements, and JITs.</div><br/><div id="41575763" class="c"><input type="checkbox" id="c-41575763" checked=""/><div class="controls bullet"><span class="by">fastball</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572067">parent</a><span>|</span><a href="#41574364">next</a><span>|</span><label class="collapse" for="c-41575763">[-]</label><label class="expand" for="c-41575763">[2 more]</label></div><br/><div class="children"><div class="content">The problem with PyPy is that it doesn&#x27;t support the C-API, which is required for all those other high performance libraries.<p>So you gain the perf of a JIT, while losing out on most everything else high-performance in the Python ecosystem.</div><br/><div id="41576582" class="c"><input type="checkbox" id="c-41576582" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41575763">parent</a><span>|</span><a href="#41574364">next</a><span>|</span><label class="collapse" for="c-41576582">[-]</label><label class="expand" for="c-41576582">[1 more]</label></div><br/><div class="children"><div class="content">Pypy has cpyext which implements a subset of the C-API, however it comes with a long list of caveats, and is more of a backstop, they very much prefer cffi.</div><br/></div></div></div></div><div id="41574364" class="c"><input type="checkbox" id="c-41574364" checked=""/><div class="controls bullet"><span class="by">RMPR</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572067">parent</a><span>|</span><a href="#41575763">prev</a><span>|</span><a href="#41572009">next</a><span>|</span><label class="collapse" for="c-41574364">[-]</label><label class="expand" for="c-41574364">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am willing to live with Python as the Lisp we deserve to have<p>You can have your cake and eat it too <a href="https:&#x2F;&#x2F;github.com&#x2F;hylang&#x2F;hy">https:&#x2F;&#x2F;github.com&#x2F;hylang&#x2F;hy</a></div><br/></div></div></div></div><div id="41572009" class="c"><input type="checkbox" id="c-41572009" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#41571544">parent</a><span>|</span><a href="#41572067">prev</a><span>|</span><a href="#41571629">next</a><span>|</span><label class="collapse" for="c-41572009">[-]</label><label class="expand" for="c-41572009">[23 more]</label></div><br/><div class="children"><div class="content">The reasons for all this stuff having been developed in Python also make Python interesting right now, all by themselves. It did not happen by accident; this stuff was developed fairly recently and there was no shortage of mature languages to choose from.</div><br/><div id="41572274" class="c"><input type="checkbox" id="c-41572274" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572009">parent</a><span>|</span><a href="#41572648">next</a><span>|</span><label class="collapse" for="c-41572274">[-]</label><label class="expand" for="c-41572274">[4 more]</label></div><br/><div class="children"><div class="content">The people disliking the language are very vocal about it, but there is a huge amount of silent people that loves it and an even bigger amount that just like it as much as alternatives. It&#x27;s mainstream now, not trending like 10 years ago, so there is no hype about it anymore. We just use it to do stuff.<p>Add to that the existing excellent ecosystem, the strong culture of scientific stacks and a very good story for providing c-extentions (actually the best one in all scripting languages because of things like cibuildwheel).<p>It&#x27;s only in small tech bubbles like HN that devs find it surprising.</div><br/><div id="41576450" class="c"><input type="checkbox" id="c-41576450" checked=""/><div class="controls bullet"><span class="by">pm90</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572274">parent</a><span>|</span><a href="#41575989">next</a><span>|</span><label class="collapse" for="c-41576450">[-]</label><label class="expand" for="c-41576450">[1 more]</label></div><br/><div class="children"><div class="content">Python has many issues that are quite clear when you operate at some kind of scale and need proper multiprocessing&#x2F;multithreading support. And its not just the GIL, you get very unexpected behaviors when dealing with exit handlers and signal handlers in edge cases. Having seen what other languages look like it just doesn’t feel like a language that was designed well for running at scale.<p>The tooling has markedly improved though. Things like typing and compile time checks, great. But its also funny to me that some of the fastest tools for python are being built in rust (eg uv).</div><br/></div></div><div id="41575989" class="c"><input type="checkbox" id="c-41575989" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572274">parent</a><span>|</span><a href="#41576450">prev</a><span>|</span><a href="#41574193">next</a><span>|</span><label class="collapse" for="c-41575989">[-]</label><label class="expand" for="c-41575989">[1 more]</label></div><br/><div class="children"><div class="content">I’ve always found Python to be sort of loved on HN. Not by everyone or course but I guess it depends on each of our experiences on here. I’m usually rather surprised when I meet people who genuinely dislike Python, because that seems like such an odd occurrence. Even if people don’t “love” the language most people seem to have had rather fond experiences or memories of it. Usually criticism comes down to its inefficiencies, but those aren’t exactly unreasonable critiques.<p>As I said it’s anecdotal, but in my experience Python gets a lot of love compared to something like Java or C#. Both of which are often met with real harshness. Hell I’ve ranted unseemly about C# myself.</div><br/></div></div><div id="41574193" class="c"><input type="checkbox" id="c-41574193" checked=""/><div class="controls bullet"><span class="by">lordgroff</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572274">parent</a><span>|</span><a href="#41575989">prev</a><span>|</span><a href="#41572648">next</a><span>|</span><label class="collapse" for="c-41574193">[-]</label><label class="expand" for="c-41574193">[1 more]</label></div><br/><div class="children"><div class="content">I mean, even on HN, I&#x27;d say if there&#x27;s derision, it&#x27;s mostly one uttered with a yawn rather than genuine hate. And that&#x27;s almost justified; while I spend a lot of my time with lots of different languages (I can&#x27;t think of a single one I outright hate btw), Python is the one that pays for my things and... Well, there&#x27;s not much drama there is there (now that we&#x27;re lost 2-&gt;3 anyway)? It&#x27;s a glue language that&#x27;s easy to learn, but offers tons of depth should you want it. My primary annoyance at Python used to be the typing, but type annotations have made this less of an issue. It&#x27;s a nice language and you can do almost everything with it. It&#x27;s a bit boring, but I guess that&#x27;s a good thing.</div><br/></div></div></div></div><div id="41572648" class="c"><input type="checkbox" id="c-41572648" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572009">parent</a><span>|</span><a href="#41572274">prev</a><span>|</span><a href="#41572116">next</a><span>|</span><label class="collapse" for="c-41572648">[-]</label><label class="expand" for="c-41572648">[16 more]</label></div><br/><div class="children"><div class="content">As a former Perl hacker who started using Python in 2005, I saw Python ride several waves. (Numerical computation, data science, deep learning)<p>Perl was the leading tool for scripting and text parsing. Python didn’t really supplant it for a long time — until people started writing more complicated scripts that had to be maintained. Perl reads like line noise after 6 months whereas I can look at Python code from 20 years ago, prettify it with black, and understand it.<p>Python got picked up by the scientific computing community, which gave it some its earliest libraries like numpy, f2py, scipy. Some of us who were on MATLAB moved over.<p>Then data science happened. Pandas built off the scientific computation foundations and eventually libraries like scikit and matplotlib (mimicking matlab’s plotting) came along.<p>Then tensorflow came along and built on the foundation of numerical libraries. PyTorch followed.<p>Other systems like Django came and made python popular for building database backed websites.<p>Suddenly there was momentum and today almost all numerical software have a python API — this includes proprietary stuff like CPLEX and what have you.<p>Python was the glue language that had the lowest barrier of entry. For instance, Spark was written in Scala and has a performant Scala API but everyone uses PySpark because it’s much more accessible, despite the interop cost.<p>The counterfactual to all this was Ruby. It had much nicer syntax than Python but when I tried to use it in grad school I was quickly stymied by the lack of numerical libraries. Ruby never found a niche outside of Rails and config management.<p>Essentially Python — like Nvidia today — bet on linear algebra (and more broadly on data processing) and won.<p>I get why there’s hate for Python — it’s not a perfect language. Yet those of us pragmatists who use it understand the trade offs. You trade off on the metal performance for programmer performance. You trade off packaging difficulties for something that works. You trade off an imperfect syntax for getting things done.<p>I could have used Ruby — a much more beautiful lanaguage — in grad school and worked around its lacks, but I would have not graduated on time. Python was pragmatic choice for me and continues to be one for me today (outside of situations requiring raw performance)</div><br/><div id="41573567" class="c"><input type="checkbox" id="c-41573567" checked=""/><div class="controls bullet"><span class="by">commodoreboxer</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572648">parent</a><span>|</span><a href="#41573475">next</a><span>|</span><label class="collapse" for="c-41573567">[-]</label><label class="expand" for="c-41573567">[12 more]</label></div><br/><div class="children"><div class="content">I agree with you, and I&#x27;ll put it slightly stronger. Ruby is a better language than Python in every way except the very most important two:<p>- Imports in Ruby seriously suck compared to Python. Everything requires into a global scope and an ecosystem like bundler which encourages centralizing all imports for your entire codebase into one file.<p>- Python has docstrings encouraging in code documentation.<p>Add common ecosystem things like the Ruby community encouraging generated methods, magical &quot;do what I mean&quot; parameters, and REPL poke-driven development, and this leads to the effect that Python codebases are almost always well documented and easy to understand. You can tell where every symbol comes from, and you can usually find a documentation entry for every single method.  It&#x27;s not uncommon for a Ruby library, even a popular one, to be documented solely through a scattering of sparsely-explained examples with literally no real API documentation. Inheriting a long-lived Ruby project can be a serious ordeal just to discover where all the code that&#x27;s running is running, why it&#x27;s running, where things are preloaded into a builtin class, and with Rails and Railties, a Gem can auto insert behavior and Middleware just by existing, without ever being explicitly mentioned in any code or configs other than the Gemfile. It&#x27;s an absolute headache.<p>My dream language would be Ruby with Python-style imports and docstrings.</div><br/><div id="41574301" class="c"><input type="checkbox" id="c-41574301" checked=""/><div class="controls bullet"><span class="by">Myrmornis</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41573567">parent</a><span>|</span><a href="#41574666">next</a><span>|</span><label class="collapse" for="c-41574301">[-]</label><label class="expand" for="c-41574301">[6 more]</label></div><br/><div class="children"><div class="content">I think your comment needs to mention that Python has syntax for type annotations and two mature type checkers (mypy and pyright) with more under development. Python  is thus very much part of the modern statically typed languages scene (moreso than Go) whereas Ruby isn&#x27;t at all. Many people wouldn&#x27;t touch Python today if it weren&#x27;t for this.</div><br/><div id="41574904" class="c"><input type="checkbox" id="c-41574904" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41574301">parent</a><span>|</span><a href="#41574859">next</a><span>|</span><label class="collapse" for="c-41574904">[-]</label><label class="expand" for="c-41574904">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Python is thus very much part of the modern statically typed languages scene (moreso than Go)</i><p>Python’s type system is substantially more complex than Go’s - it’s probably more <i>complete</i>, but given it’s optional nature, less <i>sound</i>.<p>In “modern” type systems, is completeness considered more important than soundness? The success of TypeScript suggests it is.</div><br/><div id="41575975" class="c"><input type="checkbox" id="c-41575975" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41574904">parent</a><span>|</span><a href="#41574859">next</a><span>|</span><label class="collapse" for="c-41575975">[-]</label><label class="expand" for="c-41575975">[1 more]</label></div><br/><div class="children"><div class="content">Since basically every single type system has escape hatches (casts), yes, I would say completeness is more important than soundness.</div><br/></div></div></div></div><div id="41574859" class="c"><input type="checkbox" id="c-41574859" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41574301">parent</a><span>|</span><a href="#41574904">prev</a><span>|</span><a href="#41574384">next</a><span>|</span><label class="collapse" for="c-41574859">[-]</label><label class="expand" for="c-41574859">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>two mature type checkers</i><p>I’ve never quite understood how this works. Surely a type system is absolutely fundamental to a language - how can you have multiple incompatible ones?<p>Do you need to choose a particular type checker for each project? Are you limited to only using third-party libraries that use the same type checker?</div><br/><div id="41576354" class="c"><input type="checkbox" id="c-41576354" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41574859">parent</a><span>|</span><a href="#41574384">next</a><span>|</span><label class="collapse" for="c-41576354">[-]</label><label class="expand" for="c-41576354">[1 more]</label></div><br/><div class="children"><div class="content">Look at JavaScript and typescript - Python’s typing is maybe halfway to that gold standard but there were other typed languages based on js. Python is special in that it provides type hinting syntax which is not used by the interpreter, so writing types doesn’t require the Byzantine build systems of js.</div><br/></div></div></div></div><div id="41574384" class="c"><input type="checkbox" id="c-41574384" checked=""/><div class="controls bullet"><span class="by">RMPR</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41574301">parent</a><span>|</span><a href="#41574859">prev</a><span>|</span><a href="#41574666">next</a><span>|</span><label class="collapse" for="c-41574384">[-]</label><label class="expand" for="c-41574384">[1 more]</label></div><br/><div class="children"><div class="content">&gt; syntax for type annotations and two mature type checkers (mypy and pyright)<p>I would throw Pyre in there too</div><br/></div></div></div></div><div id="41574666" class="c"><input type="checkbox" id="c-41574666" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41573567">parent</a><span>|</span><a href="#41574301">prev</a><span>|</span><a href="#41574463">next</a><span>|</span><label class="collapse" for="c-41574666">[-]</label><label class="expand" for="c-41574666">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a shame Python has a strong anti-FP stance with crippled lambdas. And an OO system that looks like it has been bolted in, compared to Ruby which is essentially a Smalltalk with Perl-like syntax and some Lisp influence.<p>These two issues would have been quite easy to fix and would have led to a completely different development experience. Python had a good implementation with a nice C FFI (CPython) right from the beginning, whereas Ruby MRI had lots of efficiency issues with long-running computations. IMHO this is one of the reasons why Python won. Building a numerics stack on top of MRI did not look very promising.</div><br/><div id="41574841" class="c"><input type="checkbox" id="c-41574841" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41574666">parent</a><span>|</span><a href="#41574463">next</a><span>|</span><label class="collapse" for="c-41574841">[-]</label><label class="expand" for="c-41574841">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>an OO system that looks like it has been bolted in, compared to Ruby</i><p>I think the two languages just have different design philosophies. In Python, functions are fundamental and classes are built on top of them. In Ruby, objects are fundamental and functions (i.e. Procs etc) are themselves objects.<p>You could just as well claim that in Ruby, functions look like they have been bolted in. For example, you can’t call a Proc itself but need to call one of its methods.</div><br/><div id="41575294" class="c"><input type="checkbox" id="c-41575294" checked=""/><div class="controls bullet"><span class="by">maple3142</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41574841">parent</a><span>|</span><a href="#41574463">next</a><span>|</span><label class="collapse" for="c-41575294">[-]</label><label class="expand" for="c-41575294">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Python&#x27;s functions are just objects with a __call__ method, and such objects has a syntax sugar allowed them to be called like a function.</div><br/><div id="41576359" class="c"><input type="checkbox" id="c-41576359" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41575294">parent</a><span>|</span><a href="#41574463">next</a><span>|</span><label class="collapse" for="c-41576359">[-]</label><label class="expand" for="c-41576359">[1 more]</label></div><br/><div class="children"><div class="content">Functions are objects are functions are objects… heard that from a little schemer</div><br/></div></div></div></div></div></div></div></div><div id="41574463" class="c"><input type="checkbox" id="c-41574463" checked=""/><div class="controls bullet"><span class="by">antod</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41573567">parent</a><span>|</span><a href="#41574666">prev</a><span>|</span><a href="#41573475">next</a><span>|</span><label class="collapse" for="c-41574463">[-]</label><label class="expand" for="c-41574463">[1 more]</label></div><br/><div class="children"><div class="content">Hard agree on the global Ruby import issues. I remember inspecting large custom Rails or Capistrano codebases in pry and having thousands of names imported. That and monkey patching had me wishing for Python with imports only having module scope and being a lot more explicit.</div><br/></div></div></div></div><div id="41573475" class="c"><input type="checkbox" id="c-41573475" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572648">parent</a><span>|</span><a href="#41573567">prev</a><span>|</span><a href="#41575454">next</a><span>|</span><label class="collapse" for="c-41573475">[-]</label><label class="expand" for="c-41573475">[2 more]</label></div><br/><div class="children"><div class="content">There was also the major anti-wave of Python 3. But it has managed to pull through despite ending up with broken strings (RIP all old code that needs to deal with legacy-encoded data), probably because there was no viable replacement.</div><br/><div id="41573919" class="c"><input type="checkbox" id="c-41573919" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41573475">parent</a><span>|</span><a href="#41575454">next</a><span>|</span><label class="collapse" for="c-41573919">[-]</label><label class="expand" for="c-41573919">[1 more]</label></div><br/><div class="children"><div class="content">Python 3 was a painful episode and I lingered on 2.7 and only ported over around 3.6.<p>But now 3.11 is fine again. Looking forward to faster releases.</div><br/></div></div></div></div><div id="41575454" class="c"><input type="checkbox" id="c-41575454" checked=""/><div class="controls bullet"><span class="by">kfrzcode</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572648">parent</a><span>|</span><a href="#41573475">prev</a><span>|</span><a href="#41572116">next</a><span>|</span><label class="collapse" for="c-41575454">[-]</label><label class="expand" for="c-41575454">[1 more]</label></div><br/><div class="children"><div class="content">Pragmatic use of $LANGUAGE is a telltale sign of the wizened programmer; one who understands the use-case and solution set well enough to know when the tool fits.<p>I wrote Ruby when I got started because it was the most accessible and the Rails learning content was top notch. Now I use python when I need more than a few `bash` pipes to accomplish anything, but if I were to solve a capital-P Problem, of course the tool often chooses the project after constraints.</div><br/></div></div></div></div><div id="41572116" class="c"><input type="checkbox" id="c-41572116" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572009">parent</a><span>|</span><a href="#41572648">prev</a><span>|</span><a href="#41572618">next</a><span>|</span><label class="collapse" for="c-41572116">[-]</label><label class="expand" for="c-41572116">[1 more]</label></div><br/><div class="children"><div class="content">Using Python as C and C++ REPL of sorts has been common in academia since it took the scripting crown away from Perl and Tcl, which were used during the late 90&#x27;s.<p>Example see the Bioinformatics papers from that period, and the Perl tooling used alongside the research.<p>Already in 2003 CERN was using Python on some of their build infrastructure (see CMT), Grid Computing scripting efforts, and we had Python trainings available to us.<p>Now there is a difference between a REPL of sorts, scripting OS tasks, and going full blown applications with a pure interpreter.</div><br/></div></div><div id="41572618" class="c"><input type="checkbox" id="c-41572618" checked=""/><div class="controls bullet"><span class="by">Eridrus</span><span>|</span><a href="#41571544">root</a><span>|</span><a href="#41572009">parent</a><span>|</span><a href="#41572116">prev</a><span>|</span><a href="#41571629">next</a><span>|</span><label class="collapse" for="c-41572618">[-]</label><label class="expand" for="c-41572618">[1 more]</label></div><br/><div class="children"><div class="content">It didn&#x27;t happen by total accident, but it didn&#x27;t happen by design for where we are today either. The original choice to start building data science tooling in Python happened intentionally, but since then path dependence has been a huge thing.</div><br/></div></div></div></div><div id="41571629" class="c"><input type="checkbox" id="c-41571629" checked=""/><div class="controls bullet"><span class="by">waldrews</span><span>|</span><a href="#41571544">parent</a><span>|</span><a href="#41572009">prev</a><span>|</span><a href="#41571220">next</a><span>|</span><label class="collapse" for="c-41571629">[-]</label><label class="expand" for="c-41571629">[1 more]</label></div><br/><div class="children"><div class="content">Looks like all of that would run in a native sandbox environment which in turn is called from the Python running on the JVM.  So, maybe it simplifies interop, but whether it&#x27;s straightforward to get full performance from the native layer (especially GPU&#x2F;multicore) is an open question.</div><br/></div></div></div></div><div id="41571220" class="c"><input type="checkbox" id="c-41571220" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#41571544">prev</a><span>|</span><a href="#41571064">next</a><span>|</span><label class="collapse" for="c-41571220">[-]</label><label class="expand" for="c-41571220">[4 more]</label></div><br/><div class="children"><div class="content">DuckDB is not currently a supported package, but Pandas and matplotlib are which is good. If DuckDB and Polars were supported and if they ran well, I suspect many data jobs could benefit.</div><br/><div id="41573822" class="c"><input type="checkbox" id="c-41573822" checked=""/><div class="controls bullet"><span class="by">rsyring</span><span>|</span><a href="#41571220">parent</a><span>|</span><a href="#41571064">next</a><span>|</span><label class="collapse" for="c-41573822">[-]</label><label class="expand" for="c-41573822">[3 more]</label></div><br/><div class="children"><div class="content">Why would they benefit?  When duckdb&#x2F;Polaris are being used correctly, all the work is happening in the native stack.  It should already be very fast compared to the Python runtime.<p>I recently moved a large ETL process that was mostly Python runtime processing to pyarrow&#x2F;Polaris and wrote all the ETL logic in SQL.  I&#x27;ve seen processes that used to take a week to run drop to about an hour (no exaggeration).</div><br/><div id="41573899" class="c"><input type="checkbox" id="c-41573899" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#41571220">root</a><span>|</span><a href="#41573822">parent</a><span>|</span><a href="#41571064">next</a><span>|</span><label class="collapse" for="c-41573899">[-]</label><label class="expand" for="c-41573899">[2 more]</label></div><br/><div class="children"><div class="content">They wouldn’t benefit from performance because as you say they are already blazing fast as is. And I know what you mean — I rewrote a pure (granted old pre-2.0) pandas transformation into duckdb and compute time dropped from nearly an hour to single digit minutes.<p>But having these in Graal would allow more types of applications to be deployed in JVM stacks. As sibling comments note, many data science models are in python but production stacks are in Java.</div><br/><div id="41574096" class="c"><input type="checkbox" id="c-41574096" checked=""/><div class="controls bullet"><span class="by">rsyring</span><span>|</span><a href="#41571220">root</a><span>|</span><a href="#41573899">parent</a><span>|</span><a href="#41571064">next</a><span>|</span><label class="collapse" for="c-41574096">[-]</label><label class="expand" for="c-41574096">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But having them this would allow more types of applications to be deployed in JVM stack...<p>Ah...makes sense now.  I was thinking along the lines of someone switching to the JVM for better performance, but being held back by the absence of those libraries.</div><br/></div></div></div></div></div></div></div></div><div id="41571064" class="c"><input type="checkbox" id="c-41571064" checked=""/><div class="controls bullet"><span class="by">sevensor</span><span>|</span><a href="#41571220">prev</a><span>|</span><a href="#41573105">next</a><span>|</span><label class="collapse" for="c-41571064">[-]</label><label class="expand" for="c-41571064">[13 more]</label></div><br/><div class="children"><div class="content">Took a little digging to find that it targets 3.11. Didn’t see anything about a GIL. If you’re a Python person, don’t click the quick start link unless you want to look at some xml.</div><br/><div id="41571197" class="c"><input type="checkbox" id="c-41571197" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41571064">parent</a><span>|</span><a href="#41571339">next</a><span>|</span><label class="collapse" for="c-41571197">[-]</label><label class="expand" for="c-41571197">[9 more]</label></div><br/><div class="children"><div class="content">Python implementations naturally don&#x27;t have any GIL in regards to JVM or CLR variants, there is no such thing on those platforms.<p>YAML and JSON have both tried to replicate the XML tooling experience, only worse.<p>Schemas, comments, parsing and schema conversions tools.</div><br/><div id="41571442" class="c"><input type="checkbox" id="c-41571442" checked=""/><div class="controls bullet"><span class="by">lopuhin</span><span>|</span><a href="#41571064">root</a><span>|</span><a href="#41571197">parent</a><span>|</span><a href="#41571339">next</a><span>|</span><label class="collapse" for="c-41571442">[-]</label><label class="expand" for="c-41571442">[8 more]</label></div><br/><div class="children"><div class="content">I think GraalPython does have a GIL, see <a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython&#x2F;blob&#x2F;master&#x2F;docs&#x2F;contributor&#x2F;IMPLEMENTATION_DETAILS.md#the-gil">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython&#x2F;blob&#x2F;master&#x2F;docs&#x2F;contr...</a> - and if by &quot;there is no such thing on those platforms&quot; you mean JVM&#x2F;CLR not having a GIL, C also does not have a GIL but CPython does.</div><br/><div id="41571956" class="c"><input type="checkbox" id="c-41571956" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41571064">root</a><span>|</span><a href="#41571442">parent</a><span>|</span><a href="#41571622">next</a><span>|</span><label class="collapse" for="c-41571956">[-]</label><label class="expand" for="c-41571956">[2 more]</label></div><br/><div class="children"><div class="content">My mistake, as I assumed they took the same decision as jython and IronPython.<p><a href="https:&#x2F;&#x2F;jython.readthedocs.io&#x2F;en&#x2F;latest&#x2F;Concurrency&#x2F;#no-global-interpreter-lock" rel="nofollow">https:&#x2F;&#x2F;jython.readthedocs.io&#x2F;en&#x2F;latest&#x2F;Concurrency&#x2F;#no-glob...</a><p><a href="https:&#x2F;&#x2F;wiki.python.org&#x2F;moin&#x2F;IronPython" rel="nofollow">https:&#x2F;&#x2F;wiki.python.org&#x2F;moin&#x2F;IronPython</a><p>The difference between JVM, CLR and C in regards to parallel and concurrent code is that they are built for those kind of workloads, and have a memory model proper, hence not needing a GIL.</div><br/><div id="41573468" class="c"><input type="checkbox" id="c-41573468" checked=""/><div class="controls bullet"><span class="by">commodoreboxer</span><span>|</span><a href="#41571064">root</a><span>|</span><a href="#41571956">parent</a><span>|</span><a href="#41571622">next</a><span>|</span><label class="collapse" for="c-41573468">[-]</label><label class="expand" for="c-41573468">[1 more]</label></div><br/><div class="children"><div class="content">I think they would have to here, to support native modules. Jython (and I believe IronPython, but don&#x27;t quote me) does not support native CPython modules. CPython modules explicitly control the GIL, so if they are supported (as they are here), you can&#x27;t really leave the GIL out without exposing potential thread safety issues.</div><br/></div></div></div></div><div id="41571622" class="c"><input type="checkbox" id="c-41571622" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41571064">root</a><span>|</span><a href="#41571442">parent</a><span>|</span><a href="#41571956">prev</a><span>|</span><a href="#41571339">next</a><span>|</span><label class="collapse" for="c-41571622">[-]</label><label class="expand" for="c-41571622">[5 more]</label></div><br/><div class="children"><div class="content">&quot;PEP 703 – Making the Global Interpreter Lock Optional in CPython&quot; (2023) <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;</a><p>CPython built with --disable-gil does not have a GIL (as long as PYTHONGIL=0 and all loaded C extensions are built for --disable-gil mode)
<a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#py-mod-gil-slot" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#py-mod-gil-slot</a><p>&quot;Intent to approve PEP 703: making the GIL optional&quot; (2023) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36913328#36917709">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36913328#36917709</a> <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36913328#36921625">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36913328#36921625</a></div><br/><div id="41571669" class="c"><input type="checkbox" id="c-41571669" checked=""/><div class="controls bullet"><span class="by">kaashif</span><span>|</span><a href="#41571064">root</a><span>|</span><a href="#41571622">parent</a><span>|</span><a href="#41571339">next</a><span>|</span><label class="collapse" for="c-41571669">[-]</label><label class="expand" for="c-41571669">[4 more]</label></div><br/><div class="children"><div class="content">This is pretty beside the point. The point is that X not having a GIL doesn&#x27;t inherently mean Python on X also doesn&#x27;t have a GIL.</div><br/><div id="41574092" class="c"><input type="checkbox" id="c-41574092" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41571064">root</a><span>|</span><a href="#41571669">parent</a><span>|</span><a href="#41571339">next</a><span>|</span><label class="collapse" for="c-41574092">[-]</label><label class="expand" for="c-41574092">[3 more]</label></div><br/><div class="children"><div class="content">CPython does not have a GIL Global Interpreter Lock GC Garbage Collection phase with --gil-disabled. GraalVM does have a GIL, like CPython without --gil-disabled.<p>How CPython accomplished nogil in their - the original and reference -  fork is described in the topical linked PEP 703.</div><br/><div id="41574282" class="c"><input type="checkbox" id="c-41574282" checked=""/><div class="controls bullet"><span class="by">kaashif</span><span>|</span><a href="#41571064">root</a><span>|</span><a href="#41574092">parent</a><span>|</span><a href="#41571339">next</a><span>|</span><label class="collapse" for="c-41574282">[-]</label><label class="expand" for="c-41574282">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I know. What I&#x27;m saying is that:<p>It&#x27;s possible to have a language that doesn&#x27;t have a GIL, which you implement Python in, but that Python implementation then has a GIL.<p>The point being that you can&#x27;t say things like: Jython is written in Java so it doesn&#x27;t have a GIL. CPython is written in C so doesn&#x27;t have a GIL. And so on.<p>If this isn&#x27;t clear, I apologize.</div><br/><div id="41574375" class="c"><input type="checkbox" id="c-41574375" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41571064">root</a><span>|</span><a href="#41574282">parent</a><span>|</span><a href="#41571339">next</a><span>|</span><label class="collapse" for="c-41574375">[-]</label><label class="expand" for="c-41574375">[1 more]</label></div><br/><div class="children"><div class="content">Oh okay. Yeah I would say that the Java GC and the ported CPython GIL are probably limits to the performance of any Python in Java implementation.<p>But are there even nogil builds of CPython C extensions on PyPi yet anyway.<p>Re: Ghidraal and various methods of Python in Java: 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36454485">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36454485</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41571339" class="c"><input type="checkbox" id="c-41571339" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41571064">parent</a><span>|</span><a href="#41571197">prev</a><span>|</span><a href="#41571244">next</a><span>|</span><label class="collapse" for="c-41571339">[-]</label><label class="expand" for="c-41571339">[1 more]</label></div><br/><div class="children"><div class="content">Happily, you can ignore the Maven XML and use Gradle instead, it&#x27;s the next codeblock on the page, after &quot;or&quot;:<p><pre><code>    implementation(&quot;org.graalvm.polyglot:polyglot:24.1.0&quot;)
    implementation(&quot;org.graalvm.polyglot:python:24.1.0&quot;)</code></pre></div><br/></div></div><div id="41571244" class="c"><input type="checkbox" id="c-41571244" checked=""/><div class="controls bullet"><span class="by">foobazgt</span><span>|</span><a href="#41571064">parent</a><span>|</span><a href="#41571339">prev</a><span>|</span><a href="#41571463">next</a><span>|</span><label class="collapse" for="c-41571244">[-]</label><label class="expand" for="c-41571244">[1 more]</label></div><br/><div class="children"><div class="content">I mean, if you&#x27;re trying to embed one language in another, please don&#x27;t be surprised when the quickstart guide has a couple of examples containing a few lines of code written for the embedding language and its package manager(s).</div><br/></div></div></div></div><div id="41573105" class="c"><input type="checkbox" id="c-41573105" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#41571064">prev</a><span>|</span><a href="#41571707">next</a><span>|</span><label class="collapse" for="c-41573105">[-]</label><label class="expand" for="c-41573105">[6 more]</label></div><br/><div class="children"><div class="content">FWIW we&#x27;ve had full Java&#x2F;Python integration in Clojure for awhile now, courtesy of Chris Neurnberger and libpython-clj: <a href="https:&#x2F;&#x2F;github.com&#x2F;clj-python&#x2F;libpython-clj">https:&#x2F;&#x2F;github.com&#x2F;clj-python&#x2F;libpython-clj</a><p>If you&#x27;re into that sort of thing.<p>Self-interest disclosure: I&#x27;m a major contributor and heavy user.</div><br/><div id="41573422" class="c"><input type="checkbox" id="c-41573422" checked=""/><div class="controls bullet"><span class="by">waldrews</span><span>|</span><a href="#41573105">parent</a><span>|</span><a href="#41571707">next</a><span>|</span><label class="collapse" for="c-41573422">[-]</label><label class="expand" for="c-41573422">[5 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the GIL&#x2F;threading story there?</div><br/><div id="41573979" class="c"><input type="checkbox" id="c-41573979" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#41573105">root</a><span>|</span><a href="#41573422">parent</a><span>|</span><a href="#41571707">next</a><span>|</span><label class="collapse" for="c-41573979">[-]</label><label class="expand" for="c-41573979">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m assuming you mean &quot;how well does JVM concurrency play with Python concurrency&quot;?  Python concurrency works perfectly well on its own, Java&#x2F;Clojure concurrency works very well on its own, trying to pass multithreaded information across the JVM boundary to Python while bypassing the GIL will result in a segfault (Edit: but there are &quot;with-gil&quot; wrappers you can use to prevent that, at a slight performance hit).  In practice this tends not to be much of a problem as you setup a parallel workload on one side of the boundary or the other and pass information with a threadsafe queue.  We do plenty of heavy parallel computations, data science, AI, fintech, etc.<p>There are certainly some leaky abstractions and there is a general expectation that you understand the quirks of Python and Clojure pretty well, so it&#x27;s not for everyone. Knowing something about Java would probably help too but I&#x27;ve been using libpython-clj in production since 2017 years and I barely know anything about Java (compared to Python&#x2F;Clojure).</div><br/><div id="41574048" class="c"><input type="checkbox" id="c-41574048" checked=""/><div class="controls bullet"><span class="by">malux85</span><span>|</span><a href="#41573105">root</a><span>|</span><a href="#41573979">parent</a><span>|</span><a href="#41571707">next</a><span>|</span><label class="collapse" for="c-41574048">[-]</label><label class="expand" for="c-41574048">[3 more]</label></div><br/><div class="children"><div class="content">This is pretty interesting, what&#x27;s the benefit over using python so directly with java? I mean, is the overhead of having these as seperate services &#x2F; processes too much? I&#x27;m not trying to provoke I&#x27;m genuinely curious about the use case.<p>Also, what&#x27;s the dev workflow like? When I&#x27;m coding python I basically live inside the debugger (a.k.a the carmark method), do you use an IDE that understands both java and python? Whats the debugging experience like? Can you set a breakpoint and then evaluate python code and expressions inside the debugger like you can if it was just solely a python project using VSCode and the python debugger?</div><br/><div id="41574906" class="c"><input type="checkbox" id="c-41574906" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#41573105">root</a><span>|</span><a href="#41574048">parent</a><span>|</span><a href="#41574879">next</a><span>|</span><label class="collapse" for="c-41574906">[-]</label><label class="expand" for="c-41574906">[1 more]</label></div><br/><div class="children"><div class="content">Oh sorry there are actually huge performance benefits over a services based approach, because you&#x27;re using the same memory space instead of serializing.  This is particularly enormous for ML and data science space because of the work Chris did on hyper efficient mapping zero copy mapping of numpy arrays to tech.ml.dataset tensors.<p>Not even GraalVM has that! Not yet, anyway.<p>So there&#x27;s a lot of easy perfomance synergies over microservices, but I&#x27;m the kind of dev where I tend to prioritize fun over performance as long as it&#x27;s &quot;performant enough&quot;. Fortunately, Chris (author of libpython-clj) is an ex-Nvidia performance obsessed dev though so the performance there is on point.</div><br/></div></div><div id="41574879" class="c"><input type="checkbox" id="c-41574879" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#41573105">root</a><span>|</span><a href="#41574048">parent</a><span>|</span><a href="#41574906">prev</a><span>|</span><a href="#41571707">next</a><span>|</span><label class="collapse" for="c-41574879">[-]</label><label class="expand" for="c-41574879">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a really interesting line of questioning!  We have a mode called &quot;embedded mode&quot; where you run the <i>python</i> application first, THEN initialize the JVM and Clojure via the Python &quot;javabridge&quot; package.  From there, you can start your Clojure REPL and experience both Clojure&#x27;s IDE integrated REPL experience or the Python debugger, depending on how you set it up.  This also allows you to run maximally complex Python applications and is the recommended approach for training ML robustly.<p>I also tend to live inside the debugger for <i>some</i> things but for other things I really enjoy the Clojure&#x2F;lisp style &quot;in editor evaluation&quot; (where the result appears right after your cursor when you evaluate the S-expression).<p>The usescasses question is a good one.  Python has some pretty good libraries.  For one project, we have a (Clojure) ring server and GCP cloud resources.  Using the Python GCP secret manager to access protected cloud resources allows me to have the same code in dev and prod with minimal configuration.<p>Also sometimes it&#x27;s just political.  Maybe your workplace is a Clojure&#x2F;Java only shop -- in that case, sometimes you can make the case Python is &quot;just a library&quot; and get some cool toys, in other circumstances where its Python only you can at least dev using your lisp REPL.<p>So if that kind of thing sounds fun to you (and you like emacs) you&#x27;ll like this.  If that sounds like hell to you, then it is!!  I really tried hard to optimize around &quot;fun&quot; for the API, but it&#x27;s also really performant, and great fun for hacking.<p>In particular I really love doing silly stuff with Python LLMs in the Clojure REPL.<p>So, tl;dr, I&#x27;d say it is really great if you are a certain kind of hacker who wants all the most fun toys and as an added bonus it <i>also</i> works in production.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41571707" class="c"><input type="checkbox" id="c-41571707" checked=""/><div class="controls bullet"><span class="by">nkzd</span><span>|</span><a href="#41573105">prev</a><span>|</span><a href="#41571576">next</a><span>|</span><label class="collapse" for="c-41571707">[-]</label><label class="expand" for="c-41571707">[25 more]</label></div><br/><div class="children"><div class="content">What is the use-case for GraalPy? To be honest I don&#x27;t understand why would anyone want to use it.</div><br/><div id="41571888" class="c"><input type="checkbox" id="c-41571888" checked=""/><div class="controls bullet"><span class="by">andreldm</span><span>|</span><a href="#41571707">parent</a><span>|</span><a href="#41571844">next</a><span>|</span><label class="collapse" for="c-41571888">[-]</label><label class="expand" for="c-41571888">[8 more]</label></div><br/><div class="children"><div class="content">I worked at a company where data scientists wrote python code using pandas and we had port it to java and a library called keanu that was very useful but soon became unmaintained.<p>Of course this was very time consuming and unrewarding, all because only java applications could be deployed to production due to a stupid top-down decision.<p>This GraalPy sounds like something I wish existed back then.</div><br/><div id="41576569" class="c"><input type="checkbox" id="c-41576569" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41571888">parent</a><span>|</span><a href="#41572213">next</a><span>|</span><label class="collapse" for="c-41576569">[-]</label><label class="expand" for="c-41576569">[1 more]</label></div><br/><div class="children"><div class="content">jep[0] has existed for a while now, and does what GraalPy is doing quite well.<p>I&#x27;m using it for similar purposes as you stated and for that it works quite well. A research group I am collaborating with does a lot of their work in one Java application (ImageJ for microscopy), so by integrating my Python processing code into that application, it finds its way a lot quicker into the daily workflows of everyone in that group.<p>Most recently I&#x27;ve also extended the jep setup to include optional Python version bootstrapping via uv[1], so that I can be sure that the plugins I&#x27;m writing have the correct Python version available, without people having to install that manually on the machine.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ninia&#x2F;jep">https:&#x2F;&#x2F;github.com&#x2F;ninia&#x2F;jep</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;astral-sh&#x2F;uv">https:&#x2F;&#x2F;github.com&#x2F;astral-sh&#x2F;uv</a></div><br/></div></div><div id="41572065" class="c"><input type="checkbox" id="c-41572065" checked=""/><div class="controls bullet"><span class="by">pvorb</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41571888">parent</a><span>|</span><a href="#41572213">prev</a><span>|</span><a href="#41571844">next</a><span>|</span><label class="collapse" for="c-41572065">[-]</label><label class="expand" for="c-41572065">[5 more]</label></div><br/><div class="children"><div class="content">Did you look into Jython back then?</div><br/><div id="41572235" class="c"><input type="checkbox" id="c-41572235" checked=""/><div class="controls bullet"><span class="by">toyg</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41572065">parent</a><span>|</span><a href="#41572617">next</a><span>|</span><label class="collapse" for="c-41572235">[-]</label><label class="expand" for="c-41572235">[2 more]</label></div><br/><div class="children"><div class="content">Jython has historically lagged <i>hard</i>, often falling behind for very extended periods. For a time their releases basically just stopped, which led to them missing support for pretty much anything between 2.7 and 3.6 (iirc). I know the project basically rebooted at some point, but I&#x27;ve since lost interest.</div><br/><div id="41574399" class="c"><input type="checkbox" id="c-41574399" checked=""/><div class="controls bullet"><span class="by">RMPR</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41572235">parent</a><span>|</span><a href="#41572617">next</a><span>|</span><label class="collapse" for="c-41574399">[-]</label><label class="expand" for="c-41574399">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention the biggest drawback imho. Those alternative implementations don&#x27;t support C extensions.</div><br/></div></div></div></div><div id="41572617" class="c"><input type="checkbox" id="c-41572617" checked=""/><div class="controls bullet"><span class="by">jsight</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41572065">parent</a><span>|</span><a href="#41572235">prev</a><span>|</span><a href="#41572466">next</a><span>|</span><label class="collapse" for="c-41572617">[-]</label><label class="expand" for="c-41572617">[1 more]</label></div><br/><div class="children"><div class="content">Jython was dead for a long time. It might be back a little now, but there is still no Python 3 support.<p>GraalPy is much more active and more compatible.</div><br/></div></div><div id="41572466" class="c"><input type="checkbox" id="c-41572466" checked=""/><div class="controls bullet"><span class="by">andreldm</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41572065">parent</a><span>|</span><a href="#41572617">prev</a><span>|</span><a href="#41571844">next</a><span>|</span><label class="collapse" for="c-41572466">[-]</label><label class="expand" for="c-41572466">[1 more]</label></div><br/><div class="children"><div class="content">Not me, someone else in the company did, I don’t remember why it was dismissed.</div><br/></div></div></div></div></div></div><div id="41571844" class="c"><input type="checkbox" id="c-41571844" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#41571707">parent</a><span>|</span><a href="#41571888">prev</a><span>|</span><a href="#41572307">next</a><span>|</span><label class="collapse" for="c-41571844">[-]</label><label class="expand" for="c-41571844">[1 more]</label></div><br/><div class="children"><div class="content">Ghidra embeds Python scripting via Jython, which is stuck on Python 2. Switching to GraalPy would allow Python 3 scripting.<p>Any other Java programs that want a scripting engine could use it as well.</div><br/></div></div><div id="41572307" class="c"><input type="checkbox" id="c-41572307" checked=""/><div class="controls bullet"><span class="by">theflyinghorse</span><span>|</span><a href="#41571707">parent</a><span>|</span><a href="#41571844">prev</a><span>|</span><a href="#41571774">next</a><span>|</span><label class="collapse" for="c-41572307">[-]</label><label class="expand" for="c-41572307">[3 more]</label></div><br/><div class="children"><div class="content">Picture working for a big, non-tech corporation. Your BU only does Java because it has always been thus and Jeff the SVP is a law grad and doesn&#x27;t want anything to change because of perceived risk. GraalVM allows smart people who have to work within such limitations to still write (mostly) the software they want while still  vaguely relating it to Java for decision makers.</div><br/><div id="41573441" class="c"><input type="checkbox" id="c-41573441" checked=""/><div class="controls bullet"><span class="by">nunobrito</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41572307">parent</a><span>|</span><a href="#41572821">next</a><span>|</span><label class="collapse" for="c-41573441">[-]</label><label class="expand" for="c-41573441">[1 more]</label></div><br/><div class="children"><div class="content">Those &quot;smart people&quot; write blackboxes in esoteric languages that only the same person maintains.<p>Everyone else has to write wrappers to interact with that blackbox. God forbid someone daring to even change the code, because it basically doesn&#x27;t even need&#x2F;use junit tests. Eventually the smart person gets bored and moves to something else, that tool then gets rewritten to Java in two days by someone else.<p>End of story.</div><br/></div></div><div id="41572821" class="c"><input type="checkbox" id="c-41572821" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41572307">parent</a><span>|</span><a href="#41573441">prev</a><span>|</span><a href="#41571774">next</a><span>|</span><label class="collapse" for="c-41572821">[-]</label><label class="expand" for="c-41572821">[1 more]</label></div><br/><div class="children"><div class="content">Not so vaguely, either. The dev story is not Java but the deploy story is.</div><br/></div></div></div></div><div id="41571774" class="c"><input type="checkbox" id="c-41571774" checked=""/><div class="controls bullet"><span class="by">abirch</span><span>|</span><a href="#41571707">parent</a><span>|</span><a href="#41572307">prev</a><span>|</span><a href="#41572208">next</a><span>|</span><label class="collapse" for="c-41571774">[-]</label><label class="expand" for="c-41571774">[3 more]</label></div><br/><div class="children"><div class="content">Minecraft Mods can only be written in Java and I want my kid to learn python.<p>Jython is still 2.x and it&#x27;d be nice to let my kid write a minecraft mod in python. Not a business use case but a use case.</div><br/><div id="41572599" class="c"><input type="checkbox" id="c-41572599" checked=""/><div class="controls bullet"><span class="by">smj-edison</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41571774">parent</a><span>|</span><a href="#41572208">next</a><span>|</span><label class="collapse" for="c-41572599">[-]</label><label class="expand" for="c-41572599">[2 more]</label></div><br/><div class="children"><div class="content">When I was learning programming, my coding class used a Bukkit plugin that connected to Python. I can&#x27;t remember what it was called, but that was for Minecraft 1.7.10.<p>Not sure if you were wanting Python specifically, but KubeJS lets you use JavaScript for mods. I think there&#x27;s also a clojure integration.</div><br/><div id="41573594" class="c"><input type="checkbox" id="c-41573594" checked=""/><div class="controls bullet"><span class="by">abirch</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41572599">parent</a><span>|</span><a href="#41572208">next</a><span>|</span><label class="collapse" for="c-41573594">[-]</label><label class="expand" for="c-41573594">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. My 3rd grader knows basic python so I&#x27;d prefer to stick with that or Scratch</div><br/></div></div></div></div></div></div><div id="41572208" class="c"><input type="checkbox" id="c-41572208" checked=""/><div class="controls bullet"><span class="by">pvorb</span><span>|</span><a href="#41571707">parent</a><span>|</span><a href="#41571774">prev</a><span>|</span><a href="#41571766">next</a><span>|</span><label class="collapse" for="c-41572208">[-]</label><label class="expand" for="c-41572208">[1 more]</label></div><br/><div class="children"><div class="content">Maybe this would be an interesting alternative runtime environment for PySpark? I think currently PySpark runs in Python and somehow interacts with a JVM and relies on copying data from one to the other.</div><br/></div></div><div id="41571766" class="c"><input type="checkbox" id="c-41571766" checked=""/><div class="controls bullet"><span class="by">xyproto</span><span>|</span><a href="#41571707">parent</a><span>|</span><a href="#41572208">prev</a><span>|</span><a href="#41571787">next</a><span>|</span><label class="collapse" for="c-41571766">[-]</label><label class="expand" for="c-41571766">[1 more]</label></div><br/><div class="children"><div class="content">Data scientists trapped in bureaucracy?</div><br/></div></div><div id="41571787" class="c"><input type="checkbox" id="c-41571787" checked=""/><div class="controls bullet"><span class="by">the_arun</span><span>|</span><a href="#41571707">parent</a><span>|</span><a href="#41571766">prev</a><span>|</span><a href="#41572846">next</a><span>|</span><label class="collapse" for="c-41571787">[-]</label><label class="expand" for="c-41571787">[2 more]</label></div><br/><div class="children"><div class="content">I am assuming - With this, JVMs needing integration with LLMs can embed LLMs in JVM instead of making outbound API calls. If my assumption is right - wouldn&#x27;t this improve performance of consumer applications?</div><br/><div id="41572167" class="c"><input type="checkbox" id="c-41572167" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41571787">parent</a><span>|</span><a href="#41572846">next</a><span>|</span><label class="collapse" for="c-41572167">[-]</label><label class="expand" for="c-41572167">[1 more]</label></div><br/><div class="children"><div class="content">Thankfully some LLMs also have Java bindings to the same native libraries used by Python.</div><br/></div></div></div></div><div id="41572846" class="c"><input type="checkbox" id="c-41572846" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41571707">parent</a><span>|</span><a href="#41571787">prev</a><span>|</span><a href="#41572147">next</a><span>|</span><label class="collapse" for="c-41572846">[-]</label><label class="expand" for="c-41572846">[4 more]</label></div><br/><div class="children"><div class="content">Besides all the nice answers given by others, a big one was not mentioned: performance!<p>Graal can do pretty advanced JIT-compilation for any Graal language, plus you can mix-and-match languages (with a big chunk of their ecosystems) and it will actually compile <i>across</i> language boundaries. And we haven’t even mentioned Java’s state of the art GCs that can run circles around any tracing GC, let alone the very low throughput reference counting.</div><br/><div id="41573076" class="c"><input type="checkbox" id="c-41573076" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41572846">parent</a><span>|</span><a href="#41572147">next</a><span>|</span><label class="collapse" for="c-41573076">[-]</label><label class="expand" for="c-41573076">[3 more]</label></div><br/><div class="children"><div class="content">I guess for pure python applications, they&#x27;d rather throw more hardware at the problem than messing with the JVM.</div><br/><div id="41573116" class="c"><input type="checkbox" id="c-41573116" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41573076">parent</a><span>|</span><a href="#41572147">next</a><span>|</span><label class="collapse" for="c-41573116">[-]</label><label class="expand" for="c-41573116">[2 more]</label></div><br/><div class="children"><div class="content">For serial workloads it’s very very hard to scale by hardware, though. CPUs aren’t getting 2x faster as they used to.<p>Also, what is “messing with the JVM”? That’s like one of the most battle tested technologies out there, right next to the Linux kernel.</div><br/><div id="41573156" class="c"><input type="checkbox" id="c-41573156" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#41571707">root</a><span>|</span><a href="#41573116">parent</a><span>|</span><a href="#41572147">next</a><span>|</span><label class="collapse" for="c-41573156">[-]</label><label class="expand" for="c-41573156">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t get me wrong, I love the JVM.<p>The unfortunately common irrational aversion to JVM aside, there&#x27;s also the fear of &quot;using it wrong&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="41572147" class="c"><input type="checkbox" id="c-41572147" checked=""/><div class="controls bullet"><span class="by">_joel</span><span>|</span><a href="#41571707">parent</a><span>|</span><a href="#41572846">prev</a><span>|</span><a href="#41571576">next</a><span>|</span><label class="collapse" for="c-41572147">[-]</label><label class="expand" for="c-41572147">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython?tab=readme-ov-file#why-graalpy">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;graalpython?tab=readme-ov-file#why...</a></div><br/></div></div></div></div><div id="41571576" class="c"><input type="checkbox" id="c-41571576" checked=""/><div class="controls bullet"><span class="by">theanonymousone</span><span>|</span><a href="#41571707">prev</a><span>|</span><a href="#41573905">next</a><span>|</span><label class="collapse" for="c-41571576">[-]</label><label class="expand" for="c-41571576">[9 more]</label></div><br/><div class="children"><div class="content">Does it have to be run in a GraalVM, or any JVM implementation is fine?</div><br/><div id="41571984" class="c"><input type="checkbox" id="c-41571984" checked=""/><div class="controls bullet"><span class="by">Okx</span><span>|</span><a href="#41571576">parent</a><span>|</span><a href="#41576372">next</a><span>|</span><label class="collapse" for="c-41571984">[-]</label><label class="expand" for="c-41571984">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You can use GraalPy with GraalVM JDK, Oracle JDK, or OpenJDK<p><a href="https:&#x2F;&#x2F;www.graalvm.org&#x2F;latest&#x2F;reference-manual&#x2F;python&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.graalvm.org&#x2F;latest&#x2F;reference-manual&#x2F;python&#x2F;</a></div><br/><div id="41576366" class="c"><input type="checkbox" id="c-41576366" checked=""/><div class="controls bullet"><span class="by">theanonymousone</span><span>|</span><a href="#41571576">root</a><span>|</span><a href="#41571984">parent</a><span>|</span><a href="#41576372">next</a><span>|</span><label class="collapse" for="c-41576366">[-]</label><label class="expand" for="c-41576366">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. I actually managed to run the quick example with Temurin Java 22. Maybe that is what they mean by &quot;OpenJDK&quot;: java.vm.name=OpenJDK 64-Bit Server VM, java.vendor.version=Temurin-22.0.2+9</div><br/></div></div></div></div><div id="41576372" class="c"><input type="checkbox" id="c-41576372" checked=""/><div class="controls bullet"><span class="by">theanonymousone</span><span>|</span><a href="#41571576">parent</a><span>|</span><a href="#41571984">prev</a><span>|</span><a href="#41571689">next</a><span>|</span><label class="collapse" for="c-41576372">[-]</label><label class="expand" for="c-41576372">[2 more]</label></div><br/><div class="children"><div class="content">Update. I actually managed to run the quick example with Temurin Java 22: java.vm.name=OpenJDK 64-Bit Server VM, java.vendor.version=Temurin-22.0.2+9</div><br/><div id="41577104" class="c"><input type="checkbox" id="c-41577104" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41571576">root</a><span>|</span><a href="#41576372">parent</a><span>|</span><a href="#41571689">next</a><span>|</span><label class="collapse" for="c-41577104">[-]</label><label class="expand" for="c-41577104">[1 more]</label></div><br/><div class="children"><div class="content">It won&#x27;t JIT compile on anything other than GraalVM however. So it&#x27;ll run, but slowly.</div><br/></div></div></div></div><div id="41571689" class="c"><input type="checkbox" id="c-41571689" checked=""/><div class="controls bullet"><span class="by">jryan49</span><span>|</span><a href="#41571576">parent</a><span>|</span><a href="#41576372">prev</a><span>|</span><a href="#41573905">next</a><span>|</span><label class="collapse" for="c-41571689">[-]</label><label class="expand" for="c-41571689">[4 more]</label></div><br/><div class="children"><div class="content">Graal let&#x27;s you compile native binaries</div><br/><div id="41571960" class="c"><input type="checkbox" id="c-41571960" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#41571576">root</a><span>|</span><a href="#41571689">parent</a><span>|</span><a href="#41573905">next</a><span>|</span><label class="collapse" for="c-41571960">[-]</label><label class="expand" for="c-41571960">[3 more]</label></div><br/><div class="children"><div class="content">Graal is many things (a marketing nightmare). The guest language part is orthogonal to the native packager AFAIK.</div><br/><div id="41572347" class="c"><input type="checkbox" id="c-41572347" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#41571576">root</a><span>|</span><a href="#41571960">parent</a><span>|</span><a href="#41573905">next</a><span>|</span><label class="collapse" for="c-41572347">[-]</label><label class="expand" for="c-41572347">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but I was under the impression that graal-level inter-op was limited to packages the graal toolchain could compile.<p>Thus, while swift and graal both depend on llvm, they use different variants and there&#x27;s no real way to make inter-op between swift and graal (even using the llvm it which graal is said to be able to consume).<p>e.g., I believe this announcement represents the work to compile a python (3.11) and some proof-of-concept python packages using graal toolchain, to spur other packages to support the same.<p>So I&#x27;d really love to be wrong, but I believe building under the graal llvm is the common factor.</div><br/><div id="41572936" class="c"><input type="checkbox" id="c-41572936" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41571576">root</a><span>|</span><a href="#41572347">parent</a><span>|</span><a href="#41573905">next</a><span>|</span><label class="collapse" for="c-41572936">[-]</label><label class="expand" for="c-41572936">[1 more]</label></div><br/><div class="children"><div class="content">I don’t really see how swift comes into the picture, besides SuLong being a thing (running LLVM bitcode). Native binary was meant as a compile <i>target</i> in the previous comment, I believe, not as an <i>input</i>. Graal can do both, but as a target it has no dependency on LLVM.<p>So yeah, graalvm should be able to produce a native binary for python code (though depending on the specifics it might actually be more like a native binary interpreter running python scripts, it can’t optimize in every circumstance but I’m hazy on the details).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41573905" class="c"><input type="checkbox" id="c-41573905" checked=""/><div class="controls bullet"><span class="by">abernard1</span><span>|</span><a href="#41571576">prev</a><span>|</span><a href="#41571632">next</a><span>|</span><label class="collapse" for="c-41573905">[-]</label><label class="expand" for="c-41573905">[1 more]</label></div><br/><div class="children"><div class="content">An honorific.  So much of this dynamic language performance improvement on the Graal JVM was proven out by Chris Seaton.<p>May he rest in peace.</div><br/></div></div><div id="41571632" class="c"><input type="checkbox" id="c-41571632" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#41573905">prev</a><span>|</span><a href="#41571052">next</a><span>|</span><label class="collapse" for="c-41571632">[-]</label><label class="expand" for="c-41571632">[2 more]</label></div><br/><div class="children"><div class="content">HPy can eventually be used to support CPython extension modules in GraalPy</div><br/><div id="41571676" class="c"><input type="checkbox" id="c-41571676" checked=""/><div class="controls bullet"><span class="by">ajdhGfa</span><span>|</span><a href="#41571632">parent</a><span>|</span><a href="#41571052">next</a><span>|</span><label class="collapse" for="c-41571676">[-]</label><label class="expand" for="c-41571676">[1 more]</label></div><br/><div class="children"><div class="content">And they will run how much slower or have strange bugs?</div><br/></div></div></div></div><div id="41575889" class="c"><input type="checkbox" id="c-41575889" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#41571052">prev</a><span>|</span><a href="#41571786">next</a><span>|</span><label class="collapse" for="c-41575889">[-]</label><label class="expand" for="c-41575889">[1 more]</label></div><br/><div class="children"><div class="content">Am Internet point for the first working demo with django + postgres.</div><br/></div></div><div id="41571786" class="c"><input type="checkbox" id="c-41571786" checked=""/><div class="controls bullet"><span class="by">calrizien</span><span>|</span><a href="#41575889">prev</a><span>|</span><a href="#41571710">next</a><span>|</span><label class="collapse" for="c-41571786">[-]</label><label class="expand" for="c-41571786">[2 more]</label></div><br/><div class="children"><div class="content">Is there a way to embed Python 3 into Swift like this?</div><br/><div id="41572406" class="c"><input type="checkbox" id="c-41572406" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#41571786">parent</a><span>|</span><a href="#41571710">next</a><span>|</span><label class="collapse" for="c-41572406">[-]</label><label class="expand" for="c-41572406">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen embedding using graal&#x2F;vm, or inter-op using the native JVM FFI.<p>There is (active, 2K stars) <a href="https:&#x2F;&#x2F;github.com&#x2F;pvieito&#x2F;PythonKit">https:&#x2F;&#x2F;github.com&#x2F;pvieito&#x2F;PythonKit</a> and I&#x27;ve heard of people being able to deploy apps with python on the app store. YMMV.</div><br/></div></div></div></div><div id="41571710" class="c"><input type="checkbox" id="c-41571710" checked=""/><div class="controls bullet"><span class="by">ajdhGfa</span><span>|</span><a href="#41571786">prev</a><span>|</span><a href="#41572436">next</a><span>|</span><label class="collapse" for="c-41571710">[-]</label><label class="expand" for="c-41571710">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very skeptical about production use, but the thought of Oracle taking over Python is amusing, since the Python community is already run like Oracle in a top down military manner. It can only get better!</div><br/></div></div><div id="41572436" class="c"><input type="checkbox" id="c-41572436" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#41571710">prev</a><span>|</span><a href="#41571900">next</a><span>|</span><label class="collapse" for="c-41572436">[-]</label><label class="expand" for="c-41572436">[2 more]</label></div><br/><div class="children"><div class="content">what&#x27;s the advantage of this over JPype?</div><br/><div id="41573540" class="c"><input type="checkbox" id="c-41573540" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#41572436">parent</a><span>|</span><a href="#41571900">next</a><span>|</span><label class="collapse" for="c-41573540">[-]</label><label class="expand" for="c-41573540">[1 more]</label></div><br/><div class="children"><div class="content">That it goes in the opposite direction of your cited project (run modern-ish python from within the JVM), and almost certainly has a much, much better JIT story than yours</div><br/></div></div></div></div><div id="41571742" class="c"><input type="checkbox" id="c-41571742" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#41571900">prev</a><span>|</span><a href="#41571678">next</a><span>|</span><label class="collapse" for="c-41571742">[-]</label><label class="expand" for="c-41571742">[3 more]</label></div><br/><div class="children"><div class="content">What does that mean for Clojure?</div><br/><div id="41571821" class="c"><input type="checkbox" id="c-41571821" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41571742">parent</a><span>|</span><a href="#41572680">next</a><span>|</span><label class="collapse" for="c-41571821">[-]</label><label class="expand" for="c-41571821">[1 more]</label></div><br/><div class="children"><div class="content">Why would it mean anything for clojure?</div><br/></div></div><div id="41572680" class="c"><input type="checkbox" id="c-41572680" checked=""/><div class="controls bullet"><span class="by">positr0n</span><span>|</span><a href="#41571742">parent</a><span>|</span><a href="#41571821">prev</a><span>|</span><a href="#41571678">next</a><span>|</span><label class="collapse" for="c-41572680">[-]</label><label class="expand" for="c-41572680">[1 more]</label></div><br/><div class="children"><div class="content">Same thing as Java. You could use this to run python in your clojure JVM process.</div><br/></div></div></div></div><div id="41571678" class="c"><input type="checkbox" id="c-41571678" checked=""/><div class="controls bullet"><span class="by">2OEH8eoCRo0</span><span>|</span><a href="#41571742">prev</a><span>|</span><a href="#41573814">next</a><span>|</span><label class="collapse" for="c-41571678">[-]</label><label class="expand" for="c-41571678">[3 more]</label></div><br/><div class="children"><div class="content">In what world is anything written in Python &quot;high performance?&quot;</div><br/><div id="41572181" class="c"><input type="checkbox" id="c-41572181" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41571678">parent</a><span>|</span><a href="#41572665">next</a><span>|</span><label class="collapse" for="c-41572181">[-]</label><label class="expand" for="c-41572181">[1 more]</label></div><br/><div class="children"><div class="content">In places where it actually has a JIT.</div><br/></div></div><div id="41572665" class="c"><input type="checkbox" id="c-41572665" checked=""/><div class="controls bullet"><span class="by">mkoubaa</span><span>|</span><a href="#41571678">parent</a><span>|</span><a href="#41572181">prev</a><span>|</span><a href="#41573814">next</a><span>|</span><label class="collapse" for="c-41572665">[-]</label><label class="expand" for="c-41572665">[1 more]</label></div><br/><div class="children"><div class="content">The one we want to live in while you fling poop</div><br/></div></div></div></div></div></div></div></div></div></body></html>