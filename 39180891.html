<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706605256471" as="style"/><link rel="stylesheet" href="styles.css?v=1706605256471"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://sudhir.io/the-big-little-guide-to-message-queues">The Big Little Guide to Message Queues (2020)</a> <span class="domain">(<a href="https://sudhir.io">sudhir.io</a>)</span></div><div class="subtext"><span>throwup238</span> | <span>29 comments</span></div><br/><div><div id="39186560" class="c"><input type="checkbox" id="c-39186560" checked=""/><div class="controls bullet"><span class="by">sudhirj</span><span>|</span><a href="#39184740">next</a><span>|</span><label class="collapse" for="c-39186560">[-]</label><label class="expand" for="c-39186560">[1 more]</label></div><br/><div class="children"><div class="content">Hey, author here, feels really nice to be HN famous (as defined by your stuff being on front page without you posting it). AMA and feedback welcome I guess.<p>Wanted to write a book on this topic over the pandemic lockdown, but then I felt it could just be a post. Let me know if anyone thinks it’s worth a full book. Maybe more exploration and demos of the options, reference designs etc.</div><br/></div></div><div id="39184740" class="c"><input type="checkbox" id="c-39184740" checked=""/><div class="controls bullet"><span class="by">thezorg</span><span>|</span><a href="#39186560">prev</a><span>|</span><a href="#39187129">next</a><span>|</span><label class="collapse" for="c-39184740">[-]</label><label class="expand" for="c-39184740">[5 more]</label></div><br/><div class="children"><div class="content">Poor [Cloud Tasks](<a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;tasks" rel="nofollow">https:&#x2F;&#x2F;cloud.google.com&#x2F;tasks</a>), they&#x27;re the actual GCP message queue, but everyone forgets they exist and use Pub&#x2F;Sub instead.<p>What&#x27;s funny is Pub&#x2F;Sub is a fundamentally different model from message queues: queues are normally tightly coupled, meaning you enqueue a message to be processed by a specific system. Pub&#x2F;Sub on the other hand is fundamentally loosely coupled: the publisher doesn&#x27;t care who (if anyone) gets the message.<p>(I&#x27;ve heard &quot;orchestration&quot; vs &quot;choreography&quot; to describe this dichotomy, but I can&#x27;t say I&#x27;m a fan of the jargon.)</div><br/><div id="39184944" class="c"><input type="checkbox" id="c-39184944" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#39184740">parent</a><span>|</span><a href="#39186526">next</a><span>|</span><label class="collapse" for="c-39184944">[-]</label><label class="expand" for="c-39184944">[1 more]</label></div><br/><div class="children"><div class="content">Pub&#x2F;Sub is truly the stuff of nightmares compared to Tasks. I wish Tasks were a little more loved, because I keep ending up using Pub&#x2F;Sub inevitably.</div><br/></div></div><div id="39186526" class="c"><input type="checkbox" id="c-39186526" checked=""/><div class="controls bullet"><span class="by">sudhirj</span><span>|</span><a href="#39184740">parent</a><span>|</span><a href="#39184944">prev</a><span>|</span><a href="#39185056">next</a><span>|</span><label class="collapse" for="c-39186526">[-]</label><label class="expand" for="c-39186526">[1 more]</label></div><br/><div class="children"><div class="content">Wasn’t this on AppEngine in the early days? Yeah, if this is the same thing it’s probably the first queue I learnt &#x2F; used. Will add it in.</div><br/></div></div><div id="39185056" class="c"><input type="checkbox" id="c-39185056" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#39184740">parent</a><span>|</span><a href="#39186526">prev</a><span>|</span><a href="#39187129">next</a><span>|</span><label class="collapse" for="c-39185056">[-]</label><label class="expand" for="c-39185056">[2 more]</label></div><br/><div class="children"><div class="content">Pub&#x2F;Sub is meant to follow the Kafka &quot;insane amounts of data&quot; firehose pattern.  Everyone thinks they need that scale unfortunately and skips over Cloud Tasks.</div><br/><div id="39185608" class="c"><input type="checkbox" id="c-39185608" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#39184740">root</a><span>|</span><a href="#39185056">parent</a><span>|</span><a href="#39187129">next</a><span>|</span><label class="collapse" for="c-39185608">[-]</label><label class="expand" for="c-39185608">[1 more]</label></div><br/><div class="children"><div class="content">The Kafka pattern isn&#x27;t about the size of your data, it&#x27;s about accommodating heterogeneous consumers and easy fan-out. I don&#x27;t love the ampq exchange model because it adds state to the middle of the queue.</div><br/></div></div></div></div></div></div><div id="39187129" class="c"><input type="checkbox" id="c-39187129" checked=""/><div class="controls bullet"><span class="by">katzenversteher</span><span>|</span><a href="#39184740">prev</a><span>|</span><a href="#39186984">next</a><span>|</span><label class="collapse" for="c-39187129">[-]</label><label class="expand" for="c-39187129">[1 more]</label></div><br/><div class="children"><div class="content">On an intuitive level I love message queues. I like how they loosen the coupling between components and the amount of flexibility they provide. A few years ago I even built quite a large system production with RabbitMQ (a scheduling, monitoring and reporting system for distributed tests).<p>However, I find it extremely difficult to reason about them. What do I mean with that? I mean all the nitty gritty details like performance, bottlenecks, crashing participants, network issues, queues filling up, protocol issues that lead to message cascades and DDoS etc.</div><br/></div></div><div id="39186984" class="c"><input type="checkbox" id="c-39186984" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#39187129">prev</a><span>|</span><a href="#39182346">next</a><span>|</span><label class="collapse" for="c-39186984">[-]</label><label class="expand" for="c-39186984">[3 more]</label></div><br/><div class="children"><div class="content">Most users want to use a message queue in a transaction safe way, so they ended up implementing it in database.</div><br/><div id="39187376" class="c"><input type="checkbox" id="c-39187376" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#39186984">parent</a><span>|</span><a href="#39182346">next</a><span>|</span><label class="collapse" for="c-39187376">[-]</label><label class="expand" for="c-39187376">[2 more]</label></div><br/><div class="children"><div class="content">But it&#x27;s not enough - for a few reasons:<p>* Databases are not as transaction-safe (in their default setup) as one is led to believe.  They are ACID for some non-isolated definition of I.  It&#x27;s popped up a number of times in the last few months on HN and was news to me: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38736904">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38736904</a><p>* Even if an ACID transaction protects you from concurrency issues, it won&#x27;t protect you (more specifically - <i>your data</i>) from logic issues.  Bad code will make your database data wrong, even after you push a fix to the code.<p>* The transactions can only span one database, which can limit your system design a bit.<p>Embrace eventual consistency and use a <i>persistent, append-only</i> message queue, and these problems go away.  The downside is you&#x27;ll be accused of chasing fads and doing resume-driven development ;)</div><br/><div id="39187812" class="c"><input type="checkbox" id="c-39187812" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#39186984">root</a><span>|</span><a href="#39187376">parent</a><span>|</span><a href="#39182346">next</a><span>|</span><label class="collapse" for="c-39187812">[-]</label><label class="expand" for="c-39187812">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Databases are not as transaction-safe<p>Yes they are. Transaction-safe does not mean &quot;protecting against concurrency issues&quot;. It just means that a transaction either succeeds or fails, nothing more and nothing less. Then there is <i>isolation</i> which is an orthogonal thing. So let&#x27;s use the correct wording here.<p>&gt; it won&#x27;t protect you (more specifically - your data) from logic issues<p>Nothing protects against logic issues though.<p>&gt; Embrace eventual consistency and use a persistent, append-only message queue, and these problems go away<p>I agree that eventual consistency should be embraced, but it doesn&#x27;t make the mentioned problems go away. How would a persistent, append-only message queue allow for solve the C of CAP while retaining A and P? Of course it can&#x27;t. How does it protect you from logic issues? Of course it can&#x27;t.</div><br/></div></div></div></div></div></div><div id="39182346" class="c"><input type="checkbox" id="c-39182346" checked=""/><div class="controls bullet"><span class="by">raju</span><span>|</span><a href="#39186984">prev</a><span>|</span><a href="#39185534">next</a><span>|</span><label class="collapse" for="c-39182346">[-]</label><label class="expand" for="c-39182346">[10 more]</label></div><br/><div class="children"><div class="content">Previous discussion on HN with 108 comments—<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25591492">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25591492</a></div><br/><div id="39182935" class="c"><input type="checkbox" id="c-39182935" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#39182346">parent</a><span>|</span><a href="#39182936">next</a><span>|</span><label class="collapse" for="c-39182935">[-]</label><label class="expand" for="c-39182935">[8 more]</label></div><br/><div class="children"><div class="content">Whoa, the top comment is really <i>+5</i> insightful.</div><br/><div id="39183736" class="c"><input type="checkbox" id="c-39183736" checked=""/><div class="controls bullet"><span class="by">corford</span><span>|</span><a href="#39182346">root</a><span>|</span><a href="#39182935">parent</a><span>|</span><a href="#39184108">next</a><span>|</span><label class="collapse" for="c-39183736">[-]</label><label class="expand" for="c-39183736">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s a great comment. Since then things like Temporal have sprung up to try and address this state machine complexity of &quot;accidental decoupling&quot;</div><br/></div></div><div id="39184108" class="c"><input type="checkbox" id="c-39184108" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#39182346">root</a><span>|</span><a href="#39182935">parent</a><span>|</span><a href="#39183736">prev</a><span>|</span><a href="#39183866">next</a><span>|</span><label class="collapse" for="c-39184108">[-]</label><label class="expand" for="c-39184108">[3 more]</label></div><br/><div class="children"><div class="content">I could add 2c. If you ever need to store some meta alongside the message in a DB. For example status, some execution history, etc. Then it&#x27;s better to avoid MQ at all. Of course if you can scale DB access from workers and you can couple producers&#x2F;consumers via the same DB. But it&#x27;s the case for almost all applications TBH.</div><br/><div id="39185472" class="c"><input type="checkbox" id="c-39185472" checked=""/><div class="controls bullet"><span class="by">briHass</span><span>|</span><a href="#39182346">root</a><span>|</span><a href="#39184108">parent</a><span>|</span><a href="#39185945">next</a><span>|</span><label class="collapse" for="c-39185472">[-]</label><label class="expand" for="c-39185472">[1 more]</label></div><br/><div class="children"><div class="content">I mostly agree, but from a devil&#x27;s advocate position, the downside is the likelihood that you end up reimplementing queue basics like retries, delay&#x2F;scheduling, and of course, the essential transactional state flips without locking or perf issues.<p>In my experience, the downside to the queue is losing all the historical statistics&#x2F;state that you get for free with a database table. You have to instrument all that stuff manually, since most simple queues are designed to be transient once messages are confirmed.<p>I usually end up with a hybrid: store a copy of the state in the DB (along with all the job data), and essentially use the queue to hand off an ID or something pointing to the DB. You can then run queries against the best-effort state recorded in the DB, but the queue handles all the at-most and schedule&#x2F;retry logic I don&#x27;t want to handcraft.</div><br/></div></div><div id="39185945" class="c"><input type="checkbox" id="c-39185945" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#39182346">root</a><span>|</span><a href="#39184108">parent</a><span>|</span><a href="#39185472">prev</a><span>|</span><a href="#39183866">next</a><span>|</span><label class="collapse" for="c-39185945">[-]</label><label class="expand" for="c-39185945">[1 more]</label></div><br/><div class="children"><div class="content">Fwiw, HTTP is a stateless synchronous at-least-once many-to-one request-reply message queue with metadata.</div><br/></div></div></div></div><div id="39183866" class="c"><input type="checkbox" id="c-39183866" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#39182346">root</a><span>|</span><a href="#39182935">parent</a><span>|</span><a href="#39184108">prev</a><span>|</span><a href="#39182936">next</a><span>|</span><label class="collapse" for="c-39183866">[-]</label><label class="expand" for="c-39183866">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Accidental decoupling is where you have a complex state machine encapsulating a business procedure with multiple steps, and it&#x27;s coordinated as messages between and actions in multiple services.<p>That might need emphasis on &quot;in multiple services.&quot;<p>Within the same service, a granular set of messages (events) can still be useful for auditing or creating good read-model &quot;projections&quot; of what happened.</div><br/><div id="39185908" class="c"><input type="checkbox" id="c-39185908" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#39182346">root</a><span>|</span><a href="#39183866">parent</a><span>|</span><a href="#39182936">next</a><span>|</span><label class="collapse" for="c-39185908">[-]</label><label class="expand" for="c-39185908">[2 more]</label></div><br/><div class="children"><div class="content">I thought event sourcing as a data storage strategy and queues as an execution model were orthogonal concepts?</div><br/><div id="39186314" class="c"><input type="checkbox" id="c-39186314" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#39182346">root</a><span>|</span><a href="#39185908">parent</a><span>|</span><a href="#39182936">next</a><span>|</span><label class="collapse" for="c-39186314">[-]</label><label class="expand" for="c-39186314">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s true that the messages (state machine transitions) don&#x27;t have to be a durable source of truth, but there are similar arguments to be made for granularity.</div><br/></div></div></div></div></div></div></div></div><div id="39182936" class="c"><input type="checkbox" id="c-39182936" checked=""/><div class="controls bullet"><span class="by">kapilvt</span><span>|</span><a href="#39182346">parent</a><span>|</span><a href="#39182935">prev</a><span>|</span><a href="#39185534">next</a><span>|</span><label class="collapse" for="c-39182936">[-]</label><label class="expand" for="c-39182936">[1 more]</label></div><br/><div class="children"><div class="content">thanks for noting, 2020 should be in the title, I was about to comment that event bridge (which linked article notes is new) is a rebrand on cloud watch events which have been around since January 2016.</div><br/></div></div></div></div><div id="39185534" class="c"><input type="checkbox" id="c-39185534" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#39182346">prev</a><span>|</span><a href="#39187716">next</a><span>|</span><label class="collapse" for="c-39185534">[-]</label><label class="expand" for="c-39185534">[4 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve started using message queues to decouple legacy code from new code in order to migrate from one platform to another. I modelled our implementation after AMQP so we could trivially switch to either RabbitMQ, Azure Service Bus or similar down the line.<p>However one thing that seems missing from the standard is retry policies. Sure you could just abandon the message and rely on the timeout, but I&#x27;d prefer an exponential backoff in case some external service is down for an extended period to avoid things bogging down.<p>Are there some standard ways I&#x27;ve missed, or do folks rely on proprietary extensions or extra services for this?</div><br/><div id="39187764" class="c"><input type="checkbox" id="c-39187764" checked=""/><div class="controls bullet"><span class="by">fake-name</span><span>|</span><a href="#39185534">parent</a><span>|</span><a href="#39185612">next</a><span>|</span><label class="collapse" for="c-39187764">[-]</label><label class="expand" for="c-39187764">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not exponential backoff, but I&#x27;ve done this in RabbitMQ with some queue weirdness.<p>I have the main queue with a reasonably short timeout (30 seconds). That queue is set up with has a dead-letter queue where failed messages that don&#x27;t get ACKed get moved to.<p>The dead-letter queue has a TTL of ~5 minutes, where <i>it&#x27;s</i> dead letter queue is the original queue.<p>So basically, if a message fails a worker, it gets kicked over to the dead-letter queue, which then moves it back to the main queue after the TTL times out. This foes mean a crashing message will fail forever (so you have to keep a careful eye on how many messages are in the dead-letter queue), but I&#x27;ve managed to work around this so far. Or you can use proprietary extensions (x-delivery-attempts).</div><br/></div></div><div id="39185612" class="c"><input type="checkbox" id="c-39185612" checked=""/><div class="controls bullet"><span class="by">dmoy</span><span>|</span><a href="#39185534">parent</a><span>|</span><a href="#39187764">prev</a><span>|</span><a href="#39187716">next</a><span>|</span><label class="collapse" for="c-39185612">[-]</label><label class="expand" for="c-39185612">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Are there some standard ways I&#x27;ve missed, or do folks rely on proprietary extensions or extra services for this?<p>As a hack, you can always have your library run its own retry by doing an atomic ack-and-resend-to-the-future (though you need to have bits for retry count if you want exponential back off).  And there&#x27;s situations where it doesn&#x27;t work well, if the message handler itself crashes too hard on failure.</div><br/><div id="39185657" class="c"><input type="checkbox" id="c-39185657" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#39185534">root</a><span>|</span><a href="#39185612">parent</a><span>|</span><a href="#39187716">next</a><span>|</span><label class="collapse" for="c-39185657">[-]</label><label class="expand" for="c-39185657">[1 more]</label></div><br/><div class="children"><div class="content">I mean yea I can do a lot myself given it&#x27;s my implementation, but I was hoping to keep our messaging code fairly generic so it&#x27;d be easy to use either RabbitMQ or Service Bus, depending on if customer wanted on-prem or hosted installation for example.</div><br/></div></div></div></div></div></div><div id="39187716" class="c"><input type="checkbox" id="c-39187716" checked=""/><div class="controls bullet"><span class="by">justsomehnguy</span><span>|</span><a href="#39185534">prev</a><span>|</span><a href="#39185857">next</a><span>|</span><label class="collapse" for="c-39187716">[-]</label><label class="expand" for="c-39187716">[1 more]</label></div><br/><div class="children"><div class="content">Ask HN: What message queue software has <i>a native</i> HTTP receiver?<p>RabbitMQ has one, but it&#x27;s actually a management interface and I really don&#x27;t want to expose it to the whole world.<p>X&#x2F;Y problem: I need to send data from clients without custom protocols (so no libs bundled) over a plain HTTP&#x2F;S (so it can traverse firewall in 99.9%) to the public endpoint.<p>I don&#x27;t really care about the most features of the message queues, but I definitely don&#x27;t want <i>to write one</i>.<p>I had a successful deployment on a very similar task with RabbitMQ, but it was fully internal and had no security requirements.</div><br/></div></div><div id="39185857" class="c"><input type="checkbox" id="c-39185857" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#39187716">prev</a><span>|</span><a href="#39184158">next</a><span>|</span><label class="collapse" for="c-39185857">[-]</label><label class="expand" for="c-39185857">[2 more]</label></div><br/><div class="children"><div class="content">If you want to learn about Message Queues firsthand (and you should if you care about CS) I recommend implementing some with ZeroMQ. (I love the joke in the article about it being &quot;zero effort&quot; xD) There are many, many forms of queues, and you can implement most of them with ZeroMQ. There&#x27;s tons of examples in many different languages, and lots of guides and docs to help you. Even considering all that, it will still be a pain to get the queues working, and that pain will help reinforce the purpose behind different queue architectures, and why it&#x27;s so nice to have COTS message queues.<p>That said, if you want a customizeable FOSS message queue stack, use NATS. I&#x27;m not aware of a better, more complete solution designed for custom integration.</div><br/><div id="39187174" class="c"><input type="checkbox" id="c-39187174" checked=""/><div class="controls bullet"><span class="by">katzenversteher</span><span>|</span><a href="#39185857">parent</a><span>|</span><a href="#39184158">next</a><span>|</span><label class="collapse" for="c-39187174">[-]</label><label class="expand" for="c-39187174">[1 more]</label></div><br/><div class="children"><div class="content">I never used ZeroMQ (visited their webpage many many times though) but I totally agree that going through the pain, struggles and subtleties of message queuing is a very valuable and important learning experience.<p>I had those experiences with RabbitMQ around 10 years ago when I pushed the team I worked for towards a message queue solution to scale our distributed test system. It turned out successful but it took quite a while :)</div><br/></div></div></div></div></div></div></div></div></div></body></html>