<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726304449836" as="style"/><link rel="stylesheet" href="styles.css?v=1726304449836"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/RyanWelly/lisp-in-rs-macros">Lisp implemented in Rust macros</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>quasigloam</span> | <span>50 comments</span></div><br/><div><div id="41535713" class="c"><input type="checkbox" id="c-41535713" checked=""/><div class="controls bullet"><span class="by">duetosymmetry</span><span>|</span><a href="#41537523">next</a><span>|</span><label class="collapse" for="c-41535713">[-]</label><label class="expand" for="c-41535713">[17 more]</label></div><br/><div class="children"><div class="content">Greenspun&#x27;s tenth rule strikes again! <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Greenspun%27s_tenth_rule" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Greenspun%27s_tenth_rule</a></div><br/><div id="41535993" class="c"><input type="checkbox" id="c-41535993" checked=""/><div class="controls bullet"><span class="by">ForOldHack</span><span>|</span><a href="#41535713">parent</a><span>|</span><a href="#41537381">next</a><span>|</span><label class="collapse" for="c-41535993">[-]</label><label class="expand" for="c-41535993">[1 more]</label></div><br/><div class="children"><div class="content">HA!<p>&quot;Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.&quot;<p>HA HA!</div><br/></div></div><div id="41537381" class="c"><input type="checkbox" id="c-41537381" checked=""/><div class="controls bullet"><span class="by">bigdict</span><span>|</span><a href="#41535713">parent</a><span>|</span><a href="#41535993">prev</a><span>|</span><a href="#41535781">next</a><span>|</span><label class="collapse" for="c-41537381">[-]</label><label class="expand" for="c-41537381">[6 more]</label></div><br/><div class="children"><div class="content">nah, this is about codebases that are not themselves primarily lisp implementations</div><br/><div id="41537668" class="c"><input type="checkbox" id="c-41537668" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41537381">parent</a><span>|</span><a href="#41537852">next</a><span>|</span><label class="collapse" for="c-41537668">[-]</label><label class="expand" for="c-41537668">[2 more]</label></div><br/><div class="children"><div class="content">This is correct. Greenspun&#x27;s Tenth Rule is not meant to be interpreted as applying to projects that are consciously creating a Lisp implementation. It&#x27;s about programs which are not meant to be language implementations at all reinventing <i>ad hoc</i> infrastructure that is <i>designed</i> in Lisps according to established patterns. For instance, badly reinventing something that functions as symbols.</div><br/><div id="41538201" class="c"><input type="checkbox" id="c-41538201" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41537668">parent</a><span>|</span><a href="#41537852">next</a><span>|</span><label class="collapse" for="c-41538201">[-]</label><label class="expand" for="c-41538201">[1 more]</label></div><br/><div class="children"><div class="content">I conjecture the line is not so easy to draw.<p>If you are creating Lisp because you want to create Lisp, like creating Lisp, want to show off creating Lisp, that obviously is not what the Law is about.<p>Furthermore, if you create Lisp because you know the Law, know it is inevitable, and want to avoid the caveats and missed bars by doing so explicitly, well then that also is not what the Law is about.<p>But if you are going about your business, focused on your independent goal, realize you need Lisp like lists, and then 250 lines of code later realize you have created a solid Lisp unintentionally? Well, congrats on falling into the trap but not getting hurt!<p>—<p>Personally, I have created both Lisp and Forth multiple times for suitable projects where I wanted some flexible runtime scripting. I am not familiar with the standard version libraries of either and don’t need them.<p>Minimal foundation implementations are extremely easy to create, and eliminate any dependencies or sources of mystery.<p>Anyone know of any other well designed mininal languages?</div><br/></div></div></div></div><div id="41537852" class="c"><input type="checkbox" id="c-41537852" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41537381">parent</a><span>|</span><a href="#41537668">prev</a><span>|</span><a href="#41535781">next</a><span>|</span><label class="collapse" for="c-41537852">[-]</label><label class="expand" for="c-41537852">[3 more]</label></div><br/><div class="children"><div class="content">Pretty sure it applies to Common Lisp itself too.</div><br/><div id="41538353" class="c"><input type="checkbox" id="c-41538353" checked=""/><div class="controls bullet"><span class="by">arnsholt</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41537852">parent</a><span>|</span><a href="#41538249">next</a><span>|</span><label class="collapse" for="c-41538353">[-]</label><label class="expand" for="c-41538353">[1 more]</label></div><br/><div class="children"><div class="content">The corollary to Greenspun’s rule is that any sufficiently complicated Common Lisp program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Prolog.</div><br/></div></div><div id="41538249" class="c"><input type="checkbox" id="c-41538249" checked=""/><div class="controls bullet"><span class="by">vasvir</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41537852">parent</a><span>|</span><a href="#41538353">prev</a><span>|</span><a href="#41535781">next</a><span>|</span><label class="collapse" for="c-41538249">[-]</label><label class="expand" for="c-41538249">[1 more]</label></div><br/><div class="children"><div class="content">yes but not recursively!</div><br/></div></div></div></div></div></div><div id="41535781" class="c"><input type="checkbox" id="c-41535781" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#41535713">parent</a><span>|</span><a href="#41537381">prev</a><span>|</span><a href="#41537523">next</a><span>|</span><label class="collapse" for="c-41535781">[-]</label><label class="expand" for="c-41535781">[9 more]</label></div><br/><div class="children"><div class="content">What defines &quot;sufficiently complicated&quot; I wonder? Seems like a shit definition.</div><br/><div id="41538179" class="c"><input type="checkbox" id="c-41538179" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41535781">parent</a><span>|</span><a href="#41537672">next</a><span>|</span><label class="collapse" for="c-41538179">[-]</label><label class="expand" for="c-41538179">[1 more]</label></div><br/><div class="children"><div class="content">&quot;for any sufficiently X the Y&quot; just means that if you don&#x27;t observe Y right now, just increase the magnitude of X and you&#x27;ll inevitably reach the conditions for Y to happen.<p>Famous use of that pattern is Arthur&#x27;s Clarke &quot;Any sufficiently advanced technology is indistinguishable from magic.&quot;. As with OP&#x27;s quote, this is also vague and imprecise but the point of the idea is that there is a gradient towards which advancements in technology bring us towards a situation where the average person no longer understands how it works and it may as well be magic (while not necessarily defining exactly when does that transition happen)</div><br/></div></div><div id="41537672" class="c"><input type="checkbox" id="c-41537672" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41535781">parent</a><span>|</span><a href="#41538179">prev</a><span>|</span><a href="#41535848">next</a><span>|</span><label class="collapse" for="c-41537672">[-]</label><label class="expand" for="c-41537672">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s explicitly encoded right in the rule itself! When the program contains a bug-ridden, ad-hoc simulacrum of half (or more) of Common Lisp, then it has become sufficiently complicated. When it has less than half, it is not yet sufficiently complicated.</div><br/></div></div><div id="41535848" class="c"><input type="checkbox" id="c-41535848" checked=""/><div class="controls bullet"><span class="by">StableAlkyne</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41535781">parent</a><span>|</span><a href="#41537672">prev</a><span>|</span><a href="#41536087">next</a><span>|</span><label class="collapse" for="c-41535848">[-]</label><label class="expand" for="c-41535848">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just a funny observation he made, it&#x27;s not meant to be a rigorous academic definition :)</div><br/></div></div><div id="41536087" class="c"><input type="checkbox" id="c-41536087" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41535781">parent</a><span>|</span><a href="#41535848">prev</a><span>|</span><a href="#41535852">next</a><span>|</span><label class="collapse" for="c-41536087">[-]</label><label class="expand" for="c-41536087">[3 more]</label></div><br/><div class="children"><div class="content">I like that the &quot;sufficiently complicated&quot; part bothered you, but not the &quot;ad hoc&quot;, &quot;informally-specified&quot;, &quot;bug-ridden&quot;, or &quot;slow&quot; parts.</div><br/><div id="41537497" class="c"><input type="checkbox" id="c-41537497" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41536087">parent</a><span>|</span><a href="#41535852">next</a><span>|</span><label class="collapse" for="c-41537497">[-]</label><label class="expand" for="c-41537497">[2 more]</label></div><br/><div class="children"><div class="content">No, I think it&#x27;s pretty fair. One could argue about these, but except for &quot;slow&quot; these are more quality qualifiers, rather than quantity. So you either agree it&#x27;s &quot;bug-ridden&quot; or not (i.e. the number and seriousness of bugs in it is negligible by whatever standards). And I think even &quot;slow&quot; can be discussed in the same manner, the actual speed is quantitative, of course, but in the end one either argues that this speed is &quot;slow&quot; or isn&#x27;t. So, given some rhetoric skills of your opponent it&#x27;s at least possible for that statement to be proven false, if he convinces you the implementation actually isn&#x27;t slow nor bug-ridden, or at least if there&#x27;s no Lisp-implementation indeed.<p>But what is &quot;sufficiently&quot; complicated? Now it&#x27;s a silly statement that just doesn&#x27;t pass Popper criterion: even if nobody dares to deny your program is complicated, one can always say it isn&#x27;t <i>sufficiently</i> complicated, hence the fact it doesn&#x27;t contain Lisp-interpreter disproves nothing. A man of culture wouldn&#x27;t use such definitions.</div><br/><div id="41537721" class="c"><input type="checkbox" id="c-41537721" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41537497">parent</a><span>|</span><a href="#41535852">next</a><span>|</span><label class="collapse" for="c-41537721">[-]</label><label class="expand" for="c-41537721">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t that sort of the point? It makes the argument impossible to dispute. If it’s not slow or big-ridden, then it’s just not sufficiently complicated. Which you’re correct to call out.<p>I think what makes it work is that Common Lisp very quickly becomes a faster way to do things because of how insanely efficient it is.</div><br/></div></div></div></div></div></div><div id="41535852" class="c"><input type="checkbox" id="c-41535852" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41535781">parent</a><span>|</span><a href="#41536087">prev</a><span>|</span><a href="#41537523">next</a><span>|</span><label class="collapse" for="c-41535852">[-]</label><label class="expand" for="c-41535852">[2 more]</label></div><br/><div class="children"><div class="content">The rule defines it tautologically. Which is sufficiently unambiguous for its purpose!</div><br/><div id="41536483" class="c"><input type="checkbox" id="c-41536483" checked=""/><div class="controls bullet"><span class="by">throw-the-towel</span><span>|</span><a href="#41535713">root</a><span>|</span><a href="#41535852">parent</a><span>|</span><a href="#41537523">next</a><span>|</span><label class="collapse" for="c-41536483">[-]</label><label class="expand" for="c-41536483">[1 more]</label></div><br/><div class="children"><div class="content">Greenspun&#x27;s tenth rule, corollary: Any sufficiently precise definition of &quot;complex system&quot; contains an ad hoc, informal, bug-ridden, slow <i>specification</i> of half of Common Lisp.</div><br/></div></div></div></div></div></div></div></div><div id="41537523" class="c"><input type="checkbox" id="c-41537523" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#41535713">prev</a><span>|</span><a href="#41536789">next</a><span>|</span><label class="collapse" for="c-41537523">[-]</label><label class="expand" for="c-41537523">[9 more]</label></div><br/><div class="children"><div class="content">Everyone is supposed to be cheering for how &quot;fun&quot; it is, but every time I see anything like that I cannot help but think, that I hate the fact it can be implemented in Rust. It never truly was a simple language, but I think it started as something way more manageable than what it has become.</div><br/><div id="41537626" class="c"><input type="checkbox" id="c-41537626" checked=""/><div class="controls bullet"><span class="by">zxexz</span><span>|</span><a href="#41537523">parent</a><span>|</span><a href="#41538324">next</a><span>|</span><label class="collapse" for="c-41537626">[-]</label><label class="expand" for="c-41537626">[5 more]</label></div><br/><div class="children"><div class="content">Rust is definitely not a <i>simple</i> language, I agree there.<p>I am quite likely a bit naïve here, but I&#x27;m having trouble understanding why you hate that this is possible. Now, the macro system definitely can generate near infinitely-complex code, but I&#x27;m not getting how implementing a sandboxed lisp using macros is a particularly potent example of the language being less manageable than at its genesis.<p>On another note, the fact that the type system is turing-complete, like with C++ templates or the Haskell type system (variously dependent on which GHC languages extensions you&#x27;re using...), makes me want to see a lisp implemented that way!</div><br/><div id="41537781" class="c"><input type="checkbox" id="c-41537781" checked=""/><div class="controls bullet"><span class="by">quasigloam</span><span>|</span><a href="#41537523">root</a><span>|</span><a href="#41537626">parent</a><span>|</span><a href="#41538324">next</a><span>|</span><label class="collapse" for="c-41537781">[-]</label><label class="expand" for="c-41537781">[4 more]</label></div><br/><div class="children"><div class="content">Implementing a lisp in the type system would be fun, that&#x27;s originally what this project was about until I got distracted with macros. Awesome projects like fortraith (<a href="https:&#x2F;&#x2F;github.com&#x2F;Ashymad&#x2F;fortraith">https:&#x2F;&#x2F;github.com&#x2F;Ashymad&#x2F;fortraith</a>) already exist, and even far more useful projects like dimensioned (compile time dimensional analysis using type level numbers) are inspiring. These examples, although cool, are probably a worse sign for krick for Rust compared with macro_rules being Turing complete.</div><br/><div id="41537821" class="c"><input type="checkbox" id="c-41537821" checked=""/><div class="controls bullet"><span class="by">zxexz</span><span>|</span><a href="#41537523">root</a><span>|</span><a href="#41537781">parent</a><span>|</span><a href="#41538324">next</a><span>|</span><label class="collapse" for="c-41537821">[-]</label><label class="expand" for="c-41537821">[3 more]</label></div><br/><div class="children"><div class="content">Aha, that&#x27;s pretty cool! Didn&#x27;t even scroll more halfway down the page before my lizard brain saw some something resembling Peano numbers.<p>Thanks for sharing your project, by the way - between this and the other one you linked, I think I know what my leisure time this weekend is going to consist of...</div><br/><div id="41537979" class="c"><input type="checkbox" id="c-41537979" checked=""/><div class="controls bullet"><span class="by">quasigloam</span><span>|</span><a href="#41537523">root</a><span>|</span><a href="#41537821">parent</a><span>|</span><a href="#41538324">next</a><span>|</span><label class="collapse" for="c-41537979">[-]</label><label class="expand" for="c-41537979">[2 more]</label></div><br/><div class="children"><div class="content">No problem! I had fun making it, for such a silly little project it&#x27;s given me a surprising amount of joy.  If you want to look at another cool project that&#x27;s tangentially related, have a look at Sectorlisp.</div><br/><div id="41538048" class="c"><input type="checkbox" id="c-41538048" checked=""/><div class="controls bullet"><span class="by">zxexz</span><span>|</span><a href="#41537523">root</a><span>|</span><a href="#41537979">parent</a><span>|</span><a href="#41538324">next</a><span>|</span><label class="collapse" for="c-41538048">[-]</label><label class="expand" for="c-41538048">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I&#x27;m very well acquainted with Sectorlisp - I even have a scrappy local package on nixos to build, boot and launch a qemu repl for it locally! Somewhere around here there&#x27;s an HDD in an X200 that probably still has it in the boot sector on its HDD.<p>I think I objectively suck at lisp, but that doesn&#x27;t preclude me from being a &quot;Greenspan enjoyer&quot; :) I think all of my projects that used Selenium ended up with a haphazardly-pieced-together lisp interpreter as their scripting tool after I realized whatever I was writing was effectively becoming a DSL in a .ini&#x2F;.yaml&#x2F;.toml file. These days, I mostly use nix, but my dream is a lispy NixOS (yes, I know of and have used Guix, but I really just want a lisp&lt;&gt;Nix &#x27;native&#x27; compiler, and to be able to use it with nixpkgs without hassle).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41538324" class="c"><input type="checkbox" id="c-41538324" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#41537523">parent</a><span>|</span><a href="#41537626">prev</a><span>|</span><a href="#41538051">next</a><span>|</span><label class="collapse" for="c-41538324">[-]</label><label class="expand" for="c-41538324">[1 more]</label></div><br/><div class="children"><div class="content">The only real change since 1.0 was async. If you want to live without async that is completely up to you. It is an entirely optional part of the language.<p>If you want a language guided by the principle of simplicity Rust was never that and you have plenty of options elsewhere.</div><br/></div></div><div id="41538051" class="c"><input type="checkbox" id="c-41538051" checked=""/><div class="controls bullet"><span class="by">huijzer</span><span>|</span><a href="#41537523">parent</a><span>|</span><a href="#41538324">prev</a><span>|</span><a href="#41537927">next</a><span>|</span><label class="collapse" for="c-41538051">[-]</label><label class="expand" for="c-41538051">[1 more]</label></div><br/><div class="children"><div class="content">Aren’t macro’s always very powerful but at the same time very tricky? I wouldn’t count the macro side into language complexity. It’s an add-on which you can but don’t have to use (I’m talking about creating macro’s here.)</div><br/></div></div><div id="41537927" class="c"><input type="checkbox" id="c-41537927" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#41537523">parent</a><span>|</span><a href="#41538051">prev</a><span>|</span><a href="#41536789">next</a><span>|</span><label class="collapse" for="c-41537927">[-]</label><label class="expand" for="c-41537927">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but I think it started as something way more manageable than what it has become.<p>Hard disagree here. Rust team is continuously making the language easier to work with by removing limitations and making features more orthogonal. A notable example is non lexical lifetimes, impl Trait in return position or async traits.  Also they have removed some features eg before it went 1.0, it even had GCed references built in with special syntax.</div><br/></div></div></div></div><div id="41536789" class="c"><input type="checkbox" id="c-41536789" checked=""/><div class="controls bullet"><span class="by">celeritascelery</span><span>|</span><a href="#41537523">prev</a><span>|</span><a href="#41535563">next</a><span>|</span><label class="collapse" for="c-41536789">[-]</label><label class="expand" for="c-41536789">[9 more]</label></div><br/><div class="children"><div class="content">I tried doing something similar to this once. I ran into an issue where I couldn’t define symbols with a dash in them (DEFINE MY-FN…). This is because rust will split the tokens on a dash.  It was a small thing, but it meant I couldn’t just copy and paste snippets from a real lisp, I had to transform everything to underscore. Is it the same in your implementation?</div><br/><div id="41536810" class="c"><input type="checkbox" id="c-41536810" checked=""/><div class="controls bullet"><span class="by">quasigloam</span><span>|</span><a href="#41536789">parent</a><span>|</span><a href="#41538049">next</a><span>|</span><label class="collapse" for="c-41536810">[-]</label><label class="expand" for="c-41536810">[7 more]</label></div><br/><div class="children"><div class="content">Yes, at the moment I just assume that all atoms are rust idents because that makes it easier to implement (I can just match against $x:ident), so it doesn&#x27;t support dashes in atoms. I guess you could match against `$x:ident $(- $y:ident)*` instead? That should work I think, I&#x27;d have to change some details in some of the arms but it seems like that would be possible.</div><br/><div id="41537221" class="c"><input type="checkbox" id="c-41537221" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#41536789">root</a><span>|</span><a href="#41536810">parent</a><span>|</span><a href="#41537229">next</a><span>|</span><label class="collapse" for="c-41537221">[-]</label><label class="expand" for="c-41537221">[4 more]</label></div><br/><div class="children"><div class="content">Wouldn’t that match “(foo - bar)” as well as “(foo-bar)”? I don’t think you can get around token whitespace in macro_rules</div><br/><div id="41537834" class="c"><input type="checkbox" id="c-41537834" checked=""/><div class="controls bullet"><span class="by">celeritascelery</span><span>|</span><a href="#41536789">root</a><span>|</span><a href="#41537221">parent</a><span>|</span><a href="#41537279">next</a><span>|</span><label class="collapse" for="c-41537834">[-]</label><label class="expand" for="c-41537834">[2 more]</label></div><br/><div class="children"><div class="content">It would, but lisp has prefix operators, so you wouldn’t have to worry about it getting confused.</div><br/><div id="41537990" class="c"><input type="checkbox" id="c-41537990" checked=""/><div class="controls bullet"><span class="by">quasigloam</span><span>|</span><a href="#41536789">root</a><span>|</span><a href="#41537834">parent</a><span>|</span><a href="#41537279">next</a><span>|</span><label class="collapse" for="c-41537990">[-]</label><label class="expand" for="c-41537990">[1 more]</label></div><br/><div class="children"><div class="content">Although in a Lisp such as Scheme, you could pass around the negation operator in something like (map - &#x27;(1 2 3)), so it would be a valid concern that it might clash.</div><br/></div></div></div></div><div id="41537279" class="c"><input type="checkbox" id="c-41537279" checked=""/><div class="controls bullet"><span class="by">quasigloam</span><span>|</span><a href="#41536789">root</a><span>|</span><a href="#41537221">parent</a><span>|</span><a href="#41537834">prev</a><span>|</span><a href="#41537229">next</a><span>|</span><label class="collapse" for="c-41537279">[-]</label><label class="expand" for="c-41537279">[1 more]</label></div><br/><div class="children"><div class="content">Yes it would match both, this would require us to assume that &quot;foo - bar&quot; can only be an atom. It&#x27;s not a great solution.</div><br/></div></div></div></div><div id="41537229" class="c"><input type="checkbox" id="c-41537229" checked=""/><div class="controls bullet"><span class="by">anothername12</span><span>|</span><a href="#41536789">root</a><span>|</span><a href="#41536810">parent</a><span>|</span><a href="#41537221">prev</a><span>|</span><a href="#41538049">next</a><span>|</span><label class="collapse" for="c-41537229">[-]</label><label class="expand" for="c-41537229">[2 more]</label></div><br/><div class="children"><div class="content">Does Rust have something like a reader macro where you can have arbitrary syntax for a bit?</div><br/><div id="41537300" class="c"><input type="checkbox" id="c-41537300" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#41536789">root</a><span>|</span><a href="#41537229">parent</a><span>|</span><a href="#41538049">next</a><span>|</span><label class="collapse" for="c-41537300">[-]</label><label class="expand" for="c-41537300">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s almost but not quite arbitrary. It still has to be a valid Rust token stream with matching braces&#x2F;parens. Since it&#x27;s whitespace insensitive with respect to tokens and &quot;-&quot; is its own token, &quot;(foo-bar)&quot; and &quot;(foo - bar)&quot; result in the same token stream minus the span information.<p>You can use proc_macro::Span.line()&#x2F;column() [1] to track how much whitespace there is between tokens and merge them, but the macro will have to rename them to valid Rust identities (&quot;foo-bar&quot; to &quot;foo_bar&quot;) and make sure there&#x27;s no collisions.<p>[1] <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;proc_macro&#x2F;struct.Span.html#method.line" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;proc_macro&#x2F;struct.Span.html#method...</a></div><br/></div></div></div></div></div></div><div id="41538049" class="c"><input type="checkbox" id="c-41538049" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41536789">parent</a><span>|</span><a href="#41536810">prev</a><span>|</span><a href="#41535563">next</a><span>|</span><label class="collapse" for="c-41538049">[-]</label><label class="expand" for="c-41538049">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I ran into an issue where I couldn’t define symbols with a dash in them<p>I&#x27;m not seeing any issue? (DEFINE MYᜭFN...) works just fine.</div><br/></div></div></div></div><div id="41535563" class="c"><input type="checkbox" id="c-41535563" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#41536789">prev</a><span>|</span><a href="#41537297">next</a><span>|</span><label class="collapse" for="c-41535563">[-]</label><label class="expand" for="c-41535563">[5 more]</label></div><br/><div class="children"><div class="content">I wish there was a well-supported Lisp in Rust, not just the macros. I wonder how much memory safety you would retain or lose being based in Rust. Is it even possible to leverage the borrow checker any any sane way?</div><br/><div id="41536424" class="c"><input type="checkbox" id="c-41536424" checked=""/><div class="controls bullet"><span class="by">dokyun</span><span>|</span><a href="#41535563">parent</a><span>|</span><a href="#41535689">next</a><span>|</span><label class="collapse" for="c-41536424">[-]</label><label class="expand" for="c-41536424">[3 more]</label></div><br/><div class="children"><div class="content">Some Lisp compilers like SBCL are already capable of more extensive compile-time type-checking, but its information that the programmer is up to supply, and tends to be the part of the optimization stage rather than normal, incremental development. Lisp is usually defined by its dynamic nature, and run-time type checking is a big part of this. Making the programmer have to worry about how objects are managed before the fact would conflict with the freedom and expressibility one would expect from such a system. It also makes the compilers themselves simpler in comparison: Normal code without any extra declarations is safe by default, some systems might ignore such declarations for always being &#x27;safe&#x27; (say if you&#x27;re on a bytecode VM like CLISP or a Lisp machine that does hardware type-checking). SBCL compiles code quite quickly--so I&#x27;ve heard others tend to be even faster; the Rust compiler on the other hand is more likely to introduce a young programmer to the concept of thrashing. I really see them as two mutually incompatible worlds although they may not seem to be at first glance. One thing to remember is that Lisp is essentially the flagship &quot;The Right Thing&quot; language, while C is the &quot;Worse is Better&quot; language. Rust is neither, it is something entirely different which I think is overdue for a name, perhaps something that reflects the losing characteristics of both philosophies.<p>(This isn&#x27;t to discredit the OP article: it&#x27;s still a cool hack!)</div><br/><div id="41537471" class="c"><input type="checkbox" id="c-41537471" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#41535563">root</a><span>|</span><a href="#41536424">parent</a><span>|</span><a href="#41538359">next</a><span>|</span><label class="collapse" for="c-41537471">[-]</label><label class="expand" for="c-41537471">[1 more]</label></div><br/><div class="children"><div class="content">&gt; perhaps something that reflects the losing characteristics of both philosophies.<p>Oof. With how much love Rust gets here, I didn&#x27;t expect to see it being called out like that.<p>How about &quot;The Worse Thing&quot;?</div><br/></div></div><div id="41538359" class="c"><input type="checkbox" id="c-41538359" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41535563">root</a><span>|</span><a href="#41536424">parent</a><span>|</span><a href="#41537471">prev</a><span>|</span><a href="#41535689">next</a><span>|</span><label class="collapse" for="c-41538359">[-]</label><label class="expand" for="c-41538359">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some Lisp compilers like SBCL are already capable of more extensive compile-time type-checking, but its information that the programmer is up to supply<p>Which is nice and all, but very much gimped by the glaring holes in CL&#x27;s typing tooling: you can&#x27;t create actual types, only derived types (deftype) and struct&#x2F;class types. The two consequences of that is that you can&#x27;t type cons-based lists&#x2F;trees (arguably THE Lisp data structure) because deftype can&#x27;t be recursive and you can&#x27;t create parametric types, it&#x27;s an internal thing only used for <a href="https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Body&#x2F;t_array.htm" rel="nofollow">https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Body&#x2F;t_arr...</a> (and not even hash-tables, these are completely untyped!).</div><br/></div></div></div></div><div id="41535689" class="c"><input type="checkbox" id="c-41535689" checked=""/><div class="controls bullet"><span class="by">alilleybrinker</span><span>|</span><a href="#41535563">parent</a><span>|</span><a href="#41536424">prev</a><span>|</span><a href="#41537297">next</a><span>|</span><label class="collapse" for="c-41535689">[-]</label><label class="expand" for="c-41535689">[1 more]</label></div><br/><div class="children"><div class="content">Steel seems alright: <a href="https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;steel">https:&#x2F;&#x2F;github.com&#x2F;mattwparas&#x2F;steel</a><p>There are other Lisps too (<a href="https:&#x2F;&#x2F;github.com&#x2F;alilleybrinker&#x2F;langs-in-rust">https:&#x2F;&#x2F;github.com&#x2F;alilleybrinker&#x2F;langs-in-rust</a>) though I think they’re less actively maintained.</div><br/></div></div></div></div><div id="41537297" class="c"><input type="checkbox" id="c-41537297" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#41535563">prev</a><span>|</span><a href="#41535725">next</a><span>|</span><label class="collapse" for="c-41537297">[-]</label><label class="expand" for="c-41537297">[1 more]</label></div><br/><div class="children"><div class="content">Wow and it uses macro_rules</div><br/></div></div><div id="41535725" class="c"><input type="checkbox" id="c-41535725" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#41537297">prev</a><span>|</span><a href="#41535355">next</a><span>|</span><label class="collapse" for="c-41535725">[-]</label><label class="expand" for="c-41535725">[3 more]</label></div><br/><div class="children"><div class="content">That was fun. Thanks for sharing!</div><br/><div id="41535812" class="c"><input type="checkbox" id="c-41535812" checked=""/><div class="controls bullet"><span class="by">quasigloam</span><span>|</span><a href="#41535725">parent</a><span>|</span><a href="#41535355">next</a><span>|</span><label class="collapse" for="c-41535812">[-]</label><label class="expand" for="c-41535812">[2 more]</label></div><br/><div class="children"><div class="content">Thanks! It was fun to make. It was also instructive, as I learned that rust analyser doesn&#x27;t handle macros generating millions of tokens :D</div><br/><div id="41535897" class="c"><input type="checkbox" id="c-41535897" checked=""/><div class="controls bullet"><span class="by">detourdog</span><span>|</span><a href="#41535725">root</a><span>|</span><a href="#41535812">parent</a><span>|</span><a href="#41535355">next</a><span>|</span><label class="collapse" for="c-41535897">[-]</label><label class="expand" for="c-41535897">[1 more]</label></div><br/><div class="children"><div class="content">Does this reinforce Greenspan’s 10th rule?</div><br/></div></div></div></div></div></div><div id="41536708" class="c"><input type="checkbox" id="c-41536708" checked=""/><div class="controls bullet"><span class="by">elif</span><span>|</span><a href="#41535355">prev</a><span>|</span><a href="#41538128">next</a><span>|</span><label class="collapse" for="c-41536708">[-]</label><label class="expand" for="c-41536708">[1 more]</label></div><br/><div class="children"><div class="content">Hmmmmmmm....  Rustemacs?</div><br/></div></div></div></div></div></div></div></body></html>