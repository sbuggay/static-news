<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729069267399" as="style"/><link rel="stylesheet" href="styles.css?v=1729069267399"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/asterinas/asterinas">Asterinas: OS kernel written in Rust and providing Linux-compatible ABI</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>Klasiaster</span> | <span>115 comments</span></div><br/><div><div id="41853874" class="c"><input type="checkbox" id="c-41853874" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#41851912">next</a><span>|</span><label class="collapse" for="c-41853874">[-]</label><label class="expand" for="c-41853874">[18 more]</label></div><br/><div class="children"><div class="content">Decades ago Linus Torvalds was asked in an interview if he feared Linux to be replaced by something new. His answer was that some day someone young and hungry would
come along, but unless they liked writing device drivers Linux would be safe.<p>This is all paraphrased from my memory, so take it with a grain of salt. I think the gist of it is still valid: Projects like Asterinas are interesting and have a place, but they will not replace Linux as we have it today.<p>(Asterinas, from what I understood, doesn&#x27;t claim to replace Linux, but it a common expectation.)</div><br/><div id="41853994" class="c"><input type="checkbox" id="c-41853994" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41853874">parent</a><span>|</span><a href="#41854663">next</a><span>|</span><label class="collapse" for="c-41853994">[-]</label><label class="expand" for="c-41853994">[8 more]</label></div><br/><div class="children"><div class="content">More recently, in a similar vein:<p>&gt; Torvalds seemed optimistic that &quot;some clueless young person will decide &#x27;how hard can it be?&#x27;&quot; and start their own operating system in Rust or some other language. If they keep at it &quot;for many, many decades&quot;, they may get somewhere; &quot;I am looking forward to seeing that&quot;. Hohndel clarified that by &quot;clueless&quot;, Torvalds was referring to his younger self; &quot;Oh, absolutely, yeah, you have to be all kinds of stupid to say &#x27;I can do this&#x27;&quot;, he said to more laughter. He could not have done it without the &quot;literally tens of thousands of other people&quot;; the &quot;only reason I ever started was that I didn&#x27;t know how hard it would be, but that&#x27;s what makes it fun&quot;.<p><a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;990534&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;990534&#x2F;</a></div><br/><div id="41854434" class="c"><input type="checkbox" id="c-41854434" checked=""/><div class="controls bullet"><span class="by">ackfoobar</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41853994">parent</a><span>|</span><a href="#41855771">next</a><span>|</span><label class="collapse" for="c-41854434">[-]</label><label class="expand" for="c-41854434">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Hohndel clarified that by &quot;clueless&quot;, Torvalds was referring to his younger self<p>As the saying goes &quot;We do this not because it is easy, but because we thought it would be easy.&quot;<p>Occasionally these are starts of great things.</div><br/><div id="41855060" class="c"><input type="checkbox" id="c-41855060" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41854434">parent</a><span>|</span><a href="#41855771">next</a><span>|</span><label class="collapse" for="c-41855060">[-]</label><label class="expand" for="c-41855060">[2 more]</label></div><br/><div class="children"><div class="content">Sometimes, we do such things because it’s hard. We enjoy the challenge. Those that succeed are glad to make it, too.</div><br/><div id="41856792" class="c"><input type="checkbox" id="c-41856792" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41855060">parent</a><span>|</span><a href="#41855771">next</a><span>|</span><label class="collapse" for="c-41856792">[-]</label><label class="expand" for="c-41856792">[1 more]</label></div><br/><div class="children"><div class="content">but most times, even in such cases, people underestimate or not estimate at all the &quot;hard task they do as a challenge&quot; it&#x27;s kinda part of the whole thing</div><br/></div></div></div></div></div></div><div id="41855771" class="c"><input type="checkbox" id="c-41855771" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41853994">parent</a><span>|</span><a href="#41854434">prev</a><span>|</span><a href="#41854663">next</a><span>|</span><label class="collapse" for="c-41855771">[-]</label><label class="expand" for="c-41855771">[4 more]</label></div><br/><div class="children"><div class="content">&quot;You are enthusiastic and write kernel device drivers in rust.  Write a device driver for an Intel i350 4 Port gigabit ethernet controller&quot;</div><br/><div id="41856263" class="c"><input type="checkbox" id="c-41856263" checked=""/><div class="controls bullet"><span class="by">NetOpWibby</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41855771">parent</a><span>|</span><a href="#41854663">next</a><span>|</span><label class="collapse" for="c-41856263">[-]</label><label class="expand" for="c-41856263">[3 more]</label></div><br/><div class="children"><div class="content">Some future VC-funded company will unironically have this same requirement</div><br/><div id="41856298" class="c"><input type="checkbox" id="c-41856298" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41856263">parent</a><span>|</span><a href="#41854663">next</a><span>|</span><label class="collapse" for="c-41856298">[-]</label><label class="expand" for="c-41856298">[2 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t a requirement, it was a prompt :)</div><br/><div id="41856453" class="c"><input type="checkbox" id="c-41856453" checked=""/><div class="controls bullet"><span class="by">NetOpWibby</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41856298">parent</a><span>|</span><a href="#41854663">next</a><span>|</span><label class="collapse" for="c-41856453">[-]</label><label class="expand" for="c-41856453">[1 more]</label></div><br/><div class="children"><div class="content">Haha damn, it’s so obvious now. I should be asleep.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41854663" class="c"><input type="checkbox" id="c-41854663" checked=""/><div class="controls bullet"><span class="by">linsomniac</span><span>|</span><a href="#41853874">parent</a><span>|</span><a href="#41853994">prev</a><span>|</span><a href="#41856026">next</a><span>|</span><label class="collapse" for="c-41854663">[-]</label><label class="expand" for="c-41854663">[5 more]</label></div><br/><div class="children"><div class="content">I feel like there&#x27;s a potentially large audience for a kernel that targets running in a VM.  For a lot of workloads, a simple VM kernel could be a win.</div><br/><div id="41856571" class="c"><input type="checkbox" id="c-41856571" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41854663">parent</a><span>|</span><a href="#41855296">next</a><span>|</span><label class="collapse" for="c-41856571">[-]</label><label class="expand" for="c-41856571">[1 more]</label></div><br/><div class="children"><div class="content">This is already the reality today with native cloud computing, managed runtimes.<p>It doesn&#x27;t matter how the language gets deployed, if the runtime is on a container, a distroless container, or directly running on an hypervisor.<p>The runtime provides enough OS like services for the programming language purposes.</div><br/></div></div><div id="41855296" class="c"><input type="checkbox" id="c-41855296" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41854663">parent</a><span>|</span><a href="#41856571">prev</a><span>|</span><a href="#41856026">next</a><span>|</span><label class="collapse" for="c-41855296">[-]</label><label class="expand" for="c-41855296">[3 more]</label></div><br/><div class="children"><div class="content">How is that different from Linux with all virtio drivers? (You can just not compile real hardware drivers)</div><br/><div id="41855781" class="c"><input type="checkbox" id="c-41855781" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41855296">parent</a><span>|</span><a href="#41856026">next</a><span>|</span><label class="collapse" for="c-41855781">[-]</label><label class="expand" for="c-41855781">[2 more]</label></div><br/><div class="children"><div class="content">I would imagine that virtualized device drivers would have a well-defined api and vastly simplified logic.</div><br/><div id="41855928" class="c"><input type="checkbox" id="c-41855928" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41855781">parent</a><span>|</span><a href="#41856026">next</a><span>|</span><label class="collapse" for="c-41855928">[-]</label><label class="expand" for="c-41855928">[1 more]</label></div><br/><div class="children"><div class="content">I imagine they do. But given that Linux has those simple drivers, why not use them?</div><br/></div></div></div></div></div></div></div></div><div id="41856026" class="c"><input type="checkbox" id="c-41856026" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#41853874">parent</a><span>|</span><a href="#41854663">prev</a><span>|</span><a href="#41851912">next</a><span>|</span><label class="collapse" for="c-41856026">[-]</label><label class="expand" for="c-41856026">[4 more]</label></div><br/><div class="children"><div class="content">Also this mysterious new Fuchsia OS from Google is also shooting for full Linux compatibility and is about to show up in Android, I think this is a much more realistic path of the next generation of operating systems that have a real chance to replace Linux but who knows what their actual plans are here at the moment but I don’t believe for a moment that that project is dead in any way.</div><br/><div id="41856686" class="c"><input type="checkbox" id="c-41856686" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41856026">parent</a><span>|</span><a href="#41856213">next</a><span>|</span><label class="collapse" for="c-41856686">[-]</label><label class="expand" for="c-41856686">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if decision for stable syscalls was genius? Like imagine that Linux syscalls will become what C ABI is now. And there will be multiple compatible kernels, so you can choose any and run the same userspace.</div><br/></div></div><div id="41856213" class="c"><input type="checkbox" id="c-41856213" checked=""/><div class="controls bullet"><span class="by">lifty</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41856026">parent</a><span>|</span><a href="#41856686">prev</a><span>|</span><a href="#41851912">next</a><span>|</span><label class="collapse" for="c-41856213">[-]</label><label class="expand" for="c-41856213">[2 more]</label></div><br/><div class="children"><div class="content">Can you give more details about it being used in Android? I thought they started using it in some small devices like nest but haven’t heard anything about Android</div><br/><div id="41856824" class="c"><input type="checkbox" id="c-41856824" checked=""/><div class="controls bullet"><span class="by">mdhb</span><span>|</span><a href="#41853874">root</a><span>|</span><a href="#41856213">parent</a><span>|</span><a href="#41851912">next</a><span>|</span><label class="collapse" for="c-41856824">[-]</label><label class="expand" for="c-41856824">[1 more]</label></div><br/><div class="children"><div class="content">It’s about to turn up inside Android running in a VM [1]  but it was less clear exactly for what purpose.<p>My theory is that this is essentially a long term project to bring the core of Chrome OS and Android to rely on Fuschia for its core which gives them syscall level compatibility with what they both use at the moment and that they would both essentially sit as products on top of that.<p>This is essentially the exact strategy they used if I remember correctly with the Nest devices where they swapped out the core and left the product on top entirely unchanged. Beyond that in a longer term scenario we might also just see a Fuchsia OS as a combined mobile &#x2F; desktop workstation setup and I think part of that is also why we are seeing ChromeOS starting to take a dependency on Android’s networking stack as well right now.<p>[1] <a href="https:&#x2F;&#x2F;www.androidauthority.com&#x2F;microfuchsia-on-android-3457788&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.androidauthority.com&#x2F;microfuchsia-on-android-345...</a></div><br/></div></div></div></div></div></div></div></div><div id="41851912" class="c"><input type="checkbox" id="c-41851912" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41853874">prev</a><span>|</span><a href="#41853080">next</a><span>|</span><label class="collapse" for="c-41851912">[-]</label><label class="expand" for="c-41851912">[19 more]</label></div><br/><div class="children"><div class="content">I personally dislike rust,  but I love kernels,  and so I&#x27;ll always check these projects out.<p>This is one of the nicer ones.<p>It looks pretty conservative in it&#x27;s use of Rust&#x27;s advanced features.  The code looks pretty easy to read and follow.  There&#x27;s actually a decent amount of comments (for rust code).<p>Not bad!</div><br/><div id="41855386" class="c"><input type="checkbox" id="c-41855386" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#41851912">parent</a><span>|</span><a href="#41852794">next</a><span>|</span><label class="collapse" for="c-41855386">[-]</label><label class="expand" for="c-41855386">[11 more]</label></div><br/><div class="children"><div class="content">Otherwise is a decent language but what makes it difficult is the borrow semantics and lifetimes. Lifetimes are more complicated to get your head around.<p>But then there&#x27;s this Arc, Ref, Pinning and what not - how deep is that rabbit hole?</div><br/><div id="41856204" class="c"><input type="checkbox" id="c-41856204" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41855386">parent</a><span>|</span><a href="#41855987">next</a><span>|</span><label class="collapse" for="c-41856204">[-]</label><label class="expand" for="c-41856204">[5 more]</label></div><br/><div class="children"><div class="content">If you’re writing C and don’t track ownership of values, you’re in a world of hurt. Rust makes you do from day one what you could do in C but unless you have years of experience you think it isn’t necessary.</div><br/><div id="41856786" class="c"><input type="checkbox" id="c-41856786" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41856204">parent</a><span>|</span><a href="#41856314">next</a><span>|</span><label class="collapse" for="c-41856786">[-]</label><label class="expand" for="c-41856786">[1 more]</label></div><br/><div class="children"><div class="content">Okay, I think it is is more like Typescript. You hate it but one day you just write small JS program and convert it to Typescript to discover that static analysis alone had so many code paths revealed that would have resulted in uncaught errors and then you always feel very uncomfortable writing plain Javascript.<p>But what about tools like valgrind in context of C?</div><br/></div></div><div id="41856314" class="c"><input type="checkbox" id="c-41856314" checked=""/><div class="controls bullet"><span class="by">metalloid</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41856204">parent</a><span>|</span><a href="#41856786">prev</a><span>|</span><a href="#41855987">next</a><span>|</span><label class="collapse" for="c-41856314">[-]</label><label class="expand" for="c-41856314">[3 more]</label></div><br/><div class="children"><div class="content">It was true until LLMs arrive.
Feature compilers + IDEs can be integrated with LLMs to help programmers.<p>Rust was a great idea, before LLMs, but I don&#x27;t see the motivation for Rust when LLMs can be the solution initial for C&#x2F;C++ &#x27;problems&#x27;.</div><br/><div id="41856419" class="c"><input type="checkbox" id="c-41856419" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41856314">parent</a><span>|</span><a href="#41856391">next</a><span>|</span><label class="collapse" for="c-41856419">[-]</label><label class="expand" for="c-41856419">[1 more]</label></div><br/><div class="children"><div class="content">Relying on LLMs to code for you in no way solves the safety problem of C&#x2F;C++ and probably worsens it.</div><br/></div></div><div id="41856391" class="c"><input type="checkbox" id="c-41856391" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41856314">parent</a><span>|</span><a href="#41856419">prev</a><span>|</span><a href="#41855987">next</a><span>|</span><label class="collapse" for="c-41856391">[-]</label><label class="expand" for="c-41856391">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary LLMs make using safe but constraining languages easier - you can just ask it how to do what you want in Rust, perhaps even by asking it to translate C-ish pseudocode.</div><br/></div></div></div></div></div></div><div id="41855987" class="c"><input type="checkbox" id="c-41855987" checked=""/><div class="controls bullet"><span class="by">oneshtein</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41855386">parent</a><span>|</span><a href="#41856204">prev</a><span>|</span><a href="#41856588">next</a><span>|</span><label class="collapse" for="c-41855987">[-]</label><label class="expand" for="c-41855987">[1 more]</label></div><br/><div class="children"><div class="content">Rust lifetime is just a label for a region of memory with various data, which is discarded at the end of its life time. When compiler enters a function, it creates a memory block to hold data of all variables in the function, and then discards this block at the exit from the function, so these variables are valid for life time of the function call only.</div><br/></div></div><div id="41856588" class="c"><input type="checkbox" id="c-41856588" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41855386">parent</a><span>|</span><a href="#41855987">prev</a><span>|</span><a href="#41856306">next</a><span>|</span><label class="collapse" for="c-41856588">[-]</label><label class="expand" for="c-41856588">[1 more]</label></div><br/><div class="children"><div class="content">Context: I&#x27;m writing a novel kernel in Rust.<p>Lifetimes aren&#x27;t bad, the learning curve is admittedly a bit high. Post-v1 rust significantly reduced the number of places you need them and a recent update allows you to elide them even more if memory serves.<p>Arc isn&#x27;t any different than other languages, not sure what you&#x27;re referring to by ref but a reference is just a pointer with added semantic guarantees, and Pin isn&#x27;t necessary unless you&#x27;re doing async (not a single Pin shows up in the kernel thus far and I can&#x27;t imagine why I&#x27;d have one going forward).</div><br/></div></div><div id="41856306" class="c"><input type="checkbox" id="c-41856306" checked=""/><div class="controls bullet"><span class="by">oersted</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41855386">parent</a><span>|</span><a href="#41856588">prev</a><span>|</span><a href="#41855995">next</a><span>|</span><label class="collapse" for="c-41856306">[-]</label><label class="expand" for="c-41856306">[1 more]</label></div><br/><div class="children"><div class="content">I don’t entirely agree, you can get used to the borrow checker relatively quickly and you mostly stop thinking about it.<p>What tends to make Rust complex is advanced use of traits, generics, iterators, closures, wrapper types, async, error types… You start getting these massive semi-autogenerated nested types, the syntax sugar starts generating complex logic for you in the background that you cannot see but have to keep in mind.<p>It’s tempting to use the advanced type system to encode and enforce complex API semantics, using Rust almost like a formal verifier &#x2F; theorem prover. But things can easily become overwhelming down that rabbit hole.</div><br/></div></div><div id="41855995" class="c"><input type="checkbox" id="c-41855995" checked=""/><div class="controls bullet"><span class="by">KingOfCoders</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41855386">parent</a><span>|</span><a href="#41856306">prev</a><span>|</span><a href="#41852794">next</a><span>|</span><label class="collapse" for="c-41855995">[-]</label><label class="expand" for="c-41855995">[2 more]</label></div><br/><div class="children"><div class="content">I always feel Arc is the admission that the borrow checker with different&#x2F;overlapping lifetimes is too difficult, despite what many Rust developers - who liberally use Arc - claim.</div><br/><div id="41856058" class="c"><input type="checkbox" id="c-41856058" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41855995">parent</a><span>|</span><a href="#41852794">next</a><span>|</span><label class="collapse" for="c-41856058">[-]</label><label class="expand" for="c-41856058">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that the borrow checker is too difficult, it&#x27;s that it&#x27;s too limiting.<p>The _static_ borrow checker can only check what is _statically_ verifiable, which is but a subset of valid programs. There are few things more frustrating than doing something you know is correct, but that you cannot express in your language.</div><br/></div></div></div></div></div></div><div id="41852794" class="c"><input type="checkbox" id="c-41852794" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41851912">parent</a><span>|</span><a href="#41855386">prev</a><span>|</span><a href="#41853080">next</a><span>|</span><label class="collapse" for="c-41852794">[-]</label><label class="expand" for="c-41852794">[7 more]</label></div><br/><div class="children"><div class="content">Rust code is usually well commented in my experience.</div><br/><div id="41854248" class="c"><input type="checkbox" id="c-41854248" checked=""/><div class="controls bullet"><span class="by">iknowstuff</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41852794">parent</a><span>|</span><a href="#41853577">next</a><span>|</span><label class="collapse" for="c-41854248">[-]</label><label class="expand" for="c-41854248">[3 more]</label></div><br/><div class="children"><div class="content">for the downvoters: it’s true, and it’s because of rustdoc and doctests. comments become publicly browsable documentation, and any code contained within is run as a part of the test suite.</div><br/><div id="41854277" class="c"><input type="checkbox" id="c-41854277" checked=""/><div class="controls bullet"><span class="by">1oooqooq</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41854248">parent</a><span>|</span><a href="#41853577">next</a><span>|</span><label class="collapse" for="c-41854277">[-]</label><label class="expand" for="c-41854277">[2 more]</label></div><br/><div class="children"><div class="content">think the downvotes are because of relevance. point was not using advanced rust features, not being documented</div><br/><div id="41854310" class="c"><input type="checkbox" id="c-41854310" checked=""/><div class="controls bullet"><span class="by">forks</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41854277">parent</a><span>|</span><a href="#41853577">next</a><span>|</span><label class="collapse" for="c-41854310">[-]</label><label class="expand" for="c-41854310">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how the relevance is in question. GGGP said &quot;There&#x27;s actually a decent amount of comments (for rust code).&quot; GGP seems to be responding to that parenthetical.</div><br/></div></div></div></div></div></div><div id="41853577" class="c"><input type="checkbox" id="c-41853577" checked=""/><div class="controls bullet"><span class="by">cies</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41852794">parent</a><span>|</span><a href="#41854248">prev</a><span>|</span><a href="#41853080">next</a><span>|</span><label class="collapse" for="c-41853577">[-]</label><label class="expand" for="c-41853577">[3 more]</label></div><br/><div class="children"><div class="content">Instead of asking &quot;what other languages and project (open&#x2F;closed, big&#x2F;small, web&#x2F;mobile&#x2F;desktop, game&#x2F;consumerapp&#x2F;bizapp) have you experience with as to come to this conclusion?&quot; people down vote you.<p>So lemme ask: what other languages and project (open&#x2F;closed, big&#x2F;small, web&#x2F;mobile&#x2F;desktop, game&#x2F;consumerapp&#x2F;bizapp) have you experience with as to come to this conclusion?</div><br/><div id="41854119" class="c"><input type="checkbox" id="c-41854119" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#41851912">root</a><span>|</span><a href="#41853577">parent</a><span>|</span><a href="#41853586">next</a><span>|</span><label class="collapse" for="c-41854119">[-]</label><label class="expand" for="c-41854119">[1 more]</label></div><br/><div class="children"><div class="content">I expect the downvotes to be there because it&#x27;s talking positively about rust, which is blasphemy! &#x2F;j</div><br/></div></div></div></div></div></div></div></div><div id="41853080" class="c"><input type="checkbox" id="c-41853080" checked=""/><div class="controls bullet"><span class="by">justmarc</span><span>|</span><a href="#41851912">prev</a><span>|</span><a href="#41854339">next</a><span>|</span><label class="collapse" for="c-41853080">[-]</label><label class="expand" for="c-41853080">[25 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested in these kind of kernels to run very high performance network&#x2F;IO specific services on bare metal, with minimal system complexity&#x2F;overheads and hopefully better (potential) stability and security.<p>The big concern I have however is hardware support, specifically networking hardware.<p>I think a very interesting approach would be to boot the machine with a FreeBSD or Linux kernel, just for the purposes of hardware as well as network support, and use a sort of Rust OS&#x2F;abstraction layer for the rest, bypassing or simply not using the originally booted kernel for all user land specific stuff.</div><br/><div id="41853724" class="c"><input type="checkbox" id="c-41853724" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#41853080">parent</a><span>|</span><a href="#41853348">next</a><span>|</span><label class="collapse" for="c-41853724">[-]</label><label class="expand" for="c-41853724">[3 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t you just boot the Linux kernel directly and launch a generic app as pid 1 instead of a full blown init system with a bunch of daemons?<p>That&#x27;s basically what you&#x27;re getting with Docker containers and a shared kernel. AWS Lambda is doing something similar with dedicated kernels with Firecracker VMs</div><br/><div id="41855864" class="c"><input type="checkbox" id="c-41855864" checked=""/><div class="controls bullet"><span class="by">justmarc</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853724">parent</a><span>|</span><a href="#41853792">next</a><span>|</span><label class="collapse" for="c-41855864">[-]</label><label class="expand" for="c-41855864">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but I wanted to bypass having the complexity of the Linux kernel completely, too.<p>Basically single app directly to network (the world) and as little as possible else in between.</div><br/></div></div><div id="41853792" class="c"><input type="checkbox" id="c-41853792" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853724">parent</a><span>|</span><a href="#41855864">prev</a><span>|</span><a href="#41853348">next</a><span>|</span><label class="collapse" for="c-41853792">[-]</label><label class="expand" for="c-41853792">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you can.  You can even have a different Pid 1 configure whatever and then replace it&#x27;s core image with the new Pid 1.</div><br/></div></div></div></div><div id="41853348" class="c"><input type="checkbox" id="c-41853348" checked=""/><div class="controls bullet"><span class="by">cgh</span><span>|</span><a href="#41853080">parent</a><span>|</span><a href="#41853724">prev</a><span>|</span><a href="#41853111">next</a><span>|</span><label class="collapse" for="c-41853348">[-]</label><label class="expand" for="c-41853348">[8 more]</label></div><br/><div class="children"><div class="content">If you want truly high-performance networking, you can bypass the kernel altogether with DPDK. So you don&#x27;t have to worry about alternative kernels for other tasks at all. On the downside, DPDK takes over the NIC entirely, removing the kernel from the equation, so if you need the kernel to see network traffic for some reason, it won&#x27;t work for you.<p>You can check out hardware support here: <a href="https:&#x2F;&#x2F;core.dpdk.org&#x2F;supported&#x2F;nics&#x2F;" rel="nofollow">https:&#x2F;&#x2F;core.dpdk.org&#x2F;supported&#x2F;nics&#x2F;</a></div><br/><div id="41853538" class="c"><input type="checkbox" id="c-41853538" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853348">parent</a><span>|</span><a href="#41853111">next</a><span>|</span><label class="collapse" for="c-41853538">[-]</label><label class="expand" for="c-41853538">[7 more]</label></div><br/><div class="children"><div class="content">This was true a decade ago, with modern io_uring dpdk is probably an anti-pattern.</div><br/><div id="41853574" class="c"><input type="checkbox" id="c-41853574" checked=""/><div class="controls bullet"><span class="by">cgh</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853538">parent</a><span>|</span><a href="#41854804">next</a><span>|</span><label class="collapse" for="c-41853574">[-]</label><label class="expand" for="c-41853574">[5 more]</label></div><br/><div class="children"><div class="content">Interesting, it&#x27;s been awhile since I looked at this stuff so I did a little searching and found this: <a href="https:&#x2F;&#x2F;www.diva-portal.org&#x2F;smash&#x2F;get&#x2F;diva2:1789103&#x2F;FULLTEXT01.pdf" rel="nofollow">https:&#x2F;&#x2F;www.diva-portal.org&#x2F;smash&#x2F;get&#x2F;diva2:1789103&#x2F;FULLTEXT...</a><p>Their conclusion is io_uring is still slower but not by much, and future improvements may make the difference negligible. So you&#x27;re right, at least in part. Given the tradeoffs, DPDK may not be worth it anymore.</div><br/><div id="41856892" class="c"><input type="checkbox" id="c-41856892" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853574">parent</a><span>|</span><a href="#41854008">next</a><span>|</span><label class="collapse" for="c-41856892">[-]</label><label class="expand" for="c-41856892">[1 more]</label></div><br/><div class="children"><div class="content">&quot;io_uring had a maximum throughput of 5.0 Gbit&#x2F;s &quot;<p>Wut?  More than 10 years ago, a cheap beige box could saturated a 1Gbps link with a kernel as it came from e.g. Debian w&#x2F;o special tuning.  A somewhat more expensive box could get a good share of a 10Gbps link (using Jumbo frames), so these new results are, er, somewhat underwhelming.</div><br/></div></div><div id="41854008" class="c"><input type="checkbox" id="c-41854008" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853574">parent</a><span>|</span><a href="#41856892">prev</a><span>|</span><a href="#41856769">next</a><span>|</span><label class="collapse" for="c-41854008">[-]</label><label class="expand" for="c-41854008">[1 more]</label></div><br/><div class="children"><div class="content">There are also just a bunch of operational hassles with using DPDK or SPDK.  Your usual administrative commands don&#x27;t work.  Other operations aren&#x27;t intermediated by the kernel -- instead you need 100% dedicated application devices.  Device counters usually tracked by the kernel aren&#x27;t.  Etc.  It can be fine, but if io_uring doesn&#x27;t add too much overhead, it&#x27;s a lot more convenient.</div><br/></div></div><div id="41856769" class="c"><input type="checkbox" id="c-41856769" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853574">parent</a><span>|</span><a href="#41854008">prev</a><span>|</span><a href="#41856349">next</a><span>|</span><label class="collapse" for="c-41856769">[-]</label><label class="expand" for="c-41856769">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting and valuable study.  I was slightly disappointed though that only a single host was used in the &#x27;network&#x27; performance tests:<p>&quot;SR-IOV was used on the NIC to enable the use of virtual functions, as it was the only NIC that was available during the study for testing and therefore the use of virtual functions was a necessity for conducting the experiments.&quot;</div><br/></div></div><div id="41856349" class="c"><input type="checkbox" id="c-41856349" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853574">parent</a><span>|</span><a href="#41856769">prev</a><span>|</span><a href="#41854804">next</a><span>|</span><label class="collapse" for="c-41856349">[-]</label><label class="expand" for="c-41856349">[1 more]</label></div><br/><div class="children"><div class="content">Not by much?? You&#x27;re exaggerating..</div><br/></div></div></div></div><div id="41854804" class="c"><input type="checkbox" id="c-41854804" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853538">parent</a><span>|</span><a href="#41853574">prev</a><span>|</span><a href="#41853111">next</a><span>|</span><label class="collapse" for="c-41854804">[-]</label><label class="expand" for="c-41854804">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure that&#x27;s true for a good chunk of the workloads that dpdk really shines on.<p>A lot of the benefit of dpdk is colocating your data and network stack in the same virtual memory context.  io_uring I can see getting you there if you have you&#x27;re serving fixed files as a cdn kind of like netflix&#x27;s appliances, but for cases where you&#x27;re actually doing branchy work on the individual requests, dpdk is probably a little easier to scale up to the faster network cards.</div><br/></div></div></div></div></div></div><div id="41853111" class="c"><input type="checkbox" id="c-41853111" checked=""/><div class="controls bullet"><span class="by">treeshateorcs</span><span>|</span><a href="#41853080">parent</a><span>|</span><a href="#41853348">prev</a><span>|</span><a href="#41855929">next</a><span>|</span><label class="collapse" for="c-41853111">[-]</label><label class="expand" for="c-41853111">[12 more]</label></div><br/><div class="children"><div class="content">i might be wrong but if it&#x27;s ABI compatible the same drivers will work?<p>p.s.: i was wrong<p>&gt;While we prioritize compatibility, it is important to note that Asterinas does not, nor will it in the future, support the loading of Linux kernel modules.<p><a href="https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;linux-compatibility.html" rel="nofollow">https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;linux-compatibility....</a></div><br/><div id="41856891" class="c"><input type="checkbox" id="c-41856891" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853111">parent</a><span>|</span><a href="#41853386">next</a><span>|</span><label class="collapse" for="c-41856891">[-]</label><label class="expand" for="c-41856891">[1 more]</label></div><br/><div class="children"><div class="content">in general the ABI is kernel&lt;-&gt;user space while the ABI (and potentially even API) on the inside (i.e. for drivers) can change with every kernel version (part of why it&#x27;s so important to maintain drivers in-tree)</div><br/></div></div><div id="41853386" class="c"><input type="checkbox" id="c-41853386" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853111">parent</a><span>|</span><a href="#41856891">prev</a><span>|</span><a href="#41853164">next</a><span>|</span><label class="collapse" for="c-41853386">[-]</label><label class="expand" for="c-41853386">[5 more]</label></div><br/><div class="children"><div class="content">Linux doesn&#x27;t even maintain ABI compatibility with <i>itself</i>, nobody else is going to manage it. The possibility that might work is there&#x27;s a couple projects that maintain just enough A<i>P</i>I compatibility to reuse driver code from Linux (IIRC FreeBSD does this for some graphics drivers). But even then you&#x27;re gambling with whether Linux decides to change implementation details one day, since internal APIs explicitly aren&#x27;t stable.</div><br/><div id="41853663" class="c"><input type="checkbox" id="c-41853663" checked=""/><div class="controls bullet"><span class="by">bcrl</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853386">parent</a><span>|</span><a href="#41853164">next</a><span>|</span><label class="collapse" for="c-41853663">[-]</label><label class="expand" for="c-41853663">[4 more]</label></div><br/><div class="children"><div class="content">The Linux kernel community takes ABI compatibility for userland very seriously.  That developers in userland are frequently unwilling to understand issues surrounding ABI stability is not the fault of the Linux kernel.</div><br/><div id="41853839" class="c"><input type="checkbox" id="c-41853839" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853663">parent</a><span>|</span><a href="#41853164">next</a><span>|</span><label class="collapse" for="c-41853839">[-]</label><label class="expand" for="c-41853839">[3 more]</label></div><br/><div class="children"><div class="content">Oh sure, the user-space ABI is stable; I meant kernel-space. Although I realize now that I failed to write that explicitly.</div><br/><div id="41854385" class="c"><input type="checkbox" id="c-41854385" checked=""/><div class="controls bullet"><span class="by">bcrl</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853839">parent</a><span>|</span><a href="#41853164">next</a><span>|</span><label class="collapse" for="c-41854385">[-]</label><label class="expand" for="c-41854385">[2 more]</label></div><br/><div class="children"><div class="content">The past 30 years of the Linux kernel&#x27;s evolution has proven that there is no need for a stable kernel ABI.  That would make refactoring, adding new features and porting to new platforms exceedingly difficult.  Pretty much all of the proprietary kernel modules have either become open source or been replaced by open source replacements.  The Linux community doesn&#x27;t need closed source kernel modules for VMWare anymore, and even Nvidia has finally given up on their closed source GPU drivers.  Proprietary Linux kernel modules have no place in the modern world.</div><br/><div id="41854526" class="c"><input type="checkbox" id="c-41854526" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41854385">parent</a><span>|</span><a href="#41853164">next</a><span>|</span><label class="collapse" for="c-41854526">[-]</label><label class="expand" for="c-41854526">[1 more]</label></div><br/><div class="children"><div class="content">&gt; even Nvidia has finally given up on their closed source GPU drivers.<p>lol. No. They just added a CPU and then offloaded all the closed source userspace driver code to it leaving behind the same dumb open sourceable kernel driver shim as before (ie instead of talking to userspace it talks to the GPU’s CPU).<p>&gt; The past 30 years of the Linux kernel&#x27;s evolution has proven that there is no need for a stable kernel ABI.<p>What the last 30 years have shown is that there is actually a need for it, otherwise DKMS wouldn’t be a thing. Heck, intel’s performance profiler can’t keep up with the kernel changes which means you get to pick running an up to date kernel or be able to use the open source out-of-tree kernel module. The fact that Linux is alone in this should make it clear it’s wrong. Heck Android even wrote their own HAL to try to make it possible to update the kernel on older devices. It’s an economics problem that the Linux kernel gets to pretend doesn’t exist but it’s a bad philosophical position. It’s possible to support refactoring and porting to new platforms while providing ABI compatibility and Linux is way past the point where it would even be a minor inconvenience - all the code has ossified quite a bit anyway.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41853164" class="c"><input type="checkbox" id="c-41853164" checked=""/><div class="controls bullet"><span class="by">bicolao</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853111">parent</a><span>|</span><a href="#41853386">prev</a><span>|</span><a href="#41853156">next</a><span>|</span><label class="collapse" for="c-41853164">[-]</label><label class="expand" for="c-41853164">[4 more]</label></div><br/><div class="children"><div class="content">They mention this in <a href="https:&#x2F;&#x2F;github.com&#x2F;asterinas&#x2F;asterinas&#x2F;blob&#x2F;2af9916de92f8ca1e694bb6ac5e33111bbcf51fd&#x2F;docs&#x2F;src&#x2F;kernel&#x2F;linux-compatibility.md?plain=1#L7">https:&#x2F;&#x2F;github.com&#x2F;asterinas&#x2F;asterinas&#x2F;blob&#x2F;2af9916de92f8ca1...</a><p>&gt; While we prioritize compatibility, it is important to note that Asterinas does not,
nor will it in the future, support the loading of Linux kernel modules.</div><br/><div id="41853210" class="c"><input type="checkbox" id="c-41853210" checked=""/><div class="controls bullet"><span class="by">justmarc</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853164">parent</a><span>|</span><a href="#41853156">next</a><span>|</span><label class="collapse" for="c-41853210">[-]</label><label class="expand" for="c-41853210">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a lot &quot;simpler&quot; to support a Linux userland as that means one needs to &quot;just&quot; emulate all the Linux syscalls, than to implement the literally countless internal APIs needed for drivers etc, as that would otherwise mean literally reimplementing the whole Linux kernel and that&#x27;s neither realistic, nor too useful.</div><br/><div id="41855503" class="c"><input type="checkbox" id="c-41855503" checked=""/><div class="controls bullet"><span class="by">mgerdts</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853210">parent</a><span>|</span><a href="#41853652">next</a><span>|</span><label class="collapse" for="c-41855503">[-]</label><label class="expand" for="c-41855503">[1 more]</label></div><br/><div class="children"><div class="content">And that’s not all that simple, as has been experienced by Solaris (never released(?) Linux branded zones, illumos (lx brand), and Windows (WSL1) developers that have tried to make existing kernels act like Linux.<p>It’s probably easier if the kernel’s key goal is to be compatible with the Linux ABI rather than being compatible with its earlier self while bolting on Linux compatibility.</div><br/></div></div><div id="41853652" class="c"><input type="checkbox" id="c-41853652" checked=""/><div class="controls bullet"><span class="by">Jyaif</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853210">parent</a><span>|</span><a href="#41855503">prev</a><span>|</span><a href="#41853156">next</a><span>|</span><label class="collapse" for="c-41853652">[-]</label><label class="expand" for="c-41853652">[1 more]</label></div><br/><div class="children"><div class="content">&gt; emulate all the Linux syscalls<p>and emulate the virtual filesystems (&#x2F;proc&#x2F;...)</div><br/></div></div></div></div></div></div><div id="41853156" class="c"><input type="checkbox" id="c-41853156" checked=""/><div class="controls bullet"><span class="by">justmarc</span><span>|</span><a href="#41853080">root</a><span>|</span><a href="#41853111">parent</a><span>|</span><a href="#41853164">prev</a><span>|</span><a href="#41855929">next</a><span>|</span><label class="collapse" for="c-41853156">[-]</label><label class="expand" for="c-41853156">[1 more]</label></div><br/><div class="children"><div class="content">No, it means you can run Linux userland&#x2F;apps on this kernel, to the level&#x2F;depth which they currently support of course.<p>They might not yet implement everything that&#x27;s needed to boot a standard Linux userland but you could say boot straight into a web server built for Linux, instead of booting into init for example.</div><br/></div></div></div></div><div id="41855929" class="c"><input type="checkbox" id="c-41855929" checked=""/><div class="controls bullet"><span class="by">protoman3000</span><span>|</span><a href="#41853080">parent</a><span>|</span><a href="#41853111">prev</a><span>|</span><a href="#41854339">next</a><span>|</span><label class="collapse" for="c-41855929">[-]</label><label class="expand" for="c-41855929">[1 more]</label></div><br/><div class="children"><div class="content">Why don’t you just use a SmartNIC and P4? It won’t get faster than running on the NIC itself</div><br/></div></div></div></div><div id="41854339" class="c"><input type="checkbox" id="c-41854339" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#41853080">prev</a><span>|</span><a href="#41856581">next</a><span>|</span><label class="collapse" for="c-41854339">[-]</label><label class="expand" for="c-41854339">[6 more]</label></div><br/><div class="children"><div class="content">I think this looks incredible. Like how does one create a compatible abi _for all of linux_??? Wow!<p>&gt; utilize the more productive Rust programming language<p>Nitpick: it’s 2024 and these ‘more productive’  comparisons are silly, completely unscientific, And a bit of a red flag for your project: The most productive language for a developer is the one they understand what is happening one layer below the level of abstraction they are working with. Unless you’re comparing something rating Ruby vs RiscV assembly, it’s just hocus-pocus.</div><br/><div id="41855895" class="c"><input type="checkbox" id="c-41855895" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#41854339">parent</a><span>|</span><a href="#41855189">next</a><span>|</span><label class="collapse" for="c-41855895">[-]</label><label class="expand" for="c-41855895">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I think this looks incredible. Like how does one create a compatible abi _for all of linux_??? Wow!<p>FWIW that’s what the Linux compatibility layer in the BSDs does and also what WSL 1 did (<a href="https:&#x2F;&#x2F;jmmv.dev&#x2F;2020&#x2F;11&#x2F;wsl-lost-potential.html" rel="nofollow">https:&#x2F;&#x2F;jmmv.dev&#x2F;2020&#x2F;11&#x2F;wsl-lost-potential.html</a>).<p>It’s hard to get _everything_ perfectly right but not that difficult to get most of it working.</div><br/><div id="41856068" class="c"><input type="checkbox" id="c-41856068" checked=""/><div class="controls bullet"><span class="by">NewJazz</span><span>|</span><a href="#41854339">root</a><span>|</span><a href="#41855895">parent</a><span>|</span><a href="#41855189">next</a><span>|</span><label class="collapse" for="c-41856068">[-]</label><label class="expand" for="c-41856068">[1 more]</label></div><br/><div class="children"><div class="content">IIRC Fuschia has something similar. And maybe Redox?</div><br/></div></div></div></div><div id="41855189" class="c"><input type="checkbox" id="c-41855189" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41854339">parent</a><span>|</span><a href="#41855895">prev</a><span>|</span><a href="#41854435">next</a><span>|</span><label class="collapse" for="c-41855189">[-]</label><label class="expand" for="c-41855189">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Like how does one create a compatible abi _for all of linux_???</i><p>You look at Linux&#x27;s syscall table[0], read through the documentation to figure out the arguments, data types, flags, return values, etc., and then implement that in your kernel.  The Linux ABI is just its &quot;library&quot; interface to userspace.<p>It&#x27;s probably not <i>that</i> difficult; writing the rest of the kernel itself is more challenging, and, frankly, more interesting.  Certainly matching behavior and semantics can be tricky sometimes, I&#x27;m sure.  And I wouldn&#x27;t be surprised if the initial implementation of some things (like io_uring, for example, if it&#x27;s even supported yet) might be primitive and poorly optimized, or might even use other syscalls to do their work.<p>But it&#x27;s doable.  While Linux&#x27;s <i>internal</i> ABI is unstable, the syscall interface is sacred.  One of Torvalds&#x27; golden rules is you don&#x27;t break userspace.<p>[0] <a href="https:&#x2F;&#x2F;filippo.io&#x2F;linux-syscall-table&#x2F;" rel="nofollow">https:&#x2F;&#x2F;filippo.io&#x2F;linux-syscall-table&#x2F;</a></div><br/></div></div><div id="41854435" class="c"><input type="checkbox" id="c-41854435" checked=""/><div class="controls bullet"><span class="by">ozgrakkurt</span><span>|</span><a href="#41854339">parent</a><span>|</span><a href="#41855189">prev</a><span>|</span><a href="#41856581">next</a><span>|</span><label class="collapse" for="c-41854435">[-]</label><label class="expand" for="c-41854435">[2 more]</label></div><br/><div class="children"><div class="content">Everyone says what they are used to is better or more productive. Even in assembly vs ruby, some stuff are much easier in assembly and maybe impossible in ruby afaik</div><br/><div id="41854559" class="c"><input type="checkbox" id="c-41854559" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#41854339">root</a><span>|</span><a href="#41854435">parent</a><span>|</span><a href="#41856581">next</a><span>|</span><label class="collapse" for="c-41854559">[-]</label><label class="expand" for="c-41854559">[1 more]</label></div><br/><div class="children"><div class="content">I’m aging myself, but ~17 years ago I was in San Diego for a conference. There was a table level competition to see who could write the fastest program in 20 minutes (we were doing a full text search of a ‘giant’ 5g file). One of the guys at the table wrote some SPARC assembly to optimize character matching that was a hotspot like he was speaking French.<p>Ah good times.</div><br/></div></div></div></div></div></div><div id="41856581" class="c"><input type="checkbox" id="c-41856581" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41854339">prev</a><span>|</span><a href="#41851369">next</a><span>|</span><label class="collapse" for="c-41856581">[-]</label><label class="expand" for="c-41856581">[1 more]</label></div><br/><div class="children"><div class="content">Besides all examples, Microsoft is now using TockOS for Pluton firmware, another Rust based OS.<p><a href="https:&#x2F;&#x2F;tockos.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tockos.org&#x2F;</a></div><br/></div></div><div id="41851369" class="c"><input type="checkbox" id="c-41851369" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#41856581">prev</a><span>|</span><a href="#41854258">next</a><span>|</span><label class="collapse" for="c-41851369">[-]</label><label class="expand" for="c-41851369">[4 more]</label></div><br/><div class="children"><div class="content">OT: if you&#x27;re interested in Asterinas, you might also be interested in Redox (entire OS written in Rust).<p><a href="https:&#x2F;&#x2F;www.redox-os.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.redox-os.org&#x2F;</a></div><br/><div id="41854346" class="c"><input type="checkbox" id="c-41854346" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#41851369">parent</a><span>|</span><a href="#41851590">next</a><span>|</span><label class="collapse" for="c-41854346">[-]</label><label class="expand" for="c-41854346">[1 more]</label></div><br/><div class="children"><div class="content">Redox has a proper architecture, aka microkernel multiserver.<p>Thus it is a much more interesting project.</div><br/></div></div><div id="41851590" class="c"><input type="checkbox" id="c-41851590" checked=""/><div class="controls bullet"><span class="by">metaketa</span><span>|</span><a href="#41851369">parent</a><span>|</span><a href="#41854346">prev</a><span>|</span><a href="#41854258">next</a><span>|</span><label class="collapse" for="c-41851590">[-]</label><label class="expand" for="c-41851590">[2 more]</label></div><br/><div class="children"><div class="content">This is fascinating! Couldn&#x27;t really find the kernel code but would love to know more about the applicability. I&#x27;m curious since seeing the Unikraft release that promised millisecond container boot times</div><br/><div id="41851679" class="c"><input type="checkbox" id="c-41851679" checked=""/><div class="controls bullet"><span class="by">cmiller1</span><span>|</span><a href="#41851369">root</a><span>|</span><a href="#41851590">parent</a><span>|</span><a href="#41854258">next</a><span>|</span><label class="collapse" for="c-41851679">[-]</label><label class="expand" for="c-41851679">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;gitlab.redox-os.org&#x2F;redox-os&#x2F;kernel&#x2F;-&#x2F;tree&#x2F;master&#x2F;src?ref_type=heads" rel="nofollow">https:&#x2F;&#x2F;gitlab.redox-os.org&#x2F;redox-os&#x2F;kernel&#x2F;-&#x2F;tree&#x2F;master&#x2F;sr...</a></div><br/></div></div></div></div></div></div><div id="41854258" class="c"><input type="checkbox" id="c-41854258" checked=""/><div class="controls bullet"><span class="by">hkalbasi</span><span>|</span><a href="#41851369">prev</a><span>|</span><a href="#41853067">next</a><span>|</span><label class="collapse" for="c-41854258">[-]</label><label class="expand" for="c-41854258">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In the framekernel OS architecture, the entire OS resides in the same address space (like a monolithic kernel) and is required to be written in Rust. However, there&#x27;s a twist---the kernel is partitioned in two halves ... the unprivileged Services must be written exclusively in safe Rust.<p>Unprivileged services can exploit known compiler bugs and do anything they want in safe Rust. How this affects their security model?</div><br/></div></div><div id="41853067" class="c"><input type="checkbox" id="c-41853067" checked=""/><div class="controls bullet"><span class="by">treeshateorcs</span><span>|</span><a href="#41854258">prev</a><span>|</span><a href="#41853719">next</a><span>|</span><label class="collapse" for="c-41853067">[-]</label><label class="expand" for="c-41853067">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3AQ5lpXujGo" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=3AQ5lpXujGo</a>  Asterinas: A safe Rust-based OS kernel for TEE by H. Tian &amp; C. Song (Ant Group &amp; Intel) | OC3 2024</div><br/></div></div><div id="41853719" class="c"><input type="checkbox" id="c-41853719" checked=""/><div class="controls bullet"><span class="by">Klasiaster</span><span>|</span><a href="#41853067">prev</a><span>|</span><a href="#41852780">next</a><span>|</span><label class="collapse" for="c-41853719">[-]</label><label class="expand" for="c-41853719">[2 more]</label></div><br/><div class="children"><div class="content">There was also the similar project Kerla¹ but development stalled. Recently people argued that instead of focusing on Rust-for-Linux it would be easier to create a drop-in replacement like these two. I wonder if there are enough people interested to make this happen as a sustained project.<p>¹ <a href="https:&#x2F;&#x2F;github.com&#x2F;nuta&#x2F;kerla&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;nuta&#x2F;kerla&#x2F;</a></div><br/><div id="41855254" class="c"><input type="checkbox" id="c-41855254" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41853719">parent</a><span>|</span><a href="#41852780">next</a><span>|</span><label class="collapse" for="c-41855254">[-]</label><label class="expand" for="c-41855254">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Recently people argued that instead of focusing on Rust-for-Linux it would be easier to create a drop-in replacement like these two</i><p>I guess it depends on what they mean by &quot;easy&quot;.  Certainly it&#x27;s easier in the sense that you can just write code all day long, and not have to deal with the politics about Rust inside Linux, or deal with all the existing C interfaces, finding ways to wrap them in Rust in good, useful ways that leverage Rust&#x27;s strengths but don&#x27;t make it harder to evolve those C interfaces without trouble on the Rust side.<p>But the bulk of Linux is device drivers.  You can build a kernel in Rust (like Asterinas) that can run all of a regular Linux userland without recompilation, and I imagine it&#x27;s maybe not even that difficult to do so.  But Asterinas only runs on x86_64 VMs right now, and won&#x27;t run on real hardware.  Getting to the point where it could -- especially on modern hardware -- might take years.  Supporting all the architectures and various bits of hardware that Linux supports could take decades.  I suppose limiting themselves to three or four architectures, and only supporting hardware made more recently could cut that down.  But still, it&#x27;s a daunting project.</div><br/></div></div></div></div><div id="41852780" class="c"><input type="checkbox" id="c-41852780" checked=""/><div class="controls bullet"><span class="by">Alexsky2</span><span>|</span><a href="#41853719">prev</a><span>|</span><a href="#41856409">next</a><span>|</span><label class="collapse" for="c-41852780">[-]</label><label class="expand" for="c-41852780">[2 more]</label></div><br/><div class="children"><div class="content">I’ll mention another OS written in Rust, Twizzler: <a href="https:&#x2F;&#x2F;twizzler.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;twizzler.io&#x2F;</a><p>Its more of a research OS but still cool.</div><br/><div id="41853035" class="c"><input type="checkbox" id="c-41853035" checked=""/><div class="controls bullet"><span class="by">Teever</span><span>|</span><a href="#41852780">parent</a><span>|</span><a href="#41856409">next</a><span>|</span><label class="collapse" for="c-41853035">[-]</label><label class="expand" for="c-41853035">[1 more]</label></div><br/><div class="children"><div class="content">And I&#x27;ll mention another one that a friend of mine is working on: uxrt<p><a href="https:&#x2F;&#x2F;gitlab.com&#x2F;uxrt" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;uxrt</a></div><br/></div></div></div></div><div id="41856409" class="c"><input type="checkbox" id="c-41856409" checked=""/><div class="controls bullet"><span class="by">wiz21c</span><span>|</span><a href="#41852780">prev</a><span>|</span><a href="#41855424">next</a><span>|</span><label class="collapse" for="c-41856409">[-]</label><label class="expand" for="c-41856409">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Linux-compatible ABI<p>Does it mean it can re-use the drivers written for hardware to run with linux ?</div><br/><div id="41856885" class="c"><input type="checkbox" id="c-41856885" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41856409">parent</a><span>|</span><a href="#41856538">next</a><span>|</span><label class="collapse" for="c-41856885">[-]</label><label class="expand" for="c-41856885">[1 more]</label></div><br/><div class="children"><div class="content">No. The drivers in Linux are kernel modules, most often in-tree - meaning that the source for the drivers is built along the rest of the kernel source code. Most hardware drivers depend on various common kernel structures that change often - when they do, the source for drivers is fixed practically in the same git branch. There is no driver ABI to speak of.</div><br/></div></div><div id="41856538" class="c"><input type="checkbox" id="c-41856538" checked=""/><div class="controls bullet"><span class="by">dezgeg</span><span>|</span><a href="#41856409">parent</a><span>|</span><a href="#41856885">prev</a><span>|</span><a href="#41855424">next</a><span>|</span><label class="collapse" for="c-41856538">[-]</label><label class="expand" for="c-41856538">[1 more]</label></div><br/><div class="children"><div class="content">No. There is no stable ABI nor API for in-kernel device drivers.</div><br/></div></div></div></div><div id="41855424" class="c"><input type="checkbox" id="c-41855424" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#41856409">prev</a><span>|</span><a href="#41854116">next</a><span>|</span><label class="collapse" for="c-41855424">[-]</label><label class="expand" for="c-41855424">[2 more]</label></div><br/><div class="children"><div class="content">Side question - I have always wondered how a Linux system is configured at the lowest level?<p>Let&#x27;s take example of network. There&#x27;s IP address, gateway, DNS, routes etc. Depending on distribution we might see something like netplan reading config files and then calling ABI functions?<p>Or Linux kernel directly also reads some config files? Probably not...</div><br/><div id="41856084" class="c"><input type="checkbox" id="c-41856084" checked=""/><div class="controls bullet"><span class="by">NewJazz</span><span>|</span><a href="#41855424">parent</a><span>|</span><a href="#41854116">next</a><span>|</span><label class="collapse" for="c-41856084">[-]</label><label class="expand" for="c-41856084">[1 more]</label></div><br/><div class="children"><div class="content">Linux kernel as much as possible tries not to parse or read external data (besides stuff like acpi tables, device trees, hardware registers). For networking, you might look at the iproute codebase to see how they do things like bring a network device up, or create a bridge device, add a route, et cetera.<p>Edit: looks like iproute2 uses NETLINK, but non-networking tools might use syscalls or device ioctls.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Netlink" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Netlink</a></div><br/></div></div></div></div><div id="41854116" class="c"><input type="checkbox" id="c-41854116" checked=""/><div class="controls bullet"><span class="by">phlip9</span><span>|</span><a href="#41855424">prev</a><span>|</span><a href="#41853532">next</a><span>|</span><label class="collapse" for="c-41854116">[-]</label><label class="expand" for="c-41854116">[1 more]</label></div><br/><div class="children"><div class="content">Super cool project. Looks like the short-term target use-case is running a Linux-compatible OS in an Intel TDX guest VM with a significantly safer and smaller TCB. Makes sense. This way you also postpone a lot of the HW driver development drudgery and instead only target VM devices.</div><br/></div></div><div id="41853532" class="c"><input type="checkbox" id="c-41853532" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41854116">prev</a><span>|</span><a href="#41851981">next</a><span>|</span><label class="collapse" for="c-41853532">[-]</label><label class="expand" for="c-41853532">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Linux-compatible ABI<p>There&#x27;s no specification of that ABI, much less a compliance test suite.  How complete is this compatibility?</div><br/><div id="41855540" class="c"><input type="checkbox" id="c-41855540" checked=""/><div class="controls bullet"><span class="by">mgerdts</span><span>|</span><a href="#41853532">parent</a><span>|</span><a href="#41853746">next</a><span>|</span><label class="collapse" for="c-41855540">[-]</label><label class="expand" for="c-41855540">[1 more]</label></div><br/><div class="children"><div class="content">While developing the lx brand on illumos&#x2F;SmartOS, ltp was helpful. It may not be complete, but it is a pretty good start.<p><a href="https:&#x2F;&#x2F;linux-test-project.readthedocs.io&#x2F;en&#x2F;latest&#x2F;" rel="nofollow">https:&#x2F;&#x2F;linux-test-project.readthedocs.io&#x2F;en&#x2F;latest&#x2F;</a></div><br/></div></div><div id="41853746" class="c"><input type="checkbox" id="c-41853746" checked=""/><div class="controls bullet"><span class="by">Klasiaster</span><span>|</span><a href="#41853532">parent</a><span>|</span><a href="#41855540">prev</a><span>|</span><a href="#41851981">next</a><span>|</span><label class="collapse" for="c-41853746">[-]</label><label class="expand" for="c-41853746">[2 more]</label></div><br/><div class="children"><div class="content">Here is a list of implemented syscalls, but of course each checked one could still be slightly incompatible:<p><a href="https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;linux-compatibility.html" rel="nofollow">https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;linux-compatibility....</a></div><br/><div id="41853945" class="c"><input type="checkbox" id="c-41853945" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41853532">root</a><span>|</span><a href="#41853746">parent</a><span>|</span><a href="#41851981">next</a><span>|</span><label class="collapse" for="c-41853945">[-]</label><label class="expand" for="c-41853945">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also tons of ioctls and &#x2F;proc and what not.</div><br/></div></div></div></div></div></div><div id="41851981" class="c"><input type="checkbox" id="c-41851981" checked=""/><div class="controls bullet"><span class="by">depressedpanda</span><span>|</span><a href="#41853532">prev</a><span>|</span><a href="#41852710">next</a><span>|</span><label class="collapse" for="c-41851981">[-]</label><label class="expand" for="c-41851981">[8 more]</label></div><br/><div class="children"><div class="content">From the README:<p>&gt; Currently, Asterinas only supports x86-64 VMs. However, our aim for 2024 is to make Asterinas production-ready on x86-64 VMs.<p>I&#x27;m confused.</div><br/><div id="41852593" class="c"><input type="checkbox" id="c-41852593" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#41851981">parent</a><span>|</span><a href="#41852073">next</a><span>|</span><label class="collapse" for="c-41852593">[-]</label><label class="expand" for="c-41852593">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s “Currently, Asterinas only supports x86-64 VMs. However, [rather than working on additional architectures this year,] our aim for 2024 is to make Asterinas production-ready on x86-64 VMs.”</div><br/></div></div><div id="41852073" class="c"><input type="checkbox" id="c-41852073" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#41851981">parent</a><span>|</span><a href="#41852593">prev</a><span>|</span><a href="#41852349">next</a><span>|</span><label class="collapse" for="c-41852073">[-]</label><label class="expand" for="c-41852073">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like their goal is to improve their x86-64 support before implementing other ISAs.</div><br/></div></div><div id="41852349" class="c"><input type="checkbox" id="c-41852349" checked=""/><div class="controls bullet"><span class="by">nurb</span><span>|</span><a href="#41851981">parent</a><span>|</span><a href="#41852073">prev</a><span>|</span><a href="#41852785">next</a><span>|</span><label class="collapse" for="c-41852349">[-]</label><label class="expand" for="c-41852349">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s clearer from the book roadmap:<p>&gt; By 2024, we aim to achieve production-ready status for VM environments on x86-64.
&gt; In 2025 and beyond, we will expand our support for CPU architectures and hardware devices.<p><a href="https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;roadmap.html" rel="nofollow">https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;roadmap.html</a></div><br/></div></div><div id="41852785" class="c"><input type="checkbox" id="c-41852785" checked=""/><div class="controls bullet"><span class="by">None4U</span><span>|</span><a href="#41851981">parent</a><span>|</span><a href="#41852349">prev</a><span>|</span><a href="#41852058">next</a><span>|</span><label class="collapse" for="c-41852785">[-]</label><label class="expand" for="c-41852785">[1 more]</label></div><br/><div class="children"><div class="content">Distinction here is between &quot;supports&quot; and &quot;production-ready on&quot;, not &quot;x86-64&quot; and &quot;x86-64&quot;</div><br/></div></div><div id="41852058" class="c"><input type="checkbox" id="c-41852058" checked=""/><div class="controls bullet"><span class="by">MattPalmer1086</span><span>|</span><a href="#41851981">parent</a><span>|</span><a href="#41852785">prev</a><span>|</span><a href="#41852585">next</a><span>|</span><label class="collapse" for="c-41852058">[-]</label><label class="expand" for="c-41852058">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I had to read that a few times... I think they just mean it isn&#x27;t production ready yet, but that&#x27;s what they are aiming for.</div><br/></div></div><div id="41852585" class="c"><input type="checkbox" id="c-41852585" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#41851981">parent</a><span>|</span><a href="#41852058">prev</a><span>|</span><a href="#41852710">next</a><span>|</span><label class="collapse" for="c-41852585">[-]</label><label class="expand" for="c-41852585">[2 more]</label></div><br/><div class="children"><div class="content">it would be nice to know how much userspace it supports. supporting the dynamic loader, reasonable futexes, epoll, signals, uring are all big milestones</div><br/><div id="41854264" class="c"><input type="checkbox" id="c-41854264" checked=""/><div class="controls bullet"><span class="by">throw4950sh06</span><span>|</span><a href="#41851981">root</a><span>|</span><a href="#41852585">parent</a><span>|</span><a href="#41852710">next</a><span>|</span><label class="collapse" for="c-41854264">[-]</label><label class="expand" for="c-41854264">[1 more]</label></div><br/><div class="children"><div class="content">Check it out <a href="https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;linux-compatibility.html" rel="nofollow">https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;linux-compatibility....</a></div><br/></div></div></div></div></div></div><div id="41852710" class="c"><input type="checkbox" id="c-41852710" checked=""/><div class="controls bullet"><span class="by">valunord</span><span>|</span><a href="#41851981">prev</a><span>|</span><a href="#41851886">next</a><span>|</span><label class="collapse" for="c-41852710">[-]</label><label class="expand" for="c-41852710">[1 more]</label></div><br/><div class="children"><div class="content">I like what they&#x27;re working towards with V in Vinix as well. Exciting times to see such things with ABI compat with Linux opening new paradigms.</div><br/></div></div><div id="41851886" class="c"><input type="checkbox" id="c-41851886" checked=""/><div class="controls bullet"><span class="by">spease</span><span>|</span><a href="#41852710">prev</a><span>|</span><a href="#41854364">next</a><span>|</span><label class="collapse" for="c-41851886">[-]</label><label class="expand" for="c-41851886">[2 more]</label></div><br/><div class="children"><div class="content">What’s the intended use case for this? Backend containers?</div><br/><div id="41852605" class="c"><input type="checkbox" id="c-41852605" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41851886">parent</a><span>|</span><a href="#41854364">next</a><span>|</span><label class="collapse" for="c-41852605">[-]</label><label class="expand" for="c-41852605">[1 more]</label></div><br/><div class="children"><div class="content">Makes a lot of sense for virtual machine containers. Inside a container inside a VM, you need far less operating system.</div><br/></div></div></div></div><div id="41854364" class="c"><input type="checkbox" id="c-41854364" checked=""/><div class="controls bullet"><span class="by">xiaodai</span><span>|</span><a href="#41851886">prev</a><span>|</span><a href="#41852159">next</a><span>|</span><label class="collapse" for="c-41854364">[-]</label><label class="expand" for="c-41854364">[5 more]</label></div><br/><div class="children"><div class="content">Lol. I am Malaysian Chinese but I honestly don&#x27;t think anyone will put into production a Chinese made kernel. The risk is too high, same as no one will use a Linux distro coming out of Russian, Iran or NK. It&#x27;s just cultural bias in the west.</div><br/><div id="41854996" class="c"><input type="checkbox" id="c-41854996" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#41854364">parent</a><span>|</span><a href="#41854592">next</a><span>|</span><label class="collapse" for="c-41854996">[-]</label><label class="expand" for="c-41854996">[1 more]</label></div><br/><div class="children"><div class="content">Supposing it caught on... which do you think is riskier? Running an OS written in mostly memory safe code that somewhat might have tried to slip a backdoor in, or running an OS written in mostly memory unsafe code that has a long history of vulnerabilities and the Chinese almost certainly know about a vulnerability in.<p>If this catches on and has generally been subject to significant third party code review with positive results, I&#x27;m not sure any backdoor is lower cost to use than an equivalent linux vulnerability. To be fair, I&#x27;m not sure it isn&#x27;t either.</div><br/></div></div><div id="41854592" class="c"><input type="checkbox" id="c-41854592" checked=""/><div class="controls bullet"><span class="by">throw4950sh06</span><span>|</span><a href="#41854364">parent</a><span>|</span><a href="#41854996">prev</a><span>|</span><a href="#41852159">next</a><span>|</span><label class="collapse" for="c-41854592">[-]</label><label class="expand" for="c-41854592">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re wrong. A lot of Chinese code and hardware is in production in the west. Huawei networking hardware is widespread, for example.</div><br/><div id="41854769" class="c"><input type="checkbox" id="c-41854769" checked=""/><div class="controls bullet"><span class="by">tredre3</span><span>|</span><a href="#41854364">root</a><span>|</span><a href="#41854592">parent</a><span>|</span><a href="#41852159">next</a><span>|</span><label class="collapse" for="c-41854769">[-]</label><label class="expand" for="c-41854769">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Huawei networking hardware is widespread<p>That&#x27;s an interesting example because Huawei equipment is currently being removed by several Western countries (UK, Canada, US, Germany) specifically because it&#x27;s Chinese.<p><a href="https:&#x2F;&#x2F;www.nytimes.com&#x2F;2024&#x2F;07&#x2F;11&#x2F;business&#x2F;huawei-germany-ban.html" rel="nofollow">https:&#x2F;&#x2F;www.nytimes.com&#x2F;2024&#x2F;07&#x2F;11&#x2F;business&#x2F;huawei-germany-b...</a><p><a href="https:&#x2F;&#x2F;www.cbc.ca&#x2F;news&#x2F;politics&#x2F;huawei-5g-decision-1.6310839" rel="nofollow">https:&#x2F;&#x2F;www.cbc.ca&#x2F;news&#x2F;politics&#x2F;huawei-5g-decision-1.631083...</a><p><a href="https:&#x2F;&#x2F;www.gov.uk&#x2F;government&#x2F;news&#x2F;huawei-to-be-removed-from-uk-5g-networks-by-2027" rel="nofollow">https:&#x2F;&#x2F;www.gov.uk&#x2F;government&#x2F;news&#x2F;huawei-to-be-removed-from...</a><p><a href="https:&#x2F;&#x2F;www.reuters.com&#x2F;business&#x2F;media-telecom&#x2F;us-open-program-replace-huawei-equipment-us-networks-2021-09-27&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reuters.com&#x2F;business&#x2F;media-telecom&#x2F;us-open-progr...</a></div><br/><div id="41855968" class="c"><input type="checkbox" id="c-41855968" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#41854364">root</a><span>|</span><a href="#41854769">parent</a><span>|</span><a href="#41852159">next</a><span>|</span><label class="collapse" for="c-41855968">[-]</label><label class="expand" for="c-41855968">[1 more]</label></div><br/><div class="children"><div class="content">When we got a license for a private LTE network in the middle of the Greenland ice sheet, the one stipulation was we couldn&#x27;t use Huawei equipment...</div><br/></div></div></div></div></div></div></div></div><div id="41853293" class="c"><input type="checkbox" id="c-41853293" checked=""/><div class="controls bullet"><span class="by">jackhalford</span><span>|</span><a href="#41854430">prev</a><span>|</span><a href="#41854334">next</a><span>|</span><label class="collapse" for="c-41853293">[-]</label><label class="expand" for="c-41853293">[2 more]</label></div><br/><div class="children"><div class="content">The building process happens in a container?<p>&gt; If everything goes well, Asterinas is now up and running inside a VM.<p>Seems like the developers are very confident about it too</div><br/></div></div><div id="41854334" class="c"><input type="checkbox" id="c-41854334" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#41853293">prev</a><span>|</span><a href="#41853298">next</a><span>|</span><label class="collapse" for="c-41854334">[-]</label><label class="expand" for="c-41854334">[1 more]</label></div><br/><div class="children"><div class="content">I looked into the architecture. It turns out to be monolithic with marketing[0].<p>Sure is a lot of text to say: We try to use unsafe as little as possible.<p>Which is the minimum you&#x27;d expect anyways ¯\_(ツ)_&#x2F;¯<p>0. <a href="https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;the-framekernel-architecture.html" rel="nofollow">https:&#x2F;&#x2F;asterinas.github.io&#x2F;book&#x2F;kernel&#x2F;the-framekernel-arch...</a></div><br/></div></div><div id="41853298" class="c"><input type="checkbox" id="c-41853298" checked=""/><div class="controls bullet"><span class="by">havaker</span><span>|</span><a href="#41854334">prev</a><span>|</span><label class="collapse" for="c-41853298">[-]</label><label class="expand" for="c-41853298">[4 more]</label></div><br/><div class="children"><div class="content">The license choice is explained with the following:<p>&gt; [...] we accommodate the business need for proprietary kernel modules. Unlike GPL, the MPL permits the linking of MPL-covered files with proprietary code.<p>Glancing at the readme, it also looks like they are treating it as a big feature:<p>&gt; Asterinas surpasses Linux in terms of developer friendliness. It empowers kernel developers to [...] choose between releasing their kernel modules as open source or keeping them proprietary, thanks to the flexibility offered by MPL.<p>Can&#x27;t wait to glue some proprietary blobs to this new, secure rust kernel &#x2F;s</div><br/><div id="41853449" class="c"><input type="checkbox" id="c-41853449" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41853298">parent</a><span>|</span><label class="collapse" for="c-41853449">[-]</label><label class="expand" for="c-41853449">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious about the practical aspect: Are they going to freeze a stable driver ABI, or are they going to break proprietary drivers from time to time?</div><br/><div id="41854175" class="c"><input type="checkbox" id="c-41854175" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#41853298">root</a><span>|</span><a href="#41853449">parent</a><span>|</span><label class="collapse" for="c-41854175">[-]</label><label class="expand" for="c-41854175">[2 more]</label></div><br/><div class="children"><div class="content">Considering their OS as a framework approach I would guess they are more likely to expose a stable <i>API</i> than a stable ABI. Which also plays well with the MPL license (source file based) rather than something like the LGPL (~linking based).</div><br/><div id="41854229" class="c"><input type="checkbox" id="c-41854229" checked=""/><div class="controls bullet"><span class="by">throw4950sh06</span><span>|</span><a href="#41853298">root</a><span>|</span><a href="#41854175">parent</a><span>|</span><label class="collapse" for="c-41854229">[-]</label><label class="expand" for="c-41854229">[1 more]</label></div><br/><div class="children"><div class="content">This is the most interesting new OS I have seen in many years.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>