<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737277254133" as="style"/><link rel="stylesheet" href="styles.css?v=1737277254133"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dthompson.us/posts/wasm-gc-isnt-ready-for-realtime-graphics.html">WASM GC isn&#x27;t ready for realtime graphics</a> <span class="domain">(<a href="https://dthompson.us">dthompson.us</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>39 comments</span></div><br/><div><div id="42754227" class="c"><input type="checkbox" id="c-42754227" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42752721">next</a><span>|</span><label class="collapse" for="c-42754227">[-]</label><label class="expand" for="c-42754227">[1 more]</label></div><br/><div class="children"><div class="content">To be fair neither are WebGL and WebGPU, versus the native API counterparts, the best you can get are shadertoy demos, and product visualisation on ecommerce sites.<p>Due to tooling, sandboxing and not having any control about what GPU gets selected, or why the browser blakckboxes it and switches into software rendering.</div><br/></div></div><div id="42752721" class="c"><input type="checkbox" id="c-42752721" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#42754227">prev</a><span>|</span><a href="#42752335">next</a><span>|</span><label class="collapse" for="c-42752721">[-]</label><label class="expand" for="c-42752721">[4 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t WASM GC a prerequisite for getting direct DOM access from WASM? Does progress for WASM GC mean progress for DOM access as well?<p>Every time I check back on that the initiative seems to run under a different name. What is the best way to track progress on that front?</div><br/><div id="42752990" class="c"><input type="checkbox" id="c-42752990" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42752721">parent</a><span>|</span><a href="#42752335">next</a><span>|</span><label class="collapse" for="c-42752990">[-]</label><label class="expand" for="c-42752990">[3 more]</label></div><br/><div class="children"><div class="content">It’s not a prerequisite for using the DOM from wasm.<p>See, for example, the rust web frameworks of leptos and dioxus. They’re honestly great, and usable today as replacements for react and friends. (With the single caveat that wasm bundle size is a bit bigger than .js size).<p>They work by exposing a number of browser methods through to wasm, and then they call them through a custom wasm&#x2F;JS API bridge. All rust objects and DOM objects are completely isolated. Rust objects are allocated via an embedded malloc implementation and JS objects are managed by V8 (or whatever). but the DOM can still be manipulated via (essentially) message passing over an RPC like interface.<p>But the rust code needs to compile malloc specially for wasm. This is ok in rust - malloc is 75kb or something. But in languages like C#, Go or Python, the runtime GC is much bigger and harder to fit in a little wasm bundle.<p>The upside of wasm-gc is that this divide goes away. Objects are just objects, shared between both languages. So wasm bundles can use &amp; reference JS&#x2F;DOM objects directly. And wasm programs can piggyback on V8’s GC without needing to ship their own. This is good in rust, and great in GC languages. I saw an example with blazor where a simple C# wasm todo app went from 2mb or something to 10kb when wasmgc was used.<p>TLDR: wasm-gc isn’t strictly needed. You can use DOM from wasm today. It just makes wasm bundles smaller and wasm-dom interaction easier (and theoretically faster).</div><br/><div id="42753557" class="c"><input type="checkbox" id="c-42753557" checked=""/><div class="controls bullet"><span class="by">geokon</span><span>|</span><a href="#42752721">root</a><span>|</span><a href="#42752990">parent</a><span>|</span><a href="#42753011">next</a><span>|</span><label class="collapse" for="c-42753557">[-]</label><label class="expand" for="c-42753557">[1 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, why is malloc 75kb ? That seems like an crazy amount of code (if this after linking and dead code removal for platform specific magic?)</div><br/></div></div><div id="42753011" class="c"><input type="checkbox" id="c-42753011" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42752721">root</a><span>|</span><a href="#42752990">parent</a><span>|</span><a href="#42753557">prev</a><span>|</span><a href="#42752335">next</a><span>|</span><label class="collapse" for="c-42753011">[-]</label><label class="expand" for="c-42753011">[1 more]</label></div><br/><div class="children"><div class="content">Wasm GC also solved the problem of reference cycles between objects in disparate heap managers leading to memory leaks. It&#x27;s not just a performance or size win: it&#x27;s a correctness win.</div><br/></div></div></div></div></div></div><div id="42752335" class="c"><input type="checkbox" id="c-42752335" checked=""/><div class="controls bullet"><span class="by">out_of_protocol</span><span>|</span><a href="#42752721">prev</a><span>|</span><a href="#42752204">next</a><span>|</span><label class="collapse" for="c-42752335">[-]</label><label class="expand" for="c-42752335">[9 more]</label></div><br/><div class="children"><div class="content">Really liked NaCl (and PNaCl) idea, which allows running arbitrary code, sanitized, with ~90% speed of native execution. Playing Bastion game in browser was refreshing. Unfortunately communication with js code and bootstrap issues (can&#x27;t run code without plugin, no one except chrome supported this) ruined that tech</div><br/><div id="42752495" class="c"><input type="checkbox" id="c-42752495" checked=""/><div class="controls bullet"><span class="by">thegeomaster</span><span>|</span><a href="#42752335">parent</a><span>|</span><a href="#42754242">next</a><span>|</span><label class="collapse" for="c-42752495">[-]</label><label class="expand" for="c-42752495">[6 more]</label></div><br/><div class="children"><div class="content">WASM nowadays has become quite the monstrosity compared to NaCl&#x2F;PNaCl. Just look at this WASM GC spaghetti, trying to compile a GC&#x27;d language but hooking it up V8&#x2F;JavaScriptCore&#x27;s GC, while upholding a strict security model... That sounds like it won&#x27;t cause any problems whatsoever!<p>Sometimes I wonder if the industry would have been better off with NaCl as a standard. Old, mature tooling would by and large still be applicable (it&#x27;s still your ordinary x86&#x2F;ARM machine code) instead of the nascent and buggy ecosystem we have now. I don&#x27;t know why, but the JS folks just keep reinventing <i>everything</i> all the time.</div><br/><div id="42753083" class="c"><input type="checkbox" id="c-42753083" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#42752335">root</a><span>|</span><a href="#42752495">parent</a><span>|</span><a href="#42752920">next</a><span>|</span><label class="collapse" for="c-42753083">[-]</label><label class="expand" for="c-42753083">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Old, mature tooling would by and large still be applicable (it&#x27;s still your ordinary x86&#x2F;ARM machine code)<p>It wasn&#x27;t, though. Since NaCl ran code in the same process as the renderer, it depended upon a verifier for security, and required the generated code to follow some unusual constraints to support that verification. For example, on x86, all branch targets were required to be 32-byte aligned, and all indirect branches were required to use a specific instruction sequence to enforce that alignment. Generating code to meet these constraints required a modified compiler, and reduced code density and speed.<p>In any case, NaCl would have run into the exact same GC issues if it had been used more extensively. The only reason it didn&#x27;t was that most of the applications it saw were games which barely interacted with the JS&#x2F;DOM &quot;world&quot;.</div><br/><div id="42753255" class="c"><input type="checkbox" id="c-42753255" checked=""/><div class="controls bullet"><span class="by">thegeomaster</span><span>|</span><a href="#42752335">root</a><span>|</span><a href="#42753083">parent</a><span>|</span><a href="#42752920">next</a><span>|</span><label class="collapse" for="c-42753255">[-]</label><label class="expand" for="c-42753255">[2 more]</label></div><br/><div class="children"><div class="content">I simplified in my comment. It was a much better story for tooling, since you could reuse large parts of existing backends&#x2F;codegen, optimization passes, and debugging. The mental model of execution would remain too, rather than being a weird machine code for a weird codesize-optimized stack machine.<p>I would wager the performance implications of NaCl code, even for ARM which required many more workarounds than x86 (whose NaCl impl has a &quot;one weird trick&quot; aura), were much better than for modern WASM.<p>It&#x27;s hard to say if it would&#x27;ve run into the same issues. For one, it would&#x27;ve been easier to port native GCs: they don&#x27;t run afoul of W^X rules, they just read memory if that, which you can do performantly in NaCl on x86 due to the segments trick. I also suspect the culture could&#x27;ve more easily evolved towards shared objects where you would be able to download&#x2F;parse&#x2F;verify a stdlib once, and then keep using it.<p>I agree it was because the applications were games, but for another second-order reason: they were by and large C&#x2F;C++ codebases where memory was refcounted manually. Java was probably the second choice, but those were the days when Java applets were still auto-loading, so there was likely no need for anybody to try.</div><br/><div id="42753845" class="c"><input type="checkbox" id="c-42753845" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#42752335">root</a><span>|</span><a href="#42753255">parent</a><span>|</span><a href="#42752920">next</a><span>|</span><label class="collapse" for="c-42753845">[-]</label><label class="expand" for="c-42753845">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s hard to say if it would&#x27;ve run into the same issues. For one, it would&#x27;ve been easier to port native GCs...<p>WASM GC isn&#x27;t just about memory management for the WASM world; it&#x27;s about managing references (including cyclical refs!) which cross the boundary into the non-WASM world. Being able to write a GC within the WASM (or NaCl) world doesn&#x27;t get you that functionality.</div><br/></div></div></div></div></div></div><div id="42752920" class="c"><input type="checkbox" id="c-42752920" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#42752335">root</a><span>|</span><a href="#42752495">parent</a><span>|</span><a href="#42753083">prev</a><span>|</span><a href="#42753282">next</a><span>|</span><label class="collapse" for="c-42752920">[-]</label><label class="expand" for="c-42752920">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m reminded of writing JavaScript way back in the old Internet Explorer days (6 and to a lesser extent 7), when you had to manually null out any references to DOM elements if you were done with them, or else the JS and the DOM nodes wouldn&#x27;t get garbage collected because IE had two different garbage collectors and cycles between them didn&#x27;t get collected immediately.</div><br/></div></div><div id="42753282" class="c"><input type="checkbox" id="c-42753282" checked=""/><div class="controls bullet"><span class="by">Vampiero</span><span>|</span><a href="#42752335">root</a><span>|</span><a href="#42752495">parent</a><span>|</span><a href="#42752920">prev</a><span>|</span><a href="#42754242">next</a><span>|</span><label class="collapse" for="c-42753282">[-]</label><label class="expand" for="c-42753282">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I don&#x27;t know why, but the JS folks just keep reinventing everything all the time.<p>It&#x27;s because they only know the web. They have never seen seen what real programmers actually do. They only live in their stupid web bubble thinking it&#x27;s all there is.</div><br/></div></div></div></div><div id="42754242" class="c"><input type="checkbox" id="c-42754242" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42752335">parent</a><span>|</span><a href="#42752495">prev</a><span>|</span><a href="#42753014">next</a><span>|</span><label class="collapse" for="c-42754242">[-]</label><label class="expand" for="c-42754242">[1 more]</label></div><br/><div class="children"><div class="content">Same here, and the irony is Mozzilla opposing it hardly matters nowadays for the Firefox browser market, it is Google driving where WebAssembly goes.<p>Remember NaCL, and PNaCL SDKs, came with support for C, C++ and OCaml, the latter being an example for GC languages.</div><br/></div></div><div id="42753014" class="c"><input type="checkbox" id="c-42753014" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#42752335">parent</a><span>|</span><a href="#42754242">prev</a><span>|</span><a href="#42752204">next</a><span>|</span><label class="collapse" for="c-42753014">[-]</label><label class="expand" for="c-42753014">[1 more]</label></div><br/><div class="children"><div class="content">What does this have to do with wasm gc?</div><br/></div></div></div></div><div id="42752204" class="c"><input type="checkbox" id="c-42752204" checked=""/><div class="controls bullet"><span class="by">sestep</span><span>|</span><a href="#42752335">prev</a><span>|</span><a href="#42753050">next</a><span>|</span><label class="collapse" for="c-42752204">[-]</label><label class="expand" for="c-42752204">[2 more]</label></div><br/><div class="children"><div class="content">I was excited to read this post because I haven&#x27;t yet tried WasmGC for anything beyond tiny toy examples, but was disappointed to find no actual numbers for performance. I don&#x27;t know the author well enough to be able to assess their assertions that various things are &quot;slow&quot; without data.</div><br/><div id="42753769" class="c"><input type="checkbox" id="c-42753769" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#42752204">parent</a><span>|</span><a href="#42753050">next</a><span>|</span><label class="collapse" for="c-42753769">[-]</label><label class="expand" for="c-42753769">[1 more]</label></div><br/><div class="children"><div class="content">This was a quickie post for me. Just a tale of what my experience has been. No in-depth, apples to apples comparison so I don&#x27;t know the magnitude of the performance differential.</div><br/></div></div></div></div><div id="42753050" class="c"><input type="checkbox" id="c-42753050" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#42752204">prev</a><span>|</span><a href="#42752574">next</a><span>|</span><label class="collapse" for="c-42753050">[-]</label><label class="expand" for="c-42753050">[3 more]</label></div><br/><div class="children"><div class="content">I just wish WASM could use more than one ArrayBuffer at a time.  Would eliminate unnecessary copying for interop with JS code.</div><br/><div id="42755116" class="c"><input type="checkbox" id="c-42755116" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#42753050">parent</a><span>|</span><a href="#42752574">next</a><span>|</span><label class="collapse" for="c-42755116">[-]</label><label class="expand" for="c-42755116">[2 more]</label></div><br/><div class="children"><div class="content">Well I just thought of something obvious...  Have a function that lets you pass in an ArrayBuffer, then it brings it into the virtual address space of the WASM program.  Function would return the virtual address that was assigned to that array buffer.  From there, you call into WASM again with that pointer, and the program can take action.<p>Then there would be another function to relinquish ownership of the ArrayBuffer.</div><br/><div id="42755167" class="c"><input type="checkbox" id="c-42755167" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#42753050">root</a><span>|</span><a href="#42755116">parent</a><span>|</span><a href="#42752574">next</a><span>|</span><label class="collapse" for="c-42755167">[-]</label><label class="expand" for="c-42755167">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no SharedArrayBuffer support? Or I misunderstand the idea</div><br/></div></div></div></div></div></div><div id="42752574" class="c"><input type="checkbox" id="c-42752574" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42753050">prev</a><span>|</span><a href="#42751982">next</a><span>|</span><label class="collapse" for="c-42752574">[-]</label><label class="expand" for="c-42752574">[5 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t it be possible to implement your own GC in WASM? Why does WASM try to be everything?</div><br/><div id="42752587" class="c"><input type="checkbox" id="c-42752587" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#42752574">parent</a><span>|</span><a href="#42752624">next</a><span>|</span><label class="collapse" for="c-42752587">[-]</label><label class="expand" for="c-42752587">[1 more]</label></div><br/><div class="children"><div class="content">Slower, single threaded, greatly increases binary size, separate heap from JS so bad interop with extern refs. Wasm GC is a great thing.</div><br/></div></div><div id="42752624" class="c"><input type="checkbox" id="c-42752624" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42752574">parent</a><span>|</span><a href="#42752587">prev</a><span>|</span><a href="#42752851">next</a><span>|</span><label class="collapse" for="c-42752624">[-]</label><label class="expand" for="c-42752624">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t GC together with the host environment if you do a custom GC (i.e. a wasm object and a JS object in a cycle wouldn&#x27;t have any way to ever be GC&#x27;d).</div><br/></div></div><div id="42752851" class="c"><input type="checkbox" id="c-42752851" checked=""/><div class="controls bullet"><span class="by">bhelx</span><span>|</span><a href="#42752574">parent</a><span>|</span><a href="#42752624">prev</a><span>|</span><a href="#42754449">next</a><span>|</span><label class="collapse" for="c-42752851">[-]</label><label class="expand" for="c-42752851">[1 more]</label></div><br/><div class="children"><div class="content">yes, it&#x27;s regularly done. But I think you are misunderstanding. WASM GC isn&#x27;t a GC implementation.</div><br/></div></div><div id="42754449" class="c"><input type="checkbox" id="c-42754449" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42752574">parent</a><span>|</span><a href="#42752851">prev</a><span>|</span><a href="#42751982">next</a><span>|</span><label class="collapse" for="c-42754449">[-]</label><label class="expand" for="c-42754449">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is how it&#x27;s done eg with Python and Go.<p>An advantage of a common GC could be interop between languages.</div><br/></div></div></div></div><div id="42751982" class="c"><input type="checkbox" id="c-42751982" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#42752574">prev</a><span>|</span><a href="#42753147">next</a><span>|</span><label class="collapse" for="c-42751982">[-]</label><label class="expand" for="c-42751982">[9 more]</label></div><br/><div class="children"><div class="content">It&#x27;s sort of baffled me that people appear to be shipping real code using WasmGC since the limitations described in this post are so severe. Maybe it&#x27;s fine because they&#x27;re just manipulating DOM nodes? Every time I&#x27;ve looked at WasmGC I&#x27;ve gone &quot;there&#x27;s no way I could use this yet&quot; and decided to check back a year later and see if it&#x27;s There Yet.<p>Hopefully it gets there. The uint8array example from this post was actually a surprise to me, I&#x27;d just assumed it would be efficient to access a typed array via WasmGC!<p>Beyond the limitations in this post there are other things needed to be able to target WasmGC with existing stuff written in other languages, like interior references or dependent handles. But that&#x27;s okay, I think, it can be worthwhile for it to exist as-is even if it can&#x27;t support i.e. existing large-scale apps in memory safe languages. It&#x27;s a little frustrating though.</div><br/><div id="42753319" class="c"><input type="checkbox" id="c-42753319" checked=""/><div class="controls bullet"><span class="by">wffurr</span><span>|</span><a href="#42751982">parent</a><span>|</span><a href="#42752933">next</a><span>|</span><label class="collapse" for="c-42753319">[-]</label><label class="expand" for="c-42753319">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The uint8array example from this post was actually a surprise to me, I&#x27;d just assumed it would be efficient to access a typed array via WasmGC!<p>The problem is that the Scheme i8 array is not actually a UInt8Array with WasmGC.  It’s a separate heap allocated object that is opaque to the JS runtime.<p>In the linear memory Wasm model, the Scheme i8 array is allocated in the wasm memory array, and so one can create an UInt8Array view that exactly maps to the same bytes in the linear memory buffer.  This isn’t possible (yet?) with the opaque WasmGC object type.</div><br/><div id="42753330" class="c"><input type="checkbox" id="c-42753330" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#42751982">root</a><span>|</span><a href="#42753319">parent</a><span>|</span><a href="#42752933">next</a><span>|</span><label class="collapse" for="c-42753330">[-]</label><label class="expand" for="c-42753330">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s right. I&#x27;m hoping there will be a way to do this in a future revision of Wasm GC.</div><br/></div></div></div></div><div id="42752933" class="c"><input type="checkbox" id="c-42752933" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#42751982">parent</a><span>|</span><a href="#42753319">prev</a><span>|</span><a href="#42752484">next</a><span>|</span><label class="collapse" for="c-42752933">[-]</label><label class="expand" for="c-42752933">[1 more]</label></div><br/><div class="children"><div class="content">Definitely a lot is missing, yeah, and adding more will take time. But it works well already for pure computational code. For example, Google Sheets uses WasmGC for Java logic:<p><a href="https:&#x2F;&#x2F;web.dev&#x2F;case-studies&#x2F;google-sheets-wasmgc#the_final_result" rel="nofollow">https:&#x2F;&#x2F;web.dev&#x2F;case-studies&#x2F;google-sheets-wasmgc#the_final_...</a></div><br/></div></div><div id="42752484" class="c"><input type="checkbox" id="c-42752484" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42751982">parent</a><span>|</span><a href="#42752933">prev</a><span>|</span><a href="#42753147">next</a><span>|</span><label class="collapse" for="c-42752484">[-]</label><label class="expand" for="c-42752484">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been shipping a Flutter app that uses it for months. Pretty heavy stuff, its doing everything from LLM inference to model inference to maintaining a vector store and indexeddb in your browser.<p>Frame latency feels like it&#x27;s gone, there&#x27;s 100% a significant decrease in perceived latency.<p>I did have a frustrating performance issues with 3rd party code doing &quot;source code parsing&quot; via RegEx, thought it was either the library or Flutters fault, but from the article content, sounds like it was WASM GC. (saw a <i>ton</i> of time spent converting objects from JS&lt;-&gt;WASM on a 50 KLOC file)<p>From that perspective, the article sounds a bit maximalist in its claims, but only from my perspective.<p>I think if you read &quot;real time graphics&quot; as &quot;3d game&quot; it gives a better understanding of where it&#x27;s at, my anecdata aside.</div><br/><div id="42752927" class="c"><input type="checkbox" id="c-42752927" checked=""/><div class="controls bullet"><span class="by">lukasb</span><span>|</span><a href="#42751982">root</a><span>|</span><a href="#42752484">parent</a><span>|</span><a href="#42752994">next</a><span>|</span><label class="collapse" for="c-42752927">[-]</label><label class="expand" for="c-42752927">[2 more]</label></div><br/><div class="children"><div class="content">When you said &quot;jump in perceived latency&quot;, did you mean perceived latency went up or down?</div><br/><div id="42752932" class="c"><input type="checkbox" id="c-42752932" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42751982">root</a><span>|</span><a href="#42752927">parent</a><span>|</span><a href="#42752994">next</a><span>|</span><label class="collapse" for="c-42752932">[-]</label><label class="expand" for="c-42752932">[1 more]</label></div><br/><div class="children"><div class="content">Down, significantly</div><br/></div></div></div></div><div id="42752994" class="c"><input type="checkbox" id="c-42752994" checked=""/><div class="controls bullet"><span class="by">ripped_britches</span><span>|</span><a href="#42751982">root</a><span>|</span><a href="#42752484">parent</a><span>|</span><a href="#42752927">prev</a><span>|</span><a href="#42753147">next</a><span>|</span><label class="collapse" for="c-42752994">[-]</label><label class="expand" for="c-42752994">[2 more]</label></div><br/><div class="children"><div class="content">Which libraries caused these problems for you?</div><br/><div id="42753030" class="c"><input type="checkbox" id="c-42753030" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42751982">root</a><span>|</span><a href="#42752994">parent</a><span>|</span><a href="#42753147">next</a><span>|</span><label class="collapse" for="c-42753030">[-]</label><label class="expand" for="c-42753030">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t wanna name names, because it&#x27;s on me, it&#x27;s a miracle it exists, and works.<p>I don&#x27;t think there&#x27;s a significant # of alternatives, so hopefully Flutter syntax highlighting library, as used in a package for making markdown columns, is enough to be helpful.<p>Problem was some weird combo of lots of regex and an absolutely huge amount of code. It&#x27;s one of those problems it&#x27;s hard for me to draw many conclusions from:<p>- Flutter may be using browser APIs for regex, so there&#x27;s some sort of JS&#x2F;WASM barrier copying cost<p>- The markdown column renderer is doing nothing at all to handle this situation lazily, i.e. if any portion of the column is displayed, syntax highlighting must be done on the complete markdown input<p>- Each different color text, so pretty much every word, gets its own object in the view hierarchy, tens if not hundreds of thousands this case. Can&#x27;t remember if this is due to the syntax highlighting library or the markdown package<p>- Regex is used to parse to code and for all I know one of them has pathological performance like backtracking unintentionally.</div><br/></div></div></div></div></div></div></div></div><div id="42753147" class="c"><input type="checkbox" id="c-42753147" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42751982">prev</a><span>|</span><a href="#42752414">next</a><span>|</span><label class="collapse" for="c-42753147">[-]</label><label class="expand" for="c-42753147">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Unsatisfying workarounds [...] Use linear memory for bytevectors<p>It <i>never</i> makes sense to use GC for leaf memory if you&#x27;re in a language that offers both, since mere refcounting (or a GC&#x27;ed object containing a unique pointer) is trivial to implement.<p>There are a <i>lot</i> of languages where it&#x27;s expensive to make the mistake this post is making. (I don&#x27;t know much about WASM in particular; it may still have other errors).</div><br/><div id="42753174" class="c"><input type="checkbox" id="c-42753174" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#42753147">parent</a><span>|</span><a href="#42752414">next</a><span>|</span><label class="collapse" for="c-42753174">[-]</label><label class="expand" for="c-42753174">[1 more]</label></div><br/><div class="children"><div class="content">Sorry but it&#x27;s just a different choice not a mistake. I do realtime graphics just fine in non-web managed memory languages.</div><br/></div></div></div></div><div id="42752414" class="c"><input type="checkbox" id="c-42752414" checked=""/><div class="controls bullet"><span class="by">simon_void</span><span>|</span><a href="#42753147">prev</a><span>|</span><label class="collapse" for="c-42752414">[-]</label><label class="expand" for="c-42752414">[3 more]</label></div><br/><div class="children"><div class="content">so what about realtime graphics with wasm without GC? (compiled from languages not needing a GC like Rust, C&#x2F;C++, Odin, ...)</div><br/><div id="42754291" class="c"><input type="checkbox" id="c-42754291" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42752414">parent</a><span>|</span><a href="#42752449">next</a><span>|</span><label class="collapse" for="c-42754291">[-]</label><label class="expand" for="c-42754291">[1 more]</label></div><br/><div class="children"><div class="content">Better, but WebGPU and WebGL aren&#x27;t going to win any performance prizes either, and tooling is pretty much non existent.<p>Nothing like Pix, Instruments or Renderdoc, SpectorJS is the only thing you get after almost 15 years since WebGL 1.0.<p>And from the hardware level they support, it about PlayStation 3 kind of graphics, if the browser doesn&#x27;t block the GPU, nor selects the integrated one instead of dedicated one.<p>Your are left with shaders as the only way to actually push the hardware.</div><br/></div></div><div id="42752449" class="c"><input type="checkbox" id="c-42752449" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#42752414">parent</a><span>|</span><a href="#42754291">prev</a><span>|</span><label class="collapse" for="c-42752449">[-]</label><label class="expand" for="c-42752449">[1 more]</label></div><br/><div class="children"><div class="content">As mentioned, that works quite well already but it&#x27;s not the topic of this post.</div><br/></div></div></div></div></div></div></div></div></div></body></html>