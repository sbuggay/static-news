<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713258059254" as="style"/><link rel="stylesheet" href="styles.css?v=1713258059254"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/knuthmorrispratt-illustrated/8EFA77D663D585B68630E372BCE1EBA4">Knuth–Morris–Pratt illustrated</a> <span class="domain">(<a href="https://www.cambridge.org">www.cambridge.org</a>)</span></div><div class="subtext"><span>g0xA52A2A</span> | <span>27 comments</span></div><br/><div><div id="40047259" class="c"><input type="checkbox" id="c-40047259" checked=""/><div class="controls bullet"><span class="by">HarHarVeryFunny</span><span>|</span><a href="#40048805">next</a><span>|</span><label class="collapse" for="c-40047259">[-]</label><label class="expand" for="c-40047259">[4 more]</label></div><br/><div class="children"><div class="content">The explanation is a bit lengthy, but the idea is simple.<p>Consider the normal naive way to search for a string in a document. First you search for the next instance of the first letter of your search string, then try to match the entire string at that position. If the match fails then you advance your search position by one character and repeat (looking for next occurrence of first letter, etc).<p>The Knuth-Morris-Pratt algorithm improves upon this naive approach by usually advancing by <i>more</i> than one character after a failed match, thereby speeding up the search. It does this by taking advantage of its knowledge of the search string and the position at which the match failed.<p>To get the idea, consider searching for the string &quot;explosion&quot; .. first we find the next &quot;e&quot;, then try matching the rest of the word. Say we match &quot;explo&quot; then fail (perhaps the document had &quot;explode&quot;), so now we want to start over and find the next &quot;e&quot; in the document... What KMP would do here is note that the document matched the first 5 letters &quot;explo&quot;, none of which (other than 1st letter) are an &quot;e&quot;, so it can advance by 5 characters, not just 1, to start looking for the next &quot;e&quot;.<p>The amounts it can advance at each failed match position are pre-calculated to be efficient.</div><br/><div id="40049137" class="c"><input type="checkbox" id="c-40049137" checked=""/><div class="controls bullet"><span class="by">itronitron</span><span>|</span><a href="#40047259">parent</a><span>|</span><a href="#40049522">next</a><span>|</span><label class="collapse" for="c-40049137">[-]</label><label class="expand" for="c-40049137">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The amounts it can advance at each failed match position are pre-calculated to be efficient.<p>Wouldn&#x27;t knowing that require having already run the search?</div><br/><div id="40049296" class="c"><input type="checkbox" id="c-40049296" checked=""/><div class="controls bullet"><span class="by">throw_pm23</span><span>|</span><a href="#40047259">root</a><span>|</span><a href="#40049137">parent</a><span>|</span><a href="#40049522">next</a><span>|</span><label class="collapse" for="c-40049296">[-]</label><label class="expand" for="c-40049296">[1 more]</label></div><br/><div class="children"><div class="content">No, check the example given. To know how much we can advance, we only needed to examine the search string &quot;explosion&quot; in advance.</div><br/></div></div></div></div><div id="40049522" class="c"><input type="checkbox" id="c-40049522" checked=""/><div class="controls bullet"><span class="by">gorkempacaci</span><span>|</span><a href="#40047259">parent</a><span>|</span><a href="#40049137">prev</a><span>|</span><a href="#40048805">next</a><span>|</span><label class="collapse" for="c-40049522">[-]</label><label class="expand" for="c-40049522">[1 more]</label></div><br/><div class="children"><div class="content">That was a great explanation. Thanks.</div><br/></div></div></div></div><div id="40048805" class="c"><input type="checkbox" id="c-40048805" checked=""/><div class="controls bullet"><span class="by">vladimirralev</span><span>|</span><a href="#40047259">prev</a><span>|</span><a href="#40049170">next</a><span>|</span><label class="collapse" for="c-40048805">[-]</label><label class="expand" for="c-40048805">[1 more]</label></div><br/><div class="children"><div class="content">Shockingly, there is a related algorithm that is widely considered much easier to understand and implement. <a href="https:&#x2F;&#x2F;cp-algorithms.com&#x2F;string&#x2F;z-function.html" rel="nofollow">https:&#x2F;&#x2F;cp-algorithms.com&#x2F;string&#x2F;z-function.html</a><p>And I can certainly implement the Z algorithm in a few mins while I struggle to implement the KMP off the top of my head.<p>Edit: perhaps a bit better article on this <a href="https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;z-algorithm-linear-time-pattern-searching-algorithm&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;z-algorithm-linear-time-patter...</a></div><br/></div></div><div id="40049170" class="c"><input type="checkbox" id="c-40049170" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#40048805">prev</a><span>|</span><a href="#40030830">next</a><span>|</span><label class="collapse" for="c-40049170">[-]</label><label class="expand" for="c-40049170">[3 more]</label></div><br/><div class="children"><div class="content">Is this post showing a bug in HN? It says it was posted 10 hours ago, but Algolia says it was posted 2 days ago<p><a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=pastWeek&amp;page=0&amp;prefix=true&amp;query=knuth+morris+pratt&amp;sort=byDate&amp;type=story" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=pastWeek&amp;page=0&amp;prefix=tru...</a><p>And mehulashah&#x27;s comment that the thread claims was posted 7 hours ago was also posted two days ago, according to Algolia<p><a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=pastWeek&amp;page=0&amp;prefix=true&amp;query=This+starts+off+well%2C+but+the+Haskell+makes+it+hard+for+me+to+understand.+Perhaps+I+should+learn+Haskell%3F&amp;sort=byDate&amp;type=comment" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=pastWeek&amp;page=0&amp;prefix=tru...</a><p>I&#x27;m aware of the second chance pool, but I don&#x27;t think it can be that<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26998308">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26998308</a></div><br/><div id="40049281" class="c"><input type="checkbox" id="c-40049281" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#40049170">parent</a><span>|</span><a href="#40030830">next</a><span>|</span><label class="collapse" for="c-40049281">[-]</label><label class="expand" for="c-40049281">[2 more]</label></div><br/><div class="children"><div class="content">This K-M-P post is on page 2 of the pool list .. reverse chrono sorted by time of <i>first</i> post:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;pool">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;pool</a><p>My recent post: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40037466">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40037466</a><p>shows with the second chance repost time (12 hours ago), but was actually <i>first</i> posted ~ 24 hours ago.<p>It sank w&#x2F;out notice then, this morning I woke to find it was suddenly active and &quot;recently&quot; posted.<p>That&#x27;s the second chance pool effect for you :-)</div><br/><div id="40049634" class="c"><input type="checkbox" id="c-40049634" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#40049170">root</a><span>|</span><a href="#40049281">parent</a><span>|</span><a href="#40030830">next</a><span>|</span><label class="collapse" for="c-40049634">[-]</label><label class="expand" for="c-40049634">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not surprised the pool can make the article reappear but I&#x27;m a bit surprised it adjusts the submission date of the article and I&#x27;m <i>very</i> surprised that the comment dates have changed.</div><br/></div></div></div></div></div></div><div id="40030830" class="c"><input type="checkbox" id="c-40030830" checked=""/><div class="controls bullet"><span class="by">mehulashah</span><span>|</span><a href="#40049170">prev</a><span>|</span><a href="#40048713">next</a><span>|</span><label class="collapse" for="c-40030830">[-]</label><label class="expand" for="c-40030830">[11 more]</label></div><br/><div class="children"><div class="content">This starts off well, but the Haskell makes it hard for me to understand. Perhaps I should learn Haskell?</div><br/><div id="40047070" class="c"><input type="checkbox" id="c-40047070" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#40030830">parent</a><span>|</span><a href="#40047126">next</a><span>|</span><label class="collapse" for="c-40047070">[-]</label><label class="expand" for="c-40047070">[1 more]</label></div><br/><div class="children"><div class="content">Independently of anything else: Yes, you should learn Haskell :)<p>If Go is more your speed, here&#x27;s an implementation in Go: <a href="https:&#x2F;&#x2F;git.lukeshu.com&#x2F;btrfs-progs-ng&#x2F;tree&#x2F;cmd&#x2F;btrfs-rec&#x2F;inspect&#x2F;rebuildmappings&#x2F;kmp.go" rel="nofollow">https:&#x2F;&#x2F;git.lukeshu.com&#x2F;btrfs-progs-ng&#x2F;tree&#x2F;cmd&#x2F;btrfs-rec&#x2F;in...</a> (though it is slightly complicated by the fact that it allows &#x27;substr&#x27; to include fixed-length wildcards).</div><br/></div></div><div id="40047126" class="c"><input type="checkbox" id="c-40047126" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40030830">parent</a><span>|</span><a href="#40047070">prev</a><span>|</span><a href="#40048420">next</a><span>|</span><label class="collapse" for="c-40047126">[-]</label><label class="expand" for="c-40047126">[5 more]</label></div><br/><div class="children"><div class="content">Learning some Haskell is very educational; it changes the way you think about programming, including daily code (much like a Lisp, Erlang, SQL, Smalltalk also do).<p>These examples use pretty minimal features of Haskell, mostly expressions, function definitions with argument pattern matching,  and algebraic type definitions. These would take an hour or two to get acquainted with. Nothing fancy is used in the code, in particular, nothing outright <i>monadic</i> :)<p>For comparison, you can check out a Lisp version at the end. It&#x27;s much longer, and Lisp (well, Racket here) is usually a very expressive language.</div><br/><div id="40047609" class="c"><input type="checkbox" id="c-40047609" checked=""/><div class="controls bullet"><span class="by">foobarian</span><span>|</span><a href="#40030830">root</a><span>|</span><a href="#40047126">parent</a><span>|</span><a href="#40049419">next</a><span>|</span><label class="collapse" for="c-40047609">[-]</label><label class="expand" for="c-40047609">[1 more]</label></div><br/><div class="children"><div class="content">If Haskell seems too intimidating I think Standard ML is easier to wrap one&#x27;s head around as it has fewer features.  But it still delivers that FP way of thinking insight.</div><br/></div></div><div id="40049419" class="c"><input type="checkbox" id="c-40049419" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40030830">root</a><span>|</span><a href="#40047126">parent</a><span>|</span><a href="#40047609">prev</a><span>|</span><a href="#40048599">next</a><span>|</span><label class="collapse" for="c-40049419">[-]</label><label class="expand" for="c-40049419">[2 more]</label></div><br/><div class="children"><div class="content">Looks problematic. Is a string in Haskell a list? I would think that in Racket a string is a vector. FIRST and REST operations then would have very different implementations.</div><br/><div id="40049611" class="c"><input type="checkbox" id="c-40049611" checked=""/><div class="controls bullet"><span class="by">pitkali</span><span>|</span><a href="#40030830">root</a><span>|</span><a href="#40049419">parent</a><span>|</span><a href="#40048599">next</a><span>|</span><label class="collapse" for="c-40049611">[-]</label><label class="expand" for="c-40049611">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the String is a list of characters. The Haskell code uses head and tail on it. In Racket, they provided string-first and string-rest (at the end) to replace those.</div><br/></div></div></div></div></div></div><div id="40048420" class="c"><input type="checkbox" id="c-40048420" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#40030830">parent</a><span>|</span><a href="#40047126">prev</a><span>|</span><a href="#40048979">next</a><span>|</span><label class="collapse" for="c-40048420">[-]</label><label class="expand" for="c-40048420">[1 more]</label></div><br/><div class="children"><div class="content">I had the same reaction! I was excited about this article before realizing that &quot;only elementary functional programming techniques&quot; promised in the abstract actually means a full programming language used by 1% of programmers.</div><br/></div></div><div id="40048979" class="c"><input type="checkbox" id="c-40048979" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#40030830">parent</a><span>|</span><a href="#40048420">prev</a><span>|</span><a href="#40047226">next</a><span>|</span><label class="collapse" for="c-40048979">[-]</label><label class="expand" for="c-40048979">[1 more]</label></div><br/><div class="children"><div class="content">It would help if it was clear what tokens are part of the language or standard library, and what tokens are implementation of this algorithm (as in, some syntax highlighting would be nice :).</div><br/></div></div><div id="40047226" class="c"><input type="checkbox" id="c-40047226" checked=""/><div class="controls bullet"><span class="by">ks2048</span><span>|</span><a href="#40030830">parent</a><span>|</span><a href="#40048979">prev</a><span>|</span><a href="#40047422">next</a><span>|</span><label class="collapse" for="c-40047226">[-]</label><label class="expand" for="c-40047226">[1 more]</label></div><br/><div class="children"><div class="content">I recently began learning Haskell via Graham Hutton’s YouTube series. Recommended!</div><br/></div></div><div id="40047422" class="c"><input type="checkbox" id="c-40047422" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40030830">parent</a><span>|</span><a href="#40047226">prev</a><span>|</span><a href="#40048713">next</a><span>|</span><label class="collapse" for="c-40047422">[-]</label><label class="expand" for="c-40047422">[1 more]</label></div><br/><div class="children"><div class="content">I mean this is the Journal of Functional Programming... That being said, I wish more people had your response. Curiosity and openness are beautiful things.</div><br/></div></div></div></div><div id="40048713" class="c"><input type="checkbox" id="c-40048713" checked=""/><div class="controls bullet"><span class="by">andrewp123</span><span>|</span><a href="#40030830">prev</a><span>|</span><a href="#40048188">next</a><span>|</span><label class="collapse" for="c-40048713">[-]</label><label class="expand" for="c-40048713">[1 more]</label></div><br/><div class="children"><div class="content">It’s really easy to come up with KMP.  Just write an algorithm that searches for a substring p in string s. Make your algorithm efficient by sliding two pointers down s to find the biggest possible match, often called “sliding window”.<p>You want to grow the window as big as possible to match the substring. The data structure you naturally come up with to do checks efficiently here is the one you use in KMP.</div><br/></div></div><div id="40048188" class="c"><input type="checkbox" id="c-40048188" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#40048713">prev</a><span>|</span><a href="#40048629">next</a><span>|</span><label class="collapse" for="c-40048188">[-]</label><label class="expand" for="c-40048188">[1 more]</label></div><br/><div class="children"><div class="content">Another fun one is the Aho-Corasick algorithm [0] which is great (i.e. more efficient) when you have <i>multiple different</i> target strings you want to find and you don&#x27;t want to do multiple scans of the document.<p>Like KMP, it involves a preliminary step of analyzing the search term(s), and from them it builds a directed graph representing rules for what to do while consuming the stream of document-characters.<p>To find all occurrences, it&#x27;s something like O(document_length + all_target_words_combined_length + number_of_hits) .<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aho-Corasick_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aho-Corasick_algorithm</a></div><br/></div></div><div id="40048629" class="c"><input type="checkbox" id="c-40048629" checked=""/><div class="controls bullet"><span class="by">jkuria</span><span>|</span><a href="#40048188">prev</a><span>|</span><a href="#40048387">next</a><span>|</span><label class="collapse" for="c-40048629">[-]</label><label class="expand" for="c-40048629">[1 more]</label></div><br/><div class="children"><div class="content">Rabin-Karp algorithm is also a fun one.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rabin%E2%80%93Karp_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rabin%E2%80%93Karp_algorithm</a></div><br/></div></div><div id="40048387" class="c"><input type="checkbox" id="c-40048387" checked=""/><div class="controls bullet"><span class="by">dreamcompiler</span><span>|</span><a href="#40048629">prev</a><span>|</span><a href="#40048008">next</a><span>|</span><label class="collapse" for="c-40048387">[-]</label><label class="expand" for="c-40048387">[2 more]</label></div><br/><div class="children"><div class="content">Good article. I&#x27;ve implemented Boyer-Moore several times and it&#x27;s <i>ridiculously</i> fast on typical English text, especially with long search strings.<p>I haven&#x27;t implemented KMP but I might try after reading this.</div><br/><div id="40048624" class="c"><input type="checkbox" id="c-40048624" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40048387">parent</a><span>|</span><a href="#40048008">next</a><span>|</span><label class="collapse" for="c-40048624">[-]</label><label class="expand" for="c-40048624">[1 more]</label></div><br/><div class="children"><div class="content">KMP is so slow, it&#x27;s not worth it. <a href="https:&#x2F;&#x2F;rurban.github.io&#x2F;smart&#x2F;results&#x2F;all&#x2F;englishTexts.html" rel="nofollow">https:&#x2F;&#x2F;rurban.github.io&#x2F;smart&#x2F;results&#x2F;all&#x2F;englishTexts.html</a><p>BM beats it easily, not talking about the best two-way search algorithms, as implemented in musl.<p>Usually Thierry Lecroqs site has all the graphical descriptions of string search algos, just the latest are missing. <a href="https:&#x2F;&#x2F;www-igm.univ-mlv.fr&#x2F;~lecroq&#x2F;string&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;www-igm.univ-mlv.fr&#x2F;~lecroq&#x2F;string&#x2F;index.html</a></div><br/></div></div></div></div><div id="40048008" class="c"><input type="checkbox" id="c-40048008" checked=""/><div class="controls bullet"><span class="by">mehulashah</span><span>|</span><a href="#40048387">prev</a><span>|</span><a href="#40048969">next</a><span>|</span><label class="collapse" for="c-40048008">[-]</label><label class="expand" for="c-40048008">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like I’m learning Haskell soon.</div><br/></div></div><div id="40048969" class="c"><input type="checkbox" id="c-40048969" checked=""/><div class="controls bullet"><span class="by">hzay</span><span>|</span><a href="#40048008">prev</a><span>|</span><label class="collapse" for="c-40048969">[-]</label><label class="expand" for="c-40048969">[1 more]</label></div><br/><div class="children"><div class="content">Nice. I tried visualizing this algorithm here - <a href="https:&#x2F;&#x2F;visuallyexplain.pages.dev&#x2F;kmp&#x2F;algorithm-(wip)" rel="nofollow">https:&#x2F;&#x2F;visuallyexplain.pages.dev&#x2F;kmp&#x2F;algorithm-(wip)</a> . The sidebar has a bunch of completed algos -- DFS, BFS, binary heap queries, dijkstra&#x27;s, union find, topological sort, quicksort, etc.<p>I abandoned this project without completing KMP. If anyone is interested in this sort of algorithm explanations, I&#x27;d love to collaborate &#x2F; finish this project.</div><br/></div></div></div></div></div></div></div></body></html>