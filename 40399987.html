<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716109254797" as="style"/><link rel="stylesheet" href="styles.css?v=1716109254797"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.contrib.andrew.cmu.edu/~somlo/BTCP/">A trustworthy, free (libre), Linux capable, self-hosting 64bit RISC-V computer</a> <span class="domain">(<a href="https://www.contrib.andrew.cmu.edu">www.contrib.andrew.cmu.edu</a>)</span></div><div class="subtext"><span>caned</span> | <span>48 comments</span></div><br/><div><div id="40401425" class="c"><input type="checkbox" id="c-40401425" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40400931">next</a><span>|</span><label class="collapse" for="c-40401425">[-]</label><label class="expand" for="c-40401425">[18 more]</label></div><br/><div class="children"><div class="content">&gt; The chip foundry wouldn&#x27;t know what the FPGA will be used for, and where the proverbial &quot;privilege bit&quot; will end up being laid out on the chip, which mitigates against Privilege Escalation hardware backdoors. Exposure is limited to DoS attacks being planted into the silicon during FPGA fabrication, which yields a significantly improved level of assurance (i.e., the computer may stop working altogether, but can&#x27;t betray its owner to an adversary while pretending to operate correctly).<p>I suppose in theory the FPGA could contain a hidden CPU that has full read&#x2F;write access to the FPGA program.<p>Further, if the system becomes popular and more FPGAs need to be produced for the same system or the next generation, then the foundry has additional information and they can make a good guess of where the privilege bit will be. Even simpler, they could program an FPGA with the code and figure it out manually.</div><br/><div id="40405318" class="c"><input type="checkbox" id="c-40405318" checked=""/><div class="controls bullet"><span class="by">mrob</span><span>|</span><a href="#40401425">parent</a><span>|</span><a href="#40404267">next</a><span>|</span><label class="collapse" for="c-40405318">[-]</label><label class="expand" for="c-40405318">[1 more]</label></div><br/><div class="children"><div class="content">I think backdooring the RAM would be easier. Modern DRAM has lots of complicated features (e.g. link training, targeted refresh, on-die ECC). I don&#x27;t know exactly how it&#x27;s implemented, but that&#x27;s plenty of complexity to provide cover for backdoors.<p>It should be possible to add something that watches for specific memory access patterns and provides arbitrary read&#x2F;write capabilities when the correct pattern is detected. This could be used for privilege escalation from untrusted but sandboxed code, e.g. JavaScript. It could work with any CPU architecture or OS, because the arbitrary memory reads could be used to detect the correct place to write.<p>This would be less effective with DIMMs or other multi-chip memory modules, but RISC-V computers are usually small single-board computers that only have a single DRAM chip.</div><br/></div></div><div id="40404267" class="c"><input type="checkbox" id="c-40404267" checked=""/><div class="controls bullet"><span class="by">karma_pharmer</span><span>|</span><a href="#40401425">parent</a><span>|</span><a href="#40405318">prev</a><span>|</span><a href="#40402203">next</a><span>|</span><label class="collapse" for="c-40404267">[-]</label><label class="expand" for="c-40404267">[2 more]</label></div><br/><div class="children"><div class="content"><i>I suppose in theory the FPGA could contain a hidden CPU that has full read&#x2F;write access to the FPGA program.</i><p>All of them do at this point.  It isn&#x27;t hidden.<p>You can&#x27;t buy a large FPGA without an ARM core in it.  The ARM cores all have an opaque signed blob running in EL3 that you can&#x27;t replace.  This isn&#x27;t a soft core on the fabric; it&#x27;s dedicated silicon.  And it has access to the ICAP (internal configuration access port) on Xilinx devices, and the equivalent on all the other manufacturers.</div><br/><div id="40405237" class="c"><input type="checkbox" id="c-40405237" checked=""/><div class="controls bullet"><span class="by">asddubs</span><span>|</span><a href="#40401425">root</a><span>|</span><a href="#40404267">parent</a><span>|</span><a href="#40402203">next</a><span>|</span><label class="collapse" for="c-40405237">[-]</label><label class="expand" for="c-40405237">[1 more]</label></div><br/><div class="children"><div class="content">What is it for?</div><br/></div></div></div></div><div id="40402203" class="c"><input type="checkbox" id="c-40402203" checked=""/><div class="controls bullet"><span class="by">ooterness</span><span>|</span><a href="#40401425">parent</a><span>|</span><a href="#40404267">prev</a><span>|</span><a href="#40401846">next</a><span>|</span><label class="collapse" for="c-40402203">[-]</label><label class="expand" for="c-40402203">[1 more]</label></div><br/><div class="children"><div class="content">This sort of thing is analogous to the &quot;Thompson hack&quot; [1], where a malicious compiler has a self-propagating backdoor. It never shows up in the source code, but self-injects into the binaries.<p>Thompson demonstrated this under controlled conditions. But realistically, the backdoor begins to approach AGI-level cunning to evade attempts at detection. It has to keep functioning and propagating as the hardware and software evolve, while still keeping a profile (size, execution time, etc.) low enough to continue evading detection.<p>Work like this that rebuilds modern computing on a completely different foundation, would seriously disrupt and complicate the use of this type of backdoor.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Backdoor_(computing)#Compiler_backdoors" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Backdoor_(computing)#Compiler_...</a></div><br/></div></div><div id="40401846" class="c"><input type="checkbox" id="c-40401846" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40401425">parent</a><span>|</span><a href="#40402203">prev</a><span>|</span><a href="#40401606">next</a><span>|</span><label class="collapse" for="c-40401846">[-]</label><label class="expand" for="c-40401846">[5 more]</label></div><br/><div class="children"><div class="content">For a nation state the most useful thing would be a &quot;kill bit&quot; where you can broadcast some signal or key and disable all your enemy&#x27;s computers.  That&#x27;s fairly easy to do in an FPGA - the signal would be detected by the serdes block(s) and the kill bit could just kill the power or clock or some other vital part of the chip.</div><br/><div id="40404208" class="c"><input type="checkbox" id="c-40404208" checked=""/><div class="controls bullet"><span class="by">8372049</span><span>|</span><a href="#40401425">root</a><span>|</span><a href="#40401846">parent</a><span>|</span><a href="#40402171">next</a><span>|</span><label class="collapse" for="c-40404208">[-]</label><label class="expand" for="c-40404208">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For a nation state the most useful thing would be a &quot;kill bit&quot; where you can broadcast some signal or key and disable all your enemy&#x27;s computers.<p>CNE is generally considered to be far more valuable than CNA. First of all keep in mind that all genuinely sensitive systems are air gapped, so you can&#x27;t effectively broadcast a signal to them.<p>Second, CNA is a one-off; after the attack you will typically lose access. CNE access on the other hand can persist for years or even decades, and will be beneficial in both &quot;cold&quot; scenarios for political and economic maneuvers, and closer to a flashpoint. CNA, on the other hand, is usually only relevant when a conflict is turning hot.</div><br/></div></div><div id="40402171" class="c"><input type="checkbox" id="c-40402171" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#40401425">root</a><span>|</span><a href="#40401846">parent</a><span>|</span><a href="#40404208">prev</a><span>|</span><a href="#40402216">next</a><span>|</span><label class="collapse" for="c-40402171">[-]</label><label class="expand" for="c-40402171">[2 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s the opposite. The FPGA makes it much harder to hide a trojan in the silicon. If the LUTs were biased, it would be detected fairly quickly. A dedicated circuit with an RF interface would be equally obvious in terms of chip usage and power draw.</div><br/><div id="40405000" class="c"><input type="checkbox" id="c-40405000" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40401425">root</a><span>|</span><a href="#40402171">parent</a><span>|</span><a href="#40402216">next</a><span>|</span><label class="collapse" for="c-40405000">[-]</label><label class="expand" for="c-40405000">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t say anything about modifying the LUTs or adding RF interfaces, I don&#x27;t know where you got that from.</div><br/></div></div></div></div><div id="40402216" class="c"><input type="checkbox" id="c-40402216" checked=""/><div class="controls bullet"><span class="by">greggsy</span><span>|</span><a href="#40401425">root</a><span>|</span><a href="#40401846">parent</a><span>|</span><a href="#40402171">prev</a><span>|</span><a href="#40401606">next</a><span>|</span><label class="collapse" for="c-40402216">[-]</label><label class="expand" for="c-40402216">[1 more]</label></div><br/><div class="children"><div class="content">Even better, a logical fuse that would make recovery impossibly expensive and timely.</div><br/></div></div></div></div><div id="40401606" class="c"><input type="checkbox" id="c-40401606" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#40401425">parent</a><span>|</span><a href="#40401846">prev</a><span>|</span><a href="#40401489">next</a><span>|</span><label class="collapse" for="c-40401606">[-]</label><label class="expand" for="c-40401606">[1 more]</label></div><br/><div class="children"><div class="content">I wonder as well whether it wouldn&#x27;t just be easier to snoop I&#x2F;O and somehow exfiltrate the data. (This would be completely impractical for dragnet surveillance, of course – but I&#x27;m sure if a state actor knew that some organization was using this technique to avoid surveillance, _and_ was using a predictable software setup...)</div><br/></div></div><div id="40401489" class="c"><input type="checkbox" id="c-40401489" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#40401425">parent</a><span>|</span><a href="#40401606">prev</a><span>|</span><a href="#40402026">next</a><span>|</span><label class="collapse" for="c-40401489">[-]</label><label class="expand" for="c-40401489">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I suppose in theory the FPGA could contain a hidden CPU that has full read&#x2F;write access to the FPGA program.<p>Even if it did, it would be exceptionally difficult for that CPU to identify which registers&#x2F;gates on the FPGA were being used to implement which components of the soft CPU. The layout isn&#x27;t fixed; there&#x27;s no consistent mapping of hardware LUTs&#x2F;FFs to synthesized functionality.</div><br/><div id="40401522" class="c"><input type="checkbox" id="c-40401522" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40401425">root</a><span>|</span><a href="#40401489">parent</a><span>|</span><a href="#40402026">next</a><span>|</span><label class="collapse" for="c-40401522">[-]</label><label class="expand" for="c-40401522">[4 more]</label></div><br/><div class="children"><div class="content">Even if the mapping changes, the network (graph of logic gates) will locally be similar. So a subgraph matching algorithm might be all that is needed.</div><br/><div id="40402597" class="c"><input type="checkbox" id="c-40402597" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40401425">root</a><span>|</span><a href="#40401522">parent</a><span>|</span><a href="#40402026">next</a><span>|</span><label class="collapse" for="c-40402597">[-]</label><label class="expand" for="c-40402597">[3 more]</label></div><br/><div class="children"><div class="content">That would you mean you connect your hidden CPU to essentially every wire inside the FPGA. Trivial to detect, and extremely expensive, and probably even impossible considering timing model.</div><br/><div id="40402787" class="c"><input type="checkbox" id="c-40402787" checked=""/><div class="controls bullet"><span class="by">tredre3</span><span>|</span><a href="#40401425">root</a><span>|</span><a href="#40402597">parent</a><span>|</span><a href="#40402026">next</a><span>|</span><label class="collapse" for="c-40402787">[-]</label><label class="expand" for="c-40402787">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no need for such complexity. FPGAs read their programming from an i2c eeprom&#x2F;flash when they boot, the hidden CPU just has to sniff that bus to get the entire bitstream and know the mapping.</div><br/><div id="40402836" class="c"><input type="checkbox" id="c-40402836" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40401425">root</a><span>|</span><a href="#40402787">parent</a><span>|</span><a href="#40402026">next</a><span>|</span><label class="collapse" for="c-40402836">[-]</label><label class="expand" for="c-40402836">[1 more]</label></div><br/><div class="children"><div class="content">And then you know that mapping. That still means you will need to connect to arbitrary wires. If you have the mapping but you aren&#x27;t connected to the wire you want to disrupt or sniff then tough luck you can&#x27;t do anything.<p>Theoretically what you could do is MITM the bitstream, upload it to a server. Resynthesize, place and route with your sniff wires connected and write that back flash. But now you have to hide a radio, and either force a restart or hope a restart will happen.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40402026" class="c"><input type="checkbox" id="c-40402026" checked=""/><div class="controls bullet"><span class="by">admax88qqq</span><span>|</span><a href="#40401425">parent</a><span>|</span><a href="#40401489">prev</a><span>|</span><a href="#40402583">next</a><span>|</span><label class="collapse" for="c-40402026">[-]</label><label class="expand" for="c-40402026">[1 more]</label></div><br/><div class="children"><div class="content">Without having thought it through fully I feel like the classic &quot;trusting trust&quot; attack could work at the fpga&#x2F;bitstream level.</div><br/></div></div><div id="40402583" class="c"><input type="checkbox" id="c-40402583" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40401425">parent</a><span>|</span><a href="#40402026">prev</a><span>|</span><a href="#40400931">next</a><span>|</span><label class="collapse" for="c-40402583">[-]</label><label class="expand" for="c-40402583">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s certainly non-trivial to put a hidden CPU in a FPGA that has full read&#x2F;write access. The wire configuration inside the FPGA will be different for every design loaded into, hell even for the same design the place and router will do different things. So to what will you connect your hidden CPU?</div><br/></div></div></div></div><div id="40400931" class="c"><input type="checkbox" id="c-40400931" checked=""/><div class="controls bullet"><span class="by">buildbot</span><span>|</span><a href="#40401425">prev</a><span>|</span><a href="#40401753">next</a><span>|</span><label class="collapse" for="c-40400931">[-]</label><label class="expand" for="c-40400931">[5 more]</label></div><br/><div class="children"><div class="content">It’s really quite amazing to login a linux shell on an orangecrab FPGA running a RISV-V softcore, built using an open source toolchain. That was impossible not so long ago! At best you’d have something like Xilinx PetaLinux and all their proprietary junk.</div><br/><div id="40403901" class="c"><input type="checkbox" id="c-40403901" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40400931">parent</a><span>|</span><a href="#40402879">next</a><span>|</span><label class="collapse" for="c-40403901">[-]</label><label class="expand" for="c-40403901">[1 more]</label></div><br/><div class="children"><div class="content">Fun thing is that orangecrab&#x27;s FPGA is not even a requirement.<p>A tiny iCE40 LP1K will fit SERV (and even QERV) no prob.<p>It&#x27;s amazing how small a fully compliant RISC-V implementation can be.</div><br/></div></div><div id="40402879" class="c"><input type="checkbox" id="c-40402879" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#40400931">parent</a><span>|</span><a href="#40403901">prev</a><span>|</span><a href="#40401753">next</a><span>|</span><label class="collapse" for="c-40402879">[-]</label><label class="expand" for="c-40402879">[3 more]</label></div><br/><div class="children"><div class="content">This is and will be a rallying moment soon for the community, both open hardware and software finally working together! This will be huge by the end of the decade.</div><br/><div id="40403014" class="c"><input type="checkbox" id="c-40403014" checked=""/><div class="controls bullet"><span class="by">taftster</span><span>|</span><a href="#40400931">root</a><span>|</span><a href="#40402879">parent</a><span>|</span><a href="#40403637">next</a><span>|</span><label class="collapse" for="c-40403014">[-]</label><label class="expand" for="c-40403014">[1 more]</label></div><br/><div class="children"><div class="content">I guess using some local definition of &quot;huge&quot;.</div><br/></div></div><div id="40403637" class="c"><input type="checkbox" id="c-40403637" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#40400931">root</a><span>|</span><a href="#40402879">parent</a><span>|</span><a href="#40403014">prev</a><span>|</span><a href="#40401753">next</a><span>|</span><label class="collapse" for="c-40403637">[-]</label><label class="expand" for="c-40403637">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is and will be a rallying moment soon for the community<p>My guy this thing is 4 years old. Spoiler alert: it wasn&#x27;t.</div><br/></div></div></div></div></div></div><div id="40401753" class="c"><input type="checkbox" id="c-40401753" checked=""/><div class="controls bullet"><span class="by">ruslan</span><span>|</span><a href="#40400931">prev</a><span>|</span><a href="#40403293">next</a><span>|</span><label class="collapse" for="c-40401753">[-]</label><label class="expand" for="c-40401753">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m kind of going the same direction, but different route. My design is based on VexRiscv and all hardware is written in SpinalHDL. It does not run Linux yet because of limited SRAM (512KB) on my Karnix board, but it has Ethernet and HDMI. I have coded a CGA-like video adapter with HDMI interface that supports graphics (320x240x4) and text (80x30x16) modes with hardware assisted smooth scrolling. :)<p>If someone is interested, here&#x27;s a rather brief README:
 <a href="https:&#x2F;&#x2F;github.com&#x2F;Fabmicro-LLC&#x2F;VexRiscvWithKarnix&#x2F;blob&#x2F;karnix_extended&#x2F;scripts&#x2F;KarnixExtended&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;Fabmicro-LLC&#x2F;VexRiscvWithKarnix&#x2F;blob&#x2F;karn...</a><p>KiCAD project for the board: <a href="https:&#x2F;&#x2F;github.com&#x2F;Fabmicro-LLC&#x2F;Karnix_ASB-254">https:&#x2F;&#x2F;github.com&#x2F;Fabmicro-LLC&#x2F;Karnix_ASB-254</a></div><br/></div></div><div id="40403293" class="c"><input type="checkbox" id="c-40403293" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#40401753">prev</a><span>|</span><a href="#40401999">next</a><span>|</span><label class="collapse" for="c-40403293">[-]</label><label class="expand" for="c-40403293">[1 more]</label></div><br/><div class="children"><div class="content">This is cool. I was happy see the prominent reference to my work on diverse double-compiling (DDC), which counters the trusting trust attack. If you&#x27;re interested  in DDC, check out
<a href="https:&#x2F;&#x2F;dwheeler.com&#x2F;trusting-trust" rel="nofollow">https:&#x2F;&#x2F;dwheeler.com&#x2F;trusting-trust</a></div><br/></div></div><div id="40401999" class="c"><input type="checkbox" id="c-40401999" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#40403293">prev</a><span>|</span><a href="#40402655">next</a><span>|</span><label class="collapse" for="c-40401999">[-]</label><label class="expand" for="c-40401999">[1 more]</label></div><br/><div class="children"><div class="content">Rebuilding the system on itself and validating that the bitfile is the same is nice.<p>I&#x27;m amazed that it could be rebuilt in 512MB (and in &quot;only&quot; 4.5 hours on a ~65MHz CPU.) My experience with yosys (and vivado etc.) is that they seem to want many gigabytes.<p>&gt; A 65MHz Linux-capable CPU inevitably invokes memories of mid- 1990s Intel 486 and first-generation Pentium processors.<p>50-65MHz* and 512MB  seems comparable to an early 1990s Unix workstation. Arguably better on the RAM side.<p>*4.5 Mflops on double precision linpack for lowRISC&#x2F;50MHz</div><br/></div></div><div id="40402655" class="c"><input type="checkbox" id="c-40402655" checked=""/><div class="controls bullet"><span class="by">mntmn</span><span>|</span><a href="#40401999">prev</a><span>|</span><a href="#40401216">next</a><span>|</span><label class="collapse" for="c-40402655">[-]</label><label class="expand" for="c-40402655">[1 more]</label></div><br/><div class="children"><div class="content">I did something similar in 2022, also with LiteX, but not self-hosting because it used a Kintex-7 FPGA which at least at the time required Vivado for the actual place-and-route. It did result in a open gateware laptop running Linux and Xorg, though (thanks to Linux-on-LiteX-VexRiscV): <a href="https:&#x2F;&#x2F;mntre.com&#x2F;media&#x2F;reform_md&#x2F;2022-09-29-rkx7-showcase.html" rel="nofollow">https:&#x2F;&#x2F;mntre.com&#x2F;media&#x2F;reform_md&#x2F;2022-09-29-rkx7-showcase.h...</a></div><br/></div></div><div id="40401216" class="c"><input type="checkbox" id="c-40401216" checked=""/><div class="controls bullet"><span class="by">dmarinus</span><span>|</span><a href="#40402655">prev</a><span>|</span><a href="#40401424">next</a><span>|</span><label class="collapse" for="c-40401216">[-]</label><label class="expand" for="c-40401216">[1 more]</label></div><br/><div class="children"><div class="content">hey this is the same guy who did some work for running osx on qemu&#x2F;kvm. <a href="https:&#x2F;&#x2F;www.contrib.andrew.cmu.edu&#x2F;~somlo&#x2F;OSXKVM&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.contrib.andrew.cmu.edu&#x2F;~somlo&#x2F;OSXKVM&#x2F;</a></div><br/></div></div><div id="40401424" class="c"><input type="checkbox" id="c-40401424" checked=""/><div class="controls bullet"><span class="by">robinsonb5</span><span>|</span><a href="#40401216">prev</a><span>|</span><a href="#40401421">next</a><span>|</span><label class="collapse" for="c-40401424">[-]</label><label class="expand" for="c-40401424">[1 more]</label></div><br/><div class="children"><div class="content">This is very, very cool. I&#x27;ve been thinking for a while that a fully self-hosted RISC-V machine is sorely needed. The biggest limiting factor at the moment actually seems to be finding an FPGA board which has enough RAM on board.  The target board here has 512 megabytes, I think - but FPGA toolchains are much happier with several gigabytes to play with.</div><br/></div></div><div id="40401421" class="c"><input type="checkbox" id="c-40401421" checked=""/><div class="controls bullet"><span class="by">bitcompost</span><span>|</span><a href="#40401424">prev</a><span>|</span><a href="#40401080">next</a><span>|</span><label class="collapse" for="c-40401421">[-]</label><label class="expand" for="c-40401421">[14 more]</label></div><br/><div class="children"><div class="content">While I love the idea of self-hosting HW and SW, I can&#x27;t even imagine the pain of building stuff like GCC on 60Mhz CPU. Not to mention the Rocket CPU is written in Scala. I recently stopped using Gentoo on RockPro64, because the compile times were unbearable, and that&#x27;s a system orders of magnitude faster than what they want to use.</div><br/><div id="40401964" class="c"><input type="checkbox" id="c-40401964" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#40401421">parent</a><span>|</span><a href="#40401495">next</a><span>|</span><label class="collapse" for="c-40401964">[-]</label><label class="expand" for="c-40401964">[1 more]</label></div><br/><div class="children"><div class="content">You can definitely go considerably faster. A lot of these FOSS cores are either outright unoptimized or target ASICs and so end up performing very badly on FPGAs. A well designed core on a modern FPGA (not one of these bottom of the barrel low power Lattice parts) can definitely hit 250+ MHz with a much more powerful microarch. It&#x27;s neither cheap nor easy which is why we tend not to see it in the hobby space. That, and better FPGAs tend not to have FOSS toolchains and so it doesn&#x27;t quite meet the libre spirit.<p>But, yes, even at 250MHz trying to run Chipyard on a softcore would certainly be an exercise in patience :)</div><br/></div></div><div id="40401495" class="c"><input type="checkbox" id="c-40401495" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#40401421">parent</a><span>|</span><a href="#40401964">prev</a><span>|</span><a href="#40403245">next</a><span>|</span><label class="collapse" for="c-40401495">[-]</label><label class="expand" for="c-40401495">[7 more]</label></div><br/><div class="children"><div class="content">People used 50Mhz SPARC systems to do real work, and the peripherals were all a lot slower (10mbps Ethernet, slower SCSI drives) with less and slower RAM. But it might take a week to compile everything you wanted, I agree; of course there is always cross-compiling as well.</div><br/><div id="40401586" class="c"><input type="checkbox" id="c-40401586" checked=""/><div class="controls bullet"><span class="by">RobotToaster</span><span>|</span><a href="#40401421">root</a><span>|</span><a href="#40401495">parent</a><span>|</span><a href="#40401535">next</a><span>|</span><label class="collapse" for="c-40401586">[-]</label><label class="expand" for="c-40401586">[2 more]</label></div><br/><div class="children"><div class="content">That was before everything became a snap package in a docker image.</div><br/><div id="40402398" class="c"><input type="checkbox" id="c-40402398" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#40401421">root</a><span>|</span><a href="#40401586">parent</a><span>|</span><a href="#40401535">next</a><span>|</span><label class="collapse" for="c-40402398">[-]</label><label class="expand" for="c-40402398">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That was before everything became a snap package in a docker image.<p>A modern app should consist of dozens of of docker images in k8s on remote cloud infrastructure, all running &quot;serverless&quot; microservices in optimized python*, connected via REST* APIs to a javascript front-end and&#x2F;or electron &quot;desktop&quot; app, with extensive telemetry and analytics subsystems connected to a prometheus&#x2F;grafana dashboard.<p>That is ignoring the ML&#x2F;LLM components, of course.<p>If all of this is running reliably, and the network isn&#x27;t broken again, then you may be able to share notepad pages between your laptop and smartphone.<p>*possibly golang&#x2F;protobufs if your name happens to be google and if pytorch and tensorflow haven&#x27;t been invented yet</div><br/></div></div></div></div><div id="40401535" class="c"><input type="checkbox" id="c-40401535" checked=""/><div class="controls bullet"><span class="by">bitcompost</span><span>|</span><a href="#40401421">root</a><span>|</span><a href="#40401495">parent</a><span>|</span><a href="#40401586">prev</a><span>|</span><a href="#40403245">next</a><span>|</span><label class="collapse" for="c-40401535">[-]</label><label class="expand" for="c-40401535">[4 more]</label></div><br/><div class="children"><div class="content">Oh I believe in theory a 50Mhz CPU is capable of doing almost everything I need, but it just lacks the software optimized for it. I think a week to compile everything is too optimistic.</div><br/><div id="40402863" class="c"><input type="checkbox" id="c-40402863" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#40401421">root</a><span>|</span><a href="#40401535">parent</a><span>|</span><a href="#40402024">next</a><span>|</span><label class="collapse" for="c-40402863">[-]</label><label class="expand" for="c-40402863">[1 more]</label></div><br/><div class="children"><div class="content">Old compilers&#x2F;IDEs like Turbo Pascal or Think C were&#x2F;are usably fast on single-digit MHz machines and emulators.<p>And even if the CPU is 50 MHz, modern DRAM and NVMe flash are very fast compared to memory and storage on 1990s (or older) machines.<p>Older versions of Microsoft Office (etc.) ran about the same on 50 MHz systems as Office 365 runs today.</div><br/></div></div><div id="40402024" class="c"><input type="checkbox" id="c-40402024" checked=""/><div class="controls bullet"><span class="by">kwhitefoot</span><span>|</span><a href="#40401421">root</a><span>|</span><a href="#40401535">parent</a><span>|</span><a href="#40402863">prev</a><span>|</span><a href="#40403245">next</a><span>|</span><label class="collapse" for="c-40402024">[-]</label><label class="expand" for="c-40402024">[2 more]</label></div><br/><div class="children"><div class="content">I did valuable work on a 2 MHz Apple II with a 4 MHz Z80 add-on running CP&#x2F;M that I used to write the documentation.  The documentation part was just as fast forty years ago as it is now but assembling the code was glacially slow.  The 6502 macro assembler running on the Apple too forty minutes to assemble code that filled an 8 k EPROM.</div><br/><div id="40402614" class="c"><input type="checkbox" id="c-40402614" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#40401421">root</a><span>|</span><a href="#40402024">parent</a><span>|</span><a href="#40403245">next</a><span>|</span><label class="collapse" for="c-40402614">[-]</label><label class="expand" for="c-40402614">[1 more]</label></div><br/><div class="children"><div class="content">6502 assemblers are amazingly fast on more recent hardware. Something like 60-70ms to run a script to assemble and link an a version of msbasic (AppleSoft) on my old laptop.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mist64&#x2F;msbasic">https:&#x2F;&#x2F;github.com&#x2F;mist64&#x2F;msbasic</a></div><br/></div></div></div></div></div></div></div></div><div id="40403245" class="c"><input type="checkbox" id="c-40403245" checked=""/><div class="controls bullet"><span class="by">marssaxman</span><span>|</span><a href="#40401421">parent</a><span>|</span><a href="#40401495">prev</a><span>|</span><a href="#40402070">next</a><span>|</span><label class="collapse" for="c-40403245">[-]</label><label class="expand" for="c-40403245">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I can&#x27;t even imagine the pain of building stuff like GCC on 60Mhz CPU<p>Some of us remember what that sort of thing was like, not so very long ago...</div><br/><div id="40404102" class="c"><input type="checkbox" id="c-40404102" checked=""/><div class="controls bullet"><span class="by">brucehoult</span><span>|</span><a href="#40401421">root</a><span>|</span><a href="#40403245">parent</a><span>|</span><a href="#40403545">next</a><span>|</span><label class="collapse" for="c-40404102">[-]</label><label class="expand" for="c-40404102">[1 more]</label></div><br/><div class="children"><div class="content">I remember when I got CodeWarrior on my PowerMac 6100&#x2F;60 and suddenly I could answer questions online about weird MacApp problems by making a temporary project with their code and compiling the whole of MacApp in 5 minutes.<p>Previously that had taken about 2 hours (Quadra with MPW), and I did clean builds only when absolutely necessary.<p>Truly painful was trying to write large programs in Apple (UCSD) Pascal on a 1 MHz 6502.</div><br/></div></div><div id="40403545" class="c"><input type="checkbox" id="c-40403545" checked=""/><div class="controls bullet"><span class="by">nineteen999</span><span>|</span><a href="#40401421">root</a><span>|</span><a href="#40403245">parent</a><span>|</span><a href="#40404102">prev</a><span>|</span><a href="#40403885">next</a><span>|</span><label class="collapse" for="c-40403545">[-]</label><label class="expand" for="c-40403545">[1 more]</label></div><br/><div class="children"><div class="content">Back then GCC was much smaller, and only contained C code, not C++. But sure, let&#x27;s compare apples and ... much bigger heavier apples.</div><br/></div></div><div id="40403885" class="c"><input type="checkbox" id="c-40403885" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#40401421">root</a><span>|</span><a href="#40403245">parent</a><span>|</span><a href="#40403545">prev</a><span>|</span><a href="#40402070">next</a><span>|</span><label class="collapse" for="c-40403885">[-]</label><label class="expand" for="c-40403885">[1 more]</label></div><br/><div class="children"><div class="content">I made a meme and sent it to my even older coworker with two guys from the office looking pensive. Titled &#x27;The Build Failed Saturday and Again Sunday Night&#x27;</div><br/></div></div></div></div><div id="40402070" class="c"><input type="checkbox" id="c-40402070" checked=""/><div class="controls bullet"><span class="by">dwheeler</span><span>|</span><a href="#40401421">parent</a><span>|</span><a href="#40403245">prev</a><span>|</span><a href="#40401080">next</a><span>|</span><label class="collapse" for="c-40402070">[-]</label><label class="expand" for="c-40402070">[1 more]</label></div><br/><div class="children"><div class="content">At one time many of us dreamed of having a computer that could run as fast as 60MHz. The first computers I used ran around 1MHz. Compilation will take longer on a slower machine, but that really isn&#x27;t a big deal. If the computer is reliable and the build scripts are correct, you can just let the process run over days or weeks. I&#x27;ve run many tasks in my life that took days or weeks. Cue &quot;compiling&quot;: <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;303&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;303&#x2F;</a><p>The real problem is debugging. Debugging the process on a slow system can be unpleasant due to long turn-arounds. Historically the solution is to work in stages &amp; be able to restart at different points (so you don&#x27;t have to do the <i>whole</i> process each time). That would work here too. In this case, there&#x27;s an additional option: you can debug the scripts on a much faster though less trustworthy system. Then, once it works, you can run it on the slower system.</div><br/></div></div></div></div><div id="40401080" class="c"><input type="checkbox" id="c-40401080" checked=""/><div class="controls bullet"><span class="by">Guestmodinfo</span><span>|</span><a href="#40401421">prev</a><span>|</span><a href="#40402924">next</a><span>|</span><label class="collapse" for="c-40401080">[-]</label><label class="expand" for="c-40401080">[1 more]</label></div><br/><div class="children"><div class="content">Wow, I am starting to read all your reading material that you have put up.<p>It&#x27;s really what I have always wanted to do and it&#x27;s more than that because you are using FPGAs. I am from India and I want to help you in any way I can because I also have wanted to go on this journey. 
It&#x27;s just amazing I wish you all the blessings.</div><br/></div></div><div id="40402924" class="c"><input type="checkbox" id="c-40402924" checked=""/><div class="controls bullet"><span class="by">indigodaddy</span><span>|</span><a href="#40401080">prev</a><span>|</span><a href="#40404443">next</a><span>|</span><label class="collapse" for="c-40402924">[-]</label><label class="expand" for="c-40402924">[1 more]</label></div><br/><div class="children"><div class="content">All the good stuff is here looks like (linked in the op article):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;litex-hub&#x2F;linux-on-litex-rocket">https:&#x2F;&#x2F;github.com&#x2F;litex-hub&#x2F;linux-on-litex-rocket</a><p>Cool, so didn’t know that you could use screen to connect to a tty&#x2F;serial.  Neat.</div><br/></div></div><div id="40404443" class="c"><input type="checkbox" id="c-40404443" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#40402924">prev</a><span>|</span><a href="#40402601">next</a><span>|</span><label class="collapse" for="c-40404443">[-]</label><label class="expand" for="c-40404443">[1 more]</label></div><br/><div class="children"><div class="content">(2020)</div><br/></div></div><div id="40402601" class="c"><input type="checkbox" id="c-40402601" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#40404443">prev</a><span>|</span><label class="collapse" for="c-40402601">[-]</label><label class="expand" for="c-40402601">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing free about FPGAs...</div><br/></div></div></div></div></div></div></div></body></html>