<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693731658834" as="style"/><link rel="stylesheet" href="styles.css?v=1693731658834"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://towardsdev.com/currying-in-kotlin-9be88bcc930d">Currying in Kotlin</a> <span class="domain">(<a href="https://towardsdev.com">towardsdev.com</a>)</span></div><div class="subtext"><span>unripe_syntax</span> | <span>28 comments</span></div><br/><div><div id="37368256" class="c"><input type="checkbox" id="c-37368256" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#37368512">next</a><span>|</span><label class="collapse" for="c-37368256">[-]</label><label class="expand" for="c-37368256">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m always wondered why some people prefer to use a lambda in a variable instead of just a function.<p>I&#x27;m referring to using<p><pre><code>    var f = (a) -&gt; code;
</code></pre>
Instead of<p><pre><code>    function f(a){ code }
</code></pre>
Which are exactly the same.<p>JavaScript (and typescript) prefers them. Is it because of a convention or it really has advantages?<p>Haskell (and other functional languages) also use them a lot, but I guess in these cases the language is designed around it.<p>Kotlin, Java and other languages with lambdas doesn&#x27;t really benefit from them in my opinion. If it&#x27;s a global variable, a function is just enough and 99% of the times preferred. If it is something local, either inline it or also use a function (Kotlin allows for inlined functions, Java doesn&#x27;t; and maybe, if you need to capture variables, a local Function variable is the only instance where this is useful, but otherwise please just use a function.  * )<p>Python and other languages with limited or not available lambdas do use functions, and there are rare cases where a lambda would help.<p>In general, if you are using language X try to use language X&#x27;s features and best practices. Don&#x27;t try to program as if you were using language Y, it will only make it more confusing.
You can easily see when someone is used to a language and tries to use another without understanding the differences. Going from java to python is a very clear example (classes everywhere! Loops just because!)<p>* In java, an initialized private Function&lt;&gt; field is 99% of the time useless and worse than just a function. And 99.99% if it is final.</div><br/><div id="37368357" class="c"><input type="checkbox" id="c-37368357" checked=""/><div class="controls bullet"><span class="by">JD557</span><span>|</span><a href="#37368256">parent</a><span>|</span><a href="#37368620">next</a><span>|</span><label class="collapse" for="c-37368357">[-]</label><label class="expand" for="c-37368357">[3 more]</label></div><br/><div class="children"><div class="content">&gt; JavaScript (and typescript) prefers them. Is it because of a convention or it really has advantages?<p>There are some slight differences: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Functions&#x2F;Arrow_functions" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>I believe the reason arrow functions are prefered in his is because of the way `this` is handled: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Operators&#x2F;this" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/><div id="37368486" class="c"><input type="checkbox" id="c-37368486" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#37368256">root</a><span>|</span><a href="#37368357">parent</a><span>|</span><a href="#37368432">next</a><span>|</span><label class="collapse" for="c-37368486">[-]</label><label class="expand" for="c-37368486">[1 more]</label></div><br/><div class="children"><div class="content">Ah! Thanks. I always forget the special &quot;this&quot; differences. I still prefer to use function when &quot;this&quot; is not involved though (I find strange to have a function as a variable, if you are not using it as a variable that is.)</div><br/></div></div><div id="37368432" class="c"><input type="checkbox" id="c-37368432" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#37368256">root</a><span>|</span><a href="#37368357">parent</a><span>|</span><a href="#37368486">prev</a><span>|</span><a href="#37368620">next</a><span>|</span><label class="collapse" for="c-37368432">[-]</label><label class="expand" for="c-37368432">[1 more]</label></div><br/><div class="children"><div class="content">you would be correct. :)</div><br/></div></div></div></div><div id="37368620" class="c"><input type="checkbox" id="c-37368620" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37368256">parent</a><span>|</span><a href="#37368357">prev</a><span>|</span><a href="#37368338">next</a><span>|</span><label class="collapse" for="c-37368620">[-]</label><label class="expand" for="c-37368620">[2 more]</label></div><br/><div class="children"><div class="content">In Kotlin the syntactic overhead of `fun` is annoying. You have to do a lot more ceremony (e.g. writing return) than if you use the lambda syntax.<p>(I don&#x27;t know why they made return mandatory in Kotlin, as a language can function just fine without explicitly writing return everywhere.)</div><br/><div id="37368846" class="c"><input type="checkbox" id="c-37368846" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#37368256">root</a><span>|</span><a href="#37368620">parent</a><span>|</span><a href="#37368338">next</a><span>|</span><label class="collapse" for="c-37368846">[-]</label><label class="expand" for="c-37368846">[1 more]</label></div><br/><div class="children"><div class="content">Are you sure? Kotlin allows for one-line functions. This is valid Kotlin:<p><pre><code>    fun sum(a:Int, b:Int) = a+b
</code></pre>
In fact, it is even shorter than the lambda equivalent:<p><pre><code>    val sum = {a:Int, b:Int -&gt; a+b }</code></pre></div><br/></div></div></div></div><div id="37368338" class="c"><input type="checkbox" id="c-37368338" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#37368256">parent</a><span>|</span><a href="#37368620">prev</a><span>|</span><a href="#37368368">next</a><span>|</span><label class="collapse" for="c-37368338">[-]</label><label class="expand" for="c-37368338">[1 more]</label></div><br/><div class="children"><div class="content">I think In JavaScript, it often comes down to the fact that you want to use arrow functions if you need to reference this, for instance when creating callbacks for events in a component class context. Since there are some use cases where it’s necessary, some people just use it all the time so as not to have to think about it. The only thing you lose is function hoisting.</div><br/></div></div><div id="37368368" class="c"><input type="checkbox" id="c-37368368" checked=""/><div class="controls bullet"><span class="by">mekster</span><span>|</span><a href="#37368256">parent</a><span>|</span><a href="#37368338">prev</a><span>|</span><a href="#37368512">next</a><span>|</span><label class="collapse" for="c-37368368">[-]</label><label class="expand" for="c-37368368">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t define the scope&#x2F;reassignmentability with latter use.</div><br/></div></div></div></div><div id="37368512" class="c"><input type="checkbox" id="c-37368512" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#37368256">prev</a><span>|</span><a href="#37366509">next</a><span>|</span><label class="collapse" for="c-37368512">[-]</label><label class="expand" for="c-37368512">[2 more]</label></div><br/><div class="children"><div class="content">I enjoy reading and writing &quot;Functional&quot; code in a language where the ergonomics lend themselves to functional semantics.
That swift code is painful to read.
I&#x27;ll give some examples (from worst to best.)<p>Java: (awful, to read and write)<p><pre><code>    import java.util.function.Function;

    public class Main {
      public static void main(String[] args) {
        Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; add = x -&gt; y -&gt; x + y;
        Function&lt;Integer, Integer&gt; addFive = add.apply(5);
        int result = addFive.apply(3);  &#x2F;&#x2F; Output will be 8
      }</code></pre>
Ruby a. (still not great, but there&#x27;s many ways to do it!)<p><pre><code>    add = proc { |x, y| x + y }
    curried_add = add.curry

    add_five = curried_add.call(5)
    result = add_five.call(3)
    }
</code></pre>
Ruby b. (slightly more concise)<p><pre><code>    add = -&gt;(x) { -&gt;(y) { x + y } }
    add_five = add.(5)
    result = add_five.(3)  
</code></pre>
Elixir (functional programing lang but doesn&#x27;t lean on currying too much)<p><pre><code>    add = fn x -&gt; (fn y -&gt; x + y end) end
    add_five = add.(5)
    result = add_five.(3)  
</code></pre>
ES6 (say what you want about javascript but they at least did arrow functions right)<p><pre><code>    const add = x =&gt; y =&gt; x + y;
    const addFive = add(5);
    const result = addFive(3);
</code></pre>
Standard ML (clearly a lang where currying is a first class concern in its language design)<p><pre><code>    fun add x y = x + y;
    val addFive = add 5;
    val result = addFive 3;
</code></pre>
and finally Haskell (which, in this case is a joy to read and write.)<p><pre><code>    add x y = x + y
    addFive = add 5
    result = addFive 3</code></pre></div><br/><div id="37368615" class="c"><input type="checkbox" id="c-37368615" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#37368512">parent</a><span>|</span><a href="#37366509">next</a><span>|</span><label class="collapse" for="c-37368615">[-]</label><label class="expand" for="c-37368615">[1 more]</label></div><br/><div class="children"><div class="content">Java has (limited) type inference now I think, right? Does this work for the example you gave?<p><pre><code>    public class Main {
      public static void main(String[] args) {
        var add = x -&gt; y -&gt; x + y;
        var addFive = add.apply(5);
        int result = addFive.apply(3);  &#x2F;&#x2F; Output will be 8
      }
    }
</code></pre>
Still not great, but a lot better than the original IMO</div><br/></div></div></div></div><div id="37366509" class="c"><input type="checkbox" id="c-37366509" checked=""/><div class="controls bullet"><span class="by">pixel_tracing</span><span>|</span><a href="#37368512">prev</a><span>|</span><a href="#37366620">next</a><span>|</span><label class="collapse" for="c-37366509">[-]</label><label class="expand" for="c-37366509">[11 more]</label></div><br/><div class="children"><div class="content">While I find these topics esoteric and very interesting in normal day to day code during a code review I’d probably say make it less complex, because majority of the time spent is reading code this makes code harder to read</div><br/><div id="37367652" class="c"><input type="checkbox" id="c-37367652" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#37366509">parent</a><span>|</span><a href="#37366592">next</a><span>|</span><label class="collapse" for="c-37367652">[-]</label><label class="expand" for="c-37367652">[2 more]</label></div><br/><div class="children"><div class="content">Currying is pretty much just a convenient way to write a one-constructor one-method class. It&#x27;s a parameterized version of the command pattern.<p>That said, if you&#x27;re using a language with classes you may as well stick with those and omit the syntactic sugar from your diet.<p>I find functional programming useful though because it can shorten code in a way where you can get a better view of the big picture and easily make sweeping changes. But it&#x27;s also easy to write in a way that&#x27;s too &quot;perfect&quot; (i.e. resistant to change) and incomprehensible. Though I&#x27;m not sure the total incomprehensibility is generally any worse than an enterprise Java codebase -- local readability might only give you the illusion that the whole system is understandable. Still, if you don&#x27;t enjoy reading code in a certain style it makes for hard reading!</div><br/></div></div><div id="37366592" class="c"><input type="checkbox" id="c-37366592" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#37366509">parent</a><span>|</span><a href="#37367652">prev</a><span>|</span><a href="#37366620">next</a><span>|</span><label class="collapse" for="c-37366592">[-]</label><label class="expand" for="c-37366592">[8 more]</label></div><br/><div class="children"><div class="content">Depends on the example.
Going off the blurb:<p>&gt; it’s a way of breaking down a complex function into smaller, simpler functions that can be composed together to achieve the same result.<p>And you could almost see it as analogous to the &quot;fluent&quot; pattern like:<p><pre><code>    GetObject()
    .add(3)
    .applyGradient()
    .giveFish()</code></pre>
Etc.
On the side: I really hate the &quot;make it less complex&quot; PR comments because it&#x27;s not complex, it&#x27;s just hard to read, and that&#x27;s usually because the reader doesn&#x27;t know about them.<p>I have one guy in our company who wants to unravel any list comprehension or map&#x2F;generators functions (python) because he doesn&#x27;t know anything except &quot;for X in Y&quot;</div><br/><div id="37367399" class="c"><input type="checkbox" id="c-37367399" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#37366509">root</a><span>|</span><a href="#37366592">parent</a><span>|</span><a href="#37366708">next</a><span>|</span><label class="collapse" for="c-37367399">[-]</label><label class="expand" for="c-37367399">[2 more]</label></div><br/><div class="children"><div class="content">I always think of Rich Hickey&#x27;s &quot;Simple Made Easy&quot; [1]<p>At the time I had a coworker who was militant about &quot;simple code&quot; and anti &quot;complexity&quot;. I used to argue that the code they preferred was more of a pain in the butt due to avoiding anything beyond the most basic of constructs. They saw that this was a talk, suggested our team watch it, and then became upset because it turned out they hadn&#x27;t actually watched it and assumed based on the title that it&#x27;d back up their viewpoints.<p>Lowest common denominator coding isn&#x27;t the same thing as avoiding complexity.</div><br/><div id="37368107" class="c"><input type="checkbox" id="c-37368107" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#37366509">root</a><span>|</span><a href="#37367399">parent</a><span>|</span><a href="#37366708">next</a><span>|</span><label class="collapse" for="c-37368107">[-]</label><label class="expand" for="c-37368107">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s hilarious.<p>The thing is, complexity &amp; complications come from known-unknowns and unknown-unknowns.<p>Semantics of language use doesn&#x27;t fit in there unless it&#x27;s undefined behaviour. Things can be hard to read, but that&#x27;s seperate from complexity.<p>And often the &quot;simple, trivial code&quot; is the slowest performance (which is a big deal in python)</div><br/></div></div></div></div><div id="37366708" class="c"><input type="checkbox" id="c-37366708" checked=""/><div class="controls bullet"><span class="by">pixel_tracing</span><span>|</span><a href="#37366509">root</a><span>|</span><a href="#37366592">parent</a><span>|</span><a href="#37367399">prev</a><span>|</span><a href="#37367018">next</a><span>|</span><label class="collapse" for="c-37366708">[-]</label><label class="expand" for="c-37366708">[3 more]</label></div><br/><div class="children"><div class="content">It _is_ literally increasing complexity. Because now the call stack has added layers of indirection:<p>[0] abort()
[1] curry call site
[2] partial closure 1
[3] partial closure 2
[4] partial closure 3
[5] partial closure 4
[6] &lt;actual place of issue&gt;
[7] partial closure 5
[8] partial closure 6<p>Compare this to something isn’t using currying:<p>[0] abort()
[1] call-site 1
[2] call-site 2 &lt;actual place of issue&gt;
[3] call-site 3<p>Dealt with this enough at a previous company I’m glad on my team at FAANG people are reasonable and don’t just shoehorn functional paradigms unnecessarily</div><br/><div id="37368637" class="c"><input type="checkbox" id="c-37368637" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#37366509">root</a><span>|</span><a href="#37366708">parent</a><span>|</span><a href="#37366879">next</a><span>|</span><label class="collapse" for="c-37368637">[-]</label><label class="expand" for="c-37368637">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re only looking at one dimension of complexity. There are tradeoffs.</div><br/></div></div><div id="37366879" class="c"><input type="checkbox" id="c-37366879" checked=""/><div class="controls bullet"><span class="by">Clamchop</span><span>|</span><a href="#37366509">root</a><span>|</span><a href="#37366708">parent</a><span>|</span><a href="#37368637">prev</a><span>|</span><a href="#37367018">next</a><span>|</span><label class="collapse" for="c-37366879">[-]</label><label class="expand" for="c-37366879">[1 more]</label></div><br/><div class="children"><div class="content">The curried example actually could only ever add one to the call stack, no matter how many times you do it.<p>And another thing, currying is one way of decomposing functions. Either your first example is decomposed too much or your second too little.<p>But I also am less comfortable working in a functional style.</div><br/></div></div></div></div><div id="37367018" class="c"><input type="checkbox" id="c-37367018" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#37366509">root</a><span>|</span><a href="#37366592">parent</a><span>|</span><a href="#37366708">prev</a><span>|</span><a href="#37366964">next</a><span>|</span><label class="collapse" for="c-37367018">[-]</label><label class="expand" for="c-37367018">[1 more]</label></div><br/><div class="children"><div class="content">I guess every language needs a variant of <i>JavaScript: The Good Parts</i>. Believe Go, despite its many shortcomings, gets <i>readability</i> better than most languages: <a href="https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2012&#x2F;splash.article#TOC_4" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2012&#x2F;splash.article#TOC_4</a>.<p>On the topic of Kotlin, it is really one is the better (perhaps the best?) JVM languages out there.</div><br/></div></div><div id="37366964" class="c"><input type="checkbox" id="c-37366964" checked=""/><div class="controls bullet"><span class="by">oofbey</span><span>|</span><a href="#37366509">root</a><span>|</span><a href="#37366592">parent</a><span>|</span><a href="#37367018">prev</a><span>|</span><a href="#37366620">next</a><span>|</span><label class="collapse" for="c-37366964">[-]</label><label class="expand" for="c-37366964">[1 more]</label></div><br/><div class="children"><div class="content">Complexity and understandability are very difficult to separate. If a coding style is unknown &#x2F; bizarre to most coders on a team, but beautifully simple to a few who know the technique, which is it?<p>There should be a balance between teaching new ideas, and acknowledging the truth of what people are comfortable with.</div><br/></div></div></div></div></div></div><div id="37366620" class="c"><input type="checkbox" id="c-37366620" checked=""/><div class="controls bullet"><span class="by">mattsan</span><span>|</span><a href="#37366509">prev</a><span>|</span><a href="#37368362">next</a><span>|</span><label class="collapse" for="c-37366620">[-]</label><label class="expand" for="c-37366620">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m questioning this advantage:<p>&gt; Improved type safety: Currying can help improve type safety by ensuring that each curried function takes exactly one argument of the correct type. This can help catch errors at compile time and make your code more robust.<p>Why would non-curried functions have worse type safety?</div><br/><div id="37366951" class="c"><input type="checkbox" id="c-37366951" checked=""/><div class="controls bullet"><span class="by">__jem</span><span>|</span><a href="#37366620">parent</a><span>|</span><a href="#37366803">next</a><span>|</span><label class="collapse" for="c-37366951">[-]</label><label class="expand" for="c-37366951">[1 more]</label></div><br/><div class="children"><div class="content">Passing around functions that have already been partially applied means that downstream users can&#x27;t incorrectly call or accidentally modify the arguments which have already been applied. Whether this actually results in more safety is unclear, as there are other language features or API design that accomplishes the same thing.</div><br/></div></div><div id="37366803" class="c"><input type="checkbox" id="c-37366803" checked=""/><div class="controls bullet"><span class="by">nanodeath</span><span>|</span><a href="#37366620">parent</a><span>|</span><a href="#37366951">prev</a><span>|</span><a href="#37368362">next</a><span>|</span><label class="collapse" for="c-37366803">[-]</label><label class="expand" for="c-37366803">[1 more]</label></div><br/><div class="children"><div class="content">I _think_ what they&#x27;re saying is a specialized&#x2F;curried function that takes a single argument is better than the method it&#x27;s replacing that takes three strings or whatever. That is, `foo.a(&quot;a&quot;).b(&quot;b&quot;).c(&quot;c&quot;)` is better than `foo.a(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)`. Which...sure, but 1. if you&#x27;re really passing 2-3 parameters in with identical types, maybe use inline value classes instead? Or at least type aliases?, and 2. if you can&#x27;t or don&#x27;t want to do that, named arguments help.</div><br/></div></div></div></div><div id="37368362" class="c"><input type="checkbox" id="c-37368362" checked=""/><div class="controls bullet"><span class="by">mekster</span><span>|</span><a href="#37366620">prev</a><span>|</span><a href="#37367249">next</a><span>|</span><label class="collapse" for="c-37368362">[-]</label><label class="expand" for="c-37368362">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used currying in the past but these articles don&#x27;t really make you tick at all as they introduce the concept first, which doesn&#x27;t mean anything until you realize you actually need it to solve a problem you may encounter but examples also doesn&#x27;t really feel like it&#x27;s usable in day to day code.<p>I&#x27;ve used it to keep specific variable assigned on a function for later use such as for asynchronous functions which you&#x27;ll lose the current state without saving it somehow such as by currying.</div><br/></div></div><div id="37367249" class="c"><input type="checkbox" id="c-37367249" checked=""/><div class="controls bullet"><span class="by">SinParadise</span><span>|</span><a href="#37368362">prev</a><span>|</span><a href="#37366591">next</a><span>|</span><label class="collapse" for="c-37367249">[-]</label><label class="expand" for="c-37367249">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if Kotlin is conductive to currying. I find it harder to read with currying, not easier.</div><br/></div></div></div></div></div></div></div></body></html>