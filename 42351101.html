<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733648455680" as="style"/><link rel="stylesheet" href="styles.css?v=1733648455680"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://just.systems/">Just: Just a Command Runner</a> <span class="domain">(<a href="https://just.systems">just.systems</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>222 comments</span></div><br/><div><div id="42355766" class="c"><input type="checkbox" id="c-42355766" checked=""/><div class="controls bullet"><span class="by">k_bx</span><span>|</span><a href="#42355731">next</a><span>|</span><label class="collapse" for="c-42355766">[-]</label><label class="expand" for="c-42355766">[1 more]</label></div><br/><div class="children"><div class="content">I see more projects switch to PIXI, another Rust-written piece of software. RERUN was the one I follow the most <a href="https:&#x2F;&#x2F;github.com&#x2F;rerun-io&#x2F;rerun">https:&#x2F;&#x2F;github.com&#x2F;rerun-io&#x2F;rerun</a><p>It looks like much more than just command runner, but my projects happen to be needing much more than that too.</div><br/></div></div><div id="42355731" class="c"><input type="checkbox" id="c-42355731" checked=""/><div class="controls bullet"><span class="by">jstrieb</span><span>|</span><a href="#42355766">prev</a><span>|</span><a href="#42351350">next</a><span>|</span><label class="collapse" for="c-42355731">[-]</label><label class="expand" for="c-42355731">[1 more]</label></div><br/><div class="children"><div class="content">In case you want to run Justfiles in places where you can&#x27;t install the Just binary (for whatever reason), I wrote a compiler that transforms Justfiles into portable shell scripts that have byte-for-byte identical output in most cases.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jstrieb&#x2F;just.sh">https:&#x2F;&#x2F;github.com&#x2F;jstrieb&#x2F;just.sh</a><p>Previous HN discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38772039">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38772039</a></div><br/></div></div><div id="42351350" class="c"><input type="checkbox" id="c-42351350" checked=""/><div class="controls bullet"><span class="by">jcalabro</span><span>|</span><a href="#42355731">prev</a><span>|</span><a href="#42351310">next</a><span>|</span><label class="collapse" for="c-42351350">[-]</label><label class="expand" for="c-42351350">[15 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using just at work and in personal projects for almost a year, and I like it a lot. In particular, its self documentation with `just --list` makes onboarding new folks easy. It&#x27;s also just a nicer syntax than make.</div><br/><div id="42351629" class="c"><input type="checkbox" id="c-42351629" checked=""/><div class="controls bullet"><span class="by">peterldowns</span><span>|</span><a href="#42351350">parent</a><span>|</span><a href="#42352448">next</a><span>|</span><label class="collapse" for="c-42351629">[-]</label><label class="expand" for="c-42351629">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. Is it that different than Make with `.PHONY` targets? Yes — it is Designed To Do Exactly What It Does, And It Does It Well. That counts for something in my book.<p>All my Justfiles start with this prelude to enable positional arguments, and a &quot;default&quot; target to print all the possible commands when you run `just` with no target name:<p><pre><code>    # this setting will allow passing arguments through to tasks, see the docs here
    # https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;chapter_24.html#positional-arguments
    set positional-arguments

    # print all available commands by default
    default:
      @just --list</code></pre></div><br/><div id="42354699" class="c"><input type="checkbox" id="c-42354699" checked=""/><div class="controls bullet"><span class="by">jdxcode</span><span>|</span><a href="#42351350">root</a><span>|</span><a href="#42351629">parent</a><span>|</span><a href="#42352448">next</a><span>|</span><label class="collapse" for="c-42354699">[-]</label><label class="expand" for="c-42354699">[1 more]</label></div><br/><div class="children"><div class="content">in mise you wouldn&#x27;t need that preamble. `set positional-arguments` is just how it behaves normally and `mise run` doesn&#x27;t just show available commands—it&#x27;s also a selector UI</div><br/></div></div></div></div><div id="42352448" class="c"><input type="checkbox" id="c-42352448" checked=""/><div class="controls bullet"><span class="by">konfekt</span><span>|</span><a href="#42351350">parent</a><span>|</span><a href="#42351629">prev</a><span>|</span><a href="#42351645">next</a><span>|</span><label class="collapse" for="c-42352448">[-]</label><label class="expand" for="c-42352448">[1 more]</label></div><br/><div class="children"><div class="content">Maybe worth reminding the self-documenting Makefile [0] discussed here.<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30137254">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30137254</a></div><br/></div></div><div id="42351645" class="c"><input type="checkbox" id="c-42351645" checked=""/><div class="controls bullet"><span class="by">mike-cardwell</span><span>|</span><a href="#42351350">parent</a><span>|</span><a href="#42352448">prev</a><span>|</span><a href="#42354202">next</a><span>|</span><label class="collapse" for="c-42351645">[-]</label><label class="expand" for="c-42351645">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have my work laptop to hand to compare, but I usually run &quot;just&quot; to get a list of commands and what they do, rather than &quot;just --list&quot;. Hope that saves you 7 key presses going forwards.</div><br/><div id="42351684" class="c"><input type="checkbox" id="c-42351684" checked=""/><div class="controls bullet"><span class="by">peterldowns</span><span>|</span><a href="#42351350">root</a><span>|</span><a href="#42351645">parent</a><span>|</span><a href="#42351841">next</a><span>|</span><label class="collapse" for="c-42351684">[-]</label><label class="expand" for="c-42351684">[7 more]</label></div><br/><div class="children"><div class="content">Running `just` will invoke the first recipe, so you need to add one that invokes `just --list` for this to work — see <a href="https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;listing-available-recipes.html" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;listing-available-recipes.html</a> and my sibling comment.</div><br/><div id="42351780" class="c"><input type="checkbox" id="c-42351780" checked=""/><div class="controls bullet"><span class="by">fmbb</span><span>|</span><a href="#42351350">root</a><span>|</span><a href="#42351684">parent</a><span>|</span><a href="#42352582">next</a><span>|</span><label class="collapse" for="c-42351780">[-]</label><label class="expand" for="c-42351780">[4 more]</label></div><br/><div class="children"><div class="content">That seems like the most useless pattern to take from make, especially when you name your tool ”just”.<p>Just what?</div><br/><div id="42351835" class="c"><input type="checkbox" id="c-42351835" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#42351350">root</a><span>|</span><a href="#42351780">parent</a><span>|</span><a href="#42352224">next</a><span>|</span><label class="collapse" for="c-42351835">[-]</label><label class="expand" for="c-42351835">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Just what?</i><p>&quot;Oh... come on! <i>Just...</i> &lt;waving hands angrily&gt;&quot;<p>Pretty clear to me :).</div><br/></div></div><div id="42352224" class="c"><input type="checkbox" id="c-42352224" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42351350">root</a><span>|</span><a href="#42351780">parent</a><span>|</span><a href="#42351835">prev</a><span>|</span><a href="#42352070">next</a><span>|</span><label class="collapse" for="c-42352224">[-]</label><label class="expand" for="c-42352224">[1 more]</label></div><br/><div class="children"><div class="content">Just execute.</div><br/></div></div></div></div><div id="42352582" class="c"><input type="checkbox" id="c-42352582" checked=""/><div class="controls bullet"><span class="by">mike-cardwell</span><span>|</span><a href="#42351350">root</a><span>|</span><a href="#42351684">parent</a><span>|</span><a href="#42351780">prev</a><span>|</span><a href="#42352169">next</a><span>|</span><label class="collapse" for="c-42352582">[-]</label><label class="expand" for="c-42352582">[1 more]</label></div><br/><div class="children"><div class="content">Hmm. Maybe the dev that set it up made the first recipe run `just --list`</div><br/></div></div><div id="42352169" class="c"><input type="checkbox" id="c-42352169" checked=""/><div class="controls bullet"><span class="by">lambda</span><span>|</span><a href="#42351350">root</a><span>|</span><a href="#42351684">parent</a><span>|</span><a href="#42352582">prev</a><span>|</span><a href="#42351841">next</a><span>|</span><label class="collapse" for="c-42352169">[-]</label><label class="expand" for="c-42352169">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve been adding `just help` as an alias for `just --list` and making it the first recipe for this reason.</div><br/></div></div></div></div><div id="42351841" class="c"><input type="checkbox" id="c-42351841" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351350">root</a><span>|</span><a href="#42351645">parent</a><span>|</span><a href="#42351684">prev</a><span>|</span><a href="#42351782">next</a><span>|</span><label class="collapse" for="c-42351841">[-]</label><label class="expand" for="c-42351841">[1 more]</label></div><br/><div class="children"><div class="content">Not as much as 7, you can just type `just -l`.</div><br/></div></div></div></div><div id="42354202" class="c"><input type="checkbox" id="c-42354202" checked=""/><div class="controls bullet"><span class="by">banku_brougham</span><span>|</span><a href="#42351350">parent</a><span>|</span><a href="#42351645">prev</a><span>|</span><a href="#42351310">next</a><span>|</span><label class="collapse" for="c-42354202">[-]</label><label class="expand" for="c-42354202">[1 more]</label></div><br/><div class="children"><div class="content">Total agree. It constrains the chaos in my projects, and its easy to refactor bits into more sustainable cicd, if or when that is ever needed.<p>The self documenting aspect is what puts jt above a folder of shell scripts for me</div><br/></div></div></div></div><div id="42351310" class="c"><input type="checkbox" id="c-42351310" checked=""/><div class="controls bullet"><span class="by">gurgeous</span><span>|</span><a href="#42351350">prev</a><span>|</span><a href="#42351210">next</a><span>|</span><label class="collapse" for="c-42351310">[-]</label><label class="expand" for="c-42351310">[8 more]</label></div><br/><div class="children"><div class="content">We love just and are using it in all projects now. So great. Our typical justfile has around ~20 rules. Here is an example rule (and helper) to illustrate how we use it in ci:<p><pre><code>  export PATH := justfile_directory() + &quot;&#x2F;node_modules&#x2F;.bin:&quot; + env_var(&#x27;PATH&#x27;)

  ci:
    @just banner yarn install
    yarn install
    @just banner tsc
    tsc --noEmit
    @just banner lint
    eslint src
    prettier --check src
    @just banner vitest
    vitest --run
    @just banner done!
  
  banner *ARGS:
    @printf &#x27;\e[42;37;1m[%s] %-72s \e[m\n&#x27; &quot;$(date +%H:%M:%S)&quot; &quot;{{ARGS}}&quot;
</code></pre>
This example is a bit contrived, more typically we would have a rule like &quot;just lint&quot; and you might call it from &quot;just ci&quot;.<p>One of the best features is that just always runs from the project root directory. Little things like that add up after you&#x27;ve spent years wrestling with bash scripts.</div><br/><div id="42351368" class="c"><input type="checkbox" id="c-42351368" checked=""/><div class="controls bullet"><span class="by">alsetmusic</span><span>|</span><a href="#42351310">parent</a><span>|</span><a href="#42351210">next</a><span>|</span><label class="collapse" for="c-42351368">[-]</label><label class="expand" for="c-42351368">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Little things like that add up after you&#x27;ve spent years wrestling with bash scripts.<p>Can you please explain what you mean here? I looked at the GitHub examples and wondered why this would be preferable to Bash aliases and functions. I must be missing something.</div><br/><div id="42352134" class="c"><input type="checkbox" id="c-42352134" checked=""/><div class="controls bullet"><span class="by">3eb7988a1663</span><span>|</span><a href="#42351310">root</a><span>|</span><a href="#42351368">parent</a><span>|</span><a href="#42351399">next</a><span>|</span><label class="collapse" for="c-42352134">[-]</label><label class="expand" for="c-42352134">[3 more]</label></div><br/><div class="children"><div class="content">For me, the niceties are in the built in functions[0]. Commands to manipulate paths(!!), get cpu counts, mess with environment variables, string processing, hashing, etc. All the gyrations a more sophisticated script is going to eventually require. Instead of having to hack on it in shell, you get cross-platform utilities which are not going to blow up because of something as wild as a space or quote mark.<p>[0] <a href="https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;functions.html" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;functions.html</a></div><br/><div id="42355694" class="c"><input type="checkbox" id="c-42355694" checked=""/><div class="controls bullet"><span class="by">alsetmusic</span><span>|</span><a href="#42351310">root</a><span>|</span><a href="#42352134">parent</a><span>|</span><a href="#42354012">next</a><span>|</span><label class="collapse" for="c-42355694">[-]</label><label class="expand" for="c-42355694">[1 more]</label></div><br/><div class="children"><div class="content">This best explains what I must be missing. Saying, “shell scripts are bad,” doesn’t tell me anything. Thanks for giving me a concept to explore. I’ll have another look with this in mind.</div><br/></div></div><div id="42354012" class="c"><input type="checkbox" id="c-42354012" checked=""/><div class="controls bullet"><span class="by">richie_adler</span><span>|</span><a href="#42351310">root</a><span>|</span><a href="#42352134">parent</a><span>|</span><a href="#42355694">prev</a><span>|</span><a href="#42351399">next</a><span>|</span><label class="collapse" for="c-42354012">[-]</label><label class="expand" for="c-42354012">[1 more]</label></div><br/><div class="children"><div class="content">My favorite feature is the ability to decorate the recipe name with the OS and then write relevant code for each recipe that does the same in each OS.</div><br/></div></div></div></div><div id="42351399" class="c"><input type="checkbox" id="c-42351399" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#42351310">root</a><span>|</span><a href="#42351368">parent</a><span>|</span><a href="#42352134">prev</a><span>|</span><a href="#42351210">next</a><span>|</span><label class="collapse" for="c-42351399">[-]</label><label class="expand" for="c-42351399">[3 more]</label></div><br/><div class="children"><div class="content">Bash has a thousand pitfalls, and as you accumulate layers of scripting they start compounding. Little things like “what the hell directory is this command actually running from”, parsing input parameters, quoting rules, exit statuses, pipelining, etc.<p>Tools like <i>just</i> provide a very consistent and simple base to start with, and you can always still call a separate script, or drop directly into inline shell scripting.</div><br/><div id="42351810" class="c"><input type="checkbox" id="c-42351810" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#42351310">root</a><span>|</span><a href="#42351399">parent</a><span>|</span><a href="#42351210">next</a><span>|</span><label class="collapse" for="c-42351810">[-]</label><label class="expand" for="c-42351810">[2 more]</label></div><br/><div class="children"><div class="content">So it&#x27;s not a fundamentally different use-case, it&#x27;s just an admission that shell scripts suck at what they do?</div><br/><div id="42352029" class="c"><input type="checkbox" id="c-42352029" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351310">root</a><span>|</span><a href="#42351810">parent</a><span>|</span><a href="#42351210">next</a><span>|</span><label class="collapse" for="c-42352029">[-]</label><label class="expand" for="c-42352029">[1 more]</label></div><br/><div class="children"><div class="content">Of course. Is that news to you? Not a snark, I am genuinely surprised, assuming that you asked seriously.<p>I moved to ZSH some years ago but even that is not good enough. I thought of using Fish at one point but just said &quot;frak this&quot; and started writing Golang for anything that&#x27;s more than 20-30 lines of bash&#x2F;zsh scripting. Or requires their weird list &#x2F; array syntaxes for iterating over stuff. Can&#x27;t ever remember that with a gun to my head.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42351210" class="c"><input type="checkbox" id="c-42351210" checked=""/><div class="controls bullet"><span class="by">bsnnkv</span><span>|</span><a href="#42351310">prev</a><span>|</span><a href="#42351928">next</a><span>|</span><label class="collapse" for="c-42351210">[-]</label><label class="expand" for="c-42351210">[9 more]</label></div><br/><div class="children"><div class="content">This is one of the most important pieces of software in my development stack that &quot;just&quot; gets out of the way and does what it&#x27;s supposed to do. Also has excellent Windows[1] support so I can take it everywhere!<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;LGUG2Z&#x2F;komorebi&#x2F;blob&#x2F;master&#x2F;justfile">https:&#x2F;&#x2F;github.com&#x2F;LGUG2Z&#x2F;komorebi&#x2F;blob&#x2F;master&#x2F;justfile</a> example justfile on my biggest and most active Windows project- might not seem like a lot but this has probably cumulatively saved me months of time</div><br/><div id="42351879" class="c"><input type="checkbox" id="c-42351879" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#42351210">parent</a><span>|</span><a href="#42351928">next</a><span>|</span><label class="collapse" for="c-42351879">[-]</label><label class="expand" for="c-42351879">[8 more]</label></div><br/><div class="children"><div class="content">[flagged]</div><br/><div id="42351997" class="c"><input type="checkbox" id="c-42351997" checked=""/><div class="controls bullet"><span class="by">bsnnkv</span><span>|</span><a href="#42351210">root</a><span>|</span><a href="#42351879">parent</a><span>|</span><a href="#42352045">next</a><span>|</span><label class="collapse" for="c-42351997">[-]</label><label class="expand" for="c-42351997">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I get that your project is Windows-only, but many projects aren&#x27;t.<p>Nit: At this point you&#x27;re better off starting a separate comment thread since you yourself already know that what you are about to talk about is not what my comment is talking about.</div><br/><div id="42352824" class="c"><input type="checkbox" id="c-42352824" checked=""/><div class="controls bullet"><span class="by">guitarbill</span><span>|</span><a href="#42351210">root</a><span>|</span><a href="#42351997">parent</a><span>|</span><a href="#42352045">next</a><span>|</span><label class="collapse" for="c-42352824">[-]</label><label class="expand" for="c-42352824">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also has excellent Windows[1] support so I can take it everywhere!<p>Nit: You mentioned it can be used &quot;everywhere&quot;. That would be a useful feature! But while it&#x27;s kinda true, there&#x27;s some quite big limitations IMO</div><br/></div></div></div></div><div id="42352045" class="c"><input type="checkbox" id="c-42352045" checked=""/><div class="controls bullet"><span class="by">3eb7988a1663</span><span>|</span><a href="#42351210">root</a><span>|</span><a href="#42351879">parent</a><span>|</span><a href="#42351997">prev</a><span>|</span><a href="#42352139">next</a><span>|</span><label class="collapse" for="c-42352045">[-]</label><label class="expand" for="c-42352045">[1 more]</label></div><br/><div class="children"><div class="content">The shell can be configured per OS. So, Windows can be set to use PowerShell and Linuxy systems will use sh.<p>From the docs<p><pre><code>  set windows-shell := [&quot;powershell.exe&quot;, &quot;-NoLogo&quot;, &quot;-Command&quot;]

  hello:
    Write-Host &quot;Hello, world!&quot;
</code></pre>
Few things work seamlessly across platforms, and that does not seem like a huge burden.</div><br/></div></div><div id="42352139" class="c"><input type="checkbox" id="c-42352139" checked=""/><div class="controls bullet"><span class="by">squeaky-clean</span><span>|</span><a href="#42351210">root</a><span>|</span><a href="#42351879">parent</a><span>|</span><a href="#42352045">prev</a><span>|</span><a href="#42352345">next</a><span>|</span><label class="collapse" for="c-42352139">[-]</label><label class="expand" for="c-42352139">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Wait, by &quot;has excellent Windows support&quot; you mean you have to set it to use Powershell or hope `sh` is installed on<p>I don&#x27;t get what the problem is here? Do you protest against shebangs too? Why does a build script for a Windows only app need to use sh instead of powershell? I think you&#x27;re interpreting &quot;excellent windows support&quot; to mean cross platform, and that&#x27;s not what it means.<p>&gt; So not only do you need just installed, which is yet another dependency,<p>Yeah if you want to use some software, your computer needs that software. That&#x27;s not a dependency. So we&#x27;re talking zero dependencies, or one of you absolutely need sh.</div><br/><div id="42353364" class="c"><input type="checkbox" id="c-42353364" checked=""/><div class="controls bullet"><span class="by">burnished</span><span>|</span><a href="#42351210">root</a><span>|</span><a href="#42352139">parent</a><span>|</span><a href="#42352345">next</a><span>|</span><label class="collapse" for="c-42353364">[-]</label><label class="expand" for="c-42353364">[1 more]</label></div><br/><div class="children"><div class="content">To be fair it is another dependency for the project that you are using just with. Its probably not software that you use for its own sake.</div><br/></div></div></div></div><div id="42352345" class="c"><input type="checkbox" id="c-42352345" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351210">root</a><span>|</span><a href="#42351879">parent</a><span>|</span><a href="#42352139">prev</a><span>|</span><a href="#42352255">next</a><span>|</span><label class="collapse" for="c-42352345">[-]</label><label class="expand" for="c-42352345">[1 more]</label></div><br/><div class="children"><div class="content">You can use the usual cmd (I do). You&#x27;re not limited to Powershell. Also, you do understand that if a tool has first class support for Windows, that does mean it prioritizes Windows tools, right? Imagine I made a command runner, and said it has &quot;excellent Linux support&quot;, and then someone comes along and complains that you have to install Powershell on Linux to use Windows recipes.<p>You can have Windows only recipes and Linux only recipes.<p>Furthermore, if you have bash installed on Windows (e.g. via git bash), you can put a shebang in your recipes to use bash.<p>We develop in Windows and deploy in Linux. Most of our recipes work in both OS&#x27;s - either we use bash or Python for the recipe. The few that don&#x27;t - we just mark as Windows only or Linux only so they&#x27;re not available in the wrong OS.<p>&gt; So not only do you need just installed, which is yet another dependency,<p>You do realize that Windows by default comes with almost <i>no</i> development tools, right? So yes, you do actually need to install things to get work done. The horror.<p>I&#x27;ll also note that while you complain about just, <i>you provide no alternative</i>.<p>Weirdest rant ever.</div><br/></div></div><div id="42352255" class="c"><input type="checkbox" id="c-42352255" checked=""/><div class="controls bullet"><span class="by">MatmaRex</span><span>|</span><a href="#42351210">root</a><span>|</span><a href="#42351879">parent</a><span>|</span><a href="#42352345">prev</a><span>|</span><a href="#42351928">next</a><span>|</span><label class="collapse" for="c-42352255">[-]</label><label class="expand" for="c-42352255">[1 more]</label></div><br/><div class="children"><div class="content">You can keep your commands simple enough so that they can be executed by both `sh` and `cmd.exe`. If you need anything more complex than invoking other programs, `&amp;&amp;`, `|` and `&gt;`, it&#x27;s time to rewrite your build script in a real programming language anyway.</div><br/></div></div></div></div></div></div><div id="42351928" class="c"><input type="checkbox" id="c-42351928" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#42351210">prev</a><span>|</span><a href="#42351736">next</a><span>|</span><label class="collapse" for="c-42351928">[-]</label><label class="expand" for="c-42351928">[2 more]</label></div><br/><div class="children"><div class="content">I love just. The main benefit for me at work is that it&#x27;s much easier to convince others to use, unlike make.<p>I like make just fine, and it&#x27;s useful to learn, but it&#x27;s also a very opaque language to someone who may not even have very much shell experience. I&#x27;ve frequently found Makefiles scattered around a repo – which do still work, to be clear – with no known ownership, the knowledge of their creation lost with the person who wrote them, and subsequently left.</div><br/><div id="42353600" class="c"><input type="checkbox" id="c-42353600" checked=""/><div class="controls bullet"><span class="by">biztos</span><span>|</span><a href="#42351928">parent</a><span>|</span><a href="#42351736">next</a><span>|</span><label class="collapse" for="c-42353600">[-]</label><label class="expand" for="c-42353600">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m hoping for this effect, as more and more I work with people who don&#x27;t consider `make` the default (or, more often, have never heard of it).<p>But I think the hard part -- for any build system -- is achieving the ubiquity `make` had back in the day.  You could &quot;just&quot; type &quot;make&quot; and you&#x27;d either build the project, or get fast feedback on how much that project cared about developers.</div><br/></div></div></div></div><div id="42351736" class="c"><input type="checkbox" id="c-42351736" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42351928">prev</a><span>|</span><a href="#42351171">next</a><span>|</span><label class="collapse" for="c-42351736">[-]</label><label class="expand" for="c-42351736">[72 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a fan. It works well for what it is, but what it is is an additional language to know in a place where you probably already have one lying around.<p>Also, like make, it encourages an imperative mode for project tooling and I think we should distance ourselves from that a bit further. It&#x27;s nice that everybody is on the same page about which verbs are available, but those verbs likely change filesystem state among your .gitignored files. And since they&#x27;re starting from an unknown state you end up with each Just command prefixed by other commands which prepare to run the actual command, so now you&#x27;re sort of freestyling a package manager around each command in an ad-hoc way when maybe it&#x27;s automation that deserves to be handled without depending on unspecified state in the project dir.<p>None of this is Just&#x27;s fault. This is people using Just poorly. But I do think it (and make) sort of place you on a slippery slope. Wherever possible I&#x27;d prefer to reframe whatever needs doing as a build and use something like nix which is less friendly up front, but less surprising later on because you know you&#x27;re not depending on the outputs of some command that was run once and forgotten about--suddenly a problem because the new guy can&#x27;t get it to work and nobody else remembers why it works on theirs.</div><br/><div id="42352974" class="c"><input type="checkbox" id="c-42352974" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42351736">parent</a><span>|</span><a href="#42351822">next</a><span>|</span><label class="collapse" for="c-42352974">[-]</label><label class="expand" for="c-42352974">[20 more]</label></div><br/><div class="children"><div class="content">I find declarative build systems end up pretty frustrating in practice. What I want from a build often <i>isn&#x27;t</i> the artifacts, but the side effects of producing the artifacts like build output or compilation time. You get this &quot;for free&quot; from an imperative tool, but represents a significant feature in a declarative system that&#x27;s usually implemented badly if it&#x27;s implemented at all. The problem gets worse the smarter your tool is.</div><br/><div id="42353291" class="c"><input type="checkbox" id="c-42353291" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352974">parent</a><span>|</span><a href="#42353258">next</a><span>|</span><label class="collapse" for="c-42353291">[-]</label><label class="expand" for="c-42353291">[8 more]</label></div><br/><div class="children"><div class="content">Logs emitted during the build, or test results, or metrics captured during the build (such as how long it took)... these can all themselves be build outputs.<p>I&#x27;ve got one where &quot;deploying&quot; means updating a few version strings and image reverences in a different repo.  The &quot;build&quot; clones that repo and makes the changes in the necessary spots and makes a commit.  Yes, the side effect I want is that the commit gets pushed--which requires my ssh key which is not a build input--but I sort of prefer doing that bit by hand.</div><br/><div id="42354065" class="c"><input type="checkbox" id="c-42354065" checked=""/><div class="controls bullet"><span class="by">tucosan</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353291">parent</a><span>|</span><a href="#42353258">next</a><span>|</span><label class="collapse" for="c-42354065">[-]</label><label class="expand" for="c-42354065">[7 more]</label></div><br/><div class="children"><div class="content">The developer time required to learn and properly use nix makes it unattractive to most teams. 
The benefits don&#x27;t outweigh the costs of adoption.<p>Instead of debugging code, the team would have to spend significant time maintaining the build system for the build systems sake.  
Don&#x27;t get me wrong, I want something nix-like in my toolbox.
I want to love nix. 
But I wouldn&#x27;t dare to argue my team to commit to the world of pain that comes with it.<p>There&#x27;s a good reason that nix didn&#x27;t see wide adoption in the industry.</div><br/><div id="42354126" class="c"><input type="checkbox" id="c-42354126" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42354065">parent</a><span>|</span><a href="#42355654">next</a><span>|</span><label class="collapse" for="c-42354126">[-]</label><label class="expand" for="c-42354126">[2 more]</label></div><br/><div class="children"><div class="content">In my experience, Nix is very high leverage. My company has ~5 nix gurus, but Nix is invisibly used by hundreds of engineers. Most engineers know we use Nix and that&#x27;s about it.</div><br/><div id="42355092" class="c"><input type="checkbox" id="c-42355092" checked=""/><div class="controls bullet"><span class="by">smilliken</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42354126">parent</a><span>|</span><a href="#42355654">next</a><span>|</span><label class="collapse" for="c-42355092">[-]</label><label class="expand" for="c-42355092">[1 more]</label></div><br/><div class="children"><div class="content">Similar experience for me. In my company adopting nix paid off in weeks with no prior experience. Very happy with it almost 10 years later and at much larger scale. The difference between things working reliability or not is too big to overstate.</div><br/></div></div></div></div><div id="42355654" class="c"><input type="checkbox" id="c-42355654" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42354065">parent</a><span>|</span><a href="#42354126">prev</a><span>|</span><a href="#42355376">next</a><span>|</span><label class="collapse" for="c-42355654">[-]</label><label class="expand" for="c-42355654">[1 more]</label></div><br/><div class="children"><div class="content">In my experience Nix is a force multiplier. But you need someone on the team who has plenty of Nix experience, because you inevitably need to write your own derivations and smoothen over issues that you might encounter in nixpkgs.<p>We use Nix with Cachix in the team I currently work in. We use a lot of ML packages&#x2F;kernels, which are nearly impossible to manage in Python venvs (long build times because we have to patch some dependencies, version incompatibilities, etc.). Now you can set up a development environment in seconds. The nicest thing is when we switch between branches we automatically have the state of the world needed for that branch (direnv yay).<p>It was some work to set up, but it saves so much time now.</div><br/></div></div><div id="42355376" class="c"><input type="checkbox" id="c-42355376" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42354065">parent</a><span>|</span><a href="#42355654">prev</a><span>|</span><a href="#42353258">next</a><span>|</span><label class="collapse" for="c-42355376">[-]</label><label class="expand" for="c-42355376">[3 more]</label></div><br/><div class="children"><div class="content">I tried using Nix but stopped for two very practical reasons: it&#x27;s very slow and it&#x27;s extremely disk heavy. Install a couple of things and suddenly your nix store weighs at 100 GB.</div><br/><div id="42355690" class="c"><input type="checkbox" id="c-42355690" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42355376">parent</a><span>|</span><a href="#42353258">next</a><span>|</span><label class="collapse" for="c-42355690">[-]</label><label class="expand" for="c-42355690">[2 more]</label></div><br/><div class="children"><div class="content">Interesting. For me it&#x27;s generally much faster than other package managers. The evaluation takes some time, but copying derivations from a cache to the Nix store is so much faster than traditional package management.<p>I wonder if you somehow ended up eval&#x27;ing many versions of nixpkgs?<p><i>your nix store weighs at 100 GB</i><p>¯\_(ツ)_&#x2F;¯ outside very constrained devices, who cares? I just checked my NixOS dev VM that I have used for months now and cannot remember when I last garbage collected. It&#x27;s 188GiB, but I have many different versions of CUDA, Torch, etc. (the project I&#x27;m currently working on entails building some kernels for many different build configurations), and I run nixos-unstable, where a lot of stuff changes, so generations are pretty unique.<p>A 2TB NVMe SSD is just over 100 Euro. Caring about 100GiB seems to be optimizing for the wrong things.<p>I completely agree on embedded machines though. Just deploy it by copying the system closure, garbage collecting anything but the previous closure for backup, it&#x27;ll be pretty much the same size as any other Linux system.</div><br/><div id="42355877" class="c"><input type="checkbox" id="c-42355877" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42355690">parent</a><span>|</span><a href="#42353258">next</a><span>|</span><label class="collapse" for="c-42355877">[-]</label><label class="expand" for="c-42355877">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For me it&#x27;s generally much faster than other package managers.<p>I don&#x27;t know what kind of package manager you were using, but I&#x27;ve never seen an  update take a good part of an hour before Nix.<p>&gt; outside very constrained devices, who cares?<p>Seriously, are we going to shame people who can&#x27;t afford to buy lots of storage?? My smaller laptop has only 250GB, but that&#x27;s freaking plenty if I stick with apt. But I can barely run Nix on it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42353258" class="c"><input type="checkbox" id="c-42353258" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352974">parent</a><span>|</span><a href="#42353291">prev</a><span>|</span><a href="#42351822">next</a><span>|</span><label class="collapse" for="c-42353258">[-]</label><label class="expand" for="c-42353258">[11 more]</label></div><br/><div class="children"><div class="content">&gt;What I want from a build often isn&#x27;t the artifacts, but the side effects of producing the artifacts like build output or compilation time<p>You frequently build things not to get binaries but to spend time compiling?</div><br/><div id="42353402" class="c"><input type="checkbox" id="c-42353402" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353258">parent</a><span>|</span><a href="#42351822">next</a><span>|</span><label class="collapse" for="c-42353402">[-]</label><label class="expand" for="c-42353402">[10 more]</label></div><br/><div class="children"><div class="content">The point is that there&#x27;s often no way way to express &quot;I want side effects&quot; in declarative tools, and the number of side effects that might be useful is vast.<p>For example, sometimes I profiling the build times to see where I should focus effort.<p>Sometimes I want to see it to quickly check for issues where adding some dependency header causes build times to explode 100% in downstream dependencies during cold builds.<p>Another common occurrence for is trying to debug a platform, toolchain, or standard library issue and the build system either doesn&#x27;t detect changes in those components or only makes the components readily accessible in an internal cache that&#x27;s subject to invalidation issues. You&#x27;ll usually get the wrong artifact or test results in those cases.<p>Some other systems (e.g. bazel&#x2F;blaze comes to mind) actively try to hide side effects like stdout.<p>In all of these cases, the only way to actually get these side effects is to reach into the tool&#x27;s internals by blowing away caches&#x2F;output folders or reading live log files. That&#x27;s a failure of the build tool.</div><br/><div id="42354606" class="c"><input type="checkbox" id="c-42354606" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353402">parent</a><span>|</span><a href="#42354190">next</a><span>|</span><label class="collapse" for="c-42354606">[-]</label><label class="expand" for="c-42354606">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The point is that there&#x27;s often no way way to express &quot;I want side effects&quot; in declarative tools, and the number of side effects that might be useful is vast.<p>Shake (<a href="https:&#x2F;&#x2F;shakebuild.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shakebuild.com&#x2F;</a>) is pretty good about letting you specify that a specific step produces multiple artifacts.<p>I suspect Nix can do the same?<p>&gt; Some other systems (e.g. bazel&#x2F;blaze comes to mind) actively try to hide side effects like stdout.<p>Yes, blaze isn&#x27;t all that great.  You can tell, because Google folks check in generated artifacts into their repositories, instead of wrestling with getting blaze to build them.</div><br/></div></div><div id="42354190" class="c"><input type="checkbox" id="c-42354190" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353402">parent</a><span>|</span><a href="#42354606">prev</a><span>|</span><a href="#42353532">next</a><span>|</span><label class="collapse" for="c-42354190">[-]</label><label class="expand" for="c-42354190">[1 more]</label></div><br/><div class="children"><div class="content">Generally my aim with both Nix and Bazel are that, while they are the source of truth, day-to-day development and debugging occurs using language-native tools. So the only touch point for local development is when you are modifying the dependency graph in some way.<p>It&#x27;s definitely more work (you need to maintain compatibility with two different build systems), but worth it for exactly these reasons.</div><br/></div></div><div id="42353532" class="c"><input type="checkbox" id="c-42353532" checked=""/><div class="controls bullet"><span class="by">MereInterest</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353402">parent</a><span>|</span><a href="#42354190">prev</a><span>|</span><a href="#42351822">next</a><span>|</span><label class="collapse" for="c-42353532">[-]</label><label class="expand" for="c-42353532">[7 more]</label></div><br/><div class="children"><div class="content">I haven’t used it, but it sounds like make’s —-assume-new flag does exactly what you want for the first part.  It lets you rebuild everything that would result from a changed file, including all side effects, without needing to first update the file.</div><br/><div id="42354609" class="c"><input type="checkbox" id="c-42354609" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353532">parent</a><span>|</span><a href="#42353967">next</a><span>|</span><label class="collapse" for="c-42354609">[-]</label><label class="expand" for="c-42354609">[5 more]</label></div><br/><div class="children"><div class="content">Alas, Make is really, really awful in most other respects.</div><br/><div id="42354792" class="c"><input type="checkbox" id="c-42354792" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42354609">parent</a><span>|</span><a href="#42353967">next</a><span>|</span><label class="collapse" for="c-42354792">[-]</label><label class="expand" for="c-42354792">[4 more]</label></div><br/><div class="children"><div class="content">Really? It&#x27;s the one part of the traditional c build system I actually still use. Easy to write, easy to debug, relatively small—what&#x27;s the issue? I hear people complain about make incessantly but people rarely have substantial criticism to offer. Is it the syntax? Reliance on the filesystem? Inconsistencies between implementations?</div><br/><div id="42355853" class="c"><input type="checkbox" id="c-42355853" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42354792">parent</a><span>|</span><a href="#42355208">next</a><span>|</span><label class="collapse" for="c-42355853">[-]</label><label class="expand" for="c-42355853">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Inconsistencies between implementations?<p>That&#x27;s actually not too much of a problem in practice: almost everyone just uses Gnu Make.<p>&gt; Easy to write, easy to debug [...]<p>Alas, Make becomes hard to write and really hard to debug past a certain complexity threshold.  And you reach that complexity threshold very quickly.<p>&gt; Is it the syntax?<p>Yes, the syntax of Make is awful, and I&#x27;m not even talking about ergonomics.  Thanks to Make&#x27;s abysmal syntax, special characters in your files make it barf completely.  And by &#x27;special&#x27; I mean something as mundane as spaces.<p>But everything you mentioned is far from the worst.  See eg <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17088328">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17088328</a> for a more comprehensive overview of Make&#x27;s sins.</div><br/></div></div><div id="42355208" class="c"><input type="checkbox" id="c-42355208" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42354792">parent</a><span>|</span><a href="#42355853">prev</a><span>|</span><a href="#42353967">next</a><span>|</span><label class="collapse" for="c-42355208">[-]</label><label class="expand" for="c-42355208">[2 more]</label></div><br/><div class="children"><div class="content">As an actual builder it has limitations, such as not having (built in) the ability to know if it can still do an incremental build after changing some build option. That can result in inconsistent builds.<p>The main problem is that you often require more logic than makes sense to write in make, but it kind of has a language built into it so people try to use it. But as a language it&#x27;s terrible (no scoping, many missing features). So people end up implementing their build logic in a bastard combination of make and shell which is very opaque and difficult to debug.<p>For example, I was recently trying to figure out how the OpenWRT makefiles are doing something, and it was really painful, because with make having no scoping any part of the system could end up affecting the piece you are looking at. There is a lot of dropping into shell to get stuff done, and a lot of the targets are themselves expanded variables, which makes it really opaque. Really a lot of it is not gaining from being written in make, they could do with rewriting large parts in a real language. But it would be a huge job. And that&#x27;s where a lot of makefile systems end up<p>That&#x27;s why you get tools like ninja where they decided not to allow any logic at all.</div><br/><div id="42355859" class="c"><input type="checkbox" id="c-42355859" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42355208">parent</a><span>|</span><a href="#42353967">next</a><span>|</span><label class="collapse" for="c-42355859">[-]</label><label class="expand" for="c-42355859">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s why you get tools like ninja where they decided not to allow any logic at all.<p>Or you get shake, where your logic is the logic of a real programming language.</div><br/></div></div></div></div></div></div></div></div><div id="42353967" class="c"><input type="checkbox" id="c-42353967" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353532">parent</a><span>|</span><a href="#42354609">prev</a><span>|</span><a href="#42351822">next</a><span>|</span><label class="collapse" for="c-42353967">[-]</label><label class="expand" for="c-42353967">[1 more]</label></div><br/><div class="children"><div class="content">--always-make&#x2F;-B is more in line, but yeah. Make has grown imperative models within its vast declarative morass.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42351822" class="c"><input type="checkbox" id="c-42351822" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#42351736">parent</a><span>|</span><a href="#42352974">prev</a><span>|</span><a href="#42351754">next</a><span>|</span><label class="collapse" for="c-42351822">[-]</label><label class="expand" for="c-42351822">[2 more]</label></div><br/><div class="children"><div class="content">I agree, but `Just` as an incremental improvement is a much easier sell to teams than asking them to think about their builds completely differently and rewrite everything to fit that.<p>Offering a cave man a flashlight is probably more helpful than offering them a lightbulb and asking them to wire up the cave to power it :D</div><br/><div id="42353274" class="c"><input type="checkbox" id="c-42353274" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42351822">parent</a><span>|</span><a href="#42351754">next</a><span>|</span><label class="collapse" for="c-42353274">[-]</label><label class="expand" for="c-42353274">[1 more]</label></div><br/><div class="children"><div class="content">It is definitely a very fine incremental improvement over make. It&#x27;s just incremental progress in a direction that I don&#x27;t want to be headed.</div><br/></div></div></div></div><div id="42351754" class="c"><input type="checkbox" id="c-42351754" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#42351736">parent</a><span>|</span><a href="#42351822">prev</a><span>|</span><a href="#42351897">next</a><span>|</span><label class="collapse" for="c-42351754">[-]</label><label class="expand" for="c-42351754">[36 more]</label></div><br/><div class="children"><div class="content">I mainly don&#x27;t understand how Just is any better than a run&#x2F; directory full of executable shell scripts.</div><br/><div id="42351858" class="c"><input type="checkbox" id="c-42351858" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42351754">parent</a><span>|</span><a href="#42353853">next</a><span>|</span><label class="collapse" for="c-42351858">[-]</label><label class="expand" for="c-42351858">[15 more]</label></div><br/><div class="children"><div class="content">If that works well for you, use it.<p>I did that for 10+ years and got fed up with having to remember which names I gave to my scripts that month. I gradually evolved my views and that got reflected with the names of the scripts.<p>`just` helped me finally move away from that. Now I have i.e. `just check` in projects in different languages that all do the same thing -- check types and&#x2F;or run various linters. I can go in a directory and run `just check` and I know I have taken care to have all checks that I want in place. Similarly I can run `just test` and I know I&#x27;ll have the test suite ran, again regardless of the programming language or framework.<p>Absolutely nothing wrong with a directory full of scripts but I lost patience for having to scan what each does and moved away from them.</div><br/><div id="42352711" class="c"><input type="checkbox" id="c-42352711" checked=""/><div class="controls bullet"><span class="by">lijok</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42351858">parent</a><span>|</span><a href="#42353746">next</a><span>|</span><label class="collapse" for="c-42352711">[-]</label><label class="expand" for="c-42352711">[13 more]</label></div><br/><div class="children"><div class="content">&gt; Now I have i.e. `just check` in projects in different languages that all do the same thing -- check types and&#x2F;or run various linters. I can go in a directory and run `just check` and I know I have taken care to have all checks that I want in place. Similarly I can run `just test` and I know I&#x27;ll have the test suite ran, again regardless of the programming language or framework.<p>How is that different from having a scripts dir, and a script called `check` or `test`?<p>How is `just -l` different to `ls scripts`?</div><br/><div id="42353162" class="c"><input type="checkbox" id="c-42353162" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352711">parent</a><span>|</span><a href="#42352739">next</a><span>|</span><label class="collapse" for="c-42353162">[-]</label><label class="expand" for="c-42353162">[3 more]</label></div><br/><div class="children"><div class="content">Tab completion. `just -l&lt;tab&gt;` shows all the commands and their descriptions.<p>Aside from that, it has lots of built-in ergonomics like consistent argument parsing, functions to say what OS you’re on, an easy way to hide helper functions, the ability to execute a justfile in a great-grandparent directory, etc.<p>You can totally do any of those things with shell scripts. I prefer letting someone else invent all the bells and whistles there so I don’t have to.</div><br/><div id="42355396" class="c"><input type="checkbox" id="c-42355396" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353162">parent</a><span>|</span><a href="#42355504">next</a><span>|</span><label class="collapse" for="c-42355396">[-]</label><label class="expand" for="c-42355396">[1 more]</label></div><br/><div class="children"><div class="content">I am a bit confused. If you have your scripts in `scripts&#x2F;`, doing `scripts&#x2F;TAB` will also auto-complete! The other things seem like really minor benefits to me,  not trying to say you should also feel the same, just giving my opinion.</div><br/></div></div><div id="42355504" class="c"><input type="checkbox" id="c-42355504" checked=""/><div class="controls bullet"><span class="by">raffraffraff</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353162">parent</a><span>|</span><a href="#42355396">prev</a><span>|</span><a href="#42352739">next</a><span>|</span><label class="collapse" for="c-42355504">[-]</label><label class="expand" for="c-42355504">[1 more]</label></div><br/><div class="children"><div class="content">I use &quot;make&quot;, so I get most of this. But the one thing I would like is a sibling &#x2F; parent &#x2F; grandparent directory with ease, so I might switch.</div><br/></div></div></div></div><div id="42352739" class="c"><input type="checkbox" id="c-42352739" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352711">parent</a><span>|</span><a href="#42353162">prev</a><span>|</span><a href="#42353746">next</a><span>|</span><label class="collapse" for="c-42352739">[-]</label><label class="expand" for="c-42352739">[9 more]</label></div><br/><div class="children"><div class="content">I believe I already addressed that this is purely a matter of taste and convenience, not sure why you are not reading my comment and are asking for more.<p>And it was already said: if you like it more, use it. Nobody is holding a gun to your head. And I even explained that I used that in the past and moved away from it.</div><br/><div id="42352859" class="c"><input type="checkbox" id="c-42352859" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352739">parent</a><span>|</span><a href="#42352950">next</a><span>|</span><label class="collapse" for="c-42352859">[-]</label><label class="expand" for="c-42352859">[5 more]</label></div><br/><div class="children"><div class="content">I also haven&#x27;t seen in your previous response how Just is better than a subdir with shell scripts <i>named according to a convention</i>.<p>AFAICT, the productivity improvements you described came exclusively from using a consistent naming convention, not from Just. And since everyone&#x27;s dev env supports subdirectories with shell scripts already, why not simply use that instead of requiring Just?</div><br/><div id="42352906" class="c"><input type="checkbox" id="c-42352906" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352859">parent</a><span>|</span><a href="#42352950">next</a><span>|</span><label class="collapse" for="c-42352906">[-]</label><label class="expand" for="c-42352906">[4 more]</label></div><br/><div class="children"><div class="content">I got a down arrow on my comment that&#x27;s your parent a minute before you responded. Coincidence, or you prefer to press it because you are not satisfied that I&#x27;m not your personal documentation agent?<p>Finally and additionally as a response: because it&#x27;s also all in one place. I don&#x27;t want 10+ scripts. For the third time: I used bespoke scripts and found them not good enough compared to Just, now for even more reasons clearly spelled out. Sigh.</div><br/><div id="42353485" class="c"><input type="checkbox" id="c-42353485" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352906">parent</a><span>|</span><a href="#42352950">next</a><span>|</span><label class="collapse" for="c-42353485">[-]</label><label class="expand" for="c-42353485">[3 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t downvote you, though I found your answer unhelpful. (I&#x27;ve now <i>received</i> 2 downvotes.)<p>10+ scripts with standard names (&quot;clean&quot;, &quot;test&quot;, &quot;build&quot;, etc.) in a subdir added to $PATH seems to me to be easier to manage -- if the scripts are independent of each other. If they do have dependencies on each other, but the dependencies are &quot;treelike&quot; (meaning that for every target you might want to run, all of its transitive deps are reached via a unique path), it&#x27;s still easier (than <i>either</i> make or Just) to have separate scripts, and turn each dep into a plain invocation at the top of each script. It&#x27;s only when that approach starts to invoke deps multiple times (because it has become non-treelike) that either make or Just starts to offer an advantage.<p>I think if you look at this with clear eyes, you&#x27;ll see that 100% of the value you feel you&#x27;re getting from Just is actually coming from the naming convention that Just nudged you towards.</div><br/><div id="42353632" class="c"><input type="checkbox" id="c-42353632" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353485">parent</a><span>|</span><a href="#42352950">next</a><span>|</span><label class="collapse" for="c-42353632">[-]</label><label class="expand" for="c-42353632">[2 more]</label></div><br/><div class="children"><div class="content">Apologies for assuming you downvoted me then. :)<p>And I have not touched your comment btw. I rarely downvote these days and I have to be really pissed to do so. I was not pissed earlier, more like a little frustrated as you seemed to ask without reading, as if demanding a complete answer without willing to piece together the info given in several other comments.<p>So... you were talking about global scripts. I was not. I was talking about per-project directory with scripts because very often projects have their little quirks that make all their scripts frustratingly 99% identical but never 100%. I danced this tango dozens of times -- not exaggerating, I am a contractor (though I hope to finally stop, currently looking for a proper long-term job with good culture fit) and worked on many projects -- and ultimately got extremely frustrated.<p>At one point I did attempt to make those universal scripts you speak of. The even more maddening thing is that they worked for part of the projects... and didn&#x27;t work for others. It was a rough 60&#x2F;40 split. So you end up maintaining even more of them. So I gave up.<p>Very soon before that I found `just` and very quickly recognized the benefits: project-local commands &#x2F; scripts, centralized location (just one file), ability to delegate to parent Justfile (i.e. you can have a dedicated folder for Golang projects and that one can contain a Justfile with e.g. `just lint` task that calls `go vet` and `staticcheck` etc., without having to copy-paste that into every Golang project Justfile file, though I actually prefer that nowadays -- better to have completely self-contained tooling after all but still, for super dev-specific stuff that does not belong in version control the parent Justfile workflow is quite a good fit), and a very easy syntax that still allows for doing stuff that will make you pull your hair out if you attempt them with pure sh or bash and if you haven&#x27;t memorized their specifics over the course of a lifetime (which is something I attempted but gave up on because it was more or less memorization of exceptions of the exceptions).<p>Now, to address this:<p>&gt; <i>I also haven&#x27;t seen in your previous response how Just is better than a subdir with shell scripts named according to a convention.</i><p>I am not impressed by conventions that are not enforced with a spiked club. Which means: we the people forget stuff easily. I suffered from that too. Conventions don&#x27;t mean much when you misspell the script filename or put `-f` instead of `-e` in the `set` call at the top of the script. :)<p>I prefer loud failures and not silent mess-ups.<p>My position is informed by a lot of negative past experiences. Does not mean that my priorities are universal or unconditionally better. Not at all. It means that everything I got through in my career made me appreciate `just` and it was a near-perfect fit for my needs.<p>&gt; <i>I think if you look at this with clear eyes, you&#x27;ll see that 100% of the value you feel you&#x27;re getting from Just is actually coming from the naming convention that Just nudged you towards.</i><p>Sure, it encouraged me to finally settle on a naming convention but I&#x27;ve done this before as well. I still prefer the singular file approach + ability to delegate to parent files.<p>The less files in total the better. I have found this rule to make me more productive.<p>If you have gotten this far: nowhere did I claim objective improvements. I had discussions in the past (might have been in other `just` threads even!) with curmudgeons who loudly proclaimed &quot;skill issue!&quot; on my non-preference towards make&#x27;s bash-isms and weird rules. So for them `make` + other scripts (even Perl &#x2F; Python ones) are working just fine and the rest are &quot;kids running after shiny toys&quot;.<p>I don&#x27;t mind them thinking that. I have my motivation and, as said above, it&#x27;s well-motivated given my past and my way of work and mental preferences.<p>Hope that helps.</div><br/><div id="42353923" class="c"><input type="checkbox" id="c-42353923" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353632">parent</a><span>|</span><a href="#42352950">next</a><span>|</span><label class="collapse" for="c-42353923">[-]</label><label class="expand" for="c-42353923">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for going into more depth. I wasn&#x27;t aware that Just could delegate like that, which does sound useful. And I certainly agree that bash and make are absolutely Byzantine at this point -- footguns on footguns. There&#x27;s much value in using a tool that is powerful enough to do what you need, but not much more -- since that makes it much easier to reason about what a given instance&#x2F;invocation of that tool could possibly be doing, without spending hours (years?) down in the detail.<p>And it sounds like Just is that tool for you! I&#x27;ll probably keep using make, now that I&#x27;ve spent so much time wrestling with its many idiosyncrasies, but you never know.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42352950" class="c"><input type="checkbox" id="c-42352950" checked=""/><div class="controls bullet"><span class="by">lijok</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352739">parent</a><span>|</span><a href="#42352859">prev</a><span>|</span><a href="#42353746">next</a><span>|</span><label class="collapse" for="c-42352950">[-]</label><label class="expand" for="c-42352950">[3 more]</label></div><br/><div class="children"><div class="content">I was asking a genuine question to see if I had missed anything about how just works, given that I couldn&#x27;t see the difference, and you were proclaiming that there is one.<p>Your comments are coming off very deffensive and insecure.</div><br/><div id="42353028" class="c"><input type="checkbox" id="c-42353028" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352950">parent</a><span>|</span><a href="#42353340">next</a><span>|</span><label class="collapse" for="c-42353028">[-]</label><label class="expand" for="c-42353028">[1 more]</label></div><br/><div class="children"><div class="content">My comments are frustrated because I believe a response was already given to the question you asked. I&#x27;ll be grateful if you at least don&#x27;t misrepresent, even if it&#x27;s difficult to find a common language. If you don&#x27;t believe that I responded adequately then just ask a more detailed question.<p>But sure, here&#x27;s one more reason for you, as said in a sibling subthread: I can have all my project&#x27;s commands in one file.<p>Also it pays off to know what `just` does. As several other people were told (not only by me) in the bigger thread, it&#x27;s an aggregating task runner, more or less. Not a dependency manager.</div><br/></div></div><div id="42353340" class="c"><input type="checkbox" id="c-42353340" checked=""/><div class="controls bullet"><span class="by">burnished</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352950">parent</a><span>|</span><a href="#42353028">prev</a><span>|</span><a href="#42353746">next</a><span>|</span><label class="collapse" for="c-42353340">[-]</label><label class="expand" for="c-42353340">[1 more]</label></div><br/><div class="children"><div class="content">Honestly you&#x27;re coming off a bit shit here, I don&#x27;t read the other person&#x27;s responses as defensive or insecure at all, so I suspect you&#x27;re saying that to be rude.</div><br/></div></div></div></div></div></div></div></div><div id="42353746" class="c"><input type="checkbox" id="c-42353746" checked=""/><div class="controls bullet"><span class="by">banku_brougham</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42351858">parent</a><span>|</span><a href="#42352711">prev</a><span>|</span><a href="#42353853">next</a><span>|</span><label class="collapse" for="c-42353746">[-]</label><label class="expand" for="c-42353746">[1 more]</label></div><br/><div class="children"><div class="content">yep just has good ergonomics for little things in my dev workflow</div><br/></div></div></div></div><div id="42353853" class="c"><input type="checkbox" id="c-42353853" checked=""/><div class="controls bullet"><span class="by">brushfoot</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42351754">parent</a><span>|</span><a href="#42351858">prev</a><span>|</span><a href="#42351852">next</a><span>|</span><label class="collapse" for="c-42353853">[-]</label><label class="expand" for="c-42353853">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, particularly if you pipe to fzf.<p>(For those who haven&#x27;t used it, fzf is a fuzzy-searchable menu for the command line. You pipe lines of input to it, and it shows them in a menu. You start typing and it fuzzy searches the menu and selects the best match. Then you press Enter to pipe that out, or Tab for multi-select. It&#x27;s fantastic.)<p>I have convenience functions in my profile script that pipe different things to fzf...scripts, paths in the current directory to copy to the clipboard, etc. It&#x27;s indispensable.<p>Bonus: progressive enhancement. If someone doesn&#x27;t have fzf&#x2F;those convenience functions, it&#x27;s just a directory with shell scripts, so they don&#x27;t have to do anything special to use them.</div><br/></div></div><div id="42351852" class="c"><input type="checkbox" id="c-42351852" checked=""/><div class="controls bullet"><span class="by">zwerdlds</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42351754">parent</a><span>|</span><a href="#42353853">prev</a><span>|</span><a href="#42352418">next</a><span>|</span><label class="collapse" for="c-42351852">[-]</label><label class="expand" for="c-42351852">[1 more]</label></div><br/><div class="children"><div class="content">That works too.  I&#x27;ve done both and I currently use Just because it collects the entrypoints to the project into a single file.  This can provide an advantage where there&#x27;s a bit of interdependence across your entrypoints.<p>E.g: You have a docker container, you might be `run`ning it, `exec`ing it etc. from the same compose-file.  So Just gives you the ability to link those shared commands within the same file.  Once the entrypoints get too numerous you can either break them into scripts (I do this partially depending on the level of behavioral complexity in the script) or partition your justfiles and import them into a single master.</div><br/></div></div><div id="42352418" class="c"><input type="checkbox" id="c-42352418" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42351754">parent</a><span>|</span><a href="#42351852">prev</a><span>|</span><a href="#42351897">next</a><span>|</span><label class="collapse" for="c-42352418">[-]</label><label class="expand" for="c-42352418">[18 more]</label></div><br/><div class="children"><div class="content">Well, for one, your recipes can be in another language (e.g. Python).<p>You can build complex recipes out of simpler ones. Sure, you could do that by creating a new shell script that calls other shell scripts, but then you&#x27;re reinventing just.<p>You don&#x27;t need to be in the directory to run those scripts.<p>I think a better question for you: What&#x27;s the benefit of putting .PHONY recipes in Makefiles, when you could just have a directory full of shell scripts. If you find yourself using .PHONY recipes, then you already have a reason to use just.</div><br/><div id="42352857" class="c"><input type="checkbox" id="c-42352857" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352418">parent</a><span>|</span><a href="#42352897">next</a><span>|</span><label class="collapse" for="c-42352857">[-]</label><label class="expand" for="c-42352857">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Well, for one, your recipes can be in another language (e.g. Python).<p>Surely this is true for stuff in a .&#x2F;bin or .&#x2F;scripts folder - binaries, python with shebang etc?</div><br/><div id="42352954" class="c"><input type="checkbox" id="c-42352954" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352857">parent</a><span>|</span><a href="#42352897">next</a><span>|</span><label class="collapse" for="c-42352954">[-]</label><label class="expand" for="c-42352954">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I see there&#x27;s:<p><a href="https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;shebang-recipes.html" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;shebang-recipes.html</a><p>Which could be done in shell, but typically rather be limited to oneliners (invoking awk) rather than piping a heredoc to an interpreter.</div><br/></div></div></div></div><div id="42352897" class="c"><input type="checkbox" id="c-42352897" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352418">parent</a><span>|</span><a href="#42352857">prev</a><span>|</span><a href="#42351897">next</a><span>|</span><label class="collapse" for="c-42352897">[-]</label><label class="expand" for="c-42352897">[15 more]</label></div><br/><div class="children"><div class="content">&gt; You don&#x27;t need to be in the directory to run those scripts.<p>There&#x27;s already an easy way to solve this: $PATH.<p>&gt; I think a better question for you: What&#x27;s the benefit of putting .PHONY recipes in Makefiles, when you could just have a directory full of shell scripts. If you find yourself using .PHONY recipes, then you already have a reason to use just.<p>Well, I think it&#x27;s the same question, rather than a better question. And the answer is yes, if <i>all</i> you need from make, now and in the future, is a set of .PHONY targets, then by all means just use shell scripts. make is used because often you need slightly more than this -- or you may do so tomorrow, and don&#x27;t want to change the syntax you use to accomplish tasks.</div><br/><div id="42353051" class="c"><input type="checkbox" id="c-42353051" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352897">parent</a><span>|</span><a href="#42351897">next</a><span>|</span><label class="collapse" for="c-42353051">[-]</label><label class="expand" for="c-42353051">[14 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s already an easy way to solve this: $PATH.<p>I have 10 projects. Each with their own set of shell scripts. You want me (and all other developers) to pollute the $PATH with 10 directories?<p>And then you have a namespace problem. I usually have a &quot;test&quot; recipe in my justfiles. The analog would be a test.sh file. But with your solution, it will have to be projA-test.sh and projB-test.sh.<p>And if I dump them all into the $PATH, how do I quickly see the scripts relevant to a particular project?</div><br/><div id="42353144" class="c"><input type="checkbox" id="c-42353144" checked=""/><div class="controls bullet"><span class="by">L3viathan</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353051">parent</a><span>|</span><a href="#42353513">next</a><span>|</span><label class="collapse" for="c-42353144">[-]</label><label class="expand" for="c-42353144">[5 more]</label></div><br/><div class="children"><div class="content">You can put `.&#x2F;scripts` in your $PATH, if you want.</div><br/><div id="42353664" class="c"><input type="checkbox" id="c-42353664" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353144">parent</a><span>|</span><a href="#42353173">next</a><span>|</span><label class="collapse" for="c-42353664">[-]</label><label class="expand" for="c-42353664">[1 more]</label></div><br/><div class="children"><div class="content">1. This requires that all your projects use &quot;scripts&quot; as the directory name.<p>2. This works only if you just happen to be in the directory above scripts.</div><br/></div></div><div id="42353173" class="c"><input type="checkbox" id="c-42353173" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353144">parent</a><span>|</span><a href="#42353664">prev</a><span>|</span><a href="#42353513">next</a><span>|</span><label class="collapse" for="c-42353173">[-]</label><label class="expand" for="c-42353173">[3 more]</label></div><br/><div class="children"><div class="content">Absolutely do not do this. That’s all well and good until you clone a repo that ‘scripts&#x2F;ls’ =&gt; install_ransomwhere().</div><br/><div id="42353202" class="c"><input type="checkbox" id="c-42353202" checked=""/><div class="controls bullet"><span class="by">olejorgenb</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353173">parent</a><span>|</span><a href="#42353184">next</a><span>|</span><label class="collapse" for="c-42353202">[-]</label><label class="expand" for="c-42353202">[1 more]</label></div><br/><div class="children"><div class="content">You can put .scripts last in PATH (or first - whichever disallows scripts&#x2F;ls to take precedence over &#x2F;usr&#x2F;bin&#x2F;ls)</div><br/></div></div><div id="42353184" class="c"><input type="checkbox" id="c-42353184" checked=""/><div class="controls bullet"><span class="by">olejorgenb</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353173">parent</a><span>|</span><a href="#42353202">prev</a><span>|</span><a href="#42353513">next</a><span>|</span><label class="collapse" for="c-42353184">[-]</label><label class="expand" for="c-42353184">[1 more]</label></div><br/><div class="children"><div class="content">You could put `.$MY-SECRET` it `PATH` and selectively symlink this to vetted script directories</div><br/></div></div></div></div></div></div><div id="42353513" class="c"><input type="checkbox" id="c-42353513" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353051">parent</a><span>|</span><a href="#42353144">prev</a><span>|</span><a href="#42353626">next</a><span>|</span><label class="collapse" for="c-42353513">[-]</label><label class="expand" for="c-42353513">[6 more]</label></div><br/><div class="children"><div class="content">Direnv is a great tool for this FWIW.</div><br/><div id="42353704" class="c"><input type="checkbox" id="c-42353704" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353513">parent</a><span>|</span><a href="#42353626">next</a><span>|</span><label class="collapse" for="c-42353704">[-]</label><label class="expand" for="c-42353704">[5 more]</label></div><br/><div class="children"><div class="content">Won&#x27;t work in Windows.<p>I think it really has to be emphasized: One of the great things about just is that it works in Windows with no hassles.</div><br/><div id="42355049" class="c"><input type="checkbox" id="c-42355049" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353704">parent</a><span>|</span><a href="#42354310">next</a><span>|</span><label class="collapse" for="c-42355049">[-]</label><label class="expand" for="c-42355049">[2 more]</label></div><br/><div class="children"><div class="content">But won&#x27;t all the scripts break?</div><br/><div id="42355221" class="c"><input type="checkbox" id="c-42355221" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42355049">parent</a><span>|</span><a href="#42354310">next</a><span>|</span><label class="collapse" for="c-42355221">[-]</label><label class="expand" for="c-42355221">[1 more]</label></div><br/><div class="children"><div class="content">Are you writing scripts that will break?<p>just isn&#x27;t something magical that will make scripts meant for Linux work in Windows, you know. Some people do actual development in Windows and have Windows scripts.</div><br/></div></div></div></div><div id="42354310" class="c"><input type="checkbox" id="c-42354310" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353704">parent</a><span>|</span><a href="#42355049">prev</a><span>|</span><a href="#42353626">next</a><span>|</span><label class="collapse" for="c-42354310">[-]</label><label class="expand" for="c-42354310">[2 more]</label></div><br/><div class="children"><div class="content">Are you sure it won&#x27;t work?<p>I ask because cmd.exe has DOSKEY, which is basically a very slightly souped up version of bash&#x27;s alias. I think it wouldn&#x27;t be hard to use DOSKEY to replace CD and PUSHD with macros that run some command to update %PATH% and then change directory as usual.</div><br/><div id="42355222" class="c"><input type="checkbox" id="c-42355222" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42354310">parent</a><span>|</span><a href="#42353626">next</a><span>|</span><label class="collapse" for="c-42355222">[-]</label><label class="expand" for="c-42355222">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s probably a tool that will work similarly in Windows. I was saying it merely because that&#x27;s what the direnv Github page implies.</div><br/></div></div></div></div></div></div></div></div><div id="42353626" class="c"><input type="checkbox" id="c-42353626" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353051">parent</a><span>|</span><a href="#42353513">prev</a><span>|</span><a href="#42351897">next</a><span>|</span><label class="collapse" for="c-42353626">[-]</label><label class="expand" for="c-42353626">[2 more]</label></div><br/><div class="children"><div class="content">I tend to work on different projects in different terminal sessions so I don&#x27;t find this a problem, but OK, I can see the benefit of making the tasks a command line executes dependent on the current directory. (There are tools that can auto-adjust $PATH for you like this, but that would be a weak argument against Just (unless you&#x27;re using them already) since it would mean swapping Just for that-other-tool.)<p>If you use git and don&#x27;t need multiple &quot;layers&quot; of Justfiles (i.e., if you have all your scripts in a scripts folder at the top level of your repo), then in bash you can get what you want with:<p><pre><code>    run(){ `git rev-parse --show-toplevel`&#x2F;scripts&#x2F;$*; }
</code></pre>
Now from any repo subdir, `run clean` will run a script named &quot;clean&quot; in the scripts folder at the top level.</div><br/><div id="42353725" class="c"><input type="checkbox" id="c-42353725" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353626">parent</a><span>|</span><a href="#42351897">next</a><span>|</span><label class="collapse" for="c-42353725">[-]</label><label class="expand" for="c-42353725">[1 more]</label></div><br/><div class="children"><div class="content">Although I&#x27;m coming off as a strong just evangelist, I do want to point out that if someone already has a workflow with just scripts, it&#x27;s totally OK to continue with that. Personally, I think using just is simpler for those who already don&#x27;t have that workflow.<p>Likewise, if you are using make as a command runner and already know make well enough - by all means continue! In my experience, though, someone who doesn&#x27;t know make will be much more likely to learn just than make.<p>I tend to sneak justfiles into the projects I work on. They usually don&#x27;t have any good automation (no make, perhaps some scripts with a doc&#x2F;md file explaining which script is for what). I sneak the justfile in the repository, and when it&#x27;s mature, start showing teammates how I use it. They typically then switch to it. I don&#x27;t think they would switch to it if it were a Makefile.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42351897" class="c"><input type="checkbox" id="c-42351897" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351736">parent</a><span>|</span><a href="#42351754">prev</a><span>|</span><a href="#42354594">next</a><span>|</span><label class="collapse" for="c-42351897">[-]</label><label class="expand" for="c-42351897">[6 more]</label></div><br/><div class="children"><div class="content">1. The language is extremely simple and is consistent.<p>2. I agree on having to move away from imperative and go for declarative (if the latter was what you had in mind) -- any ideas for a better tool that does that and is just as easy to learn?<p>3. RE: cobbling together stuff with and around `just` is relatively trivial to fix f.ex. I have my own `just` recipes to bring up the entire set of dev dependencies for the project at hand, and then to tear them down. It&#x27;s a very small investment and you get a lot of ROI.<p>4. RE: Nix, nah, if that&#x27;s your sales pitch for it and against `just` then I&#x27;ll just strongly disagree. Nix is a mess, has confusing cutesy naming terminology, has a big learning curve and a terrible language. All of that would be fine, mind you, and I could muscle through it easily but the moment I received several cryptic error messages that absolutely did not tell me what I did wrong and I had to go to forums and get yelled at, is the moment I gave up. `just` is simply much easier and I am not worried about not having Nix-like environments for my projects. Docker + compose work very well for this.<p>Finally, your point about an obscure single command that people forget about in the future applies to literally any and all task runners and dependency managers, Nix included. That&#x27;s not a valid criticism towards `just` IMO.</div><br/><div id="42355716" class="c"><input type="checkbox" id="c-42355716" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42351897">parent</a><span>|</span><a href="#42352404">next</a><span>|</span><label class="collapse" for="c-42355716">[-]</label><label class="expand" for="c-42355716">[1 more]</label></div><br/><div class="children"><div class="content"><i>Nix [...] and a terrible language</i><p>I never get this criticism. Nix is a pretty nice, small, functional programming language and lazy evaluation makes it really powerful (see e.g. using fixed-points for overlays). I wonder if this criticism comes from people who have never done any functional programming?<p>When I first started with Nix six years ago, the language was one of the things I immediately liked a lot. What I didn&#x27;t like was the lack of documentation for all the functions, hooks, etc. in <i>nixpkgs</i>, though it certainly got better with time.</div><br/></div></div><div id="42352404" class="c"><input type="checkbox" id="c-42352404" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42351897">parent</a><span>|</span><a href="#42355716">prev</a><span>|</span><a href="#42354594">next</a><span>|</span><label class="collapse" for="c-42352404">[-]</label><label class="expand" for="c-42352404">[4 more]</label></div><br/><div class="children"><div class="content">1. It&#x27;s a fine language but I have all kinds of &quot;works on my machine&quot; problems with it because it has no associated dependency manager. Other languages solve this with lockfiles and such, and it&#x27;s likely that you&#x27;re already doing that with one of those same languages in the same project. So just... Use the main language for whatever it is.<p>2. No, nothing&#x27;s so easy, but you can get more if you&#x27;re willing to work for it, and I think the juice is worth the squeeze.<p>3. For runtime state, I find that using just as a wrapper around Tilt or docker-compose or k3d or whatever just hides the perfectly adequate interfaces that those tools have. The wrapper discourages deeper tinkering with those tools. It&#x27;s not a particularly difficult layer of abstraction to pierce, but it doesn&#x27;t buy you enough to justify having an additional layer at all.<p>4. In the case I&#x27;m thinking of, the whole team was working happily because they had used a Just recipe to download a file from a different repo, and then somebody removed the recipe, but everyone (except the new guy) had the file from months ago, which worked. Nix wouldn&#x27;t have let us accidentally get into a broken state and not know it. It would have broken as soon as we removed the derivation for the necessary file. I sent him the file through slack and then he was able to work, and only discovered later how it got there on my machine. That kind of uncertainty leads to expensive problems eventually.</div><br/><div id="42352484" class="c"><input type="checkbox" id="c-42352484" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352404">parent</a><span>|</span><a href="#42354594">next</a><span>|</span><label class="collapse" for="c-42352484">[-]</label><label class="expand" for="c-42352484">[3 more]</label></div><br/><div class="children"><div class="content">1. I don&#x27;t follow. I work with Elixir, Golang and Rust and I use their dependency managers just fine. F.ex. I have `just deps` that does `mix deps.get` in Elixir and `go get -u .&#x2F;... &amp;&amp; go mod tidy &amp;&amp; go mod vendor` in Golang. Furthermore, `just` does not claim to do dependency management. So what do you mean here?<p>2. Sure but I am not paid for it. Nobody will look at me with admiration if I delay an important milestone with 2 weeks (or, more likely, 2 years) to invent such a tool. :&#x2F; So not sure I get you here either.<p>3. We&#x27;re veering into bikeshedding here and I will not argue; use whatever interface works best for you. I personally love having `just up` &#x2F; `just down` &#x2F; `just start` &#x2F; `just stop` for my development dependencies of any project project. No more one big shared Postgres instance that if I screw it up (and homebrew did that a number of times!) I&#x27;ll have to dig through TimeMachine for DB backups. I wisened up eventually and started making scheduled exhaustive backups of each DB... and then said to myself &quot;forget it&quot; and just started using separate containers for each project. For my work I found wrapping the tools worth it for not having to remember their bespoke full command lines. I standardized my tasks and I can enter almost any directory and run the same `just ...` commands and get what I expect as a result. To me that&#x27;s valuable. But again, use whatever is convenient for you. No argument from me.<p>4. I don&#x27;t disagree here and I am kind of 50&#x2F;50 because on the one hand this is failure of process + lack of proper dev&#x2F;ops tooling (f.ex. deleting this or that should raise alarms i.e. every such repository should have CI that makes sure everything important stays in place). On the other hand if Nix or anything else spares you from having to install those guard rails then sure, then it&#x27;s a good fit for you. For my work and hobbies Nix is a net negative and I gave it more than a fair chance and I had enough of opinionated diva-like tools whose message is &quot;learn everything about me to love me, baby&quot;. No thanks. But that&#x27;s just a single example. Again, if there are tools that spare you from screwing up something accidentally, I usually vote strongly in favor of them.</div><br/><div id="42353263" class="c"><input type="checkbox" id="c-42353263" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352484">parent</a><span>|</span><a href="#42354594">next</a><span>|</span><label class="collapse" for="c-42353263">[-]</label><label class="expand" for="c-42353263">[2 more]</label></div><br/><div class="children"><div class="content">People like Just when they&#x27;re the one who is writing the recipes, because those recipes implicitly depend on whatever they have installed at the time of writing so everything is easy, but then other people come to the project and it has a culture of &quot;IDK I just use the Just recipe,&quot; except that recipe doesn&#x27;t work unless you&#x27;ve been around since it was written and have all of the right versions of things.  For instance I&#x27;ve got all these errors like:<p>&gt; This application uses version go1.20 of the source-processing packages but runs version go1.23 of &#x27;go list&#x27;. It may fail to process source files that rely on newer language features. If so, rebuild the application using a newer version of Go.<p>They don&#x27;t seem to be hurting anything but I&#x27;m not really sure how to reason about them since somebody packaged the commands together but didn&#x27;t specify anything about the environment.  The Justfile entry tells me that it&#x27;s running some script in $FOO_DOWNLOAD_DIR but I&#x27;ve got some sleuthing to do to figure out where that dir actually is and how its contents were populated and what it has to do with `go list`.<p>This is of course bad practice, but Just is the rug under which it is hidden and made to look like good practice.  It&#x27;s good that Just doesn&#x27;t claim to manage dependencies, since it doesn&#x27;t, but this action could instead be a go program in which case go <i>would</i> be handling those dependencies for me.</div><br/><div id="42353305" class="c"><input type="checkbox" id="c-42353305" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353263">parent</a><span>|</span><a href="#42354594">next</a><span>|</span><label class="collapse" for="c-42353305">[-]</label><label class="expand" for="c-42353305">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree. Your example is a good demonstration why Nix -- or a much more thorough Justfile -- would be needed.<p>In my case I also supply the `.tool-versions` file so that only mandates the other dev to have Just and asdf &#x2F; mise (for installing exactly the right versions of tools).<p>I also tried having full Dockerized development environment but that proved to be too much of a hassle.<p>But yep, in your scenario it seems like the other guys did sloppy work. Sadly 99% of everything can be misused by people who don&#x27;t practice their craft well.<p>(EDIT: Golang programs should really be made to work with the latest version, all being said and done. Another example of sloppy work, if you don&#x27;t mind me saying.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42354594" class="c"><input type="checkbox" id="c-42354594" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42351736">parent</a><span>|</span><a href="#42351897">prev</a><span>|</span><a href="#42355422">next</a><span>|</span><label class="collapse" for="c-42354594">[-]</label><label class="expand" for="c-42354594">[1 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t want to buy into the whole Nix philosophy, you can also use something like &#x27;shake&#x27; (<a href="https:&#x2F;&#x2F;shakebuild.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shakebuild.com&#x2F;</a>) to build your own buildsystem-like command line tooling.</div><br/></div></div><div id="42355422" class="c"><input type="checkbox" id="c-42355422" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#42351736">parent</a><span>|</span><a href="#42354594">prev</a><span>|</span><a href="#42352318">next</a><span>|</span><label class="collapse" for="c-42355422">[-]</label><label class="expand" for="c-42355422">[1 more]</label></div><br/><div class="children"><div class="content">just is not meant as a built tool, just a task runner. Those have vastly different goals.<p>make is a build system: it has targets, it has file deps, a dag resolver, etc.<p>But a task runner is basically a fancy aliaser with task deps and arg parsing&#x2F;proxing.<p>And just is good at being that. Although I agree I not a fan of adding yet another DSL.</div><br/></div></div><div id="42352318" class="c"><input type="checkbox" id="c-42352318" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42351736">parent</a><span>|</span><a href="#42355422">prev</a><span>|</span><a href="#42351171">next</a><span>|</span><label class="collapse" for="c-42352318">[-]</label><label class="expand" for="c-42352318">[5 more]</label></div><br/><div class="children"><div class="content">&gt; like make, it encourages an imperative mode for project tooling and I think we should distance ourselves from that a bit further.<p>Um, what? `make` is arguably the most common declarative tool in existence ...<p>Whenever people complain about Make in detail, it&#x27;s almost always either because they&#x27;re violating Paul&#x27;s Rules of Makefiles or because they&#x27;re actually complaining about autotools (or occasionally cmake).</div><br/><div id="42355762" class="c"><input type="checkbox" id="c-42355762" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352318">parent</a><span>|</span><a href="#42353691">next</a><span>|</span><label class="collapse" for="c-42355762">[-]</label><label class="expand" for="c-42355762">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite easy to accidentally write makefiles that build something different when you run them a second time, or when some server that used to be reliable suddenly goes down. Or when the user upgrades something that you wouldn&#x27;t think is related.<p>It does no validation of inputs. So suppose you&#x27;re bisecting your way towards the cause of a failure related to the compiler version. Ideally there would be a commit which changed the compiler version, so your bisect would find a nice neat boundary in version history where the problem began. Make, by contrast, is just picking up whatever it finds on the PATH and hoping for the best. So the best you can do is exclude the code as the source of the bug and start scratching your head about the environment.<p>That willingness to just pick up whatever it finds and make changes wherever it wants with no regard to whether dependency created by these state changes is made explicit and transparent to the user is what I mean by &quot;imperative&quot;.</div><br/></div></div><div id="42353691" class="c"><input type="checkbox" id="c-42353691" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42352318">parent</a><span>|</span><a href="#42355762">prev</a><span>|</span><a href="#42351171">next</a><span>|</span><label class="collapse" for="c-42353691">[-]</label><label class="expand" for="c-42353691">[3 more]</label></div><br/><div class="children"><div class="content">Make isn&#x27;t, at all, declarative. It&#x27;s almost entirely based on you writing out <i>what</i> to invoke, as opposed to what should exist and having the build system &quot;figure that out&quot;.<p>That is, in make you say `$(CC) -c foo.c -o foo.o`, which is telling you, ultimately, how to compile the thing, while declarative build systems (bazel&#x2F;nix&#x2F;etc.) you say &quot;this is a cc_binary&quot; or &quot;this is a cc_library&quot; and you let it figure the rest out for you.</div><br/><div id="42354361" class="c"><input type="checkbox" id="c-42354361" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353691">parent</a><span>|</span><a href="#42354488">next</a><span>|</span><label class="collapse" for="c-42354361">[-]</label><label class="expand" for="c-42354361">[1 more]</label></div><br/><div class="children"><div class="content">If your executable is named &quot;foo&quot; and there is a &quot;foo.c&quot; somewhere, your Makefile only needs to contain &quot;foo:&quot; and make will figure out how to build it using its default rules. If you have more than one file (ex: foo.c and bar.c), just write &quot;foo: bar.c&quot;.<p>Modern build systems are more advanced and have better defaults, but the general idea is the same. They are all declarative. An imperative build system would be like a shell script.</div><br/></div></div><div id="42354488" class="c"><input type="checkbox" id="c-42354488" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42351736">root</a><span>|</span><a href="#42353691">parent</a><span>|</span><a href="#42354361">prev</a><span>|</span><a href="#42351171">next</a><span>|</span><label class="collapse" for="c-42354488">[-]</label><label class="expand" for="c-42354488">[1 more]</label></div><br/><div class="children"><div class="content">Your &quot;declarative&quot; systems are no more declarative - they just <i>hide</i> the commands&#x2F;flags being used, far worse than `include config.make`.</div><br/></div></div></div></div></div></div></div></div><div id="42351171" class="c"><input type="checkbox" id="c-42351171" checked=""/><div class="controls bullet"><span class="by">golly_ned</span><span>|</span><a href="#42351736">prev</a><span>|</span><a href="#42352069">next</a><span>|</span><label class="collapse" for="c-42351171">[-]</label><label class="expand" for="c-42351171">[33 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used Just at a workplace on a project I didn&#x27;t start. It seemed slightly simpler than make when putting together task dependencies. But I couldn&#x27;t figure out what justifies using it over make.</div><br/><div id="42351565" class="c"><input type="checkbox" id="c-42351565" checked=""/><div class="controls bullet"><span class="by">clintonc</span><span>|</span><a href="#42351171">parent</a><span>|</span><a href="#42351349">next</a><span>|</span><label class="collapse" for="c-42351565">[-]</label><label class="expand" for="c-42351565">[4 more]</label></div><br/><div class="children"><div class="content">For me, it&#x27;s a fit-for-purpose issue. Make is great when you&#x27;re creating artifacts and want to rebuild based on changes. Just is a task runner, so while there&#x27;s a notion of dependent tasks, there&#x27;s no notion of dependent artifacts. If you&#x27;re using a lot of .PHONY targets in a Makefile, you&#x27;re mostly using it as a task runner -- it works, but it&#x27;s not ergonomic.<p>I like that just will search upward for the nearest justfile, and run the command with its directory as the working directory (optional -- <a href="https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;attributes.html" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;attributes.html</a> -- with fallback available -- <a href="https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;fallback-to-parent-justfiles.html" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;fallback-to-parent-justfiles.htm...</a>). For example, I might use something like `just devserver` or `just testfe` to trigger commands, or `just upload` to push some assets -- these commands work from anywhere within the project.<p>My life wouldn&#x27;t be <i>that</i> different if I just had to use Make (and I still use Make for some tasks), but I like having a language-agnostic, more ergonomic task runner.</div><br/><div id="42352937" class="c"><input type="checkbox" id="c-42352937" checked=""/><div class="controls bullet"><span class="by">nrclark</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351565">parent</a><span>|</span><a href="#42351640">next</a><span>|</span><label class="collapse" for="c-42352937">[-]</label><label class="expand" for="c-42352937">[2 more]</label></div><br/><div class="children"><div class="content">Just a quick note for interested readers: you don&#x27;t need to explicitly mark things as .PHONY in make, unless your Makefile lives next to files&#x2F;folders with the same name as your targets. So unless you had some file called &quot;install&quot; in the same folder, you wouldn&#x27;t need to have something like  &quot;.PHONY: install&quot;.</div><br/><div id="42354127" class="c"><input type="checkbox" id="c-42354127" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42352937">parent</a><span>|</span><a href="#42351640">next</a><span>|</span><label class="collapse" for="c-42354127">[-]</label><label class="expand" for="c-42354127">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the right thing to do, so you should. Relying on implicit condition of specific file missing in current directory is very wrong IMO.</div><br/></div></div></div></div><div id="42351640" class="c"><input type="checkbox" id="c-42351640" checked=""/><div class="controls bullet"><span class="by">peterldowns</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351565">parent</a><span>|</span><a href="#42352937">prev</a><span>|</span><a href="#42351349">next</a><span>|</span><label class="collapse" for="c-42351640">[-]</label><label class="expand" for="c-42351640">[1 more]</label></div><br/><div class="children"><div class="content">As a heavy Just user, I agree with all of this — great answer.</div><br/></div></div></div></div><div id="42351349" class="c"><input type="checkbox" id="c-42351349" checked=""/><div class="controls bullet"><span class="by">nucleardog</span><span>|</span><a href="#42351171">parent</a><span>|</span><a href="#42351565">prev</a><span>|</span><a href="#42351384">next</a><span>|</span><label class="collapse" for="c-42351349">[-]</label><label class="expand" for="c-42351349">[2 more]</label></div><br/><div class="children"><div class="content">make is a build system and has a lot of complexity in it to make it optimal (or at least attempt to) for that use case.<p>just is a &quot;command runner&quot; and functionally the equivalent of packing up a folder full of short scripts into a single file with a little bit of sugar on top. (E.g., by default every script is executed with the CWD being the folder the justfile is in so you don&#x27;t need to go search for that stackoverflow answer about getting the script&#x27;s folder and paste that in the top of every script.)<p>If you use just as a build system, you&#x27;re going to end up reimplementing half of make. If you try and use make as a command runner, you end up fighting it in many ways because you&#x27;re not &quot;building&quot; things.<p>I&#x27;ve generally found the most value in just in situations where shell is a good way to implement whatever I&quot;m doing but it&#x27;s grown large enough that it could benefit from some greater organization.</div><br/><div id="42351685" class="c"><input type="checkbox" id="c-42351685" checked=""/><div class="controls bullet"><span class="by">12_throw_away</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351349">parent</a><span>|</span><a href="#42351384">next</a><span>|</span><label class="collapse" for="c-42351685">[-]</label><label class="expand" for="c-42351685">[1 more]</label></div><br/><div class="children"><div class="content">&gt; search for that stackoverflow answer about getting the script&#x27;s folder and paste that in the top of every script<p>Ah, a fellow Person of Culture.</div><br/></div></div></div></div><div id="42351384" class="c"><input type="checkbox" id="c-42351384" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351171">parent</a><span>|</span><a href="#42351349">prev</a><span>|</span><a href="#42351204">next</a><span>|</span><label class="collapse" for="c-42351384">[-]</label><label class="expand" for="c-42351384">[1 more]</label></div><br/><div class="children"><div class="content">Having recipes just for Windows&#x2F;Linux.<p>Being able to write your recipes in another language.<p>Not having to be in the directory where the Makefile resides.<p>Being able to call a recipe <i>after</i> the current recipe with &amp;&amp; syntax.<p>Overall lower mental burden than make. make is very complex. just is very simple. If you know neither of the two, you&#x27;ll get going much faster with just.</div><br/></div></div><div id="42351204" class="c"><input type="checkbox" id="c-42351204" checked=""/><div class="controls bullet"><span class="by">qznc</span><span>|</span><a href="#42351171">parent</a><span>|</span><a href="#42351384">prev</a><span>|</span><a href="#42354033">next</a><span>|</span><label class="collapse" for="c-42351204">[-]</label><label class="expand" for="c-42351204">[23 more]</label></div><br/><div class="children"><div class="content">The manual lists the reasons why using it over make: <a href="https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;</a><p>The question is if those reasons are convincing to someone. The big advantage of Make is that it is probably already installed.</div><br/><div id="42351528" class="c"><input type="checkbox" id="c-42351528" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351204">parent</a><span>|</span><a href="#42351337">next</a><span>|</span><label class="collapse" for="c-42351528">[-]</label><label class="expand" for="c-42351528">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can disable this behavior for specific targets using make’s built-in .PHONY target name, but the syntax is verbose and can be hard to remember.<p>I think this is overstating things a bit. I first read `.PHONY` in a Makefile while i was a teenager and i figured out what it does just by looking at it in practice.<p>Makefiles do have some weirdness (e.g. tab being part of the syntax) but `.PHONY` is not one of them.</div><br/></div></div><div id="42351337" class="c"><input type="checkbox" id="c-42351337" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351204">parent</a><span>|</span><a href="#42351528">prev</a><span>|</span><a href="#42351237">next</a><span>|</span><label class="collapse" for="c-42351337">[-]</label><label class="expand" for="c-42351337">[8 more]</label></div><br/><div class="children"><div class="content">What does it offer over bazel?</div><br/><div id="42351654" class="c"><input type="checkbox" id="c-42351654" checked=""/><div class="controls bullet"><span class="by">peterldowns</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351337">parent</a><span>|</span><a href="#42351709">next</a><span>|</span><label class="collapse" for="c-42351654">[-]</label><label class="expand" for="c-42351654">[6 more]</label></div><br/><div class="children"><div class="content">Not making you want to shoot yourself in the head.<p>It does one thing very well, and it has well-written and <i>useful</i> documentation.<p>It literally just runs commands in a convenient way.</div><br/><div id="42351676" class="c"><input type="checkbox" id="c-42351676" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351654">parent</a><span>|</span><a href="#42351709">next</a><span>|</span><label class="collapse" for="c-42351676">[-]</label><label class="expand" for="c-42351676">[5 more]</label></div><br/><div class="children"><div class="content">how well does it cache across a build farm?</div><br/><div id="42352005" class="c"><input type="checkbox" id="c-42352005" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351676">parent</a><span>|</span><a href="#42351704">next</a><span>|</span><label class="collapse" for="c-42352005">[-]</label><label class="expand" for="c-42352005">[1 more]</label></div><br/><div class="children"><div class="content">Did you miss the part that says &quot;it just runs commands in a convenient way&quot; and &quot;it is not a build system&quot;?</div><br/></div></div></div></div></div></div><div id="42351709" class="c"><input type="checkbox" id="c-42351709" checked=""/><div class="controls bullet"><span class="by">12_throw_away</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351337">parent</a><span>|</span><a href="#42351654">prev</a><span>|</span><a href="#42351237">next</a><span>|</span><label class="collapse" for="c-42351709">[-]</label><label class="expand" for="c-42351709">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a build system, it&#x27;s a command runner, it is for different use cases</div><br/></div></div></div></div><div id="42351237" class="c"><input type="checkbox" id="c-42351237" checked=""/><div class="controls bullet"><span class="by">erichdongubler</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351204">parent</a><span>|</span><a href="#42351337">prev</a><span>|</span><a href="#42351443">next</a><span>|</span><label class="collapse" for="c-42351237">[-]</label><label class="expand" for="c-42351237">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The big advantage of Make is that it is probably already installed.<p>...unless you&#x27;re on Windows, like me!</div><br/><div id="42351371" class="c"><input type="checkbox" id="c-42351371" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351237">parent</a><span>|</span><a href="#42354702">next</a><span>|</span><label class="collapse" for="c-42351371">[-]</label><label class="expand" for="c-42351371">[4 more]</label></div><br/><div class="children"><div class="content">Make is installed on Windows, if you install Microsoft&#x27;s C&#x2F;C++ dev stack (typically via installing Visual Studio). They just use nmake instead of GNU make. They also include Cmake these days, as it&#x27;s the common cross platform option.</div><br/><div id="42352387" class="c"><input type="checkbox" id="c-42352387" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351371">parent</a><span>|</span><a href="#42354702">next</a><span>|</span><label class="collapse" for="c-42352387">[-]</label><label class="expand" for="c-42352387">[3 more]</label></div><br/><div class="children"><div class="content">&gt; if you install Microsoft&#x27;s C&#x2F;C++ dev stack (typically via installing Visual Studio).<p>So I have to install this huge dependency just to use make, when my project is in Python?<p>Way easier to install just :-)</div><br/><div id="42353995" class="c"><input type="checkbox" id="c-42353995" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42352387">parent</a><span>|</span><a href="#42354702">next</a><span>|</span><label class="collapse" for="c-42353995">[-]</label><label class="expand" for="c-42353995">[2 more]</label></div><br/><div class="children"><div class="content">You wouldn&#x27;t use GNU Make (the thing that comes for &quot;default&quot; on Linux) with Python either.<p>What a weird way to converse.</div><br/><div id="42355231" class="c"><input type="checkbox" id="c-42355231" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42353995">parent</a><span>|</span><a href="#42354702">next</a><span>|</span><label class="collapse" for="c-42355231">[-]</label><label class="expand" for="c-42355231">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You wouldn&#x27;t use GNU Make (the thing that comes for &quot;default&quot; on Linux) with Python either.<p>But people <i>do</i> use Make all the time for Python projects - as a command runner. Pelican projects, for example, come with a Makefile to start the server, publish, etc.<p>The whole point of this submission is that many, many people use Makefiles not for incremental builds, but as a convenient place to store commonly used commands. And just is a better and simpler tool than make for that. If you&#x27;re on Windows, it&#x27;s a pain to install make, compared to installing just.</div><br/></div></div></div></div></div></div></div></div><div id="42354702" class="c"><input type="checkbox" id="c-42354702" checked=""/><div class="controls bullet"><span class="by">ttyprintk</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351237">parent</a><span>|</span><a href="#42351371">prev</a><span>|</span><a href="#42351443">next</a><span>|</span><label class="collapse" for="c-42354702">[-]</label><label class="expand" for="c-42354702">[1 more]</label></div><br/><div class="children"><div class="content">Busybox comes with a vestigial make. I wager git might. Those are both in winget.</div><br/></div></div></div></div><div id="42351443" class="c"><input type="checkbox" id="c-42351443" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351204">parent</a><span>|</span><a href="#42351237">prev</a><span>|</span><a href="#42354033">next</a><span>|</span><label class="collapse" for="c-42351443">[-]</label><label class="expand" for="c-42351443">[7 more]</label></div><br/><div class="children"><div class="content">The manual states that &quot;just is a command runner, not a build system,&quot; and mentions &quot;no need for .PHONY recipes!&quot; This seems to suggest that there&#x27;s no way to prevent Just from rebuilding targets, even if they are up-to-date. For me, one of the key advantages of using Make is its support for incremental builds, which is a major distinction from using a plain shell script to run some commands.</div><br/><div id="42351577" class="c"><input type="checkbox" id="c-42351577" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351443">parent</a><span>|</span><a href="#42352372">next</a><span>|</span><label class="collapse" for="c-42351577">[-]</label><label class="expand" for="c-42351577">[2 more]</label></div><br/><div class="children"><div class="content">Maybe it’s the stacks I’m using, but I’ve always had incremental happen with language-native tooling like `go` or `cargo`. So for me at least, having lazy eval features like that would be an unnecessary increase in scope and complexity. With Just, I can just throw together different commands and it just works cross platform. I love it.<p>I much prefer that than the other way, ie letting language tooling become command runners (looking at you npm). That’s the worst of both worlds.</div><br/><div id="42352572" class="c"><input type="checkbox" id="c-42352572" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351577">parent</a><span>|</span><a href="#42352372">next</a><span>|</span><label class="collapse" for="c-42352572">[-]</label><label class="expand" for="c-42352572">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’ve always had incremental happen with language-native tooling like `go` or `cargo`<p>That makes sense, but for me, Make is incredibly useful for incremental file processing outside of programming. I&#x27;ve written tiny Makefiles that use glob patterns to batch-convert thousands of SVGs into PNGs and WebPs, but only for the modified SVG files. I&#x27;ve used Make to batch-convert modified LaTeX files to PDFs and render modified Blender projects into WebM videos for the web. Rendering videos is <i>very</i> time-consuming, so only rendering modified video files is a huge win.</div><br/></div></div></div></div><div id="42352372" class="c"><input type="checkbox" id="c-42352372" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351443">parent</a><span>|</span><a href="#42351577">prev</a><span>|</span><a href="#42351967">next</a><span>|</span><label class="collapse" for="c-42352372">[-]</label><label class="expand" for="c-42352372">[2 more]</label></div><br/><div class="children"><div class="content">Your first sentence says:<p>&gt; just is a command runner, not a build system<p>And then you go ahead and complain that it is poor at building.<p>If you need a build tool, don&#x27;t use just. Use make or something else. The purpose of just is to stop putting non-build stuff in Makefiles. And of course, it has a nice set of features that make doesn&#x27;t.</div><br/><div id="42352713" class="c"><input type="checkbox" id="c-42352713" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42352372">parent</a><span>|</span><a href="#42351967">next</a><span>|</span><label class="collapse" for="c-42352713">[-]</label><label class="expand" for="c-42352713">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s been a misunderstanding.<p>&gt; Your first sentence says<p>My first sentence was me quoting the Just manual and my second sentence was my observation about what that suggests. I wasn&#x27;t asserting whether it&#x27;s true or not, just sharing my interpretation, as I&#x27;m not familiar with Just.<p>&gt; And then you go ahead and complain that it is poor at building.<p>I did not &quot;complain&quot; I stated that incremental builds, regardless of whether Just has them or not, is one feature I personally like about Make.<p>Going by the responses I received, Just does not appear to support incremental builds and a simple acknowledgement, minus the vitriol, would have sufficed.</div><br/></div></div></div></div><div id="42351967" class="c"><input type="checkbox" id="c-42351967" checked=""/><div class="controls bullet"><span class="by">guipsp</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351443">parent</a><span>|</span><a href="#42352372">prev</a><span>|</span><a href="#42351986">next</a><span>|</span><label class="collapse" for="c-42351967">[-]</label><label class="expand" for="c-42351967">[1 more]</label></div><br/><div class="children"><div class="content">If you need incrementalism, Just is not for you.</div><br/></div></div><div id="42351986" class="c"><input type="checkbox" id="c-42351986" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351171">root</a><span>|</span><a href="#42351443">parent</a><span>|</span><a href="#42351967">prev</a><span>|</span><a href="#42354033">next</a><span>|</span><label class="collapse" for="c-42351986">[-]</label><label class="expand" for="c-42351986">[1 more]</label></div><br/><div class="children"><div class="content">The programming languages that I use don&#x27;t need to be told to not rebuild from scratch so yours is a pretty strange argument.</div><br/></div></div></div></div></div></div><div id="42354033" class="c"><input type="checkbox" id="c-42354033" checked=""/><div class="controls bullet"><span class="by">richie_adler</span><span>|</span><a href="#42351171">parent</a><span>|</span><a href="#42351204">prev</a><span>|</span><a href="#42352315">next</a><span>|</span><label class="collapse" for="c-42354033">[-]</label><label class="expand" for="c-42354033">[1 more]</label></div><br/><div class="children"><div class="content">For me is not needing to chain a lot of commands with &amp;&amp; to ensure that it fails with the first command that fails. With just, if one of the commands of the recipe fails, it stops.</div><br/></div></div><div id="42352315" class="c"><input type="checkbox" id="c-42352315" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#42351171">parent</a><span>|</span><a href="#42354033">prev</a><span>|</span><a href="#42352069">next</a><span>|</span><label class="collapse" for="c-42352315">[-]</label><label class="expand" for="c-42352315">[1 more]</label></div><br/><div class="children"><div class="content">The moment you need to build the same software on windows its already justified IMO</div><br/></div></div></div></div><div id="42352069" class="c"><input type="checkbox" id="c-42352069" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#42351171">prev</a><span>|</span><a href="#42353020">next</a><span>|</span><label class="collapse" for="c-42352069">[-]</label><label class="expand" for="c-42352069">[8 more]</label></div><br/><div class="children"><div class="content">Can anyone with experience with just and tools like npm&#x2F;yarn explain if there are any benefits to use just instead of codifying commands into the &quot;scripts&quot; field of the package.json? Commands can also be enumerated. How often would I benefit from just&#x27;s other features?</div><br/><div id="42352170" class="c"><input type="checkbox" id="c-42352170" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42352069">parent</a><span>|</span><a href="#42352656">next</a><span>|</span><label class="collapse" for="c-42352170">[-]</label><label class="expand" for="c-42352170">[2 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t use Just, but we have a Makefile that doesn&#x27;t take advantage of any of Make&#x27;s dependency features just to easily be able to run several commands in sequence.<p>JSON is just a really bad format for script configuration—you either have to string commands together on one big line with &amp;&amp; or you have to pair package.json with some other strategy for organizing commands. That may end up being a `scripts` directory with a file per script, it could be that you use a framework that bakes all the complexity into shorter wrapper commands (a la vite), or you could use something like Just to sequence them.</div><br/><div id="42352243" class="c"><input type="checkbox" id="c-42352243" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#42352069">root</a><span>|</span><a href="#42352170">parent</a><span>|</span><a href="#42352656">next</a><span>|</span><label class="collapse" for="c-42352243">[-]</label><label class="expand" for="c-42352243">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not perfect but it gets the job done. Sometimes it&#x27;s ugly but in the end it forces me to break commands down into subcommands, which can increase clarity.<p>But sometimes you do have to write a collection of script files for complex multi-line scripts. I assumed I would still do that with just? Is the idea for these to all live in a single just file? I like having larger programs separated as individual files. All good points, though. I like make too, but it can definitely be needlessly verbose. My main thing would be not wanting to need users to have another binary installed locally. Can just live in my repository?<p>Edit: Nevermind! <a href="https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;nodejs-installation.html" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;nodejs-installation.html</a><p>&gt; `just-install` will install a local, platform-specific binary as part of the npm install command. This removes the need for every developer to install just independently using one of the processes mentioned above.</div><br/></div></div></div></div><div id="42352656" class="c"><input type="checkbox" id="c-42352656" checked=""/><div class="controls bullet"><span class="by">gurgeous</span><span>|</span><a href="#42352069">parent</a><span>|</span><a href="#42352170">prev</a><span>|</span><a href="#42354804">next</a><span>|</span><label class="collapse" for="c-42352656">[-]</label><label class="expand" for="c-42352656">[1 more]</label></div><br/><div class="children"><div class="content">Actually, it was package.json scripts that pushed me toward just! I wanted that stuff in non-node projects (python&#x2F;ruby&#x2F;~), I wanted more complicated scripts, I wanted more logging output, I wanted comments... For whatever reason every project seems to have 10-20 little commands (often interdependent) and just makes that a breeze.</div><br/></div></div><div id="42354804" class="c"><input type="checkbox" id="c-42354804" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42352069">parent</a><span>|</span><a href="#42352656">prev</a><span>|</span><a href="#42352160">next</a><span>|</span><label class="collapse" for="c-42354804">[-]</label><label class="expand" for="c-42354804">[2 more]</label></div><br/><div class="children"><div class="content">&quot;yarn&#x2F;npm install&quot; has an artifact in the project directory, so here&#x27;s one point for &quot;make&quot; instead of &quot;just&quot;:<p><pre><code>  start: node_modules
      yarn run start

  test: node_modules
      yarn run test

  node_modules: package.json yarn.lock
      yarn install
      touch $@
</code></pre>
You can clone the repo and &quot;make test&quot;, and it&#x27;ll include &quot;yarn install&quot; automatically - then on subsequent &quot;make test&quot;, it&#x27;ll skip it because &quot;node_modules&quot; is already up-to-date.  And then include it again later if someone updated the packages.  The &quot;touch&quot; is so the last-modified timestamp on &quot;node_modules&quot; is updated even if &quot;yarn install&quot; doesn&#x27;t add&#x2F;remove anything, so make knows it succeeded.<p>&quot;yarn install&quot; is usually pretty fast when it has nothing to do, so I can see why people may not bother and just have it run every time, but patterns like this can be used for quite a bit.  This way heavier commands don&#x27;t need to be run repeatedly and devs don&#x27;t need to know all the individual commands to run in sequence.</div><br/><div id="42355496" class="c"><input type="checkbox" id="c-42355496" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#42352069">root</a><span>|</span><a href="#42354804">parent</a><span>|</span><a href="#42352160">next</a><span>|</span><label class="collapse" for="c-42355496">[-]</label><label class="expand" for="c-42355496">[1 more]</label></div><br/><div class="children"><div class="content">The touch trick is nice. There&#x27;s definitely merit to such an approach, since it provides a simple cross-platform way to check if node_modules exists.<p>Though things begin to get more complicated if say, the project use plug-n-play resolution. `yarn` handles both cases.<p>Another benefit of `&quot;test&quot;: &quot;yarn &amp;&amp; &lt;test command&gt;&quot;` is that you also make sure the project is in a buildable state when testing.</div><br/></div></div></div></div><div id="42352160" class="c"><input type="checkbox" id="c-42352160" checked=""/><div class="controls bullet"><span class="by">zemo</span><span>|</span><a href="#42352069">parent</a><span>|</span><a href="#42354804">prev</a><span>|</span><a href="#42353020">next</a><span>|</span><label class="collapse" for="c-42352160">[-]</label><label class="expand" for="c-42352160">[2 more]</label></div><br/><div class="children"><div class="content">package.json is specific to node projects, just can be used for anything. Why learn the quirks of something you can only use with a single programming language? I&#x27;m also a fan of the shebang recipes: <a href="https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;shebang-recipes.html" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;shebang-recipes.html</a></div><br/><div id="42352215" class="c"><input type="checkbox" id="c-42352215" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#42352069">root</a><span>|</span><a href="#42352160">parent</a><span>|</span><a href="#42353020">next</a><span>|</span><label class="collapse" for="c-42352215">[-]</label><label class="expand" for="c-42352215">[1 more]</label></div><br/><div class="children"><div class="content">I place package.json files into non-node projects all the time just for some organizational benefits like workspaces and scripts. As a web-first engineer this doesn&#x27;t particularly bother me. I&#x27;ll check out shebang recipes, thanks!</div><br/></div></div></div></div></div></div><div id="42353020" class="c"><input type="checkbox" id="c-42353020" checked=""/><div class="controls bullet"><span class="by">tgmatt</span><span>|</span><a href="#42352069">prev</a><span>|</span><a href="#42355502">next</a><span>|</span><label class="collapse" for="c-42353020">[-]</label><label class="expand" for="c-42353020">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised nobody mentioned Rake yet. Having the full capability of Ruby and whatever gem you want makes it a dream for these kind of tasks. Absolutely love it.</div><br/><div id="42353289" class="c"><input type="checkbox" id="c-42353289" checked=""/><div class="controls bullet"><span class="by">ufmace</span><span>|</span><a href="#42353020">parent</a><span>|</span><a href="#42354765">next</a><span>|</span><label class="collapse" for="c-42353289">[-]</label><label class="expand" for="c-42353289">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I dropped in to say. I&#x27;ve used most of them, and I think Rake is my favorite.<p>Pretty much all of the others are shell command runners with a couple of extra bits bolted on. Well and good most of the time, but it&#x27;s another language to learn, and you&#x27;re mostly SOL if it doesn&#x27;t support something you want to do nicely.<p>With Rake, you get the same basic ability to do pre-set shell commands as the others, a single one or a sequence. But you also have the full power of Ruby, a full-fledged programming language, if you want to do anything more complex.</div><br/></div></div><div id="42354765" class="c"><input type="checkbox" id="c-42354765" checked=""/><div class="controls bullet"><span class="by">flomo</span><span>|</span><a href="#42353020">parent</a><span>|</span><a href="#42353289">prev</a><span>|</span><a href="#42355502">next</a><span>|</span><label class="collapse" for="c-42354765">[-]</label><label class="expand" for="c-42354765">[1 more]</label></div><br/><div class="children"><div class="content">I was looking for this comment, because rake is great. One big thing is it never felt good imposing Ruby on a (say) a JS project (and I&#x27;m not sure of the current state of macos default ruby), so next time this comes up, I will be taking a look at just.</div><br/></div></div></div></div><div id="42355502" class="c"><input type="checkbox" id="c-42355502" checked=""/><div class="controls bullet"><span class="by">dimator</span><span>|</span><a href="#42353020">prev</a><span>|</span><a href="#42352792">next</a><span>|</span><label class="collapse" for="c-42355502">[-]</label><label class="expand" for="c-42355502">[1 more]</label></div><br/><div class="children"><div class="content">I use it as a somewhat more sane way of collecting my repetitive, project specific commands, without having to rely on shell history.<p>I&#x27;ll just plop my project-specific workflows (series of shell commands) into a Justfile (that I don&#x27;t commit, it&#x27;s just for me). That allows me to be more rigorous and structured with how I&#x27;m iterating on a project.<p>It has syntax and semantics that are sufficiently saner than make, so I don&#x27;t need to know a lot to be productive.<p>If I come back to a project after a couple weeks, I don&#x27;t need to spelunk shell history. Just --list is enough to get back up to speed with how I was iterating.</div><br/></div></div><div id="42352792" class="c"><input type="checkbox" id="c-42352792" checked=""/><div class="controls bullet"><span class="by">petabyt</span><span>|</span><a href="#42355502">prev</a><span>|</span><a href="#42351424">next</a><span>|</span><label class="collapse" for="c-42352792">[-]</label><label class="expand" for="c-42352792">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used make for years, even partially wrote my own make interpreter once, I hate it as much as anybody else.
But I don&#x27;t feel confident investing in a new tool that has widespread industry adoption.
I wish there was a &#x27;better make&#x27; that tries to replace make the same way Zig wants to replace C, where they have great interop and make it easy to rewrite code into the new language.</div><br/><div id="42352852" class="c"><input type="checkbox" id="c-42352852" checked=""/><div class="controls bullet"><span class="by">dmead</span><span>|</span><a href="#42352792">parent</a><span>|</span><a href="#42351424">next</a><span>|</span><label class="collapse" for="c-42352852">[-]</label><label class="expand" for="c-42352852">[4 more]</label></div><br/><div class="children"><div class="content">There are a ton of better makes. It still didn&#x27;t matter.</div><br/><div id="42353927" class="c"><input type="checkbox" id="c-42353927" checked=""/><div class="controls bullet"><span class="by">enbugger</span><span>|</span><a href="#42352792">root</a><span>|</span><a href="#42352852">parent</a><span>|</span><a href="#42351424">next</a><span>|</span><label class="collapse" for="c-42353927">[-]</label><label class="expand" for="c-42353927">[3 more]</label></div><br/><div class="children"><div class="content">Any examples besides the subject?</div><br/><div id="42354730" class="c"><input type="checkbox" id="c-42354730" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#42352792">root</a><span>|</span><a href="#42353927">parent</a><span>|</span><a href="#42354692">next</a><span>|</span><label class="collapse" for="c-42354730">[-]</label><label class="expand" for="c-42354730">[1 more]</label></div><br/><div class="children"><div class="content">&quot;just&quot; is not a better make, it is, well, just a command runner.<p>Make is designed, well, to make stuff, it is a build system. But now, it is showing its age as a build system, and other, more advanced systems have taken over, these are the &quot;better make&quot; [1]. But it turns out that make is flexible and can be used for other things, namely running commands, and it has been rather popular for this. Problem is, make is still a build system at its core, and it has some quirks that make it less than ideal as a simple command runner, notably the &quot;.PHONY&quot; target. Just is like make, but it is explicitly not a build system, which allows it to do away with most of these quirks.<p>So is it a &quot;better make&quot;? As a build system, no, it is intentionally a &quot;worse make&quot;, but as &quot;just a command runner&quot;, then it is indeed a &quot;better make&quot;, and I am not aware of a similar project.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_build_automation_software" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_build_automation_softw...</a></div><br/></div></div><div id="42354692" class="c"><input type="checkbox" id="c-42354692" checked=""/><div class="controls bullet"><span class="by">ttyprintk</span><span>|</span><a href="#42352792">root</a><span>|</span><a href="#42353927">parent</a><span>|</span><a href="#42354730">prev</a><span>|</span><a href="#42351424">next</a><span>|</span><label class="collapse" for="c-42354692">[-]</label><label class="expand" for="c-42354692">[1 more]</label></div><br/><div class="children"><div class="content">I’m old enough that Solaris came with SVR4 make as an alternative. On Windows, Borland make and nmake come to mind.</div><br/></div></div></div></div></div></div></div></div><div id="42351424" class="c"><input type="checkbox" id="c-42351424" checked=""/><div class="controls bullet"><span class="by">no_circuit</span><span>|</span><a href="#42352792">prev</a><span>|</span><a href="#42352502">next</a><span>|</span><label class="collapse" for="c-42351424">[-]</label><label class="expand" for="c-42351424">[6 more]</label></div><br/><div class="children"><div class="content">Task is in a similar problem space.<p>Unlike Just which clearly states it is not a build system [1], Task can be told about expected files so tasks can be skipped to avoid unnecessary work [2]. So if your task is to build software, IMO make and the others like Task would be better.<p>If your tasks only care about the success code from a process, and&#x2F;or are a Rust fan instead of Go, then Just should be fine. Otherwise, for specific use-cases like CI, you are likely already coding in a proprietary YAML&#x2F;JSON&#x2F;XML format.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;casey&#x2F;just&#x2F;blob&#x2F;e1b85d9d0bc160c1ac8ca3bcadb2342ea37e8e9b&#x2F;README.md?plain=1#L47-L49">https:&#x2F;&#x2F;github.com&#x2F;casey&#x2F;just&#x2F;blob&#x2F;e1b85d9d0bc160c1ac8ca3bca...</a><p>[2] <a href="https:&#x2F;&#x2F;taskfile.dev&#x2F;usage&#x2F;#prevent-unnecessary-work" rel="nofollow">https:&#x2F;&#x2F;taskfile.dev&#x2F;usage&#x2F;#prevent-unnecessary-work</a></div><br/><div id="42351705" class="c"><input type="checkbox" id="c-42351705" checked=""/><div class="controls bullet"><span class="by">jensenbox</span><span>|</span><a href="#42351424">parent</a><span>|</span><a href="#42354041">next</a><span>|</span><label class="collapse" for="c-42351705">[-]</label><label class="expand" for="c-42351705">[1 more]</label></div><br/><div class="children"><div class="content">The one thing that converted us from Taskfile to Justfile is how it handle parameters injected at instantiation.<p><a href="https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;recipe-parameters.html" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;man&#x2F;en&#x2F;recipe-parameters.html</a> just works better for us than <a href="https:&#x2F;&#x2F;taskfile.dev&#x2F;usage&#x2F;#forwarding-cli-arguments-to-commands" rel="nofollow">https:&#x2F;&#x2F;taskfile.dev&#x2F;usage&#x2F;#forwarding-cli-arguments-to-comm...</a><p>We use Docker Compose for our dev environment and were trying to do something like (notice the extra dash dash for separating the arguments out):<p><pre><code>    task poetry -- add requests django
</code></pre>
It was not working as we expected for some of the users due to the argument dash dash stuff - they were forgetting due to muscle memory but the following does:<p><pre><code>    just poetry add requests django
</code></pre>
under the hood it was just calling (the equivalent):<p><pre><code>    docker compose run --rm --build poetry poetry &quot;$@&quot;
</code></pre>
Just arguments are more ergonomic.<p>This is how just does it:<p><pre><code>    poetry +command:

        docker compose run --rm --build poetry poetry {{command}}</code></pre></div><br/></div></div><div id="42354041" class="c"><input type="checkbox" id="c-42354041" checked=""/><div class="controls bullet"><span class="by">LinXitoW</span><span>|</span><a href="#42351424">parent</a><span>|</span><a href="#42351705">prev</a><span>|</span><a href="#42353730">next</a><span>|</span><label class="collapse" for="c-42354041">[-]</label><label class="expand" for="c-42354041">[1 more]</label></div><br/><div class="children"><div class="content">I unironically like the YAML format. It&#x27;s very readable, imho, and most people (at least in the web space) already know it. It&#x27;s better than the way just does attributes and descriptions.<p>On the other hand, what irks me is how parameters are fiddly to pass along. You have to define environment variables, instead of jusst passing them directly in the call.</div><br/></div></div><div id="42353730" class="c"><input type="checkbox" id="c-42353730" checked=""/><div class="controls bullet"><span class="by">trallnag</span><span>|</span><a href="#42351424">parent</a><span>|</span><a href="#42354041">prev</a><span>|</span><a href="#42352502">next</a><span>|</span><label class="collapse" for="c-42353730">[-]</label><label class="expand" for="c-42353730">[3 more]</label></div><br/><div class="children"><div class="content">Currently, every few months, I switch between Task and Just. Started with Task, went to Just, now I&#x27;m using Task again. Procrastination at its best</div><br/><div id="42353913" class="c"><input type="checkbox" id="c-42353913" checked=""/><div class="controls bullet"><span class="by">andreynering</span><span>|</span><a href="#42351424">root</a><span>|</span><a href="#42353730">parent</a><span>|</span><a href="#42352502">next</a><span>|</span><label class="collapse" for="c-42353913">[-]</label><label class="expand" for="c-42353913">[2 more]</label></div><br/><div class="children"><div class="content">Task creator here.<p>How do you evaluate each tool? What do you miss on each that keeps you switching between them?<p>I understand you, though. I keep switching between Firefox and Chrome-based browsers because each has its pros and cons...</div><br/><div id="42355166" class="c"><input type="checkbox" id="c-42355166" checked=""/><div class="controls bullet"><span class="by">hahn-kev</span><span>|</span><a href="#42351424">root</a><span>|</span><a href="#42353913">parent</a><span>|</span><a href="#42352502">next</a><span>|</span><label class="collapse" for="c-42355166">[-]</label><label class="expand" for="c-42355166">[1 more]</label></div><br/><div class="children"><div class="content">Passing parameters kinda sucks, someone else made a comparison in another thread about named parameters and how easy it is to pass and define them in Just. Love taskfile otherwise</div><br/></div></div></div></div></div></div></div></div><div id="42352502" class="c"><input type="checkbox" id="c-42352502" checked=""/><div class="controls bullet"><span class="by">drewbitt</span><span>|</span><a href="#42351424">prev</a><span>|</span><a href="#42352984">next</a><span>|</span><label class="collapse" for="c-42352502">[-]</label><label class="expand" for="c-42352502">[7 more]</label></div><br/><div class="children"><div class="content">I started writing my tasks in mise (<a href="https:&#x2F;&#x2F;mise.jdx.dev&#x2F;tasks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mise.jdx.dev&#x2F;tasks&#x2F;</a>) instead of just, but I found that others didn’t want to install it. Something about mise being an all-in-one tool—combining asdf&#x2F;direnv&#x2F;virtualenv&#x2F;global npm&#x2F;task management—made installing it just for the task feature off-putting. At least that&#x27;s my theory. So, I’m back to using just. I am happy that there isn&#x27;t a ton of pushback on adding a justfile here and there. Maybe it’s the name—‘just’ feels lightweight and is known to be fast, so people are cool with it.</div><br/><div id="42354161" class="c"><input type="checkbox" id="c-42354161" checked=""/><div class="controls bullet"><span class="by">jdxcode</span><span>|</span><a href="#42352502">parent</a><span>|</span><a href="#42352565">next</a><span>|</span><label class="collapse" for="c-42354161">[-]</label><label class="expand" for="c-42354161">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be surprised if you weren&#x27;t correct. Perhaps I could improve this a bit with the docs, but ultimately mise <i>is</i> complex and that will put people off no matter how good it is.<p>I think this is all fine though. I&#x27;m hard at work improving mise and will continue to do so for the foreseeable future. If someone is hesitant, I&#x27;d rather they wait a year until more kinks have been worked out, docs have been improved, feature gaps are closed, etc. I think this is especially true for tasks which only came out of experimental a few weeks ago.<p>Or people can just not use it. It&#x27;s not like this is a business where I make more money when I have more DAU or anything. I just want to build a good tool for building sake after all.</div><br/></div></div><div id="42352565" class="c"><input type="checkbox" id="c-42352565" checked=""/><div class="controls bullet"><span class="by">byproxy</span><span>|</span><a href="#42352502">parent</a><span>|</span><a href="#42354161">prev</a><span>|</span><a href="#42352984">next</a><span>|</span><label class="collapse" for="c-42352565">[-]</label><label class="expand" for="c-42352565">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m starting to use `mise` for tooling management and task running on greenfield projects, myself. Anything you feel `just` does better with regards to running tasks?</div><br/><div id="42353823" class="c"><input type="checkbox" id="c-42353823" checked=""/><div class="controls bullet"><span class="by">iKlsR</span><span>|</span><a href="#42352502">root</a><span>|</span><a href="#42352565">parent</a><span>|</span><a href="#42353634">next</a><span>|</span><label class="collapse" for="c-42353823">[-]</label><label class="expand" for="c-42353823">[1 more]</label></div><br/><div class="children"><div class="content">I was half tempted to make a toy runner called `use` when I first learned of `just` just so I could say... just use make.</div><br/></div></div><div id="42353634" class="c"><input type="checkbox" id="c-42353634" checked=""/><div class="controls bullet"><span class="by">jdxcode</span><span>|</span><a href="#42352502">root</a><span>|</span><a href="#42352565">parent</a><span>|</span><a href="#42353823">prev</a><span>|</span><a href="#42352984">next</a><span>|</span><label class="collapse" for="c-42353634">[-]</label><label class="expand" for="c-42353634">[3 more]</label></div><br/><div class="children"><div class="content">(author of mise)<p>The biggest advantage just has is that it&#x27;s been around longer, in mise tasks only came out of experimental like a month ago. mise tasks themselves are stable, but there are still experimental things and some portions that need to be used more—like windows. That said, most of the stuff that needs polish are features just doesn&#x27;t even have.<p>I had a look at the top issues for just and pretty much all of them I&#x27;ve handled in mise: <a href="https:&#x2F;&#x2F;github.com&#x2F;casey&#x2F;just&#x2F;issues?q=is%3Aissue+is%3Aopen+sort%3Areactions-%2B1-desc">https:&#x2F;&#x2F;github.com&#x2F;casey&#x2F;just&#x2F;issues?q=is%3Aissue+is%3Aopen+...</a><p>here&#x27;s my unashamedly biased thoughts on why I like mise tasks compared to just:<p>* tool integration - this is the obvious benefit. If you run `mise run test` on CI or wherever it&#x27;ll setup your toolchains and wire them up automatically<p>* parallel tasks - I saw this as table-stakes so it&#x27;s been there since the very beginning<p>* flags+options - mise tasks are integrated with usage (<a href="https:&#x2F;&#x2F;usage.jdx.dev" rel="nofollow">https:&#x2F;&#x2F;usage.jdx.dev</a>) which provides _very_ comprehensive CLI argument support. We&#x27;re talking way more than things like flags and default options, as an example, you can even have mise tasks give you custom completion support so you can complete `mise run server --app=&lt;tab&gt;&lt;tab&gt;`<p>* toml syntax - it&#x27;s more verbose, but I think it&#x27;s more obvious and easier to learn<p>* file sources&#x2F;outputs - I suspect just doesn&#x27;t want to implement this because it would make it more of a &quot;build tool&quot; and less of a &quot;task runner&quot;. I chose to despite having the same position that mise tasks is also not a &quot;build tool&quot;. Still, I think even in the world of running tasks you want to only run things if certain files changed often.<p>* `mise watch` - this is mostly just a simple wrapper around `watchexec -- mise run ...` for now, but it&#x27;s an area of the codebase I plan to focus on sometime in the next few months. Still, even as a simple wrapper it&#x27;s a nice convenience.<p>* &quot;file tasks&quot; - in mise you can define tasks just by being executable and in a directory like &quot;.&#x2F;tasks&quot;. This is great for complex scripts since you don&#x27;t also need to add them to mise.toml.<p>I have not used just very much, but I did go through the docs and there are a handful of things I like that it definitely does better:<p>* help customization - it looks like you can split tasks into separate sections which is nice, I don&#x27;t have that<p>* invoking multiple recipes - I don&#x27;t love how this is done in mise with `mise run task1 ::: task2` but I _also_ wanted to make it easy to pass arguments. At least for now, the &quot;:::&quot; won out in the design—but I don&#x27;t like it. Probably too late to change it anyhow.<p>* [no-cd] flag - both just and mise run tasks in the directory they&#x27;re defined, but I prefer how this is overridden in just vs mise.<p>* expression&#x2F;substitutions - mise uses tera for templating, which is very flexible, but it requires a bit more verbosity. I like that in just you can just use backticks or reference vars with minimal syntax. Same thing with things like joining paths and coalescing. I have all of this, but the syntax is definitely more verbose in mise. Arguably though, mise&#x27;s verbosity might be easier to read since it&#x27;s more obvious what you&#x27;re saying.<p>* confirmation - I love that in just you can just add `[confirm]` to get a confirmation dialog for the task. I&#x27;m sure we&#x27;ll get around to this at some point, mise already has confirmation dialogs so it shouldn&#x27;t be hard to add. The tricky part will be getting it to work right when running a bunch of stuff in parallel.<p>* task output - I haven&#x27;t used just that much so I can&#x27;t actually say that it&#x27;s &quot;better&quot;, but having more control over how tasks are output is definitely a weak part of mise right now and is in need of more functionality like in just how you can add&#x2F;remove &quot;@&quot; to echo out the command that&#x27;s running<p>I want to call out one very silly thing that from reading these github issues sounds crazy. It sounds like both just and taskfile have the same behavior with `.env` files. In just and taskfile, variables defined in .env are ignored if they&#x27;re already defined. I don&#x27;t think anyone would want that—nobody has asked for mise to behave that way—and it doesn&#x27;t appear either tool even allows you to change it!</div><br/><div id="42353753" class="c"><input type="checkbox" id="c-42353753" checked=""/><div class="controls bullet"><span class="by">gurgeous</span><span>|</span><a href="#42352502">root</a><span>|</span><a href="#42353634">parent</a><span>|</span><a href="#42352984">next</a><span>|</span><label class="collapse" for="c-42353753">[-]</label><label class="expand" for="c-42353753">[2 more]</label></div><br/><div class="children"><div class="content">Hi Jeff, thanks for creating mise! I am gearing up to migrate from asdf, very excited to check it out. Not totally sure we can adopt mise for tasks (we use just) but willing to give it a whirl. Putting run commands into toml sounds like it might be challenging, I wonder if there&#x27;s syntactic sugar that would help.</div><br/><div id="42354020" class="c"><input type="checkbox" id="c-42354020" checked=""/><div class="controls bullet"><span class="by">jdxcode</span><span>|</span><a href="#42352502">root</a><span>|</span><a href="#42353753">parent</a><span>|</span><a href="#42352984">next</a><span>|</span><label class="collapse" for="c-42354020">[-]</label><label class="expand" for="c-42354020">[1 more]</label></div><br/><div class="children"><div class="content">most people just put simple tasks into toml (like `npm run test` or something), for anything complex, file tasks are much better: <a href="https:&#x2F;&#x2F;mise.jdx.dev&#x2F;tasks&#x2F;file-tasks.html" rel="nofollow">https:&#x2F;&#x2F;mise.jdx.dev&#x2F;tasks&#x2F;file-tasks.html</a><p>file tasks are basically just a directory of bash (or whatever shebang) scripts, but special comments give them extra functionality like dependencies or defining flags&#x2F;options.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42352984" class="c"><input type="checkbox" id="c-42352984" checked=""/><div class="controls bullet"><span class="by">nrclark</span><span>|</span><a href="#42352502">prev</a><span>|</span><a href="#42353021">next</a><span>|</span><label class="collapse" for="c-42352984">[-]</label><label class="expand" for="c-42352984">[3 more]</label></div><br/><div class="children"><div class="content">From my perspective, Just would be more useful if it had some ability to skip steps where the input hasn&#x27;t changed.<p>Like maybe a Justfile&#x27;s recipe could produce a &quot;&lt;task&gt;.complete&quot; kind of file, and could decide whether to re-run the task based on whether the task&#x27;s inputs (or its dependencies&#x27; inputs).<p>Also if that sounds like a useful feature, consider using Make.</div><br/><div id="42353205" class="c"><input type="checkbox" id="c-42353205" checked=""/><div class="controls bullet"><span class="by">hobofan</span><span>|</span><a href="#42352984">parent</a><span>|</span><a href="#42353078">next</a><span>|</span><label class="collapse" for="c-42353205">[-]</label><label class="expand" for="c-42353205">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also if that sounds like a useful feature, consider using Make<p>Just not having that feature is _the_ defining difference in design between the two. If just were to ever add that it would likely kill its appeal. Not having that is what keeps the logic of a just invocation simple and what keeps Justfiles from devolving into the mess that Makefiles tend to with entangled build targets.</div><br/></div></div><div id="42353078" class="c"><input type="checkbox" id="c-42353078" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#42352984">parent</a><span>|</span><a href="#42353205">prev</a><span>|</span><a href="#42353021">next</a><span>|</span><label class="collapse" for="c-42353078">[-]</label><label class="expand" for="c-42353078">[1 more]</label></div><br/><div class="children"><div class="content">Make solves that problem. The problem that I have is that all of the tools I use day to day do their own dependency tracking and re-run tracking. Say I want to deploy a dotnet app to a k8s cluster - none of helm, docker, dotnet build, dotnet test expose their dependency tracking in a way that is straightforward to use with make. The most straightforward way to do it is to just run the commands anyway, IME.</div><br/></div></div></div></div><div id="42353021" class="c"><input type="checkbox" id="c-42353021" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#42352984">prev</a><span>|</span><a href="#42351404">next</a><span>|</span><label class="collapse" for="c-42353021">[-]</label><label class="expand" for="c-42353021">[1 more]</label></div><br/><div class="children"><div class="content">One reward you get for allowing yourself to become brainwashed by Bazel is you get a pretty nice task runner in every project that you&#x27;ve brought into the fold.</div><br/></div></div><div id="42351404" class="c"><input type="checkbox" id="c-42351404" checked=""/><div class="controls bullet"><span class="by">throwaway743950</span><span>|</span><a href="#42353021">prev</a><span>|</span><a href="#42353354">next</a><span>|</span><label class="collapse" for="c-42351404">[-]</label><label class="expand" for="c-42351404">[1 more]</label></div><br/><div class="children"><div class="content">I recently looked at various alternatives to make and landed on <a href="https:&#x2F;&#x2F;taskfile.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;taskfile.dev&#x2F;</a><p>It handles dependencies and conditions well without needing to be a full blown bash expert.</div><br/></div></div><div id="42353354" class="c"><input type="checkbox" id="c-42353354" checked=""/><div class="controls bullet"><span class="by">PhilippGille</span><span>|</span><a href="#42351404">prev</a><span>|</span><a href="#42354597">next</a><span>|</span><label class="collapse" for="c-42353354">[-]</label><label class="expand" for="c-42353354">[1 more]</label></div><br/><div class="children"><div class="content">Several comments mention Task&#x2F;Taskfile already, which is very similar in that you define tasks in YAML.<p>I think it&#x27;s worth mentioning Mage&#x2F;Magefile [1][2] as well, where your tasks are actual Go code. Similar to how Rake is for tasks in Ruby code.<p>It&#x27;s useful when you have complex tasks.<p>It&#x27;s like using Pulumi instead of Terraform.<p>[1] <a href="https:&#x2F;&#x2F;magefile.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;magefile.org&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;magefile&#x2F;mage">https:&#x2F;&#x2F;github.com&#x2F;magefile&#x2F;mage</a></div><br/></div></div><div id="42354597" class="c"><input type="checkbox" id="c-42354597" checked=""/><div class="controls bullet"><span class="by">csomar</span><span>|</span><a href="#42353354">prev</a><span>|</span><a href="#42351460">next</a><span>|</span><label class="collapse" for="c-42354597">[-]</label><label class="expand" for="c-42354597">[2 more]</label></div><br/><div class="children"><div class="content">I used this until AI became good enough. Now, for most purpose, I can just declare what I want to be done&#x2F;executed and get perfect bash for it. I have a relatively complex Makefile that build graphql schemas and sets them up. It&#x27;d have been a no-go given how weird bash syntax is; but now I can get it generated and working from pretty much the first try.<p>There is lots of bash around and it&#x27;s a very simple language, so AI models are pretty good at it.</div><br/><div id="42354678" class="c"><input type="checkbox" id="c-42354678" checked=""/><div class="controls bullet"><span class="by">mikojan</span><span>|</span><a href="#42354597">parent</a><span>|</span><a href="#42351460">next</a><span>|</span><label class="collapse" for="c-42354678">[-]</label><label class="expand" for="c-42354678">[1 more]</label></div><br/><div class="children"><div class="content">What does that mean? You have a huge LLM generated bash script instead of a human-readable makefile? I do not understand.</div><br/></div></div></div></div><div id="42351460" class="c"><input type="checkbox" id="c-42351460" checked=""/><div class="controls bullet"><span class="by">brokegrammer</span><span>|</span><a href="#42354597">prev</a><span>|</span><a href="#42355040">next</a><span>|</span><label class="collapse" for="c-42351460">[-]</label><label class="expand" for="c-42351460">[1 more]</label></div><br/><div class="children"><div class="content">I switched from make a while ago because I was using it to run tasks in my Python projects, which doesn&#x27;t require any of make&#x27;s build tools.<p>I didn&#x27;t like make&#x27;s complicated syntax either. Everything just makes more sense now.</div><br/></div></div><div id="42355040" class="c"><input type="checkbox" id="c-42355040" checked=""/><div class="controls bullet"><span class="by">WuxiFingerHold</span><span>|</span><a href="#42351460">prev</a><span>|</span><a href="#42351923">next</a><span>|</span><label class="collapse" for="c-42355040">[-]</label><label class="expand" for="c-42355040">[1 more]</label></div><br/><div class="children"><div class="content">I find it more powerful and from a certain point easier to create the tooling using the projects programming language. Every dev should be familiar with that language and ecosystem. E.g. for project that had several tools - Rust (server), .NET and Node (CLI tools) and Svelte (frontend) - I wrote <i>all</i> operational tools in Typescript and run them using Deno. Very clean and powerful (typesafe, composable, Deno std lib). You can add all kind of stuff like timings, logging, checks, whatever ...</div><br/></div></div><div id="42351923" class="c"><input type="checkbox" id="c-42351923" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42355040">prev</a><span>|</span><a href="#42352724">next</a><span>|</span><label class="collapse" for="c-42351923">[-]</label><label class="expand" for="c-42351923">[29 more]</label></div><br/><div class="children"><div class="content">I love `just` and have adopted it universally in all my projects. For what it does, it gets the job done fantastically.<p>That being said, I found myself needing a tool that builds a DAG of dependent tasks and automatically figures out what can be ran in parallel and what cannot -- obviously you have to spell out all tasks and who depends on what first.<p>Anybody knows such a tool?<p>EDIT: Apparently people did not get the hint that I believe `make` is an over-engineered pile of metric tons of legacy and I&#x27;ll sooner slash my wrists than to learn it in full.<p>I did mean something ergonomic and easy to read and write. And no I&#x27;ll never view `make` as such. I tried. Many times. I have better things to do in my life than to memorize exceptions of the exceptions.</div><br/><div id="42352049" class="c"><input type="checkbox" id="c-42352049" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#42351923">parent</a><span>|</span><a href="#42351976">next</a><span>|</span><label class="collapse" for="c-42352049">[-]</label><label class="expand" for="c-42352049">[2 more]</label></div><br/><div class="children"><div class="content">I’ve not tried it but this popped up on here a while back and sound like it might fit the bill.<p><a href="https:&#x2F;&#x2F;taskfile.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;taskfile.dev&#x2F;</a></div><br/><div id="42352072" class="c"><input type="checkbox" id="c-42352072" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352049">parent</a><span>|</span><a href="#42351976">next</a><span>|</span><label class="collapse" for="c-42352072">[-]</label><label class="expand" for="c-42352072">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, this one has been in my radar for a while, I&#x27;ll absolutely get to it at one point.</div><br/></div></div></div></div><div id="42351976" class="c"><input type="checkbox" id="c-42351976" checked=""/><div class="controls bullet"><span class="by">bfLives</span><span>|</span><a href="#42351923">parent</a><span>|</span><a href="#42352049">prev</a><span>|</span><a href="#42352071">next</a><span>|</span><label class="collapse" for="c-42351976">[-]</label><label class="expand" for="c-42351976">[3 more]</label></div><br/><div class="children"><div class="content">I think this is exactly the intended use case for Ninja. It’s discussed in this recently posted article.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42268310">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42268310</a></div><br/><div id="42351992" class="c"><input type="checkbox" id="c-42351992" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42351976">parent</a><span>|</span><a href="#42352071">next</a><span>|</span><label class="collapse" for="c-42351992">[-]</label><label class="expand" for="c-42351992">[2 more]</label></div><br/><div class="children"><div class="content">Thanks. That article is fairly disappointing for not having even one simple example file though...</div><br/><div id="42354914" class="c"><input type="checkbox" id="c-42354914" checked=""/><div class="controls bullet"><span class="by">tjalfi</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42351992">parent</a><span>|</span><a href="#42352071">next</a><span>|</span><label class="collapse" for="c-42354914">[-]</label><label class="expand" for="c-42354914">[1 more]</label></div><br/><div class="children"><div class="content">Julia Evans has a Ninja introduction[0] with simple examples.
 I tried it for awhile, but ended up going back to GNU Make.<p>[0] <a href="https:&#x2F;&#x2F;jvns.ca&#x2F;blog&#x2F;2020&#x2F;10&#x2F;26&#x2F;ninja--a-simple-way-to-do-builds&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jvns.ca&#x2F;blog&#x2F;2020&#x2F;10&#x2F;26&#x2F;ninja--a-simple-way-to-do-bu...</a></div><br/></div></div></div></div></div></div><div id="42352071" class="c"><input type="checkbox" id="c-42352071" checked=""/><div class="controls bullet"><span class="by">j6m8</span><span>|</span><a href="#42351923">parent</a><span>|</span><a href="#42351976">prev</a><span>|</span><a href="#42351960">next</a><span>|</span><label class="collapse" for="c-42352071">[-]</label><label class="expand" for="c-42352071">[9 more]</label></div><br/><div class="children"><div class="content">I wrote frof [1] for exactly this purpose :)<p>Designed to be ultra-simple and with minimal &quot;config-file acrobatics&quot;.<p>It looks like this [edit, formatting]:<p><pre><code>    write -&gt; analyze
    build -&gt; analyze

    write:     echo 1 2 3 &gt; data.txt
    build:     compile_tool.sh &gt; tool.sh
    analyze:   tool.sh data.txt
</code></pre>
<a href="https:&#x2F;&#x2F;github.com&#x2F;j6k4m8&#x2F;frof&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;j6k4m8&#x2F;frof&#x2F;</a></div><br/><div id="42352088" class="c"><input type="checkbox" id="c-42352088" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352071">parent</a><span>|</span><a href="#42351960">next</a><span>|</span><label class="collapse" for="c-42352088">[-]</label><label class="expand" for="c-42352088">[8 more]</label></div><br/><div class="children"><div class="content">Can you explain that one a little bit more to me, please?<p>I don&#x27;t get the first two lines of your example well. They seem to show the dependency but which one is the default task, or how do you ask for a task to be ran?</div><br/><div id="42352118" class="c"><input type="checkbox" id="c-42352118" checked=""/><div class="controls bullet"><span class="by">j6m8</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352088">parent</a><span>|</span><a href="#42351960">next</a><span>|</span><label class="collapse" for="c-42352118">[-]</label><label class="expand" for="c-42352118">[7 more]</label></div><br/><div class="children"><div class="content">You write the file and ALL steps are run in topological order so that a job never runs until its dependencies have run. i.e., in a tool I&#x27;ll have `build.frof` as a separate frof file than `download-dependencies.frof`, perhaps. (If your preference is that those belong in the same file I&#x27;d be down to have PRs that support that! Should be very easy, I&#x27;m happy to try implementing this if there&#x27;s interest.)<p>So for a file with those contents called `mygraph.frof`, you can (after installing) run `frof mygraph.frof` to kick off the jobs in the current shell (inheriting env vars etc).<p>[edit] maybe a clarifying example here:
<a href="https:&#x2F;&#x2F;blog.jordan.matelsky.com&#x2F;frof-render&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.jordan.matelsky.com&#x2F;frof-render&#x2F;</a></div><br/><div id="42352148" class="c"><input type="checkbox" id="c-42352148" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352118">parent</a><span>|</span><a href="#42351960">next</a><span>|</span><label class="collapse" for="c-42352148">[-]</label><label class="expand" for="c-42352148">[6 more]</label></div><br/><div class="children"><div class="content">OK, so for the example in your comment upthread both `write` and `build` will be executed sequentially?</div><br/><div id="42352434" class="c"><input type="checkbox" id="c-42352434" checked=""/><div class="controls bullet"><span class="by">j6m8</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352148">parent</a><span>|</span><a href="#42351960">next</a><span>|</span><label class="collapse" for="c-42352434">[-]</label><label class="expand" for="c-42352434">[5 more]</label></div><br/><div class="children"><div class="content">here they&#x27;ll probably be executed simultaneously, since they both have zero dependencies and the machine can run multiple jobs at the same time. (can be disabled with `--max_jobs=1` or `-p=1`).<p>Here&#x27;s another illustrative example:<p><pre><code>    A -&gt; B
    B -&gt; C
    Z -&gt; C
</code></pre>
In this situation, frof will schedule `Z` to run in a parallel thread ASAP, so it will likely run alongside A... and if Z takes longer to run than A, Z will continue running when A stops and B starts. But C will wait for all other jobs to finish before it can schedule.</div><br/><div id="42352497" class="c"><input type="checkbox" id="c-42352497" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352434">parent</a><span>|</span><a href="#42351960">next</a><span>|</span><label class="collapse" for="c-42352497">[-]</label><label class="expand" for="c-42352497">[4 more]</label></div><br/><div class="children"><div class="content">Nice, thanks a lot. Unfortunately I am quite swamped recently so I will definitely cannot help you with feature requests and testing but I have bookmarked frof and absolutely will be giving it a try.<p>Just one thing I would dislike... Python. How easy it is to run frof without having to fiddle with venvs and such?</div><br/><div id="42352667" class="c"><input type="checkbox" id="c-42352667" checked=""/><div class="controls bullet"><span class="by">j6m8</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352497">parent</a><span>|</span><a href="#42351960">next</a><span>|</span><label class="collapse" for="c-42352667">[-]</label><label class="expand" for="c-42352667">[3 more]</label></div><br/><div class="children"><div class="content">no worries, good to know this would be a useful feature! I&#x27;ll add it to my backlog.<p><pre><code>    pip install &#x27;git+https:&#x2F;&#x2F;github.com&#x2F;j6k4m8&#x2F;frof&#x2F;&#x27;

</code></pre>
and then<p><pre><code>    frof myfile.frof
</code></pre>
should work!<p>Was thinking about rewriting it in Go recently... :)</div><br/><div id="42353426" class="c"><input type="checkbox" id="c-42353426" checked=""/><div class="controls bullet"><span class="by">burnished</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352667">parent</a><span>|</span><a href="#42352680">next</a><span>|</span><label class="collapse" for="c-42353426">[-]</label><label class="expand" for="c-42353426">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found prototyping in python followed by a rewrite in Go quite pleasant, would recommend</div><br/></div></div><div id="42352680" class="c"><input type="checkbox" id="c-42352680" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352667">parent</a><span>|</span><a href="#42353426">prev</a><span>|</span><a href="#42351960">next</a><span>|</span><label class="collapse" for="c-42352680">[-]</label><label class="expand" for="c-42352680">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll try the vanilla Python route but knowing our mutual hatred, it&#x27;ll crap the bed in 0.5s. :D We&#x27;ll see.<p>&gt; <i>Was thinking about rewriting it in Go recently... :)</i><p>And then I might actually contribute. :)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42351960" class="c"><input type="checkbox" id="c-42351960" checked=""/><div class="controls bullet"><span class="by">diggan</span><span>|</span><a href="#42351923">parent</a><span>|</span><a href="#42352071">prev</a><span>|</span><a href="#42351932">next</a><span>|</span><label class="collapse" for="c-42351960">[-]</label><label class="expand" for="c-42351960">[4 more]</label></div><br/><div class="children"><div class="content">Besides Make, I guess Bazel kind of fits the bill? It was very &quot;Googly&quot; last time I checked it out, but I think that was a decade ago and right when it was released, so it might be more fitting for not-Google nowadays.</div><br/><div id="42352106" class="c"><input type="checkbox" id="c-42352106" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42351960">parent</a><span>|</span><a href="#42351932">next</a><span>|</span><label class="collapse" for="c-42352106">[-]</label><label class="expand" for="c-42352106">[3 more]</label></div><br/><div class="children"><div class="content">I never looked at it but seen some fairly negative reviews here on HN. Any idea why? And why do you like it?</div><br/><div id="42354530" class="c"><input type="checkbox" id="c-42354530" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352106">parent</a><span>|</span><a href="#42351932">next</a><span>|</span><label class="collapse" for="c-42354530">[-]</label><label class="expand" for="c-42354530">[2 more]</label></div><br/><div class="children"><div class="content">Imagine that instead of a make target listing its dependencies, you had to pull them out into a separately maintained BUILD file.<p>That’s not quite true, but it feels like it sometimes. Bazel is nice about seeing exactly what you need to rebuild if you touch a file. It’s very, very complex though.<p>In code terms, think of it as a framework that you have to embed your project into, not a Makefile or such that you’d drop into a project. That doesn’t make it bad and it has its niceties. You’ve gotta be prepared to pay for them with sweat equity.</div><br/><div id="42355301" class="c"><input type="checkbox" id="c-42355301" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42354530">parent</a><span>|</span><a href="#42351932">next</a><span>|</span><label class="collapse" for="c-42355301">[-]</label><label class="expand" for="c-42355301">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. I heard similar sentiments RE: complexity and that&#x27;s usually enough to turn me off of a tool.</div><br/></div></div></div></div></div></div></div></div><div id="42351932" class="c"><input type="checkbox" id="c-42351932" checked=""/><div class="controls bullet"><span class="by">guipsp</span><span>|</span><a href="#42351923">parent</a><span>|</span><a href="#42351960">prev</a><span>|</span><a href="#42351949">next</a><span>|</span><label class="collapse" for="c-42351932">[-]</label><label class="expand" for="c-42351932">[7 more]</label></div><br/><div class="children"><div class="content">Make?</div><br/><div id="42351964" class="c"><input type="checkbox" id="c-42351964" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42351932">parent</a><span>|</span><a href="#42351949">next</a><span>|</span><label class="collapse" for="c-42351964">[-]</label><label class="expand" for="c-42351964">[6 more]</label></div><br/><div class="children"><div class="content">Come on, be serious. If I wanted ancient sh-isms and bash-isms I would have learned make to 100% some 15 years ago.<p>I meant something ergonomic and easy to read and write.</div><br/><div id="42352040" class="c"><input type="checkbox" id="c-42352040" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42351964">parent</a><span>|</span><a href="#42352025">next</a><span>|</span><label class="collapse" for="c-42352040">[-]</label><label class="expand" for="c-42352040">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If I wanted ancient sh-isms and bash-isms<p>So don&#x27;t, set make&#x27;s shell to something else instead.  It doesn&#x27;t understand the recipes, it just dumps them to a file and runs $(SHELL) on them.<p>For a more extreme example, just to show what&#x27;s possible:<p><pre><code>   SHELL := python3
   
   .ONESHELL:
   
   foo.csv:
    import csv
    with open(&quot;$@&quot;, &quot;w&quot;) as f:
        writer = csv.writer(f)
        writer.writerows([
            [&#x27;Test1&#x27;, &#x27;Test2&#x27;],
            [&#x27;Test3&#x27;, &#x27;Test4&#x27;],
        ])</code></pre></div><br/><div id="42352642" class="c"><input type="checkbox" id="c-42352642" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352040">parent</a><span>|</span><a href="#42352065">next</a><span>|</span><label class="collapse" for="c-42352642">[-]</label><label class="expand" for="c-42352642">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m this years old when my life was revolutionized.</div><br/></div></div><div id="42352065" class="c"><input type="checkbox" id="c-42352065" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352040">parent</a><span>|</span><a href="#42352642">prev</a><span>|</span><a href="#42352025">next</a><span>|</span><label class="collapse" for="c-42352065">[-]</label><label class="expand" for="c-42352065">[1 more]</label></div><br/><div class="children"><div class="content">Not a bad idea, thanks. I did this a few times as well but when I analyzed the ROI I figured that just writing a simple-ish Golang program is just less confusing and more consistent in its totality when you ask yourself &quot;do I really have to use Make and Python and, and, and...?&quot;.<p>So yeah, thanks for bringing visibility to this pretty decent compromising approach. It worked for me for a while but eventually I just went all-in to either use `just`, some _very_ short bash&#x2F;zsh scripts, or jump all the way to Golang.</div><br/></div></div></div></div><div id="42352025" class="c"><input type="checkbox" id="c-42352025" checked=""/><div class="controls bullet"><span class="by">ofrzeta</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42351964">parent</a><span>|</span><a href="#42352040">prev</a><span>|</span><a href="#42351949">next</a><span>|</span><label class="collapse" for="c-42352025">[-]</label><label class="expand" for="c-42352025">[2 more]</label></div><br/><div class="children"><div class="content">They are right, though, aren&#x27;t they? I mean .. if you want something &quot;modern&quot;, go ahead and learn Bazel. Make is quite a bit easier to learn, I&#x27;d say, and you don&#x27;t need much (also no shell&#x2F;bash) to express your DAG dependencies.</div><br/><div id="42352052" class="c"><input type="checkbox" id="c-42352052" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352025">parent</a><span>|</span><a href="#42351949">next</a><span>|</span><label class="collapse" for="c-42352052">[-]</label><label class="expand" for="c-42352052">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll agree on the DAG bit but I&#x27;ll never use `make` again and I tried for no less than 10 years (on and off, not 24&#x2F;7, otherwise I would have learned it long ago indeed).<p>I stay away from `make` almost religiously. Its complications _always_ find a way to creep into your file one day. Always. :(<p>So while they are technically correct and it&#x27;s my fault for not saying I don&#x27;t want `make` in the comment up-thread, I don&#x27;t think my comment deserved the down arrows but oh well, I&#x27;ll live through it.</div><br/></div></div></div></div></div></div></div></div><div id="42351949" class="c"><input type="checkbox" id="c-42351949" checked=""/><div class="controls bullet"><span class="by">plmpsu</span><span>|</span><a href="#42351923">parent</a><span>|</span><a href="#42351932">prev</a><span>|</span><a href="#42352776">next</a><span>|</span><label class="collapse" for="c-42351949">[-]</label><label class="expand" for="c-42351949">[1 more]</label></div><br/><div class="children"><div class="content">Maven, Gradle, etc.</div><br/></div></div><div id="42352776" class="c"><input type="checkbox" id="c-42352776" checked=""/><div class="controls bullet"><span class="by">matja</span><span>|</span><a href="#42351923">parent</a><span>|</span><a href="#42351949">prev</a><span>|</span><a href="#42352724">next</a><span>|</span><label class="collapse" for="c-42352776">[-]</label><label class="expand" for="c-42352776">[2 more]</label></div><br/><div class="children"><div class="content">FYI to some people trivializing self-harm in a technical discussion is rather tasteless.</div><br/><div id="42352791" class="c"><input type="checkbox" id="c-42352791" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42351923">root</a><span>|</span><a href="#42352776">parent</a><span>|</span><a href="#42352724">next</a><span>|</span><label class="collapse" for="c-42352791">[-]</label><label class="expand" for="c-42352791">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an exaggeration to illustrate a point. Still, thanks for bringing in the perspective.</div><br/></div></div></div></div></div></div><div id="42352724" class="c"><input type="checkbox" id="c-42352724" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#42351923">prev</a><span>|</span><a href="#42352848">next</a><span>|</span><label class="collapse" for="c-42352724">[-]</label><label class="expand" for="c-42352724">[1 more]</label></div><br/><div class="children"><div class="content">I already have a command runner, it&#x27;s called a shell.<p>Apparently just also needs one to run.</div><br/></div></div><div id="42352848" class="c"><input type="checkbox" id="c-42352848" checked=""/><div class="controls bullet"><span class="by">silasdavis</span><span>|</span><a href="#42352724">prev</a><span>|</span><a href="#42351537">next</a><span>|</span><label class="collapse" for="c-42352848">[-]</label><label class="expand" for="c-42352848">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m Stockholm syndrome with make at this point. I&#x27;m not sure I&#x27;d want it any other way.</div><br/></div></div><div id="42351537" class="c"><input type="checkbox" id="c-42351537" checked=""/><div class="controls bullet"><span class="by">Astronaut3315</span><span>|</span><a href="#42352848">prev</a><span>|</span><a href="#42354842">next</a><span>|</span><label class="collapse" for="c-42351537">[-]</label><label class="expand" for="c-42351537">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been happy with Just at our workplace. It lets me focus more on the task at hand instead of Conan &#x2F; Cmake incantations.<p>It’s consistent, easy to use and maintain, and keeps all relevant operations in one place.</div><br/></div></div><div id="42354842" class="c"><input type="checkbox" id="c-42354842" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42351537">prev</a><span>|</span><a href="#42354408">next</a><span>|</span><label class="collapse" for="c-42354842">[-]</label><label class="expand" for="c-42354842">[1 more]</label></div><br/><div class="children"><div class="content">My favorite entry in this space is Argc. I like it because the only “new syntax” it introduces is metadata comments, and the rest is pure bash. The maintainer is also best-in-class in terms of responsiveness.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;sigoden&#x2F;argc">https:&#x2F;&#x2F;github.com&#x2F;sigoden&#x2F;argc</a></div><br/></div></div><div id="42354408" class="c"><input type="checkbox" id="c-42354408" checked=""/><div class="controls bullet"><span class="by">dr_kretyn</span><span>|</span><a href="#42354842">prev</a><span>|</span><a href="#42351421">next</a><span>|</span><label class="collapse" for="c-42354408">[-]</label><label class="expand" for="c-42354408">[1 more]</label></div><br/><div class="children"><div class="content">Seems that I&#x27;m the only one who opened up the website and didn&#x27;t know what was going on. At least two sentences what the &quot;just&quot; is, otherwise it&#x27;s &quot;if you, you know&quot; and that isn&#x27;t inviting page.</div><br/></div></div><div id="42351421" class="c"><input type="checkbox" id="c-42351421" checked=""/><div class="controls bullet"><span class="by">majkinetor</span><span>|</span><a href="#42354408">prev</a><span>|</span><a href="#42354212">next</a><span>|</span><label class="collapse" for="c-42351421">[-]</label><label class="expand" for="c-42351421">[1 more]</label></div><br/><div class="children"><div class="content">I use Invoke-Build[1] everywhere and I highly recommend it. It&#x27;s cross-platform, uses PowerShell so we have serious programming language in the background and is extremely simple yet powerful: dependencies, integrated help, good defaults for error handling and starting directory, vs code support, DOT charts of task dependencies, incremental task, persistent builds, parallel stuff etc. See example usage here [2]<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;nightroman&#x2F;Invoke-Build">https:&#x2F;&#x2F;github.com&#x2F;nightroman&#x2F;Invoke-Build</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;majkinetor&#x2F;mm-docs">https:&#x2F;&#x2F;github.com&#x2F;majkinetor&#x2F;mm-docs</a></div><br/></div></div><div id="42354212" class="c"><input type="checkbox" id="c-42354212" checked=""/><div class="controls bullet"><span class="by">jdxcode</span><span>|</span><a href="#42351421">prev</a><span>|</span><a href="#42352884">next</a><span>|</span><label class="collapse" for="c-42354212">[-]</label><label class="expand" for="c-42354212">[3 more]</label></div><br/><div class="children"><div class="content">no flags, no parallel tasks, no skipping tasks unless files change, no watching for changes<p>come see a modern task manager: <a href="https:&#x2F;&#x2F;mise.jdx.dev&#x2F;tasks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mise.jdx.dev&#x2F;tasks&#x2F;</a></div><br/><div id="42354227" class="c"><input type="checkbox" id="c-42354227" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#42354212">parent</a><span>|</span><a href="#42352884">next</a><span>|</span><label class="collapse" for="c-42354227">[-]</label><label class="expand" for="c-42354227">[2 more]</label></div><br/><div class="children"><div class="content">This looks cool, but why not have vars in .env files?</div><br/><div id="42354244" class="c"><input type="checkbox" id="c-42354244" checked=""/><div class="controls bullet"><span class="by">jdxcode</span><span>|</span><a href="#42354212">root</a><span>|</span><a href="#42354227">parent</a><span>|</span><a href="#42352884">next</a><span>|</span><label class="collapse" for="c-42354244">[-]</label><label class="expand" for="c-42354244">[1 more]</label></div><br/><div class="children"><div class="content">you can do that too: <a href="https:&#x2F;&#x2F;mise.jdx.dev&#x2F;environments.html#env-file" rel="nofollow">https:&#x2F;&#x2F;mise.jdx.dev&#x2F;environments.html#env-file</a><p>but sometimes you don&#x27;t want to make it an env var—just supports this too through the `export` keyword</div><br/></div></div></div></div></div></div><div id="42352884" class="c"><input type="checkbox" id="c-42352884" checked=""/><div class="controls bullet"><span class="by">olvrng</span><span>|</span><a href="#42354212">prev</a><span>|</span><label class="collapse" for="c-42352884">[-]</label><label class="expand" for="c-42352884">[2 more]</label></div><br/><div class="children"><div class="content">My favorite command runner setup is just a simple bash script and .envrc<p>I can put my commands in a run file, which source a simple bash script, and use it like:<p><pre><code>    run do-foo
    run build-bar
</code></pre>
You can even `run help` to list all available commands.<p>The setup is explained here:
<a href="https:&#x2F;&#x2F;olivernguyen.io&#x2F;w&#x2F;direnv.run&#x2F;" rel="nofollow">https:&#x2F;&#x2F;olivernguyen.io&#x2F;w&#x2F;direnv.run&#x2F;</a></div><br/><div id="42352914" class="c"><input type="checkbox" id="c-42352914" checked=""/><div class="controls bullet"><span class="by">olvrng</span><span>|</span><a href="#42352884">parent</a><span>|</span><label class="collapse" for="c-42352914">[-]</label><label class="expand" for="c-42352914">[1 more]</label></div><br/><div class="children"><div class="content">Create a bash script `run`:<p><pre><code>    #!&#x2F;bin&#x2F;bash
    set -eo pipefail

    run-hello() {
        echo &quot;Hello, World!&quot;
    }

    # -------- this is the magic ------- #
    source &quot;scripts&#x2F;_cli.sh&quot;
    </code></pre>
And source a simple script `_cli.sh`:<p><pre><code>    #!&#x2F;bin&#x2F;bash
    set -eo pipefail

    show-help(){
        items=()
        while IFS=&#x27;&#x27; read -r line; do items+=(&quot;$line&quot;); done &lt; \
            &lt;(compgen -A &quot;function&quot; | grep &quot;run-&quot; | sed &quot;s&#x2F;run-&#x2F;&#x2F;&quot;)
        printf -v items &quot;\t%s\n&quot; &quot;${items[@]}&quot;

        usage=&quot;USAGE: $(basename &quot;$0&quot;) CMD [ARGUMENTS]
      CMD:\n$items&quot;
        printf &quot;$usage&quot;
    }

    name=$1
    case &quot;$name&quot; in
        &quot;&quot; | &quot;-h&quot; | &quot;--help&quot; | &quot;help&quot;)
            show-help
            ;;
        *)
            shift
            if compgen -A &quot;function&quot; | grep &quot;run-$name&quot; &gt;&#x2F;dev&#x2F;null ; then
                run-&quot;${name}&quot; &quot;$@&quot;
            else
                echo &quot;ERROR: run-$name not found.&quot;
                exit 123
            fi
            ;;
    esac</code></pre></div><br/></div></div></div></div></div></div></div></div></div></body></html>