<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716973278411" as="style"/><link rel="stylesheet" href="styles.css?v=1716973278411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://db.in.tum.de/~ellmann/theses/finished/24/pirhonen_writing_an_nvme_driver_in_rust.pdf">Writing an NVMe Driver in Rust [pdf]</a> <span class="domain">(<a href="https://db.in.tum.de">db.in.tum.de</a>)</span></div><div class="subtext"><span>foooo4</span> | <span>18 comments</span></div><br/><div><div id="40508426" class="c"><input type="checkbox" id="c-40508426" checked=""/><div class="controls bullet"><span class="by">bengl3rt</span><span>|</span><a href="#40508367">next</a><span>|</span><label class="collapse" for="c-40508426">[-]</label><label class="expand" for="c-40508426">[6 more]</label></div><br/><div class="children"><div class="content">I only read the paper (and the code in the paper) but not the complete source code, so maybe this would become clearer if I had, but...<p>Does Rust fundamentally guarantee that if you make a struct, its fields will lay out in memory in the order that you defined them? Can it be used to interact with APIs (really ABIs) who expect a C struct (or pointer to one)?<p>I think my main frustration with stuff like Go and Swift in this case is that their structs are not binary-compatible with C structs in this way because they rearrange things to be better aligned&#x2F;packed&#x2F;whatever.</div><br/><div id="40508478" class="c"><input type="checkbox" id="c-40508478" checked=""/><div class="controls bullet"><span class="by">pitterpatter</span><span>|</span><a href="#40508426">parent</a><span>|</span><a href="#40509379">next</a><span>|</span><label class="collapse" for="c-40508478">[-]</label><label class="expand" for="c-40508478">[1 more]</label></div><br/><div class="children"><div class="content">Yes, Rust supports annotating your types with a `#[repr(...)]` attribute to control how it gets laid out in memory. There&#x27;s a &quot;C&quot; repr that gives you representations interoperable with C.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;type-layout.html#the-c-representation" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;type-layout.html#the-c-r...</a></div><br/></div></div><div id="40509379" class="c"><input type="checkbox" id="c-40509379" checked=""/><div class="controls bullet"><span class="by">thegeekpirate</span><span>|</span><a href="#40508426">parent</a><span>|</span><a href="#40508478">prev</a><span>|</span><a href="#40508455">next</a><span>|</span><label class="collapse" for="c-40509379">[-]</label><label class="expand" for="c-40509379">[1 more]</label></div><br/><div class="children"><div class="content">Go doesn&#x27;t rearrange struct fields, which is also why there&#x27;s a linter&#x2F;analyzer which shows you whether or not you could be using less memory with better field sorting<p><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;golang.org&#x2F;x&#x2F;tools&#x2F;go&#x2F;analysis&#x2F;passes&#x2F;fieldalignment" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;golang.org&#x2F;x&#x2F;tools&#x2F;go&#x2F;analysis&#x2F;passes&#x2F;fie...</a></div><br/></div></div><div id="40508455" class="c"><input type="checkbox" id="c-40508455" checked=""/><div class="controls bullet"><span class="by">Hemospectrum</span><span>|</span><a href="#40508426">parent</a><span>|</span><a href="#40509379">prev</a><span>|</span><a href="#40509502">next</a><span>|</span><label class="collapse" for="c-40508455">[-]</label><label class="expand" for="c-40508455">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does Rust fundamentally guarantee that if you make a struct, its fields will lay out in memory in the order that you defined them? Can it be used to interact with APIs (really ABIs) who expect a C struct (or pointer to one)?<p>You have to specify this behavior with #[repr(C)]. Otherwise, the compiler will rearrange fields to try to optimize packing and alignment.</div><br/></div></div><div id="40509502" class="c"><input type="checkbox" id="c-40509502" checked=""/><div class="controls bullet"><span class="by">Zanfa</span><span>|</span><a href="#40508426">parent</a><span>|</span><a href="#40508455">prev</a><span>|</span><a href="#40509162">next</a><span>|</span><label class="collapse" for="c-40509502">[-]</label><label class="expand" for="c-40509502">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think my main frustration with stuff like Go and Swift in this case is that their structs are not binary-compatible with C structs in this way because they rearrange things to be better aligned&#x2F;packed&#x2F;whatever.<p>If you need binary-compatibility with C structs in Swift, you can define them in a bridging header.</div><br/></div></div></div></div><div id="40508367" class="c"><input type="checkbox" id="c-40508367" checked=""/><div class="controls bullet"><span class="by">drv</span><span>|</span><a href="#40508426">prev</a><span>|</span><a href="#40507528">next</a><span>|</span><label class="collapse" for="c-40508367">[-]</label><label class="expand" for="c-40508367">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s cool to see more systems code written in Rust! I also previously worked on SPDK, so it was neat to see it being chosen as a point of comparison.<p>However, I was waiting for the touted memory safety to be mentioned beyond the introduction, but it never really came up again. I was hoping for the paper to make a stronger argument for memory-safe languages like Rust, something like &quot;our driver did not have bugs X, Y, and Z, which were found in other drivers, because the compiler caught them&quot;.<p>Additionally, in a userspace device driver that is given control of a piece of hardware that can do DMA, like an NVMe controller, the most critical memory safety feature is an IOMMU, which the driver covered by the paper does not enable; no amount of memory safety in the driver code itself matters when the hardware can be programmed to read or write anywhere in the physical address space, including memory belonging to other processes or even the kernel, from totally &quot;safe&quot; (in Rust semantics) code.<p>While the driver from the paper may certainly have a &quot;simplified API and less code&quot;, I don&#x27;t expect much of this to be related to the implementation language; it&#x27;s comparing a clean-sheet minimal design to a project that has been around for a while and has had additional features incrementally added to it over time, making the older codebase inevitably larger and more complex. This doesn&#x27;t seem like a particularly surprising result or an endorsement of a particular language, though it perhaps does indicate that it would be useful to start from scratch now and again just to see what the minimum viable system can look like. I certainly would have liked to rewrite it in Rust, but that wasn&#x27;t really feasible. :)<p>In any case, it&#x27;s great to see proof that a Rust driver can have comparable performance to one written in C, since it will hopefully encourage new code to be written in a nicer language than C. I definitely don&#x27;t miss having to deal with manual memory management and chasing down use-after-frees now that I write Rust instead of C.<p>(As a side note, I&#x27;d encourage anyone thinking of using a userspace storage driver on Linux to check out io_uring first before going all in; if io_uring had existed before SPDK, I don&#x27;t know that SPDK would have been written, given that io_uring gets you most of the way there performance-wise and integrates nicely with the rest of the kernel. A userspace driver has its uses, but I would consider it to be a last resort after exhausting all other options, since you have to reinvent all of the other functionality normally provided by the kernel like I&#x2F;O scheduling, filesystems, encryption, etc., not just the NVMe driver itself. That is, assuming the io_uring security issues get resolved over time, and I expect they will.)</div><br/><div id="40509001" class="c"><input type="checkbox" id="c-40509001" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#40508367">parent</a><span>|</span><a href="#40507528">next</a><span>|</span><label class="collapse" for="c-40509001">[-]</label><label class="expand" for="c-40509001">[2 more]</label></div><br/><div class="children"><div class="content">Very interesting comment. By I&#x2F;O scheduling, you mean across multiple processes (i.e. multiplexing the device)?</div><br/><div id="40509485" class="c"><input type="checkbox" id="c-40509485" checked=""/><div class="controls bullet"><span class="by">drv</span><span>|</span><a href="#40508367">root</a><span>|</span><a href="#40509001">parent</a><span>|</span><a href="#40507528">next</a><span>|</span><label class="collapse" for="c-40509485">[-]</label><label class="expand" for="c-40509485">[1 more]</label></div><br/><div class="children"><div class="content">I&#x2F;O scheduler was probably a bad example, since you might not need&#x2F;want one for fast NVMe devices anyway, but yes, they help ensure limited resources (storage device bandwidth or IOPS) get shared fairly between multiple users&#x2F;processes, as well as potentially reordering requests to improve batching (this matters more on spinning disks with seek latency, since a strategy of delaying a little bit to sort requests could save more time on seeks than it would spend on the delay+CPU overhead).<p>The more general point is that if you need any of the many features of a general-purpose OS kernel, a full userspace driver may not be a very good fit, since you will end up reinventing a lot of wheels. Cases where it could be a good fit would be things like database backends or dedicated block storage appliances, situations where the OS would just get in the way and where it&#x27;s viable to dedicate a whole storage device (or several) and a whole CPU (or several) to one task.</div><br/></div></div></div></div></div></div><div id="40507528" class="c"><input type="checkbox" id="c-40507528" checked=""/><div class="controls bullet"><span class="by">gdiamos</span><span>|</span><a href="#40508367">prev</a><span>|</span><a href="#40507281">next</a><span>|</span><label class="collapse" for="c-40507528">[-]</label><label class="expand" for="c-40507528">[2 more]</label></div><br/><div class="children"><div class="content">That is a bachelor’s thesis - someone should hire that student<p>Clear writing and ideas</div><br/><div id="40509136" class="c"><input type="checkbox" id="c-40509136" checked=""/><div class="controls bullet"><span class="by">eisbaw</span><span>|</span><a href="#40507528">parent</a><span>|</span><a href="#40507281">next</a><span>|</span><label class="collapse" for="c-40509136">[-]</label><label class="expand" for="c-40509136">[1 more]</label></div><br/><div class="children"><div class="content">Let him at least finish M.Sc. first. Then he can get dissapointed about the industry a bit later.</div><br/></div></div></div></div><div id="40507281" class="c"><input type="checkbox" id="c-40507281" checked=""/><div class="controls bullet"><span class="by">tormeh</span><span>|</span><a href="#40507528">prev</a><span>|</span><a href="#40508743">next</a><span>|</span><label class="collapse" for="c-40507281">[-]</label><label class="expand" for="c-40507281">[1 more]</label></div><br/><div class="children"><div class="content">Extremely impressive. Does anyone know if performance is likely to decrease as more features are implemented? Because if not, this is a winner.</div><br/></div></div><div id="40508743" class="c"><input type="checkbox" id="c-40508743" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#40507281">prev</a><span>|</span><a href="#40508310">next</a><span>|</span><label class="collapse" for="c-40508743">[-]</label><label class="expand" for="c-40508743">[3 more]</label></div><br/><div class="children"><div class="content">One question that is unclear to me - what are the <i>disadvantages</i> of a user space driver like SPDK (in comparison to a kernel implementation)? It prevents multiplexing the device? The API is more complex to program?</div><br/><div id="40509425" class="c"><input type="checkbox" id="c-40509425" checked=""/><div class="controls bullet"><span class="by">ongy</span><span>|</span><a href="#40508743">parent</a><span>|</span><a href="#40508310">next</a><span>|</span><label class="collapse" for="c-40509425">[-]</label><label class="expand" for="c-40509425">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not protected by the copy-left properties of the kernel D:<p>For the more technical points:<p>The kernel needs to have it available in a somewhat complex way to be able to mount the drive.
I.e. init becomes a lot more involved with an initram that first needs to load the driver (potentially loopback it?) and the mount actual root.<p>To some degree there can also be issues around syscall boundaries. I.e. the usual monolith vs. microkernel.
I haven&#x27;t checked the API they hook into to provide the device to other components. But it likely requires the kernel to jump back into userspace in various &quot;hot-ish&quot; paths for IO.</div><br/><div id="40509459" class="c"><input type="checkbox" id="c-40509459" checked=""/><div class="controls bullet"><span class="by">ongy</span><span>|</span><a href="#40508743">root</a><span>|</span><a href="#40509425">parent</a><span>|</span><a href="#40508310">next</a><span>|</span><label class="collapse" for="c-40509459">[-]</label><label class="expand" for="c-40509459">[1 more]</label></div><br/><div class="children"><div class="content">Ok, it doesn&#x27;t integrate with the system at all.
This provides a library to access the device.<p>I.e. it can only be used by a single consumer, that consumer doesn&#x27;t get nice things like ther kernel&#x27;s file systems or device mapper (raid&#x2F;crypt&#x2F;verity...) features.
This can be fine, e.g. when the consumer is a database that just needs a block device, or something like ceph&#x2F;minio etc. that provides the storage api to its consumers.<p>It&#x27;d have to use something like NBD (~fuse for block devices) to actually integrate and then my previous post describes some of the downsides to that setup.</div><br/></div></div></div></div></div></div><div id="40508310" class="c"><input type="checkbox" id="c-40508310" checked=""/><div class="controls bullet"><span class="by">koverstreet</span><span>|</span><a href="#40508743">prev</a><span>|</span><a href="#40508793">next</a><span>|</span><label class="collapse" for="c-40508310">[-]</label><label class="expand" for="c-40508310">[1 more]</label></div><br/><div class="children"><div class="content">Rust is a total gamechanger, and it&#x27;s probably the thing that excites me the most about the future of kernel development.</div><br/></div></div><div id="40508793" class="c"><input type="checkbox" id="c-40508793" checked=""/><div class="controls bullet"><span class="by">moonshotideas</span><span>|</span><a href="#40508310">prev</a><span>|</span><label class="collapse" for="c-40508793">[-]</label><label class="expand" for="c-40508793">[1 more]</label></div><br/><div class="children"><div class="content">Given the statement ‘we achieve SPDK-like throughput,’ I’m curious whether the performance is slightly worse than SPDK. If it is, do you have any comparison metrics for throughput?</div><br/></div></div></div></div></div></div></div></body></html>