<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693990869238" as="style"/><link rel="stylesheet" href="styles.css?v=1693990869238"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/EmNudge/watlings">Learn WebAssembly by writing small programs</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>72 comments</span></div><br/><div><div id="37402369" class="c"><input type="checkbox" id="c-37402369" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#37398677">next</a><span>|</span><label class="collapse" for="c-37402369">[-]</label><label class="expand" for="c-37402369">[1 more]</label></div><br/><div class="children"><div class="content">Because I&#x27;ve read it here and elsewhere quite often:
What is missing from WASM in the browser isn&#x27;t &quot;just&quot; DOM access, but &quot;everything&quot; else - including fetch or XMLHttpRequest - too. Here is a list of all web APIs supported by browsers and not supported by WASM, the DOM is just one of them: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API</a><p>But at least there is hope, that these interfaces will be available once GC is final and supported by browsers:<p><pre><code>    Once GC is supported, WebAssembly code would be able to reference and access JavaScript, DOM, and general WebIDL-defined objects.
</code></pre>
Last paragraph at <a href="https:&#x2F;&#x2F;webassembly.org&#x2F;docs&#x2F;web&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;webassembly.org&#x2F;docs&#x2F;web&#x2F;</a></div><br/></div></div><div id="37398677" class="c"><input type="checkbox" id="c-37398677" checked=""/><div class="controls bullet"><span class="by">ysavir</span><span>|</span><a href="#37402369">prev</a><span>|</span><a href="#37395628">next</a><span>|</span><label class="collapse" for="c-37398677">[-]</label><label class="expand" for="c-37398677">[5 more]</label></div><br/><div class="children"><div class="content">Looks very similar to the Exercism model, which also has a free WASM course filled with small exercises[1]. I wonder if the author considered contributing to that course or working together with them, it might get their work to a broader audience and leverage the existing toolset Exercism has to offer.<p>[1]<a href="https:&#x2F;&#x2F;exercism.org&#x2F;tracks&#x2F;wasm" rel="nofollow noreferrer">https:&#x2F;&#x2F;exercism.org&#x2F;tracks&#x2F;wasm</a></div><br/><div id="37400240" class="c"><input type="checkbox" id="c-37400240" checked=""/><div class="controls bullet"><span class="by">emnudge</span><span>|</span><a href="#37398677">parent</a><span>|</span><a href="#37400071">next</a><span>|</span><label class="collapse" for="c-37400240">[-]</label><label class="expand" for="c-37400240">[2 more]</label></div><br/><div class="children"><div class="content">I really like Exercism! Unfortunately their exercise model is considerably more free-form where it teaches you considerably less and in much larger chunks. I think this is a great model for certain contexts, but the format I have in the repo is more similar to &quot;rustlings&quot; and &quot;ziglings&quot; where you&#x27;re taught syntax and features alongside the code examples.<p>I don&#x27;t know that their Wasm module is necessarily &quot;broken&quot;, so I&#x27;m unsure whether my contributions would be welcome.</div><br/><div id="37400635" class="c"><input type="checkbox" id="c-37400635" checked=""/><div class="controls bullet"><span class="by">ysavir</span><span>|</span><a href="#37398677">root</a><span>|</span><a href="#37400240">parent</a><span>|</span><a href="#37400071">next</a><span>|</span><label class="collapse" for="c-37400635">[-]</label><label class="expand" for="c-37400635">[1 more]</label></div><br/><div class="children"><div class="content">Very fair! It&#x27;s been close to a decade since I used Exercism so I don&#x27;t really know what their stuff is like nowadays. From what I remember, the focus was less on teaching you the language directly (via instructions) and was more on encouraging the user to reiterate on their code and experiment, and letting reviewers lead the direction of growth.</div><br/></div></div></div></div><div id="37400071" class="c"><input type="checkbox" id="c-37400071" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#37398677">parent</a><span>|</span><a href="#37400240">prev</a><span>|</span><a href="#37395628">next</a><span>|</span><label class="collapse" for="c-37400071">[-]</label><label class="expand" for="c-37400071">[2 more]</label></div><br/><div class="children"><div class="content">One thing I don&#x27;t like about Exercism is that except for the most popular languages, the exercises are often not &quot;sysematics&quot;.<p>In other words, it&#x27;s just a bunch of leetcode-like questions, ordered by difficulties.<p>A proper course should order the exercises by language features. Exercism actually has built a fantastic interface for this[1], but not utiltized it for most langauges.<p>[1]: <a href="https:&#x2F;&#x2F;exercism.org&#x2F;tracks&#x2F;csharp&#x2F;concepts" rel="nofollow noreferrer">https:&#x2F;&#x2F;exercism.org&#x2F;tracks&#x2F;csharp&#x2F;concepts</a></div><br/><div id="37402463" class="c"><input type="checkbox" id="c-37402463" checked=""/><div class="controls bullet"><span class="by">tietjens</span><span>|</span><a href="#37398677">root</a><span>|</span><a href="#37400071">parent</a><span>|</span><a href="#37395628">next</a><span>|</span><label class="collapse" for="c-37402463">[-]</label><label class="expand" for="c-37402463">[1 more]</label></div><br/><div class="children"><div class="content">I completely agree with this. I love the platform, the mentors, and the enthusiasm for languages. They’ve done a great series every month this year on a new set of languages, and have great YouTube interviews.<p>However, the problems they offer do not help you learn the syntax or quirks of specific languages and for me are only a place to practice leetcode&#x2F;codewars style logic. Also important! But not what I need when I first begin a language.</div><br/></div></div></div></div></div></div><div id="37395628" class="c"><input type="checkbox" id="c-37395628" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37398677">prev</a><span>|</span><a href="#37395031">next</a><span>|</span><label class="collapse" for="c-37395628">[-]</label><label class="expand" for="c-37395628">[5 more]</label></div><br/><div class="children"><div class="content">This is great, thanks!<p>One of my favorite ways to learn a new language or framework is via &quot;koans&quot;[1], which this reminds me of. It&#x27;s a gentle ramp up from basic to advanced features, and the TDD-like workflow of seeing a test fail, understanding why, and fixing it, is really conducive to learning, while giving you that dopamine jolt from &quot;a-ha!&quot;.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ahmdrefat&#x2F;awesome-koans&#x2F;blob&#x2F;master&#x2F;koans-en.md">https:&#x2F;&#x2F;github.com&#x2F;ahmdrefat&#x2F;awesome-koans&#x2F;blob&#x2F;master&#x2F;koans...</a></div><br/><div id="37396377" class="c"><input type="checkbox" id="c-37396377" checked=""/><div class="controls bullet"><span class="by">dfee</span><span>|</span><a href="#37395628">parent</a><span>|</span><a href="#37395031">next</a><span>|</span><label class="collapse" for="c-37396377">[-]</label><label class="expand" for="c-37396377">[4 more]</label></div><br/><div class="children"><div class="content">sounds like a great way to learn a language &quot;on your own&quot;. unfortunately, Rust is missing. can anyone propose a link?</div><br/><div id="37397648" class="c"><input type="checkbox" id="c-37397648" checked=""/><div class="controls bullet"><span class="by">billti</span><span>|</span><a href="#37395628">root</a><span>|</span><a href="#37396377">parent</a><span>|</span><a href="#37396675">next</a><span>|</span><label class="collapse" for="c-37397648">[-]</label><label class="expand" for="c-37397648">[1 more]</label></div><br/><div class="children"><div class="content">It credits Rustlings at the end of the page linked to (<a href="https:&#x2F;&#x2F;github.com&#x2F;EmNudge&#x2F;watlings#credits">https:&#x2F;&#x2F;github.com&#x2F;EmNudge&#x2F;watlings#credits</a>).</div><br/></div></div><div id="37396675" class="c"><input type="checkbox" id="c-37396675" checked=""/><div class="controls bullet"><span class="by">Kalq</span><span>|</span><a href="#37395628">root</a><span>|</span><a href="#37396377">parent</a><span>|</span><a href="#37397648">prev</a><span>|</span><a href="#37395031">next</a><span>|</span><label class="collapse" for="c-37396675">[-]</label><label class="expand" for="c-37396675">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that basically Rustlings?</div><br/><div id="37396722" class="c"><input type="checkbox" id="c-37396722" checked=""/><div class="controls bullet"><span class="by">dfee</span><span>|</span><a href="#37395628">root</a><span>|</span><a href="#37396675">parent</a><span>|</span><a href="#37395031">next</a><span>|</span><label class="collapse" for="c-37396722">[-]</label><label class="expand" for="c-37396722">[1 more]</label></div><br/><div class="children"><div class="content">i think you&#x27;ve found what i&#x27;m looking for! <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustlings">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustlings</a></div><br/></div></div></div></div></div></div></div></div><div id="37395031" class="c"><input type="checkbox" id="c-37395031" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#37395628">prev</a><span>|</span><a href="#37400928">next</a><span>|</span><label class="collapse" for="c-37395031">[-]</label><label class="expand" for="c-37395031">[1 more]</label></div><br/><div class="children"><div class="content">Just a remark: if you want to play with WASM features like GC, use Binaryen&#x27;s `wasm-opt` instead of WABT, as `wasm-opt` supports way more  WASM extensions.</div><br/></div></div><div id="37400928" class="c"><input type="checkbox" id="c-37400928" checked=""/><div class="controls bullet"><span class="by">RagnarD</span><span>|</span><a href="#37395031">prev</a><span>|</span><a href="#37395197">next</a><span>|</span><label class="collapse" for="c-37400928">[-]</label><label class="expand" for="c-37400928">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m cheered by ongoing progress in adoption of WebAssembly. While Microsoft is often given minimal notice here, I urge anyone interested in WASM to experiment with Blazor WebAssembly. It&#x27;s an incredibly powerful framework that lets you use C# and most .NET libraries (including NuGet packages) as compiled WASM in the browser.</div><br/><div id="37401018" class="c"><input type="checkbox" id="c-37401018" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#37400928">parent</a><span>|</span><a href="#37401528">next</a><span>|</span><label class="collapse" for="c-37401018">[-]</label><label class="expand" for="c-37401018">[2 more]</label></div><br/><div class="children"><div class="content">Re ‘most nuget packages’ What’s the limitation here? If it requires the ability to read a file on disk, does it straight up fail or does the file read interface push the action back into a server-side rendering type action?</div><br/><div id="37402056" class="c"><input type="checkbox" id="c-37402056" checked=""/><div class="controls bullet"><span class="by">RagnarD</span><span>|</span><a href="#37400928">root</a><span>|</span><a href="#37401018">parent</a><span>|</span><a href="#37401528">next</a><span>|</span><label class="collapse" for="c-37402056">[-]</label><label class="expand" for="c-37402056">[1 more]</label></div><br/><div class="children"><div class="content">The NuGet packages are zip files containing compiled binary and possibly other resources. They&#x27;re referenced in the source code and included at compile time. Since they become integrated into the overall compile, there&#x27;s no need to reference them in the final runtime product.</div><br/></div></div></div></div></div></div><div id="37395197" class="c"><input type="checkbox" id="c-37395197" checked=""/><div class="controls bullet"><span class="by">arek_nawo</span><span>|</span><a href="#37400928">prev</a><span>|</span><a href="#37400908">next</a><span>|</span><label class="collapse" for="c-37395197">[-]</label><label class="expand" for="c-37395197">[26 more]</label></div><br/><div class="children"><div class="content">Pretty cool.<p>I haven&#x27;t really explored WASM hands-on (I&#x27;ll give this guide a try) but, given that it&#x27;s already been a few years, I think it&#x27;s been hugely beneficial for web development.<p>Not the &quot;JavaScript killer&quot; some where hoping for, though it was never meant to be one. Instead it integrates pretty nicely within the existing ecosystem, optimizing existing use-cases and allowing new ones when heavy computations are required. Net benefit for all web devs - faster libraries, impressive dev tools and more portable node binaries.</div><br/><div id="37395577" class="c"><input type="checkbox" id="c-37395577" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#37395197">parent</a><span>|</span><a href="#37400908">next</a><span>|</span><label class="collapse" for="c-37395577">[-]</label><label class="expand" for="c-37395577">[25 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been watching WASM from afar, and it&#x27;s my understanding that it&#x27;s not a JS killer because it doesn&#x27;t have direct access to the DOM or to most DOM APIs. I&#x27;m curious if there&#x27;s another reason I&#x27;m missing?</div><br/><div id="37397578" class="c"><input type="checkbox" id="c-37397578" checked=""/><div class="controls bullet"><span class="by">math_dandy</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37395577">parent</a><span>|</span><a href="#37396548">next</a><span>|</span><label class="collapse" for="c-37397578">[-]</label><label class="expand" for="c-37397578">[11 more]</label></div><br/><div class="children"><div class="content">Is being a &quot;JS killer&quot; even a goal of WASM? From what I understand, WASM&#x27;s goal is to allow computationally heavy workloads (e.g., image and audio processing) to the browser by providing a compilation target for C code. This is how we get nice things like Figma or MS Office running in the browser.<p>Let WASM do the number crunching, let JS do the UI.</div><br/><div id="37398649" class="c"><input type="checkbox" id="c-37398649" checked=""/><div class="controls bullet"><span class="by">Philip-J-Fry</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37397578">parent</a><span>|</span><a href="#37396548">next</a><span>|</span><label class="collapse" for="c-37398649">[-]</label><label class="expand" for="c-37398649">[10 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the goal from what it seems. But it&#x27;s definitely what would make it the most interesting to a lot of people, and it&#x27;s what I think most people expected at some point.<p>For a lot of companies the only place JavaScript is ever used is on their website frontend. And it makes you wonder, why does it even still need to be JavaScript? With the rise of SPAs and the fall of normal document based websites, browsers are basically just becoming their own platform like Windows Desktop, Mac, Linux, Android, iOS, etc. You could say it&#x27;s been that way for a long time, but more and more apps are becoming web based only because the browser is now powerful enough to run what used to be a desktop application.<p>Browsers are literally just a VM with an address bar. We go to a URL and run a program, except right now there&#x27;s basically the limitation that the program has to be written at least partly in JavaScript. Being able to deploy an entire website as WASM is just the next logical step from what I see.</div><br/><div id="37400604" class="c"><input type="checkbox" id="c-37400604" checked=""/><div class="controls bullet"><span class="by">math_dandy</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37398649">parent</a><span>|</span><a href="#37401840">next</a><span>|</span><label class="collapse" for="c-37400604">[-]</label><label class="expand" for="c-37400604">[7 more]</label></div><br/><div class="children"><div class="content">The two language problem is, indeed, awkward.<p>DOM bindings in WASM would be awesome. I would be a happy nerd if I could do all of my web dev in OCaml.<p>In the meantime, WASM has real, just not for front end dev.<p>The two language problem is hardly unique to web dev. It’s also ubiquitous in the machine learning&#x2F;data science space with Python and C&#x2F;C++&#x2F;CUDA playing the roles of JS and WASM, respectively.</div><br/><div id="37402150" class="c"><input type="checkbox" id="c-37402150" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37400604">parent</a><span>|</span><a href="#37400884">next</a><span>|</span><label class="collapse" for="c-37402150">[-]</label><label class="expand" for="c-37402150">[3 more]</label></div><br/><div class="children"><div class="content">&gt; DOM bindings in WASM would be awesome. I would be a happy nerd if I could do all of my web dev in OCaml.<p>DOM is not enough for that. You almost certainly would like to be able to communicate with your backend ;)<p>Here is a list of the &quot;usual&quot; web APIs: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API</a> 
And everything that needs network access or access to local resources (file system in the worst case) will never happen to WASM because of security considerations.</div><br/><div id="37402337" class="c"><input type="checkbox" id="c-37402337" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37402150">parent</a><span>|</span><a href="#37400884">next</a><span>|</span><label class="collapse" for="c-37402337">[-]</label><label class="expand" for="c-37402337">[2 more]</label></div><br/><div class="children"><div class="content">How is allowing WebAssembly to use the network any less secure than allowing JavaScript to use the network?</div><br/><div id="37402476" class="c"><input type="checkbox" id="c-37402476" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37402337">parent</a><span>|</span><a href="#37400884">next</a><span>|</span><label class="collapse" for="c-37402476">[-]</label><label class="expand" for="c-37402476">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t ask me :).<p>At least WASM will get DOM access (and hopefully access to similar web APIs) as soon as the GC is stable and usable.<p><pre><code>   Once GC is supported, WebAssembly code would be able to reference and access JavaScript, DOM, and general WebIDL-defined objects.
</code></pre>
<a href="https:&#x2F;&#x2F;webassembly.org&#x2F;docs&#x2F;web&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;webassembly.org&#x2F;docs&#x2F;web&#x2F;</a></div><br/></div></div></div></div></div></div><div id="37400884" class="c"><input type="checkbox" id="c-37400884" checked=""/><div class="controls bullet"><span class="by">catlover76</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37400604">parent</a><span>|</span><a href="#37402150">prev</a><span>|</span><a href="#37401840">next</a><span>|</span><label class="collapse" for="c-37400884">[-]</label><label class="expand" for="c-37400884">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  I would be a happy nerd if I could do all of my web dev in OCaml.<p>You don&#x27;t like Bonsai? Or do you just want something that doesn&#x27;t &quot;transpile&quot; to JS at all?</div><br/><div id="37401281" class="c"><input type="checkbox" id="c-37401281" checked=""/><div class="controls bullet"><span class="by">math_dandy</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37400884">parent</a><span>|</span><a href="#37401840">next</a><span>|</span><label class="collapse" for="c-37401281">[-]</label><label class="expand" for="c-37401281">[2 more]</label></div><br/><div class="children"><div class="content">I find that these compile-to-JS languages are great until you want to bring in other JS libraries. Then you’re stuck writing bindings which is annoying, and often brittle if you’re not really careful.</div><br/><div id="37401558" class="c"><input type="checkbox" id="c-37401558" checked=""/><div class="controls bullet"><span class="by">catlover76</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37401281">parent</a><span>|</span><a href="#37401840">next</a><span>|</span><label class="collapse" for="c-37401558">[-]</label><label class="expand" for="c-37401558">[1 more]</label></div><br/><div class="children"><div class="content">Oh I didn&#x27;t even think of that--that sounds like a huge pain in the ass lol</div><br/></div></div></div></div></div></div></div></div><div id="37401840" class="c"><input type="checkbox" id="c-37401840" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37398649">parent</a><span>|</span><a href="#37400604">prev</a><span>|</span><a href="#37401908">next</a><span>|</span><label class="collapse" for="c-37401840">[-]</label><label class="expand" for="c-37401840">[1 more]</label></div><br/><div class="children"><div class="content">You can certainly bridge the DOM to WASM with a virtual DOM. The problems with WASM are not just interoperability.<p>The biggest problem is tooling. You cannot build tooling for in-browser WASM because it runs in a browser sandbox. JS has the same problem but the difference is that JS has a known object model that the browser can provide good tooling for.<p>Whereas with WASM the browser has little insight into what those opaque Memory objects contain. So you need to bring your own tooling and run it inside the sandbox, and the sandboxing does not make this easy.<p>Let’s say for example you want to pause execution, inspect the object tree, and run a REPL while it’s paused.</div><br/></div></div><div id="37401908" class="c"><input type="checkbox" id="c-37401908" checked=""/><div class="controls bullet"><span class="by">yieldcrv</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37398649">parent</a><span>|</span><a href="#37401840">prev</a><span>|</span><a href="#37396548">next</a><span>|</span><label class="collapse" for="c-37401908">[-]</label><label class="expand" for="c-37401908">[1 more]</label></div><br/><div class="children"><div class="content">If it was the JavaScript killer it will attract JavaScript devs and they’ll make it just like JavaScript<p>not syntax-wise just community wise, where the package and package managers are a mess and why there is demand for a JavaScript killer</div><br/></div></div></div></div></div></div><div id="37396548" class="c"><input type="checkbox" id="c-37396548" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37395577">parent</a><span>|</span><a href="#37397578">prev</a><span>|</span><a href="#37395988">next</a><span>|</span><label class="collapse" for="c-37396548">[-]</label><label class="expand" for="c-37396548">[2 more]</label></div><br/><div class="children"><div class="content">Yep. Give access to the DOM - perhaps via a batch update&#x2F;fragment mechanism and watch as it becomes a JS killer. But WASM is currently a starved prisoner locked up in a room only allowed to view the goodies outside the cell door.</div><br/><div id="37399459" class="c"><input type="checkbox" id="c-37399459" checked=""/><div class="controls bullet"><span class="by">tcfhgj</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37396548">parent</a><span>|</span><a href="#37395988">next</a><span>|</span><label class="collapse" for="c-37399459">[-]</label><label class="expand" for="c-37399459">[1 more]</label></div><br/><div class="children"><div class="content">What would that change? 
DOM interaction can and is abstracted away by frameworks anyways and not performance critical</div><br/></div></div></div></div><div id="37395988" class="c"><input type="checkbox" id="c-37395988" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37395577">parent</a><span>|</span><a href="#37396548">prev</a><span>|</span><a href="#37400908">next</a><span>|</span><label class="collapse" for="c-37395988">[-]</label><label class="expand" for="c-37395988">[11 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t have access to _anything_ (in the browser, in other runtimes there is WASI with POSIX functions). Everything has to be imported from or exported to JS.<p>And currently using anything but C, C++ or Rust isn&#x27;t feasible, as the runtime needed for a GC is way too big. A Haskell &quot;Hello World&quot; for example is about 1MB (even after running `wasm-opt` on the generated WASM binary).</div><br/><div id="37400650" class="c"><input type="checkbox" id="c-37400650" checked=""/><div class="controls bullet"><span class="by">progmetaldev</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37395988">parent</a><span>|</span><a href="#37396457">next</a><span>|</span><label class="collapse" for="c-37400650">[-]</label><label class="expand" for="c-37400650">[1 more]</label></div><br/><div class="children"><div class="content">I do agree things like the GC are very large if we&#x27;re comparing against standard JavaScript, so I don&#x27;t believe the technology is ready for standard customer facing websites. For things like internal applications&#x2F;extranet type applications, I think that the runtime download cost is minimal compared to the functionality that you are given with a proper framework (I can only speak of Microsoft Blazor, but that&#x27;s just language ignorance, and I know there are other that fit the model as well). As a web developer that also writes utilities to run on the desktop, for things such as ETL or fixing bad data, being able to not switch to another language or even really framework is a huge boon for my time. I know JavaScript, but being able to rarely have to deal with it keeps my head in what I&#x27;m solving, rather than having to context switch between interface and server.</div><br/></div></div><div id="37396457" class="c"><input type="checkbox" id="c-37396457" checked=""/><div class="controls bullet"><span class="by">yebyen</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37395988">parent</a><span>|</span><a href="#37400650">prev</a><span>|</span><a href="#37397632">next</a><span>|</span><label class="collapse" for="c-37396457">[-]</label><label class="expand" for="c-37396457">[2 more]</label></div><br/><div class="children"><div class="content">&gt; isn&#x27;t feasible<p>This is kind of subjective, and in the context of &quot;is this a JS killer&quot; which is what you&#x27;re answering, I&#x27;d agree, it makes sending the Wasm to the browser a bit of a non-starter that it requires a large bundle most of which is simply boilerplate for whatever runtime, without some type of local storage and persistent cache it&#x27;s difficult to imagine using Ruby in a Wasm for example. If you&#x27;re deploying to a container, where you&#x27;re able to use a cache warmer to ensure the wasm is ready before it&#x27;s called, then a 1mb binary might not be such a big issue.<p>(I mean, it is still a big issue because the point was fast cold starts, and big assemblies mean no fast cold starts, but again, subjective value judgments... 1mb isn&#x27;t too big in many cases and I&#x27;d wager most of the cases that I&#x27;d really care about. But in a browser...)<p>But if you&#x27;re not trying to run the Wasm in a browser then it&#x27;s still potentially quite useful. You might not be running all of your Wasm in a browser and it might still be a JS killer, and all of those might not be in conflict.</div><br/><div id="37396994" class="c"><input type="checkbox" id="c-37396994" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37396457">parent</a><span>|</span><a href="#37397632">next</a><span>|</span><label class="collapse" for="c-37396994">[-]</label><label class="expand" for="c-37396994">[1 more]</label></div><br/><div class="children"><div class="content">Well, the main reason why I&#x27;m taking a deeper look at WASM is because I&#x27;m creating a language and compiler that is optimized to compile to WASM.
While I don&#x27;t think that my compiler will be the JS killer, I do think that WASM languages using a (the WASM) GC have a future.</div><br/></div></div></div></div><div id="37397632" class="c"><input type="checkbox" id="c-37397632" checked=""/><div class="controls bullet"><span class="by">patmorgan23</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37395988">parent</a><span>|</span><a href="#37396457">prev</a><span>|</span><a href="#37397015">next</a><span>|</span><label class="collapse" for="c-37397632">[-]</label><label class="expand" for="c-37397632">[1 more]</label></div><br/><div class="children"><div class="content">I mean Microsofts Blazor framework can use WASM to run C#(and its runtime) in the browser.</div><br/></div></div><div id="37397015" class="c"><input type="checkbox" id="c-37397015" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37395988">parent</a><span>|</span><a href="#37397632">prev</a><span>|</span><a href="#37397103">next</a><span>|</span><label class="collapse" for="c-37397015">[-]</label><label class="expand" for="c-37397015">[1 more]</label></div><br/><div class="children"><div class="content">Virgil compiles to Wasm and brings its own GC as well, and the runtime is on the order of about 4KB. The GC is a simple semi-space copying collector and the compiler prunes away dead code from libraries, so binaries are pretty small. So overall I don&#x27;t think this is a Wasm issue as it is mostly a language runtime size issue.</div><br/></div></div><div id="37397103" class="c"><input type="checkbox" id="c-37397103" checked=""/><div class="controls bullet"><span class="by">plopz</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37395988">parent</a><span>|</span><a href="#37397015">prev</a><span>|</span><a href="#37397845">next</a><span>|</span><label class="collapse" for="c-37397103">[-]</label><label class="expand" for="c-37397103">[3 more]</label></div><br/><div class="children"><div class="content">In the browser, can it integrate with SharedArrayBuffer, worker&#x27;s postMessage or transferrable offscreen canvas?</div><br/><div id="37397306" class="c"><input type="checkbox" id="c-37397306" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37397103">parent</a><span>|</span><a href="#37397276">next</a><span>|</span><label class="collapse" for="c-37397306">[-]</label><label class="expand" for="c-37397306">[1 more]</label></div><br/><div class="children"><div class="content">Depends what you mean by &quot;integrate&quot;. It always has to import or export JS functions or memory. WASM (without WASI) has no direct connection to &quot;the outside World&quot;, everything has to be routed via JS FFI. So you can import or export a SharedArrayBuffer to communicate with JS. 
<a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;WebAssembly&#x2F;JavaScript_interface&#x2F;Memory#creating_a_shared_memory" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;WebAssembly&#x2F;JavaScr...</a><p>But you need the WASM thread extension (for atomic access to the shared memory) to be able to use shared memory.</div><br/></div></div><div id="37397276" class="c"><input type="checkbox" id="c-37397276" checked=""/><div class="controls bullet"><span class="by">connicpu</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37397103">parent</a><span>|</span><a href="#37397306">prev</a><span>|</span><a href="#37397845">next</a><span>|</span><label class="collapse" for="c-37397276">[-]</label><label class="expand" for="c-37397276">[1 more]</label></div><br/><div class="children"><div class="content">WASM essentially can call javascript functions that were imported, and I believe javascript is able to read WASM&#x27;s memory (a big help for transferring strings). If you&#x27;re using something like Rust, all the glue code to call any JS APIs can be automatically generated for you with wasm-bindgen, so it really isn&#x27;t a huge problem usability wise. It&#x27;s just not great for performance.</div><br/></div></div></div></div><div id="37397845" class="c"><input type="checkbox" id="c-37397845" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37395988">parent</a><span>|</span><a href="#37397103">prev</a><span>|</span><a href="#37400908">next</a><span>|</span><label class="collapse" for="c-37397845">[-]</label><label class="expand" for="c-37397845">[2 more]</label></div><br/><div class="children"><div class="content">&gt; And currently using anything but C, C++ or Rust isn&#x27;t feasible<p>Someone should tell Anaconda that they can&#x27;t do this, then: <a href="https:&#x2F;&#x2F;pyscript.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;pyscript.net&#x2F;</a></div><br/><div id="37400692" class="c"><input type="checkbox" id="c-37400692" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#37395197">root</a><span>|</span><a href="#37397845">parent</a><span>|</span><a href="#37400908">next</a><span>|</span><label class="collapse" for="c-37400692">[-]</label><label class="expand" for="c-37400692">[1 more]</label></div><br/><div class="children"><div class="content">That uses Pyodide.  From Pyodide&#x27;s own pages:<p><i>&quot;At present a first load of Pyodide requires a 6.4 MB download, and the environment initialization takes 4 to 5 seconds.&quot;</i><p>So, yes, it works.  But there&#x27;s plenty of situations where a 
 big download followed by a 5 second stall is a non-starter.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37400908" class="c"><input type="checkbox" id="c-37400908" checked=""/><div class="controls bullet"><span class="by">eliben</span><span>|</span><a href="#37395197">prev</a><span>|</span><a href="#37397870">next</a><span>|</span><label class="collapse" for="c-37400908">[-]</label><label class="expand" for="c-37400908">[2 more]</label></div><br/><div class="children"><div class="content">Cool project!<p>I maintain a somewhat related repo here: <a href="https:&#x2F;&#x2F;github.com&#x2F;eliben&#x2F;wasm-wat-samples&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;eliben&#x2F;wasm-wat-samples&#x2F;</a></div><br/><div id="37401049" class="c"><input type="checkbox" id="c-37401049" checked=""/><div class="controls bullet"><span class="by">emnudge</span><span>|</span><a href="#37400908">parent</a><span>|</span><a href="#37397870">next</a><span>|</span><label class="collapse" for="c-37401049">[-]</label><label class="expand" for="c-37401049">[1 more]</label></div><br/><div class="children"><div class="content">That looks super useful! I wish I knew about this when first learning wat. This would make a great reference!</div><br/></div></div></div></div><div id="37397870" class="c"><input type="checkbox" id="c-37397870" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37400908">prev</a><span>|</span><a href="#37399855">next</a><span>|</span><label class="collapse" for="c-37397870">[-]</label><label class="expand" for="c-37397870">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s super interesting to me how much WebAssembly resembles a &quot;real language&quot; that&#x27;s sorta writable by-hand. I bet it lowers the bar quite a bit when targeting it</div><br/></div></div><div id="37399855" class="c"><input type="checkbox" id="c-37399855" checked=""/><div class="controls bullet"><span class="by">frithsun</span><span>|</span><a href="#37397870">prev</a><span>|</span><a href="#37400067">next</a><span>|</span><label class="collapse" for="c-37399855">[-]</label><label class="expand" for="c-37399855">[1 more]</label></div><br/><div class="children"><div class="content">Very neat.<p>As WebAssembly becomes the lingua franca of different ecosystems, having a strong grasp of how it works is worth the time investment. Thanks for this.</div><br/></div></div><div id="37400067" class="c"><input type="checkbox" id="c-37400067" checked=""/><div class="controls bullet"><span class="by">ozcanay</span><span>|</span><a href="#37399855">prev</a><span>|</span><a href="#37396483">next</a><span>|</span><label class="collapse" for="c-37400067">[-]</label><label class="expand" for="c-37400067">[2 more]</label></div><br/><div class="children"><div class="content">Cool. Did anyone try targeting Qt applications for WebAssembly? I wonder how convenient it is to use.</div><br/><div id="37400179" class="c"><input type="checkbox" id="c-37400179" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#37400067">parent</a><span>|</span><a href="#37396483">next</a><span>|</span><label class="collapse" for="c-37400179">[-]</label><label class="expand" for="c-37400179">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an interesting write up here:
<a href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;pulse&#x2F;qt-wasm-nicholas-petreley-1c" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.linkedin.com&#x2F;pulse&#x2F;qt-wasm-nicholas-petreley-1c</a><p>Personally, I didn&#x27;t find the author&#x27;s sample app to load very quickly- I think it was 10 seconds or so just to get something on the screen- and it was useless on my phone.<p>That same app would easily perform better and have better device support were it written in js&#x2F;html&#x2F;css.<p>I just don&#x27;t see a place for things like QT or native gui stuff in real world WASM. Number crunching or fast data processing, sure, or maybe a game, but a standard UI is crap if the whole thing is in a big canvas.</div><br/></div></div></div></div><div id="37396483" class="c"><input type="checkbox" id="c-37396483" checked=""/><div class="controls bullet"><span class="by">ducktective</span><span>|</span><a href="#37400067">prev</a><span>|</span><a href="#37395280">next</a><span>|</span><label class="collapse" for="c-37396483">[-]</label><label class="expand" for="c-37396483">[4 more]</label></div><br/><div class="children"><div class="content">Is there a WA UI framework for web similar to Svelte or Vue?</div><br/><div id="37397584" class="c"><input type="checkbox" id="c-37397584" checked=""/><div class="controls bullet"><span class="by">RetiredRichard</span><span>|</span><a href="#37396483">parent</a><span>|</span><a href="#37396582">next</a><span>|</span><label class="collapse" for="c-37397584">[-]</label><label class="expand" for="c-37397584">[1 more]</label></div><br/><div class="children"><div class="content">Technically Blazor<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;aspnet&#x2F;core&#x2F;blazor&#x2F;host-and-deploy&#x2F;webassembly?view=aspnetcore-7.0" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;aspnet&#x2F;core&#x2F;blazor&#x2F;host-an...</a></div><br/></div></div><div id="37396582" class="c"><input type="checkbox" id="c-37396582" checked=""/><div class="controls bullet"><span class="by">Kennnan</span><span>|</span><a href="#37396483">parent</a><span>|</span><a href="#37397584">prev</a><span>|</span><a href="#37395280">next</a><span>|</span><label class="collapse" for="c-37396582">[-]</label><label class="expand" for="c-37396582">[2 more]</label></div><br/><div class="children"><div class="content">Hand written wasm is too low level to use a UI framework with, but there are rust frameworks that compile to wasm for web. For example, Yew and Leptos are both web-first frameworks, and there are a few such as Dioxus or wgpu that are native-first and work on web.</div><br/><div id="37399247" class="c"><input type="checkbox" id="c-37399247" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#37396483">root</a><span>|</span><a href="#37396582">parent</a><span>|</span><a href="#37395280">next</a><span>|</span><label class="collapse" for="c-37399247">[-]</label><label class="expand" for="c-37399247">[1 more]</label></div><br/><div class="children"><div class="content">What makes hand written WASM too &quot;low level&quot;?<p>It isn&#x27;t, really, what the Rust frameworks do is compile down to a specific interop, sure (JS + WASM, its not pure WASM due to lack of DOM access for starters).<p>That said, no reason a hand written WASM app isn&#x27;t feasible, with appropriate JS glue</div><br/></div></div></div></div></div></div><div id="37395280" class="c"><input type="checkbox" id="c-37395280" checked=""/><div class="controls bullet"><span class="by">syndicatedjelly</span><span>|</span><a href="#37396483">prev</a><span>|</span><a href="#37395432">next</a><span>|</span><label class="collapse" for="c-37395280">[-]</label><label class="expand" for="c-37395280">[4 more]</label></div><br/><div class="children"><div class="content">Gave WASM a try and ran into problems exposing connections to a SQLite database I wanted to connect to locally. Has anyone done something like that before and can point to good resources?</div><br/><div id="37396498" class="c"><input type="checkbox" id="c-37396498" checked=""/><div class="controls bullet"><span class="by">yebyen</span><span>|</span><a href="#37395280">parent</a><span>|</span><a href="#37395432">next</a><span>|</span><label class="collapse" for="c-37396498">[-]</label><label class="expand" for="c-37396498">[3 more]</label></div><br/><div class="children"><div class="content">Check out Spin! It includes sqlite support natively in the runtime since 1.4:<p><a href="https:&#x2F;&#x2F;www.fermyon.com&#x2F;blog&#x2F;spin-v14" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.fermyon.com&#x2F;blog&#x2F;spin-v14</a></div><br/><div id="37398271" class="c"><input type="checkbox" id="c-37398271" checked=""/><div class="controls bullet"><span class="by">syndicatedjelly</span><span>|</span><a href="#37395280">root</a><span>|</span><a href="#37396498">parent</a><span>|</span><a href="#37395432">next</a><span>|</span><label class="collapse" for="c-37398271">[-]</label><label class="expand" for="c-37398271">[2 more]</label></div><br/><div class="children"><div class="content">Looks like it’s only available for Python, I was hoping for a more language agnostic solution. Thanks though!</div><br/><div id="37398425" class="c"><input type="checkbox" id="c-37398425" checked=""/><div class="controls bullet"><span class="by">yebyen</span><span>|</span><a href="#37395280">root</a><span>|</span><a href="#37398271">parent</a><span>|</span><a href="#37395432">next</a><span>|</span><label class="collapse" for="c-37398425">[-]</label><label class="expand" for="c-37398425">[1 more]</label></div><br/><div class="children"><div class="content">It is? The docs example shows support for Rust, TypeScript, and Python:<p><a href="https:&#x2F;&#x2F;developer.fermyon.com&#x2F;spin&#x2F;sqlite-api-guide#using-sqlite-storage-from-applications" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.fermyon.com&#x2F;spin&#x2F;sqlite-api-guide#using-sq...</a><p>I&#x27;m not sure what holds back from being a completely language agnostic solution, but I know when I tried binding functions into my Ruby app with wasmer I had nothing but problems, I wound up using WASI exclusively to communicate with my WASM modules. I don&#x27;t honestly know how good the WASM language agnostic story is today. I gave a talk with my perspective as a Rubyist at OSS Summit and CDCon&#x2F;GitOpsCon a few months ago in Vancouver. The talk (and lightning talk variant) are called &quot;Exotic Runtime Targets: Ruby and Wasm on Kubernetes and GitOps Delivery Pipelines&quot;</div><br/></div></div></div></div></div></div></div></div><div id="37395432" class="c"><input type="checkbox" id="c-37395432" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#37395280">prev</a><span>|</span><a href="#37396595">next</a><span>|</span><label class="collapse" for="c-37395432">[-]</label><label class="expand" for="c-37395432">[9 more]</label></div><br/><div class="children"><div class="content">While it&#x27;s an interesting (and effective) approach to learn something, what is the point of learning WebAssembly? After all, I thought that WASM was supposed to be something like &quot;LLVM for web&quot;, a low-level IR for webdev languages to target and for browsers to execute efficiently, and not something that you&#x27;d write manually. Or am I wrong?</div><br/><div id="37395883" class="c"><input type="checkbox" id="c-37395883" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#37395432">parent</a><span>|</span><a href="#37395496">next</a><span>|</span><label class="collapse" for="c-37395883">[-]</label><label class="expand" for="c-37395883">[1 more]</label></div><br/><div class="children"><div class="content">Actually it is quite high level (with the GC extension even &quot;higher&quot; than C), not comparable to &quot;real&quot; assembler. It has types. It isn&#x27;t fun writing WAT, but for small stuff it&#x27;s perfectly doable.<p>That&#x27;s a record with 3 fields, its constructor and getters using the GC extension:<p><pre><code>    ;; A `struct` with 3 fields, all immutable.
    (type $testStruct
      (struct
        (field $first i64)
        (field $foo f32)
        (field $baz f64)))

     ;; Constructor. `ref` is a reference
     (func $mkTestStruct
       (param $a i64) (param $b f32) (param $c f64) (result (ref $testStruct))
        (struct.new $testStruct (local.get $a) (local.get $b) (local.get $c)))
     (export &quot;mkTestStruct&quot; (func $mkTestStruct))

     ;; Getter function for the three fields:

     (func $getTestStruct1 (param $rs (ref $testStruct)) (result i64)
       (struct.get $testStruct 0 (local.get $rs)))
     (export &quot;getTestStruct1&quot; (func $getTestStruct1))

     (func $getTestStruct2 (param $rs (ref $testStruct)) (result f32)
       (struct.get $testStruct 1 (local.get $rs)))
     (export &quot;getTestStruct2&quot; (func $getTestStruct2))

     (func $getTestStruct3 (param $rs (ref $testStruct)) (result f64)
       (struct.get $testStruct 2 (local.get $rs)))
     (export &quot;getTestStruct3&quot; (func $getTestStruct3))</code></pre></div><br/></div></div><div id="37395496" class="c"><input type="checkbox" id="c-37395496" checked=""/><div class="controls bullet"><span class="by">emnudge</span><span>|</span><a href="#37395432">parent</a><span>|</span><a href="#37395883">prev</a><span>|</span><a href="#37395540">next</a><span>|</span><label class="collapse" for="c-37395496">[-]</label><label class="expand" for="c-37395496">[2 more]</label></div><br/><div class="children"><div class="content">Author here!<p>My initial motivation to learn WASM (as someone from a primarily web background) was that I had a pretty poor understanding of WASM in general and so I had a lot of difficulty working with WASM builds in just about any capacity other than a heavy JS wrapper.<p>There are aspects to how WASM works that are quite different from other kinds of assembly formats that make learning the basics pretty important. e.g. how memory is requested, provided, grown. How functions are received and exported. Capabilities of tables.<p>A lot of this might be abstracted by massive wrappers, but you&#x27;re losing a lot in perf and debugability when using them.</div><br/><div id="37395630" class="c"><input type="checkbox" id="c-37395630" checked=""/><div class="controls bullet"><span class="by">wanderlust123</span><span>|</span><a href="#37395432">root</a><span>|</span><a href="#37395496">parent</a><span>|</span><a href="#37395540">next</a><span>|</span><label class="collapse" for="c-37395630">[-]</label><label class="expand" for="c-37395630">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for putting this together, I too learn best by doing, and this looks very helpful!</div><br/></div></div></div></div><div id="37395540" class="c"><input type="checkbox" id="c-37395540" checked=""/><div class="controls bullet"><span class="by">chrisco255</span><span>|</span><a href="#37395432">parent</a><span>|</span><a href="#37395496">prev</a><span>|</span><a href="#37396471">next</a><span>|</span><label class="collapse" for="c-37395540">[-]</label><label class="expand" for="c-37395540">[2 more]</label></div><br/><div class="children"><div class="content">Sometimes you may need to debug the actual wasm code or understand what the compiler is outputting. Depending on the flags you set during compilation, you may want to optimize for size of binary or for performance. You may also want to compare the wasm produced by two different languages or different versions of the language compiler. Maybe you want to verify what libraries are actually getting bundled with your wasm.</div><br/><div id="37396301" class="c"><input type="checkbox" id="c-37396301" checked=""/><div class="controls bullet"><span class="by">thamer</span><span>|</span><a href="#37395432">root</a><span>|</span><a href="#37395540">parent</a><span>|</span><a href="#37396471">next</a><span>|</span><label class="collapse" for="c-37396301">[-]</label><label class="expand" for="c-37396301">[1 more]</label></div><br/><div class="children"><div class="content">Understanding what the compiler outputs is also essential to debug the inevitable issues that come up when porting an existing program to WASM. Since it&#x27;s a different platform with significant limitations, it&#x27;s important to know how to replace some core APIs and capabilities and how to interface with these alternatives.<p>By limitations I mean things that a POSIX program would expect that aren&#x27;t generally available from WASM, like network programming, file system access, processes and threads, pipes and signals. Emscripten and WASI help to some extent, but the replacement APIs are rarely fully compatible.</div><br/></div></div></div></div><div id="37396471" class="c"><input type="checkbox" id="c-37396471" checked=""/><div class="controls bullet"><span class="by">__s</span><span>|</span><a href="#37395432">parent</a><span>|</span><a href="#37395540">prev</a><span>|</span><a href="#37395477">next</a><span>|</span><label class="collapse" for="c-37396471">[-]</label><label class="expand" for="c-37396471">[1 more]</label></div><br/><div class="children"><div class="content">For awhile I was using a raw wasm program for a game engine&#x27;s random number generator. Stored all the state in global variables, so no heap necessary<p>Eventually I moved the whole game engine into wasm &amp; at that point it all got ported to Rust<p><a href="https:&#x2F;&#x2F;github.com&#x2F;serprex&#x2F;openEtG&#x2F;blob&#x2F;8b7069cc52ec8db3406a69c8b6ac38a955b8dd16&#x2F;src&#x2F;rng.wat">https:&#x2F;&#x2F;github.com&#x2F;serprex&#x2F;openEtG&#x2F;blob&#x2F;8b7069cc52ec8db3406a...</a></div><br/></div></div><div id="37395477" class="c"><input type="checkbox" id="c-37395477" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#37395432">parent</a><span>|</span><a href="#37396471">prev</a><span>|</span><a href="#37395498">next</a><span>|</span><label class="collapse" for="c-37395477">[-]</label><label class="expand" for="c-37395477">[1 more]</label></div><br/><div class="children"><div class="content">Some reasons to understand the textual representation, besides curiousity:<p>You are embedding a WASM engine and want to better grok how the import or exporting works.<p>You are writing a compiler that targets WASM.</div><br/></div></div></div></div><div id="37396595" class="c"><input type="checkbox" id="c-37396595" checked=""/><div class="controls bullet"><span class="by">mdswanson</span><span>|</span><a href="#37395432">prev</a><span>|</span><a href="#37396931">next</a><span>|</span><label class="collapse" for="c-37396595">[-]</label><label class="expand" for="c-37396595">[5 more]</label></div><br/><div class="children"><div class="content">Is it just me, or does &quot;WebAssembly&quot; seem like an oxymoron? Maybe it&#x27;s because I&#x27;ve been involved with the web since its earliest beginnings.</div><br/><div id="37397089" class="c"><input type="checkbox" id="c-37397089" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#37396595">parent</a><span>|</span><a href="#37397975">next</a><span>|</span><label class="collapse" for="c-37397089">[-]</label><label class="expand" for="c-37397089">[2 more]</label></div><br/><div class="children"><div class="content">You might like this bit of speculative history: &lt;<a href="https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;the-birth-and-death-of-javascript" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;the-birth-and-death...</a>&gt;</div><br/><div id="37398507" class="c"><input type="checkbox" id="c-37398507" checked=""/><div class="controls bullet"><span class="by">mdswanson</span><span>|</span><a href="#37396595">root</a><span>|</span><a href="#37397089">parent</a><span>|</span><a href="#37397975">next</a><span>|</span><label class="collapse" for="c-37398507">[-]</label><label class="expand" for="c-37398507">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! That was fun. I hadn&#x27;t seen it. There&#x27;s the problem of bootstrapping METAL, but perhaps left for a different lecture! ;-)</div><br/></div></div></div></div><div id="37397975" class="c"><input type="checkbox" id="c-37397975" checked=""/><div class="controls bullet"><span class="by">patmorgan23</span><span>|</span><a href="#37396595">parent</a><span>|</span><a href="#37397089">prev</a><span>|</span><a href="#37396600">next</a><span>|</span><label class="collapse" for="c-37397975">[-]</label><label class="expand" for="c-37397975">[1 more]</label></div><br/><div class="children"><div class="content">I mean technically it&#x27;s browser VM bytecode by it&#x27;s semantics.</div><br/></div></div></div></div></div></div></div></div></div></body></html>