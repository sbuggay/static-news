<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712307649518" as="style"/><link rel="stylesheet" href="styles.css?v=1712307649518"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://xr0.dev/">Xr0: C but Safe</a> <span class="domain">(<a href="https://xr0.dev">xr0.dev</a>)</span></div><div class="subtext"><span>synergy20</span> | <span>77 comments</span></div><br/><div><div id="39940050" class="c"><input type="checkbox" id="c-39940050" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#39936970">next</a><span>|</span><label class="collapse" for="c-39940050">[-]</label><label class="expand" for="c-39940050">[2 more]</label></div><br/><div class="children"><div class="content">It is quite interesting, but it seems to fail with even very simple examples:<p><pre><code>  void x() {
   int * p;
   p = malloc(1);
   if(0) {
      free(p);
   } else {
      free(p);
   }
  }

  0v: src&#x2F;ast&#x2F;stmt&#x2F;verify.c:228: stmt_sel_exec: Assertion `!ast_stmt_sel_nest(stmt)&#x27; failed.</code></pre></div><br/><div id="39940109" class="c"><input type="checkbox" id="c-39940109" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39940050">parent</a><span>|</span><a href="#39936970">next</a><span>|</span><label class="collapse" for="c-39940109">[-]</label><label class="expand" for="c-39940109">[1 more]</label></div><br/><div class="children"><div class="content">To be fair if the program never runs it’s 100% safe.</div><br/></div></div></div></div><div id="39936970" class="c"><input type="checkbox" id="c-39936970" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#39940050">prev</a><span>|</span><a href="#39937339">next</a><span>|</span><label class="collapse" for="c-39936970">[-]</label><label class="expand" for="c-39936970">[4 more]</label></div><br/><div class="children"><div class="content">Homepage seems to focus mostly on temporal memory safety; there isn&#x27;t much said about spatial memory safety or memory-safe-but-unsound primitives, like type confusion.<p>These should be table stakes when talking about &quot;safe&quot; languages (or subsets thereof); I hope these authors have or propose plans for these classes as well!<p>(I agree with the more general critique here, that any adaptation invasive enough to provide these properties in C might as well be its own programming language.)</div><br/><div id="39939583" class="c"><input type="checkbox" id="c-39939583" checked=""/><div class="controls bullet"><span class="by">adamrezich</span><span>|</span><a href="#39936970">parent</a><span>|</span><a href="#39937339">next</a><span>|</span><label class="collapse" for="c-39939583">[-]</label><label class="expand" for="c-39939583">[3 more]</label></div><br/><div class="children"><div class="content">There is no universally-accepted definition for the term &quot;safe&quot; as it applies to programming languages.</div><br/><div id="39939985" class="c"><input type="checkbox" id="c-39939985" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#39936970">root</a><span>|</span><a href="#39939583">parent</a><span>|</span><a href="#39940030">next</a><span>|</span><label class="collapse" for="c-39939985">[-]</label><label class="expand" for="c-39939985">[1 more]</label></div><br/><div class="children"><div class="content">While we can of course always bikeshed the minutiae, memory safety is a fairly well accepted and well defined term. And so are temporal and spatial safety  (as subsets of memory safety).<p>I would add that temporal safety is significantly harder than spatial safety (spatial safety is only hard in C if you do not want to break the ABI), so it is nice that this project is focusing on it.</div><br/></div></div><div id="39940030" class="c"><input type="checkbox" id="c-39940030" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#39936970">root</a><span>|</span><a href="#39939583">parent</a><span>|</span><a href="#39939985">prev</a><span>|</span><a href="#39937339">next</a><span>|</span><label class="collapse" for="c-39940030">[-]</label><label class="expand" for="c-39940030">[1 more]</label></div><br/><div class="children"><div class="content">True and yet useless. When &quot;that&#x27;s not safe&quot; turns into a &quot;discussion&quot; about what safety means (e.g. at basically every C++ conference for over a year) what that signals is that you&#x27;re much more interested in preserving the status quo than improving safety.</div><br/></div></div></div></div></div></div><div id="39937339" class="c"><input type="checkbox" id="c-39937339" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#39936970">prev</a><span>|</span><a href="#39939626">next</a><span>|</span><label class="collapse" for="c-39937339">[-]</label><label class="expand" for="c-39937339">[3 more]</label></div><br/><div class="children"><div class="content">What about data races?<p>(I can&#x27;t find anything about it in this page)<p>Avoiding UB in single threaded programs is the easy part. It&#x27;s harder for a low level language like C, but not too hard.<p>But avoiding UB in multithreaded programs is very very hard. Many &quot;safe&quot; managed languages have UB when you misuse synchronization mechanisms, like Go.<p>Some languages Java and OCaml manage to avoid UB when you have data races. They do so by disallowing some compiler optimizations. OCaml is the better one in this regard (see the paper &quot;bounding data races in time and space&quot;)</div><br/><div id="39939915" class="c"><input type="checkbox" id="c-39939915" checked=""/><div class="controls bullet"><span class="by">betz47</span><span>|</span><a href="#39937339">parent</a><span>|</span><a href="#39939626">next</a><span>|</span><label class="collapse" for="c-39939915">[-]</label><label class="expand" for="c-39939915">[2 more]</label></div><br/><div class="children"><div class="content">Xr0 is currently targeting the c89 spec and working up from there, thread safety is something that we would address in C11 (See a previous discussion here <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39858240#39858813">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39858240#39858813</a>).</div><br/><div id="39940020" class="c"><input type="checkbox" id="c-39940020" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#39937339">root</a><span>|</span><a href="#39939915">parent</a><span>|</span><a href="#39939626">next</a><span>|</span><label class="collapse" for="c-39940020">[-]</label><label class="expand" for="c-39940020">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exciting!<p>Is there any proposal or rough ideas or musings or anything that might suggest how Xr0 could possibly guarantee data race freedom?<p>Would it be something like Rust&#x27;s Send &amp; Sync traits? Or something else entirely?</div><br/></div></div></div></div></div></div><div id="39937176" class="c"><input type="checkbox" id="c-39937176" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39939626">prev</a><span>|</span><a href="#39939800">next</a><span>|</span><label class="collapse" for="c-39937176">[-]</label><label class="expand" for="c-39937176">[1 more]</label></div><br/><div class="children"><div class="content">They need a guide to compare it frama-c and other systems with annotations. Or at least compare what the objective ultimately will be, since this is still in its infancy.</div><br/></div></div><div id="39939800" class="c"><input type="checkbox" id="c-39939800" checked=""/><div class="controls bullet"><span class="by">compressedgas</span><span>|</span><a href="#39937176">prev</a><span>|</span><a href="#39936987">next</a><span>|</span><label class="collapse" for="c-39939800">[-]</label><label class="expand" for="c-39939800">[2 more]</label></div><br/><div class="children"><div class="content">Looks like it&#x27;s a C version of Dafny.</div><br/><div id="39939898" class="c"><input type="checkbox" id="c-39939898" checked=""/><div class="controls bullet"><span class="by">akiarie</span><span>|</span><a href="#39939800">parent</a><span>|</span><a href="#39936987">next</a><span>|</span><label class="collapse" for="c-39939898">[-]</label><label class="expand" for="c-39939898">[1 more]</label></div><br/><div class="children"><div class="content">A lot of truth to this. (Speaking as one of the creators of Xr0).</div><br/></div></div></div></div><div id="39936987" class="c"><input type="checkbox" id="c-39936987" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39939800">prev</a><span>|</span><a href="#39936835">next</a><span>|</span><label class="collapse" for="c-39936987">[-]</label><label class="expand" for="c-39936987">[2 more]</label></div><br/><div class="children"><div class="content">Posted last week: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39858240">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39858240</a></div><br/><div id="39938943" class="c"><input type="checkbox" id="c-39938943" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39936987">parent</a><span>|</span><a href="#39936835">next</a><span>|</span><label class="collapse" for="c-39938943">[-]</label><label class="expand" for="c-39938943">[1 more]</label></div><br/><div class="children"><div class="content">That thread only spent 18 minutes on HN&#x27;s front page, perhaps because of the baity title, so it&#x27;s probably ok to have another go.</div><br/></div></div></div></div><div id="39936835" class="c"><input type="checkbox" id="c-39936835" checked=""/><div class="controls bullet"><span class="by">jnwatson</span><span>|</span><a href="#39936987">prev</a><span>|</span><a href="#39936749">next</a><span>|</span><label class="collapse" for="c-39936835">[-]</label><label class="expand" for="c-39936835">[25 more]</label></div><br/><div class="children"><div class="content">The problem with the safe C subsets is that it means you have to write new code.  But if you have to write new code, why would you do it in C?</div><br/><div id="39940053" class="c"><input type="checkbox" id="c-39940053" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39936835">parent</a><span>|</span><a href="#39938492">next</a><span>|</span><label class="collapse" for="c-39940053">[-]</label><label class="expand" for="c-39940053">[1 more]</label></div><br/><div class="children"><div class="content">Most of the proposals I&#x27;ve seen so far work via annotating existing code, not complete rewrites (e.g. here&#x27;s one example from Apple: <a href="https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-c-fbounds-safety&#x2F;70854" rel="nofollow">https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-enforcing-bounds-safety-in-...</a>)</div><br/></div></div><div id="39938492" class="c"><input type="checkbox" id="c-39938492" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#39936835">parent</a><span>|</span><a href="#39940053">prev</a><span>|</span><a href="#39936952">next</a><span>|</span><label class="collapse" for="c-39938492">[-]</label><label class="expand" for="c-39938492">[2 more]</label></div><br/><div class="children"><div class="content">You wouldn&#x27;t - you&#x27;d write it in the safe C subset?<p>Presumably it&#x27;s easier to rewrite part of your app rather than the whole thing.<p>But I&#x27;m all for a safe version of C17 (or C23&#x2F;24). It&#x27;s so disappointing that there isn&#x27;t a standard memory-safe compiler&#x2F;runtime&#x2F;ABI. (And while they&#x27;re at it, the stack should grow up rather than down.)<p>Perhaps CHERI or similar will catch on someday. Maybe Apple could try implementing memory checking for clang and Apple Silicon.</div><br/><div id="39939013" class="c"><input type="checkbox" id="c-39939013" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39938492">parent</a><span>|</span><a href="#39936952">next</a><span>|</span><label class="collapse" for="c-39939013">[-]</label><label class="expand" for="c-39939013">[1 more]</label></div><br/><div class="children"><div class="content">I am currently working on a GCC frontend that has a memory safe mode where it would warn about every unsafe constructs.  At the same time a trying on modifying some of my projects to work with it.  To me, this seems an entirely reasonable approach.  But it is a spare time project, so progressing slowly.</div><br/></div></div></div></div><div id="39936952" class="c"><input type="checkbox" id="c-39936952" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#39936835">parent</a><span>|</span><a href="#39938492">prev</a><span>|</span><a href="#39937157">next</a><span>|</span><label class="collapse" for="c-39936952">[-]</label><label class="expand" for="c-39936952">[7 more]</label></div><br/><div class="children"><div class="content">A bit unfair. It verifies a subset of C because it is incomplete.<p>It looks as though the idea is that you can annotate existing code, which is a lot easier than rewriting.</div><br/><div id="39937200" class="c"><input type="checkbox" id="c-39937200" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39936952">parent</a><span>|</span><a href="#39937157">next</a><span>|</span><label class="collapse" for="c-39937200">[-]</label><label class="expand" for="c-39937200">[6 more]</label></div><br/><div class="children"><div class="content">You have to understand the code at a level sufficient to make accurate annotations, which isn&#x27;t that much easier. And you&#x27;re not getting as much safety bang for your buck for the effort as you would in a rewrite in actually safe language.</div><br/><div id="39937511" class="c"><input type="checkbox" id="c-39937511" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39937200">parent</a><span>|</span><a href="#39940081">next</a><span>|</span><label class="collapse" for="c-39937511">[-]</label><label class="expand" for="c-39937511">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You have to understand the code at a level sufficient to make accurate annotations, which isn&#x27;t that much easier<p>That&#x27;s not necessarily true though.<p>Half decent C code already has a coherent memory management strategy. The problem is that humans can&#x27;t follow even pretty straight-forward memory management strategies 100% of the time. If you have a function that returns memory the caller is required to free, or accepts a parameter that the function takes ownership of, that can be easily expressed but hard to get right every time.<p>In fact, functions typically document this... in half-decent C code. So we&#x27;re really talking about formalizing the expression of memory management documentation that already exists and is already understood.<p>&gt; And you&#x27;re not getting as much safety bang for your buck for the effort as you would in a rewrite in actually safe language.<p>I just can&#x27;t think of what the rational argument for this could be. A complete deep rewrite -- where the new language requires reorganizing the code at a low level so that a lot of existing logic cannot be reused (as-is, or transformed in certain specific ways) -- is extremely costly. It is on the order of the total cost of writing the software in the first place plus the entire cost already spent maintaining it over time. Some costs -- like the goodwill of users&#x2F;adpoters -- simply cannot be paid again at the same rate. For large scale software there would be numerous regressions over a long period of time, while at the same time the software stops adding many new features, since all the focus will on the rewrite and bugs related to the rewrite. I will stand corrected if there is more than one or two exceptional cases of large scale software making a successful transition of this sort without paying a massive cost.</div><br/></div></div><div id="39940081" class="c"><input type="checkbox" id="c-39940081" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39937200">parent</a><span>|</span><a href="#39937511">prev</a><span>|</span><a href="#39939428">next</a><span>|</span><label class="collapse" for="c-39940081">[-]</label><label class="expand" for="c-39940081">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still better than a complete rewrite, which will very likely introduce new bugs that had already been fixed in the existing code (no matter what languages are used).</div><br/></div></div><div id="39939428" class="c"><input type="checkbox" id="c-39939428" checked=""/><div class="controls bullet"><span class="by">awaythrow999</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39937200">parent</a><span>|</span><a href="#39940081">prev</a><span>|</span><a href="#39939076">next</a><span>|</span><label class="collapse" for="c-39939428">[-]</label><label class="expand" for="c-39939428">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; understand the code at a level sufficient to make accurate annotations, which isn&#x27;t that much easier. And you&#x27;re not getting as much safety bang for your buck for the effort as you would in a rewrite in<p>But rewriting assumes I learn a new language on top of rewriting.</div><br/></div></div><div id="39939076" class="c"><input type="checkbox" id="c-39939076" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39937200">parent</a><span>|</span><a href="#39939428">prev</a><span>|</span><a href="#39938227">next</a><span>|</span><label class="collapse" for="c-39939076">[-]</label><label class="expand" for="c-39939076">[1 more]</label></div><br/><div class="children"><div class="content">You certainly could get the same level of safety via annotations as you can in safe language. And if you transition existing code, you do not need to rewrite that will introduce new bugs and invalidate all the testing.</div><br/></div></div><div id="39938227" class="c"><input type="checkbox" id="c-39938227" checked=""/><div class="controls bullet"><span class="by">DougN7</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39937200">parent</a><span>|</span><a href="#39939076">prev</a><span>|</span><a href="#39937157">next</a><span>|</span><label class="collapse" for="c-39938227">[-]</label><label class="expand" for="c-39938227">[1 more]</label></div><br/><div class="children"><div class="content">If you don’t understand the code well enough to annotate it, it seems hard to believe you’d able to rewrite it and end up with the same functionality (same processing rules, accepts identical input, produces identical output, etc).</div><br/></div></div></div></div></div></div><div id="39937157" class="c"><input type="checkbox" id="c-39937157" checked=""/><div class="controls bullet"><span class="by">ironmagma</span><span>|</span><a href="#39936835">parent</a><span>|</span><a href="#39936952">prev</a><span>|</span><a href="#39937318">next</a><span>|</span><label class="collapse" for="c-39937157">[-]</label><label class="expand" for="c-39937157">[2 more]</label></div><br/><div class="children"><div class="content">A lot of times, C is the only option, for example in embedded scenarios where the vendor&#x27;s C compiler is the only way of compiling for that platform.</div><br/><div id="39939618" class="c"><input type="checkbox" id="c-39939618" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39937157">parent</a><span>|</span><a href="#39937318">next</a><span>|</span><label class="collapse" for="c-39939618">[-]</label><label class="expand" for="c-39939618">[1 more]</label></div><br/><div class="children"><div class="content">That just means you need a whatever-to-C transpiler. Which in most cases is quite achievable, and especially so if the language is designed to allow that (so e.g. no guaranteed tail call optimizations etc).</div><br/></div></div></div></div><div id="39937318" class="c"><input type="checkbox" id="c-39937318" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#39936835">parent</a><span>|</span><a href="#39937157">prev</a><span>|</span><a href="#39937296">next</a><span>|</span><label class="collapse" for="c-39937318">[-]</label><label class="expand" for="c-39937318">[1 more]</label></div><br/><div class="children"><div class="content">The problem with black-and-white thinking is that it&#x27;s too simplistic to apply to the great majority of real-world problems.<p>Safe C provides an incremental migration path from unsafe C to safe C. And you don&#x27;t need to completely rewrite, but instead address the issues flagged, which will often be a lot less work and risk than an actual rewrite in a new language. (This seems obvious to me, but apparently not?)</div><br/></div></div><div id="39937296" class="c"><input type="checkbox" id="c-39937296" checked=""/><div class="controls bullet"><span class="by">mofosyne</span><span>|</span><a href="#39936835">parent</a><span>|</span><a href="#39937318">prev</a><span>|</span><a href="#39937163">next</a><span>|</span><label class="collapse" for="c-39937296">[-]</label><label class="expand" for="c-39937296">[2 more]</label></div><br/><div class="children"><div class="content">It could be helpful if the annotation can be stripped out if needed for use with older compilers (especially important for older microprocessors that won&#x27;t ever have it&#x27;s C compiler ported).</div><br/><div id="39939839" class="c"><input type="checkbox" id="c-39939839" checked=""/><div class="controls bullet"><span class="by">betz47</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39937296">parent</a><span>|</span><a href="#39937163">next</a><span>|</span><label class="collapse" for="c-39939839">[-]</label><label class="expand" for="c-39939839">[1 more]</label></div><br/><div class="children"><div class="content">Xr0 currently works this way, the annotations can be stripped out with a &quot;-s&quot; flag (See here <a href="https:&#x2F;&#x2F;xr0.dev&#x2F;learn#compiling" rel="nofollow">https:&#x2F;&#x2F;xr0.dev&#x2F;learn#compiling</a>)</div><br/></div></div></div></div><div id="39936968" class="c"><input type="checkbox" id="c-39936968" checked=""/><div class="controls bullet"><span class="by">infamouscow</span><span>|</span><a href="#39936835">parent</a><span>|</span><a href="#39937163">prev</a><span>|</span><a href="#39937300">next</a><span>|</span><label class="collapse" for="c-39936968">[-]</label><label class="expand" for="c-39936968">[2 more]</label></div><br/><div class="children"><div class="content">Despite being 2024, there&#x27;s still has not been any progress on taste.</div><br/><div id="39937250" class="c"><input type="checkbox" id="c-39937250" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39936968">parent</a><span>|</span><a href="#39937300">next</a><span>|</span><label class="collapse" for="c-39937250">[-]</label><label class="expand" for="c-39937250">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s been regress!</div><br/></div></div></div></div><div id="39937300" class="c"><input type="checkbox" id="c-39937300" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#39936835">parent</a><span>|</span><a href="#39936968">prev</a><span>|</span><a href="#39937835">next</a><span>|</span><label class="collapse" for="c-39937300">[-]</label><label class="expand" for="c-39937300">[1 more]</label></div><br/><div class="children"><div class="content">Less ceremony than Rust (and no ball-breaking fighting the borrow checker), a lot faster than Go, way more mature than Zig, and with more immediate compatibility with tons of code, more support, more developers, and more mature compilers than any of the above.</div><br/></div></div><div id="39937835" class="c"><input type="checkbox" id="c-39937835" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#39936835">parent</a><span>|</span><a href="#39937300">prev</a><span>|</span><a href="#39936749">next</a><span>|</span><label class="collapse" for="c-39937835">[-]</label><label class="expand" for="c-39937835">[5 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t like C, you don&#x27;t need to come into threads about C. HN is not for ideological battle.<p>Would you go into a thread about emacs and say, &quot;Why would anyone use emacs over vi?&quot; And if not, what makes you think you should do that here?</div><br/><div id="39938009" class="c"><input type="checkbox" id="c-39938009" checked=""/><div class="controls bullet"><span class="by">twiceaday</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39937835">parent</a><span>|</span><a href="#39936749">next</a><span>|</span><label class="collapse" for="c-39938009">[-]</label><label class="expand" for="c-39938009">[4 more]</label></div><br/><div class="children"><div class="content">I understand both perspectives. The premise should be questioned, a correct amount. &quot;Do not question our premise&quot; is a weird take.</div><br/><div id="39938023" class="c"><input type="checkbox" id="c-39938023" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39938009">parent</a><span>|</span><a href="#39936749">next</a><span>|</span><label class="collapse" for="c-39938023">[-]</label><label class="expand" for="c-39938023">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not objecting to &quot;the problem with the safe C subsets....&quot;<p>I&#x27;m objecting to the disdainful &quot;why would you do it in C?&quot;</div><br/><div id="39938177" class="c"><input type="checkbox" id="c-39938177" checked=""/><div class="controls bullet"><span class="by">twiceaday</span><span>|</span><a href="#39936835">root</a><span>|</span><a href="#39938023">parent</a><span>|</span><a href="#39936749">next</a><span>|</span><label class="collapse" for="c-39938177">[-]</label><label class="expand" for="c-39938177">[2 more]</label></div><br/><div class="children"><div class="content">You didn&#x27;t ask him to clarify, you asked him to leave.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39936749" class="c"><input type="checkbox" id="c-39936749" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39936835">prev</a><span>|</span><a href="#39936873">next</a><span>|</span><label class="collapse" for="c-39936749">[-]</label><label class="expand" for="c-39936749">[8 more]</label></div><br/><div class="children"><div class="content">Nice.<p>Are any of the many &quot;safe versions of C&quot; getting any traction? There have been so many. It&#x27;s not a technical problem. It&#x27;s a mindshare problem.<p>The future in this area may be something that takes in existing C code and uses a LLM to recognize idioms and annotate. Without some automated way to convert legacy code, this isn&#x27;t going to happen.<p>(One big problem with converting to Rust is that Rust&#x27;s data model is so far from C&#x2F;C++ that you can&#x27;t really convert much existing code. You have to rethink the design to fit the affine type model. That&#x27;s hard.)</div><br/><div id="39937147" class="c"><input type="checkbox" id="c-39937147" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39936749">parent</a><span>|</span><a href="#39939080">next</a><span>|</span><label class="collapse" for="c-39937147">[-]</label><label class="expand" for="c-39937147">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m attempting something.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Gij9UQy_JEQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Gij9UQy_JEQ</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge&#x2F;blob&#x2F;deluge&#x2F;Manifesto.md">https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge&#x2F;blob&#x2F;delug...</a><p>Right now I&#x27;m ~90% through a major rewrite to use GC instead of isoheaps, because then I&#x27;ll go from rewrite-a-bit (Fil-C previously required malloc calls to be annotated and for some unions to be changed) to rewrite-nothing (malloc will Just Work and so will unions).<p>I hope there are others also trying various alternatives. It&#x27;s too soon for most of these things to tell what traction they may or may not get.</div><br/><div id="39938374" class="c"><input type="checkbox" id="c-39938374" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39936749">root</a><span>|</span><a href="#39937147">parent</a><span>|</span><a href="#39939575">next</a><span>|</span><label class="collapse" for="c-39938374">[-]</label><label class="expand" for="c-39938374">[1 more]</label></div><br/><div class="children"><div class="content">That seems to be a &quot;fat pointer&quot; scheme, like the one GCC used to have. (Is it still in GCC?)</div><br/></div></div><div id="39939575" class="c"><input type="checkbox" id="c-39939575" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#39936749">root</a><span>|</span><a href="#39937147">parent</a><span>|</span><a href="#39938374">prev</a><span>|</span><a href="#39939080">next</a><span>|</span><label class="collapse" for="c-39939575">[-]</label><label class="expand" for="c-39939575">[1 more]</label></div><br/><div class="children"><div class="content">Talking about malloc always reminds me of this paper the discusses delaying popping the stack to return temporary objects.<p><a href="https:&#x2F;&#x2F;www.cs.purdue.edu&#x2F;homes&#x2F;rompf&#x2F;papers&#x2F;xhebraj-ecoop22.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.purdue.edu&#x2F;homes&#x2F;rompf&#x2F;papers&#x2F;xhebraj-ecoop22...</a></div><br/></div></div></div></div><div id="39939080" class="c"><input type="checkbox" id="c-39939080" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#39936749">parent</a><span>|</span><a href="#39937147">prev</a><span>|</span><a href="#39937292">next</a><span>|</span><label class="collapse" for="c-39939080">[-]</label><label class="expand" for="c-39939080">[1 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s data model diverged from C++, but it&#x27;s not very far from C. It&#x27;s easy enough to write C-compatible structs and functions in Rust, as long as you don&#x27;t need `Drop`. Even tagged unions (data carrying enums) are supported to some degree.</div><br/></div></div><div id="39937292" class="c"><input type="checkbox" id="c-39937292" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#39936749">parent</a><span>|</span><a href="#39939080">prev</a><span>|</span><a href="#39939505">next</a><span>|</span><label class="collapse" for="c-39937292">[-]</label><label class="expand" for="c-39937292">[2 more]</label></div><br/><div class="children"><div class="content">Rust isn&#x27;t the only game in town. You can convert to Ada.</div><br/><div id="39940110" class="c"><input type="checkbox" id="c-39940110" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#39936749">root</a><span>|</span><a href="#39937292">parent</a><span>|</span><a href="#39939505">next</a><span>|</span><label class="collapse" for="c-39940110">[-]</label><label class="expand" for="c-39940110">[1 more]</label></div><br/><div class="children"><div class="content">Right. Eiffel may be another option. Both Ada and Eiffel emphasize and support good software engineering practices.</div><br/></div></div></div></div><div id="39939505" class="c"><input type="checkbox" id="c-39939505" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#39936749">parent</a><span>|</span><a href="#39937292">prev</a><span>|</span><a href="#39936873">next</a><span>|</span><label class="collapse" for="c-39939505">[-]</label><label class="expand" for="c-39939505">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (One big problem with converting to Rust is that Rust&#x27;s data model is so far from C&#x2F;C++ that you can&#x27;t really convert much existing code. You have to rethink the design to fit the affine type model. That&#x27;s hard.)<p>True, but that&#x27;s likely going to be the case as well to convert to any ”safe version of C” as well, because in the general case the safety of a C program is undecidable: to make it safe, you have to restrict it to a subset of behaviors that can be statically proven as safe, and the borrow checker and “Rust&#x27;s data model” is just that.</div><br/></div></div></div></div><div id="39936873" class="c"><input type="checkbox" id="c-39936873" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#39936749">prev</a><span>|</span><a href="#39937351">next</a><span>|</span><label class="collapse" for="c-39936873">[-]</label><label class="expand" for="c-39936873">[3 more]</label></div><br/><div class="children"><div class="content">C has a minimal, interpreted, safe, functional language embeded into it. You just have to execute it with cc -P -E, no need to run any fancy generated binary.</div><br/><div id="39937245" class="c"><input type="checkbox" id="c-39937245" checked=""/><div class="controls bullet"><span class="by">incanus77</span><span>|</span><a href="#39936873">parent</a><span>|</span><a href="#39937351">next</a><span>|</span><label class="collapse" for="c-39937245">[-]</label><label class="expand" for="c-39937245">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re talking about GCC, I wonder if you can say more about this? I mean, I see the options, but I&#x27;m not entirely following.<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Preprocessor-Options.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Preprocessor-Options.html</a></div><br/><div id="39938041" class="c"><input type="checkbox" id="c-39938041" checked=""/><div class="controls bullet"><span class="by">moron4hire</span><span>|</span><a href="#39936873">root</a><span>|</span><a href="#39937245">parent</a><span>|</span><a href="#39937351">next</a><span>|</span><label class="collapse" for="c-39938041">[-]</label><label class="expand" for="c-39938041">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a joke about coding in just the preprocessor</div><br/></div></div></div></div></div></div><div id="39936484" class="c"><input type="checkbox" id="c-39936484" checked=""/><div class="controls bullet"><span class="by">FrankWilhoit</span><span>|</span><a href="#39937476">prev</a><span>|</span><label class="collapse" for="c-39936484">[-]</label><label class="expand" for="c-39936484">[19 more]</label></div><br/><div class="children"><div class="content">This is one way to go; but the only &quot;problem&quot; with C is management&#x27;s expectation that production software can be written by people who have only half learned the language, and that is a problem irrespective of which language we are talking about.</div><br/><div id="39936834" class="c"><input type="checkbox" id="c-39936834" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#39936484">parent</a><span>|</span><a href="#39937330">next</a><span>|</span><label class="collapse" for="c-39936834">[-]</label><label class="expand" for="c-39936834">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think knowledge of the language is the issue with C, it&#x27;s the fact that it requires a huge amount of diligence to not have security issues. Knowing the nooks and crannies of the language doesn&#x27;t really help with that.</div><br/><div id="39936863" class="c"><input type="checkbox" id="c-39936863" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#39936484">root</a><span>|</span><a href="#39936834">parent</a><span>|</span><a href="#39937330">next</a><span>|</span><label class="collapse" for="c-39936863">[-]</label><label class="expand" for="c-39936863">[2 more]</label></div><br/><div class="children"><div class="content">Made worse by the fact that most people don&#x27;t work with it or get taught it as much as 25 years ago.  A dev who has come up in the last decade or more, the typical C experience they have is writing it poorly for college.  They&#x27;re not typically battle-hardened on it, few people learn the best practices anymore.  But when existing code doesn&#x27;t suit a need they still might be tasked with maintaining something or fixing bugs.</div><br/></div></div></div></div><div id="39937330" class="c"><input type="checkbox" id="c-39937330" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#39936484">parent</a><span>|</span><a href="#39936834">prev</a><span>|</span><a href="#39936899">next</a><span>|</span><label class="collapse" for="c-39937330">[-]</label><label class="expand" for="c-39937330">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>the only &quot;problem&quot; with C is management&#x27;s expectation that production software can be written by people who have only half learned the language, and that is a problem irrespective of which language we are talking about.</i><p>Obviously that&#x27;s not &quot;the only problem&quot;, else there wouldn&#x27;t be huge style guides forbidding tons of practices to make programs safe for NASA and other such uses, aimed at the expert C programmers hired there.<p>Also obviously that is not &quot;a problem irrespective of which language we are talking about&quot;, unless half-knowing the language has the same impact and the language have the same footguns, which is nowhere near true for other languages versus C. You can &quot;half know&quot; Java and not ever get a buffer overflow. You can know C quite well and still get all kinds of dangerous bugs into the code.</div><br/></div></div><div id="39936899" class="c"><input type="checkbox" id="c-39936899" checked=""/><div class="controls bullet"><span class="by">overgard</span><span>|</span><a href="#39936484">parent</a><span>|</span><a href="#39937330">prev</a><span>|</span><a href="#39939361">next</a><span>|</span><label class="collapse" for="c-39936899">[-]</label><label class="expand" for="c-39936899">[2 more]</label></div><br/><div class="children"><div class="content">Outside of tiny languages though, pretty much nobody knows the &quot;whole&quot; language. Almost every production language has a ton of quirks that can surprise people who have been using a language for years.</div><br/><div id="39937137" class="c"><input type="checkbox" id="c-39937137" checked=""/><div class="controls bullet"><span class="by">HideousKojima</span><span>|</span><a href="#39936484">root</a><span>|</span><a href="#39936899">parent</a><span>|</span><a href="#39939361">next</a><span>|</span><label class="collapse" for="c-39937137">[-]</label><label class="expand" for="c-39937137">[1 more]</label></div><br/><div class="children"><div class="content">And frankly large numbers of features in languages aren&#x27;t needed by most devs. Marshalling in C#, for example, isn&#x27;t needed unless you&#x27;re calling into native code. Making raw syscalls in Rust isn&#x27;t needed unless you&#x27;re working on optimizing some low level systems code.</div><br/></div></div></div></div><div id="39939361" class="c"><input type="checkbox" id="c-39939361" checked=""/><div class="controls bullet"><span class="by">cultofmetatron</span><span>|</span><a href="#39936484">parent</a><span>|</span><a href="#39936899">prev</a><span>|</span><a href="#39936742">next</a><span>|</span><label class="collapse" for="c-39939361">[-]</label><label class="expand" for="c-39939361">[1 more]</label></div><br/><div class="children"><div class="content">it takes literal years for someone to get to a point where they can ship proper c code and the process of getting good requires shipping c code when you don&#x27;t know everything yet. having a system that automates and enforces years of collective knowledge on juniors is great and lets them contribute while they acquire experience.</div><br/></div></div><div id="39936742" class="c"><input type="checkbox" id="c-39936742" checked=""/><div class="controls bullet"><span class="by">stephencanon</span><span>|</span><a href="#39936484">parent</a><span>|</span><a href="#39939361">prev</a><span>|</span><a href="#39936799">next</a><span>|</span><label class="collapse" for="c-39936742">[-]</label><label class="expand" for="c-39936742">[7 more]</label></div><br/><div class="children"><div class="content">There’s also engineers’ belief that they have learned the language despite only half-knowing it at best.</div><br/><div id="39936919" class="c"><input type="checkbox" id="c-39936919" checked=""/><div class="controls bullet"><span class="by">mtklein</span><span>|</span><a href="#39936484">root</a><span>|</span><a href="#39936742">parent</a><span>|</span><a href="#39936799">next</a><span>|</span><label class="collapse" for="c-39936919">[-]</label><label class="expand" for="c-39936919">[6 more]</label></div><br/><div class="children"><div class="content">I think this is actually one of the selling points of C over other languages.  Certainly it&#x27;s easy to fool yourself into thinking you know any language better than you do, but C genuinely is relatively tiny, and I think it&#x27;s reasonable to expect to become familiar with almost everything in the language in a month or so of full-time work.  After a decade of day job C++ coding, I&#x27;d not say the same for myself there.<p>Rust and C++ lately have been particularly quickly moving targets to keep up with, where C is still pretty much the same as C99.  The compilers are better, their warnings are better, sanitizer modes are incredible, but the things you type into your text editor to express your program structure are still pretty much the same thing.</div><br/><div id="39937247" class="c"><input type="checkbox" id="c-39937247" checked=""/><div class="controls bullet"><span class="by">mtklein</span><span>|</span><a href="#39936484">root</a><span>|</span><a href="#39936919">parent</a><span>|</span><a href="#39939680">next</a><span>|</span><label class="collapse" for="c-39937247">[-]</label><label class="expand" for="c-39937247">[1 more]</label></div><br/><div class="children"><div class="content">I could have been more precise when I said it&#x27;s easy to fool yourself into thinking you know _any_ language better than you do... both rustc and ghc have made it abundantly and repeatedly clear that I don&#x27;t know Rust and Haskell well, and the &quot;if it compiles, it&#x27;s probably correct&quot; trust that develops from that frustration is a great asset to both those languages.<p>But those are exceptions: I&#x27;ve definitely felt like I&#x27;ve known more than I really did about at least C, C++, Java, Scheme, Python, Go, bash, Javascript, cron, and several assembly variants, and those platforms did little to stop me from learning about my inexperience in difficult, sometimes embarrassing, sometimes expensive ways.<p>I&#x27;m a big fan of more compile time analysis any way it can be done, and whatever can&#x27;t at runtime.  More types, more proofs, more fuzzing, more sanitizers, and also where possible, more restricted execution models than Turing-complete.  Any code that can&#x27;t prove itself correct is a serious liability.  I just also like C... it&#x27;s got many footguns, yes indeed, it&#x27;s practically constructed out of only footguns, but there are only like 8 of them, and they&#x27;re all right there waiting for you to get to know them.  It&#x27;s like having a few good sharp knives in your kitchen.  You get to know each well, using them one at a time---and if any is missing from the block you pause everything and look around very carefully.</div><br/></div></div><div id="39939680" class="c"><input type="checkbox" id="c-39939680" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#39936484">root</a><span>|</span><a href="#39936919">parent</a><span>|</span><a href="#39937247">prev</a><span>|</span><a href="#39937093">next</a><span>|</span><label class="collapse" for="c-39939680">[-]</label><label class="expand" for="c-39939680">[1 more]</label></div><br/><div class="children"><div class="content">I doubt that a month of so of full work will get someone fully proficient on e.g. the finer details of integer promotions and how they can break things in non-obvious ways (think of situations such as combining signed and unsigned operands of different widths). The fundamental problem is that sane production code written in C will generally deliberately avoid some aspects of the language precisely because they are so footgun-prone, which means that if you learn solely by experience, you may never even become aware of the footgun behind the pattern.</div><br/></div></div><div id="39937139" class="c"><input type="checkbox" id="c-39937139" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#39936484">root</a><span>|</span><a href="#39936919">parent</a><span>|</span><a href="#39937093">prev</a><span>|</span><a href="#39936799">next</a><span>|</span><label class="collapse" for="c-39937139">[-]</label><label class="expand" for="c-39937139">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but C genuinely is relatively tiny,<p>Relatively tiny and with a disproportionate number of footguns.</div><br/><div id="39939170" class="c"><input type="checkbox" id="c-39939170" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#39936484">root</a><span>|</span><a href="#39937139">parent</a><span>|</span><a href="#39936799">next</a><span>|</span><label class="collapse" for="c-39939170">[-]</label><label class="expand" for="c-39939170">[1 more]</label></div><br/><div class="children"><div class="content">Not really that much In my experience. Most of the unsafety is very obvious and most of the memory safety really come from errors from this obviously unsafe parts, e.g. the most common  memory safety bug is pointer arithmetic gone wrong.  The others are temporal memory safety and signed integer overflows. None of this is really subtle or what I would really call a footgun.  Nowadays, programmers do not seem to understand integer conversion rules of C anymore (although they are  simply IMHO), but then this is something which can be mitigated  via sanitizers.</div><br/></div></div></div></div></div></div></div></div><div id="39936799" class="c"><input type="checkbox" id="c-39936799" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#39936484">parent</a><span>|</span><a href="#39936742">prev</a><span>|</span><a href="#39937457">next</a><span>|</span><label class="collapse" for="c-39936799">[-]</label><label class="expand" for="c-39936799">[2 more]</label></div><br/><div class="children"><div class="content">I think one of the problems with C today, which you&#x27;re touching on but I think not quite capturing, is that it&#x27;s not taught and used nearly as much anymore.  So when people are found in the position of writing, or more likely altering existing C, they usually don&#x27;t know popular styles, conventions, coping mechanisms; eg. you can use coding style to make memory leaks less likely [one example: a rule forbidding early return out of a function, designating cleanup blocks], but few people are learning or teaching it.</div><br/><div id="39939311" class="c"><input type="checkbox" id="c-39939311" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#39936484">root</a><span>|</span><a href="#39936799">parent</a><span>|</span><a href="#39937457">next</a><span>|</span><label class="collapse" for="c-39939311">[-]</label><label class="expand" for="c-39939311">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree than most of problems of C can be mitigated with good training. It it of course far easier to blame the language than admit that there is a skill issue. The story that this a language full of footguns that even experienced programmers can not deal with is a lot of nonsense in my opinion and does not match my experience (both as a C programmer, a manager of C programmers, and user of many rock-solid C programs).   At the same time, does it help to complain about insufficient training? It is just reality that many programmers are not experienced in C and it is also true that there are a lot of serious problems in C code. This is not a contradiction. If you have  C coders without sufficient training and&#x2F;or experience you will get memory safety issues in C code and you will not even notice in time. If you have unexperienced Rust coders, you will still get memory safe code - at least if you have a rule against using &quot;unsafe&quot; or some oversight. (the code might be buggy in others ways, or programmers may be less efficient, but you still get memory safety ensured by the language). I think this is the real great advantage that Rust has and why we should also have a memory-safe subset of C.</div><br/></div></div></div></div><div id="39937457" class="c"><input type="checkbox" id="c-39937457" checked=""/><div class="controls bullet"><span class="by">Repulsion9513</span><span>|</span><a href="#39936484">parent</a><span>|</span><a href="#39936799">prev</a><span>|</span><a href="#39937077">next</a><span>|</span><label class="collapse" for="c-39937457">[-]</label><label class="expand" for="c-39937457">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not usually that someone only half knows the language but rather that different people in a team can carry different assumptions about how something was done...</div><br/></div></div><div id="39937077" class="c"><input type="checkbox" id="c-39937077" checked=""/><div class="controls bullet"><span class="by">Zababa</span><span>|</span><a href="#39936484">parent</a><span>|</span><a href="#39937457">prev</a><span>|</span><label class="collapse" for="c-39937077">[-]</label><label class="expand" for="c-39937077">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it is the only problem. Even if you learn the language and know it well, if you start contributing on a big project, it&#x27;s going to be hard to understand exactly what happens and to be sure that you didn&#x27;t make mistakes. At this point it makes sense to delegate some checking to the computer.</div><br/></div></div></div></div></div></div></div></div></div></body></html>