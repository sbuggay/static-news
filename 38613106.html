<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702544459156" as="style"/><link rel="stylesheet" href="styles.css?v=1702544459156"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.bonaroo.nl/2023/12/12/building-node-applications-without-dependencies.html">Building Node.js applications without dependencies</a> <span class="domain">(<a href="https://www.bonaroo.nl">www.bonaroo.nl</a>)</span></div><div class="subtext"><span>puuush</span> | <span>24 comments</span></div><br/><div><div id="38637721" class="c"><input type="checkbox" id="c-38637721" checked=""/><div class="controls bullet"><span class="by">willsmith72</span><span>|</span><a href="#38639115">next</a><span>|</span><label class="collapse" for="c-38637721">[-]</label><label class="expand" for="c-38637721">[16 more]</label></div><br/><div class="children"><div class="content">Somehow in my career I&#x27;ve never managed to develop the hatred for dependencies and upgrades that so many seem to have.<p>What&#x27;s the big deal?</div><br/><div id="38639292" class="c"><input type="checkbox" id="c-38639292" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38639060">next</a><span>|</span><label class="collapse" for="c-38639292">[-]</label><label class="expand" for="c-38639292">[1 more]</label></div><br/><div class="children"><div class="content">If you upgrade regularly, maintain sufficient business-logic testing to catch breakage, and regularly audit your dependencies for those which are no longer maintained so that they can be ripped out and replaced with maintained alternatives, then you&#x27;re fine.<p>If you skip any one of those, then your full-time job is longer about shipping features&#x2F;value but just trying to get the damned thing to work.</div><br/></div></div><div id="38639060" class="c"><input type="checkbox" id="c-38639060" checked=""/><div class="controls bullet"><span class="by">fifticon</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38639292">prev</a><span>|</span><a href="#38638824">next</a><span>|</span><label class="collapse" for="c-38639060">[-]</label><label class="expand" for="c-38639060">[2 more]</label></div><br/><div class="children"><div class="content">I manage a 4year old &#x27;vanilla&#x27; typescript app at work. It doesnt&#x27;t really do anything &#x27;wild&#x27;, looking at it you would think &#x27;that could be built with anything&#x2F;nothing&#x27;.
  But if you check node-modules, it contains ~1500 npm packages!<p>Your second thought might be &#x27;oh, its because they let themselves use a huge amount of random gizmos!&#x27;.<p>Nope.. the actual root dependencies are relatively small in number, maybe 30-40 core dependencies.<p>The problem is, that the prevailing attitude in the ecosystem is to &#x27;just use dependencies&#x27;, for anything, like lpad.
  As &#x27;I know, we&#x27;ll just use the creditcard my daddy gave me&#x27;.<p>As long as your daddy is rich, you won&#x27;t see a problem.<p>If your daddy isnt rich, you will notice that every 10 days as you run npm-build, it will proclaim &#x27;hooray, there are now again 10-15 high-medium security in your 1500 dependencies&#x27;.<p>Combine this need to npm update continuously, with frontends happy disregard for typechecking and backwards compatibility, and you have a recipe for the plague,which we are currently living :-(</div><br/><div id="38639256" class="c"><input type="checkbox" id="c-38639256" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#38637721">root</a><span>|</span><a href="#38639060">parent</a><span>|</span><a href="#38638824">next</a><span>|</span><label class="collapse" for="c-38639256">[-]</label><label class="expand" for="c-38639256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; small in number, maybe 30-40 core dependencies<p>I consider 40 to be a lot, even for a huge enterprise project. I think without major refactoring half of them can be replaced with simple utility functions.</div><br/></div></div></div></div><div id="38638824" class="c"><input type="checkbox" id="c-38638824" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38639060">prev</a><span>|</span><a href="#38638697">next</a><span>|</span><label class="collapse" for="c-38638824">[-]</label><label class="expand" for="c-38638824">[4 more]</label></div><br/><div class="children"><div class="content">I used to not have issues with Java or .net, but with npm it’s very painful; I need to pin everything as updates, even minor ones, break whole slews of things. And that’s with dependencies of dependencies of dependencies. If you are not a consulting outfit (I suspect consultancy outfits <i>love</i> the js ecosystem; every day something breaks so that’s another few $150&#x2F;hr hours), but have a company with 100+ applications installed that actively make or help you make your bottom line, you want them to run in peace for years or decades. If no new features or security issues arrive, you don’t want to spend $0.01 on them as what’s the point of that?<p>And that’s where this new fangled crap falls down: we have Django and .net apps running that are 10 years old, php and java ones 15-20 years old that all survived without much or any work. We have apps in js&#x2F;typescript from 1 year ago that have bucketloads of deprecated, no longer supported, mandatory update warnings. It’s a pita so we are looking to move back to php or&#x2F;and Django.<p>I can see that in a startup with a dedicated team, this would be no issue; you are on top of all and working daily.<p>Note as well that for some products (the more regulated of our products; financial&#x2F;health&#x2F;gov) have strict dependencies we all have to vet; in our experience of the past 4 years, it’s not a hallucination that npms change so often without any useful new features or fixes; just some useless dep updates that sometimes break things and weren’t needed,  at all (you do not always need the latest version of everything ya know); I suspect (but maybe someone here knows) is that npms often update because it gives the authors more kudos somehow (as in; if posting many videos on TikTok ups your engagement; does that work for npm updates and new useless npms too?).</div><br/><div id="38638913" class="c"><input type="checkbox" id="c-38638913" checked=""/><div class="controls bullet"><span class="by">holoduke</span><span>|</span><a href="#38637721">root</a><span>|</span><a href="#38638824">parent</a><span>|</span><a href="#38638697">next</a><span>|</span><label class="collapse" for="c-38638913">[-]</label><label class="expand" for="c-38638913">[3 more]</label></div><br/><div class="children"><div class="content">What are really painful if i may ask? 
We have some very old node express servers running. I think 20 years old. They still work after so many years. Occasionally I update them. But never really run into issues. For those old php&#x2F;puthon projects. Do you really have package manager used for those? Most of those old projects are just folders with scripts without any managers.</div><br/><div id="38639166" class="c"><input type="checkbox" id="c-38639166" checked=""/><div class="controls bullet"><span class="by">nanidin</span><span>|</span><a href="#38637721">root</a><span>|</span><a href="#38638913">parent</a><span>|</span><a href="#38639147">next</a><span>|</span><label class="collapse" for="c-38639166">[-]</label><label class="expand" for="c-38639166">[1 more]</label></div><br/><div class="children"><div class="content">Node was released in 2009 :)</div><br/></div></div><div id="38639147" class="c"><input type="checkbox" id="c-38639147" checked=""/><div class="controls bullet"><span class="by">curtisblaine</span><span>|</span><a href="#38637721">root</a><span>|</span><a href="#38638913">parent</a><span>|</span><a href="#38639166">prev</a><span>|</span><a href="#38638697">next</a><span>|</span><label class="collapse" for="c-38639147">[-]</label><label class="expand" for="c-38639147">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s painful when you have a lot of peer dependencies in your tree and then you are forced to update one dependency for security reasons. That dependency may have updated peer dependencies that are not compatible with the existing ones, which forces you to upgrade other dependencies and so on, in a domino effect. If the dependencies you have upgraded to are not compatible with your code or, worse, you configuration, you might end up refactoring big chunks of your application.<p>This happens a lot with the frontend ecosystem (where everything is a peer dependency of either react or webpack &#x2F; rollup &#x2F; whatever build system) but can happen on the backend too (where many things are plugins &#x2F; middlewares of express or whatever server you&#x27;re using and carry a peer dependency on express).<p>This is made more evident by the fact that, in its latest iterations, the npm project decided to install peer dependencies by default and break if their collective ranges are not compatible (before it just warned), essentially breaking CI if peer deps are broken (I&#x27;m not saying it&#x27;s a bad move, before that a lot of applications essentially failed less but more obscurely).<p>Another issue is the fact that the Node project moves quite fastly and new versions of dependencies that you must support for security reasons may be dependant on newer Node engines. A simple dependency migration, in that case, might become a migration towards a new version of Node, that 1) in corporate environments might not be available 2) might clash with other dependencies being still dependent on earlier versions of the Node engine 3) might deprecate or remove some of the APIs you were using.<p>All this makes sense per se: upgrading dependencies is a complex topic that shouldn&#x27;t be taken lightly. What makes less sense, imho, is the extreme customizability of a Node project: millions of available small dependencies that you can combine however you like, fractally (your deps do this as well, and their deps and so on).<p>The ecosystem would probably benefit from more monolithic dependencies that are less customizable. Rome was a project in this sense - a monolithic package of pre-configured, opinionated dev tooling - but now the cat is out of the bag. Less experienced developers will bikeshed if they can and npm is the perfect ecosystem to bikeshed your way to thousands of dependencies that are not upgraded regularly and after a couple of years become a nightmare to upgrade in bloc. That&#x27;s why people are starting to write zero-deps code.</div><br/></div></div></div></div></div></div><div id="38638697" class="c"><input type="checkbox" id="c-38638697" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38638824">prev</a><span>|</span><a href="#38639117">next</a><span>|</span><label class="collapse" for="c-38638697">[-]</label><label class="expand" for="c-38638697">[1 more]</label></div><br/><div class="children"><div class="content">Because with big enough project you have 2 ways:<p>You update dependencies as a full time job and it bites you  because something breaks big way. But most likely you have some help to fix it and as you are on top you might need to put work to fix it but yeah still full time job.<p>You neglect updating dependencies and it bites you and you don’t even expect it just because you have to update something you did not expect will need it and you are now scrambling to do anything because you are messed up.<p>Besides I like writing my own code more than dealing with some lib shenanigans.</div><br/></div></div><div id="38639117" class="c"><input type="checkbox" id="c-38639117" checked=""/><div class="controls bullet"><span class="by">glutamate</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38638697">prev</a><span>|</span><a href="#38638328">next</a><span>|</span><label class="collapse" for="c-38639117">[-]</label><label class="expand" for="c-38639117">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s also a question of education. You can read these sorts of blog posts and tinker with this type of development without using it at work. A lot of web developers are confused about basic things like the request cycle and I think the use of magic easy frameworks is partly responsible (also this is stuff you don&#x27;t learn in CS school). Seeing how things work without dependencies or frameworks really helps.</div><br/></div></div><div id="38638328" class="c"><input type="checkbox" id="c-38638328" checked=""/><div class="controls bullet"><span class="by">jwells89</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38639117">prev</a><span>|</span><a href="#38638074">next</a><span>|</span><label class="collapse" for="c-38638328">[-]</label><label class="expand" for="c-38638328">[1 more]</label></div><br/><div class="children"><div class="content">The thing about dependencies (regardless of ecosystem) is that it’s easy for them to spiral out of control, making it difficult to have a solid grip on all the things going on under the hood. Over time this can be a real problem because it makes tracking down breakages and fixing them that much more difficult, especially when dealing with deep fractals of dependencies.<p>In short, they’re fine in moderation but each added is another liability. As such, it can be beneficial to take a judicious approach and only add them when the value they bring outweighs that liability.</div><br/></div></div><div id="38638074" class="c"><input type="checkbox" id="c-38638074" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38638328">prev</a><span>|</span><a href="#38638095">next</a><span>|</span><label class="collapse" for="c-38638074">[-]</label><label class="expand" for="c-38638074">[2 more]</label></div><br/><div class="children"><div class="content">The black hole that is node_modules? Like, it’s fine for my personal projects, but every time I install the project I implicitly trust some 2000 authors to not have added “rm -rf &#x2F;“ to their installation scripts.<p>Ideally I wouldn’t have to worry about that.</div><br/><div id="38639281" class="c"><input type="checkbox" id="c-38639281" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#38637721">root</a><span>|</span><a href="#38638074">parent</a><span>|</span><a href="#38638095">next</a><span>|</span><label class="collapse" for="c-38639281">[-]</label><label class="expand" for="c-38639281">[1 more]</label></div><br/><div class="children"><div class="content">You have to have this trust with any software you&#x27;re using. Is not feasible to inspect source and install from source every package&#x2F;library you use. Any of them can hypothetically run rm rf and include it even in a minor update.</div><br/></div></div></div></div><div id="38638095" class="c"><input type="checkbox" id="c-38638095" checked=""/><div class="controls bullet"><span class="by">r3trohack3r</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38638074">prev</a><span>|</span><a href="#38638413">next</a><span>|</span><label class="collapse" for="c-38638095">[-]</label><label class="expand" for="c-38638095">[1 more]</label></div><br/><div class="children"><div class="content">For me, personally, my &quot;hatred&quot; developed while working on a team that shipped software living in other people&#x27;s process spaces.<p>Classical examples of this are metrics clients, tracing clients, loggers, HTTP frameworks, routers, etc. Tools that are hard&#x2F;impossible to spin out into a dedicated microservice but generic enough to warrant trying to share that code across many services.<p>These dependencies can have measurable impact on the user experience.<p>Some teams just toss the code over the wall so &quot;it&#x27;s someone else&#x27;s problem.&quot; But I&#x27;d take a &quot;every instance of my code in a production server is a production deployment&quot; approach.<p>Being able to test your changes against real production traffic, knowing when you&#x27;ve made a change that is going to break services, owning that, being able to roll it back yourself. All of that is stuff I want in my dependency manager.<p>A dependency is more than something down inside a node_modules directory. It&#x27;s a code path that executes alongside, or even directly handles incoming customer requests.<p>Trying to track down and upgrade my library&#x2F;framework&#x2F;w.e. when it&#x27;s deployed across 100,000+ instances for 10,000+ services is... not fun.<p>Even less fun is trying to surgically update _only_ my code and not rebuild the entire world pulling in a huge pile of changes along with my changes.<p>Package management failed me when I tried to model deployments as a collection of stakeholders shipping code to production.<p>This isn&#x27;t just an npm problem. This sucks in pretty much every package manager I&#x27;ve worked with. Don&#x27;t get me started on apt... unpack an ar archive into a global namespace, run some Rube Goldberg scripts, and hope for the best.<p>The Nix paper gives me hope, but I never got around to using Nix in production before I moved on from large-scale deployments.</div><br/></div></div><div id="38638413" class="c"><input type="checkbox" id="c-38638413" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38638095">prev</a><span>|</span><a href="#38637805">next</a><span>|</span><label class="collapse" for="c-38638413">[-]</label><label class="expand" for="c-38638413">[1 more]</label></div><br/><div class="children"><div class="content">Different combinations of versions break in novel ways.  They each come with their own build constraints.  Some of them have bugs that go unfixed for years.  It&#x27;s find to submit a PR, but sometimes they&#x27;re not accepting any.  And it&#x27;s a transitive dependency anyway, so using my fork wouldn&#x27;t even help. And so on.</div><br/></div></div><div id="38637805" class="c"><input type="checkbox" id="c-38637805" checked=""/><div class="controls bullet"><span class="by">thomasfromcdnjs</span><span>|</span><a href="#38637721">parent</a><span>|</span><a href="#38638413">prev</a><span>|</span><a href="#38639115">next</a><span>|</span><label class="collapse" for="c-38637805">[-]</label><label class="expand" for="c-38637805">[1 more]</label></div><br/><div class="children"><div class="content">Neither.<p>I&#x27;ve also used pretty much every package manager out there, and this may hurt some, but I&#x27;ve always loved the npm ecosystem the most.</div><br/></div></div></div></div><div id="38637666" class="c"><input type="checkbox" id="c-38637666" checked=""/><div class="controls bullet"><span class="by">notpachet</span><span>|</span><a href="#38639115">prev</a><span>|</span><a href="#38637495">next</a><span>|</span><label class="collapse" for="c-38637666">[-]</label><label class="expand" for="c-38637666">[2 more]</label></div><br/><div class="children"><div class="content">The author says:<p>&gt; Normally, I use express as a webserver, and I use jest for testing. ... Naturally, without dependencies, I can’t use any of these things.<p>But the examples are still using Jest from the look of it.</div><br/><div id="38637711" class="c"><input type="checkbox" id="c-38637711" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#38637666">parent</a><span>|</span><a href="#38637495">next</a><span>|</span><label class="collapse" for="c-38637711">[-]</label><label class="expand" for="c-38637711">[1 more]</label></div><br/><div class="children"><div class="content">I think he just elided the imports of node&#x27;s new-ish built-in `node:test` module: <a href="https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;test.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;test.html</a></div><br/></div></div></div></div><div id="38637495" class="c"><input type="checkbox" id="c-38637495" checked=""/><div class="controls bullet"><span class="by">a13n</span><span>|</span><a href="#38637666">prev</a><span>|</span><label class="collapse" for="c-38637495">[-]</label><label class="expand" for="c-38637495">[4 more]</label></div><br/><div class="children"><div class="content">Was curious if author considers node libs like `http` a dependency and the answer is no they don&#x27;t. Looks like they&#x27;re defining a dependency as an npm module, which seems pretty fair.</div><br/><div id="38638661" class="c"><input type="checkbox" id="c-38638661" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#38637495">parent</a><span>|</span><a href="#38637928">next</a><span>|</span><label class="collapse" for="c-38638661">[-]</label><label class="expand" for="c-38638661">[1 more]</label></div><br/><div class="children"><div class="content">Std is not a dependency.</div><br/></div></div><div id="38637928" class="c"><input type="checkbox" id="c-38637928" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#38637495">parent</a><span>|</span><a href="#38638661">prev</a><span>|</span><label class="collapse" for="c-38637928">[-]</label><label class="expand" for="c-38637928">[2 more]</label></div><br/><div class="children"><div class="content">Your comment got me curious if it’s at all possible to build a Node web service without importing any Node modules (ie with just the global&#x2F;module-local namespace). Glancing at the globals docs, I think you’d be limited to WASM, binary extensions (like N-API), or maaaaaaybe doing something horrifically hacky with CJS require.</div><br/><div id="38638288" class="c"><input type="checkbox" id="c-38638288" checked=""/><div class="controls bullet"><span class="by">DecoPerson</span><span>|</span><a href="#38637495">root</a><span>|</span><a href="#38637928">parent</a><span>|</span><label class="collapse" for="c-38638288">[-]</label><label class="expand" for="c-38638288">[1 more]</label></div><br/><div class="children"><div class="content">If you’re OK importing node’s internal modules [0], which I believe are loaded anyway, you could achieve a lot, though it definitely wouldn’t be worth it.<p>No developer is an island. [1]<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;node&#x2F;tree&#x2F;main&#x2F;lib&#x2F;internal">https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;node&#x2F;tree&#x2F;main&#x2F;lib&#x2F;internal</a><p>[1] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;TY9xsT6S75A?si=uqPUuxKNl_1vqMhm" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;TY9xsT6S75A?si=uqPUuxKNl_1vqMhm</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>