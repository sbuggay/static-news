<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685610079720" as="style"/><link rel="stylesheet" href="styles.css?v=1685610079720"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://borretti.me/article/language-pragmatics">Language Pragmatics Engineering</a> <span class="domain">(<a href="https://borretti.me">borretti.me</a>)</span></div><div class="subtext"><span>ashpil</span> | <span>14 comments</span></div><br/><div><div id="36147720" class="c"><input type="checkbox" id="c-36147720" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36148760">next</a><span>|</span><label class="collapse" for="c-36147720">[-]</label><label class="expand" for="c-36147720">[3 more]</label></div><br/><div class="children"><div class="content">I loved this paragraph:<p><pre><code>   You observe this with types. Dynamic types feel faster, at the REPL, when you’re coding at 1Hz, because you’re not factoring in the (unseen) cost of future bugs, the cost of refactors you won’t do because you don’t have the confidence to refactor which static types give you, the cost of legacy software that can’t be replaced because it can’t be understood by anyone, the cost of a Python server doing four requests per second while you pay five figures to AWS every month.</code></pre></div><br/><div id="36147923" class="c"><input type="checkbox" id="c-36147923" checked=""/><div class="controls bullet"><span class="by">sk0g</span><span>|</span><a href="#36147720">parent</a><span>|</span><a href="#36148285">prev</a><span>|</span><a href="#36148760">next</a><span>|</span><label class="collapse" for="c-36147923">[-]</label><label class="expand" for="c-36147923">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny, in a few dynamically typed projects I&#x27;ve noticed people start treating some code as append-only. The fear of getting bitten means reinventing the wheel is a more palatable prospect than diving into the inexplicable horrors that are around the corner.<p>Of course, that &#x27;a g i l i t y&#x27; of dynamic typing is impossible to give up. The devs must churn out code ASAP, maintenance be damned -- mostly because they probably won&#x27;t be maintaining it.</div><br/></div></div></div></div><div id="36148760" class="c"><input type="checkbox" id="c-36148760" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#36147720">prev</a><span>|</span><a href="#36148329">next</a><span>|</span><label class="collapse" for="c-36148760">[-]</label><label class="expand" for="c-36148760">[1 more]</label></div><br/><div class="children"><div class="content">This is why I love Go. Go feels like a language that is boring on purpose - few magic short cuts, and few ways of misusing some special language feature. Just a lot of boring, regular code which is easy to refactor and maintain at scale (IMO).</div><br/></div></div><div id="36147964" class="c"><input type="checkbox" id="c-36147964" checked=""/><div class="controls bullet"><span class="by">jaxrtech</span><span>|</span><a href="#36148329">prev</a><span>|</span><a href="#36147749">next</a><span>|</span><label class="collapse" for="c-36147964">[-]</label><label class="expand" for="c-36147964">[1 more]</label></div><br/><div class="children"><div class="content">Various thoughts:<p>It seems to me that the fundamental definition of a function&#x2F;method should be a compile time executed function that generates a syntax tree <i>always</i> (assuming the compiler dog-foods itself or can parse and interpret it). Much like Python has metaclasses or Rust&#x27;s procedural macros but it&#x27;s just assumed by default.<p>It&#x27;s kind of unfortunate that a language with managed effects &amp; capabilities hasn&#x27;t gone mainstream. Maybe it doesn&#x27;t have the right ergonomics yet.</div><br/></div></div><div id="36147749" class="c"><input type="checkbox" id="c-36147749" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#36147964">prev</a><span>|</span><a href="#36147738">next</a><span>|</span><label class="collapse" for="c-36147749">[-]</label><label class="expand" for="c-36147749">[1 more]</label></div><br/><div class="children"><div class="content">I agree with everything, apart from metaprogramming. I&#x27;d say the issues with metaprogramming are issues with tooling (that you cannot easily inspect &#x2F; debug the generated code).</div><br/></div></div><div id="36147738" class="c"><input type="checkbox" id="c-36147738" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36147749">prev</a><span>|</span><label class="collapse" for="c-36147738">[-]</label><label class="expand" for="c-36147738">[6 more]</label></div><br/><div class="children"><div class="content">Hardly pragmatic; this page seems to be little more than rah-rah Haskell evangelism. (And I like Haskell!).<p>Making it hard to YOLO your I&#x2F;O does not seem to be paying off very well for Haskell; the cost in adoption often outweighs the gain in safety. Yes, Django codebases occasionally have bugs due to I&#x2F;O happening at the wrong time, but that&#x27;s pretty far down the list of causes of bugs in Django codebases.<p>Likewise the argument against macros seems to be driven by nothing more than personal taste. (And again, I dislike macros! But you have to actually make the argument why they&#x27;re bad. Certainly my experience is that checking generated code into source control is worse, not better)</div><br/><div id="36147901" class="c"><input type="checkbox" id="c-36147901" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#36147738">parent</a><span>|</span><a href="#36147888">next</a><span>|</span><label class="collapse" for="c-36147901">[-]</label><label class="expand" for="c-36147901">[3 more]</label></div><br/><div class="children"><div class="content">About macros: the author did argue why it&#x27;s bad. It was actually the final point leading to the conclusion:<p><pre><code>    salience bias: measuring what is seen and not what is unseen.
</code></pre>
And he did not say all macros are bad, giving the example of Common Lisp macros being good. Why? Because you can easily expand them (the language itself gives you the capability, not just an IDE... but of course with SLIME it&#x27;s one shortcut away) and see the actual code you will get running.</div><br/><div id="36148566" class="c"><input type="checkbox" id="c-36148566" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#36147738">root</a><span>|</span><a href="#36147901">parent</a><span>|</span><a href="#36148124">next</a><span>|</span><label class="collapse" for="c-36148566">[-]</label><label class="expand" for="c-36148566">[1 more]</label></div><br/><div class="children"><div class="content">The salience bias can be seen the opposite way: your code base consists of understandable metaprogramming based on principled tools, and the corresponding write-only generated code is unseen.<p>The OP might have been bitten by bad macros and bad code generation (early and repeatedly).</div><br/></div></div><div id="36148124" class="c"><input type="checkbox" id="c-36148124" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#36147738">root</a><span>|</span><a href="#36147901">parent</a><span>|</span><a href="#36148566">prev</a><span>|</span><a href="#36147888">next</a><span>|</span><label class="collapse" for="c-36148124">[-]</label><label class="expand" for="c-36148124">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And he did not say all macros are bad, giving the example of Common Lisp macros being good. Why? Because you can easily expand them (the language itself gives you the capability, not just an IDE... but of course with SLIME it&#x27;s one shortcut away) and see the actual code you will get running.<p>That seems pretty unconvincing. If it&#x27;s important for macros, why isn&#x27;t it important for regular code? And yet taking a Haskell function and dropping down to the corresponding Core is no easier than expanding a Rust or OCaml macro.</div><br/></div></div></div></div><div id="36147888" class="c"><input type="checkbox" id="c-36147888" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#36147738">parent</a><span>|</span><a href="#36147901">prev</a><span>|</span><label class="collapse" for="c-36147888">[-]</label><label class="expand" for="c-36147888">[2 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t RTFA, but I wanted to note that in Linguistics, at least, &quot;pragmatics&quot; isn&#x27;t really about pragmatism.</div><br/><div id="36148336" class="c"><input type="checkbox" id="c-36148336" checked=""/><div class="controls bullet"><span class="by">dmvdoug</span><span>|</span><a href="#36147738">root</a><span>|</span><a href="#36147888">parent</a><span>|</span><label class="collapse" for="c-36148336">[-]</label><label class="expand" for="c-36148336">[1 more]</label></div><br/><div class="children"><div class="content">It isn’t, but the confusion is the author’s, not the commenter’s. Although the author situates the article as discussing the programming languages equivalent of pragmatics in linguistics (explicitly coupling it with syntax and semantics), the author actually focuses on practical, everyday concerns, like how programmers will steer away from using things a language makes difficult to use, or the inefficiencies resulting from bad tooling, or tedium-avoidance by programmers.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>