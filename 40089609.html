<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713603652411" as="style"/><link rel="stylesheet" href="styles.css?v=1713603652411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.mptcp.dev/">Multipath TCP for Linux (2022)</a> <span class="domain">(<a href="https://www.mptcp.dev">www.mptcp.dev</a>)</span></div><div class="subtext"><span>pantalaimon</span> | <span>76 comments</span></div><br/><div><div id="40090268" class="c"><input type="checkbox" id="c-40090268" checked=""/><div class="controls bullet"><span class="by">ohnoesjmr</span><span>|</span><a href="#40093902">next</a><span>|</span><label class="collapse" for="c-40090268">[-]</label><label class="expand" for="c-40090268">[26 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard about MPTCP back in 2013.<p>It made so much sense back then, when mobile apps were not that robust to networks changing, I assumed it&#x27;s going to get adopted in no time due to how much of a ux improvement it would have been back in the day.<p>It&#x27;s incredibly depressing that this gained barely any traction in the last 10 years, and kernel options are appearing just recently, after everyone has wrapped they http calls in multiple retry handlers, and mobile operating systems have abstracted network connectivity to the point where it feels more like you are using zeromq rather than tcp.</div><br/><div id="40091001" class="c"><input type="checkbox" id="c-40091001" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40090268">parent</a><span>|</span><a href="#40091193">next</a><span>|</span><label class="collapse" for="c-40091001">[-]</label><label class="expand" for="c-40091001">[6 more]</label></div><br/><div class="children"><div class="content">I wanted to like it, and Apple included it in iOS, but supporting it on real servers was going to be too hard...<p>When I was deployed on FreeBSD with no load balancers, there weren&#x27;t recent patches. And even if there were, I&#x27;d need to do some serious work to avoid advertising the private network ips as alternates...<p>When I was on Linux behind a load balancer, it&#x27;s too complex to get the streams to the right place. And the load balancer doesn&#x27;t want to do it anyway.<p>Processing two streams together involves a lot of complexity in a high throughput code path. It&#x27;s a lot of risk, and you&#x27;ve got to reboot for changes.<p>And then you do all that work and it only benefits iOS users, who tend to be on better networks anyway.</div><br/><div id="40095488" class="c"><input type="checkbox" id="c-40095488" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40091001">parent</a><span>|</span><a href="#40091830">next</a><span>|</span><label class="collapse" for="c-40095488">[-]</label><label class="expand" for="c-40095488">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  iOS users, who tend to be on better networks anyway.<p>I don&#x27;t think there is any basis to claim that.</div><br/></div></div><div id="40091830" class="c"><input type="checkbox" id="c-40091830" checked=""/><div class="controls bullet"><span class="by">bbss</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40091001">parent</a><span>|</span><a href="#40095488">prev</a><span>|</span><a href="#40093651">next</a><span>|</span><label class="collapse" for="c-40091830">[-]</label><label class="expand" for="c-40091830">[1 more]</label></div><br/><div class="children"><div class="content">Apple also contributed[1] MPTCP support to Envoy Proxy.<p>[1]<a href="https:&#x2F;&#x2F;github.com&#x2F;envoyproxy&#x2F;envoy&#x2F;pull&#x2F;18780">https:&#x2F;&#x2F;github.com&#x2F;envoyproxy&#x2F;envoy&#x2F;pull&#x2F;18780</a></div><br/></div></div><div id="40093651" class="c"><input type="checkbox" id="c-40093651" checked=""/><div class="controls bullet"><span class="by">RulerOf</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40091001">parent</a><span>|</span><a href="#40091830">prev</a><span>|</span><a href="#40091193">next</a><span>|</span><label class="collapse" for="c-40093651">[-]</label><label class="expand" for="c-40093651">[3 more]</label></div><br/><div class="children"><div class="content">It sounds like this would have taken off if it were added to various managed cloud load balancers based on what you&#x27;re saying.<p>The only question I have is if it opens up a different can of worms even if you&#x27;ve got a magic box terminating layer 7 for you or not. Never dug deep enough into mptcp myself to know.</div><br/><div id="40093807" class="c"><input type="checkbox" id="c-40093807" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40093651">parent</a><span>|</span><a href="#40091193">next</a><span>|</span><label class="collapse" for="c-40093807">[-]</label><label class="expand" for="c-40093807">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a no brainer if it&#x27;s no effort or small effort (set a socket option on the client, somehow)... but it&#x27;s a big effort to support it in a large load balancing situation.<p>If you balance your load balancers with ECMP, I don&#x27;t know if you can get two client streams to the same mptcp terminating place.<p>If you&#x27;ve optimized the heck out of your tcp flows, this throws a wrench in there, because the second stream is likely to get hashed into a different nic queue, and then you have communication between cpus to move forward on the logical stream.<p>It would have been really handy though, and solve real issues with real users.<p>Edit to add: it could also solve some issues on private networking &#x2F; interserver networking I saw... although the contention would be a much bigger problem on higher bandwidth streams. On networks with link aggregation, while there are many paths from one host to another, usually path selection is by hashing the connection 5-tuple {src ip, dst ip, protocol, src port, dst port} so a long running tcp connection remains on the same path for the duration, if a path segment has high loss&#x2F;corruption or is congested, MPTCP could help if you had an extra connection that hit a different path. Otherwise, you need to find the segment and get network operations to fix it; it&#x27;s not easy to figure that out (i had to write a tool to sample and find port combinations with trouble and then a patch for mtr to run a trace with fixed ports) and then you still need to reconnect your affected tcp sockets unless you can get a quick response from net ops (sometimes they can check error stats once the right devices are pointed out to them, and then replacing a cable&#x2F;fiber often helps, or disconnecting it during investigation can help the traffic flow across the redundant links)</div><br/><div id="40094292" class="c"><input type="checkbox" id="c-40094292" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40093807">parent</a><span>|</span><a href="#40091193">next</a><span>|</span><label class="collapse" for="c-40094292">[-]</label><label class="expand" for="c-40094292">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you balance your load balancers with ECMP, I don&#x27;t know if you can get two client streams to the same mptcp terminating place.<p>At Google, we do something similar with QUIC and connection migration. Our mechanism for ensuring these hit the same backend is Maglev [0], where we use the QUIC connection ID for hashing purposes in software. (Our routers still mostly use ECMP based on the 5-tuple, so being able to consistently hash to the same backend across multiple LB instances is crucial.)<p>&gt; if a path segment has high loss&#x2F;corruption or is congested, MPTCP could help if you had an extra connection that hit a different path.<p>Incidentally, we also have a family of internal mechanisms that do this, although we don&#x27;t rely on MPTCP. (We instead twiddle some other bits in the packet that we make sure our routers use for hashing, at least for RPCs between prod machines.) This inspired some of the connection migration work in our QUIC implementation [1], wherein we can migrate to a different ephemeral port if we detect issues with the current path. This works shockingly often for routing around network problems.<p>[0] <a href="https:&#x2F;&#x2F;research.google&#x2F;pubs&#x2F;maglev-a-fast-and-reliable-software-network-load-balancer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;research.google&#x2F;pubs&#x2F;maglev-a-fast-and-reliable-soft...</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;quiche&#x2F;blob&#x2F;main&#x2F;quiche&#x2F;quic&#x2F;core&#x2F;quic_connection.cc#L6252">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;quiche&#x2F;blob&#x2F;main&#x2F;quiche&#x2F;quic&#x2F;core&#x2F;...</a></div><br/></div></div></div></div></div></div></div></div><div id="40091193" class="c"><input type="checkbox" id="c-40091193" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#40090268">parent</a><span>|</span><a href="#40091001">prev</a><span>|</span><a href="#40090536">next</a><span>|</span><label class="collapse" for="c-40091193">[-]</label><label class="expand" for="c-40091193">[3 more]</label></div><br/><div class="children"><div class="content">I suspect that a lot of innovation energy moved to QUIC, because with TCP your nice new variant can be randomly nobbled by middleboxes. For example, see <a href="https:&#x2F;&#x2F;blog.apnic.net&#x2F;2021&#x2F;12&#x2F;08&#x2F;efficient-multipath-transport-with-quic-video-services&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.apnic.net&#x2F;2021&#x2F;12&#x2F;08&#x2F;efficient-multipath-transp...</a></div><br/><div id="40094649" class="c"><input type="checkbox" id="c-40094649" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40091193">parent</a><span>|</span><a href="#40090536">next</a><span>|</span><label class="collapse" for="c-40094649">[-]</label><label class="expand" for="c-40094649">[2 more]</label></div><br/><div class="children"><div class="content">QUIC is a step back, IMHO. Especially, given how many national networks work poorly with UDP protocols.</div><br/><div id="40094713" class="c"><input type="checkbox" id="c-40094713" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40094649">parent</a><span>|</span><a href="#40090536">next</a><span>|</span><label class="collapse" for="c-40094713">[-]</label><label class="expand" for="c-40094713">[1 more]</label></div><br/><div class="children"><div class="content">If QUIC adoption grows, that will motivate network providers to improve UDP performance and connectivity</div><br/></div></div></div></div></div></div><div id="40090536" class="c"><input type="checkbox" id="c-40090536" checked=""/><div class="controls bullet"><span class="by">quectophoton</span><span>|</span><a href="#40090268">parent</a><span>|</span><a href="#40091193">prev</a><span>|</span><a href="#40093037">next</a><span>|</span><label class="collapse" for="c-40090536">[-]</label><label class="expand" for="c-40090536">[12 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve heard about MPTCP back in 2013.<p>&gt; I assumed it&#x27;s going to get adopted in no time due to how much of a ux improvement it would have been back in the day.<p>You might also be interested in SCTP[1] from the year 2000, which also hasn&#x27;t gotten any traction so far.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stream_Control_Transmission_Protocol" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stream_Control_Transmission_Pr...</a></div><br/><div id="40090707" class="c"><input type="checkbox" id="c-40090707" checked=""/><div class="controls bullet"><span class="by">throw0101b</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40090536">parent</a><span>|</span><a href="#40090695">next</a><span>|</span><label class="collapse" for="c-40090707">[-]</label><label class="expand" for="c-40090707">[9 more]</label></div><br/><div class="children"><div class="content">&gt; <i>You might also be interested in SCTP[1] from the year 2000, which also hasn&#x27;t gotten any traction so far.</i><p>Probably partly because middleware boxes (e.g., firewalls) either didn&#x27;t&#x2F;don&#x27;t support it and&#x2F;or rules were written to only support &quot;TCP&quot; (as opposed to &#x27;stream&#x27;) or &quot;UDP&quot; (as opposed to &#x27;dgram&#x27;; see also &quot;DCCP&quot;).</div><br/><div id="40093245" class="c"><input type="checkbox" id="c-40093245" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40090707">parent</a><span>|</span><a href="#40091617">next</a><span>|</span><label class="collapse" for="c-40093245">[-]</label><label class="expand" for="c-40093245">[1 more]</label></div><br/><div class="children"><div class="content">Certainly that&#x27;s a part, but it didn&#x27;t help that SCTP has some fundamental low-level flaws.<p>Given that TCP also has at least one unfixable flaw, the only recommendation I can make is to use something UDP-based - which, to make sure you don&#x27;t stomp on everybody else&#x27;s traffic, means use the only popular one: QUIC (the layer beneath HTTP&#x2F;3).</div><br/></div></div><div id="40091617" class="c"><input type="checkbox" id="c-40091617" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40090707">parent</a><span>|</span><a href="#40093245">prev</a><span>|</span><a href="#40090695">next</a><span>|</span><label class="collapse" for="c-40091617">[-]</label><label class="expand" for="c-40091617">[7 more]</label></div><br/><div class="children"><div class="content">The protocol is specified by a byte in the IP packet; how many middleware boxes block everything except for ICMP, TCP, and UDP? What is the probability that a packet with that byte set to something unexpected actually gets from source to destination?</div><br/><div id="40094270" class="c"><input type="checkbox" id="c-40094270" checked=""/><div class="controls bullet"><span class="by">throw0101c</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40091617">parent</a><span>|</span><a href="#40092715">next</a><span>|</span><label class="collapse" for="c-40094270">[-]</label><label class="expand" for="c-40094270">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The protocol is specified by a byte in the IP packet; how many middleware boxes block everything except for ICMP, TCP, and UDP?</i><p>Most firewalls are <i>default deny</i> out of the box and you have to allow things through. How many folks bother opening up SCTP&#x2F;DCCP&#x2F;etc?</div><br/></div></div><div id="40092715" class="c"><input type="checkbox" id="c-40092715" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40091617">parent</a><span>|</span><a href="#40094270">prev</a><span>|</span><a href="#40092164">next</a><span>|</span><label class="collapse" for="c-40092715">[-]</label><label class="expand" for="c-40092715">[3 more]</label></div><br/><div class="children"><div class="content">How does sctp work with NAT that your typical home box uses?</div><br/><div id="40093704" class="c"><input type="checkbox" id="c-40093704" checked=""/><div class="controls bullet"><span class="by">lttlrck</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40092715">parent</a><span>|</span><a href="#40092164">next</a><span>|</span><label class="collapse" for="c-40093704">[-]</label><label class="expand" for="c-40093704">[2 more]</label></div><br/><div class="children"><div class="content">SCTP can run over UDP. It&#x27;s part of the spec.<p>Now we have HTTP3 which runs over UDP - where there is a will, there is a way.<p>Perhaps SCTP was ahead of its time.</div><br/><div id="40094289" class="c"><input type="checkbox" id="c-40094289" checked=""/><div class="controls bullet"><span class="by">throw0101c</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40093704">parent</a><span>|</span><a href="#40092164">next</a><span>|</span><label class="collapse" for="c-40094289">[-]</label><label class="expand" for="c-40094289">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>SCTP can run over UDP. It&#x27;s part of the spec.</i><p>SCTP over UDP came out in 2013:<p>* <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc6951" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc6951</a><p>SCTP came out in 2000:<p>* <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc2960" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc2960</a><p>Over a decade is quite a while in Internet-time.</div><br/></div></div></div></div></div></div><div id="40092164" class="c"><input type="checkbox" id="c-40092164" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40091617">parent</a><span>|</span><a href="#40092715">prev</a><span>|</span><a href="#40090695">next</a><span>|</span><label class="collapse" for="c-40092164">[-]</label><label class="expand" for="c-40092164">[2 more]</label></div><br/><div class="children"><div class="content">The “funny” thing is that http3 really really looks like a transport protocol encapsulated into… uso. Exactly because many middle boxes block anything that’s not a very well known protocol</div><br/><div id="40093359" class="c"><input type="checkbox" id="c-40093359" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40092164">parent</a><span>|</span><a href="#40090695">next</a><span>|</span><label class="collapse" for="c-40093359">[-]</label><label class="expand" for="c-40093359">[1 more]</label></div><br/><div class="children"><div class="content">The internet is just broken and only works because of lot of hacked bandaids.</div><br/></div></div></div></div></div></div></div></div><div id="40090695" class="c"><input type="checkbox" id="c-40090695" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40090536">parent</a><span>|</span><a href="#40090707">prev</a><span>|</span><a href="#40090600">next</a><span>|</span><label class="collapse" for="c-40090695">[-]</label><label class="expand" for="c-40090695">[1 more]</label></div><br/><div class="children"><div class="content">SCTP is used a lot inside telco networks for carrying switching control metadata for voice connections. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SIGTRAN" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SIGTRAN</a></div><br/></div></div><div id="40090600" class="c"><input type="checkbox" id="c-40090600" checked=""/><div class="controls bullet"><span class="by">gamegod</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40090536">parent</a><span>|</span><a href="#40090695">prev</a><span>|</span><a href="#40093037">next</a><span>|</span><label class="collapse" for="c-40090600">[-]</label><label class="expand" for="c-40090600">[1 more]</label></div><br/><div class="children"><div class="content">WebRTC data channels use SCTP, which ain&#x27;t nothing!
<a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8831" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8831</a><p>(SCTP over DTLS, that is...)</div><br/></div></div></div></div><div id="40093037" class="c"><input type="checkbox" id="c-40093037" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#40090268">parent</a><span>|</span><a href="#40090536">prev</a><span>|</span><a href="#40090319">next</a><span>|</span><label class="collapse" for="c-40093037">[-]</label><label class="expand" for="c-40093037">[3 more]</label></div><br/><div class="children"><div class="content">I was excited about it because we were working on delivery robots and I wanted a good solution for instant failover given 2 cellular modems.<p>We ended up going with PepLink&#x27;s SpeedFusion to save engineering time. But the license was costly. I really hope for a free solution in the future for 2 cellular networks and &lt;50ms failover.<p>Multipath UDP + OpenVPN would also probably be a viable solution.</div><br/><div id="40095807" class="c"><input type="checkbox" id="c-40095807" checked=""/><div class="controls bullet"><span class="by">tubs</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40093037">parent</a><span>|</span><a href="#40095465">next</a><span>|</span><label class="collapse" for="c-40095807">[-]</label><label class="expand" for="c-40095807">[1 more]</label></div><br/><div class="children"><div class="content">Hehe, I also worked on a delivery robot with exactly the same problem. We ended up licencing phantom auto. Expensive and ... Not particularly amazing.</div><br/></div></div><div id="40095465" class="c"><input type="checkbox" id="c-40095465" checked=""/><div class="controls bullet"><span class="by">kariemf</span><span>|</span><a href="#40090268">root</a><span>|</span><a href="#40093037">parent</a><span>|</span><a href="#40095807">prev</a><span>|</span><a href="#40090319">next</a><span>|</span><label class="collapse" for="c-40095465">[-]</label><label class="expand" for="c-40095465">[1 more]</label></div><br/><div class="children"><div class="content">I created something like what you&#x27;re describing with the addition of P2P communication using NAT traversal (<a href="https:&#x2F;&#x2F;www.hyperpath.ie" rel="nofollow">https:&#x2F;&#x2F;www.hyperpath.ie</a>)<p>It will connect your devices in a P2P Mesh VPN and allow them to send and receive data using multiple links (e.g. multiple 5G or 5G + Satellite).<p>It is significantly cheaper than Peplink&#x27;s license, less latency and no bandwidth &#x2F; data limits.<p>You need to bring your own hardware though. Like a Raspberry Pi with 3 USB 4G&#x2F;5G dongles.</div><br/></div></div></div></div><div id="40090319" class="c"><input type="checkbox" id="c-40090319" checked=""/><div class="controls bullet"><span class="by">zoobab</span><span>|</span><a href="#40090268">parent</a><span>|</span><a href="#40093037">prev</a><span>|</span><a href="#40093902">next</a><span>|</span><label class="collapse" for="c-40090319">[-]</label><label class="expand" for="c-40090319">[1 more]</label></div><br/><div class="children"><div class="content">ZeroMQ yeah!</div><br/></div></div></div></div><div id="40093902" class="c"><input type="checkbox" id="c-40093902" checked=""/><div class="controls bullet"><span class="by">bdd8f1df777b</span><span>|</span><a href="#40090268">prev</a><span>|</span><a href="#40091155">next</a><span>|</span><label class="collapse" for="c-40093902">[-]</label><label class="expand" for="c-40093902">[3 more]</label></div><br/><div class="children"><div class="content">The only practical use of MPTCP for me is to use mobile and Wi-Fi network together to boost the speed. iOS and WeChat both support this. However, I always turn them off because my mobile network is metered. So in the end, MPTCP is useless for me *personally*.</div><br/><div id="40093995" class="c"><input type="checkbox" id="c-40093995" checked=""/><div class="controls bullet"><span class="by">psaux</span><span>|</span><a href="#40093902">parent</a><span>|</span><a href="#40091155">next</a><span>|</span><label class="collapse" for="c-40093995">[-]</label><label class="expand" for="c-40093995">[2 more]</label></div><br/><div class="children"><div class="content">I worked on this. We called it the parking lot bug. WiFi still shows signal but no proper connection. With MPTCP, it will failover to cell.</div><br/><div id="40095342" class="c"><input type="checkbox" id="c-40095342" checked=""/><div class="controls bullet"><span class="by">taken_usernam</span><span>|</span><a href="#40093902">root</a><span>|</span><a href="#40093995">parent</a><span>|</span><a href="#40091155">next</a><span>|</span><label class="collapse" for="c-40095342">[-]</label><label class="expand" for="c-40095342">[1 more]</label></div><br/><div class="children"><div class="content">You can even learn to predict these handovers to make it really smooth [0].<p>[0] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1907.10493.pdf" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1907.10493.pdf</a></div><br/></div></div></div></div></div></div><div id="40091155" class="c"><input type="checkbox" id="c-40091155" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#40093902">prev</a><span>|</span><a href="#40094470">next</a><span>|</span><label class="collapse" for="c-40091155">[-]</label><label class="expand" for="c-40091155">[17 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know which makes me sadder-- IPv4 only having a 32-bit address space or TCP using the source and destination IP addresses in the connection tuple. That&#x27;s one of those &quot;if I had a time machine&quot; of things-- I&#x27;d go back and have Cert and Kahn change both of those items.</div><br/><div id="40095644" class="c"><input type="checkbox" id="c-40095644" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40091155">parent</a><span>|</span><a href="#40091298">next</a><span>|</span><label class="collapse" for="c-40095644">[-]</label><label class="expand" for="c-40095644">[1 more]</label></div><br/><div class="children"><div class="content">I think they&#x27;d point out that they gave you source routing which is half of what you want and is correctly specified as an option.</div><br/></div></div><div id="40091298" class="c"><input type="checkbox" id="c-40091298" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40091155">parent</a><span>|</span><a href="#40095644">prev</a><span>|</span><a href="#40094470">next</a><span>|</span><label class="collapse" for="c-40091298">[-]</label><label class="expand" for="c-40091298">[15 more]</label></div><br/><div class="children"><div class="content">How would you change TCP?<p>Do you mean how we have to use 4 fields to track a connection - IP address and port for both ends?</div><br/><div id="40091478" class="c"><input type="checkbox" id="c-40091478" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40091298">parent</a><span>|</span><a href="#40094470">next</a><span>|</span><label class="collapse" for="c-40091478">[-]</label><label class="expand" for="c-40091478">[14 more]</label></div><br/><div class="children"><div class="content">If TCP had a protocol specific identifier for connections (a couple of 32-bit values, for example-- a client nonce and server nonce) rather than using the source&#x2F;destination IP addresses multi-homed hosts and seamless transition between different networks would become native features of the protocol. A client could roam between two different IP networks and TCP connections would &quot;survive&quot;, for example. (I&#x27;m oversimplifying nearly to the point of hyperbole, to be sure...)<p>(Another fun future would have been one where SCTP got widespread adoption.)</div><br/><div id="40091916" class="c"><input type="checkbox" id="c-40091916" checked=""/><div class="controls bullet"><span class="by">mauriciob</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40091478">parent</a><span>|</span><a href="#40092025">next</a><span>|</span><label class="collapse" for="c-40091916">[-]</label><label class="expand" for="c-40091916">[5 more]</label></div><br/><div class="children"><div class="content">How would routing be done without source&#x2F;destination? When the device changes networks, how does the origin and all routers along the way know that this device is on a new network?</div><br/><div id="40092125" class="c"><input type="checkbox" id="c-40092125" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40091916">parent</a><span>|</span><a href="#40092123">next</a><span>|</span><label class="collapse" for="c-40092125">[-]</label><label class="expand" for="c-40092125">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How would routing be done without source&#x2F;destination?<p>There is still a source&#x2F;destination address.  Routing still works.  But those addresses are allowed to change without disrupting the connection because the connection isn&#x27;t based on the values of these addresses.<p>&gt; When the device changes networks, how does the origin and all routers along the way know<p>The routers don&#x27;t need to &quot;know&quot; these things.<p>MPQUIC does this.  To the network it&#x27;s just UDP packets moving around.  Connection state is dealt with at higher levels and doesn&#x27;t rely on IP addresses.</div><br/></div></div><div id="40092123" class="c"><input type="checkbox" id="c-40092123" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40091916">parent</a><span>|</span><a href="#40092125">prev</a><span>|</span><a href="#40091969">next</a><span>|</span><label class="collapse" for="c-40092123">[-]</label><label class="expand" for="c-40092123">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  how does the origin and all routers along the way<p>It&#x27;s just the origin that needs to know what address(es) it should be using as the destination at layer 3.<p>The big problems with this is that it depends upon things that weren&#x27;t really feasible in the early 80&#x27;s -- bigger packet headers, a bit more state on each side of the connection, potential need for cryptographic authentication.</div><br/></div></div><div id="40091969" class="c"><input type="checkbox" id="c-40091969" checked=""/><div class="controls bullet"><span class="by">zare_st</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40091916">parent</a><span>|</span><a href="#40092123">prev</a><span>|</span><a href="#40092025">next</a><span>|</span><label class="collapse" for="c-40091969">[-]</label><label class="expand" for="c-40091969">[2 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s a shortsighted plan. How would i set up rules on firewall if I don&#x27;t know how to distingush the connections?</div><br/><div id="40092073" class="c"><input type="checkbox" id="c-40092073" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40091969">parent</a><span>|</span><a href="#40092025">next</a><span>|</span><label class="collapse" for="c-40092073">[-]</label><label class="expand" for="c-40092073">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s two separate ideas here:<p>* Where to send a frame to get to the other side of the connection<p>* Whose connection this is.<p>TCP combined the two, because we didn&#x27;t have mobile clients or a lot of multihomed systems that would benefit from distinguishing them.  Also, every octet in the header counted.<p>In practice, this means we have to keep building a lot of infrastructure on top of TCP (or parallel to it, in datagram protocols) to handle retries and splitting flows well.  In turn, these things are completely opaque to the network and it&#x27;s difficult to write rules about them.<p>Whereas if we had different packet fields for &quot;where am I sending this packet right now&quot; and &quot;whose flow does this belong to&quot;? we could write better firewall rules, have less infrastructure built on top of TCP, and have better typical application performance.</div><br/></div></div></div></div></div></div><div id="40092025" class="c"><input type="checkbox" id="c-40092025" checked=""/><div class="controls bullet"><span class="by">zare_st</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40091478">parent</a><span>|</span><a href="#40091916">prev</a><span>|</span><a href="#40092770">next</a><span>|</span><label class="collapse" for="c-40092025">[-]</label><label class="expand" for="c-40092025">[4 more]</label></div><br/><div class="children"><div class="content">But the stuff that carries TCP is IP. That&#x27;s why TCP can work seamlessly, because it uses identification from a previous layer. Consider I bind a server to an ID, and not IP:port, the operating system running it must know how to communicate that via IP, so there will be a corellation map somewhere and that map needs to be synchronized between all peers that wish to host the roaming server.<p>Otherwise you&#x27;re just switching port (16-bit) value to arbitrary 32-bit identifier.</div><br/><div id="40092092" class="c"><input type="checkbox" id="c-40092092" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40092025">parent</a><span>|</span><a href="#40092395">next</a><span>|</span><label class="collapse" for="c-40092092">[-]</label><label class="expand" for="c-40092092">[2 more]</label></div><br/><div class="children"><div class="content">If TCP didn&#x27;t use L3 source and destination addresses to distinguish connections, it could be more easily taught to deal with:<p>* Clients roaming between L3 addresses<p>* Clients&#x2F;servers with multiple L3 addresses</div><br/><div id="40095772" class="c"><input type="checkbox" id="c-40095772" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40092092">parent</a><span>|</span><a href="#40092395">next</a><span>|</span><label class="collapse" for="c-40095772">[-]</label><label class="expand" for="c-40095772">[1 more]</label></div><br/><div class="children"><div class="content">But... it doesn&#x27;t? TCP has no notion of IP address in the protocol, only the port.
TCP with changing IPs can work e.g. on top of an ip-ip tunnel with applications not being aware at all.</div><br/></div></div></div></div><div id="40092395" class="c"><input type="checkbox" id="c-40092395" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40092025">parent</a><span>|</span><a href="#40092092">prev</a><span>|</span><a href="#40092770">next</a><span>|</span><label class="collapse" for="c-40092395">[-]</label><label class="expand" for="c-40092395">[1 more]</label></div><br/><div class="children"><div class="content">The protocol would have to handle binding the network to the transport. MPTCP and SCTP both handle that via registering and un-register network layer endpoints. This parallel universe TCP would be the same in that regard.<p>(I did say I was oversimplifying...</div><br/></div></div></div></div><div id="40092770" class="c"><input type="checkbox" id="c-40092770" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40091478">parent</a><span>|</span><a href="#40092025">prev</a><span>|</span><a href="#40092299">next</a><span>|</span><label class="collapse" for="c-40092770">[-]</label><label class="expand" for="c-40092770">[1 more]</label></div><br/><div class="children"><div class="content">How do you even firewall such a protocol?</div><br/></div></div><div id="40092299" class="c"><input type="checkbox" id="c-40092299" checked=""/><div class="controls bullet"><span class="by">alerighi</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40091478">parent</a><span>|</span><a href="#40092770">prev</a><span>|</span><a href="#40094470">next</a><span>|</span><label class="collapse" for="c-40092299">[-]</label><label class="expand" for="c-40092299">[3 more]</label></div><br/><div class="children"><div class="content">The problem is that the TCP&#x2F;IP model stops at level 4, and if we consider TCP a protocol of transport, it shouldn&#x27;t do that.<p>In the OSI model what you talk about is level 5, that is session, but in TCP&#x2F;IP there is no such level, thus it must be handled by the application (e.g. trough a session cookie, in HTTP).</div><br/><div id="40093725" class="c"><input type="checkbox" id="c-40093725" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40092299">parent</a><span>|</span><a href="#40092900">next</a><span>|</span><label class="collapse" for="c-40093725">[-]</label><label class="expand" for="c-40093725">[1 more]</label></div><br/><div class="children"><div class="content">Slavish adherence to theoretical models is a recipe for failure. Even worse, the OSI model was developed in the 1970s before successful internetworks existed so it&#x27;s not informed by experience; it&#x27;s mostly made up.</div><br/></div></div><div id="40092900" class="c"><input type="checkbox" id="c-40092900" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40091155">root</a><span>|</span><a href="#40092299">parent</a><span>|</span><a href="#40093725">prev</a><span>|</span><a href="#40094470">next</a><span>|</span><label class="collapse" for="c-40092900">[-]</label><label class="expand" for="c-40092900">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. There’s no reason TCP couldn’t work like that. See QUIC for example</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40094470" class="c"><input type="checkbox" id="c-40094470" checked=""/><div class="controls bullet"><span class="by">suprjami</span><span>|</span><a href="#40091155">prev</a><span>|</span><a href="#40090308">next</a><span>|</span><label class="collapse" for="c-40094470">[-]</label><label class="expand" for="c-40094470">[1 more]</label></div><br/><div class="children"><div class="content">I work supporting, debugging, fixing the Linux network stack and drivers. I am amazed how little adoption this has seen.<p>Like everything which came along and tried to supplant regular TCP, such as SCTP, it seems MPTCP has also been confined to a niche of application developers who will use it forever while the rest of the world forgets about it.</div><br/></div></div><div id="40090308" class="c"><input type="checkbox" id="c-40090308" checked=""/><div class="controls bullet"><span class="by">zoobab</span><span>|</span><a href="#40094470">prev</a><span>|</span><a href="#40090041">next</a><span>|</span><label class="collapse" for="c-40090308">[-]</label><label class="expand" for="c-40090308">[9 more]</label></div><br/><div class="children"><div class="content">Too bad there is no link to projects using mptcp, such as Openwrt derivatives.<p>PS: I mentored a student for 2 years at GSOC to patch Openwrt with mptcp:<p><a href="https:&#x2F;&#x2F;blog.freifunk.net&#x2F;2017&#x2F;05&#x2F;29&#x2F;gsoc-2017-add-mptcp-support-ledeopenwrt-trunk&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.freifunk.net&#x2F;2017&#x2F;05&#x2F;29&#x2F;gsoc-2017-add-mptcp-sup...</a></div><br/><div id="40090769" class="c"><input type="checkbox" id="c-40090769" checked=""/><div class="controls bullet"><span class="by">jburgess777</span><span>|</span><a href="#40090308">parent</a><span>|</span><a href="#40090692">next</a><span>|</span><label class="collapse" for="c-40090769">[-]</label><label class="expand" for="c-40090769">[2 more]</label></div><br/><div class="children"><div class="content">It was recently enabled in the Home Assistant ‘HAOS’ kernel.
<a href="https:&#x2F;&#x2F;github.com&#x2F;home-assistant&#x2F;operating-system&#x2F;pull&#x2F;3248">https:&#x2F;&#x2F;github.com&#x2F;home-assistant&#x2F;operating-system&#x2F;pull&#x2F;3248</a></div><br/><div id="40095749" class="c"><input type="checkbox" id="c-40095749" checked=""/><div class="controls bullet"><span class="by">matttbe</span><span>|</span><a href="#40090308">root</a><span>|</span><a href="#40090769">parent</a><span>|</span><a href="#40090692">next</a><span>|</span><label class="collapse" for="c-40095749">[-]</label><label class="expand" for="c-40095749">[1 more]</label></div><br/><div class="children"><div class="content">I hope some apps will start using it :)</div><br/></div></div></div></div><div id="40090692" class="c"><input type="checkbox" id="c-40090692" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40090308">parent</a><span>|</span><a href="#40090769">prev</a><span>|</span><a href="#40090370">next</a><span>|</span><label class="collapse" for="c-40090692">[-]</label><label class="expand" for="c-40090692">[4 more]</label></div><br/><div class="children"><div class="content">Whats the benefit of an openwrt router supporting mptcp?<p>I&#x27;d think support on web servers and mobile devices would be most important...</div><br/><div id="40091260" class="c"><input type="checkbox" id="c-40091260" checked=""/><div class="controls bullet"><span class="by">DarrisMackelroy</span><span>|</span><a href="#40090308">root</a><span>|</span><a href="#40090692">parent</a><span>|</span><a href="#40090980">next</a><span>|</span><label class="collapse" for="c-40091260">[-]</label><label class="expand" for="c-40091260">[2 more]</label></div><br/><div class="children"><div class="content">I got fiber run to my neighborhood, and for a while, had a 1gb coax connection and a 1gb fiber connection. I used openmptcprouter to aggregate my connections through a droplet and I effectively had a 2 gigabit internet connection. I would have stuck with it, but having a datacenter IP for your home network really doesn’t work.</div><br/><div id="40092224" class="c"><input type="checkbox" id="c-40092224" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40090308">root</a><span>|</span><a href="#40091260">parent</a><span>|</span><a href="#40090980">next</a><span>|</span><label class="collapse" for="c-40092224">[-]</label><label class="expand" for="c-40092224">[1 more]</label></div><br/><div class="children"><div class="content">Except TCP is just a bad protocol to start with for tunnelling, because packetized data has to be delivered in-order, and head of line blocking messes up congestion control algorithms in the tunnelled data.</div><br/></div></div></div></div><div id="40090980" class="c"><input type="checkbox" id="c-40090980" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#40090308">root</a><span>|</span><a href="#40090692">parent</a><span>|</span><a href="#40091260">prev</a><span>|</span><a href="#40090370">next</a><span>|</span><label class="collapse" for="c-40090980">[-]</label><label class="expand" for="c-40090980">[1 more]</label></div><br/><div class="children"><div class="content">Link aggregation and redundancy</div><br/></div></div></div></div><div id="40090370" class="c"><input type="checkbox" id="c-40090370" checked=""/><div class="controls bullet"><span class="by">atarvaneitor</span><span>|</span><a href="#40090308">parent</a><span>|</span><a href="#40090692">prev</a><span>|</span><a href="#40090041">next</a><span>|</span><label class="collapse" for="c-40090370">[-]</label><label class="expand" for="c-40090370">[2 more]</label></div><br/><div class="children"><div class="content">one example 
on openwrt
<a href="http:&#x2F;&#x2F;www.openmptcprouter.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.openmptcprouter.com&#x2F;</a></div><br/><div id="40095746" class="c"><input type="checkbox" id="c-40095746" checked=""/><div class="controls bullet"><span class="by">matttbe</span><span>|</span><a href="#40090308">root</a><span>|</span><a href="#40090370">parent</a><span>|</span><a href="#40090041">next</a><span>|</span><label class="collapse" for="c-40095746">[-]</label><label class="expand" for="c-40095746">[1 more]</label></div><br/><div class="children"><div class="content">Good point, the last version (v0.60) is using the upstream kernel by default. I just added it in the list: <a href="https:&#x2F;&#x2F;www.mptcp.dev&#x2F;apps.html#misc" rel="nofollow">https:&#x2F;&#x2F;www.mptcp.dev&#x2F;apps.html#misc</a></div><br/></div></div></div></div></div></div><div id="40090041" class="c"><input type="checkbox" id="c-40090041" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40090308">prev</a><span>|</span><a href="#40091664">next</a><span>|</span><label class="collapse" for="c-40090041">[-]</label><label class="expand" for="c-40090041">[5 more]</label></div><br/><div class="children"><div class="content">Why does this require explicit opt in by applications if there’s transparent fallback? Wouldn’t it make most sense for the kernel to do it transparently for every TCP connection so that it can make more global decisions about path aggregation &#x2F; link preference?</div><br/><div id="40090485" class="c"><input type="checkbox" id="c-40090485" checked=""/><div class="controls bullet"><span class="by">brenns10</span><span>|</span><a href="#40090041">parent</a><span>|</span><a href="#40090095">next</a><span>|</span><label class="collapse" for="c-40090485">[-]</label><label class="expand" for="c-40090485">[2 more]</label></div><br/><div class="children"><div class="content">My understanding is that it was basically a condition enforced by the maintainers of the Linux TCP &#x2F; networking subsystems. If you look at the initial upstreaming discussions[1], this was setup as a ground rule.<p>If you look at the older multipath TCP implementation, prior to the upstreaming, it was intended to be fully transparent to the application, which I think makes more sense for the intent of the protocol. Sure, in many cases MPTCP may be better with application-guided logic, but having a standard system approach (e.g. establish sub-flows on an LTE connection for automatic failover, but don&#x27;t send any data along those sub-flows) would have worked for 95% of cases.<p>[1] <a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;all&#x2F;alpine.OSX.2.21.1707181728570.11990@dhruvmeh-mobl1.amr.corp.intel.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;all&#x2F;alpine.OSX.2.21.1707181728570.11...</a></div><br/><div id="40095795" class="c"><input type="checkbox" id="c-40095795" checked=""/><div class="controls bullet"><span class="by">matttbe</span><span>|</span><a href="#40090041">root</a><span>|</span><a href="#40090485">parent</a><span>|</span><a href="#40090095">next</a><span>|</span><label class="collapse" for="c-40095795">[-]</label><label class="expand" for="c-40095795">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s correct. In the Linux kernel, it would not be possible to switch to MPTCP by default.<p>But apps can use it by default. For the server case, it really makes sense: <a href="https:&#x2F;&#x2F;www.mptcp.dev&#x2F;faq.html#why--when-should-mptcp-be-enabled-by-default" rel="nofollow">https:&#x2F;&#x2F;www.mptcp.dev&#x2F;faq.html#why--when-should-mptcp-be-ena...</a><p>GNU&#x2F;Linux distributions could even switch MPTCP on by default (via eBPF).</div><br/></div></div></div></div><div id="40090095" class="c"><input type="checkbox" id="c-40090095" checked=""/><div class="controls bullet"><span class="by">chmod775</span><span>|</span><a href="#40090041">parent</a><span>|</span><a href="#40090485">prev</a><span>|</span><a href="#40090779">next</a><span>|</span><label class="collapse" for="c-40090095">[-]</label><label class="expand" for="c-40090095">[1 more]</label></div><br/><div class="children"><div class="content">Using this implies that there are multiple IPs per endpoint associated with a single TCP connection. That is going to need explicit support&#x2F;awarness by the application in many cases.</div><br/></div></div><div id="40090779" class="c"><input type="checkbox" id="c-40090779" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40090041">parent</a><span>|</span><a href="#40090095">prev</a><span>|</span><a href="#40091664">next</a><span>|</span><label class="collapse" for="c-40090779">[-]</label><label class="expand" for="c-40090779">[1 more]</label></div><br/><div class="children"><div class="content">I can imagine new security holes being opened up by allowing multiple IP&#x27;s to talk over the same TCP connection...<p>Imagine you have an application which checks the clients IP (eg. against a whitelist) at the time of connection and then assumes it doesn&#x27;t change...</div><br/></div></div></div></div><div id="40091664" class="c"><input type="checkbox" id="c-40091664" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40090041">prev</a><span>|</span><a href="#40090216">next</a><span>|</span><label class="collapse" for="c-40091664">[-]</label><label class="expand" for="c-40091664">[2 more]</label></div><br/><div class="children"><div class="content">I found [1] which describes the architectural difference between MPTCP and QUIC, and also introduces the authors&#x27; proposed MPQUIC protocol:<p>&gt; QUIC multiplexes application streams on a single UDP ﬂow, whereas MPTCP splits a single stream on multiple TCP subﬂows. MPQUIC combines both features by multiplex-
ing application streams on multiple UDP subﬂows.<p>[1]: &quot;Multipath QUIC: A Deployable Multipath Transport Protocol&quot; <a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;327122884_Multipath_QUIC_A_Deployable_Multipath_Transport_Protocol" rel="nofollow">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;327122884_Multipath...</a><p>Now I&#x27;m curious about how these protocols compare in production operation. Anybody have experience with both?</div><br/><div id="40095813" class="c"><input type="checkbox" id="c-40095813" checked=""/><div class="controls bullet"><span class="by">matttbe</span><span>|</span><a href="#40091664">parent</a><span>|</span><a href="#40090216">next</a><span>|</span><label class="collapse" for="c-40095813">[-]</label><label class="expand" for="c-40095813">[1 more]</label></div><br/><div class="children"><div class="content">Note that MPQUIC is still being discussed at the IETF. At the last IETF meeting, more changes have been discussed. Unfortunately, that slows down its adoption. <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;964377&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;964377&#x2F;</a><p>But both tries to achieve the same goal. Technically, you can have a very similar behaviour. MPTCP is implemented in the Linux kernel, while QUIC is on the userspace side.</div><br/></div></div></div></div><div id="40090216" class="c"><input type="checkbox" id="c-40090216" checked=""/><div class="controls bullet"><span class="by">iknowstuff</span><span>|</span><a href="#40091664">prev</a><span>|</span><a href="#40090398">next</a><span>|</span><label class="collapse" for="c-40090216">[-]</label><label class="expand" for="c-40090216">[2 more]</label></div><br/><div class="children"><div class="content">Apple supports it too and uses it for Siri <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;foundation&#x2F;urlsessionconfiguration&#x2F;improving_network_reliability_using_multipath_tcp" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;foundation&#x2F;urlsess...</a></div><br/><div id="40090381" class="c"><input type="checkbox" id="c-40090381" checked=""/><div class="controls bullet"><span class="by">Arcanum-XIII</span><span>|</span><a href="#40090216">parent</a><span>|</span><a href="#40090398">next</a><span>|</span><label class="collapse" for="c-40090381">[-]</label><label class="expand" for="c-40090381">[1 more]</label></div><br/><div class="children"><div class="content">It’s quite easy to use in other app - it’s there in the basics. We were quite amazed to find our voip app to be quite robust in 2011 :D</div><br/></div></div></div></div><div id="40090398" class="c"><input type="checkbox" id="c-40090398" checked=""/><div class="controls bullet"><span class="by">vesinisa</span><span>|</span><a href="#40090216">prev</a><span>|</span><a href="#40091094">next</a><span>|</span><label class="collapse" for="c-40090398">[-]</label><label class="expand" for="c-40090398">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If any middlebox in between does not support it, the returned SYN+ACK packet will not contain MPTCP options in the TCP option field.<p>That sounds .. quite restrictive. Is the only requirement on a middlebox to just forward the MPTCP options as-is?</div><br/><div id="40093002" class="c"><input type="checkbox" id="c-40093002" checked=""/><div class="controls bullet"><span class="by">mhandley</span><span>|</span><a href="#40090398">parent</a><span>|</span><a href="#40091094">next</a><span>|</span><label class="collapse" for="c-40093002">[-]</label><label class="expand" for="c-40093002">[1 more]</label></div><br/><div class="children"><div class="content">Before we finalized the specs we did a lot of testing to make sure that enabling MPTCP wouldn&#x27;t break connectivity.  Either it would be passed correctly, or it would fall back to single-path TCP safely.  Generally, so long as a middlebox passes through unknown options unmodified, and does not try to enforce that the TCP sequence space it sees is contiguous, MPTCP should work through that middlebox.<p>If you&#x27;re interested, we wrote a couple of papers on this:<p>[1] <a href="https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;nsdi12&#x2F;technical-sessions&#x2F;presentation&#x2F;raiciu" rel="nofollow">https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;nsdi12&#x2F;technical-sessions&#x2F;...</a><p>[2] <a href="https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;229002024_Is_it_still_possible_to_extend_TCP" rel="nofollow">https:&#x2F;&#x2F;www.researchgate.net&#x2F;publication&#x2F;229002024_Is_it_sti...</a></div><br/></div></div></div></div><div id="40091094" class="c"><input type="checkbox" id="c-40091094" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#40090398">prev</a><span>|</span><a href="#40090574">next</a><span>|</span><label class="collapse" for="c-40091094">[-]</label><label class="expand" for="c-40091094">[2 more]</label></div><br/><div class="children"><div class="content">This can help in security&#x2F;privacy setting.<p>for example Great Chinese firewall: if you can split your traffic across multiple uplink channels, the firewall will have a hard time to put them together for enforcement?</div><br/><div id="40092791" class="c"><input type="checkbox" id="c-40092791" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#40091094">parent</a><span>|</span><a href="#40090574">next</a><span>|</span><label class="collapse" for="c-40092791">[-]</label><label class="expand" for="c-40092791">[1 more]</label></div><br/><div class="children"><div class="content">They just block or rate limit it severely when they dont know what it is.</div><br/></div></div></div></div><div id="40090574" class="c"><input type="checkbox" id="c-40090574" checked=""/><div class="controls bullet"><span class="by">extraduder_ire</span><span>|</span><a href="#40091094">prev</a><span>|</span><a href="#40090211">next</a><span>|</span><label class="collapse" for="c-40090574">[-]</label><label class="expand" for="c-40090574">[3 more]</label></div><br/><div class="children"><div class="content">The examples given on the page seem to focus on multipath to get to a device over the internet, but I can see this being more likely to work properly without needing to fallback on home networks.</div><br/><div id="40091581" class="c"><input type="checkbox" id="c-40091581" checked=""/><div class="controls bullet"><span class="by">txutxu</span><span>|</span><a href="#40090574">parent</a><span>|</span><a href="#40090211">next</a><span>|</span><label class="collapse" for="c-40091581">[-]</label><label class="expand" for="c-40091581">[2 more]</label></div><br/><div class="children"><div class="content">At home&#x2F;lan we use LACP, VRRP... I mean link aggregation and HA needs are solved time ago.<p>With multiple ISPs, or on a complex enough LAN, we can use multiple routing tables + weights too.<p>Also, if the ISP at home can do 10Gbps, 1Gbps, 300 Mbps whatever... I want to be able to use them with a single path, so there is no gain using multiple paths. Eventually, when I have cable+wifi connected at the same time, I use to force one of both, cannot see a reason to prefer using both at the same time.<p>Maybe the latency thing? Never had that issue at home, but could understand that usage case &quot;just use the network segment with less latency to reach $thing&quot;.</div><br/><div id="40095845" class="c"><input type="checkbox" id="c-40095845" checked=""/><div class="controls bullet"><span class="by">matttbe</span><span>|</span><a href="#40090574">root</a><span>|</span><a href="#40091581">parent</a><span>|</span><a href="#40090211">next</a><span>|</span><label class="collapse" for="c-40095845">[-]</label><label class="expand" for="c-40095845">[1 more]</label></div><br/><div class="children"><div class="content">Some ISPs in Europe are using MPTCP for people being too far from the street cabinets. Typically, for people in the countryside, with &lt; 50 Mbps. Thanks to a transparent proxy installed in the home gateway, and servers in the ISP&#x27;s network, they can combine both the fixed and cellular networks, and use the fixed one in priority.<p>MPTCP can also be very interesting for mobility use-cases, even when one network is used at a time, e.g. switching from WiFi to cellular, or different cellular networks in the train, etc.</div><br/></div></div></div></div></div></div><div id="40090211" class="c"><input type="checkbox" id="c-40090211" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#40090574">prev</a><span>|</span><label class="collapse" for="c-40090211">[-]</label><label class="expand" for="c-40090211">[3 more]</label></div><br/><div class="children"><div class="content">Is this something that middle boxes tend to support in practice?</div><br/><div id="40091141" class="c"><input type="checkbox" id="c-40091141" checked=""/><div class="controls bullet"><span class="by">flounder3</span><span>|</span><a href="#40090211">parent</a><span>|</span><a href="#40094457">next</a><span>|</span><label class="collapse" for="c-40091141">[-]</label><label class="expand" for="c-40091141">[1 more]</label></div><br/><div class="children"><div class="content">We found that most proxies&#x2F;firewalls (90%+ ? I forget) didn&#x27;t tamper with it. The largest hurdle was working with load balancer vendors to implement it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>