<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694422870094" as="style"/><link rel="stylesheet" href="styles.css?v=1694422870094"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://retrocomputing.stackexchange.com/questions/26083/how-could-early-unix-os-comprise-so-few-lines-of-code">How could the early Unix OS comprise so few lines of code?</a>Â <span class="domain">(<a href="https://retrocomputing.stackexchange.com">retrocomputing.stackexchange.com</a>)</span></div><div class="subtext"><span>peter_d_sherman</span> | <span>10 comments</span></div><br/><div><div id="37464317" class="c"><input type="checkbox" id="c-37464317" checked=""/><div class="controls bullet"><span class="by">ovi256</span><span>|</span><a href="#37464335">next</a><span>|</span><label class="collapse" for="c-37464317">[-]</label><label class="expand" for="c-37464317">[4 more]</label></div><br/><div class="children"><div class="content">Answer: smaller target to cover! Modern Linux has most code in device drivers to support so many different devices. Then, it supports many targets for other subsystems, like file systems.<p>The original Unix provided one implementation for each subsystem. They relentlessly simplified the problem they were solving to make it doable.</div><br/><div id="37464506" class="c"><input type="checkbox" id="c-37464506" checked=""/><div class="controls bullet"><span class="by">mdp2021</span><span>|</span><a href="#37464317">parent</a><span>|</span><a href="#37464441">next</a><span>|</span><label class="collapse" for="c-37464506">[-]</label><label class="expand" for="c-37464506">[1 more]</label></div><br/><div class="children"><div class="content">Latest Linux kernel source:<p><pre><code>     39051  certs    0.0%
     40404  usr      0.0%
    164228  init     0.0%
    240426  virt     0.0%
    250265  ipc      0.0%
    459021  io_uring 0.0%
    664443  rust     0.1%
    979555  samples  0.1%
   1885010  block    0.1%
   2849606  scripts  0.2%
   2953164  security 0.2%
   3609139  crypto   0.3%
   5165331  mm       0.4%
   7156454  lib      0.5%
  12419586  kernel   1.0%
  33047417  net      2.5%
  39916290  include  3.1%
  43223905  fs       3.3%
  45000780  sound    3.4%
  54987535  tools    4.2%
 107971048  arch     8.3%
 943527384  drivers 72.2%
</code></pre>
Based on byte count (total 1,306,550,042 bytes in the above).</div><br/></div></div><div id="37464441" class="c"><input type="checkbox" id="c-37464441" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37464317">parent</a><span>|</span><a href="#37464506">prev</a><span>|</span><a href="#37464473">next</a><span>|</span><label class="collapse" for="c-37464441">[-]</label><label class="expand" for="c-37464441">[1 more]</label></div><br/><div class="children"><div class="content">They also didn&#x27;t care nearly as much about performance.<p>Or to be more precise, they had very different trade-offs to make.  Back then, you could have a system call and context switch for every read and live with the overhead.<p>Today we have something like io_uring.</div><br/></div></div><div id="37464473" class="c"><input type="checkbox" id="c-37464473" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#37464317">parent</a><span>|</span><a href="#37464441">prev</a><span>|</span><a href="#37464335">next</a><span>|</span><label class="collapse" for="c-37464473">[-]</label><label class="expand" for="c-37464473">[1 more]</label></div><br/><div class="children"><div class="content">With virtual memory and demand paging, memory management (done efficiently) becomes a much harder problem, too.</div><br/></div></div></div></div><div id="37464335" class="c"><input type="checkbox" id="c-37464335" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#37464317">prev</a><span>|</span><a href="#37464360">next</a><span>|</span><label class="collapse" for="c-37464335">[-]</label><label class="expand" for="c-37464335">[2 more]</label></div><br/><div class="children"><div class="content">It was essentially a &quot;time-sharing&quot; system that multiplexes interactive sessions of multiple users on teletype terminals. The &quot;shell&quot; handles such a session by waiting for user input on the terminal, interpreting it and starting external programs as a sub-hierarchy of user processes. On a teletype terminal, you couldn&#x27;t even have a cursor-oriented editor like vi, but had to rely on line-oriented editors like ed and sed.</div><br/><div id="37464622" class="c"><input type="checkbox" id="c-37464622" checked=""/><div class="controls bullet"><span class="by">pluijzer</span><span>|</span><a href="#37464335">parent</a><span>|</span><a href="#37464360">next</a><span>|</span><label class="collapse" for="c-37464622">[-]</label><label class="expand" for="c-37464622">[1 more]</label></div><br/><div class="children"><div class="content">In a way it became the complete opposite of how it started. At first one OS for many users, ea with many processes. Now, with containers, micro services etc. we have an OS per service&#x2F;process. Still the original abstractions work surprisingly well though makes it me wonder how  a complete redesign of would look like aimed at modern usage.</div><br/></div></div></div></div><div id="37464360" class="c"><input type="checkbox" id="c-37464360" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#37464335">prev</a><span>|</span><label class="collapse" for="c-37464360">[-]</label><label class="expand" for="c-37464360">[3 more]</label></div><br/><div class="children"><div class="content">I think mindset plays a role as well. Back in the day, there was a restraint on adding features, at least when they would make the logic more complicated for only a tiny or imagined benefit. Part of that was memory&#x2F;storage limitations. But I think the pursuit of an abstract idea of elegance was equally important. After all, these systems were primarily written for other computer people.<p>This idea is completely gone from the world of software engineering. Systems become overloaded with the implementation of every crappy idea under the sun -- if a PM in a fever dream can think of it, and an overworked dev can hack it together, it goes in.</div><br/><div id="37464385" class="c"><input type="checkbox" id="c-37464385" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#37464360">parent</a><span>|</span><a href="#37464434">next</a><span>|</span><label class="collapse" for="c-37464385">[-]</label><label class="expand" for="c-37464385">[1 more]</label></div><br/><div class="children"><div class="content">Not in open source. Projects with the attitude of allowing any feature that some rando comes up with die quickly when the manpower to keep it up simply isn&#x27;t there. The projects with maintainers that gatekeep are the ones that survive, and they survive for a long time.</div><br/></div></div><div id="37464434" class="c"><input type="checkbox" id="c-37464434" checked=""/><div class="controls bullet"><span class="by">anewhnaccount2</span><span>|</span><a href="#37464360">parent</a><span>|</span><a href="#37464385">prev</a><span>|</span><label class="collapse" for="c-37464434">[-]</label><label class="expand" for="c-37464434">[1 more]</label></div><br/><div class="children"><div class="content">In the case of Unix, it was deliberately a KISS&#x2F;stripped down successor to Multics. The simplicity was originally intended for faster development and running on minicomputers rather than mainframes. In the end the simplicity also meant hackability and portability which is probably why it was successful and has had so much staying power.</div><br/></div></div></div></div></div></div></div></div></div></body></html>