<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729501267894" as="style"/><link rel="stylesheet" href="styles.css?v=1729501267894"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cs.cmu.edu/~pavlo/blog/2023/04/the-part-of-postgresql-we-hate-the-most.html">MVCC – the part of PostgreSQL we hate the most (2023)</a> <span class="domain">(<a href="https://www.cs.cmu.edu">www.cs.cmu.edu</a>)</span></div><div class="subtext"><span>virtualwhys</span> | <span>87 comments</span></div><br/><div><div id="41897093" class="c"><input type="checkbox" id="c-41897093" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#41897588">next</a><span>|</span><label class="collapse" for="c-41897093">[-]</label><label class="expand" for="c-41897093">[1 more]</label></div><br/><div class="children"><div class="content">Wow, as someone who feels like I&#x27;m decently familiar with the ins and outs of Postgres, I thought this was a great article and I learned a ton.<p>It seems like one of the biggest fundamental flaws is that Postgres chose the O2N approach for tracking row versions instead of N2O. While switching to N2O wouldn&#x27;t solve all problems (e.g. the article also talks about how Postgres stores full row copies and not just diffs), from an &quot;80&#x2F;20 rule&quot; perspective, it seems like it would get rid of most of the downsides with the current implementation. For example, I&#x27;d assume that the vast majority of the time that transactions want the latest row version, so using the N2O ordering means you could probably do away with storing each row version in an index, as you&#x27;d only need to traverse the linked list of you needed an older version, which should be much less common.</div><br/></div></div><div id="41897588" class="c"><input type="checkbox" id="c-41897588" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#41897093">prev</a><span>|</span><a href="#41897421">next</a><span>|</span><label class="collapse" for="c-41897588">[-]</label><label class="expand" for="c-41897588">[10 more]</label></div><br/><div class="children"><div class="content">The big advantage is that you do not need any extra space if your workload mostly consists of INSERTs (followed by table drops). And it&#x27;s generally unnecessary to split up insertion transactions because there is no size limit as such (neither on the generated data or the total count of rows changed). There is a limit on statements in a transaction, but you can sidestep that by using COPY FROM if you do not have to switch tables too frequently. From a DBA point of view, there is no need to manage a rollback&#x2F;undo space separately from table storage.<p>Every application is a bit different, but it&#x27;s not that the PostgreSQL design is a loser in all regards. It&#x27;s not like bubble sort.</div><br/><div id="41897732" class="c"><input type="checkbox" id="c-41897732" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#41897588">parent</a><span>|</span><a href="#41897421">next</a><span>|</span><label class="collapse" for="c-41897732">[-]</label><label class="expand" for="c-41897732">[9 more]</label></div><br/><div class="children"><div class="content">&gt; but it&#x27;s not that the PostgreSQL design is a loser in all regards<p>the article literally says that pg&#x27;s mvcc design is from the 90s and no one does it like that any more. that is technology that is outdated by over 30 years. i&#x27;d say it does not make it a loser in all regards, but in the most important aspects.</div><br/><div id="41898235" class="c"><input type="checkbox" id="c-41898235" checked=""/><div class="controls bullet"><span class="by">mikeocool</span><span>|</span><a href="#41897588">root</a><span>|</span><a href="#41897732">parent</a><span>|</span><a href="#41898162">next</a><span>|</span><label class="collapse" for="c-41898235">[-]</label><label class="expand" for="c-41898235">[2 more]</label></div><br/><div class="children"><div class="content">When it comes to your data store, some people might consider using technology that’s been reliably used in production by many organizations for 30 years a feature not a bug.<p>I’d prefer not to be the first person running up against a limit or discovering a bug in my DB software.</div><br/><div id="41898511" class="c"><input type="checkbox" id="c-41898511" checked=""/><div class="controls bullet"><span class="by">mannyv</span><span>|</span><a href="#41897588">root</a><span>|</span><a href="#41898235">parent</a><span>|</span><a href="#41898162">next</a><span>|</span><label class="collapse" for="c-41898511">[-]</label><label class="expand" for="c-41898511">[1 more]</label></div><br/><div class="children"><div class="content">Well every product has issues. The question is, do you feel like dealing with those issues or not?<p>Flat files have also been reliably used in production for decades. That doesn&#x27;t mean they&#x27;re ideal...although amusingly enough s3 and its equivalent of flat files is what we&#x27;ve migrated to as a data store.</div><br/></div></div></div></div><div id="41898162" class="c"><input type="checkbox" id="c-41898162" checked=""/><div class="controls bullet"><span class="by">naranha</span><span>|</span><a href="#41897588">root</a><span>|</span><a href="#41897732">parent</a><span>|</span><a href="#41898235">prev</a><span>|</span><a href="#41898303">next</a><span>|</span><label class="collapse" for="c-41898162">[-]</label><label class="expand" for="c-41898162">[2 more]</label></div><br/><div class="children"><div class="content">At least couchdb is also append only with vacuum. So it&#x27;s maybe not completely outdated.</div><br/><div id="41898658" class="c"><input type="checkbox" id="c-41898658" checked=""/><div class="controls bullet"><span class="by">jbellis</span><span>|</span><a href="#41897588">root</a><span>|</span><a href="#41898162">parent</a><span>|</span><a href="#41898303">next</a><span>|</span><label class="collapse" for="c-41898658">[-]</label><label class="expand" for="c-41898658">[1 more]</label></div><br/><div class="children"><div class="content">High performance has never been a reason to use couchdb.</div><br/></div></div></div></div><div id="41898303" class="c"><input type="checkbox" id="c-41898303" checked=""/><div class="controls bullet"><span class="by">kunley</span><span>|</span><a href="#41897588">root</a><span>|</span><a href="#41897732">parent</a><span>|</span><a href="#41898162">prev</a><span>|</span><a href="#41897421">next</a><span>|</span><label class="collapse" for="c-41898303">[-]</label><label class="expand" for="c-41898303">[4 more]</label></div><br/><div class="children"><div class="content">Still I am very happy to use every day the technology designed in early 70s by Ken Thompson and colleagues, so far in that specific field many tried to invent something more &quot;modern&quot; and &quot;better&quot; and failed, with an exception of a certain Finnish clone of that tech, also started in 80s by the way.<p>So, newer not always means better, just saying</div><br/><div id="41899219" class="c"><input type="checkbox" id="c-41899219" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41897588">root</a><span>|</span><a href="#41898303">parent</a><span>|</span><a href="#41899463">next</a><span>|</span><label class="collapse" for="c-41899219">[-]</label><label class="expand" for="c-41899219">[1 more]</label></div><br/><div class="children"><div class="content">Speaking of which, if you try an actual System V in an emulator, or look at C code in K&amp;R style, certain progress, as in &quot;much more actually usable&quot;, can be noticed.<p>While persisting key architectural ideas certainly has benefits, so does evolving their implementations.</div><br/></div></div><div id="41899463" class="c"><input type="checkbox" id="c-41899463" checked=""/><div class="controls bullet"><span class="by">throwawayie6</span><span>|</span><a href="#41897588">root</a><span>|</span><a href="#41898303">parent</a><span>|</span><a href="#41899219">prev</a><span>|</span><a href="#41897421">next</a><span>|</span><label class="collapse" for="c-41899463">[-]</label><label class="expand" for="c-41899463">[2 more]</label></div><br/><div class="children"><div class="content">&gt; exception of a certain Finnish clone of that tech<p>Are you referring to C++? That was actually created by a Danish guy, who was also inspired by the object oriented Simula language created in the 60s</div><br/><div id="41899553" class="c"><input type="checkbox" id="c-41899553" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#41897588">root</a><span>|</span><a href="#41899463">parent</a><span>|</span><a href="#41897421">next</a><span>|</span><label class="collapse" for="c-41899553">[-]</label><label class="expand" for="c-41899553">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure the OP was referring to UNIX and its “Finnish clone” Linux.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41897421" class="c"><input type="checkbox" id="c-41897421" checked=""/><div class="controls bullet"><span class="by">nightfly</span><span>|</span><a href="#41897588">prev</a><span>|</span><a href="#41899794">next</a><span>|</span><label class="collapse" for="c-41897421">[-]</label><label class="expand" for="c-41897421">[15 more]</label></div><br/><div class="children"><div class="content">&gt; MySQL and Oracle store a compact delta between the new and current versions (think of it like a git diff).<p>Doesn&#x27;t git famously _not_ store diffs and instead follows the same storage pattern postgres uses here and stores the full new and old objects?</div><br/><div id="41897486" class="c"><input type="checkbox" id="c-41897486" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41897421">parent</a><span>|</span><a href="#41897457">next</a><span>|</span><label class="collapse" for="c-41897486">[-]</label><label class="expand" for="c-41897486">[2 more]</label></div><br/><div class="children"><div class="content">TBF, the quoted section doesn&#x27;t say that git stores diffs (or anything about git storage), it just says that what MySQL and Oracle stores is similar to a git diff.</div><br/><div id="41900208" class="c"><input type="checkbox" id="c-41900208" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#41897421">root</a><span>|</span><a href="#41897486">parent</a><span>|</span><a href="#41897457">next</a><span>|</span><label class="collapse" for="c-41900208">[-]</label><label class="expand" for="c-41900208">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a little too easy to misinterpret if you&#x27;re skimming and still have memories of working with SVN, mercurial, perforce, and probably others (I&#x27;ve intentionally repressed everything about tfvc).</div><br/></div></div></div></div><div id="41897457" class="c"><input type="checkbox" id="c-41897457" checked=""/><div class="controls bullet"><span class="by">jmholla</span><span>|</span><a href="#41897421">parent</a><span>|</span><a href="#41897486">prev</a><span>|</span><a href="#41899189">next</a><span>|</span><label class="collapse" for="c-41897457">[-]</label><label class="expand" for="c-41897457">[8 more]</label></div><br/><div class="children"><div class="content">That is correct. Each version of a file is a separate blob. There is some compression done by packing to make cloning faster, but the raw for git works with is these blobs.</div><br/><div id="41898446" class="c"><input type="checkbox" id="c-41898446" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#41897421">root</a><span>|</span><a href="#41897457">parent</a><span>|</span><a href="#41897535">next</a><span>|</span><label class="collapse" for="c-41898446">[-]</label><label class="expand" for="c-41898446">[1 more]</label></div><br/><div class="children"><div class="content">git&#x27;s model is a good example of layered architecture. Most of the code works in terms of whole blobs. The blob storage system, as an implementation detail, stores some blobs with diffs. The use of diffs doesn&#x27;t leak into the rest of the system. Good separation of concerns</div><br/></div></div></div></div><div id="41899189" class="c"><input type="checkbox" id="c-41899189" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41897421">parent</a><span>|</span><a href="#41897457">prev</a><span>|</span><a href="#41899164">next</a><span>|</span><label class="collapse" for="c-41899189">[-]</label><label class="expand" for="c-41899189">[1 more]</label></div><br/><div class="children"><div class="content">Others have mentioned that it said “git diffs”. However git does use deltas in pack files as a low level optimization, similar to the MySQL comparison. You don’t get back diffs from a SQL query either.</div><br/></div></div><div id="41897885" class="c"><input type="checkbox" id="c-41897885" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41897421">parent</a><span>|</span><a href="#41899164">prev</a><span>|</span><a href="#41897759">next</a><span>|</span><label class="collapse" for="c-41897885">[-]</label><label class="expand" for="c-41897885">[1 more]</label></div><br/><div class="children"><div class="content">1. The comparison was to <i>MySQL and Oracle storage</i> using <i>git diff</i> format as an analogy, not git storage.<p>2. git storage does compress, and the compression is &quot;diff-based&quot; of sorts, but it is not based on commit history as one might naively expect.</div><br/></div></div><div id="41897759" class="c"><input type="checkbox" id="c-41897759" checked=""/><div class="controls bullet"><span class="by">Hendrikto</span><span>|</span><a href="#41897421">parent</a><span>|</span><a href="#41897885">prev</a><span>|</span><a href="#41899794">next</a><span>|</span><label class="collapse" for="c-41897759">[-]</label><label class="expand" for="c-41897759">[1 more]</label></div><br/><div class="children"><div class="content">Git diffs are generated on the fly, but diffs are still diffs.</div><br/></div></div></div></div><div id="41899794" class="c"><input type="checkbox" id="c-41899794" checked=""/><div class="controls bullet"><span class="by">halayli</span><span>|</span><a href="#41897421">prev</a><span>|</span><a href="#41898326">next</a><span>|</span><label class="collapse" for="c-41899794">[-]</label><label class="expand" for="c-41899794">[4 more]</label></div><br/><div class="children"><div class="content">This topic cannot be discussed alone without talking about disks. SSDs write 4k page at a time. Meaning if you&#x27;re going to update 1 bit, the disk will read 4k, you update the bit, and it writes back a 4k page in a new slot. So the penalty for copying varies depending on the disk type.</div><br/><div id="41900275" class="c"><input type="checkbox" id="c-41900275" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#41899794">parent</a><span>|</span><a href="#41898326">next</a><span>|</span><label class="collapse" for="c-41900275">[-]</label><label class="expand" for="c-41900275">[3 more]</label></div><br/><div class="children"><div class="content">Postgres pages are 8kb so the point is moot.</div><br/><div id="41901808" class="c"><input type="checkbox" id="c-41901808" checked=""/><div class="controls bullet"><span class="by">halayli</span><span>|</span><a href="#41899794">root</a><span>|</span><a href="#41900275">parent</a><span>|</span><a href="#41901535">next</a><span>|</span><label class="collapse" for="c-41901808">[-]</label><label class="expand" for="c-41901808">[1 more]</label></div><br/><div class="children"><div class="content">I am referring to physical pages in an SSD disk. The 8k pg page maps to 2 pages in a typical SSD disk. Your comment proves my initial point, which is write amplification cannot be discussed without talking about the disk types and their behavior.</div><br/></div></div><div id="41901535" class="c"><input type="checkbox" id="c-41901535" checked=""/><div class="controls bullet"><span class="by">olavgg</span><span>|</span><a href="#41899794">root</a><span>|</span><a href="#41900275">parent</a><span>|</span><a href="#41901808">prev</a><span>|</span><a href="#41898326">next</a><span>|</span><label class="collapse" for="c-41901535">[-]</label><label class="expand" for="c-41901535">[1 more]</label></div><br/><div class="children"><div class="content">The default is 8kb, but it can be recompiled for 4kb-32kb, I actually prefer 32kb because with ZSTD compression, it will most likey only use 8kb after being compressed. Average compress ratio with ZSTD, is usually between 4x-6x. But depending on how your compressable you data is, you may also get a lot less. Note that changing this block size, will require initialization of a new data file system for your Postgres database.</div><br/></div></div></div></div></div></div><div id="41898326" class="c"><input type="checkbox" id="c-41898326" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#41899794">prev</a><span>|</span><a href="#41898543">next</a><span>|</span><label class="collapse" for="c-41898326">[-]</label><label class="expand" for="c-41898326">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Oracle and MySQL do not have this problem in their MVCC implementation because their secondary indexes do not store the physical addresses of new versions. Instead, they store a logical identifier (e.g., tuple id, primary key) that the DBMS then uses to look up the current version’s physical address. Now this may make secondary index reads slower since the DBMS has to resolve a logical identifier, but these DBMS have other advantages in their MVCC implementation to reduce overhead.<p>Interesting behavior of MySQL that I have observed (~500GB database, with a schema that is more of an document oriented than relational) is that when you update single row doing SELECT id WHERE something; UPDATE what WHERE id=id is orders of magnitudes faster than UPDATE what WHERE something. I somehow suspect that this is the reason for this behavior. But well, the normal workload will not do that and this only slows down ad-hoc DML when you fix some inconsistency.</div><br/><div id="41898716" class="c"><input type="checkbox" id="c-41898716" checked=""/><div class="controls bullet"><span class="by">whazor</span><span>|</span><a href="#41898326">parent</a><span>|</span><a href="#41898543">next</a><span>|</span><label class="collapse" for="c-41898716">[-]</label><label class="expand" for="c-41898716">[3 more]</label></div><br/><div class="children"><div class="content">A SELECT is a readonly operation and can be performed in parallel. However, an UPDATE actually writes and might lock the table. Whereas UPDATE id=id allows for row level locking. There is also the risk of missing newly inserted records between the SELECT and the UPDATE.</div><br/><div id="41898733" class="c"><input type="checkbox" id="c-41898733" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41898326">root</a><span>|</span><a href="#41898716">parent</a><span>|</span><a href="#41898543">next</a><span>|</span><label class="collapse" for="c-41898733">[-]</label><label class="expand" for="c-41898733">[2 more]</label></div><br/><div class="children"><div class="content">SELECT FOR UPDATE was invented to address this,</div><br/><div id="41898851" class="c"><input type="checkbox" id="c-41898851" checked=""/><div class="controls bullet"><span class="by">fipar</span><span>|</span><a href="#41898326">root</a><span>|</span><a href="#41898733">parent</a><span>|</span><a href="#41898543">next</a><span>|</span><label class="collapse" for="c-41898851">[-]</label><label class="expand" for="c-41898851">[1 more]</label></div><br/><div class="children"><div class="content">Or just select + update in a transaction, which with IIRC, with the default isolation level will use optimistic locking for the select part, unlike select for update.</div><br/></div></div></div></div></div></div></div></div><div id="41898543" class="c"><input type="checkbox" id="c-41898543" checked=""/><div class="controls bullet"><span class="by">thih9</span><span>|</span><a href="#41898326">prev</a><span>|</span><a href="#41897492">next</a><span>|</span><label class="collapse" for="c-41898543">[-]</label><label class="expand" for="c-41898543">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Then in the 2010s, it was MongoDB because non-durable writes made it “webscale“.<p>Off topic, it was marketing all along: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15124306">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15124306</a></div><br/><div id="41899286" class="c"><input type="checkbox" id="c-41899286" checked=""/><div class="controls bullet"><span class="by">Hilift</span><span>|</span><a href="#41898543">parent</a><span>|</span><a href="#41897492">next</a><span>|</span><label class="collapse" for="c-41899286">[-]</label><label class="expand" for="c-41899286">[1 more]</label></div><br/><div class="children"><div class="content">It was designed by former DoubleClick engineers as an afterthought DIY db for another service because no other db met their requirements. Supposedly version 4.2.8 (2020) is fairly solid, i.e. no dirty writes. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;MongoDB#Technical_criticisms" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;MongoDB#Technical_criticisms</a></div><br/></div></div></div></div><div id="41897492" class="c"><input type="checkbox" id="c-41897492" checked=""/><div class="controls bullet"><span class="by">vinnymac</span><span>|</span><a href="#41898543">prev</a><span>|</span><a href="#41898053">next</a><span>|</span><label class="collapse" for="c-41897492">[-]</label><label class="expand" for="c-41897492">[2 more]</label></div><br/><div class="children"><div class="content">The part I hate the most is that in 2024 I still need a connection pooler (such as pgbouncer) in front of it to make it usable.</div><br/><div id="41901827" class="c"><input type="checkbox" id="c-41901827" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#41897492">parent</a><span>|</span><a href="#41898053">next</a><span>|</span><label class="collapse" for="c-41901827">[-]</label><label class="expand" for="c-41901827">[1 more]</label></div><br/><div class="children"><div class="content">Let me guess, PHP?</div><br/></div></div></div></div><div id="41898053" class="c"><input type="checkbox" id="c-41898053" checked=""/><div class="controls bullet"><span class="by">fforflo</span><span>|</span><a href="#41897492">prev</a><span>|</span><a href="#41896827">next</a><span>|</span><label class="collapse" for="c-41898053">[-]</label><label class="expand" for="c-41898053">[5 more]</label></div><br/><div class="children"><div class="content">OrioleDB was supposed to tackle this problem with a new storage engine . <a href="https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb">https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb</a></div><br/><div id="41898410" class="c"><input type="checkbox" id="c-41898410" checked=""/><div class="controls bullet"><span class="by">kiwicopple</span><span>|</span><a href="#41898053">parent</a><span>|</span><a href="#41896827">next</a><span>|</span><label class="collapse" for="c-41898410">[-]</label><label class="expand" for="c-41898410">[4 more]</label></div><br/><div class="children"><div class="content">(I’m on the Supabase team)<p>Oriole has joined us at supabase now and it’s being worked on full time by Alexander and his team. Here is the patch set:<p><a href="https:&#x2F;&#x2F;www.orioledb.com&#x2F;docs#patch-set" rel="nofollow">https:&#x2F;&#x2F;www.orioledb.com&#x2F;docs#patch-set</a><p>It will be available to try on the supabase platform later this year too</div><br/><div id="41899346" class="c"><input type="checkbox" id="c-41899346" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#41898053">root</a><span>|</span><a href="#41898410">parent</a><span>|</span><a href="#41899603">next</a><span>|</span><label class="collapse" for="c-41899346">[-]</label><label class="expand" for="c-41899346">[1 more]</label></div><br/><div class="children"><div class="content">As a data point, there are easily noticeable typos on that docs page.  Might be a good idea to have someone run a spell checker over it at some point?</div><br/></div></div><div id="41899603" class="c"><input type="checkbox" id="c-41899603" checked=""/><div class="controls bullet"><span class="by">philippemnoel</span><span>|</span><a href="#41898053">root</a><span>|</span><a href="#41898410">parent</a><span>|</span><a href="#41899346">prev</a><span>|</span><a href="#41898435">next</a><span>|</span><label class="collapse" for="c-41899603">[-]</label><label class="expand" for="c-41899603">[1 more]</label></div><br/><div class="children"><div class="content">The whole ParadeDB team is really excited for OrioleDB and Supabase to ship this :) It&#x27;s long overdue in the Postgres ecosystem!</div><br/></div></div><div id="41898435" class="c"><input type="checkbox" id="c-41898435" checked=""/><div class="controls bullet"><span class="by">fforflo</span><span>|</span><a href="#41898053">root</a><span>|</span><a href="#41898410">parent</a><span>|</span><a href="#41899603">prev</a><span>|</span><a href="#41896827">next</a><span>|</span><label class="collapse" for="c-41898435">[-]</label><label class="expand" for="c-41898435">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve been keeping an eye on the pgsql-hackers discussions. Alexander+team are doing great work.</div><br/></div></div></div></div></div></div><div id="41896827" class="c"><input type="checkbox" id="c-41896827" checked=""/><div class="controls bullet"><span class="by">hlandau</span><span>|</span><a href="#41898053">prev</a><span>|</span><a href="#41900626">next</a><span>|</span><label class="collapse" for="c-41896827">[-]</label><label class="expand" for="c-41896827">[7 more]</label></div><br/><div class="children"><div class="content">With every new PostgreSQL release we see yet more features and sugar added to the frontend, yet seemingly no meaningful improvement to the backend&#x2F;storage layer which suffers these fundamental problems.<p>I wish the PostgreSQL community would stop chasing more frontend features and spend a concerted few years completely renovating their storage layer. The effort in each release seems massively and disproportionately skewed towards frontend improvements without the will to address these fundamental issues.<p>It&#x27;s absurd that in 2024, &quot;the world&#x27;s most advanced open source database&quot; doesn&#x27;t have a method of doing upgrades between major versions that doesn&#x27;t involve taking the database down.<p>Yes, logical replication exists, but it still doesn&#x27;t do DDL, so it has big caveats attached.</div><br/><div id="41897077" class="c"><input type="checkbox" id="c-41897077" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#41896827">parent</a><span>|</span><a href="#41896999">next</a><span>|</span><label class="collapse" for="c-41897077">[-]</label><label class="expand" for="c-41897077">[2 more]</label></div><br/><div class="children"><div class="content">The design of good storage layers in databases is deeply architectural. As a consequence, it is essentially a &quot;forever&quot; design decision. Fundamentally changing the storage architecture will alter the set of tradeoffs being made such that it will break the assumptions of existing user applications, which is generally considered a Very Bad Thing. The existing architecture, with all its quirks and behaviors, is part of the public API (see also: Hyrum&#x27;s Law).<p>In practice, the only way to change the fundamental architecture of a database is to write a new one, with everything that entails.</div><br/><div id="41901775" class="c"><input type="checkbox" id="c-41901775" checked=""/><div class="controls bullet"><span class="by">Negitivefrags</span><span>|</span><a href="#41896827">root</a><span>|</span><a href="#41897077">parent</a><span>|</span><a href="#41896999">next</a><span>|</span><label class="collapse" for="c-41901775">[-]</label><label class="expand" for="c-41901775">[1 more]</label></div><br/><div class="children"><div class="content">You could select which storage approach on a per table level. That way the new characteristics don’t surprise anyone.</div><br/></div></div></div></div><div id="41896999" class="c"><input type="checkbox" id="c-41896999" checked=""/><div class="controls bullet"><span class="by">factormeta</span><span>|</span><a href="#41896827">parent</a><span>|</span><a href="#41897077">prev</a><span>|</span><a href="#41897049">next</a><span>|</span><label class="collapse" for="c-41896999">[-]</label><label class="expand" for="c-41896999">[1 more]</label></div><br/><div class="children"><div class="content">what about <a href="https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb">https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb</a> ?</div><br/></div></div><div id="41897049" class="c"><input type="checkbox" id="c-41897049" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#41896827">parent</a><span>|</span><a href="#41896999">prev</a><span>|</span><a href="#41897182">next</a><span>|</span><label class="collapse" for="c-41897049">[-]</label><label class="expand" for="c-41897049">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a method of doing upgrades between major versions that doesn&#x27;t involve taking the database down.<p>For large instances this is a big ask, especially of a project without single person in charge. MySQL does have better replication, yet still often requires manually setting that up and cutting it over to do major version upgrades.</div><br/></div></div><div id="41897182" class="c"><input type="checkbox" id="c-41897182" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#41896827">parent</a><span>|</span><a href="#41897049">prev</a><span>|</span><a href="#41900626">next</a><span>|</span><label class="collapse" for="c-41897182">[-]</label><label class="expand" for="c-41897182">[2 more]</label></div><br/><div class="children"><div class="content">Better yet: decouple front and back ends. Let them talk over a stable interface and evolve independently. The SQLite ecosystem is evolving in this direction, in fits and starts.</div><br/><div id="41897304" class="c"><input type="checkbox" id="c-41897304" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#41896827">root</a><span>|</span><a href="#41897182">parent</a><span>|</span><a href="#41900626">next</a><span>|</span><label class="collapse" for="c-41897304">[-]</label><label class="expand" for="c-41897304">[1 more]</label></div><br/><div class="children"><div class="content">You can implement a different mvcc model today, without patching code.</div><br/></div></div></div></div></div></div><div id="41900626" class="c"><input type="checkbox" id="c-41900626" checked=""/><div class="controls bullet"><span class="by">WuxiFingerHold</span><span>|</span><a href="#41896827">prev</a><span>|</span><a href="#41901448">next</a><span>|</span><label class="collapse" for="c-41900626">[-]</label><label class="expand" for="c-41900626">[3 more]</label></div><br/><div class="children"><div class="content">Putting aside the license &#x2F; closed source issues with CockroachDB (CRDB) and just focus at it technically: CRDB uses MVVM too, but its storage is a key-value store. I know it uses some kind of garbage collection to remove the old versions.<p>I wonder if CRDB (or other newer designed DBs) has circumvented those issues? Or don&#x27;t we just hear from those issues as CRDB and the other newer DBs are not that widely used and mainly in the commercial space?</div><br/><div id="41901017" class="c"><input type="checkbox" id="c-41901017" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#41900626">parent</a><span>|</span><a href="#41901777">next</a><span>|</span><label class="collapse" for="c-41901017">[-]</label><label class="expand" for="c-41901017">[1 more]</label></div><br/><div class="children"><div class="content">CRDB will be slower than PG on the same hardware.With CRDB you are trading off performance for ability to scale horizontally.</div><br/></div></div><div id="41901777" class="c"><input type="checkbox" id="c-41901777" checked=""/><div class="controls bullet"><span class="by">ddorian43</span><span>|</span><a href="#41900626">parent</a><span>|</span><a href="#41901017">prev</a><span>|</span><a href="#41901448">next</a><span>|</span><label class="collapse" for="c-41901777">[-]</label><label class="expand" for="c-41901777">[1 more]</label></div><br/><div class="children"><div class="content">This is fixed in YugabyteDB that reuses the PostgreSQL query layer source code but uses it&#x27;s own storage: <a href="https:&#x2F;&#x2F;www.yugabyte.com&#x2F;blog&#x2F;improve-postgresql&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.yugabyte.com&#x2F;blog&#x2F;improve-postgresql&#x2F;</a> (other issues too like XID wraparound etc).<p>It&#x27;s also apache2 license.</div><br/></div></div></div></div><div id="41901448" class="c"><input type="checkbox" id="c-41901448" checked=""/><div class="controls bullet"><span class="by">bluedonuts</span><span>|</span><a href="#41900626">prev</a><span>|</span><a href="#41898232">next</a><span>|</span><label class="collapse" for="c-41901448">[-]</label><label class="expand" for="c-41901448">[1 more]</label></div><br/><div class="children"><div class="content">Loved this post! Could anyone recommend a book (or other medium) with similar content about RMBDS internals?</div><br/></div></div><div id="41898232" class="c"><input type="checkbox" id="c-41898232" checked=""/><div class="controls bullet"><span class="by">thr0w</span><span>|</span><a href="#41901448">prev</a><span>|</span><a href="#41900026">next</a><span>|</span><label class="collapse" for="c-41898232">[-]</label><label class="expand" for="c-41898232">[3 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t agree with their characterization of `pg_repack`. `VACUUM FULL` is definitely crushing, but that&#x27;s why repack exists as a faster&#x2F;lighter alternative. Anyone have a different experience?</div><br/><div id="41899466" class="c"><input type="checkbox" id="c-41899466" checked=""/><div class="controls bullet"><span class="by">fovc</span><span>|</span><a href="#41898232">parent</a><span>|</span><a href="#41898486">next</a><span>|</span><label class="collapse" for="c-41899466">[-]</label><label class="expand" for="c-41899466">[1 more]</label></div><br/><div class="children"><div class="content">The requirement for having two copies of the table simultaneously on systems that make it easy to add but not subtract storage. Otherwise pg_repack has worked really well.<p>We solved the 2x storage with partitions, but it feels like the tail wagging the dog</div><br/></div></div><div id="41898486" class="c"><input type="checkbox" id="c-41898486" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#41898232">parent</a><span>|</span><a href="#41899466">prev</a><span>|</span><a href="#41900026">next</a><span>|</span><label class="collapse" for="c-41898486">[-]</label><label class="expand" for="c-41898486">[1 more]</label></div><br/><div class="children"><div class="content">pg_repack is an hack-ish solution to do what VACUUM FULL does without completely locking the relation in question. But well, when you care about either of these things, your workload has significant issues, with the typical case being using pgsql as a backend for something that was originally a thick client designed for some kind of RDBMS based on shared files (InterBase mentioned in TFA, MS Jet whatever…)</div><br/></div></div></div></div><div id="41900026" class="c"><input type="checkbox" id="c-41900026" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#41898232">prev</a><span>|</span><a href="#41898780">next</a><span>|</span><label class="collapse" for="c-41900026">[-]</label><label class="expand" for="c-41900026">[3 more]</label></div><br/><div class="children"><div class="content">So, if this is such a problem, my question is — are the poor MVCC choices of Postgres enough to make the authors (or people here) recommend another RDBMS?</div><br/><div id="41900276" class="c"><input type="checkbox" id="c-41900276" checked=""/><div class="controls bullet"><span class="by">abenga</span><span>|</span><a href="#41900026">parent</a><span>|</span><a href="#41898780">next</a><span>|</span><label class="collapse" for="c-41900276">[-]</label><label class="expand" for="c-41900276">[2 more]</label></div><br/><div class="children"><div class="content">The last couple of paragraphs of the article answer this. (The answer is No).</div><br/><div id="41900542" class="c"><input type="checkbox" id="c-41900542" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#41900026">root</a><span>|</span><a href="#41900276">parent</a><span>|</span><a href="#41898780">next</a><span>|</span><label class="collapse" for="c-41900542">[-]</label><label class="expand" for="c-41900542">[1 more]</label></div><br/><div class="children"><div class="content">Thanks - I completely missed the “concluding remarks” paragraph the first time. After the “problems” sections, I apparently just stopped reading.<p>For others who are curious:<p><i>&gt; But please don’t misunderstand our diatribe to mean that we don’t think you should ever use PostgreSQL. Although its MVCC implementation is the wrong way to do it, PostgreSQL is still our favorite DBMS. To love something is to be willing to work with its flaws. </i></div><br/></div></div></div></div></div></div><div id="41898780" class="c"><input type="checkbox" id="c-41898780" checked=""/><div class="controls bullet"><span class="by">OrvalWintermute</span><span>|</span><a href="#41900026">prev</a><span>|</span><a href="#41897751">next</a><span>|</span><label class="collapse" for="c-41898780">[-]</label><label class="expand" for="c-41898780">[1 more]</label></div><br/><div class="children"><div class="content">This article is incorrect IMO - the following section in particular.<p>“ In the 2000s, the conventional wisdom selected MySQL because rising tech stars like Google and Facebook were using it. Then in the 2010s, it was MongoDB because non-durable writes made it “webscale“. In the last five years, PostgreSQL has become the Internet’s darling DBMS. And for good reasons! It’s dependable, feature-rich, extensible, and well-suited for most operational workloads.”<p>Smart engineers were choosing postgres not because of the logical fallacy of popularum, but for the following reasons:<p>Data safety - not MyIsam,
ACID,
Similarity to Oracle,
MVCC,
SQL standards adherence,
Postgres team,
Helpful awesome community,
Data types,
High performance,
BSD flexibility<p>Above are the reasons I selected Postgres while at ATT early 2000s and our Oracle DBA found it a very easy transition. While Mysql went through rough transitions, PG has gone from strength to strength and ever improving path.<p>I think Bruce Momjian is a big part of this success; they truly have an excellent community.
&lt;3</div><br/></div></div><div id="41897751" class="c"><input type="checkbox" id="c-41897751" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#41898780">prev</a><span>|</span><a href="#41897894">next</a><span>|</span><label class="collapse" for="c-41897751">[-]</label><label class="expand" for="c-41897751">[3 more]</label></div><br/><div class="children"><div class="content">Question: is storing full new row-tuple versions something fundamental to Postgres as a whole, or is it just a property of the default storage engine &#x2F; “table access method”?</div><br/><div id="41898523" class="c"><input type="checkbox" id="c-41898523" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#41897751">parent</a><span>|</span><a href="#41897917">next</a><span>|</span><label class="collapse" for="c-41898523">[-]</label><label class="expand" for="c-41898523">[1 more]</label></div><br/><div class="children"><div class="content">From the PQ protocol PoV the way how this works is pretty much irrelevant, but the actual implementation of PostgreSQL contains ridiculous amount of places that depend on the “backward” MVCC implementation of the tuple heaps.</div><br/></div></div><div id="41897917" class="c"><input type="checkbox" id="c-41897917" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41897751">parent</a><span>|</span><a href="#41898523">prev</a><span>|</span><a href="#41897894">next</a><span>|</span><label class="collapse" for="c-41897917">[-]</label><label class="expand" for="c-41897917">[1 more]</label></div><br/><div class="children"><div class="content">You could store partial tuples without disrupting the interface.<p>Though full tuples is pretty fundamental to the underlying implementation....MVCC, VACUUM, etc. It&#x27;d be a massive change to say the least.</div><br/></div></div></div></div><div id="41897894" class="c"><input type="checkbox" id="c-41897894" checked=""/><div class="controls bullet"><span class="by">msie</span><span>|</span><a href="#41897751">prev</a><span>|</span><a href="#41900307">next</a><span>|</span><label class="collapse" for="c-41897894">[-]</label><label class="expand" for="c-41897894">[1 more]</label></div><br/><div class="children"><div class="content">Nicely written article. Easy to read and understand!</div><br/></div></div><div id="41900307" class="c"><input type="checkbox" id="c-41900307" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#41897894">prev</a><span>|</span><a href="#41897284">next</a><span>|</span><label class="collapse" for="c-41900307">[-]</label><label class="expand" for="c-41900307">[1 more]</label></div><br/><div class="children"><div class="content">It’s really annoying to see people write that Postgres has a “primary index” and “secondary indexes”. No. That’s not what those words mean. Every index in Postgres is a secondary index.</div><br/></div></div><div id="41897284" class="c"><input type="checkbox" id="c-41897284" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41900307">prev</a><span>|</span><a href="#41897553">next</a><span>|</span><label class="collapse" for="c-41897284">[-]</label><label class="expand" for="c-41897284">[3 more]</label></div><br/><div class="children"><div class="content">The article says the benefit of O2N is there&#x27;s no need to immediately update indexes, but then goes on to say postgres updates the indexes anyway! So is there actually any advantage to O2N at all?</div><br/><div id="41897608" class="c"><input type="checkbox" id="c-41897608" checked=""/><div class="controls bullet"><span class="by">apavlo</span><span>|</span><a href="#41897284">parent</a><span>|</span><a href="#41897609">next</a><span>|</span><label class="collapse" for="c-41897608">[-]</label><label class="expand" for="c-41897608">[1 more]</label></div><br/><div class="children"><div class="content">If all table pages exist in memory and you are using cooperative GC, then O2N can be preferable. As workers scan version chains, they can clean up dead tuples without taking additional locks.<p>This is what Microsoft Hekaton does.</div><br/></div></div><div id="41897609" class="c"><input type="checkbox" id="c-41897609" checked=""/><div class="controls bullet"><span class="by">kikimora</span><span>|</span><a href="#41897284">parent</a><span>|</span><a href="#41897608">prev</a><span>|</span><a href="#41897553">next</a><span>|</span><label class="collapse" for="c-41897609">[-]</label><label class="expand" for="c-41897609">[1 more]</label></div><br/><div class="children"><div class="content">Good question! Also they point out that famous Uber article erroneously mentions write amplification caused by what they thought was N2O. IDK if write amplification is real or not. But if it is really O2N then there is no apparent reason for write amplification and entire Uber article might had been based on the wrong premise.</div><br/></div></div></div></div><div id="41897553" class="c"><input type="checkbox" id="c-41897553" checked=""/><div class="controls bullet"><span class="by">avg_dev</span><span>|</span><a href="#41897284">prev</a><span>|</span><a href="#41896249">next</a><span>|</span><label class="collapse" for="c-41897553">[-]</label><label class="expand" for="c-41897553">[1 more]</label></div><br/><div class="children"><div class="content">pretty informative. now i understand why people are often having issues with vacuum-related stuff. i like the diagrams too.</div><br/></div></div><div id="41896249" class="c"><input type="checkbox" id="c-41896249" checked=""/><div class="controls bullet"><span class="by">terminalbraid</span><span>|</span><a href="#41897553">prev</a><span>|</span><a href="#41897140">next</a><span>|</span><label class="collapse" for="c-41896249">[-]</label><label class="expand" for="c-41896249">[6 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41892830">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41892830</a></div><br/><div id="41897128" class="c"><input type="checkbox" id="c-41897128" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41896249">parent</a><span>|</span><a href="#41898993">next</a><span>|</span><label class="collapse" for="c-41897128">[-]</label><label class="expand" for="c-41897128">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for pointing this out, it&#x27;s an existing discussion started half a day ago with 5 comments:<p><i>The Part of PostgreSQL We Hate the Most (2023)</i><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41892830">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41892830</a></div><br/></div></div><div id="41898993" class="c"><input type="checkbox" id="c-41898993" checked=""/><div class="controls bullet"><span class="by">evanelias</span><span>|</span><a href="#41896249">parent</a><span>|</span><a href="#41897128">prev</a><span>|</span><a href="#41898153">next</a><span>|</span><label class="collapse" for="c-41898993">[-]</label><label class="expand" for="c-41898993">[1 more]</label></div><br/><div class="children"><div class="content">The overall topic was also discussed extensively in this subthread from 6 days ago:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41837317">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41837317</a></div><br/></div></div><div id="41898153" class="c"><input type="checkbox" id="c-41898153" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#41896249">parent</a><span>|</span><a href="#41898993">prev</a><span>|</span><a href="#41897142">next</a><span>|</span><label class="collapse" for="c-41898153">[-]</label><label class="expand" for="c-41898153">[2 more]</label></div><br/><div class="children"><div class="content">@dang maybe merge these threads?</div><br/><div id="41901201" class="c"><input type="checkbox" id="c-41901201" checked=""/><div class="controls bullet"><span class="by">wordofx</span><span>|</span><a href="#41896249">root</a><span>|</span><a href="#41898153">parent</a><span>|</span><a href="#41897142">next</a><span>|</span><label class="collapse" for="c-41901201">[-]</label><label class="expand" for="c-41901201">[1 more]</label></div><br/><div class="children"><div class="content">No</div><br/></div></div></div></div></div></div><div id="41898538" class="c"><input type="checkbox" id="c-41898538" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#41897714">prev</a><span>|</span><label class="collapse" for="c-41898538">[-]</label><label class="expand" for="c-41898538">[5 more]</label></div><br/><div class="children"><div class="content">For most cases, MVCC sounds like over-engineering. From the problem description:<p>&gt; The goal of MVCC in a DBMS is to allow multiple queries to read and write to the database simultaneously without interfering with each other when possible.<p>How is that a problem for most use cases?<p>If there is a read query which is taking a long time, with many rows, and some of these later rows happen to be updated mid-read but the earlier rows are not... It&#x27;s not really a problem for the vast majority of application. Why is it better for all rows to be delivered out of date versus just the first half fetched being out of date? It&#x27;s not ideal in either case but it&#x27;s unavoidable that some requests can sometimes return out of date data. It seems like a tiny advantage.<p>I suspect the real need to implement MVCC arose out of the desire for databases like Postgres to implement atomic transactions as a magical black box.<p>IMO, two-phase commit is a simpler solution to this problem. It&#x27;s not possible to fully hide concurrency complexity from the user; it ends up with tradeoffs.</div><br/><div id="41898609" class="c"><input type="checkbox" id="c-41898609" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41898538">parent</a><span>|</span><label class="collapse" for="c-41898609">[-]</label><label class="expand" for="c-41898609">[4 more]</label></div><br/><div class="children"><div class="content">One person&#x27;s over engineering is another person&#x27;s essential feature. I personally like the fact that Postgres supports the serializable isolation level that simplifies application programming.<p>&gt; It&#x27;s not really a problem for the vast majority of application.<p>This is true, but I don&#x27;t even want to think about when it is indeed not really a problem and in the few cases when it is a problem.</div><br/><div id="41898746" class="c"><input type="checkbox" id="c-41898746" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41898538">root</a><span>|</span><a href="#41898609">parent</a><span>|</span><label class="collapse" for="c-41898746">[-]</label><label class="expand" for="c-41898746">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I personally like the fact that Postgres supports the serializable isolation level that simplifies application programming.<p>Not sure how PG implements it, but I tried it in a case where I did need it in SQLAnywhere, and only found out a bit too late that while the docs stated it was very detrimental to performance, the docs didn&#x27;t explicitly say <i>why</i>, and it was much worse than I had assumed.<p>I assumed it meant the transaction would lock the table, do it&#x27;s thing and release on commit&#x2F;rollback. And of course, that would hurt performance a lot if there was high contention. But no, that&#x27;s not what it did. It was much, <i>much</i> worse.<p>Instead of taking a lock on the whole table, it locked all the rows. Which went as swimmingly as you could expect on a table with thousands upon thousands of rows.<p>Not sure why they did it this way, but yeah had to ditch that and went with the good old retry loop.</div><br/><div id="41900778" class="c"><input type="checkbox" id="c-41900778" checked=""/><div class="controls bullet"><span class="by">sitharus</span><span>|</span><a href="#41898538">root</a><span>|</span><a href="#41898746">parent</a><span>|</span><label class="collapse" for="c-41900778">[-]</label><label class="expand" for="c-41900778">[2 more]</label></div><br/><div class="children"><div class="content">One of the best things about postgresql is the documentation. They document not only the features, but the constraints and considerations for using it and why they exist.<p>So from reading <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;17&#x2F;transaction-iso.html#XACT-SERIALIZABLE" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;17&#x2F;transaction-iso.html#XACT...</a> we can tell that using serializable transactions only locks data actually used.</div><br/><div id="41901173" class="c"><input type="checkbox" id="c-41901173" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41898538">root</a><span>|</span><a href="#41900778">parent</a><span>|</span><label class="collapse" for="c-41901173">[-]</label><label class="expand" for="c-41901173">[1 more]</label></div><br/><div class="children"><div class="content">Yea that&#x27;s much, much better. I also note that it goes for the retry instead of locking.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>