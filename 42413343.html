<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734166872139" as="style"/><link rel="stylesheet" href="styles.css?v=1734166872139"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/rochus-keller/Luon/blob/master/Readme.md">Luon programming language</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>47 comments</span></div><br/><div><div id="42413787" class="c"><input type="checkbox" id="c-42413787" checked=""/><div class="controls bullet"><span class="by">owenm</span><span>|</span><a href="#42413614">next</a><span>|</span><label class="collapse" for="c-42413787">[-]</label><label class="expand" for="c-42413787">[10 more]</label></div><br/><div class="children"><div class="content">This is an impressive achievement, given there’s a whole language plus IDE.  Kudos to the author.  I couldn’t see any indication of what the author plans to use it for - I hope he can share more below?<p>I’m intrigued by the LeanQt library as well that the IDE uses (<a href="https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;LeanQt">https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;LeanQt</a>) too.</div><br/><div id="42413864" class="c"><input type="checkbox" id="c-42413864" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#42413787">parent</a><span>|</span><a href="#42414090">next</a><span>|</span><label class="collapse" for="c-42413864">[-]</label><label class="expand" for="c-42413864">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>what the author plans to use it for</i><p>Thanks. I e.g. re-implemented the Smalltalk-80 VM in Luon (see <a href="https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;Smalltalk&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;Smalltalk&#x2F;</a>), and I consider implementing an Interlisp VM (see <a href="https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;gingko&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;gingko&#x2F;</a>) which uses LuaJIT, which was an important motivation to interrupt my Micron language project to implement Luon.</div><br/><div id="42414815" class="c"><input type="checkbox" id="c-42414815" checked=""/><div class="controls bullet"><span class="by">pkphilip</span><span>|</span><a href="#42413787">root</a><span>|</span><a href="#42413864">parent</a><span>|</span><a href="#42414630">next</a><span>|</span><label class="collapse" for="c-42414815">[-]</label><label class="expand" for="c-42414815">[1 more]</label></div><br/><div class="children"><div class="content">Amazing that you also managed to implement Smalltalk besides Oberon and Luon - all of them with IDEs!<p>Wow!<p>And by the way the startup speed of the IFE is just insane! it is actually faster than my simple text editor!</div><br/></div></div><div id="42414630" class="c"><input type="checkbox" id="c-42414630" checked=""/><div class="controls bullet"><span class="by">owenm</span><span>|</span><a href="#42413787">root</a><span>|</span><a href="#42413864">parent</a><span>|</span><a href="#42414815">prev</a><span>|</span><a href="#42413879">next</a><span>|</span><label class="collapse" for="c-42414630">[-]</label><label class="expand" for="c-42414630">[1 more]</label></div><br/><div class="children"><div class="content">The Interlisp VM sounds awesome - I would love to see Notecards on Windows&#x2F;Linux&#x2F;Mac natively!</div><br/></div></div><div id="42413879" class="c"><input type="checkbox" id="c-42413879" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#42413787">root</a><span>|</span><a href="#42413864">parent</a><span>|</span><a href="#42414630">prev</a><span>|</span><a href="#42414090">next</a><span>|</span><label class="collapse" for="c-42413879">[-]</label><label class="expand" for="c-42413879">[2 more]</label></div><br/><div class="children"><div class="content">nice! do you feel like oberon has something that gives it an edge over more currently popular languages, or is it just a matter of personal preference?</div><br/><div id="42413929" class="c"><input type="checkbox" id="c-42413929" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#42413787">root</a><span>|</span><a href="#42413879">parent</a><span>|</span><a href="#42414090">next</a><span>|</span><label class="collapse" for="c-42413929">[-]</label><label class="expand" for="c-42413929">[1 more]</label></div><br/><div class="children"><div class="content">Actually, I only use original Oberon when I&#x27;m migrating the old Oberon systems. My interest lies in finding out how I would have to modify original Oberon to be as productive as I am used to with e.g. C++, but still adhering to the goal of simplicity. My version, which I call Oberon+ (and to which Luon is quite similar, whereas Luon is even simpler), goes in this direction.<p>Actually an &quot;edge over more currently popular languages&quot; from my humble point of view is the goal and maintenance of simplicity. The term is subjective, but if you look at many of today&#x27;s completely overloaded languages, it is intuitive to understand.</div><br/></div></div></div></div></div></div><div id="42414090" class="c"><input type="checkbox" id="c-42414090" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#42413787">parent</a><span>|</span><a href="#42413864">prev</a><span>|</span><a href="#42413872">next</a><span>|</span><label class="collapse" for="c-42414090">[-]</label><label class="expand" for="c-42414090">[3 more]</label></div><br/><div class="children"><div class="content">Amazing project!<p>I get the appeal to write an IDE from scratch, especially if you are already an expert in writing GUIs with your framework of choice! I wonder if it would make more sense to spend that time writing a language server protocol daemon. That way, you could make your language available in any IDEs your users like that support LSP.</div><br/><div id="42414179" class="c"><input type="checkbox" id="c-42414179" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#42413787">root</a><span>|</span><a href="#42414090">parent</a><span>|</span><a href="#42413872">next</a><span>|</span><label class="collapse" for="c-42414179">[-]</label><label class="expand" for="c-42414179">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m usually working on older machines on which the IDE&#x27;s supporting language servers would be much too slow or wouldn&#x27;t work at all because of incompatibilities. I like lean tools with little dependencies. But there is a parser in moderate C++, so maybe someone else will implement such a daemon.</div><br/><div id="42414834" class="c"><input type="checkbox" id="c-42414834" checked=""/><div class="controls bullet"><span class="by">devin</span><span>|</span><a href="#42413787">root</a><span>|</span><a href="#42414179">parent</a><span>|</span><a href="#42413872">next</a><span>|</span><label class="collapse" for="c-42414834">[-]</label><label class="expand" for="c-42414834">[1 more]</label></div><br/><div class="children"><div class="content">Could I ask why you find yourself working on older machines? Work? A fan of retro computing? Something else?</div><br/></div></div></div></div></div></div></div></div><div id="42413614" class="c"><input type="checkbox" id="c-42413614" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#42413787">prev</a><span>|</span><a href="#42413612">next</a><span>|</span><label class="collapse" for="c-42413614">[-]</label><label class="expand" for="c-42413614">[26 more]</label></div><br/><div class="children"><div class="content">Luon looks mostly like Oberon and not so much like Lua, it&#x27;s not obvious which of the Lua features it incorporated.  It didn&#x27;t seem to have coroutines, for example.<p>But I am glad that it went with Oberon&#x27;s 0-based array indices, as opposed to Lua&#x27;s 1-based table indices.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;Luon&#x2F;blob&#x2F;master&#x2F;specification&#x2F;The_Programming_Language_Luon.adoc#array-types">https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;Luon&#x2F;blob&#x2F;master&#x2F;specificat...</a></div><br/><div id="42413843" class="c"><input type="checkbox" id="c-42413843" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#42413614">parent</a><span>|</span><a href="#42415426">next</a><span>|</span><label class="collapse" for="c-42413843">[-]</label><label class="expand" for="c-42413843">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Luon looks mostly like Oberon and not so much like Lua</i><p>Luon can indeed look similar to Oberon if you use upper-case keywords and semicolons, but there is not need for this. Both - Lua and Luon - have much in common with Modula-2 (given lower-case keywords). There are many elements in Luon which are pretty similar to Lua, e.g. constructors, pcall, most control and loop statements. But there are also significant differences of course, because Luon is a statically typed language and Lua isn&#x27;t.</div><br/></div></div><div id="42415426" class="c"><input type="checkbox" id="c-42415426" checked=""/><div class="controls bullet"><span class="by">ninalanyon</span><span>|</span><a href="#42413614">parent</a><span>|</span><a href="#42413843">prev</a><span>|</span><a href="#42413686">next</a><span>|</span><label class="collapse" for="c-42415426">[-]</label><label class="expand" for="c-42415426">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t all of Wirth&#x27;s languages let you use any ordinal as the array index?  At leat in Pascal you can declare an integer subtype, say 7..17 and use that as the type of the index of an array.  Then the first element is item 7.<p>The point being that both the start at 0 and start at 1 camps can have it their own way.</div><br/></div></div><div id="42413686" class="c"><input type="checkbox" id="c-42413686" checked=""/><div class="controls bullet"><span class="by">dmz73</span><span>|</span><a href="#42413614">parent</a><span>|</span><a href="#42415426">prev</a><span>|</span><a href="#42413612">next</a><span>|</span><label class="collapse" for="c-42413686">[-]</label><label class="expand" for="c-42413686">[23 more]</label></div><br/><div class="children"><div class="content">I have a really hard time understanding why people like 0 based indexes. 
They are a relic of C style arrays that are based on and interchangeable with pointers which use offsets that are naturally 0 based.
Use in later languages gives us endless off-by-1 issues and rise to &quot;for 0 to count&#x2F;len&#x2F;num - 1&quot; or even better range syntax that is start inclusive BUT end exclusive.
It is a horrible cludge just to support 1970s language perfomace optimization.
Arrays should start and end at whatever start index is required, not at offset 0 of pointer to fist element of array.</div><br/><div id="42413753" class="c"><input type="checkbox" id="c-42413753" checked=""/><div class="controls bullet"><span class="by">Benjamin_Dobell</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413686">parent</a><span>|</span><a href="#42415312">next</a><span>|</span><label class="collapse" for="c-42413753">[-]</label><label class="expand" for="c-42413753">[11 more]</label></div><br/><div class="children"><div class="content">Hang on. Off by one issues are the argument frequently given in favour of zero-based indices, not the other way around. For example, let&#x27;s iterate through items placing them in 3 different groups;<p>JS:<p><pre><code>    for (let i = 0; i &lt; items.length; i++) {
        groups[i % 3].push(items[i]);
    }
</code></pre>
Lua:<p><pre><code>    for i = 1, #items do
        table.insert(groups[((i - 1) % 3) + 1], items[i])
    end
</code></pre>
Don&#x27;t get me wrong. I like Lua, I&#x27;ve made my own IDE for it, <a href="https:&#x2F;&#x2F;plugins.jetbrains.com&#x2F;plugin&#x2F;14698-luanalysis" rel="nofollow">https:&#x2F;&#x2F;plugins.jetbrains.com&#x2F;plugin&#x2F;14698-luanalysis</a>, but this is definitely not an argument in favour of 1-based indices.</div><br/><div id="42415339" class="c"><input type="checkbox" id="c-42415339" checked=""/><div class="controls bullet"><span class="by">geocar</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413753">parent</a><span>|</span><a href="#42414346">next</a><span>|</span><label class="collapse" for="c-42415339">[-]</label><label class="expand" for="c-42415339">[1 more]</label></div><br/><div class="children"><div class="content">Off by one issues are also an argument given in favour of <i>no</i> indexing.<p><pre><code>    groups=new Array(3).fill([])
    items.reduce(function(a,x,y){y=a.shift();y.push(x);a.push(y);return a},groups)
</code></pre>
Array languages typically have a reshaping operator so that you can just do something like:<p><pre><code>    groups:3 0N#items
</code></pre>
Does that seem so strange? 0N is just null. numpy has ...reshape([3,-1]) which wouldn&#x27;t be so bad in a hypothetical numjs or numlu; I think null is better, so surely this would be nice:<p><pre><code>    groups = table.reshape(items,{3,nil})   -- numlu?
    groups = items.reshape([3,null])        &#x2F;&#x2F; numjs?
</code></pre>
Such a function could hide an ugly iteration if it were performant to do so. No reason for the programmer to see it every day. Working at rank is better.<p>On the other hand, Erlang is also 1-based, and there&#x27;s no numerl I know of, so I might write:<p><pre><code>    f(N,Items) -&gt; f_(erlang:make_tuple(N,[]),Items,0,N).
    f_(Groups,[],_,_N) -&gt; Groups;
    f_(G,Items,0,N) -&gt; f_(G,Items,N,N);
    f_(G,[X|XS],I,N) -&gt; f_(setelement(I,G,X),XS,I-1,N).
</code></pre>
I don&#x27;t think that&#x27;s too bad either, and it seems straightforward to translate to lua. Working backwards maybe makes the 1-based indexing a little more natural.<p><pre><code>    n = 0
    for i = 1,#items do
      if n &lt; 1 then n = #groups end
      table.insert(groups[n],items[i])
      n = n - 1
    end
</code></pre>
Does that seem right? I don&#x27;t program in lua very much these days, but the ugly thing to me is the for-loop  and how much typing it is (a complaint I also have about Erlang), not the one-based nature of the index I have in exactly one place in the program.<p>The cool thing about one-based indexes is that 0 meaningfully represents the position before the first element or not-an-element. If you use zero-based indexes, you&#x27;re forced to either use -1 which precludes its use for referring to the end of the list, or null which isn&#x27;t great for complicated reasons. There are other mathematical reasons for preferring 1-based indexes, but I don&#x27;t think they&#x27;re as cool as that.</div><br/></div></div><div id="42414346" class="c"><input type="checkbox" id="c-42414346" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413753">parent</a><span>|</span><a href="#42415339">prev</a><span>|</span><a href="#42414056">next</a><span>|</span><label class="collapse" for="c-42414346">[-]</label><label class="expand" for="c-42414346">[3 more]</label></div><br/><div class="children"><div class="content">why not just iterate in steps of three over items for each next group?  seems a bit contrived.</div><br/><div id="42414499" class="c"><input type="checkbox" id="c-42414499" checked=""/><div class="controls bullet"><span class="by">Benjamin_Dobell</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42414346">parent</a><span>|</span><a href="#42414056">next</a><span>|</span><label class="collapse" for="c-42414499">[-]</label><label class="expand" for="c-42414499">[2 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s a simplified example to demonstrate the problem. If you do as you&#x27;ve described you need three separate assignments. What happens when the number of groups is dynamic? Nested loop? This is suddenly getting a lot more complicated.</div><br/><div id="42415226" class="c"><input type="checkbox" id="c-42415226" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42414499">parent</a><span>|</span><a href="#42414056">next</a><span>|</span><label class="collapse" for="c-42415226">[-]</label><label class="expand" for="c-42415226">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that’s what I was saying:<p>for each group:<p>for i in steps of #groups:<p>assign item to this group<p>I think that’s a lot easier to comprehend than the modulus trick</div><br/></div></div></div></div></div></div><div id="42414056" class="c"><input type="checkbox" id="c-42414056" checked=""/><div class="controls bullet"><span class="by">Jerrrry</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413753">parent</a><span>|</span><a href="#42414346">prev</a><span>|</span><a href="#42415312">next</a><span>|</span><label class="collapse" for="c-42414056">[-]</label><label class="expand" for="c-42414056">[6 more]</label></div><br/><div class="children"><div class="content">Your second example subtracts and adds 1 nearly arbitrarily, which wouldn&#x27;t be needed if the convention of the 0-index wasn&#x27;t so widespread.</div><br/><div id="42414298" class="c"><input type="checkbox" id="c-42414298" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42414056">parent</a><span>|</span><a href="#42415312">next</a><span>|</span><label class="collapse" for="c-42414298">[-]</label><label class="expand" for="c-42414298">[5 more]</label></div><br/><div class="children"><div class="content">You need the first three elements to go into the first group, the next three to go into the second group, and so on. How would you write it?</div><br/><div id="42414376" class="c"><input type="checkbox" id="c-42414376" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42414298">parent</a><span>|</span><a href="#42415312">next</a><span>|</span><label class="collapse" for="c-42414376">[-]</label><label class="expand" for="c-42414376">[4 more]</label></div><br/><div class="children"><div class="content">That’s not what that loop does, it puts one item into each next group and loops back over the groups after every three items.  Really it ought to be a by-three stepped loop over items, inserting each into each group inline:<p>groups[1], groups[2], groups[3] = items[i], items[i+1], items[i+2]<p>If the group count is dynamic, you can just loop over groups instead, and then step through items by #groups, inserting.</div><br/><div id="42414718" class="c"><input type="checkbox" id="c-42414718" checked=""/><div class="controls bullet"><span class="by">Benjamin_Dobell</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42414376">parent</a><span>|</span><a href="#42414403">next</a><span>|</span><label class="collapse" for="c-42414718">[-]</label><label class="expand" for="c-42414718">[2 more]</label></div><br/><div class="children"><div class="content">If it is dynamic one of the loops will also suffer from an off-by-one issue. You can&#x27;t add 1-based indices together like you can zero-based indices.<p>It&#x27;s also worth noting your solution exhibits similar off-by-one behaviour. The left hand side constants (integer values) do not match the right. It&#x27;s error prone.</div><br/><div id="42415245" class="c"><input type="checkbox" id="c-42415245" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42414718">parent</a><span>|</span><a href="#42414403">next</a><span>|</span><label class="collapse" for="c-42415245">[-]</label><label class="expand" for="c-42415245">[1 more]</label></div><br/><div class="children"><div class="content">sorry, where is the off by one?  the code offered is of course only a solution for the fixed-size groups</div><br/></div></div></div></div><div id="42414403" class="c"><input type="checkbox" id="c-42414403" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42414376">parent</a><span>|</span><a href="#42414718">prev</a><span>|</span><a href="#42415312">next</a><span>|</span><label class="collapse" for="c-42414403">[-]</label><label class="expand" for="c-42414403">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough, for some reason I thought it was i&#x2F;3 and not i%3. Still, I think the point stands.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42415312" class="c"><input type="checkbox" id="c-42415312" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413686">parent</a><span>|</span><a href="#42413753">prev</a><span>|</span><a href="#42414438">next</a><span>|</span><label class="collapse" for="c-42415312">[-]</label><label class="expand" for="c-42415312">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [0-based indexes] are a relic of C style arrays<p>I don&#x27;t think this is true. They exist in other disciplines (maths for instance) that have no relationship with C or other programming languages from the 1970s.<p>&gt; for 0 to count&#x2F;len&#x2F;num - 1<p>I will counter saying that such a for...to syntax is a relic of BASIC.<p>&gt; or even better range syntax that is start inclusive BUT end exclusive<p>I know that your &quot;better&quot; is sarcastic, but I actually find left-inclusive+right-exclusive ranges fantastic. They allow perfect partitioning, easy calculation of lenght, etc.<p>&gt; Arrays should start and end at whatever start index is required<p>I agree. An accommodating language would let you define both lower and upper bounds of an array, instead of its size.</div><br/></div></div><div id="42414438" class="c"><input type="checkbox" id="c-42414438" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413686">parent</a><span>|</span><a href="#42415312">prev</a><span>|</span><a href="#42413775">next</a><span>|</span><label class="collapse" for="c-42414438">[-]</label><label class="expand" for="c-42414438">[1 more]</label></div><br/><div class="children"><div class="content">I have a really hard time understanding why people like 1-based indexes! 0 is the smallest unsigned integer in every programming language I know of that supports the concept of unsigned integer. Why shouldn’t an array at the smallest possible index correspond to the beginning of the array?<p>It’s also very natural to think of arr[i] as “i steps past the beginning of arr”. With one-based indexing arr[i] has no natural interpretation that I know of. It’s “i-1 (for some reason) steps past the beginning of arr”. The only reason I can think of to prefer that extra -1 in your formula is just because human languages (at least the ones I know of) work this way — the 42nd element of a sequence, in normal colloquial English, means the one 41 steps past the beginning. But I’m not sure if there is any logical justification for that.<p>I also, despite being American, find the convention used in many countries of numbering building floors starting with zero to be more logical. I’m on the third floor, how many stories up did I travel to get here? Three.</div><br/></div></div><div id="42413775" class="c"><input type="checkbox" id="c-42413775" checked=""/><div class="controls bullet"><span class="by">coder543</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413686">parent</a><span>|</span><a href="#42414438">prev</a><span>|</span><a href="#42414889">next</a><span>|</span><label class="collapse" for="c-42413775">[-]</label><label class="expand" for="c-42413775">[2 more]</label></div><br/><div class="children"><div class="content">Some countries consider the 1st floor to be the ground floor, others consider the 1st floor to be the floor above the ground floor, which the formerly mentioned countries consider the 2nd floor… I think 0&#x2F;1-based indexing is more subjective than simply being a “relic of C” or a “horrible kludge” :P</div><br/><div id="42413857" class="c"><input type="checkbox" id="c-42413857" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413775">parent</a><span>|</span><a href="#42414889">next</a><span>|</span><label class="collapse" for="c-42413857">[-]</label><label class="expand" for="c-42413857">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been in the US for over a decade and it still occasionally makes me double-take when a room numbered 1xx is on the ground floor</div><br/></div></div></div></div><div id="42414889" class="c"><input type="checkbox" id="c-42414889" checked=""/><div class="controls bullet"><span class="by">fallous</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413686">parent</a><span>|</span><a href="#42413775">prev</a><span>|</span><a href="#42413967">next</a><span>|</span><label class="collapse" for="c-42414889">[-]</label><label class="expand" for="c-42414889">[2 more]</label></div><br/><div class="children"><div class="content">There are 360 degrees in a circle, and the first entry is 0 degrees.  The first time element of a day is 0:00:00(and enough 0s to satisfy whatever resolution you require).  These were not established in the 1970s, and somehow pretty much everyone understands and works quite well with these systems.</div><br/><div id="42415213" class="c"><input type="checkbox" id="c-42415213" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42414889">parent</a><span>|</span><a href="#42413967">next</a><span>|</span><label class="collapse" for="c-42415213">[-]</label><label class="expand" for="c-42415213">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There are 360 degrees in a circle, and the first entry is 0 degrees.<p>To be pedantic, &quot;first&quot; is associated with 1. And a circle does not have a &quot;first&quot; entry, whatever you mean by entry. I think what you&#x27;re trying to say is that a circle is a continuous arc going from 0 to 360 degrees, but you should recognize that the &quot;starting point&quot; is arbitrary, any point will do, so there isn&#x27;t really a &quot;first&quot;, and that this is not the same as counting because counting is done with natural numbers, which are non-continuous. The problem of 0 VS 1 makes sense only in counting exactly because it&#x27;s subjective whether you prefer to count from 0 or from 1. Because zero is the absence of anything, I find it hard to start counting from 0 (when you do, your &quot;first&quot; item is actually your zeroth item, and the next item would be the &quot;first&quot;??!), to be honest, despite being completely familiar with doing so since I&#x27;ve used 0-index programming languages my whole life.</div><br/></div></div></div></div><div id="42413967" class="c"><input type="checkbox" id="c-42413967" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413686">parent</a><span>|</span><a href="#42414889">prev</a><span>|</span><a href="#42414108">next</a><span>|</span><label class="collapse" for="c-42413967">[-]</label><label class="expand" for="c-42413967">[3 more]</label></div><br/><div class="children"><div class="content">Here’s the ultimate authority on why computer languages should count from zero:<p>&lt;<a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;ewd08xx&#x2F;EWD831.PDF" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;ewd08xx&#x2F;EWD831.PDF</a>&gt;</div><br/><div id="42414387" class="c"><input type="checkbox" id="c-42414387" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413967">parent</a><span>|</span><a href="#42414252">next</a><span>|</span><label class="collapse" for="c-42414387">[-]</label><label class="expand" for="c-42414387">[1 more]</label></div><br/><div class="children"><div class="content">I find that argument to be written in a terse &quot;mathy&quot; style that makes it a bit hard to follow. So let me try to restate it in more concrete &quot;programmy&quot; terms.<p>To iterate over an array with &quot;len&quot; elements, it’s most elegant if “len” appears as a loop bound, rather than &quot;len+1&quot; or &quot;len-1&quot;. Thus, in 0-based languages we use half-open ranges, whereas in 1-based languages we use closed ranges:<p><pre><code>  &#x2F;&#x2F; real C
  for (int i = 0; i &lt; len; ++i)
      process(array[i]);


  &#x2F;&#x2F; C-like language with 1-based indexing
  for (int i = 1; i &lt;= len; ++i)
      process(array[i]);
</code></pre>
But the second is inelegant when len is zero, because 0 isn’t a valid index at all, so it’s weird for it to appear as a bound.</div><br/></div></div><div id="42414252" class="c"><input type="checkbox" id="c-42414252" checked=""/><div class="controls bullet"><span class="by">thefaux</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413967">parent</a><span>|</span><a href="#42414387">prev</a><span>|</span><a href="#42414108">next</a><span>|</span><label class="collapse" for="c-42414252">[-]</label><label class="expand" for="c-42414252">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I disagree with Dijkstra on this. And many other things.</div><br/></div></div></div></div><div id="42414108" class="c"><input type="checkbox" id="c-42414108" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413686">parent</a><span>|</span><a href="#42413967">prev</a><span>|</span><a href="#42413736">next</a><span>|</span><label class="collapse" for="c-42414108">[-]</label><label class="expand" for="c-42414108">[1 more]</label></div><br/><div class="children"><div class="content">Having done fairly extensive parsing work in Lua and Julia on the one hand (one-based), and Python, Javascript, and Zig on the other (zero-based), the zero-based semiopen standard makes intervals dramatically easier to calculate and work with.  It&#x27;s really the semiopen intervals which make this the case, but as the Word of Dijkstra makes clear, zero-basis comes along for the ride, to combine semiopen intervals with a one-basis is perverse.<p>Naturally it&#x27;s true that for collections and naïve indexing, 1-based is more natural. But those are rare places for bugs to occur, while interval calculations are a frequent place for them to occur.<p>Clearly I&#x27;m far from allergic to the other standard, but I come down on the side of the zero basis for that reason.</div><br/></div></div><div id="42413736" class="c"><input type="checkbox" id="c-42413736" checked=""/><div class="controls bullet"><span class="by">topato</span><span>|</span><a href="#42413614">root</a><span>|</span><a href="#42413686">parent</a><span>|</span><a href="#42414108">prev</a><span>|</span><a href="#42413612">next</a><span>|</span><label class="collapse" for="c-42413736">[-]</label><label class="expand" for="c-42413736">[1 more]</label></div><br/><div class="children"><div class="content">Slam!  Now this guy really knows how to hate on a zero based index!</div><br/></div></div></div></div></div></div><div id="42413612" class="c"><input type="checkbox" id="c-42413612" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#42413614">prev</a><span>|</span><a href="#42413994">next</a><span>|</span><label class="collapse" for="c-42413612">[-]</label><label class="expand" for="c-42413612">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nice when a project can find such a simple pronouncable name that is also meaningful.</div><br/></div></div><div id="42413994" class="c"><input type="checkbox" id="c-42413994" checked=""/><div class="controls bullet"><span class="by">HexDecOctBin</span><span>|</span><a href="#42413612">prev</a><span>|</span><a href="#42413646">next</a><span>|</span><label class="collapse" for="c-42413994">[-]</label><label class="expand" for="c-42413994">[2 more]</label></div><br/><div class="children"><div class="content">Is this purely a personal project, or is it supposed to be used by others? You have made so many languages in the Oberon family (great job keeping the traditions alive, by the way), it&#x27;s hard to know whether they are just a personal experimentation or you are expecting others to use them too.</div><br/><div id="42414080" class="c"><input type="checkbox" id="c-42414080" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#42413994">parent</a><span>|</span><a href="#42413646">next</a><span>|</span><label class="collapse" for="c-42414080">[-]</label><label class="expand" for="c-42414080">[1 more]</label></div><br/><div class="children"><div class="content">This is not actually a contradicion, and the audience will decide whether the language will be used more widely. It&#x27;s not my first priority, but there&#x27;s nothing against it either. What you call &quot;tradition&quot; applies to my experiments with the Oberon Systems and the backward compatibility with their source code (for practical reasons, otherwise I would not be able to compile them), but my interest is actually in the language adapted for today&#x27;s meaning of simplicity, which I call Oberon+ (or Luon, or Micron), and which would definitely have the potential for further adaptation if you look at what kinds of new languages are popular at the moment.</div><br/></div></div></div></div><div id="42413646" class="c"><input type="checkbox" id="c-42413646" checked=""/><div class="controls bullet"><span class="by">srhtftw</span><span>|</span><a href="#42413994">prev</a><span>|</span><a href="#42415340">next</a><span>|</span><label class="collapse" for="c-42413646">[-]</label><label class="expand" for="c-42413646">[5 more]</label></div><br/><div class="children"><div class="content">&gt; locals can no longer be used before declaration<p>There&#x27;s a lot I like about Lua but it so happens that a few days ago I spent longer than I&#x27;d like to admit debugging a trivial typo for Advent of Code day 5 that would have been caught by this.<p>Wondering if Luon will also prohibit or at least warn about storing nil in a table.</div><br/><div id="42413873" class="c"><input type="checkbox" id="c-42413873" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#42413646">parent</a><span>|</span><a href="#42415340">next</a><span>|</span><label class="collapse" for="c-42413873">[-]</label><label class="expand" for="c-42413873">[4 more]</label></div><br/><div class="children"><div class="content">Luon doesn&#x27;t directly support tables, but instead supports records, arrays and hashmaps (which internally use tables). Since it&#x27;s statically typed you can only store nil to a field or element if it is of a structured type.</div><br/><div id="42414043" class="c"><input type="checkbox" id="c-42414043" checked=""/><div class="controls bullet"><span class="by">akkartik</span><span>|</span><a href="#42413646">root</a><span>|</span><a href="#42413873">parent</a><span>|</span><a href="#42415340">next</a><span>|</span><label class="collapse" for="c-42414043">[-]</label><label class="expand" for="c-42414043">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s a structured type? Something that has fields or elements?</div><br/><div id="42414085" class="c"><input type="checkbox" id="c-42414085" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#42413646">root</a><span>|</span><a href="#42414043">parent</a><span>|</span><a href="#42415340">next</a><span>|</span><label class="collapse" for="c-42414085">[-]</label><label class="expand" for="c-42414085">[2 more]</label></div><br/><div class="children"><div class="content">Records, arrays and hashmaps are structured types; in contrast to original Oberon, Luon has no pointer type, but reference semantics instead.</div><br/><div id="42415268" class="c"><input type="checkbox" id="c-42415268" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42413646">root</a><span>|</span><a href="#42414085">parent</a><span>|</span><a href="#42415340">next</a><span>|</span><label class="collapse" for="c-42415268">[-]</label><label class="expand" for="c-42415268">[1 more]</label></div><br/><div class="children"><div class="content">So Luon has reference types and value types, and reference types are always nullable?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42415340" class="c"><input type="checkbox" id="c-42415340" checked=""/><div class="controls bullet"><span class="by">1attice</span><span>|</span><a href="#42413646">prev</a><span>|</span><a href="#42415193">next</a><span>|</span><label class="collapse" for="c-42415340">[-]</label><label class="expand" for="c-42415340">[1 more]</label></div><br/><div class="children"><div class="content">I confess I was worried, until I read the name explanation, that it was named after Lululemon&#x27;s marketing term for its preferred elastane&#x2F;cotton blend</div><br/></div></div><div id="42415193" class="c"><input type="checkbox" id="c-42415193" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#42415340">prev</a><span>|</span><label class="collapse" for="c-42415193">[-]</label><label class="expand" for="c-42415193">[1 more]</label></div><br/><div class="children"><div class="content">Why not using brackets to replace begin and end ?</div><br/></div></div></div></div></div></div></div></body></html>