<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717837263418" as="style"/><link rel="stylesheet" href="styles.css?v=1717837263418"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.EmbeddedRelated.com/showarticle/152.php">Chebyshev approximation and how it can help (2012)</a> <span class="domain">(<a href="https://www.embeddedrelated.com">www.embeddedrelated.com</a>)</span></div><div class="subtext"><span>y04nn</span> | <span>13 comments</span></div><br/><div><div id="40615095" class="c"><input type="checkbox" id="c-40615095" checked=""/><div class="controls bullet"><span class="by">programjames</span><span>|</span><a href="#40615252">next</a><span>|</span><label class="collapse" for="c-40615095">[-]</label><label class="expand" for="c-40615095">[2 more]</label></div><br/><div class="children"><div class="content">Some other useful things about Chebyshev approximations:<p>1. You can use a Fourier transform to get the coefficients in O(n log n) time.<p>2. So, multiplying two approximations only takes O(n log n) time.<p>3. Also, adding, integrating, or taking the derivative only take O(n) time.<p>This is why chebfun&#x2F;chebpy can run so fast while magically finding roots&#x2F;derivatives&#x2F;etc. A couple other interesting facts:<p>1. Remember the double-angle formula? There&#x27;s a more general recursion for the Chebyshev polynomials:<p>\[ T_n(x) = 2x T_{n-1}(x) - T_{n-2}. \]<p>So, e.g.<p>\[ T_2(cos(theta)) = cos(2*theta) = 2cos(theta)^2 - 1 = 2cos(theta)T_1(cos(theta)) 
- T_0(cos(theta)) \]<p>2. Computers actually use this recursion to calculate sines and cosines! So, it&#x27;s a little inefficient to code your Chebyshev polynomials using `math.sin`.<p>3. Using generating functions, you can get a closed form for T_n(x) that only takes O(log n) time to calculate. (Note: assuming you count multiplications as constant. However, you actually need O(log n) bits to accurately represent x, so it&#x27;s more accurately O((log n)^2 log log n).)</div><br/><div id="40615844" class="c"><input type="checkbox" id="c-40615844" checked=""/><div class="controls bullet"><span class="by">alexcnwy</span><span>|</span><a href="#40615095">parent</a><span>|</span><a href="#40615252">next</a><span>|</span><label class="collapse" for="c-40615844">[-]</label><label class="expand" for="c-40615844">[1 more]</label></div><br/><div class="children"><div class="content">I’m gonna give this to my gpt system prompt as an example of how I want everything explained :)</div><br/></div></div></div></div><div id="40615252" class="c"><input type="checkbox" id="c-40615252" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40615095">prev</a><span>|</span><a href="#40614828">next</a><span>|</span><label class="collapse" for="c-40615252">[-]</label><label class="expand" for="c-40615252">[1 more]</label></div><br/><div class="children"><div class="content">chebyshev approximations are fucking awesome, but this article gives too short shrift to table lookup; it does go a bit beyond nearest-neighbor interpolation to linear interpolation, and correctly points out that this gives you error that is quadratic in the distance from the x-coordinate of the nearest table entry (and therefore worst-case error quadratic in your point spacing), and that this gives you half the error of the fifth-order chebyshev approximation.  it says that this is a &#x27;rare case&#x27;, but in fact you will always get a lower error from table lookup if you use enough points.  it&#x27;s just that with only linear interpolation, the number of points rapidly becomes impractical<p>as i understand it, other commonly-used strategies include spline interpolation (using second-, third-, or even fourth-order interpolation, requiring respectively three, four, and five multiplications, which can be done concurrently) and, in suitable cases like this example, newton iteration from an initial table-lookup guess<p>unlike the piecewise-taylor approach outlined early in the article, spline interpolation only requires storing a tiny amount more data than simple nearest-neighbor table lookup (potentially three more points for fourth-order interpolation, so a 256-entry table becomes 259 entries)<p>on a different topic, i think it&#x27;s easy to find embedded dsp applications where the easiest solution uses fourier transforms, which usually do require high-precision floating point.  machine vision, radio communication, musical applications, etc.<p>incidentally, if you find yourself in a situation where you actually need the taylor expansion of √(1+<i>x</i>) or √(½+<i>x</i>) or something, and you don&#x27;t want to do a bunch of pencil-and-paper algebra (or don&#x27;t trust yourself), pari&#x2F;gp has your back:<p><pre><code>    ? sqrt(1+x) + O(x^5)
    %5 = 1 + 1&#x2F;2*x - 1&#x2F;8*x^2 + 1&#x2F;16*x^3 - 5&#x2F;128*x^4 + O(x^5)
    ? sqrt(1+x) + O(x^7)
    %7 = 1 + 1&#x2F;2*x - 1&#x2F;8*x^2 + 1&#x2F;16*x^3 - 5&#x2F;128*x^4 + 7&#x2F;256*x^5 - 21&#x2F;1024*x^6 + O(x^7)
    ? sqrt(1&#x2F;2+x) + O(x^5)
    %6 = 0.70710678118654752440084436210484903928 + 0.70710678118654752440084436210484903928*x - 0.35355339059327376220042218105242451964*x^2 + 0.35355339059327376220042218105242451964*x^3 - 0.44194173824159220275052772631553064955*x^4 + O(x^5)</code></pre></div><br/></div></div><div id="40614828" class="c"><input type="checkbox" id="c-40614828" checked=""/><div class="controls bullet"><span class="by">alleycat5000</span><span>|</span><a href="#40615252">prev</a><span>|</span><a href="#40615084">next</a><span>|</span><label class="collapse" for="c-40614828">[-]</label><label class="expand" for="c-40614828">[1 more]</label></div><br/><div class="children"><div class="content">A great book on this subject is Approximation Theory and Approximation Practice:<p><a href="https:&#x2F;&#x2F;people.maths.ox.ac.uk&#x2F;trefethen&#x2F;ATAP&#x2F;" rel="nofollow">https:&#x2F;&#x2F;people.maths.ox.ac.uk&#x2F;trefethen&#x2F;ATAP&#x2F;</a><p>Also chebfun!<p><a href="https:&#x2F;&#x2F;www.chebfun.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.chebfun.org&#x2F;</a></div><br/></div></div><div id="40615084" class="c"><input type="checkbox" id="c-40615084" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40614828">prev</a><span>|</span><a href="#40615253">next</a><span>|</span><label class="collapse" for="c-40615084">[-]</label><label class="expand" for="c-40615084">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Chebyshev Approximation</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10115336">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10115336</a> - Aug 2015 (60 comments)</div><br/></div></div><div id="40615253" class="c"><input type="checkbox" id="c-40615253" checked=""/><div class="controls bullet"><span class="by">inamberclad</span><span>|</span><a href="#40615084">prev</a><span>|</span><a href="#40614855">next</a><span>|</span><label class="collapse" for="c-40615253">[-]</label><label class="expand" for="c-40615253">[3 more]</label></div><br/><div class="children"><div class="content">Once more, this is _exactly_ why Ada has arbitrary precision decimal arithmetic. One merely needs to specify<p>type Result is range -100 .. 100 delta 0.0001;<p>and the compiler will figure out how to give you fast math with only the accuracy and resolution that you need!</div><br/><div id="40615491" class="c"><input type="checkbox" id="c-40615491" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#40615253">parent</a><span>|</span><a href="#40614855">next</a><span>|</span><label class="collapse" for="c-40615491">[-]</label><label class="expand" for="c-40615491">[2 more]</label></div><br/><div class="children"><div class="content">How does that feature work without a solution to the tablemaker&#x27;s dilemma? Does the compiler just give up and give you arbitrary precision every time you use transcendentals or does it give up and use lower precision if the estimate exceeds some arbitrary bound?</div><br/><div id="40616102" class="c"><input type="checkbox" id="c-40616102" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40615253">root</a><span>|</span><a href="#40615491">parent</a><span>|</span><a href="#40614855">next</a><span>|</span><label class="collapse" for="c-40616102">[-]</label><label class="expand" for="c-40616102">[1 more]</label></div><br/><div class="children"><div class="content">Looking at the spec [0], it only demands 1 ULP of precision for the elementary operations, and 2, 4, or 8 ULPs for special functions. So there&#x27;s no magic 1&#x2F;2-ULP guarantee.<p>[0] <a href="http:&#x2F;&#x2F;ada-auth.org&#x2F;standards&#x2F;22rm&#x2F;html&#x2F;RM-G-2-3.html" rel="nofollow">http:&#x2F;&#x2F;ada-auth.org&#x2F;standards&#x2F;22rm&#x2F;html&#x2F;RM-G-2-3.html</a></div><br/></div></div></div></div></div></div><div id="40614855" class="c"><input type="checkbox" id="c-40614855" checked=""/><div class="controls bullet"><span class="by">archermarks</span><span>|</span><a href="#40615253">prev</a><span>|</span><a href="#40615396">next</a><span>|</span><label class="collapse" for="c-40614855">[-]</label><label class="expand" for="c-40614855">[1 more]</label></div><br/><div class="children"><div class="content">Nice article, thanks for sharing!</div><br/></div></div><div id="40615396" class="c"><input type="checkbox" id="c-40615396" checked=""/><div class="controls bullet"><span class="by">richrichie</span><span>|</span><a href="#40614855">prev</a><span>|</span><a href="#40615011">next</a><span>|</span><label class="collapse" for="c-40615396">[-]</label><label class="expand" for="c-40615396">[1 more]</label></div><br/><div class="children"><div class="content">As Boyd says in his book on Chebyshev Methods: when in doubt use Chebyshev polynomials.<p>I use Chebyshev polynomials extensively in finance and have tried problems like MNIST with Chebyshev and they get close to CNNs in accuracy.<p>ApproxFun Julia package pretty cool for Chebyshev work:<p><a href="https:&#x2F;&#x2F;juliaapproximation.github.io&#x2F;ApproxFun.jl&#x2F;latest&#x2F;" rel="nofollow">https:&#x2F;&#x2F;juliaapproximation.github.io&#x2F;ApproxFun.jl&#x2F;latest&#x2F;</a></div><br/></div></div><div id="40615011" class="c"><input type="checkbox" id="c-40615011" checked=""/><div class="controls bullet"><span class="by">bryan0</span><span>|</span><a href="#40615396">prev</a><span>|</span><label class="collapse" for="c-40615011">[-]</label><label class="expand" for="c-40615011">[2 more]</label></div><br/><div class="children"><div class="content">2012</div><br/><div id="40615081" class="c"><input type="checkbox" id="c-40615081" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40615011">parent</a><span>|</span><label class="collapse" for="c-40615081">[-]</label><label class="expand" for="c-40615081">[1 more]</label></div><br/><div class="children"><div class="content">Added. Thanks!</div><br/></div></div></div></div></div></div></div></div></div></body></html>