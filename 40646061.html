<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718182855991" as="style"/><link rel="stylesheet" href="styles.css?v=1718182855991"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dgroshev.com/blog/rp2040/">I like the RP2040</a>Â <span class="domain">(<a href="https://dgroshev.com">dgroshev.com</a>)</span></div><div class="subtext"><span>dgroshev</span> | <span>294 comments</span></div><br/><div><div id="40646627" class="c"><input type="checkbox" id="c-40646627" checked=""/><div class="controls bullet"><span class="by">MegaDeKay</span><span>|</span><a href="#40647342">next</a><span>|</span><label class="collapse" for="c-40646627">[-]</label><label class="expand" for="c-40646627">[39 more]</label></div><br/><div class="children"><div class="content">The PIO&#x27;s really are the star of the RP2040 show, giving it a capability that competing chips like the ESP32 can&#x27;t match. They are appearing all over the place in the console hacking space for this reason. Lower power consumption in steep modes for battery-backed applications would be a welcome addition in any V2 version though.</div><br/><div id="40646675" class="c"><input type="checkbox" id="c-40646675" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40646627">parent</a><span>|</span><a href="#40651644">next</a><span>|</span><label class="collapse" for="c-40646675">[-]</label><label class="expand" for="c-40646675">[13 more]</label></div><br/><div class="children"><div class="content">Things like battery life will probably improve with experience, I was talking to a silicon guy about the RP2040 and they said it&#x27;s pretty characteristic of a first generation design. The digital logic that can be validated on an FPGA is fine for the most part, but the analog elements are much more difficult to fine tune, hence the poor power consumption, poor ADCs, and lack of internal DACs or opamps in the RP2040, and why the Pico Ws radio is a separate off-the-shelf part rather than fully integrated like it is on the ESP32.</div><br/><div id="40648282" class="c"><input type="checkbox" id="c-40648282" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40646675">parent</a><span>|</span><a href="#40647943">next</a><span>|</span><label class="collapse" for="c-40648282">[-]</label><label class="expand" for="c-40648282">[3 more]</label></div><br/><div class="children"><div class="content">Though it&#x27;s a continuing puzzle to me why ESPs have worse ADCs than the rp2040, given their relative maturity. (Neither is particularly good, mind you, but I&#x27;m generally ok with the rp for my toy applications.)</div><br/><div id="40652890" class="c"><input type="checkbox" id="c-40652890" checked=""/><div class="controls bullet"><span class="by">datameta</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40648282">parent</a><span>|</span><a href="#40647943">next</a><span>|</span><label class="collapse" for="c-40652890">[-]</label><label class="expand" for="c-40652890">[2 more]</label></div><br/><div class="children"><div class="content">Speaking of relative maturity, I just had a heap corruption debug for a few days. Imagine my surprise when fixing the issue involved switching from the default ESP32 BLE library to the  NimBLE library...</div><br/><div id="40654985" class="c"><input type="checkbox" id="c-40654985" checked=""/><div class="controls bullet"><span class="by">Ballas</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40652890">parent</a><span>|</span><a href="#40647943">next</a><span>|</span><label class="collapse" for="c-40654985">[-]</label><label class="expand" for="c-40654985">[1 more]</label></div><br/><div class="children"><div class="content">I have been having an intermittent issue as well, but only when using BLE, so I was suspecting the Espressive drivers. I was wondering if it would be worth switching over to NimBLE, so thanks for that tip, I&#x27;ll try it out and see if the problem goes away. Luckily, it&#x27;s a very low priority.</div><br/></div></div></div></div></div></div><div id="40647943" class="c"><input type="checkbox" id="c-40647943" checked=""/><div class="controls bullet"><span class="by">nimish</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40646675">parent</a><span>|</span><a href="#40648282">prev</a><span>|</span><a href="#40654874">next</a><span>|</span><label class="collapse" for="c-40647943">[-]</label><label class="expand" for="c-40647943">[6 more]</label></div><br/><div class="children"><div class="content">Analog is large area and expensive in general so sticking to good digital and passable analog is a very good strategy to keep costs down.</div><br/><div id="40648534" class="c"><input type="checkbox" id="c-40648534" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40647943">parent</a><span>|</span><a href="#40654874">next</a><span>|</span><label class="collapse" for="c-40648534">[-]</label><label class="expand" for="c-40648534">[5 more]</label></div><br/><div class="children"><div class="content">Modern Microcontrollers focus on analog because modern microprocessors start at like $5, maybe even cheaper.<p>If you need digital girth, don&#x27;t mess with lol 264kB RP2040 systems. Just buy $3 of DDR3L RAM (aka: 128MB) and run Linux for goodness sake.<p>---------<p>Even ESP32 is a glorified Bluetooth&#x2F;Wifi chip first and everything secondary. You have to have a niche at this price point to be competitive.<p>RP2040&#x27;s niche is the 264kB of SRAM, but not much else. It needs a bunch of external parts before it can become a reasonable solution as well, so its not really cost optimized IMO.</div><br/><div id="40650447" class="c"><input type="checkbox" id="c-40650447" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40648534">parent</a><span>|</span><a href="#40654874">next</a><span>|</span><label class="collapse" for="c-40650447">[-]</label><label class="expand" for="c-40650447">[4 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t run Linux on DRAM. You need a CPU.</div><br/><div id="40650736" class="c"><input type="checkbox" id="c-40650736" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40650447">parent</a><span>|</span><a href="#40654874">next</a><span>|</span><label class="collapse" for="c-40650736">[-]</label><label class="expand" for="c-40650736">[3 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t run anything on an RP2040. There&#x27;s no Flash or code space.<p>RP2040 sits at an awkward placement. It requires external parts, but low end SPI parts and not the nicer proper RAM like DDR3L or the like.<p>------<p>My point is that if you have a design that fundamentally requires external parts like the RP2040, the accurate comparison is against MPUs. Chips that are specifically designed to work with powerful and cost effective external components.<p>--------<p>Analog-focused designs like ATMega, ESP32 or STM32 comfortably do things that the real computers or MPUs cannot do. Like read a voltage, work with OpAMPs or other analog stuff that cannot fit on a proper Linux computer chip like SAM9x60D1G. And to do so without any external parts, so that you have the simplest design possible.</div><br/><div id="40655805" class="c"><input type="checkbox" id="c-40655805" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40650736">parent</a><span>|</span><a href="#40652858">next</a><span>|</span><label class="collapse" for="c-40655805">[-]</label><label class="expand" for="c-40655805">[1 more]</label></div><br/><div class="children"><div class="content">ESP32 chips also need external SPI Flash, and many STM32 have little flash and QuadSPI with execute from external flash capabilities, so I don&#x27;t see this as a specificity of RP2040.</div><br/></div></div><div id="40652858" class="c"><input type="checkbox" id="c-40652858" checked=""/><div class="controls bullet"><span class="by">floxy</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40650736">parent</a><span>|</span><a href="#40655805">prev</a><span>|</span><a href="#40654874">next</a><span>|</span><label class="collapse" for="c-40652858">[-]</label><label class="expand" for="c-40652858">[1 more]</label></div><br/><div class="children"><div class="content">Glad you mentioned Microchip.  The PIC32MK family is MIPS architecture microcontroller, with hardware floating point unit, running at 120 MHz, with a whole slew of peripherals, like 10 MHz unity-gain op-amp, D&#x2F;A converter, lots of flexibility in mapping peripherals to pins, fast A&#x2F;D, DMA, etc..<p><a href="https:&#x2F;&#x2F;www.microchip.com&#x2F;en-us&#x2F;products&#x2F;microcontrollers-and-microprocessors&#x2F;32-bit-mcus&#x2F;pic32-32-bit-mcus&#x2F;pic32mk" rel="nofollow">https:&#x2F;&#x2F;www.microchip.com&#x2F;en-us&#x2F;products&#x2F;microcontrollers-an...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40654874" class="c"><input type="checkbox" id="c-40654874" checked=""/><div class="controls bullet"><span class="by">konstantinua00</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40646675">parent</a><span>|</span><a href="#40647943">prev</a><span>|</span><a href="#40651148">next</a><span>|</span><label class="collapse" for="c-40654874">[-]</label><label class="expand" for="c-40654874">[2 more]</label></div><br/><div class="children"><div class="content">he said?</div><br/><div id="40655589" class="c"><input type="checkbox" id="c-40655589" checked=""/><div class="controls bullet"><span class="by">triyambakam</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40654874">parent</a><span>|</span><a href="#40651148">next</a><span>|</span><label class="collapse" for="c-40655589">[-]</label><label class="expand" for="c-40655589">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking about this. I think there is a trend in English to use they even when the gender is known to indicate a kind of distance from that person. E.g. my guess about the parent poster is that they (he or she in this case, a different usage) may not be very close to the &quot;silicon guy&quot;</div><br/></div></div></div></div></div></div><div id="40651644" class="c"><input type="checkbox" id="c-40651644" checked=""/><div class="controls bullet"><span class="by">boznz</span><span>|</span><a href="#40646627">parent</a><span>|</span><a href="#40646675">prev</a><span>|</span><a href="#40648956">next</a><span>|</span><label class="collapse" for="c-40651644">[-]</label><label class="expand" for="c-40651644">[2 more]</label></div><br/><div class="children"><div class="content">Availability is the star of the show for me. One IC, long product lifetime, always in stock, after the shitshow that was 2021&#x2F;2022 I&#x27;m not going to bother trying to shave a few cents to compromise this again.</div><br/><div id="40655427" class="c"><input type="checkbox" id="c-40655427" checked=""/><div class="controls bullet"><span class="by">jsbdudh</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40651644">parent</a><span>|</span><a href="#40648956">next</a><span>|</span><label class="collapse" for="c-40655427">[-]</label><label class="expand" for="c-40655427">[1 more]</label></div><br/><div class="children"><div class="content">The RP2040 was only available during the last component shortage, since it was a newly released design, not yet implemented in many products.<p>The IC will be unobtainable in the next shortage, too.<p>I mean, don&#x27;t you remember the shortage before where even capacitors were only hardly available?</div><br/></div></div></div></div><div id="40648956" class="c"><input type="checkbox" id="c-40648956" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#40646627">parent</a><span>|</span><a href="#40651644">prev</a><span>|</span><a href="#40646811">next</a><span>|</span><label class="collapse" for="c-40648956">[-]</label><label class="expand" for="c-40648956">[1 more]</label></div><br/><div class="children"><div class="content">The most annoying part about the PIO is that there are only two of them (though with 4 sub-units each), they only have space for 32 instructions, and they don&#x27;t have an external clock input.<p>They are <i>great</i> for implementing very basic peripherals, but more than once I&#x27;ve started to implement something more complex just to realize it would be unacceptably slow and run out of space. If they were to beef them up just a little, they could easily replace the more trivial FPGA applications.</div><br/></div></div><div id="40646811" class="c"><input type="checkbox" id="c-40646811" checked=""/><div class="controls bullet"><span class="by">dvdbloc</span><span>|</span><a href="#40646627">parent</a><span>|</span><a href="#40648956">prev</a><span>|</span><a href="#40652058">next</a><span>|</span><label class="collapse" for="c-40646811">[-]</label><label class="expand" for="c-40646811">[6 more]</label></div><br/><div class="children"><div class="content">Where can I learn more about how they are used in console hacking? This sounds very interesting</div><br/><div id="40647912" class="c"><input type="checkbox" id="c-40647912" checked=""/><div class="controls bullet"><span class="by">MegaDeKay</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40646811">parent</a><span>|</span><a href="#40650912">next</a><span>|</span><label class="collapse" for="c-40647912">[-]</label><label class="expand" for="c-40647912">[3 more]</label></div><br/><div class="children"><div class="content">Here you go. There might be more but these are all I can think of off the top of my head.<p>Nintendo Switch modchip - PicoFly: <a href="https:&#x2F;&#x2F;github.com&#x2F;rehius&#x2F;usk">https:&#x2F;&#x2F;github.com&#x2F;rehius&#x2F;usk</a>. That is the OG source of the firmware behind the already mentioned <a href="https:&#x2F;&#x2F;github.com&#x2F;Ansem-SoD&#x2F;Picofly">https:&#x2F;&#x2F;github.com&#x2F;Ansem-SoD&#x2F;Picofly</a><p>OG XBox Modchip - Modxo: <a href="https:&#x2F;&#x2F;github.com&#x2F;shalxmva&#x2F;modxo">https:&#x2F;&#x2F;github.com&#x2F;shalxmva&#x2F;modxo</a> (see initial impressions from ModzvilleUSA at <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=uUsov3i6jL0" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=uUsov3i6jL0</a>)<p>XBox360 NAND reader &#x2F; writer - Picoflasher: <a href="https:&#x2F;&#x2F;github.com&#x2F;X360Tools&#x2F;PicoFlasher">https:&#x2F;&#x2F;github.com&#x2F;X360Tools&#x2F;PicoFlasher</a> (used in the RGH3 hack for some versions of the console as described at <a href="https:&#x2F;&#x2F;consolemods.org&#x2F;wiki&#x2F;Xbox_360:RGH&#x2F;RGH3" rel="nofollow">https:&#x2F;&#x2F;consolemods.org&#x2F;wiki&#x2F;Xbox_360:RGH&#x2F;RGH3</a>)<p>Gamecube Modchip - Picoboot: <a href="https:&#x2F;&#x2F;github.com&#x2F;webhdx&#x2F;PicoBoot">https:&#x2F;&#x2F;github.com&#x2F;webhdx&#x2F;PicoBoot</a><p>Gamecube Optical Drive Emulator - Flippydrive: <a href="https:&#x2F;&#x2F;github.com&#x2F;OffBroadway&#x2F;flippydrive">https:&#x2F;&#x2F;github.com&#x2F;OffBroadway&#x2F;flippydrive</a> as described at <a href="https:&#x2F;&#x2F;teamoffbroadway.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;teamoffbroadway.com&#x2F;</a></div><br/><div id="40648496" class="c"><input type="checkbox" id="c-40648496" checked=""/><div class="controls bullet"><span class="by">mewse-hn</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40647912">parent</a><span>|</span><a href="#40650912">next</a><span>|</span><label class="collapse" for="c-40648496">[-]</label><label class="expand" for="c-40648496">[2 more]</label></div><br/><div class="children"><div class="content">The flippydrive is such a nice, clean install on a gamecube that it leaves me wondering if the rp2040 could make better ODE&#x27;s for every other console (psx, saturn in particular)</div><br/><div id="40654065" class="c"><input type="checkbox" id="c-40654065" checked=""/><div class="controls bullet"><span class="by">MegaDeKay</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40648496">parent</a><span>|</span><a href="#40650912">next</a><span>|</span><label class="collapse" for="c-40654065">[-]</label><label class="expand" for="c-40654065">[1 more]</label></div><br/><div class="children"><div class="content">Interconnecting the flippydrive by squeezing a flex PCB between the optical drive and its motherboard connector was a stroke of genius.</div><br/></div></div></div></div></div></div><div id="40650912" class="c"><input type="checkbox" id="c-40650912" checked=""/><div class="controls bullet"><span class="by">morsch</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40646811">parent</a><span>|</span><a href="#40647912">prev</a><span>|</span><a href="#40647113">next</a><span>|</span><label class="collapse" for="c-40650912">[-]</label><label class="expand" for="c-40650912">[1 more]</label></div><br/><div class="children"><div class="content">Related: retro PC stuff.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;polpo&#x2F;picogus">https:&#x2F;&#x2F;github.com&#x2F;polpo&#x2F;picogus</a><p>Emulates all kinds of sound cards, including the Gravis Ultrasound.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;FreddyVRetro&#x2F;ISA-PicoMEM">https:&#x2F;&#x2F;github.com&#x2F;FreddyVRetro&#x2F;ISA-PicoMEM</a><p>Emulates a memory extension, but also so much more stuff.</div><br/></div></div><div id="40647113" class="c"><input type="checkbox" id="c-40647113" checked=""/><div class="controls bullet"><span class="by">nereye</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40646811">parent</a><span>|</span><a href="#40650912">prev</a><span>|</span><a href="#40652058">next</a><span>|</span><label class="collapse" for="c-40647113">[-]</label><label class="expand" for="c-40647113">[1 more]</label></div><br/><div class="children"><div class="content">One use case is related to the Nintendo Switch, as mentioned in another post.<p>E.g. see <a href="https:&#x2F;&#x2F;github.com&#x2F;Ansem-SoD&#x2F;Picofly">https:&#x2F;&#x2F;github.com&#x2F;Ansem-SoD&#x2F;Picofly</a>.</div><br/></div></div></div></div><div id="40652058" class="c"><input type="checkbox" id="c-40652058" checked=""/><div class="controls bullet"><span class="by">nkozyra</span><span>|</span><a href="#40646627">parent</a><span>|</span><a href="#40646811">prev</a><span>|</span><a href="#40647135">next</a><span>|</span><label class="collapse" for="c-40652058">[-]</label><label class="expand" for="c-40652058">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t cycle sleeps help on the esp32? I typically run on power but I know a lot of people get all day with wifi on reasonable LiPo</div><br/></div></div><div id="40647135" class="c"><input type="checkbox" id="c-40647135" checked=""/><div class="controls bullet"><span class="by">JAlexoid</span><span>|</span><a href="#40646627">parent</a><span>|</span><a href="#40652058">prev</a><span>|</span><a href="#40647689">next</a><span>|</span><label class="collapse" for="c-40647135">[-]</label><label class="expand" for="c-40647135">[9 more]</label></div><br/><div class="children"><div class="content">Comparing ESP32 to RP2040 is like comparing oranges to apples.<p>If you need a lot of IO - you&#x27;re probably not looking at ESP32. It&#x27;s just cheap and has WiFi builtin.<p>There are many options for other MCUs, that compare favorably to with RP2040... though majority aren&#x27;t for the hobbyist market.</div><br/><div id="40651216" class="c"><input type="checkbox" id="c-40651216" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40647135">parent</a><span>|</span><a href="#40647689">next</a><span>|</span><label class="collapse" for="c-40651216">[-]</label><label class="expand" for="c-40651216">[8 more]</label></div><br/><div class="children"><div class="content">&gt; There are many options for other MCUs, that compare favorably to with RP2040<p>That&#x27;s pretty interesting, could you list some?</div><br/><div id="40655880" class="c"><input type="checkbox" id="c-40655880" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40651216">parent</a><span>|</span><a href="#40651371">next</a><span>|</span><label class="collapse" for="c-40655880">[-]</label><label class="expand" for="c-40655880">[1 more]</label></div><br/><div class="children"><div class="content">Not sure about favorably, but if it&#x27;s PIO you&#x27;re after, there is TI&#x27;s Sitara family with their PRU.  afaics, more functionality for a higher price.</div><br/></div></div><div id="40651371" class="c"><input type="checkbox" id="c-40651371" checked=""/><div class="controls bullet"><span class="by">jayyhu</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40651216">parent</a><span>|</span><a href="#40655880">prev</a><span>|</span><a href="#40647689">next</a><span>|</span><label class="collapse" for="c-40651371">[-]</label><label class="expand" for="c-40651371">[6 more]</label></div><br/><div class="children"><div class="content">The STM32 F0&#x2F;G0&#x2F;C0 lines come to mind. More I&#x2F;O, more peripherals and built-in flash.<p>For hobbyist levels, buying 1-10 pcs they are comparable in price to an RP2040 + SPI flash. However at volume pricing, the STM32 MCU&#x27;s can be cheaper than just the RP2040 itself. I do think Raspberry Pi needs to figure out volume pricing if they want to be competitive for anything that&#x27;s not just hobbyists.</div><br/><div id="40652026" class="c"><input type="checkbox" id="c-40652026" checked=""/><div class="controls bullet"><span class="by">Johanx64</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40651371">parent</a><span>|</span><a href="#40647689">next</a><span>|</span><label class="collapse" for="c-40652026">[-]</label><label class="expand" for="c-40652026">[5 more]</label></div><br/><div class="children"><div class="content">rp2040 is 64cents @ 1000qty, thats a good price, compatible winbond 16mbit flash is 12cents.<p>You need to go up way above a dollar to get comparable specs, given the unique nature of rp2040, two cores with fairly high clock, 264kb sram, pio.<p>The only thing i dont like about rp2040 is the package, not hobbyist home soldering friendly for custom board designs.</div><br/><div id="40653227" class="c"><input type="checkbox" id="c-40653227" checked=""/><div class="controls bullet"><span class="by">SeanCline</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40652026">parent</a><span>|</span><a href="#40653733">next</a><span>|</span><label class="collapse" for="c-40653227">[-]</label><label class="expand" for="c-40653227">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; not hobbyist home soldering friendly for custom board designs
</code></pre>
I assume by home soldering friendly, you mean too small. I&#x27;ll make a case for why this isn&#x27;t a bad thing...<p>If it&#x27;s difficult to solder a QFN package, then it will be equally difficult to solder the passives and flash it requires. Its price, availability, and good documentation make up for the package by creating an ecosystem of cheap boards hobbyists can use instead.<p>For example, I designed a keyboard around the Solder Party RP2040 Stamp (<a href="https:&#x2F;&#x2F;www.solder.party&#x2F;docs&#x2F;rp2040-stamp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.solder.party&#x2F;docs&#x2F;rp2040-stamp&#x2F;</a>). It integrated all the difficult components in a package that fit between the arrow keys and delete key.</div><br/><div id="40655347" class="c"><input type="checkbox" id="c-40655347" checked=""/><div class="controls bullet"><span class="by">Johanx64</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40653227">parent</a><span>|</span><a href="#40654057">next</a><span>|</span><label class="collapse" for="c-40655347">[-]</label><label class="expand" for="c-40655347">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If it&#x27;s difficult to solder a QFN package, then it will be equally difficult to solder the passives and flash it requires.<p>Compatible winbond flash is available in sop-8 package which are very easy to solder.
1206 and 0805 are not hard to solder. Nobody is forcing you to use 0201 and 0402.<p>Sop, tssop or even LQFP-64 are still quite fine for hobbyists. Those can be soldered &amp; most importantly examined quite easily.<p>Yes, there are various RP2040 boards that can be bought for as low as 2-3dollars a piece which makes the QFN package less of an issue.<p>If I need to design my own board, I would almost certainly likely use something else unless I need PIO or some other inherent quality of rp2040.</div><br/></div></div></div></div><div id="40653733" class="c"><input type="checkbox" id="c-40653733" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40652026">parent</a><span>|</span><a href="#40653227">prev</a><span>|</span><a href="#40647689">next</a><span>|</span><label class="collapse" for="c-40653733">[-]</label><label class="expand" for="c-40653733">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The only thing i dont like about rp2040 is the package, not hobbyist home soldering friendly for custom board designs.<p>- Use home SMT reflow solutions like toaster ovens or hot sand in frying pans; or<p>- As the other reply suggested, use &#x27;breakout boards&#x27; to turn the RP2040 into a through hole part; or<p>- Use SMT assembly services, which are getting cheaper all the time<p>It&#x27;s not just a problem with the rp2040 - loads of modern parts have very fine pitches and&#x2F;or hidden pads, gotta find a way to work with them or stick to aging out, larger parts and miss out on things like PIO.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40647689" class="c"><input type="checkbox" id="c-40647689" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#40646627">parent</a><span>|</span><a href="#40647135">prev</a><span>|</span><a href="#40647342">next</a><span>|</span><label class="collapse" for="c-40647689">[-]</label><label class="expand" for="c-40647689">[6 more]</label></div><br/><div class="children"><div class="content">Ditto for robotics. 8 PIO units are enough to read and log four quadrature encoders at practically no interrupt cost, so it&#x27;s possible to build a perfectly performant closed loop controller in something as slow as Micropython.</div><br/><div id="40655529" class="c"><input type="checkbox" id="c-40655529" checked=""/><div class="controls bullet"><span class="by">05</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40647689">parent</a><span>|</span><a href="#40655728">next</a><span>|</span><label class="collapse" for="c-40655529">[-]</label><label class="expand" for="c-40655529">[2 more]</label></div><br/><div class="children"><div class="content">Many, <i>many</i> cheap MCUs have peripherals that can decode quadrature in hardware. E.g, PCNT on ESP32, timer modes on STM32 etc. Might as well use PIO to implement I2C or UART :)</div><br/><div id="40655986" class="c"><input type="checkbox" id="c-40655986" checked=""/><div class="controls bullet"><span class="by">fest</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40655529">parent</a><span>|</span><a href="#40655728">next</a><span>|</span><label class="collapse" for="c-40655986">[-]</label><label class="expand" for="c-40655986">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Might as well use PIO to implement I2C or UART :)<p>PIO actually came in handy for me when interfacing with an x-ray sensor which had 12 or 14 bits long UART data frame- not many micros have such a flexibility in their UART peripherals.</div><br/></div></div></div></div><div id="40655728" class="c"><input type="checkbox" id="c-40655728" checked=""/><div class="controls bullet"><span class="by">m-ee</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40647689">parent</a><span>|</span><a href="#40655529">prev</a><span>|</span><a href="#40651149">next</a><span>|</span><label class="collapse" for="c-40655728">[-]</label><label class="expand" for="c-40655728">[1 more]</label></div><br/><div class="children"><div class="content">Itâs also possible to build a perfectly performant closed loop controller with micropython on an STM32</div><br/></div></div><div id="40651149" class="c"><input type="checkbox" id="c-40651149" checked=""/><div class="controls bullet"><span class="by">Teknoman117</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40647689">parent</a><span>|</span><a href="#40655728">prev</a><span>|</span><a href="#40647342">next</a><span>|</span><label class="collapse" for="c-40651149">[-]</label><label class="expand" for="c-40651149">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t even need the 8 :), 4 quadrature inputs will fit on one PIO block.<p>Some lovely person got a quadrature decoder into 24 instructions, so you can potentially still do something useful on the same PIO block if you only need one or two quadrature encoders.</div><br/><div id="40652124" class="c"><input type="checkbox" id="c-40652124" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#40646627">root</a><span>|</span><a href="#40651149">parent</a><span>|</span><a href="#40647342">next</a><span>|</span><label class="collapse" for="c-40652124">[-]</label><label class="expand" for="c-40652124">[1 more]</label></div><br/><div class="children"><div class="content">I mean yeah one block is 8 units right? Two pins per encoder which both need a unit each.</div><br/></div></div></div></div></div></div></div></div><div id="40647342" class="c"><input type="checkbox" id="c-40647342" checked=""/><div class="controls bullet"><span class="by">smcameron</span><span>|</span><a href="#40646627">prev</a><span>|</span><a href="#40646716">next</a><span>|</span><label class="collapse" for="c-40647342">[-]</label><label class="expand" for="c-40647342">[3 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been using the RP2040 in the electronic badges[1] for the RVASec security conference[2] for the past several years, and it&#x27;s been very nice to write software for.  Here&#x27;s the github repo for this year&#x27;s badge (there&#x27;s a software-only badge simulator so you can kind of play around with it even without the hardware, although some of the multi-player things that rely on infrared badge-to-badge communication won&#x27;t be any fun): <a href="https:&#x2F;&#x2F;github.com&#x2F;HackRVA&#x2F;badge2024">https:&#x2F;&#x2F;github.com&#x2F;HackRVA&#x2F;badge2024</a><p>[1] Video of the 2023 badge: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KWZriUMNpLc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KWZriUMNpLc</a>
[2] <a href="https:&#x2F;&#x2F;rvasec.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rvasec.com&#x2F;</a></div><br/><div id="40651122" class="c"><input type="checkbox" id="c-40651122" checked=""/><div class="controls bullet"><span class="by">brcmthrowaway</span><span>|</span><a href="#40647342">parent</a><span>|</span><a href="#40646716">next</a><span>|</span><label class="collapse" for="c-40651122">[-]</label><label class="expand" for="c-40651122">[2 more]</label></div><br/><div class="children"><div class="content">Why custom and not use NXP stuff?</div><br/><div id="40654142" class="c"><input type="checkbox" id="c-40654142" checked=""/><div class="controls bullet"><span class="by">smcameron</span><span>|</span><a href="#40647342">root</a><span>|</span><a href="#40651122">parent</a><span>|</span><a href="#40646716">next</a><span>|</span><label class="collapse" for="c-40654142">[-]</label><label class="expand" for="c-40654142">[1 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s kind of a group project for the local hackerspace and it&#x27;s evolved over a bit more than a decade (didn&#x27;t always use rp2040, obviously).</div><br/></div></div></div></div></div></div><div id="40646716" class="c"><input type="checkbox" id="c-40646716" checked=""/><div class="controls bullet"><span class="by">axoltl</span><span>|</span><a href="#40647342">prev</a><span>|</span><a href="#40646783">next</a><span>|</span><label class="collapse" for="c-40646716">[-]</label><label class="expand" for="c-40646716">[3 more]</label></div><br/><div class="children"><div class="content">&quot;(This is the same microcontroller, just two bugfix revisions.)&quot;<p>It is exactly the same microcontroller! They&#x27;re just two different packaging options. One is a 7&quot; reel with 500 units the other is a 13&quot; reel with 3400 units. (See &quot;Ordering code&quot; in the datasheet (<a href="https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.pdf" rel="nofollow">https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.p...</a>))</div><br/><div id="40646900" class="c"><input type="checkbox" id="c-40646900" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40646716">parent</a><span>|</span><a href="#40646834">next</a><span>|</span><label class="collapse" for="c-40646900">[-]</label><label class="expand" for="c-40646900">[1 more]</label></div><br/><div class="children"><div class="content">That said they have done a few bugfix revisions, RP2040-B0 is the original, -B1 has some refinements to the ROM code, and -B2 has further ROM changes and also fixes some silicon bugs from the earlier versions. If you&#x27;re using the official SDK you probably don&#x27;t need to care too much about which version you have though, because the standard high level libraries detect the hardware revision at runtime and enable or disable workarounds as needed.</div><br/></div></div><div id="40646834" class="c"><input type="checkbox" id="c-40646834" checked=""/><div class="controls bullet"><span class="by">dgroshev</span><span>|</span><a href="#40646716">parent</a><span>|</span><a href="#40646900">prev</a><span>|</span><a href="#40646783">next</a><span>|</span><label class="collapse" for="c-40646834">[-]</label><label class="expand" for="c-40646834">[1 more]</label></div><br/><div class="children"><div class="content">Ooops, you&#x27;re right! Fixed &amp; attributed.</div><br/></div></div></div></div><div id="40646783" class="c"><input type="checkbox" id="c-40646783" checked=""/><div class="controls bullet"><span class="by">nickcw</span><span>|</span><a href="#40646716">prev</a><span>|</span><a href="#40648694">next</a><span>|</span><label class="collapse" for="c-40646783">[-]</label><label class="expand" for="c-40646783">[7 more]</label></div><br/><div class="children"><div class="content">If you are an electronics hobbyist but don&#x27;t want to make&#x2F;design your own surface mount boards (like me) there are lots of very accessible RP2040 boards at very low prices.<p>I&#x27;ve used it in the Raspbery Pi Pico ($5) which comes on a nice board with lots of IO. There is a W version for a bit more with WiFi.<p>If you don&#x27;t mind slightly less IO then you can order an RP-2040 Zero. I got 6 off AliExpress for about $12. These only have 23 IO pins but they have a reset button, USB-C and are tiny (1.5cm x 2.5cm).<p>The nice thing about all of these is that they use the standard Raspberry Pi dev tools, micropython, C++ just works with convenient USB loading of the firmware.</div><br/><div id="40647763" class="c"><input type="checkbox" id="c-40647763" checked=""/><div class="controls bullet"><span class="by">willis936</span><span>|</span><a href="#40646783">parent</a><span>|</span><a href="#40649016">next</a><span>|</span><label class="collapse" for="c-40647763">[-]</label><label class="expand" for="c-40647763">[1 more]</label></div><br/><div class="children"><div class="content">I like to shout out the pico ice.  Most of the $30 price tag is for the UP5K tied at the hip, but for embedded projects where you have some sub-microsecond activities it&#x27;s a (relatively) inexpensive option with open source tooling.</div><br/></div></div><div id="40649016" class="c"><input type="checkbox" id="c-40649016" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#40646783">parent</a><span>|</span><a href="#40647763">prev</a><span>|</span><a href="#40648075">next</a><span>|</span><label class="collapse" for="c-40649016">[-]</label><label class="expand" for="c-40649016">[3 more]</label></div><br/><div class="children"><div class="content">I also highly recommend shopping around for alternative RP2040-based dev boards. The official Pi Pico is surprisingly bad, and just about every alternative out there is better in one way or another.<p>I mean, come on: no reset, huge form factor, only 2Mbit flash, micro USB - in 2024? Just about the only pro it has is that it is widely available.</div><br/><div id="40650901" class="c"><input type="checkbox" id="c-40650901" checked=""/><div class="controls bullet"><span class="by">joemi</span><span>|</span><a href="#40646783">root</a><span>|</span><a href="#40649016">parent</a><span>|</span><a href="#40654301">next</a><span>|</span><label class="collapse" for="c-40650901">[-]</label><label class="expand" for="c-40650901">[1 more]</label></div><br/><div class="children"><div class="content">The Pi Pico is not a &quot;huge form factor&quot;. It fits better on breadboard than pretty much anything with an ESP32 on it (since it&#x27;s less wide), and it provides access to most of the RP2040 pins. Since the PIO can drive a lot of pins at once, this lets you really unleash the RP2040&#x27;s power to do things like DVI output. Having access to more pins is something many people consider a plus not a minus.<p>As to your other points, I wouldn&#x27;t mind more flash but I don&#x27;t think the amount it has is particularly small. The micro USB, though, is a disappointment, though.</div><br/></div></div><div id="40654301" class="c"><input type="checkbox" id="c-40654301" checked=""/><div class="controls bullet"><span class="by">KennyBlanken</span><span>|</span><a href="#40646783">root</a><span>|</span><a href="#40649016">parent</a><span>|</span><a href="#40650901">prev</a><span>|</span><a href="#40648075">next</a><span>|</span><label class="collapse" for="c-40654301">[-]</label><label class="expand" for="c-40654301">[1 more]</label></div><br/><div class="children"><div class="content">Given the incompetence in hardware design with nearly every Pi ever released, I&#x27;m not sure why anyone would be surprised that the official Pico board is terrible as well.<p>I mean come on, how do you fuck up USB-PD that badly? Unless you&#x27;re doing it on purpose to force people to buy special power supplies sold by your vendors...</div><br/></div></div></div></div><div id="40648075" class="c"><input type="checkbox" id="c-40648075" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#40646783">parent</a><span>|</span><a href="#40649016">prev</a><span>|</span><a href="#40648694">next</a><span>|</span><label class="collapse" for="c-40648075">[-]</label><label class="expand" for="c-40648075">[2 more]</label></div><br/><div class="children"><div class="content">Unless you&#x27;re incredibly space constrained I don&#x27;t really get the point of that 2040 Zero, it just costs more for fewer features. The Pico is already pretty tiny.<p>The Pico is really good at pin interoperability at least, in the land of ESP, what appears to be lots of IO pins quickly turns into barely enough if you&#x27;re lucky, with pins connected internally to flash or the bootloader or whatever. I really wonder why they even bother breaking those out. The ESP32-CAM comes with 10 data pins, and only 4 of them are actually generally usable lol.</div><br/><div id="40648446" class="c"><input type="checkbox" id="c-40648446" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#40646783">root</a><span>|</span><a href="#40648075">parent</a><span>|</span><a href="#40648694">next</a><span>|</span><label class="collapse" for="c-40648446">[-]</label><label class="expand" for="c-40648446">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s about the clones on aliexpress, which are about $2.50, vs $5 for the pico.</div><br/></div></div></div></div></div></div><div id="40648694" class="c"><input type="checkbox" id="c-40648694" checked=""/><div class="controls bullet"><span class="by">uncletaco</span><span>|</span><a href="#40646783">prev</a><span>|</span><a href="#40646580">next</a><span>|</span><label class="collapse" for="c-40648694">[-]</label><label class="expand" for="c-40648694">[7 more]</label></div><br/><div class="children"><div class="content">RP2040 has single handedly reinvigorated a really niche market: custom controllers. Due to the wonderful work done on gp2040[1] which is open source game pad firmware, people can buy cheap, quality, fightsticks and leverless controllers for a lot cheaper than they can from vendors like Victrix or Razer. Not only that but because its open sourced the hobbyist side of the controller community are building RP2040 pcbs to accommodate all kinds of projects and weird controller ideas.<p>[1] <a href="https:&#x2F;&#x2F;gp2040-ce.info" rel="nofollow">https:&#x2F;&#x2F;gp2040-ce.info</a></div><br/><div id="40648892" class="c"><input type="checkbox" id="c-40648892" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#40648694">parent</a><span>|</span><a href="#40650726">next</a><span>|</span><label class="collapse" for="c-40648892">[-]</label><label class="expand" for="c-40648892">[1 more]</label></div><br/><div class="children"><div class="content">I do wonder how much of that can be accounted directly to the RP2040. Projects like QMK[0] have been using a technically quite similar codebase for making DIY keyboards for quite a while now.<p>At first glance I&#x27;m not really seeing anything in GP2040 which couldn&#x27;t have been done with any other somewhat-modern MCU. The RP2040 has undoubtedly been the catalyst leading to GP2040&#x27;s widespread adoption, but it seems the same could&#x27;ve happened with a Pro Micro instead.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;qmk&#x2F;qmk_firmware">https:&#x2F;&#x2F;github.com&#x2F;qmk&#x2F;qmk_firmware</a></div><br/></div></div><div id="40650726" class="c"><input type="checkbox" id="c-40650726" checked=""/><div class="controls bullet"><span class="by">opello</span><span>|</span><a href="#40648694">parent</a><span>|</span><a href="#40648892">prev</a><span>|</span><a href="#40650421">next</a><span>|</span><label class="collapse" for="c-40650726">[-]</label><label class="expand" for="c-40650726">[3 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t this discount things like the Brook boards (e.g., Zero-Pi[1]) that came before?  I only take issue with &quot;single handedly&quot; because it seems not quite true to the history here.<p>[1] <a href="https:&#x2F;&#x2F;www.brookaccessory.com&#x2F;detail&#x2F;53169470&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.brookaccessory.com&#x2F;detail&#x2F;53169470&#x2F;</a></div><br/><div id="40652237" class="c"><input type="checkbox" id="c-40652237" checked=""/><div class="controls bullet"><span class="by">uncletaco</span><span>|</span><a href="#40648694">root</a><span>|</span><a href="#40650726">parent</a><span>|</span><a href="#40650421">next</a><span>|</span><label class="collapse" for="c-40652237">[-]</label><label class="expand" for="c-40652237">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t. Brook boards always added like an extra $100 dollars to any custom or DIY fight stick. The reinvigoration came because sticks that used to be $250 new are now closer to $100 and in some cases less, particularly leverless controllers. If you&#x27;ve heard of the Haute 42 or any of the countless leverless controllers that have been flooding Ali Express, Amazon, and other sites they&#x27;re possible because of the firmware gp2040. For a lot of these new makers all they have to do is get the pcb printed and build an enclosure.</div><br/><div id="40655133" class="c"><input type="checkbox" id="c-40655133" checked=""/><div class="controls bullet"><span class="by">opello</span><span>|</span><a href="#40648694">root</a><span>|</span><a href="#40652237">parent</a><span>|</span><a href="#40650421">next</a><span>|</span><label class="collapse" for="c-40655133">[-]</label><label class="expand" for="c-40655133">[1 more]</label></div><br/><div class="children"><div class="content">I remember spending $75-$200 for MadCatz&#x2F;Hori&#x2F;... sticks when I was more involved with the fighting game scene around 10 years ago.  Customizing an OEM stick or doing something DIY for an arcade cabinet was doable with a donor controller.<p>This all hangs on what &quot;reinvigorated&quot; means and I&#x27;m fine conceding the ground of not paying close attention in the intervening decade.  I didn&#x27;t think it was prohibitive back then, maybe it was in between then and now, and perhaps the barrier to entry is so low now that it&#x27;s even better for gamers.</div><br/></div></div></div></div></div></div><div id="40650421" class="c"><input type="checkbox" id="c-40650421" checked=""/><div class="controls bullet"><span class="by">CarVac</span><span>|</span><a href="#40648694">parent</a><span>|</span><a href="#40650726">prev</a><span>|</span><a href="#40646580">next</a><span>|</span><label class="collapse" for="c-40650421">[-]</label><label class="expand" for="c-40650421">[2 more]</label></div><br/><div class="children"><div class="content">Not to mention PhobGCC (I&#x27;m the lead dev) and its less-Gamecube-specific descendents such as ProGCC V3 and GC Ultimate and Phizard...</div><br/><div id="40652246" class="c"><input type="checkbox" id="c-40652246" checked=""/><div class="controls bullet"><span class="by">uncletaco</span><span>|</span><a href="#40648694">root</a><span>|</span><a href="#40650421">parent</a><span>|</span><a href="#40646580">next</a><span>|</span><label class="collapse" for="c-40652246">[-]</label><label class="expand" for="c-40652246">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll mention it. PhobGCC is awesome and thank you for making it!</div><br/></div></div></div></div></div></div><div id="40646580" class="c"><input type="checkbox" id="c-40646580" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#40648694">prev</a><span>|</span><a href="#40647333">next</a><span>|</span><label class="collapse" for="c-40646580">[-]</label><label class="expand" for="c-40646580">[25 more]</label></div><br/><div class="children"><div class="content">I switched from ESP32 to the RP2040 because it&#x27;s a much more reliable and documented device. My <i>only</i> concern right now with the RP2040 is that there are many ESP32 models with SPIRAM but it&#x27;s not so simple to find a SPIRAM equipped RP2040 board. To be honest, given that the C development environment of the RP2040 is so good, you can make good use of the memory, but when one wants to develop a large MicroPython project, the SPIRAM is really a great asset. Other than that, everything about the RP2040 is just great.</div><br/><div id="40650985" class="c"><input type="checkbox" id="c-40650985" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#40646580">parent</a><span>|</span><a href="#40652740">next</a><span>|</span><label class="collapse" for="c-40650985">[-]</label><label class="expand" for="c-40650985">[5 more]</label></div><br/><div class="children"><div class="content">I <i>heavily</i> disagree. Iâve been working with the Espressif ecosystem for a couple of months now and itâs the best documented microcontroller platform out there.</div><br/><div id="40656009" class="c"><input type="checkbox" id="c-40656009" checked=""/><div class="controls bullet"><span class="by">casept</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40650985">parent</a><span>|</span><a href="#40651594">next</a><span>|</span><label class="collapse" for="c-40656009">[-]</label><label class="expand" for="c-40656009">[1 more]</label></div><br/><div class="children"><div class="content">Only if you use their SDK. Quite a few parts of the chip lack actual register-level documentation, not so on the 2040.</div><br/></div></div><div id="40651594" class="c"><input type="checkbox" id="c-40651594" checked=""/><div class="controls bullet"><span class="by">throwaway15968</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40650985">parent</a><span>|</span><a href="#40656009">prev</a><span>|</span><a href="#40652863">next</a><span>|</span><label class="collapse" for="c-40651594">[-]</label><label class="expand" for="c-40651594">[2 more]</label></div><br/><div class="children"><div class="content">Completely agreed. ESP-IDF is incredible and the dev experience is miles beyond STM32 (my opinion).</div><br/><div id="40655980" class="c"><input type="checkbox" id="c-40655980" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40651594">parent</a><span>|</span><a href="#40652863">next</a><span>|</span><label class="collapse" for="c-40655980">[-]</label><label class="expand" for="c-40655980">[1 more]</label></div><br/><div class="children"><div class="content">&gt; STM32 (my opinion).<p>STM32 is horrible, if you don&#x27;t want to use the HAL.. Everything I used (Atmel, ESP32, rp2040) was better than that - Tho I heard NXP is bad.</div><br/></div></div></div></div><div id="40652863" class="c"><input type="checkbox" id="c-40652863" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40650985">parent</a><span>|</span><a href="#40651594">prev</a><span>|</span><a href="#40652740">next</a><span>|</span><label class="collapse" for="c-40652863">[-]</label><label class="expand" for="c-40652863">[1 more]</label></div><br/><div class="children"><div class="content">Meanwhile NXP is producing 3000+ page PDFs with behavioral examples.</div><br/></div></div></div></div><div id="40652740" class="c"><input type="checkbox" id="c-40652740" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#40646580">parent</a><span>|</span><a href="#40650985">prev</a><span>|</span><a href="#40646932">next</a><span>|</span><label class="collapse" for="c-40652740">[-]</label><label class="expand" for="c-40652740">[4 more]</label></div><br/><div class="children"><div class="content">The RP2040 only has one QSPI port.<p>JLC will assemble a RP2040 board for you for &lt;$3&#x2F;pc at quantities of 5.</div><br/><div id="40653376" class="c"><input type="checkbox" id="c-40653376" checked=""/><div class="controls bullet"><span class="by">shadowpho</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40652740">parent</a><span>|</span><a href="#40646932">next</a><span>|</span><label class="collapse" for="c-40653376">[-]</label><label class="expand" for="c-40653376">[3 more]</label></div><br/><div class="children"><div class="content">I think itâll be more expensive. When I was looking at jlc it seemed to be $100&#x2F;10 was starting point if you want assembly</div><br/><div id="40653552" class="c"><input type="checkbox" id="c-40653552" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40653376">parent</a><span>|</span><a href="#40653507">next</a><span>|</span><label class="collapse" for="c-40653552">[-]</label><label class="expand" for="c-40653552">[1 more]</label></div><br/><div class="children"><div class="content">You need to carefully select JLC basic parts. QSPI, XOSC, etc. can all be had without paying fees. I&#x27;ve ordered 5+ boards with RP2040s that have come out to &quot;cheaper than Pico&quot; prices.</div><br/></div></div><div id="40653507" class="c"><input type="checkbox" id="c-40653507" checked=""/><div class="controls bullet"><span class="by">MartijnBraam</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40653376">parent</a><span>|</span><a href="#40653552">prev</a><span>|</span><a href="#40646932">next</a><span>|</span><label class="collapse" for="c-40653507">[-]</label><label class="expand" for="c-40653507">[1 more]</label></div><br/><div class="children"><div class="content">It all depends on how you select the parts. I&#x27;ve ordered a set of 5 boards for $12 total including shipping and assembly.</div><br/></div></div></div></div></div></div><div id="40646932" class="c"><input type="checkbox" id="c-40646932" checked=""/><div class="controls bullet"><span class="by">dgroshev</span><span>|</span><a href="#40646580">parent</a><span>|</span><a href="#40652740">prev</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40646932">[-]</label><label class="expand" for="c-40646932">[11 more]</label></div><br/><div class="children"><div class="content">I ended up cutting a section on Rust support from the post, but if you&#x27;re open to Rust (iirc you were sceptical at some point?), async Rust is really pleasant to use in embedded. Dario Nieuwenhuis, one of the main people behind Embassy, gave a great overview talk at RustNL: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=H7NtzyP9q8E" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=H7NtzyP9q8E</a></div><br/><div id="40647303" class="c"><input type="checkbox" id="c-40647303" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40646932">parent</a><span>|</span><a href="#40647302">next</a><span>|</span><label class="collapse" for="c-40647303">[-]</label><label class="expand" for="c-40647303">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I prefer using C :) But happy that there are options out there.</div><br/></div></div><div id="40647302" class="c"><input type="checkbox" id="c-40647302" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40646932">parent</a><span>|</span><a href="#40647303">prev</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40647302">[-]</label><label class="expand" for="c-40647302">[9 more]</label></div><br/><div class="children"><div class="content">I disagree. Rust on embedded is fantastic (I do STM32 programming on rust all the time, and have used the RISC-V ESP chips and nRF-52 as well), but Async Rust on embedded suffers from the same problems of contagion and coloring that non-embedded async rust has.</div><br/><div id="40647513" class="c"><input type="checkbox" id="c-40647513" checked=""/><div class="controls bullet"><span class="by">fleventynine</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40647302">parent</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40647513">[-]</label><label class="expand" for="c-40647513">[8 more]</label></div><br/><div class="children"><div class="content">Everything had tradeoffs, but the composability of the state machines built by the compiler&#x27;s async support allows you to easily build multi-tasking bare-metal systems with thousands of &quot;tasks&quot; and no RTOS (or SRAM-wasting  threads). I highly recommend playing with Embassy for a week before discounting this approach for embedded software.<p>If you care about RAM consumption, you need to share the stack between tasks, forcing you to write event-driven code. Rust async makes this easy, and a bit of function coloring is no big deal compared to converting blocking code into event-driven code the traditional way...</div><br/><div id="40647603" class="c"><input type="checkbox" id="c-40647603" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40647513">parent</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40647603">[-]</label><label class="expand" for="c-40647603">[7 more]</label></div><br/><div class="children"><div class="content">I have - it does not avoid the structural and compatibility problems of Async in other contexts.</div><br/><div id="40647737" class="c"><input type="checkbox" id="c-40647737" checked=""/><div class="controls bullet"><span class="by">fleventynine</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40647603">parent</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40647737">[-]</label><label class="expand" for="c-40647737">[6 more]</label></div><br/><div class="children"><div class="content">Can you go into more details? Most of the criticism I&#x27;ve read tends to be more abstract (&quot;I don&#x27;t like how ALL my blocking-style calls need to be async&quot;), and doesn&#x27;t propose an alternative mechanism to async that can provide a similar coding style in the same tight RAM footprint.</div><br/><div id="40647793" class="c"><input type="checkbox" id="c-40647793" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40647737">parent</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40647793">[-]</label><label class="expand" for="c-40647793">[5 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;ll find details regarding any discussion of async in rust and other languages - I don&#x27;t mean to casually dismiss your question, but my objections are not unique.<p>The alternative mechanism is to use interrupts, DMA, multiple cores, distributed devices (eg a CAN network) a state machine, an RTOS, or, it sounds like in context of this thread, PIOs! You get the point. Do these provide a similar coding style? No, and that&#x27;s the point. The coding style <i>is</i> the objection.<p>I find the &quot;how else would you do it&quot; style questions that come up frequently re Async rust (embedded or not) amusing. It&#x27;s as if there is a new method of accomplishing a task, and asking a world that has been accomplishing this task for decades how it&#x27;s possible to accomplish the task without the new thing!</div><br/><div id="40647976" class="c"><input type="checkbox" id="c-40647976" checked=""/><div class="controls bullet"><span class="by">fleventynine</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40647793">parent</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40647976">[-]</label><label class="expand" for="c-40647976">[4 more]</label></div><br/><div class="children"><div class="content">As I see it, if you need everything to run on a single cpu core, the alternatives are to either implement threads (wasting memory on redundant stacks) or to write the event-driven state machines manually. Whether the state machine is pumped by interrupts or not doesn&#x27;t change anything IMHO.<p>Because of RAM constraints, all the bare-metal projects I&#x27;ve worked on have used manually-written state machines, and I&#x27;m comfortable enough with this approach. But sometimes these state machines can be hard to understand when the control flow is complicated, and I am seriously considering adding some compiler-generated state machines that will fit nicely into my existing model.</div><br/><div id="40650065" class="c"><input type="checkbox" id="c-40650065" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40647976">parent</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40650065">[-]</label><label class="expand" for="c-40650065">[3 more]</label></div><br/><div class="children"><div class="content">none of this will be news to <i>you</i>, but it&#x27;s probably of interest to other people reading the discussion.  you can do stuff inside the interrupt handler itself, and while what you do there does have to be an event-driven explicit state machine, interrupts introduce two key differences:<p>- the <i>rest</i> of your program doesn&#x27;t have to be an explicit state machine; it can use structured control flow with nested loops and conditionals and subroutines<p>- the interaction between the interrupt handlers and the rest of the program is almost completely asynchronous, because as long as interrupts are enabled, the interrupt can fire between any two instructions of the rest of the program; if you look at it as multitasking, it&#x27;s preemptive multitasking rather than cooperative multitasking.  preemptive multitasking introduces a lot of hairy error cases, and this is only moderately simplified by the fact that the rest of the program can&#x27;t preempt your interrupt handler, only vice versa.  arguably that makes the problem worse rather than better because you can&#x27;t solve the problem with locks (except by disabling interrupts as a sort of global lock)</div><br/><div id="40652016" class="c"><input type="checkbox" id="c-40652016" checked=""/><div class="controls bullet"><span class="by">fleventynine</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40650065">parent</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40652016">[-]</label><label class="expand" for="c-40652016">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the rest of your program doesn&#x27;t have to be an explicit state machine; it can use structured control flow with nested loops and conditionals and subroutines<p>This works well until the requirements change and you have to run two structured control flows simultaneously. If I find myself in such a situation and have no SRAM for a second thread, rust async may be the quickest way to accomplish the goal without a major rewrite into manual event driven code.</div><br/><div id="40652277" class="c"><input type="checkbox" id="c-40652277" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40652016">parent</a><span>|</span><a href="#40651100">next</a><span>|</span><label class="collapse" for="c-40652277">[-]</label><label class="expand" for="c-40652277">[1 more]</label></div><br/><div class="children"><div class="content">i don&#x27;t have experience with rust async, although i used to maintain a csp protocol stack in python async, which is pretty similar, so tell me if this is wrong<p>i feel like the same kind of thing can happen even if you start entirely async, because something that was previously synchronous may have to become asynchronous, which leads to having to revalidate all your concurrency assumptions all the way up its (static) call stack.  wherever you were depending on not getting preempted, you need to change the code to not depend on that anymore.  but if ram is so tight that you&#x27;re concerned about the sram for a second stack, maybe that&#x27;s a pretty small task rather than a major rewrite<p>that said, i don&#x27;t recall having actually had that problem</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40651100" class="c"><input type="checkbox" id="c-40651100" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#40646580">parent</a><span>|</span><a href="#40646932">prev</a><span>|</span><a href="#40647333">next</a><span>|</span><label class="collapse" for="c-40651100">[-]</label><label class="expand" for="c-40651100">[4 more]</label></div><br/><div class="children"><div class="content">Did you use esp-idf? Or the Arduino libs?</div><br/><div id="40653896" class="c"><input type="checkbox" id="c-40653896" checked=""/><div class="controls bullet"><span class="by">reassembled</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40651100">parent</a><span>|</span><a href="#40651625">next</a><span>|</span><label class="collapse" for="c-40653896">[-]</label><label class="expand" for="c-40653896">[1 more]</label></div><br/><div class="children"><div class="content">You can use Arduino libs via ESP-IDF. The IDF environment comes with a lot of libraries on its own but it is a development environment first and foremost. The design of IDF is very open and easy to understand throughout the stack. It is very easy to integrate external libraries via CMake as well.</div><br/></div></div><div id="40651625" class="c"><input type="checkbox" id="c-40651625" checked=""/><div class="controls bullet"><span class="by">antirez</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40651100">parent</a><span>|</span><a href="#40653896">prev</a><span>|</span><a href="#40647333">next</a><span>|</span><label class="collapse" for="c-40651625">[-]</label><label class="expand" for="c-40651625">[2 more]</label></div><br/><div class="children"><div class="content">ESP-IDF, Arduino IDE is untouchable for serious stuff IMHO.</div><br/><div id="40653192" class="c"><input type="checkbox" id="c-40653192" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#40646580">root</a><span>|</span><a href="#40651625">parent</a><span>|</span><a href="#40647333">next</a><span>|</span><label class="collapse" for="c-40653192">[-]</label><label class="expand" for="c-40653192">[1 more]</label></div><br/><div class="children"><div class="content">Yeah agreed, that&#x27;s why I was wondering! But esp-idf has been great recently. It used to be very patchy and undocumented but I prefer it over everything else now. I&#x27;ll check the rp2040 docs and try out the dev board I&#x27;ve had for a while, because now I&#x27;m wondering if I&#x27;m missing something haha</div><br/></div></div></div></div></div></div></div></div><div id="40647333" class="c"><input type="checkbox" id="c-40647333" checked=""/><div class="controls bullet"><span class="by">flohoff</span><span>|</span><a href="#40646580">prev</a><span>|</span><a href="#40648767">next</a><span>|</span><label class="collapse" for="c-40647333">[-]</label><label class="expand" for="c-40647333">[33 more]</label></div><br/><div class="children"><div class="content">The issue is that its a comparison about apples to peaches. The RPI2040 is JUST the chip whereas the ESP32 come with tons of peripherals for your liking.<p>From Wifi&#x2F;Bluetooth Antenna, LI Battery Controller, Ethernet whatever, Display or Camera Connector - You choose.<p>And then we have a multitude of even CPU choices and when running on a coin cell it makes a difference powering a second, unnecessary core or even wifi.<p>And with the C6 variants, Espressif even switches ISA again, from 8266, to ESP32 to a RISC-V based ISA.<p>So you are comparing the first of its kind SOC with a decade old Family of SBCs.</div><br/><div id="40650992" class="c"><input type="checkbox" id="c-40650992" checked=""/><div class="controls bullet"><span class="by">Youden</span><span>|</span><a href="#40647333">parent</a><span>|</span><a href="#40647432">next</a><span>|</span><label class="collapse" for="c-40650992">[-]</label><label class="expand" for="c-40650992">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The RPI2040 is JUST the chip whereas the ESP32 come with tons of peripherals for your liking.<p>I think you&#x27;re mistaking the ESP32 devkits for the ESP32 itself. The thing that comes with an antenna, battery controller and any kind of connector whatsoever is a devkit or at least a module. The ESP32 itself is a small IC just like the RP2040.<p>For example you might be thinking of a devkit like this: <a href="https:&#x2F;&#x2F;docs.espressif.com&#x2F;projects&#x2F;esp-idf&#x2F;en&#x2F;latest&#x2F;esp32s3&#x2F;hw-reference&#x2F;esp32s3&#x2F;user-guide-devkitc-1.html" rel="nofollow">https:&#x2F;&#x2F;docs.espressif.com&#x2F;projects&#x2F;esp-idf&#x2F;en&#x2F;latest&#x2F;esp32s...</a><p>Which is itself based on a module (e.g. ESP32-S3-WROOM-1), which just bundles the ESP32-S3 IC with a few niceties (like wifi antenna or connector).<p>The equivalent for the RP2040 would be the Raspberry Pi Pico, which does come with some minor niceties (like a wifi variant). There are other products that package it with different peripherals.<p>&gt; So you are comparing the first of its kind SOC with a decade old Family of SBCs.<p>Neither the RP2040 nor ESP32 series are SBCs and neither has any SBC lineage. The Raspberry Pi SBCs were all Broadcom based, the RP2040 is a brand new IC developed by Raspberry Pi and afaik has no IP licensed by Broadcom.</div><br/></div></div><div id="40647432" class="c"><input type="checkbox" id="c-40647432" checked=""/><div class="controls bullet"><span class="by">snufkin97</span><span>|</span><a href="#40647333">parent</a><span>|</span><a href="#40650992">prev</a><span>|</span><a href="#40647434">next</a><span>|</span><label class="collapse" for="c-40647432">[-]</label><label class="expand" for="c-40647432">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right about the technicals, but I think its about the use cases. RP2040 is indeed one of its kind and is suddenly a great choice for so many projects, both hobby&#x2F;educational and proffessional embedded devices. With its price vs possibilities it just covers soooo much when You know it&#x27;s just one single chip version. To me, this is what tech progress is all about.</div><br/></div></div><div id="40647434" class="c"><input type="checkbox" id="c-40647434" checked=""/><div class="controls bullet"><span class="by">HyulianGrader</span><span>|</span><a href="#40647333">parent</a><span>|</span><a href="#40647432">prev</a><span>|</span><a href="#40648807">next</a><span>|</span><label class="collapse" for="c-40647434">[-]</label><label class="expand" for="c-40647434">[19 more]</label></div><br/><div class="children"><div class="content">It&#x27;s safe to assume he&#x27;s talking about the chip in both cases. You can connect either of them to a battery charger, camera, or nuclear reactor but all of those &#x27;peripherals&#x27; are completely irrelevant to this comparison.</div><br/><div id="40648875" class="c"><input type="checkbox" id="c-40648875" checked=""/><div class="controls bullet"><span class="by">milesvp</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40647434">parent</a><span>|</span><a href="#40649948">next</a><span>|</span><label class="collapse" for="c-40648875">[-]</label><label class="expand" for="c-40648875">[6 more]</label></div><br/><div class="children"><div class="content">FYI. In the embedded space, peripherals refer to the chip&#x27;s built in capabilities. Typically there is a peripheral that handles SPI, a peripheral that handles I2C, a peripheral that handles USART. There might be a peripheral that handles USB, or I2S, or any number of different abilities. It&#x27;s either transistors or microcode on more sophisticated MCUs that allows these peripherals, and not every pin is connected to every peripheral, which can make chip selection even trickier. It really sucks to start designing around a chip that looks like it does everything you need with enough pins to only find out that once you start doing pin layouts you can&#x27;t use both USART2 and I2C because they use the same pins. Worse, is when the datasheet makes this difficult to discern, and you only find out when doing some firmware work on a devboard.</div><br/><div id="40650659" class="c"><input type="checkbox" id="c-40650659" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648875">parent</a><span>|</span><a href="#40649256">next</a><span>|</span><label class="collapse" for="c-40650659">[-]</label><label class="expand" for="c-40650659">[1 more]</label></div><br/><div class="children"><div class="content">Except it&#x27;s not at all how GP used the word:<p>&gt; From Wifi&#x2F;Bluetooth Antenna, LI Battery Controller, Ethernet whatever, Display or Camera Connector - You choose.<p>None of those are in-chip peripherals. Besides, the RP2040 comes with a lot of peripherals too. Not as much as an ESP32 by a wide margin, but still.</div><br/></div></div><div id="40649256" class="c"><input type="checkbox" id="c-40649256" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648875">parent</a><span>|</span><a href="#40650659">prev</a><span>|</span><a href="#40649010">next</a><span>|</span><label class="collapse" for="c-40649256">[-]</label><label class="expand" for="c-40649256">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Worse, is when the datasheet makes this difficult to discern,<p>That&#x27;s why I like RP2040 so much. Datasheet is amazing and clear, even for someone like me who hasn&#x27;t spent too much time in embedded world.<p>There is a special, much shorter document just for hardware design that makes designing a board that uses RP2040 even easier.</div><br/><div id="40652811" class="c"><input type="checkbox" id="c-40652811" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40649256">parent</a><span>|</span><a href="#40649010">next</a><span>|</span><label class="collapse" for="c-40652811">[-]</label><label class="expand" for="c-40652811">[2 more]</label></div><br/><div class="children"><div class="content">The RP2040 has one of the shortest datasheets of any MCU.<p>Look at any Nordic part or NXP part to see what a datasheet is supposed to look like. 3000+ pages with register documentation and behavioral examples.</div><br/><div id="40652891" class="c"><input type="checkbox" id="c-40652891" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40652811">parent</a><span>|</span><a href="#40649010">next</a><span>|</span><label class="collapse" for="c-40652891">[-]</label><label class="expand" for="c-40652891">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, RP2040 also has the least features compared to those.<p>Iâm not talking size of documentation, but itâs âbio-availabilityâ.</div><br/></div></div></div></div></div></div><div id="40649010" class="c"><input type="checkbox" id="c-40649010" checked=""/><div class="controls bullet"><span class="by">HyulianGrader</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648875">parent</a><span>|</span><a href="#40649256">prev</a><span>|</span><a href="#40649948">next</a><span>|</span><label class="collapse" for="c-40649010">[-]</label><label class="expand" for="c-40649010">[1 more]</label></div><br/><div class="children"><div class="content">FYI the RP2040 has peripherals too, a lot of the same ones.<p>It&#x27;s very clear that GP has an odd misconception that an ESP32 is some kind of development board complete with &quot;connectors&quot; and possibly a battery charger, while an RP2040 is just the SoC itself.</div><br/></div></div></div></div><div id="40649948" class="c"><input type="checkbox" id="c-40649948" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40647434">parent</a><span>|</span><a href="#40648875">prev</a><span>|</span><a href="#40647739">next</a><span>|</span><label class="collapse" for="c-40649948">[-]</label><label class="expand" for="c-40649948">[1 more]</label></div><br/><div class="children"><div class="content">But if it&#x27;s about the chip then just grab any ESP32.</div><br/></div></div><div id="40647739" class="c"><input type="checkbox" id="c-40647739" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40647434">parent</a><span>|</span><a href="#40649948">prev</a><span>|</span><a href="#40648807">next</a><span>|</span><label class="collapse" for="c-40647739">[-]</label><label class="expand" for="c-40647739">[11 more]</label></div><br/><div class="children"><div class="content">So is GP.<p>The silicon chip itself for an ESP has:<p>bluetooth, ethernet, wifi, SD&#x2F;EMMC, and a bunch more &quot;peripherals&quot; built into it.<p>The RP2040 does not.<p>To make this painfully clear:<p>For an esp32 to do wifi you wire the esp32 to an antenna.<p>For an RP2040 to do wifi you wire the 2040 to another chip, and that other chip to an antenna.<p>Do you see the difference?</div><br/><div id="40647919" class="c"><input type="checkbox" id="c-40647919" checked=""/><div class="controls bullet"><span class="by">moefh</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40647739">parent</a><span>|</span><a href="#40647829">next</a><span>|</span><label class="collapse" for="c-40647919">[-]</label><label class="expand" for="c-40647919">[4 more]</label></div><br/><div class="children"><div class="content">GP is clearly talking about ESP32 boards, not the chip; they mentioned &quot;LI Battery Controller&quot;, and &quot;Display or Camera Connector&quot;. People sell RP2040 boards with those too, for example:<p>- board with a battery charger: <a href="https:&#x2F;&#x2F;learn.adafruit.com&#x2F;adafruit-feather-rp2040-pico&#x2F;power-management" rel="nofollow">https:&#x2F;&#x2F;learn.adafruit.com&#x2F;adafruit-feather-rp2040-pico&#x2F;powe...</a><p>- board with camera: <a href="https:&#x2F;&#x2F;www.waveshare.com&#x2F;pico-cam-a.htm" rel="nofollow">https:&#x2F;&#x2F;www.waveshare.com&#x2F;pico-cam-a.htm</a></div><br/><div id="40648300" class="c"><input type="checkbox" id="c-40648300" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40647919">parent</a><span>|</span><a href="#40647829">next</a><span>|</span><label class="collapse" for="c-40648300">[-]</label><label class="expand" for="c-40648300">[3 more]</label></div><br/><div class="children"><div class="content">ESP32 is available as a tiny module that is soldered to the board as if it was a chip.<p>Ignoring the module results in a flawed comparison. The module is chip and frequently used.<p>If they encased the module in plastic and called it a chip, it would be the same. You can think of it as a chip.</div><br/><div id="40648500" class="c"><input type="checkbox" id="c-40648500" checked=""/><div class="controls bullet"><span class="by">moefh</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648300">parent</a><span>|</span><a href="#40647829">next</a><span>|</span><label class="collapse" for="c-40648500">[-]</label><label class="expand" for="c-40648500">[2 more]</label></div><br/><div class="children"><div class="content">Do they sell chip-like modules with camera connectors and battery controllers, though? I don&#x27;t deny that ESP32 modules look like and are soldered as though they were chips, but to me it&#x27;s clear that GP was mixing up chips (and chip-like modules) with boards.</div><br/><div id="40651334" class="c"><input type="checkbox" id="c-40651334" checked=""/><div class="controls bullet"><span class="by">tbyehl</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648500">parent</a><span>|</span><a href="#40647829">next</a><span>|</span><label class="collapse" for="c-40651334">[-]</label><label class="expand" for="c-40651334">[1 more]</label></div><br/><div class="children"><div class="content">Espressif sell bare chips, modules with castellations for soldering to a PCB, and complete boards that typically contain a module. Some 3rd-party boards use a bare chip. Some 3rd-party boards also have castellations, as do Picos sold without pre-soldered headers. 3rd-party modules are also a thing.<p>Here&#x27;s a pic of a module and several boards that demonstrates all of that.<p><a href="https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;yxjG8vh" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;yxjG8vh</a></div><br/></div></div></div></div></div></div></div></div><div id="40647829" class="c"><input type="checkbox" id="c-40647829" checked=""/><div class="controls bullet"><span class="by">HyulianGrader</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40647739">parent</a><span>|</span><a href="#40647919">prev</a><span>|</span><a href="#40648807">next</a><span>|</span><label class="collapse" for="c-40647829">[-]</label><label class="expand" for="c-40647829">[6 more]</label></div><br/><div class="children"><div class="content">No, that&#x27;s both &quot;just the chip&quot;, the chips have different peripherals. They both have the usual SPI, I2C, UART, ADC, etc., and they have their differences too.<p>I could just as well say &quot;For an RP2040 to do USB you wire the RP2040 to the connector. For an ESP32 to do USB you wire the 32 to another chip, and that other chip to a connector.&quot;<p>It&#x27;s clear to me GP has the impression that ESP32 is something more (a development board with an ESP32?) than the ESP32 &quot;chip&quot; itself.</div><br/><div id="40648113" class="c"><input type="checkbox" id="c-40648113" checked=""/><div class="controls bullet"><span class="by">krisoft</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40647829">parent</a><span>|</span><a href="#40648807">next</a><span>|</span><label class="collapse" for="c-40648113">[-]</label><label class="expand" for="c-40648113">[5 more]</label></div><br/><div class="children"><div class="content">Maybe look at the ESP32 chip&#x27;s datasheet? [1] This is the first sentence in it: &quot;ESP32 is a single 2.4 GHz Wi-Fi-and-Bluetooth combo chip designed with the TSMC low-power 40 nm technology.&quot; That&#x27;s the chip. Not the development board.<p>1: <a href="https:&#x2F;&#x2F;www.espressif.com&#x2F;sites&#x2F;default&#x2F;files&#x2F;documentation&#x2F;esp32_datasheet_en.pdf" rel="nofollow">https:&#x2F;&#x2F;www.espressif.com&#x2F;sites&#x2F;default&#x2F;files&#x2F;documentation&#x2F;...</a></div><br/><div id="40648321" class="c"><input type="checkbox" id="c-40648321" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648113">parent</a><span>|</span><a href="#40648296">next</a><span>|</span><label class="collapse" for="c-40648321">[-]</label><label class="expand" for="c-40648321">[2 more]</label></div><br/><div class="children"><div class="content">The Espressif chips are available as cheap modules, and frequently used as such.<p>People generally refer to the module, not the isolated chip. The modules are effectively like a chip that you solder to the board.</div><br/><div id="40649373" class="c"><input type="checkbox" id="c-40649373" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648321">parent</a><span>|</span><a href="#40648296">next</a><span>|</span><label class="collapse" for="c-40649373">[-]</label><label class="expand" for="c-40649373">[1 more]</label></div><br/><div class="children"><div class="content">Modules are &quot;just&quot; chip + all necessary hardware to start + antenna connector&#x2F;pcb antenna. Those modules don&#x27;t add any functionality to the chip.<p>The main benefit of those modules is: it&#x27;s already certified with FCC and others, so you don&#x27;t have to re-certify your design for radio communication. Since RP2040 does not have a radio, this is unnecessary.</div><br/></div></div></div></div><div id="40648296" class="c"><input type="checkbox" id="c-40648296" checked=""/><div class="controls bullet"><span class="by">HyulianGrader</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648113">parent</a><span>|</span><a href="#40648321">prev</a><span>|</span><a href="#40648807">next</a><span>|</span><label class="collapse" for="c-40648296">[-]</label><label class="expand" for="c-40648296">[2 more]</label></div><br/><div class="children"><div class="content">What part of that contradicts my comment?<p>To be clear, GP is the one saying the ESP32 is more than just the chip itself, complete with battery controller and camera connector.</div><br/><div id="40652499" class="c"><input type="checkbox" id="c-40652499" checked=""/><div class="controls bullet"><span class="by">krisoft</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648296">parent</a><span>|</span><a href="#40648807">next</a><span>|</span><label class="collapse" for="c-40652499">[-]</label><label class="expand" for="c-40652499">[1 more]</label></div><br/><div class="children"><div class="content">Hmm. You are right.<p>On a second re-read it seems we agree.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40648807" class="c"><input type="checkbox" id="c-40648807" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40647333">parent</a><span>|</span><a href="#40647434">prev</a><span>|</span><a href="#40648767">next</a><span>|</span><label class="collapse" for="c-40648807">[-]</label><label class="expand" for="c-40648807">[11 more]</label></div><br/><div class="children"><div class="content">Is there a non-Chinese equivalent of ESP that compares in terms of module integration re: Wifi et al? (but perhaps not cost)</div><br/><div id="40653199" class="c"><input type="checkbox" id="c-40653199" checked=""/><div class="controls bullet"><span class="by">squarefoot</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648807">parent</a><span>|</span><a href="#40651026">next</a><span>|</span><label class="collapse" for="c-40653199">[-]</label><label class="expand" for="c-40653199">[1 more]</label></div><br/><div class="children"><div class="content">Non Chinese as in not made in China? Pretty hard I believe.
As for near equivalent, I recall about the old (and now possibly hard to find) WiFiMCU modules and the W80x MCUs by Winnermicro.<p><a href="http:&#x2F;&#x2F;wifimcu.com&#x2F;" rel="nofollow">http:&#x2F;&#x2F;wifimcu.com&#x2F;</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;SmartArduino&#x2F;WiFiMCU">https:&#x2F;&#x2F;github.com&#x2F;SmartArduino&#x2F;WiFiMCU</a><p><a href="https:&#x2F;&#x2F;www.aliexpress.com&#x2F;item&#x2F;1005003456975478.html" rel="nofollow">https:&#x2F;&#x2F;www.aliexpress.com&#x2F;item&#x2F;1005003456975478.html</a></div><br/></div></div><div id="40651026" class="c"><input type="checkbox" id="c-40651026" checked=""/><div class="controls bullet"><span class="by">Youden</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648807">parent</a><span>|</span><a href="#40653199">prev</a><span>|</span><a href="#40649966">next</a><span>|</span><label class="collapse" for="c-40651026">[-]</label><label class="expand" for="c-40651026">[2 more]</label></div><br/><div class="children"><div class="content">There aren&#x27;t a whole lot of options for wifi specifically; there&#x27;s tons of choice for Bluetooth though.<p>For Wifi, the only competition I&#x27;m aware of is the wireless STM32 series from ST Microelectronics: <a href="https:&#x2F;&#x2F;www.st.com&#x2F;en&#x2F;microcontrollers-microprocessors&#x2F;stm32-wireless-mcus.html" rel="nofollow">https:&#x2F;&#x2F;www.st.com&#x2F;en&#x2F;microcontrollers-microprocessors&#x2F;stm32...</a><p>For BT, Nordic&#x27;s nRF series is pretty popular. In the DIY world, I mostly know it in the form of the nice!nano, a keyboard controller.</div><br/><div id="40651388" class="c"><input type="checkbox" id="c-40651388" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40651026">parent</a><span>|</span><a href="#40649966">next</a><span>|</span><label class="collapse" for="c-40651388">[-]</label><label class="expand" for="c-40651388">[1 more]</label></div><br/><div class="children"><div class="content">I see some microchip offerings, but am not clear on how they fit into this trade space. <a href="https:&#x2F;&#x2F;www.microchip.com&#x2F;en-us&#x2F;products&#x2F;wireless-connectivity&#x2F;embedded-wi-fi&#x2F;microcontrollers" rel="nofollow">https:&#x2F;&#x2F;www.microchip.com&#x2F;en-us&#x2F;products&#x2F;wireless-connectivi...</a><p>These range from $4 to $14 for MPU + Wifi.</div><br/></div></div></div></div><div id="40649966" class="c"><input type="checkbox" id="c-40649966" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40648807">parent</a><span>|</span><a href="#40651026">prev</a><span>|</span><a href="#40648767">next</a><span>|</span><label class="collapse" for="c-40649966">[-]</label><label class="expand" for="c-40649966">[7 more]</label></div><br/><div class="children"><div class="content">no, of course not</div><br/><div id="40650149" class="c"><input type="checkbox" id="c-40650149" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40649966">parent</a><span>|</span><a href="#40648767">next</a><span>|</span><label class="collapse" for="c-40650149">[-]</label><label class="expand" for="c-40650149">[6 more]</label></div><br/><div class="children"><div class="content">I dont see why that&#x27;s obvious.</div><br/><div id="40651030" class="c"><input type="checkbox" id="c-40651030" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40650149">parent</a><span>|</span><a href="#40648767">next</a><span>|</span><label class="collapse" for="c-40651030">[-]</label><label class="expand" for="c-40651030">[5 more]</label></div><br/><div class="children"><div class="content">many new chips don&#x27;t even have non-chinese datasheets</div><br/><div id="40651281" class="c"><input type="checkbox" id="c-40651281" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40651030">parent</a><span>|</span><a href="#40648767">next</a><span>|</span><label class="collapse" for="c-40651281">[-]</label><label class="expand" for="c-40651281">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re making a probabilistic argument against the existence of an American made (or designed) equivalent to a Wifi+MCU module on a chip?</div><br/><div id="40651417" class="c"><input type="checkbox" id="c-40651417" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40651281">parent</a><span>|</span><a href="#40648767">next</a><span>|</span><label class="collapse" for="c-40651417">[-]</label><label class="expand" for="c-40651417">[3 more]</label></div><br/><div class="children"><div class="content">how is america in any way relevant here?  we were discussing china<p>you might be able to find american-designed (or european-designed, african-designed, antarctica-designed, etc.) chips that do something similar, but you can be pretty sure they will be made either in taiwan or in the rest of china<p>in a now-deleted response to this comment, you asked, &#x27;How is it relevant in the thread I started by asking for american designed chips?&#x27;<p>you <i>didn&#x27;t</i> ask for american-designed chips.  you asked for <i>non-chinese</i> chips, but many chinese chips are american-designed (in some sense, all of them, since transistors and integrated circuits are both american inventions).  literally what you said was<p>&gt; <i>Is there a non-Chinese equivalent of ESP that compares in terms of module integration re: Wifi et al? (but perhaps not cost)</i><p>i just went back to see if you&#x27;d edited your comment, but no, that&#x27;s literally what you said, byte for byte</div><br/><div id="40651874" class="c"><input type="checkbox" id="c-40651874" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#40647333">root</a><span>|</span><a href="#40651417">parent</a><span>|</span><a href="#40651763">prev</a><span>|</span><a href="#40648767">next</a><span>|</span><label class="collapse" for="c-40651874">[-]</label><label class="expand" for="c-40651874">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s very helpful.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40648767" class="c"><input type="checkbox" id="c-40648767" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#40647333">prev</a><span>|</span><a href="#40647835">next</a><span>|</span><label class="collapse" for="c-40648767">[-]</label><label class="expand" for="c-40648767">[10 more]</label></div><br/><div class="children"><div class="content">I have mixed feelings about the RP2040.<p>On the one hand, it&#x27;s a <i>great</i> chip for hobbyists. It&#x27;s cheap, it&#x27;s easily available, it&#x27;s easy to build a board around, and it offers plenty of stuff for your average application.<p>On the other hand, it&#x27;s definitely a bit lacking from a professional perspective. The peripherals are <i>fine</i>, but once you start looking into the details it&#x27;s easy to run into limitations. That XIP interface is great - but it doesn&#x27;t support writing so you can&#x27;t hook up an FRAM chip and expand your memory. That PIO interface is amazing - but having only 2x32 instructions is quite limiting once you try to implement more complex interfaces. And where are my Timer&#x2F;Counters? No capacitive touch? Analog on only four pins? No 5V tolerance? No high-speed clock input for the PIO modules? Why can&#x27;t I run the bootloader off the internal ring oscillator? Hmm, a USB-C PHY sure would&#x27;ve been helpful...<p>I was also surprised about its poor ESD performance. An Atmega or STM32 can handle the occasional zap just fine - ESD protection is more of a nice-to-have on external-facing ports. The RP2040? If you don&#x27;t add external protection to <i>every single pin</i> you are basically guaranteed to see a few of them die due to day-to-day use.<p>To summarize: neat chip, great for hobbyists, wouldn&#x27;t be my first choice in professional environments.</div><br/><div id="40650109" class="c"><input type="checkbox" id="c-40650109" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40648767">parent</a><span>|</span><a href="#40649038">next</a><span>|</span><label class="collapse" for="c-40650109">[-]</label><label class="expand" for="c-40650109">[5 more]</label></div><br/><div class="children"><div class="content">i&#x27;m curious what kinds of applications you&#x27;ve found fram most useful for.  it seems like a really cool technology, but the price point is so high that i struggle to understand when you&#x27;d use it rather than a combination of sram (or psram) and nand</div><br/><div id="40651000" class="c"><input type="checkbox" id="c-40651000" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40648767">root</a><span>|</span><a href="#40650109">parent</a><span>|</span><a href="#40649038">next</a><span>|</span><label class="collapse" for="c-40651000">[-]</label><label class="expand" for="c-40651000">[4 more]</label></div><br/><div class="children"><div class="content">I assume that most people&#x27;s use of FRAM is when its integrated into TI&#x27;s MSP430 microcontrollers<p>IE: if FRAM comes free with your MCU, might as well use it and take advantage of its benefits. For example: MSP430FR4132, just picking one such MCU off of Digikey (<a href="https:&#x2F;&#x2F;www.digikey.com&#x2F;en&#x2F;products&#x2F;detail&#x2F;texas-instruments&#x2F;MSP430FR4132IG56&#x2F;5067015" rel="nofollow">https:&#x2F;&#x2F;www.digikey.com&#x2F;en&#x2F;products&#x2F;detail&#x2F;texas-instruments...</a>)<p>------<p>Most of what I know of FRAM comes from TI&#x27;s marketing pages. <a href="https:&#x2F;&#x2F;www.ti.com&#x2F;document-viewer&#x2F;lit&#x2F;html&#x2F;SSZTA32" rel="nofollow">https:&#x2F;&#x2F;www.ti.com&#x2F;document-viewer&#x2F;lit&#x2F;html&#x2F;SSZTA32</a></div><br/><div id="40651408" class="c"><input type="checkbox" id="c-40651408" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40648767">root</a><span>|</span><a href="#40651000">parent</a><span>|</span><a href="#40649038">next</a><span>|</span><label class="collapse" for="c-40651408">[-]</label><label class="expand" for="c-40651408">[3 more]</label></div><br/><div class="children"><div class="content">probably so, but crote was talking about external fram chips<p>the msp430fr4132 you linked costs 160Â¢ in quantity 35, which is actually considerably cheaper than comparable flash-based chips like the msp430f233 <a href="https:&#x2F;&#x2F;www.digikey.com&#x2F;en&#x2F;products&#x2F;detail&#x2F;texas-instruments&#x2F;MSP430F233TPMR&#x2F;1784864" rel="nofollow">https:&#x2F;&#x2F;www.digikey.com&#x2F;en&#x2F;products&#x2F;detail&#x2F;texas-instruments...</a> which is 500Â¢ in quantity 25.  so that&#x27;s maybe one reason people would use fram: evidently it&#x27;s cheaper than nor?  but i&#x27;m pretty sure there are Î¼cs with 8k of nor flash that are cheaper than that and in fact cheaper than the price difference.  is this pricing policy some sort of loss leader by ti to drive fram adoption?  it seems unlikely.  does using fram instead of nor make it cheaper for ti to make the chip?  surely 8k of nor couldn&#x27;t account for such a large cost<p>on further investigation, i <i>don&#x27;t</i> find Î¼cs with 8k of nor flash that are cheaper than that, at least in stock at digi-key and still in production.  <a href="https:&#x2F;&#x2F;www.digikey.com&#x2F;en&#x2F;products&#x2F;filter&#x2F;embedded&#x2F;microcontrollers&#x2F;685?s=N4IgjCBcpgrLVQGMoDMCGAbAzgUwDQgD2UA2iAEwUDs1ALNSIVbXQBxOUAMbAzLxGbtYvCpwoA2CdQpdxUmYMoKKvcWy4BOLnU51NvOl0bNqXWNvGa6quc2uqx9m7wTPVE9UYpLe5rSYg1IawgWzUYIac4ZFuIDG8noQJgfqG5pyaEgZqhGBcflKZbBIUcfkaYJqcFVyyNTx15Y00DRoUHIR0%2BmCteWASvYFgNll24KODNbB00sMz0p3gC9TVeQsaNRIzm10GRkngUn654GxsRuNg50ZK1xd1NTcZec%2BH1xIX5Zpmmk6UIxkgR8DA64jK4X%2BVFg4VO0PCumYEOocW2BnO4gO4UxvBRcQo3WswMJ7Ex%2Bn0nBkGk0SzKVKUdI6-0UbE0%2BIsIkOZTZuPEHN4tMGIjWyjgRnkYsRop28h49HkAoECr4UO2onGHRk8HUWq5BjgcT8AUNXAChxOqiWFt4Iot4sIfjorhFtDZgVW12Zmmupwe12itxFD3qyVgBMOJTqUpKsFN0W2j2SCd9CcO2m2hyd7B0mXg3oa%2BS4d3MbAGNWusfeFeM5bYsaWIwKNum1GyUrgqx%2BLc0NOmGkTy378w0s040lCMK2sA%2BT2C3SepciY7rNpFVR%2B%2BXEAw6Gpt-Che-44kP%2BL3EilqgMRUI2VoEUxVCmQgs9sosykXMGBWB1Bid1k07lABIbgMBSh0AM2x6AStB6MEuzxAUkT-PAoinDMNpXJ8mo1KoeY1AIqwanUAynJMvJIr%2BdbiDopRKBEZhQYQDFcNeIDZNo%2BbMFIpZLCx0hWE6vY3nWkhxPxtIXB0DbSD2ngALqEAADgALlAIAAMoqQATgAlgAdgA5iAAC%2B9hyNAIAoJAGA4AQxBkCAhi0JODoMHwciKSAqnqVpelGaZhAALRiJZ1k6QArvZJCQOQCDySZZnsYgIC6QAJupQX5EoPmQCAnAAI4qQAnupnAlUpuDqeg2AoIlQA" rel="nofollow">https:&#x2F;&#x2F;www.digikey.com&#x2F;en&#x2F;products&#x2F;filter&#x2F;embedded&#x2F;microcon...</a> is the link to my search, which i trust hn will abbreviate in a useful way.  but lcsc has the ch32v203 in stock for 39Â¢ in quantity 100 <a href="https:&#x2F;&#x2F;www.lcsc.com&#x2F;product-detail&#x2F;Microcontroller-Units-MCUs-MPUs-SOCs_WCH-Jiangsu-Qin-Heng-CH32V203G6U6_C5142280.html" rel="nofollow">https:&#x2F;&#x2F;www.lcsc.com&#x2F;product-detail&#x2F;Microcontroller-Units-MC...</a> and that has 20k of sram, 64k of flash (presumably nor!), and 24 gpios.  that&#x27;s half the gpios of the ti chip, but i believe my digi-key search linked above was not limited by pin count<p>so maybe the only reason fram costs more is that ti doesn&#x27;t license the fram patents to chinese companies?  it still beggars belief that ti (and microchip, st, etc.) would be spending three dollars a chip on 8k of nor, or even three dollars a chip divided by two layers of profit margin</div><br/><div id="40652543" class="c"><input type="checkbox" id="c-40652543" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40648767">root</a><span>|</span><a href="#40651408">parent</a><span>|</span><a href="#40649038">next</a><span>|</span><label class="collapse" for="c-40652543">[-]</label><label class="expand" for="c-40652543">[2 more]</label></div><br/><div class="children"><div class="content">AVR64DD14 is $1.20 qty25 for 64kB of Flash and 8kB of SRAM (and quite a bit more analog features, like dual-power supplies, more ACs, DAC, Differential ADC...).<p>So I&#x27;m pretty sure NOR Flash remains quite cheap. TI&#x27;s MSP430 are all cheapest with FRAM though, so your question is curious. I admit I don&#x27;t know where to go or how to investigate your question however. I don&#x27;t really use MSP430 myself, I just know thats what is commonly associated with FRAM in the literature I&#x27;ve read.</div><br/><div id="40652691" class="c"><input type="checkbox" id="c-40652691" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40648767">root</a><span>|</span><a href="#40652543">parent</a><span>|</span><a href="#40649038">next</a><span>|</span><label class="collapse" for="c-40652691">[-]</label><label class="expand" for="c-40652691">[1 more]</label></div><br/><div class="children"><div class="content">huh, I wonder why it wasn&#x27;t coming up in my search<p>just as a perspective point on &#x27;quite cheap&#x27;, nor is still about a thousand times more expensive than nand<p>i would never buy from ti. they hate hobbyists and have since at least the 70s. they put limor fried on a blacklist</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40649038" class="c"><input type="checkbox" id="c-40649038" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40648767">parent</a><span>|</span><a href="#40650109">prev</a><span>|</span><a href="#40649294">next</a><span>|</span><label class="collapse" for="c-40649038">[-]</label><label class="expand" for="c-40649038">[1 more]</label></div><br/><div class="children"><div class="content">I suspect that the Synopsys DesignWare SSI macro in RP2040 can in fact be used for R&#x2F;W PSRAM or FRAM, but the abridged documentation of it in RP2040 datasheet is not sufficient for one to configure it that way.</div><br/></div></div><div id="40649294" class="c"><input type="checkbox" id="c-40649294" checked=""/><div class="controls bullet"><span class="by">ChiefNotAClue</span><span>|</span><a href="#40648767">parent</a><span>|</span><a href="#40649038">prev</a><span>|</span><a href="#40649044">next</a><span>|</span><label class="collapse" for="c-40649294">[-]</label><label class="expand" for="c-40649294">[1 more]</label></div><br/><div class="children"><div class="content">Well said. I&#x27;ll add that, as a hobbyist, you&#x27;ll eventually work on more involved projects and run into those exact limitations.</div><br/></div></div><div id="40649044" class="c"><input type="checkbox" id="c-40649044" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#40648767">parent</a><span>|</span><a href="#40649294">prev</a><span>|</span><a href="#40648795">next</a><span>|</span><label class="collapse" for="c-40649044">[-]</label><label class="expand" for="c-40649044">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean by USB-C PHY? USB-C is the connector, and you can run USB 1.1&#x2F;2.0&#x2F;3.0&#x2F;3.1 through it, but realistically a RP2040 can not feed even a USB 2.0 PHY.</div><br/></div></div><div id="40648795" class="c"><input type="checkbox" id="c-40648795" checked=""/><div class="controls bullet"><span class="by">doubloon</span><span>|</span><a href="#40648767">parent</a><span>|</span><a href="#40649044">prev</a><span>|</span><a href="#40647835">next</a><span>|</span><label class="collapse" for="c-40648795">[-]</label><label class="expand" for="c-40648795">[1 more]</label></div><br/><div class="children"><div class="content">Raspberry pi was originally an educational non profit</div><br/></div></div></div></div><div id="40647835" class="c"><input type="checkbox" id="c-40647835" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#40648767">prev</a><span>|</span><a href="#40648035">next</a><span>|</span><label class="collapse" for="c-40647835">[-]</label><label class="expand" for="c-40647835">[2 more]</label></div><br/><div class="children"><div class="content">The RP2040 is pretty cool. I&#x27;ve used them in a half dozen projects now.<p>&gt; Raspberry Pi pulled a Henry Ford and boldly went with just one microcontroller.<p>However, this one size fits all thing doesn&#x27;t work for me. I prefer to use the least microcontroller that will do the job I need done.<p>&gt; There is no choice, no right sizing, but that might be OK! An RP2040 costs ~70 cents, and not all gizmos are produced by the million.<p>The reason I like to use the wimpiest microcontroller possible is not related to monetary cost. It&#x27;s related to my power budget. Most of my projects are battery-powered, and having them use the least possible amount of juice is a huge advantage.<p>But even so, why use a $1 microcontroller when a 20 cent one will do the job equally well?</div><br/><div id="40651703" class="c"><input type="checkbox" id="c-40651703" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40647835">parent</a><span>|</span><a href="#40648035">next</a><span>|</span><label class="collapse" for="c-40651703">[-]</label><label class="expand" for="c-40651703">[1 more]</label></div><br/><div class="children"><div class="content">A much larger pool of online documentation, example code, and experienced hobbyists who like answering questions, is worth a great deal more than eighty cents.<p>Getting more use out of the battery is a good and sufficient reason to use a less powerful controller, though. It being cheaper is nice in theory, but almost meaningless for a one-off project, in practice.  I can&#x27;t remember the last time I made a purchase which was a fraction of a dollar, it just doesn&#x27;t move the needle.</div><br/></div></div></div></div><div id="40648035" class="c"><input type="checkbox" id="c-40648035" checked=""/><div class="controls bullet"><span class="by">peteforde</span><span>|</span><a href="#40647835">prev</a><span>|</span><a href="#40649012">next</a><span>|</span><label class="collapse" for="c-40648035">[-]</label><label class="expand" for="c-40648035">[30 more]</label></div><br/><div class="children"><div class="content">I also like the RP2040, but I&#x27;d like to explain why I migrated away from it for my current project.<p>First, the drama with PlatformIO really rubbed me the wrong way. I&#x27;m taking the side of the developers who are hurt by confusion in tooling.<p>Second, the top of the line ESP32-S3 comes in a module format that can be dropped on a PCB with basically nothing but a few decoupling capacitors. The RP2040 requires careful placement of about a dozen components, including a crystal. Not only does a module reduce implementation complexity dramatically, standardization skips every engineer potentially making their own dumb component placement mistakes.<p>Third, the ESP32-S3 has 14 GPIO pins that can be configured to do capacitive touch, while the RP2040 has none. Most of the projects that use RP2040 and capacitive touch rely on the MPR121, an IC that past its EOL and will likely cause a lot of hasty redesigns over the next few months.<p>It&#x27;s also worth saying that eventually RP2040 will likely release more or less powerful versions, and hopefully versions in a module format. I doubt they will ever let it become an STM or PIC situation, but the ESP32 product lineup doesn&#x27;t look so crazy once you are acclimatized to it.</div><br/><div id="40648289" class="c"><input type="checkbox" id="c-40648289" checked=""/><div class="controls bullet"><span class="by">geerlingguy</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40648812">next</a><span>|</span><label class="collapse" for="c-40648289">[-]</label><label class="expand" for="c-40648289">[7 more]</label></div><br/><div class="children"><div class="content">It seems like Espressif are in the same situation as Pi w&#x2F;r&#x2F;t PlatformIO[1]. As an outsider, it sounds like PlatformIO was trying to extract a very large annual payment from RPi and Espressif, and that was <i>after</i> the initial support was added in, and some of the community started adopting it.<p>It&#x27;s a weird situation, but I think PlatformIO built up a dominant position by supporting all these platforms and accepting community contributions to do so, then tried extracting value from the manufacturers directly after the fact, blocking further community PRs that would add new board revisions or fix bugs. See related: [2]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;platformio&#x2F;platform-espressif32&#x2F;issues&#x2F;1225">https:&#x2F;&#x2F;github.com&#x2F;platformio&#x2F;platform-espressif32&#x2F;issues&#x2F;12...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;platformio&#x2F;platform-raspberrypi&#x2F;pull&#x2F;36">https:&#x2F;&#x2F;github.com&#x2F;platformio&#x2F;platform-raspberrypi&#x2F;pull&#x2F;36</a></div><br/><div id="40648734" class="c"><input type="checkbox" id="c-40648734" checked=""/><div class="controls bullet"><span class="by">peteforde</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40648289">parent</a><span>|</span><a href="#40648812">next</a><span>|</span><label class="collapse" for="c-40648734">[-]</label><label class="expand" for="c-40648734">[6 more]</label></div><br/><div class="children"><div class="content">Thanks for all of your rational contributions to those many threads, Jeff.<p>It is an <i>extremely</i> weird situation, and a deeply bad look. If I was pressed for an opinion, I would say that I wish Eben had taken the high road and gone all in on supporting PIO despite the tangy mystery aftertaste for the simple reason that it would be a net-positive for developers.<p>The way things stand, migrating away from the Arduino IDE to using VSCode with RP2040 feels like you&#x27;re being actively messed with; there&#x27;s so many projects and forum posts that sound like the right path, when it seems like the actual answer should be super simple. This is super painful for newcomers.</div><br/><div id="40649337" class="c"><input type="checkbox" id="c-40649337" checked=""/><div class="controls bullet"><span class="by">gchadwick</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40648734">parent</a><span>|</span><a href="#40649313">next</a><span>|</span><label class="collapse" for="c-40649337">[-]</label><label class="expand" for="c-40649337">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It is an extremely weird situation, and a deeply bad look<p>I never followed all the ins and outs but from having a quick look through the comments on <a href="https:&#x2F;&#x2F;github.com&#x2F;platformio&#x2F;platform-raspberrypi&#x2F;pull&#x2F;36">https:&#x2F;&#x2F;github.com&#x2F;platformio&#x2F;platform-raspberrypi&#x2F;pull&#x2F;36</a> the following happened:<p><pre><code>  - Developer independent of RPi opens PR to add RP2040 support to PlatformIO

  - PlatformIO don&#x27;t want to merge it, expecting some financial contribution to help maintain the support (seems reasonable)

  - They discuss this with RPi, ultimately RPi don&#x27;t want to pay the asked contributions so that PlatformIO are happy maintaining support (this also seems reasonable)

  - End result is no RP2040 support in PlatformIO
</code></pre>
Ultimately maintaining things isn&#x27;t free. RPi have chosen the development environment(s) they wish to support and it hasn&#x27;t included PlatformIO. What&#x27;s weird or a bad look?</div><br/><div id="40655399" class="c"><input type="checkbox" id="c-40655399" checked=""/><div class="controls bullet"><span class="by">moefh</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40649337">parent</a><span>|</span><a href="#40649631">next</a><span>|</span><label class="collapse" for="c-40655399">[-]</label><label class="expand" for="c-40655399">[1 more]</label></div><br/><div class="children"><div class="content">The problem (to me) is that they welcomed that PR and requested corrections until it was in a good enough shape to be accepted, without any indication that <i>it wouldn&#x27;t be accepted</i> unless&#x2F;until they had financial support from RPi. That only became clear almost a year after the PR was opened.</div><br/></div></div><div id="40649631" class="c"><input type="checkbox" id="c-40649631" checked=""/><div class="controls bullet"><span class="by">sangnoir</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40649337">parent</a><span>|</span><a href="#40655399">prev</a><span>|</span><a href="#40649313">next</a><span>|</span><label class="collapse" for="c-40649631">[-]</label><label class="expand" for="c-40649631">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Ultimately maintaining things isn&#x27;t free.<p>This is a hypocritical stance for any project that accepts free contributions from the public. Besides rent-seeking, what reason could justify preventing the community from maintaining features&#x2F;microcontrollers that the organization is unwilling to (due to costs)?</div><br/><div id="40649852" class="c"><input type="checkbox" id="c-40649852" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40649631">parent</a><span>|</span><a href="#40649313">next</a><span>|</span><label class="collapse" for="c-40649852">[-]</label><label class="expand" for="c-40649852">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Besides rent-seeking, what reason could justify preventing the community from maintaining features&#x2F;microcontrollers that the organization is unwilling to (due to costs)?<p>Platformio I suspect.</div><br/></div></div></div></div></div></div><div id="40649313" class="c"><input type="checkbox" id="c-40649313" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40648734">parent</a><span>|</span><a href="#40649337">prev</a><span>|</span><a href="#40648812">next</a><span>|</span><label class="collapse" for="c-40649313">[-]</label><label class="expand" for="c-40649313">[1 more]</label></div><br/><div class="children"><div class="content">Can you provide a TLDR to what the state of things are? I was under the impression that ESPHome was built on top of PlatformIO so this sounds scary...</div><br/></div></div></div></div></div></div><div id="40648812" class="c"><input type="checkbox" id="c-40648812" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40648289">prev</a><span>|</span><a href="#40649146">next</a><span>|</span><label class="collapse" for="c-40648812">[-]</label><label class="expand" for="c-40648812">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The RP2040 requires careful placement of about a dozen components, including a crystal.<p>To be fair, the chip is designed to make these <i>really</i> easy to place. There&#x27;s pretty much one single layout which makes sense, and it provides easy access to all the pins you could possibly want. Combine that with the <i>excellent</i> documentation they have provided, and it&#x27;s essentially just a multi-part drop-in design you don&#x27;t ever have to think about again.<p>It did look a little bit intimidating at first, but it was a genuinely pleasure to implement.</div><br/><div id="40648879" class="c"><input type="checkbox" id="c-40648879" checked=""/><div class="controls bullet"><span class="by">peteforde</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40648812">parent</a><span>|</span><a href="#40649146">next</a><span>|</span><label class="collapse" for="c-40648879">[-]</label><label class="expand" for="c-40648879">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re kind of making my point for me; when every engineer has to place a dozen components, a non-zero number of them are going to make facepalm mistakes.<p>Even if you create a sub-module layout that you include in every project you work on... that&#x27;s still n slightly different permutations of the same thing, even if they are all perfect. (They aren&#x27;t.)</div><br/><div id="40651775" class="c"><input type="checkbox" id="c-40651775" checked=""/><div class="controls bullet"><span class="by">petsfed</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40648879">parent</a><span>|</span><a href="#40649146">next</a><span>|</span><label class="collapse" for="c-40651775">[-]</label><label class="expand" for="c-40651775">[1 more]</label></div><br/><div class="children"><div class="content">A non-zero number of engineers will implement &quot;hello world&quot; wrong when they&#x27;re first learning a language. That&#x27;s not an argument against any given programming language either. &quot;I made a design error that the documentation specifically calls out as something to avoid&quot; doesn&#x27;t hold much water as a legitimate criticism. Especially when the design error is &quot;I didn&#x27;t put the decoupling cap very close to the pin it&#x27;s supposed to be decoupling for&quot;. (as an aside, you should read the &quot;minimal design example&quot; chapter from the RP2040 Hardware Design Guide[0], even if you have zero intention of designing with the chip. It&#x27;s a literal masterclass in beginner-level pcb design.)<p>Literally none of this is actually a hazard if you design more than one PCBA with a microcontroller on it in your entire life. I&#x27;d argue that designing around a castellated-edge module is much MUCH harder to get right on the first try than discrete components, even though the parameter space is <i>apparently</i> much smaller.<p>0. <a href="https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;hardware-design-with-rp2040.pdf" rel="nofollow">https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;hardware-design-wi...</a></div><br/></div></div></div></div></div></div><div id="40649146" class="c"><input type="checkbox" id="c-40649146" checked=""/><div class="controls bullet"><span class="by">adriancr</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40648812">prev</a><span>|</span><a href="#40655467">next</a><span>|</span><label class="collapse" for="c-40649146">[-]</label><label class="expand" for="c-40649146">[1 more]</label></div><br/><div class="children"><div class="content">&gt; First, the drama with PlatformIO really rubbed me the wrong way. I&#x27;m taking the side of the developers who are hurt by confusion in tooling.<p>I&#x27;m out of the loop, have been using rp2040 since launch and never used platformIO.<p>How did you use it and what rubbed you the wrong way?<p>Developing locally either with cmake and pico sdk or micropython seems very easy... why add platformio in the mix?</div><br/></div></div><div id="40655467" class="c"><input type="checkbox" id="c-40655467" checked=""/><div class="controls bullet"><span class="by">mordae</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40649146">prev</a><span>|</span><a href="#40649744">next</a><span>|</span><label class="collapse" for="c-40655467">[-]</label><label class="expand" for="c-40655467">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The RP2040 requires careful placement of about a dozen components, including a crystal.<p>I have had 14yo kids do the PCB layout for RP2040 on our custom handheld console. They had no trouble.<p>Nor did I with my ~10 boards.<p>Crystal is the simplest, decoupling can be a chore, but only if you add them too late. Power can be 90% done with a pour under the package.</div><br/></div></div><div id="40649744" class="c"><input type="checkbox" id="c-40649744" checked=""/><div class="controls bullet"><span class="by">zbrozek</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40655467">prev</a><span>|</span><a href="#40648641">next</a><span>|</span><label class="collapse" for="c-40649744">[-]</label><label class="expand" for="c-40649744">[2 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t think there&#x27;s any significant value to be gained by turning this into a module. Everyone wants a slightly different form factor and the thing is so easy to design around that a module isn&#x27;t meaningfully achieving anything.<p>Touch is a niche single tasker. I&#x27;m glad they didn&#x27;t include it. Using another ic for that makes sense, and folks being lazy and sticking to an EOL part to provide that functionality isn&#x27;t RPi&#x27;s problem. Or do it in software.<p>I&#x27;m with the OP on this one, I really think the foundation nailed the product definition.</div><br/><div id="40649951" class="c"><input type="checkbox" id="c-40649951" checked=""/><div class="controls bullet"><span class="by">aswanson</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40649744">parent</a><span>|</span><a href="#40648641">next</a><span>|</span><label class="collapse" for="c-40649951">[-]</label><label class="expand" for="c-40649951">[1 more]</label></div><br/><div class="children"><div class="content">The pico board is the de facto module for me. Very cheap and breaks out every useful signal.</div><br/></div></div></div></div><div id="40648641" class="c"><input type="checkbox" id="c-40648641" checked=""/><div class="controls bullet"><span class="by">danhor</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40649744">prev</a><span>|</span><a href="#40649242">next</a><span>|</span><label class="collapse" for="c-40648641">[-]</label><label class="expand" for="c-40648641">[3 more]</label></div><br/><div class="children"><div class="content">The Pi Pico is intended to be the module format (and can be delivered on reels and used with some PnP machines), though it is much larger than it needs to be for this purpose (and this might be why you didn&#x27;t mention it).<p>I have only implement touch buttons for hobby projects using a different MCU, but is there a reason to not just use the PIOs for touch sensing?</div><br/><div id="40648825" class="c"><input type="checkbox" id="c-40648825" checked=""/><div class="controls bullet"><span class="by">peteforde</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40648641">parent</a><span>|</span><a href="#40648715">next</a><span>|</span><label class="collapse" for="c-40648825">[-]</label><label class="expand" for="c-40648825">[1 more]</label></div><br/><div class="children"><div class="content">I can appreciate intentions, but a Pi Pico does not compare favorably to a chip module in any regard.<p>It&#x27;s huge, it only exposes 26 GPIOs.<p>I&#x27;m not saying Pico sucks by any means. It has uses and places. It&#x27;s just very not this: <a href="https:&#x2F;&#x2F;www.digikey.ca&#x2F;en&#x2F;products&#x2F;detail&#x2F;espressif-systems&#x2F;ESP32-S3-MINI-1U-N8&#x2F;17728863" rel="nofollow">https:&#x2F;&#x2F;www.digikey.ca&#x2F;en&#x2F;products&#x2F;detail&#x2F;espressif-systems&#x2F;...</a></div><br/></div></div></div></div><div id="40649242" class="c"><input type="checkbox" id="c-40649242" checked=""/><div class="controls bullet"><span class="by">petsfed</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40648641">prev</a><span>|</span><a href="#40648603">next</a><span>|</span><label class="collapse" for="c-40649242">[-]</label><label class="expand" for="c-40649242">[2 more]</label></div><br/><div class="children"><div class="content">&gt;<i>Not only does a module reduce implementation complexity dramatically, standardization skips every engineer potentially making their own dumb component placement mistakes.</i><p>And we&#x27;ve never found a way around that for the decades we&#x27;ve been putting Atmel, STM, TI, Ambiq, Nordic, etc chips in our designs... There&#x27;s an intern 2 yards away from me who will be wrestling with getting the right components in place around an STM, for his very first pcb design. This is not a hard problem for anyone who has been doing this for any period of time.<p>And anyway, those dozen or so components are the oscillator&#x2F;crystal circuit, the reset holdup, and the 3.3v supply. And then like a bazillion decoupling caps.  Certainly, antenna tuning can be hard, but if you can use chip antennas, its not <i>that</i> hard.<p>All of those are so bog standard that when I looked at e.g. the adafruit RP2040 Feather&#x27;s schematic, I was sort of surprised at how much is just lifted wholesale from all of their other feathers. Like, the only difference between the RP2040 feather and the nRF52840 feather is the micro itself, the timing circuit (all 5 components of it for the RP2040), and the antenna circuit for the Nordic board.<p>As to the convenience of modules, I submit that they are very handy for sale to the hobbyist market, but if you want to actually sell your products, you still have to go through the process of RF certification (although at a lower cost. Only you can decide if the higher upfront cost of using a module vs. spinning your own is offset by the lower certification cost), so the benefit is a lot more mixed. Even so, you&#x27;re only saving the antenna tuning step, which is usually done as a BOM variation, not a major trace adjustment.<p>As to the dozens of STM and PIC chips, TI has the same situation. Customers want to pay for only what they need and those manufacturers have the manufacturing capacity to support that desire. Its not daunting if the difference matters. This is very much akin to complaining that Home Depot sells too many different kinds of lumber.<p>As for capacitive touch ICs, sure Adafruit only carries one. But mouser carries 199 that are not end of life. To keep that functionality going, adafruit need only pick up one of them. The cheapest one is even in a TSOT package, so the DFM will be pretty easy. Hell, if I&#x27;m not too tired from my job designing and programming these things, I might go home and spin one up tonight. Ought to only take me an hour or so. And the I2C driver another couple hours.</div><br/><div id="40653144" class="c"><input type="checkbox" id="c-40653144" checked=""/><div class="controls bullet"><span class="by">floating-io</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40649242">parent</a><span>|</span><a href="#40648603">next</a><span>|</span><label class="collapse" for="c-40653144">[-]</label><label class="expand" for="c-40653144">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but if you want to actually sell your products, you still have to go through the process of RF certification (although at a lower cost. Only you can decide if the higher upfront cost of using a module vs. spinning your own is offset by the lower certification cost)<p>I doubt it was your intention given the disclaimer there, but based on my own research into this issue, this is a highly misleading statement, especially for small volume products.<p>Full FCC RF certification is not only very expensive, but also very complex from what I understand.  It is <i>NOT</i> an easy process.  That is why these modules are so popular in many actual commercial products.<p>If you need FCC certification for your product and use a pre-certified module (and presuming no other radio hardware is present), you only have to undergo the testing for an unintentional radiator I believe, which is a much simpler prospect.<p>The difference in cost is said to be in the neighborhood of $5K to $10K, though I haven&#x27;t gotten any actual quotes yet, so I can&#x27;t give anything definitive there.<p>Disclaimer:  IANAL of any description, and I have not yet gone through this process myself; I&#x27;m just researching it as I get ready to produce a product.  Do your own research, or better yet, hire someone who truly knows this stuff!</div><br/></div></div></div></div><div id="40648603" class="c"><input type="checkbox" id="c-40648603" checked=""/><div class="controls bullet"><span class="by">127</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40649242">prev</a><span>|</span><a href="#40648938">next</a><span>|</span><label class="collapse" for="c-40648603">[-]</label><label class="expand" for="c-40648603">[4 more]</label></div><br/><div class="children"><div class="content">You can do capacitive touch with RP2040 just fine. Turn on, turn off, measure time. Plus I don&#x27;t like modules as they seem pointless complexity when I just want to order a ready-assembled, self-designed PCB.</div><br/><div id="40650045" class="c"><input type="checkbox" id="c-40650045" checked=""/><div class="controls bullet"><span class="by">_Microft</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40648603">parent</a><span>|</span><a href="#40648938">next</a><span>|</span><label class="collapse" for="c-40650045">[-]</label><label class="expand" for="c-40650045">[3 more]</label></div><br/><div class="children"><div class="content">I also did not understand this complaint. On a Pico, any GPIO can be used for touch (using PIO of course).<p>Example with 23 touch buttons if I counted that correctly:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;todbot&#x2F;picotouch">https:&#x2F;&#x2F;github.com&#x2F;todbot&#x2F;picotouch</a></div><br/><div id="40651092" class="c"><input type="checkbox" id="c-40651092" checked=""/><div class="controls bullet"><span class="by">peteforde</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40650045">parent</a><span>|</span><a href="#40648938">next</a><span>|</span><label class="collapse" for="c-40651092">[-]</label><label class="expand" for="c-40651092">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for this! I am happy to have been wrong about the touch stuff, because I&#x27;m learning a lot.</div><br/><div id="40651205" class="c"><input type="checkbox" id="c-40651205" checked=""/><div class="controls bullet"><span class="by">_Microft</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40651092">parent</a><span>|</span><a href="#40648938">next</a><span>|</span><label class="collapse" for="c-40651205">[-]</label><label class="expand" for="c-40651205">[1 more]</label></div><br/><div class="children"><div class="content">The same user has also got a board with touch sliders, consisting of inversely tapering touch areas that allow to compute the touch position along the axis (same for rotary sliders that use three of these in a circle configuration).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;todbot&#x2F;picoslidertoy">https:&#x2F;&#x2F;github.com&#x2F;todbot&#x2F;picoslidertoy</a></div><br/></div></div></div></div></div></div></div></div><div id="40648938" class="c"><input type="checkbox" id="c-40648938" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40648603">prev</a><span>|</span><a href="#40650765">next</a><span>|</span><label class="collapse" for="c-40648938">[-]</label><label class="expand" for="c-40648938">[1 more]</label></div><br/><div class="children"><div class="content">I did manual capacitive touch on an ATMega328. Peripheral support is easier and more reliable, but not strictly necessary. You &quot;just&quot; need a GPIO with analog input and a timer.</div><br/></div></div><div id="40650765" class="c"><input type="checkbox" id="c-40650765" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40648938">prev</a><span>|</span><a href="#40648866">next</a><span>|</span><label class="collapse" for="c-40650765">[-]</label><label class="expand" for="c-40650765">[1 more]</label></div><br/><div class="children"><div class="content">Honestly you just don&#x27;t need platformio for programming esp32. I tried, and it was just easier to deal with esp-idf than have a middleware with its own quirks on top of esp-idf&#x27;s own quirks.</div><br/></div></div><div id="40648866" class="c"><input type="checkbox" id="c-40648866" checked=""/><div class="controls bullet"><span class="by">olabyne</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40650765">prev</a><span>|</span><a href="#40649962">next</a><span>|</span><label class="collapse" for="c-40648866">[-]</label><label class="expand" for="c-40648866">[2 more]</label></div><br/><div class="children"><div class="content">what is the drama with platformIO ?</div><br/><div id="40648887" class="c"><input type="checkbox" id="c-40648887" checked=""/><div class="controls bullet"><span class="by">peteforde</span><span>|</span><a href="#40648035">root</a><span>|</span><a href="#40648866">parent</a><span>|</span><a href="#40649962">next</a><span>|</span><label class="collapse" for="c-40648887">[-]</label><label class="expand" for="c-40648887">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;platformio&#x2F;platform-raspberrypi&#x2F;pull&#x2F;36">https:&#x2F;&#x2F;github.com&#x2F;platformio&#x2F;platform-raspberrypi&#x2F;pull&#x2F;36</a></div><br/></div></div></div></div><div id="40649962" class="c"><input type="checkbox" id="c-40649962" checked=""/><div class="controls bullet"><span class="by">aswanson</span><span>|</span><a href="#40648035">parent</a><span>|</span><a href="#40648866">prev</a><span>|</span><a href="#40650266">next</a><span>|</span><label class="collapse" for="c-40649962">[-]</label><label class="expand" for="c-40649962">[1 more]</label></div><br/><div class="children"><div class="content">Pico board is the module.  I agree that placing the xtal etc is too much.</div><br/></div></div></div></div><div id="40649012" class="c"><input type="checkbox" id="c-40649012" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#40648035">prev</a><span>|</span><a href="#40646555">next</a><span>|</span><label class="collapse" for="c-40649012">[-]</label><label class="expand" for="c-40649012">[6 more]</label></div><br/><div class="children"><div class="content">I think the PIO state machines are pretty cool and relatively unique. I am also glad the Foundation resisted the temptation to market them as extra cores and sell the RP2040 as 10-core processor.<p>When it comes to the Raspi Pico and similar devices[1], I think UF2 flashing is the best thing since sliced bread.
This alone lowers the barrier for beginners significantly.<p>Things I don&#x27;t like: power consumption.<p>But you can&#x27;t have everything...<p>[1] I know it is not restricted to RP2040 boards, but I think it is nowhere as common as there.</div><br/><div id="40649139" class="c"><input type="checkbox" id="c-40649139" checked=""/><div class="controls bullet"><span class="by">mdp2021</span><span>|</span><a href="#40649012">parent</a><span>|</span><a href="#40646555">next</a><span>|</span><label class="collapse" for="c-40649139">[-]</label><label class="expand" for="c-40649139">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Things I don&#x27;t like: power consumption</i><p>I understand it could use ~0.08W, given it draws 3.3V at ~24mA... I am not a specialist, is that a lot?<p>Ref.: <a href="https:&#x2F;&#x2F;learn.sparkfun.com&#x2F;tutorials&#x2F;rp2040-thing-plus-hookup-guide&#x2F;all" rel="nofollow">https:&#x2F;&#x2F;learn.sparkfun.com&#x2F;tutorials&#x2F;rp2040-thing-plus-hooku...</a></div><br/><div id="40649257" class="c"><input type="checkbox" id="c-40649257" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40649012">root</a><span>|</span><a href="#40649139">parent</a><span>|</span><a href="#40649496">next</a><span>|</span><label class="collapse" for="c-40649257">[-]</label><label class="expand" for="c-40649257">[1 more]</label></div><br/><div class="children"><div class="content">TI&#x27;s MSPM0G350x (also a low-cost Cortex-M0+ design) runs full-tilt at 8mA, STOP-sleeps at 400uA, STANDBY-sleeps at 5uA, and SHUTDOWN-sleeps at 80nA.<p><a href="https:&#x2F;&#x2F;www.ti.com&#x2F;lit&#x2F;ds&#x2F;symlink&#x2F;mspm0g3507-q1.pdf" rel="nofollow">https:&#x2F;&#x2F;www.ti.com&#x2F;lit&#x2F;ds&#x2F;symlink&#x2F;mspm0g3507-q1.pdf</a><p>--------<p>RP2040&#x27;s full-speed is okay. 20+mA is a lot but it is easily explained by the absurdly huge SRAM banks it has.<p>But RP2040&#x27;s sleep states are absolutely AWFUL. The Cortex-M0+ chips are all extremely power-competitive vs each other, because Cortex-M0+ is extremely low-end with regards to core-design.<p>You&#x27;re pretty much only getting a Cortex-M0+ because its the absolute minimum 32-bit processor on the market. (8-bitters and 4-bitters exist if you&#x27;re willing to go even lower-end, but Cortex-M0+ is the bottom of ARM&#x27;s offerings). So low-power seems to be a must in this market, IMO anyway.<p>If you&#x27;re willing to use higher amounts of power, you really should get a few more features, like an FPU on the Cortex-M4.</div><br/></div></div><div id="40649496" class="c"><input type="checkbox" id="c-40649496" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#40649012">root</a><span>|</span><a href="#40649139">parent</a><span>|</span><a href="#40649257">prev</a><span>|</span><a href="#40650533">next</a><span>|</span><label class="collapse" for="c-40649496">[-]</label><label class="expand" for="c-40649496">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it&#x27;s a lot. It will empty a 1000mAh battery in about two days. In sleep states, you&#x27;ll find it challenging to reach a single month on RP2040 while you can build things with other controllers that would last years on the same battery.</div><br/></div></div><div id="40650533" class="c"><input type="checkbox" id="c-40650533" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40649012">root</a><span>|</span><a href="#40649139">parent</a><span>|</span><a href="#40649496">prev</a><span>|</span><a href="#40652750">next</a><span>|</span><label class="collapse" for="c-40650533">[-]</label><label class="expand" for="c-40650533">[1 more]</label></div><br/><div class="children"><div class="content">The main issue is that there&#x27;s no low power sleep mode. There are sleep modes, but they consume tremendous amount of power, so there&#x27;s no way to build a battery-powered device.</div><br/></div></div><div id="40652750" class="c"><input type="checkbox" id="c-40652750" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#40649012">root</a><span>|</span><a href="#40649139">parent</a><span>|</span><a href="#40650533">prev</a><span>|</span><a href="#40646555">next</a><span>|</span><label class="collapse" for="c-40652750">[-]</label><label class="expand" for="c-40652750">[1 more]</label></div><br/><div class="children"><div class="content">Ambiq Apollo4s run at &lt;1mA from RAM.<p>Lots of variables go into this figure, but 24mA isn&#x27;t great.</div><br/></div></div></div></div></div></div><div id="40646555" class="c"><input type="checkbox" id="c-40646555" checked=""/><div class="controls bullet"><span class="by">HyulianGrader</span><span>|</span><a href="#40649012">prev</a><span>|</span><a href="#40647032">next</a><span>|</span><label class="collapse" for="c-40646555">[-]</label><label class="expand" for="c-40646555">[7 more]</label></div><br/><div class="children"><div class="content">nit: There are 6 different espressif microcontrollers in that table, not &quot;dozens&quot;.<p>Espressif also went many years with only the ESP8266, then many years more after introducing the ESP32 before this recent binge of releasing a new series every time they blink. ESP-IDF is really suffering for it, so I hope Raspberry avoid this fate or at least find a better way to support them all.</div><br/><div id="40647809" class="c"><input type="checkbox" id="c-40647809" checked=""/><div class="controls bullet"><span class="by">rdlw</span><span>|</span><a href="#40646555">parent</a><span>|</span><a href="#40646778">next</a><span>|</span><label class="collapse" for="c-40647809">[-]</label><label class="expand" for="c-40647809">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;products.espressif.com&#x2F;#&#x2F;product-selector?language=en&amp;names=" rel="nofollow">https:&#x2F;&#x2F;products.espressif.com&#x2F;#&#x2F;product-selector?language=e...</a><p>This is the official Espressif &quot;ESP Product Selector&quot;. I checked everything in the ESP series, and limited to &quot;Mass Production&quot; status, and then it showed me a list of 175 products.<p>I&#x27;m sure some of those are doubled up, or just the same chip with different packaging options or whatever, but as a potential customer I&#x27;m still presented with 175 things and told to pick one.</div><br/><div id="40649134" class="c"><input type="checkbox" id="c-40649134" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40646555">root</a><span>|</span><a href="#40647809">parent</a><span>|</span><a href="#40646778">next</a><span>|</span><label class="collapse" for="c-40649134">[-]</label><label class="expand" for="c-40649134">[1 more]</label></div><br/><div class="children"><div class="content">Most of that are not bare microcontrollers (or âSoCâs as Espressif calls it), but entire modules with different combinations of SoC, Flash, PSRAM, antenna configuration and packaging. If you filter only SoCs, you get 39 products, which in fact are 9 different chips and rest are packaging variants and versions with package-on-package Flash.</div><br/></div></div></div></div><div id="40646778" class="c"><input type="checkbox" id="c-40646778" checked=""/><div class="controls bullet"><span class="by">em3rgent0rdr</span><span>|</span><a href="#40646555">parent</a><span>|</span><a href="#40647809">prev</a><span>|</span><a href="#40650778">next</a><span>|</span><label class="collapse" for="c-40646778">[-]</label><label class="expand" for="c-40646778">[1 more]</label></div><br/><div class="children"><div class="content">Considering how many different Raspberry Pis are out there now, I wouldn&#x27;t be surprised if the Raspberry Foundation makes a plethora of newer microcontrollers.</div><br/></div></div><div id="40650778" class="c"><input type="checkbox" id="c-40650778" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#40646555">parent</a><span>|</span><a href="#40646778">prev</a><span>|</span><a href="#40647865">next</a><span>|</span><label class="collapse" for="c-40650778">[-]</label><label class="expand" for="c-40650778">[2 more]</label></div><br/><div class="children"><div class="content">How is ESP-IDF &quot;suffering for it&quot;?</div><br/><div id="40653908" class="c"><input type="checkbox" id="c-40653908" checked=""/><div class="controls bullet"><span class="by">HyulianGrader</span><span>|</span><a href="#40646555">root</a><span>|</span><a href="#40650778">parent</a><span>|</span><a href="#40647865">next</a><span>|</span><label class="collapse" for="c-40653908">[-]</label><label class="expand" for="c-40653908">[1 more]</label></div><br/><div class="children"><div class="content">Complexity. It&#x27;s now playing catch up trying to support all of these different chips with all of these different peripherals, capabilities, and errata in quick succession.<p>As a developer, it&#x27;s much more difficult to navigate when there are 8 files with the same name, 5 registers with the same name defined in different files, etc. A lot of code is heavily punctuated by ifdefs to selectively include and exclude lines for different targets, making it more difficult to follow. Intellisense struggles, no matter how well it&#x27;s configured.<p>I could deal with all that but it&#x27;s the runtime cost that is the worst. ESP-IDF is constantly getting bigger and slower. All of these abstractions, structs half-full of pointers being handed about at runtime, dead code being linked in for features the chip doesn&#x27;t even support, it all has a cost.<p>This is even worse in binary blobs where conditional compilation is more difficult to do. I&#x27;m not convinced they&#x27;re even trying though. A single commit that only mentioned WiFi 6 changes increased my binary size by over 10kB. <i>On a chip that doesn&#x27;t support WiFi 6.</i></div><br/></div></div></div></div><div id="40647865" class="c"><input type="checkbox" id="c-40647865" checked=""/><div class="controls bullet"><span class="by">ajsnigrutin</span><span>|</span><a href="#40646555">parent</a><span>|</span><a href="#40650778">prev</a><span>|</span><a href="#40647032">next</a><span>|</span><label class="collapse" for="c-40647865">[-]</label><label class="expand" for="c-40647865">[1 more]</label></div><br/><div class="children"><div class="content">Many of the variants listed are the same chip but with different amounts of storage, oboard vs external (vs both) options, etc.</div><br/></div></div></div></div><div id="40647032" class="c"><input type="checkbox" id="c-40647032" checked=""/><div class="controls bullet"><span class="by">djfergus</span><span>|</span><a href="#40646555">prev</a><span>|</span><a href="#40646632">next</a><span>|</span><label class="collapse" for="c-40647032">[-]</label><label class="expand" for="c-40647032">[1 more]</label></div><br/><div class="children"><div class="content">For hobbists buying dev boards note that an ESP32 comes with WiFi and maybe Bluetooth depending on the model, whereas a vanilla Pi Pico has no radio - you need a Pi Pico W for that, which in my experience is double the cost of an esp32 board.<p>I agree with the authors points that the RP2040 is a great chip would love to see the Pico W pricing come down as popularity grows.</div><br/></div></div><div id="40646632" class="c"><input type="checkbox" id="c-40646632" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#40647032">prev</a><span>|</span><a href="#40646454">next</a><span>|</span><label class="collapse" for="c-40646632">[-]</label><label class="expand" for="c-40646632">[31 more]</label></div><br/><div class="children"><div class="content">How are people using this in practice?<p>Iâve never worked with a BGA device. Iâm guessing you need to design a board send it to say pcbway and then have the equipment to solder the bga in?</div><br/><div id="40647553" class="c"><input type="checkbox" id="c-40647553" checked=""/><div class="controls bullet"><span class="by">dave78</span><span>|</span><a href="#40646632">parent</a><span>|</span><a href="#40648368">next</a><span>|</span><label class="collapse" for="c-40647553">[-]</label><label class="expand" for="c-40647553">[6 more]</label></div><br/><div class="children"><div class="content">I built a custom RP2040-based board by designing it KiCad and then sending it off to JLCPCB to be fabbed and they assembled the SMT components. I didn&#x27;t do a direct comparison, but it was cheap - cheap enough that it&#x27;s possible that getting the board pre-assembled from JLC was cheaper than buying the raw parts in low quantities from Digikey and assembling it myself (which, given my experience level, would be pushing the edge of my capabilities). I made a second run recently and even added some through-hole to the assembly and the board cost was still single digit dollars per board. The major problem was that shipping prices from JLC seem to have gone up significantly in the past year.<p>Keep in mind that it&#x27;s not just the RP2040 that is difficult to solder. To do a decent PCB layout you&#x27;ll need to use very small passives in order to get the placement right. I did my layout with mostly 0402 resistors and capacitors - I know plenty of people are capable of hand-soldering those but I think it would be difficult for most. Perhaps easier if you had a decent microscope, which I do not have yet. I don&#x27;t think my magnifying visor would be nearly enough.</div><br/><div id="40649062" class="c"><input type="checkbox" id="c-40649062" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40647553">parent</a><span>|</span><a href="#40648368">next</a><span>|</span><label class="collapse" for="c-40649062">[-]</label><label class="expand" for="c-40649062">[5 more]</label></div><br/><div class="children"><div class="content">&gt; To do a decent PCB layout you&#x27;ll need to use very small passives in order to get the placement right.<p>0402 (inches) is small but doable. They really start to feel like grains of sand at that point.<p>But I personally stick with 0805 and 0603 when doing my own board layouts. I can&#x27;t say I&#x27;ve ever felt space constrained. The placement of decoupling capacitors can be a few mil off, and in fact the &quot;extra space&quot; for placement helps your tweezers anyway, so you don&#x27;t really want to push everything so close together.<p>Especially for hobby projects, I don&#x27;t think anyone is really in the business of counting up the savings of 0.01&quot; in the hobby world. Like, how small are you actually aiming for, and is it really so bad that you can&#x27;t add another 0.5&quot; to your board?<p>--------<p>Professionals use 0201 (inches) for maximum flexibility and minimal sizes. So even 0402 is larger than professional projects. If we&#x27;re all accepting &quot;larger hobbyist sizes&quot; anyway, might as well go all the way up to the much easier 0603 or 0805 parts.<p>While a 0402 is slightly larger than a grain of sand, I&#x27;d say 0805 is approximately the size of a grain of rice. So yeah, doable with tweezers and solder paste. Just imagine lining up dry rice and its well within the capabilities of most hobbyists.<p>Its just problematic when you get smaller than that.</div><br/><div id="40649471" class="c"><input type="checkbox" id="c-40649471" checked=""/><div class="controls bullet"><span class="by">dave78</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40649062">parent</a><span>|</span><a href="#40648368">next</a><span>|</span><label class="collapse" for="c-40649471">[-]</label><label class="expand" for="c-40649471">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Especially for hobby projects, I don&#x27;t think anyone is really in the business of counting up the savings of 0.01&quot; in the hobby world. Like, how small are you actually aiming for, and is it really so bad that you can&#x27;t add another 0.5&quot; to your board?<p>It&#x27;s not really about saving board space. Decoupling capacitors need to be placed &quot;close&quot; to the chip, and at higher clock frequencies this can be an issue. There&#x27;s enough decoupling caps needed on a RP2040 that doing them in 0805 would require moving them quite a bit further away from the chip just to have room to place them all.<p>An ATmega (Arduino) at something like 8MHz is really forgiving and you can take a lot of liberties with the layout. The RP2040 runs much faster at 133MHz, so presumably the tolerances are much tighter. Admittedly, I didn&#x27;t try a doing a design with 0805s for the RP2040 but I read enough from people more experienced than me that gave me the impression that compromising the layout with larger passives had a greater chance of things not working right.<p>Since assembly is so cheap at places like JLC these days, even in small quantities, it really wasn&#x27;t worth the hassle. I&#x27;ve done many other boards by hand with 0805s and and agree they&#x27;re pretty easy to deal with.</div><br/><div id="40650260" class="c"><input type="checkbox" id="c-40650260" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40649471">parent</a><span>|</span><a href="#40648368">next</a><span>|</span><label class="collapse" for="c-40650260">[-]</label><label class="expand" for="c-40650260">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Decoupling capacitors need to be placed &quot;close&quot; to the chip<p>All of these rules are just rules of thumb.<p>The &quot;rule&quot; is that your Power Delivery Network (PDN) needs to have low-enough impedance to function properly. High parallel capacitance and low series inductance&#x2F;resistance. Longer leads increases inductance and resistance so closer is preferred.<p>But for even 100MHz designs, you&#x27;re well under the size where 100mil or 0805 would cause any serious problem.<p>-------------<p>So the &quot;secret&quot; is that all faster designs (100MHz to 300MHz) have substantial on-package capacitance.<p>Take a look at this design, which I admit is Microchip&#x2F;Atmel MCU, but its running at 300MHz and not just the relatively low 133MHz of the RP2040.<p><a href="https:&#x2F;&#x2F;lcamtuf.coredump.cx&#x2F;bob-the-cat&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lcamtuf.coredump.cx&#x2F;bob-the-cat&#x2F;</a><p>Those are LARGE 1206 1uF capacitors. Which is actually scary to me because we&#x27;re not looking at tight 100nF decoupling caps anymore but instead substantially relying upon &quot;on-package&quot; capacitance.<p>Still, it shows that lcamtuf was confident in this 300MHz processor handling far-away 1206 capacitors, showing how much wiggle room we have in practice in these designs.<p>You shouldn&#x27;t worry about 100mil of movement of 0805 caps on a 133MHz design. After all, there are real designs that are closer to 500 mil that use 1206 caps on a 300MHz MCU.<p>--------<p>I&#x27;m honestly scared for lcamtuf here and would never design a board like this. But I&#x27;m really not worried about 0805 caps on relatively low speed 100MHz (or even 133MHz) MCUs. Especially if you&#x27;re properly &quot;teaming&quot; them up so that their resistances are paralleled and inductances are paralleled. (Notice that lcamtuf&#x27;s 300MHz design doesn&#x27;t even have the 10x recommended parallel 100nF capacitors close to any of the pins!! He&#x27;s really stretching the specs)<p>-----------<p>But yeah, my personal preference is majority of 0805s and 0603s for the &quot;close&quot; decoupling capacitors. I know there&#x27;s plenty of wiggle room here (even if I&#x27;m not as aggressive as lcamtuf&#x27;s designs).<p>If you&#x27;re using PCBA from another shop, I guess its all &quot;free&quot; to you to use 0402s or whatever they got loaded in their chip-shooters. So might as well take your free pre-loaded resistors. But if I&#x27;m assembling a board myself, I definitely prefer the larger size.</div><br/><div id="40650847" class="c"><input type="checkbox" id="c-40650847" checked=""/><div class="controls bullet"><span class="by">dave78</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40650260">parent</a><span>|</span><a href="#40648368">next</a><span>|</span><label class="collapse" for="c-40650847">[-]</label><label class="expand" for="c-40650847">[2 more]</label></div><br/><div class="children"><div class="content">Fair enough. I&#x27;ve taken digital logic classes etc. in college but when it comes to practical circuit design I&#x27;m mostly self-taught, having worked my way up from all through-hole components with ATmega and similar devices to dipping my toe in the SMD waters with larger TQFP parts to now doing a few designs with the RP2040. I&#x27;ve tried to educate myself on best practices and follow recommended layouts and things like that where possible, to try to learn to do things the &quot;right way&quot; - but I definitely don&#x27;t have enough experience to know when the rules of thumb can be broken or not.<p>It&#x27;s good to know that the &quot;closeness&quot; requirement of decoupling caps is perhaps not as important as I had believed.</div><br/><div id="40651278" class="c"><input type="checkbox" id="c-40651278" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40650847">parent</a><span>|</span><a href="#40648368">next</a><span>|</span><label class="collapse" for="c-40651278">[-]</label><label class="expand" for="c-40651278">[1 more]</label></div><br/><div class="children"><div class="content">The professionals use PCB-design software with physical modeling &#x2F; FEA to calculate estimates to all of the important parameters of the circuit board (including how much trace lengths matter... but also board-capacitance, resistances, and resonance frequencies of the board itself, etc. etc.)<p>In contrast, we hobbyists deal with &quot;rules of thumb&quot;, because none of us will spend $4000+ on professional PCB software that run these calculations for us. And furthermore, we aim very conservative because its very difficult to debug a PCB layout issue... as we hobbyists are functionally blind to all of these issues (ex: trace inductance, trace capacitance, or other issues).<p>I think spending a good bit of time on PDN &#x2F; grounding &#x2F; etc. etc. study is very worth your while.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ySuUZEjARPY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ySuUZEjARPY</a><p>2+ hour talk on just the issue of good &quot;grounding&quot; design in PCBs, but it does relate to this issue of capacitors, trace-lengths and the like. I feel like you&#x27;d benefit from this talk.<p>The &quot;correct&quot; way of thinking is exceptionally complex, far more complex than what is taught in colleges. But you have all the basic ideas thanks to the old rules of thumb. You just need to take the next step to see what the problems are.<p>--------<p>And as you&#x27;ll see, traces on the same side of a board are cake. Its things like vias that actually wreck you.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40648368" class="c"><input type="checkbox" id="c-40648368" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40646632">parent</a><span>|</span><a href="#40647553">prev</a><span>|</span><a href="#40646732">next</a><span>|</span><label class="collapse" for="c-40648368">[-]</label><label class="expand" for="c-40648368">[4 more]</label></div><br/><div class="children"><div class="content">RP2040 is QFN, not BGA.<p>QFN is doable at home, though more difficult than TQFP leads or larger SOIC-chips. Still, far too many components are QFN today so its a good skill to pickup.<p>------<p>The techninque is:<p>1. Reflow soldering brings the _whole_ board to soldering temperatures, and then relies upon surface-tension to pull all the devices into proper place.<p>2. Solder paste is applies ahead of time. You can cleanup solder paste with a toothpick before you bring the board up to temperature. Solder paste tends to go bad pretty quickly however. When doing prototypes, opt for the more expensive low-melt solder paste to minimize potential heat damage.<p>3. Prefer to use a stencil to apply solder paste. But its more than doable to be sloppy with a syringe and then rely upon the solder mask + surface tension to magically cleanup things during reflow temperatures.<p>4. Use a hot-air gun to fix any issues. The #1 issue you&#x27;ll have is tombstoning, QFNs or TQFP chips are usually pretty good about settling into place. For TQFP issues (ex: bridging), you&#x27;ll need solder-wick + soldering iron. EDIT: And flux: lots of flux helps. Also, flux goes bad, so throw away Flux all the time and keep buying new batches.<p>---------<p>BGA is also doable at home btw, thanks to the above principles. But its even harder than QFN. The real issue of BGAs is that you&#x27;re looking at 4-layer minimum, maybe 6, 8, or 10-layer designs. There&#x27;s also substantial grounding and other advanced PCB concepts you need before you can layout a BGA-capable PCB.<p>Its not so much the physical activity of soldering that&#x27;s hard or difficult for BGAs. Its all the theory you need to study to breakout BGAs + minimize inductance + deal with impedance matching and trace-length matching.</div><br/><div id="40649259" class="c"><input type="checkbox" id="c-40649259" checked=""/><div class="controls bullet"><span class="by">morio</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40648368">parent</a><span>|</span><a href="#40646732">next</a><span>|</span><label class="collapse" for="c-40649259">[-]</label><label class="expand" for="c-40649259">[3 more]</label></div><br/><div class="children"><div class="content">I find hand soldering QFN is faster, easier and more reliable than (T)QFP once you got enough practice. If you need to rework the QFN part the key is to FLOOD the footprint with good solder flux from a syringe. Do not use one of those flux pens, those do not dispense enough flux.</div><br/><div id="40649288" class="c"><input type="checkbox" id="c-40649288" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40649259">parent</a><span>|</span><a href="#40646732">next</a><span>|</span><label class="collapse" for="c-40649288">[-]</label><label class="expand" for="c-40649288">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you need to rework the QFN part the key is to FLOOD the footprint with good solder flux from a syringe.<p>I&#x27;ve never tried this but this makes a lot of sense in my mind&#x27;s eye. I&#x27;ll try this next time I have such an issue.<p>-------<p>TQFP seems nice because I can sloppily shove tons of solder down, and then just wick up all the excess solder with solder wick. In fact, I purposefully over-solder all the TQFP joints for this practice. (Too much solder during reflow, and then just a quick cleanup step with a soldering iron later).</div><br/><div id="40649923" class="c"><input type="checkbox" id="c-40649923" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40649288">parent</a><span>|</span><a href="#40646732">next</a><span>|</span><label class="collapse" for="c-40649923">[-]</label><label class="expand" for="c-40649923">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;ve been seeing a bunch of chip swaps that use this method, its wild how forgiving it appears to be.</div><br/></div></div></div></div></div></div></div></div><div id="40646732" class="c"><input type="checkbox" id="c-40646732" checked=""/><div class="controls bullet"><span class="by">neilo40</span><span>|</span><a href="#40646632">parent</a><span>|</span><a href="#40648368">prev</a><span>|</span><a href="#40646746">next</a><span>|</span><label class="collapse" for="c-40646732">[-]</label><label class="expand" for="c-40646732">[7 more]</label></div><br/><div class="children"><div class="content">Although it looks like BGA, it actually uses a QFN package where all the contacts are accessible at the edge.  With a little practice they are relatively easy to hand solder (I&#x27;ve done many, not just rp2040)</div><br/><div id="40647890" class="c"><input type="checkbox" id="c-40647890" checked=""/><div class="controls bullet"><span class="by">dvdkon</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40646732">parent</a><span>|</span><a href="#40648038">next</a><span>|</span><label class="collapse" for="c-40647890">[-]</label><label class="expand" for="c-40647890">[1 more]</label></div><br/><div class="children"><div class="content">QFN packages are very nice to hand-solder in my experience, considering the pitch. Better than the bridge-prone pins of QFP. The bottom pads do need some preparation, but you don&#x27;t need hot air or reflow.</div><br/></div></div><div id="40648038" class="c"><input type="checkbox" id="c-40648038" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40646732">parent</a><span>|</span><a href="#40647890">prev</a><span>|</span><a href="#40646746">next</a><span>|</span><label class="collapse" for="c-40648038">[-]</label><label class="expand" for="c-40648038">[5 more]</label></div><br/><div class="children"><div class="content">i admit to being intimidated by qfns still. any tips for hand-soldering them successfully?</div><br/><div id="40649203" class="c"><input type="checkbox" id="c-40649203" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40648038">parent</a><span>|</span><a href="#40646746">next</a><span>|</span><label class="collapse" for="c-40649203">[-]</label><label class="expand" for="c-40649203">[4 more]</label></div><br/><div class="children"><div class="content">Kind of cheating trick for the QFN substrate pad is to put a grid of somewhat higher diameter vias in there  and solder the pad from the other side of the board through these vias. Another approach is to just ignore the substrate pad altogether (in many devices it should not be connected to anything anyway and has no real thermal management purpose).</div><br/><div id="40649293" class="c"><input type="checkbox" id="c-40649293" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40649203">parent</a><span>|</span><a href="#40646746">next</a><span>|</span><label class="collapse" for="c-40649293">[-]</label><label class="expand" for="c-40649293">[3 more]</label></div><br/><div class="children"><div class="content">i wonder if you could use the vias trick for the regular pins too, and bga balls</div><br/><div id="40649567" class="c"><input type="checkbox" id="c-40649567" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40649293">parent</a><span>|</span><a href="#40646746">next</a><span>|</span><label class="collapse" for="c-40649567">[-]</label><label class="expand" for="c-40649567">[2 more]</label></div><br/><div class="children"><div class="content">I have in fact seen the via trick used for 50mil pitch BGAs, but cannot remember where. I even vaguely recollect some board where that was used for CGA, which seems like really ridiculous idea (you don&#x27;t use CGA packages and then invent some weird kludge pseudo-process).</div><br/><div id="40649878" class="c"><input type="checkbox" id="c-40649878" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40649567">parent</a><span>|</span><a href="#40646746">next</a><span>|</span><label class="collapse" for="c-40649878">[-]</label><label class="expand" for="c-40649878">[1 more]</label></div><br/><div class="children"><div class="content">wow, i&#x27;d never even heard of cgas</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40646746" class="c"><input type="checkbox" id="c-40646746" checked=""/><div class="controls bullet"><span class="by">GlibMonkeyDeath</span><span>|</span><a href="#40646632">parent</a><span>|</span><a href="#40646732">prev</a><span>|</span><a href="#40647858">next</a><span>|</span><label class="collapse" for="c-40646746">[-]</label><label class="expand" for="c-40646746">[1 more]</label></div><br/><div class="children"><div class="content">Almost universally a hobbyist would purchase the RP2040 mounted to a pcb with other i&#x2F;o components (e.g. the Seeeduino Xiao <a href="https:&#x2F;&#x2F;wiki.seeedstudio.com&#x2F;XIAO-RP2040&#x2F;" rel="nofollow">https:&#x2F;&#x2F;wiki.seeedstudio.com&#x2F;XIAO-RP2040&#x2F;</a>) There are other versions which bring out more lines to accessible solder points.<p>Of course you can design your own custom board, but I&#x27;d wager most people don&#x27;t need or want to do this.</div><br/></div></div><div id="40647858" class="c"><input type="checkbox" id="c-40647858" checked=""/><div class="controls bullet"><span class="by">floxy</span><span>|</span><a href="#40646632">parent</a><span>|</span><a href="#40646746">prev</a><span>|</span><a href="#40647950">next</a><span>|</span><label class="collapse" for="c-40647858">[-]</label><label class="expand" for="c-40647858">[5 more]</label></div><br/><div class="children"><div class="content">You would probably be surprised what you can do with a $65 hot plate [0], no-refrigeration-required solder paste[1] and the matching laser-cut solder stencil[2].<p>[0] -- <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Soiiw-Microcomputer-Soldering-Preheating-200X200mm&#x2F;dp&#x2F;B082H12PPT&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Soiiw-Microcomputer-Soldering-Preheat...</a><p>[1] -- <a href="https:&#x2F;&#x2F;www.chipquik.com&#x2F;store&#x2F;index.php?cPath=470&amp;osCsid=8tbpu9sk2vibcv4tt05fcevrm7" rel="nofollow">https:&#x2F;&#x2F;www.chipquik.com&#x2F;store&#x2F;index.php?cPath=470&amp;osCsid=8t...</a><p>[2] -- <a href="https:&#x2F;&#x2F;www.pololu.com&#x2F;product&#x2F;446&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.pololu.com&#x2F;product&#x2F;446&#x2F;</a></div><br/><div id="40648345" class="c"><input type="checkbox" id="c-40648345" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40647858">parent</a><span>|</span><a href="#40647950">next</a><span>|</span><label class="collapse" for="c-40648345">[-]</label><label class="expand" for="c-40648345">[4 more]</label></div><br/><div class="children"><div class="content">Pololu&#x27;s stencils leave much to be desired. They do work but I feel like <a href="https:&#x2F;&#x2F;www.oshstencils.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oshstencils.com&#x2F;</a> makes a higher quality stencil instead at similar prices.<p>-----<p>Note that BGA chips mostly come pre-soldered &#x2F; solder balls. You also design PCBs so that there is a &quot;well&quot; for the balls to melt into and settle into place, and molten-solder has a significant amount of surface tension, so you can magically watch the solder &quot;pull&quot; your designs into place. Of course, the OP is likely talking about QFN not BGA, but... just in case people are worried about BGAs its not terrible... (its just impossible to inspect a BGA XRays).<p>The surface-tension can be harmful in the case of tombstoning (ex: a resistor or capacitor with two leads, especially a &quot;sideways&quot; low-inductance capacitor, will get &quot;pulled up&quot; by one side, lifting off the 2nd pad).<p>If you have a solder-plate + hot-gun, you can &quot;feel&quot; the surface tension by just grabbing a toothpick and pushing on these components as they&#x27;re still hot. You&#x27;ll find the pressure to be far higher than you expect.</div><br/><div id="40648961" class="c"><input type="checkbox" id="c-40648961" checked=""/><div class="controls bullet"><span class="by">floxy</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40648345">parent</a><span>|</span><a href="#40647950">next</a><span>|</span><label class="collapse" for="c-40648961">[-]</label><label class="expand" for="c-40648961">[3 more]</label></div><br/><div class="children"><div class="content">Funny, I had the exact opposite experience.  For OSH Stencils, they had a scaling issue with their setup that I pointed out to them, and they just shrugged and said that was the nature of the beast essentially and they couldn&#x27;t do anything about it.  They might have said something about Kapton shrinkage or some such.  (I don&#x27;t currently have the exact numbers, but it was off a couple of percent linearly, which doesn&#x27;t matter for a tiny board, but for a 4&quot; board, the difference adds up, so that if you align the apertures on one end of the board, they don&#x27;t on the other side of the board.  Like the aperture was off by a whole 0603 pad or more).  I went back to Pololu for that same board, and everything was spot on.  And I have had zero complaints with them since.  If I had to complain about something, I might slightly ding them slightly on the super-tiny aperture shapes and the kerf width of their laser.  But everything has always worked.  Apparently YMMV.</div><br/><div id="40648999" class="c"><input type="checkbox" id="c-40648999" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40648961">parent</a><span>|</span><a href="#40647950">next</a><span>|</span><label class="collapse" for="c-40648999">[-]</label><label class="expand" for="c-40648999">[2 more]</label></div><br/><div class="children"><div class="content">Hmmm, maybe my designs have been small enough that it hasn&#x27;t been an issue.<p>I&#x27;ll keep your experience in mind then. Thanks for sharing your experience.</div><br/><div id="40652870" class="c"><input type="checkbox" id="c-40652870" checked=""/><div class="controls bullet"><span class="by">floxy</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40648999">parent</a><span>|</span><a href="#40647950">next</a><span>|</span><label class="collapse" for="c-40652870">[-]</label><label class="expand" for="c-40652870">[1 more]</label></div><br/><div class="children"><div class="content">Who knows, it may be fixed by now.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40647950" class="c"><input type="checkbox" id="c-40647950" checked=""/><div class="controls bullet"><span class="by">botdan</span><span>|</span><a href="#40646632">parent</a><span>|</span><a href="#40647858">prev</a><span>|</span><a href="#40646701">next</a><span>|</span><label class="collapse" for="c-40647950">[-]</label><label class="expand" for="c-40647950">[2 more]</label></div><br/><div class="children"><div class="content">Just in case you were unaware, the RP2040 is available on dozens of ready-made, arduino-compatible boards like the Pi Pico, the Adafruit feather boards, of the Seeed XIAO RP2040 boards. Those have all (or at least most) of the IO already mapped to pins, USB headers, booatloaders, reset buttons, etc already mapped.<p>Things like the Pico are really easy to solder onto a designed PCB as well because of the castellations, so it&#x27;s easy enough to design a board around the footprint and then just solder the entire pico onto your PCB with a soldering iron, avoiding the need to use something like a hot-plate or reflow oven. This has been my preferred way of working with it.</div><br/><div id="40650217" class="c"><input type="checkbox" id="c-40650217" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40647950">parent</a><span>|</span><a href="#40646701">next</a><span>|</span><label class="collapse" for="c-40650217">[-]</label><label class="expand" for="c-40650217">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;ve got a variety of dev boards already, but thought moving away from that as part of a move to PCBs might make sense. Esp given the cost diff - raw rp2040 seems to be at least 1&#x2F;5 of the dev boards. Dev boards are probably the better deal overall, but also less scope for learning</div><br/></div></div></div></div><div id="40646701" class="c"><input type="checkbox" id="c-40646701" checked=""/><div class="controls bullet"><span class="by">eulgro</span><span>|</span><a href="#40646632">parent</a><span>|</span><a href="#40647950">prev</a><span>|</span><a href="#40646805">next</a><span>|</span><label class="collapse" for="c-40646701">[-]</label><label class="expand" for="c-40646701">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a BGA, it&#x27;s a QFN with a ground pad.</div><br/><div id="40648101" class="c"><input type="checkbox" id="c-40648101" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40646701">parent</a><span>|</span><a href="#40646805">next</a><span>|</span><label class="collapse" for="c-40648101">[-]</label><label class="expand" for="c-40648101">[2 more]</label></div><br/><div class="children"><div class="content">I see. What does that change in terms of process needed?</div><br/><div id="40648262" class="c"><input type="checkbox" id="c-40648262" checked=""/><div class="controls bullet"><span class="by">a1o</span><span>|</span><a href="#40646632">root</a><span>|</span><a href="#40648101">parent</a><span>|</span><a href="#40646805">next</a><span>|</span><label class="collapse" for="c-40648262">[-]</label><label class="expand" for="c-40648262">[1 more]</label></div><br/><div class="children"><div class="content">BGA you need hot air and reflow but a QFN I think you can just position and solder by the side with a simple solder iron with a knife like tip.</div><br/></div></div></div></div></div></div><div id="40646805" class="c"><input type="checkbox" id="c-40646805" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#40646632">parent</a><span>|</span><a href="#40646701">prev</a><span>|</span><a href="#40647893">next</a><span>|</span><label class="collapse" for="c-40646805">[-]</label><label class="expand" for="c-40646805">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the desired approach, yes, but... hot take incoming!<p>I think BGAs are easier to &quot;hand&quot; solder than other footprints (QFP, QFN etc). You drop the item in place, place it on a hot plate and or heat gun, and start melting it. Of course, if you screw it up, you are screwed. (Reballing sounds not worth it for most cases). And, you can&#x27;t visually inspect.<p>I think this is because, at least for me, most of the soldering faults I have are due to uneven application, or improper amount of solder. BGA solves this.</div><br/></div></div></div></div><div id="40646454" class="c"><input type="checkbox" id="c-40646454" checked=""/><div class="controls bullet"><span class="by">cide1</span><span>|</span><a href="#40646632">prev</a><span>|</span><a href="#40650498">next</a><span>|</span><label class="collapse" for="c-40646454">[-]</label><label class="expand" for="c-40646454">[8 more]</label></div><br/><div class="children"><div class="content">The lack of security features really limits where this can be used in commercial designs.</div><br/><div id="40646638" class="c"><input type="checkbox" id="c-40646638" checked=""/><div class="controls bullet"><span class="by">ndiddy</span><span>|</span><a href="#40646454">parent</a><span>|</span><a href="#40646529">next</a><span>|</span><label class="collapse" for="c-40646638">[-]</label><label class="expand" for="c-40646638">[2 more]</label></div><br/><div class="children"><div class="content">In general, read-out protection provides a very limited level of protection that I wouldn&#x27;t rely on to stop cloning. There&#x27;s quite a few firms that will extract the firmware from protected microcontrollers for a couple thousand dollars (i.e. <a href="https:&#x2F;&#x2F;russiansemiresearch.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;russiansemiresearch.com&#x2F;</a> ) which is a drop in the bucket considering the potential profit from industrialized cloning. Lots of microcontroller series also have exploits that can allow hobbyists with very little funding to bypass read-out protection (here&#x27;s one for the STM32F0 series for example: <a href="https:&#x2F;&#x2F;github.com&#x2F;racerxdl&#x2F;stm32f0-pico-dump">https:&#x2F;&#x2F;github.com&#x2F;racerxdl&#x2F;stm32f0-pico-dump</a> ).</div><br/><div id="40652769" class="c"><input type="checkbox" id="c-40652769" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#40646454">root</a><span>|</span><a href="#40646638">parent</a><span>|</span><a href="#40646529">next</a><span>|</span><label class="collapse" for="c-40652769">[-]</label><label class="expand" for="c-40652769">[1 more]</label></div><br/><div class="children"><div class="content">Crypto key storage fuses and high-assurance boot are often more important than readout protection.</div><br/></div></div></div></div><div id="40646529" class="c"><input type="checkbox" id="c-40646529" checked=""/><div class="controls bullet"><span class="by">hitekker</span><span>|</span><a href="#40646454">parent</a><span>|</span><a href="#40646638">prev</a><span>|</span><a href="#40646836">next</a><span>|</span><label class="collapse" for="c-40646529">[-]</label><label class="expand" for="c-40646529">[4 more]</label></div><br/><div class="children"><div class="content">Can you explain how? Genuinely curious. The author only refers to &quot;security theater&quot; which seems to be when a product or system around a product makes people feel like they&#x27;re safer, when actually it&#x27;s not making anything more safer or more secure.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Security_theater" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Security_theater</a></div><br/><div id="40646730" class="c"><input type="checkbox" id="c-40646730" checked=""/><div class="controls bullet"><span class="by">kj4ips</span><span>|</span><a href="#40646454">root</a><span>|</span><a href="#40646529">parent</a><span>|</span><a href="#40646836">next</a><span>|</span><label class="collapse" for="c-40646730">[-]</label><label class="expand" for="c-40646730">[3 more]</label></div><br/><div class="children"><div class="content">I suspect this mostly refers to &quot;Code Protect&quot; or similar functions, that are designed to stop the user for extracting the firmware from a device in the field. Typically, when this is enabled, large parts of the debug interface stop working, and turning it off requires a &quot;secure&quot; erase, that clears the loaded firmware.<p>While many CP implementations are flawed, or can be bypassed by a skilled attacker (power glitching, &amp;c), I wouldn&#x27;t say they are purely theater, as they raise the required investment from a &lt;$10 ISP to $$$+ for something like a chipwhisperer.</div><br/><div id="40646863" class="c"><input type="checkbox" id="c-40646863" checked=""/><div class="controls bullet"><span class="by">relaxing</span><span>|</span><a href="#40646454">root</a><span>|</span><a href="#40646730">parent</a><span>|</span><a href="#40646836">next</a><span>|</span><label class="collapse" for="c-40646863">[-]</label><label class="expand" for="c-40646863">[2 more]</label></div><br/><div class="children"><div class="content">Consider that in other fields of computer security we treat a device where attackers have physical access to be de facto compromised.</div><br/><div id="40647755" class="c"><input type="checkbox" id="c-40647755" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#40646454">root</a><span>|</span><a href="#40646863">parent</a><span>|</span><a href="#40646836">next</a><span>|</span><label class="collapse" for="c-40647755">[-]</label><label class="expand" for="c-40647755">[1 more]</label></div><br/><div class="children"><div class="content">Even with chip security features this is still the case (if an attacker gets their hands on it it can be compromised).  There&#x27;s no chip that exists that I&#x27;m aware of that can&#x27;t be compromised to have its firmware dumped.<p>It&#x27;s like locks:  Every time a manufacture claims to have made an unpickable lock someone goes and picks it.  It&#x27;s the same for chip security features.<p>Microcontroller &quot;security&quot; features really are security theater and not actual security.  The only <i>real</i> reason they exist is because certain vendors&#x2F;&quot;big buyers&quot; will require it as part of their parts checklists (which is silly) and it provides a way for chip manufacturers to wriggle more money out of each sale.</div><br/></div></div></div></div></div></div></div></div><div id="40646836" class="c"><input type="checkbox" id="c-40646836" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#40646454">parent</a><span>|</span><a href="#40646529">prev</a><span>|</span><a href="#40650498">next</a><span>|</span><label class="collapse" for="c-40646836">[-]</label><label class="expand" for="c-40646836">[1 more]</label></div><br/><div class="children"><div class="content">I suspect the use cases where MCU security features are useful is dwarfed by those that are not.</div><br/></div></div></div></div><div id="40650498" class="c"><input type="checkbox" id="c-40650498" checked=""/><div class="controls bullet"><span class="by">ta988</span><span>|</span><a href="#40646454">prev</a><span>|</span><a href="#40655070">next</a><span>|</span><label class="collapse" for="c-40650498">[-]</label><label class="expand" for="c-40650498">[1 more]</label></div><br/><div class="children"><div class="content">Posted yesterday, info about the successor to the RP2040: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40642268">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40642268</a></div><br/></div></div><div id="40655070" class="c"><input type="checkbox" id="c-40655070" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40650498">prev</a><span>|</span><a href="#40646944">next</a><span>|</span><label class="collapse" for="c-40655070">[-]</label><label class="expand" for="c-40655070">[1 more]</label></div><br/><div class="children"><div class="content">Dreaming about a smaller, lower-power yet faster RISC-V CPU (many cores exist that are strong against cortex-M0+) with the RP2040&#x27;s peripherals.</div><br/></div></div><div id="40646944" class="c"><input type="checkbox" id="c-40646944" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40655070">prev</a><span>|</span><a href="#40646474">next</a><span>|</span><label class="collapse" for="c-40646944">[-]</label><label class="expand" for="c-40646944">[23 more]</label></div><br/><div class="children"><div class="content">The lack of built-in flash kills it for me. STM32 M3s with comparable throughput are cheaper <i>and</i> don&#x27;t require an external flash chip (example: STM32F103C8T6 for $1.20 from jlc).<p>I love the generic PIO though, I really hope other manufacturers pick up on that.</div><br/><div id="40648277" class="c"><input type="checkbox" id="c-40648277" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#40646944">parent</a><span>|</span><a href="#40647218">next</a><span>|</span><label class="collapse" for="c-40648277">[-]</label><label class="expand" for="c-40648277">[5 more]</label></div><br/><div class="children"><div class="content">I used to have the same beliefs but the <i>flexibility</i> of being able to use just about any pin for any purpose really sold me on the RP2040.  When I decide to add a new feature to my boards I don&#x27;t have to spend an hour examining the minutiae of the data sheet to see if I can use a given pin for SPI (oops: no, I can&#x27;t because I enabled alternate function 3...).  It saves a TON of track routing time and simplifies boards considerably.<p>Once I decided to start using the RP2040 I realized the &quot;strange&quot; flash situation turned into a feature, not a drawback!  With STM32 you pick your part and then you can order an expensive version (if it&#x27;s available!) with the max RAM of say, 512Kb or you can save a few bucks and go with say, 64Kb.  Either way you&#x27;re paying like $2.50-4 for a single chip.<p>Now compare that with the super fast, dual-core RP2040 which costs $1 (yeah it&#x27;s technically $0.70 in bulk) paired with a 16 FUCKING MEGABYTE SPI flash chip (W25Q128JVSIQ, basic part at JLCPCB :thumbsup:) that costs $0.60.  You get a <i>vastly</i> more capable MCU with so much goddamned flash space you could fit a truck in there!<p>You can even <i>partition</i> that flash chip&#x27;s space so that your RP2040 firmware is reserved to the say, the first 2MB (or wherever you wish!) and the rest can be used for storing stuff like settings.  It eliminates the need for an EEPROM!  Not to mention there&#x27;s enough storage space in there to store all your settings in something absurdly inefficient like JSON and the chip is fast enough to parse it too!<p>Working with the RP2040 <i>in reality</i> is just SO NICE.  Seriously, try it!  You won&#x27;t be disappointed.</div><br/><div id="40649529" class="c"><input type="checkbox" id="c-40649529" checked=""/><div class="controls bullet"><span class="by">diydsp</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40648277">parent</a><span>|</span><a href="#40653101">next</a><span>|</span><label class="collapse" for="c-40649529">[-]</label><label class="expand" for="c-40649529">[1 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t used the RP2040 yet, but having worked with SPIRAM and SPIflash on the ESP32, and also on many different STM32s, I can say this: if your project reaches a certain size, lots of tasks or multiple chunks of discontiguous memory, then the caching of the SPI memories becomes a traffic jam and things that should be really fast get really slow.  And you start running into lots of weird error messages from inside the esp-idf drivers that you can&#x27;t do much about.  It will drive you crazy.  You have to start strategically partitioning your memory, create&#x2F;delete tasks dynamically, adjust lots of params in menuconfig, etc etc.<p>Not a problem for most hobbyist projects, but when you start to push the limits the ESP32 feels like a chipboard apartment building compared to STM32&#x27;s concrete and rebar.  Hopefully the RP2040 doesn&#x27;t suffer the same problems.</div><br/></div></div><div id="40653101" class="c"><input type="checkbox" id="c-40653101" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40648277">parent</a><span>|</span><a href="#40649529">prev</a><span>|</span><a href="#40648654">next</a><span>|</span><label class="collapse" for="c-40653101">[-]</label><label class="expand" for="c-40653101">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m speaking from experience, I built two boards with the rp2040 before I decided to stop using it.<p>The pin flexibility is nice, I agree with you there. But I spend more time dealing with the flash chip than that saves me.<p>I don&#x27;t want more capability. An STM32 M3 has far far more processing throughput than I need for 99.9% of what I do. I want the smaller thing, even if it isn&#x27;t cheaper. It is sufficient.<p>I love stm32s because I can write bare metal C without using any of stmicro&#x27;s libraries at all (except the one header defining the register offsets). Here&#x27;s an example: <a href="https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;ledboard&#x2F;blob&#x2F;master&#x2F;firmware.c">https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;ledboard&#x2F;blob&#x2F;master&#x2F;firmwar...</a><p>The rp2040 is not set up to easily let you do minimalist stuff like that. And after all, why would they go to the trouble? You have 16MB of flash to waste on library code you never call... it&#x27;s like buying a mack truck to commute to work.<p>I&#x27;ll also echo the other comment about the cache: if you actually have megabytes of .text, you&#x27;re gonna have a bad time.</div><br/><div id="40653853" class="c"><input type="checkbox" id="c-40653853" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40653101">parent</a><span>|</span><a href="#40648654">next</a><span>|</span><label class="collapse" for="c-40653853">[-]</label><label class="expand" for="c-40653853">[1 more]</label></div><br/><div class="children"><div class="content">I forgot another win for the STM32: no crystal.</div><br/></div></div></div></div><div id="40648654" class="c"><input type="checkbox" id="c-40648654" checked=""/><div class="controls bullet"><span class="by">dave78</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40648277">parent</a><span>|</span><a href="#40653101">prev</a><span>|</span><a href="#40647218">next</a><span>|</span><label class="collapse" for="c-40648654">[-]</label><label class="expand" for="c-40648654">[1 more]</label></div><br/><div class="children"><div class="content">I agree with all that and would add that the documentation is fantastic, and the software tooling and SDK is well-done. That&#x27;s a big advantage that vastly outweighs small differences in cost (unless you&#x27;re selling millions of something).</div><br/></div></div></div></div><div id="40647218" class="c"><input type="checkbox" id="c-40647218" checked=""/><div class="controls bullet"><span class="by">bangaladore</span><span>|</span><a href="#40646944">parent</a><span>|</span><a href="#40648277">prev</a><span>|</span><a href="#40646980">next</a><span>|</span><label class="collapse" for="c-40647218">[-]</label><label class="expand" for="c-40647218">[2 more]</label></div><br/><div class="children"><div class="content">That chip has over 10x less RAM and only 60k flash. It has only one core and that core is clocked at half the speeds compared to both the RP2040 cores.<p>And it cost six bucks from US distributors. I can buy a single RP2040 chip from Digikey for 70 cents. Even if you add another dollar for flash memory, you are still far better off.</div><br/><div id="40647727" class="c"><input type="checkbox" id="c-40647727" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40647218">parent</a><span>|</span><a href="#40646980">next</a><span>|</span><label class="collapse" for="c-40647727">[-]</label><label class="expand" for="c-40647727">[1 more]</label></div><br/><div class="children"><div class="content">I mean, that&#x27;s sort of my point: the rp2040 has an absurd amount of RAM for a micro, I don&#x27;t need it and don&#x27;t want to pay for it.<p>I care more about the cost to manufacture boards with the part, than the cost to get sample parts mailed to me in the US :)</div><br/></div></div></div></div><div id="40646980" class="c"><input type="checkbox" id="c-40646980" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40646944">parent</a><span>|</span><a href="#40647218">prev</a><span>|</span><a href="#40647038">next</a><span>|</span><label class="collapse" for="c-40646980">[-]</label><label class="expand" for="c-40646980">[11 more]</label></div><br/><div class="children"><div class="content">&gt; I love the generic PIO though, I really hope other manufacturers pick up on that.<p>Unfortunately the Pi Foundation is seeking patents on the PIO architecture. I don&#x27;t think they&#x27;ve been granted yet though.</div><br/><div id="40647301" class="c"><input type="checkbox" id="c-40647301" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40646980">parent</a><span>|</span><a href="#40649983">next</a><span>|</span><label class="collapse" for="c-40647301">[-]</label><label class="expand" for="c-40647301">[6 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that already covered by FPGAs? I mean, it is just a way of configuring ports. And FPGAs are much broader (also configuring computation).</div><br/><div id="40649187" class="c"><input type="checkbox" id="c-40649187" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40647301">parent</a><span>|</span><a href="#40649186">next</a><span>|</span><label class="collapse" for="c-40649187">[-]</label><label class="expand" for="c-40649187">[2 more]</label></div><br/><div class="children"><div class="content">No, FPGAs work substantially different.<p>You can think of an FPGA as a bunch of &quot;programmable transistors&quot;. You&#x27;ve got a whole bunch of basic logic building blocks, and you program the wires between them to build a logic circuit. This means it is <i>great</i> for building relatively simple but high-speed logic (grab sample from sensor, do some additions and multiplications, store result in external DRAM chip, repeat at 5GHz). However, they are really inflexible: getting them to do different operations depending on some condition is extremely costly.<p>The PIO, on the other hand, is essentially a really basic CPU core. It reads and executes a stream of instructions, and it can do (very simple) math and conditional logic. This means it is great for building some kind of state machine, which dynamically adjusts it behaviour based on some kind of external condition. The unique selling point of the PIO is that the instruction set is completely designed around super-fast IO, so reading or writing two dozen pins can be done in one or even zero(!) instructions. And because every instruction executes in exactly one cycle, you&#x27;ve got really good control over the exact timing. This makes it ideal for implementing hardware-level protocols in software.</div><br/><div id="40650881" class="c"><input type="checkbox" id="c-40650881" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40649187">parent</a><span>|</span><a href="#40649186">next</a><span>|</span><label class="collapse" for="c-40650881">[-]</label><label class="expand" for="c-40650881">[1 more]</label></div><br/><div class="children"><div class="content">In that case, it sounds like they reinvented the coprocessor. I don&#x27;t see any fundamental difference between that and what they did.</div><br/></div></div></div></div><div id="40649186" class="c"><input type="checkbox" id="c-40649186" checked=""/><div class="controls bullet"><span class="by">arlort</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40647301">parent</a><span>|</span><a href="#40649187">prev</a><span>|</span><a href="#40649983">next</a><span>|</span><label class="collapse" for="c-40649186">[-]</label><label class="expand" for="c-40649186">[3 more]</label></div><br/><div class="children"><div class="content">The same features of pio can be implemented via FPGA, but it&#x27;s a lot more complicated to do so, and probably you won&#x27;t find FPGAs  as cheap as on the pi</div><br/><div id="40650780" class="c"><input type="checkbox" id="c-40650780" checked=""/><div class="controls bullet"><span class="by">nereye</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40649186">parent</a><span>|</span><a href="#40652783">next</a><span>|</span><label class="collapse" for="c-40650780">[-]</label><label class="expand" for="c-40650780">[1 more]</label></div><br/><div class="children"><div class="content">One example (PIO implemented in Verilog for use in FPGAs):<p><a href="https:&#x2F;&#x2F;github.com&#x2F;lawrie&#x2F;fpga_pio">https:&#x2F;&#x2F;github.com&#x2F;lawrie&#x2F;fpga_pio</a></div><br/></div></div><div id="40652783" class="c"><input type="checkbox" id="c-40652783" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40649186">parent</a><span>|</span><a href="#40650780">prev</a><span>|</span><a href="#40649983">next</a><span>|</span><label class="collapse" for="c-40652783">[-]</label><label class="expand" for="c-40652783">[1 more]</label></div><br/><div class="children"><div class="content">This core is probably less than 1000 lines of RTL (the verification suite probably being far more.)</div><br/></div></div></div></div></div></div><div id="40649983" class="c"><input type="checkbox" id="c-40649983" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40646980">parent</a><span>|</span><a href="#40647301">prev</a><span>|</span><a href="#40647127">next</a><span>|</span><label class="collapse" for="c-40649983">[-]</label><label class="expand" for="c-40649983">[2 more]</label></div><br/><div class="children"><div class="content">Source? I&#x27;ve not seen a patent for that, plus I suspect its not actually patentable</div><br/><div id="40650249" class="c"><input type="checkbox" id="c-40650249" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40649983">parent</a><span>|</span><a href="#40647127">next</a><span>|</span><label class="collapse" for="c-40650249">[-]</label><label class="expand" for="c-40650249">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;forums.raspberrypi.com&#x2F;viewtopic.php?p=1837408&amp;sid=69a92788e59c4bc692c32f97e819acff#p1837408" rel="nofollow">https:&#x2F;&#x2F;forums.raspberrypi.com&#x2F;viewtopic.php?p=1837408&amp;sid=6...</a><p>I haven&#x27;t seen a more recent update, unsure if they abandoned the patent bid or if it&#x27;s just taking a while to go through the system.</div><br/></div></div></div></div><div id="40647127" class="c"><input type="checkbox" id="c-40647127" checked=""/><div class="controls bullet"><span class="by">vitiral</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40646980">parent</a><span>|</span><a href="#40649983">prev</a><span>|</span><a href="#40646999">next</a><span>|</span><label class="collapse" for="c-40647127">[-]</label><label class="expand" for="c-40647127">[1 more]</label></div><br/><div class="children"><div class="content">seeking patents to then open source it?<p>Right?... Right?!?</div><br/></div></div><div id="40646999" class="c"><input type="checkbox" id="c-40646999" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40646980">parent</a><span>|</span><a href="#40647127">prev</a><span>|</span><a href="#40647038">next</a><span>|</span><label class="collapse" for="c-40646999">[-]</label><label class="expand" for="c-40646999">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s really disappointing :&#x2F;</div><br/></div></div></div></div><div id="40647038" class="c"><input type="checkbox" id="c-40647038" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#40646944">parent</a><span>|</span><a href="#40646980">prev</a><span>|</span><a href="#40646474">next</a><span>|</span><label class="collapse" for="c-40647038">[-]</label><label class="expand" for="c-40647038">[4 more]</label></div><br/><div class="children"><div class="content">Are you gated on PCB real estate, or cost? 8 megabits of QSPI is under 50 cents. I really don&#x27;t care that it&#x27;s external if the entire chipset is under 2 bucks.</div><br/><div id="40647131" class="c"><input type="checkbox" id="c-40647131" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40647038">parent</a><span>|</span><a href="#40646474">next</a><span>|</span><label class="collapse" for="c-40647131">[-]</label><label class="expand" for="c-40647131">[3 more]</label></div><br/><div class="children"><div class="content">Not the OP, but I&#x27;ll say, whenever designing a fresh board, this sort of convenience built-in is nice. Individually, it&#x27;s not a huge deal, but when you start adding things that are sometimes built in (external crystal vice internal? flash? PDs on USB or a bus?), you appreciate when it&#x27;s one less component to allow spacing for, that might be out of stock at a given order etc. Also note that QSPI flash has a number of connections, you have to check the datasheet etc to know what to wire where, if you are changing MCU footprint you have to re-wire it each design etc.</div><br/><div id="40647906" class="c"><input type="checkbox" id="c-40647906" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40647131">parent</a><span>|</span><a href="#40647653">next</a><span>|</span><label class="collapse" for="c-40647906">[-]</label><label class="expand" for="c-40647906">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d agree with most of those points, but in my decades of experience here...YAGNI.</div><br/></div></div><div id="40647653" class="c"><input type="checkbox" id="c-40647653" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#40646944">root</a><span>|</span><a href="#40647131">parent</a><span>|</span><a href="#40647906">prev</a><span>|</span><a href="#40646474">next</a><span>|</span><label class="collapse" for="c-40647653">[-]</label><label class="expand" for="c-40647653">[1 more]</label></div><br/><div class="children"><div class="content">Exactly this, it&#x27;s just another thing to deal with and I save a little time by not having to.</div><br/></div></div></div></div></div></div></div></div><div id="40646474" class="c"><input type="checkbox" id="c-40646474" checked=""/><div class="controls bullet"><span class="by">cockings</span><span>|</span><a href="#40646944">prev</a><span>|</span><a href="#40648560">next</a><span>|</span><label class="collapse" for="c-40646474">[-]</label><label class="expand" for="c-40646474">[27 more]</label></div><br/><div class="children"><div class="content">&gt; The RP2040 is impossible to brick. It comes with a read-only bootloader that can either mount as a USB mass storage device (firmware updates can just be copypasted to the &quot;storage device&quot;), or use its own simple USB protocol.<p>Can anyone explain what this means? How is it both read-only and updateable? If the latter, how is it unbrickable?</div><br/><div id="40646527" class="c"><input type="checkbox" id="c-40646527" checked=""/><div class="controls bullet"><span class="by">ndiddy</span><span>|</span><a href="#40646474">parent</a><span>|</span><a href="#40646496">next</a><span>|</span><label class="collapse" for="c-40646527">[-]</label><label class="expand" for="c-40646527">[13 more]</label></div><br/><div class="children"><div class="content">He&#x27;s saying that the bootloader is in ROM so it&#x27;s unbrickable, but the application code that the bootloader jumps into can be updated over USB. Most mid-range and higher microcontrollers have a similar feature, but they almost always have a custom protocol that requires a specialized flashing program rather than showing up as a mass storage device.</div><br/><div id="40646648" class="c"><input type="checkbox" id="c-40646648" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646527">parent</a><span>|</span><a href="#40646496">next</a><span>|</span><label class="collapse" for="c-40646648">[-]</label><label class="expand" for="c-40646648">[12 more]</label></div><br/><div class="children"><div class="content">To be frank, I don&#x27;t get its appeal at all. Most hobbyist uCs were already unbrickable, and using mass storage mode for flashing is rather cumbersome and clunky to automate as soon as you&#x27;re past hello worlds.</div><br/><div id="40646816" class="c"><input type="checkbox" id="c-40646816" checked=""/><div class="controls bullet"><span class="by">timenova</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646648">parent</a><span>|</span><a href="#40646721">next</a><span>|</span><label class="collapse" for="c-40646816">[-]</label><label class="expand" for="c-40646816">[6 more]</label></div><br/><div class="children"><div class="content">Hence they made the Pico Debug Probe [0]. It makes it super easy to reflash firmware to the Pico in a quick iterative loop.<p>However, the appeal of mounting as a mass storage device is not for iterative development (as you mentioned). Invariably something breaks, and the easiest way to get back on track is to reflash their default blank firmware using the mass storage interface.<p>[0] <a href="https:&#x2F;&#x2F;www.raspberrypi.com&#x2F;products&#x2F;debug-probe&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.raspberrypi.com&#x2F;products&#x2F;debug-probe&#x2F;</a></div><br/><div id="40647827" class="c"><input type="checkbox" id="c-40647827" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646816">parent</a><span>|</span><a href="#40646721">next</a><span>|</span><label class="collapse" for="c-40647827">[-]</label><label class="expand" for="c-40647827">[5 more]</label></div><br/><div class="children"><div class="content">I can use things like dfu-util or esptool for quick iterative loops without any additional hardware. Hence my point - mass storage is a downgrade over what other ÂµCs on the market were already doing with their ROM bootloaders before RP2040.</div><br/><div id="40648259" class="c"><input type="checkbox" id="c-40648259" checked=""/><div class="controls bullet"><span class="by">moefh</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40647827">parent</a><span>|</span><a href="#40646721">next</a><span>|</span><label class="collapse" for="c-40648259">[-]</label><label class="expand" for="c-40648259">[4 more]</label></div><br/><div class="children"><div class="content">Just to note: with the RP2040 you don&#x27;t need additional hardware (debug probe) for quick iterative development, you can use picotool[1] (using -f allows you to flash and reboot without needing to get it to bootsel mode).<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;picotool">https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;picotool</a></div><br/><div id="40648732" class="c"><input type="checkbox" id="c-40648732" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40648259">parent</a><span>|</span><a href="#40646721">next</a><span>|</span><label class="collapse" for="c-40648732">[-]</label><label class="expand" for="c-40648732">[3 more]</label></div><br/><div class="children"><div class="content">...and it doesn&#x27;t use mass storage at all, blocking access to it in a clunky way to prevent simultaneous usage.<p>UMS seems like a nice idea when you first hear about it, but it doesn&#x27;t really offer much once you look at it closer. The only proper argument for it is &quot;no special software needed&quot;, but it a world where picotool is `apt install picotool` away that&#x27;s not very advantageous anyway and only causes automount annoyances.<p>UMS shines where you have a device with a filesystem in its flash that you can access to actually manage the files stored there. Super useful for stuff like MicroPython. In contrast, pseudo-mass storage like on RP2040 doesn&#x27;t seem very useful at all. It makes it <i>appear</i> more approachable, but only superficially.</div><br/><div id="40649364" class="c"><input type="checkbox" id="c-40649364" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40648732">parent</a><span>|</span><a href="#40646721">next</a><span>|</span><label class="collapse" for="c-40649364">[-]</label><label class="expand" for="c-40649364">[2 more]</label></div><br/><div class="children"><div class="content">The whole UF2 idea has to do with the educational background of RaspberryPi. The protocol was invented by Microsoft for use in some kind of similar educational board with the express purpose of not needing drivers, being reasonably crossplatform and crucially not needing any special permissions to access the device. The end result is that in some kind of educational setting you can use some kind of cloud&#x2F;remote IDE on iPad, stick the RPi-Pico into the iPad and flash it, no blessing from Apple needed.</div><br/><div id="40649432" class="c"><input type="checkbox" id="c-40649432" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40649364">parent</a><span>|</span><a href="#40646721">next</a><span>|</span><label class="collapse" for="c-40649432">[-]</label><label class="expand" for="c-40649432">[1 more]</label></div><br/><div class="children"><div class="content">Oh. So it&#x27;s just a result of locked-down walled gardens being so widespread that they influence the world around them. Depressing, but thank you for pointing it out anyway; on my phone I can just run picotool itself and it&#x27;s easy to forget how dystopian it all got outside of the niche I&#x27;m in.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40646721" class="c"><input type="checkbox" id="c-40646721" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646648">parent</a><span>|</span><a href="#40646816">prev</a><span>|</span><a href="#40649271">next</a><span>|</span><label class="collapse" for="c-40646721">[-]</label><label class="expand" for="c-40646721">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never had great luck with the mass storage flashing.  It works fine, but boy is it slow.  I bought a J-Link a few years ago and haven&#x27;t looked back.<p>(It just takes a long time for the OS to recognize a USB device.  And you have to press the reset button yourself in order to enter the bootloader.  With something like J-Link, your build script can handle pressing the reset button and sending the code, saving you quite a bit of time between iterations.)</div><br/><div id="40647636" class="c"><input type="checkbox" id="c-40647636" checked=""/><div class="controls bullet"><span class="by">drrotmos</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646721">parent</a><span>|</span><a href="#40649271">next</a><span>|</span><label class="collapse" for="c-40647636">[-]</label><label class="expand" for="c-40647636">[1 more]</label></div><br/><div class="children"><div class="content">A debug probe is nice (quite possibly a must) if you&#x27;re actively developing, but for <i>deploying</i> in a hobbyist environment, USB is hard to beat.<p>I make open source espresso machine hardware (github.com&#x2F;variegated-coffee), and it&#x27;s nice to be able to give users a wired way to update firmwares that doesn&#x27;t require extra hardware.</div><br/></div></div></div></div><div id="40649271" class="c"><input type="checkbox" id="c-40649271" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646648">parent</a><span>|</span><a href="#40646721">prev</a><span>|</span><a href="#40647120">next</a><span>|</span><label class="collapse" for="c-40649271">[-]</label><label class="expand" for="c-40649271">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, I&#x27;ve got the exact opposite experience.<p>Small to medium production runs are always a bit of a pain, because you have to do a lot of coordination with the factory when it comes to tooling. You have to ship a custom programmer, get them to install the drivers on <i>whatever</i> OS they are using, and then find a way to write custom code to interact with the programmer and deal with all the possible error conditions.<p>The RP2040? A simple script which detects the presence of a RPI-labelled flash drive, copies a file, and repeats. Written in half an hour. Drivers? Not an issue. Hardware? Everyone has a USB cable lying around already. Error conditions? It either succeeds, or it doesn&#x27;t - the OS handles the rest.</div><br/></div></div><div id="40647120" class="c"><input type="checkbox" id="c-40647120" checked=""/><div class="controls bullet"><span class="by">dgroshev</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646648">parent</a><span>|</span><a href="#40649271">prev</a><span>|</span><a href="#40646496">next</a><span>|</span><label class="collapse" for="c-40647120">[-]</label><label class="expand" for="c-40647120">[2 more]</label></div><br/><div class="children"><div class="content">I completely agree that it&#x27;s inconvenient as a developer tool, a debug probe is much, much nicer.<p>I just think that despite all testing and care bugs are still possible, and the ROM bootloader is a backup that&#x27;s always there. Plop a tiny switch on the PCB, and even if I screw up an OTA update customers will still be able to flash with no special tools (if the device has a USB port, that is).<p>I also use it as a recovery state for panics, makes the device impossible to brick by a panic loop.</div><br/><div id="40647866" class="c"><input type="checkbox" id="c-40647866" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40647120">parent</a><span>|</span><a href="#40646496">next</a><span>|</span><label class="collapse" for="c-40647866">[-]</label><label class="expand" for="c-40647866">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I just think that despite all testing and care bugs are still possible, and the ROM bootloader is a backup that&#x27;s always there.<p>That&#x27;s orthogonal to mass storage mode. ROM bootloaders were standard in this class of microcontrollers for years, but they usually don&#x27;t use UMS. One could argue that UMS is perhaps better than some custom incompatible solutions, but then that&#x27;s what DFU is there for - a standard way to flash things over USB.</div><br/></div></div></div></div></div></div></div></div><div id="40646496" class="c"><input type="checkbox" id="c-40646496" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#40646474">parent</a><span>|</span><a href="#40646527">prev</a><span>|</span><a href="#40646548">next</a><span>|</span><label class="collapse" for="c-40646496">[-]</label><label class="expand" for="c-40646496">[9 more]</label></div><br/><div class="children"><div class="content">The bootloader is read-only. What the bootloader loads isn&#x27;t. If the thing you&#x27;re trying to boot into is faulty, it doesn&#x27;t matter because you can just replace the thing the bootloader is trying to load.<p>If the bootloader itself was faulty, the device would be bricked.</div><br/><div id="40646576" class="c"><input type="checkbox" id="c-40646576" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646496">parent</a><span>|</span><a href="#40646548">next</a><span>|</span><label class="collapse" for="c-40646576">[-]</label><label class="expand" for="c-40646576">[8 more]</label></div><br/><div class="children"><div class="content">To elaborate on the alternative:<p>When the bootloader is not read-only, you can upload another bootloader.<p>This is great in a different way because custom bootloaders allow for more flexibility.<p>For example, you may want to keep two copies of your firmware on the chip: One that you&#x27;re uploading, and one you can fall back to if the most recent one has problems. This protects you against failure during firmware upload or post-deployment failure, because you only overwrite one of the two. So if the device switches off while flashing it, and you boot back up, a custom bootloader can just default to the older copy.<p>But... what if you update the bootloader and <i>it</i> fails?<p>Then you can&#x27;t use the bootloader to upload new firmware. Bricked.<p>To unbrick a bootloader you need to overwrite the bootloader using alternative methods that don&#x27;t involve the bootloader, which usually involves attaching wires to the print. This is highly inconvenient in a production setting: Maybe your hardware is encased, embedded in a bigger thing, or located on a pole on a mountain top in a different country.<p>So a read-only bootloader is a safe choice, and you can make other workarounds wrt. flexibility.</div><br/><div id="40646662" class="c"><input type="checkbox" id="c-40646662" checked=""/><div class="controls bullet"><span class="by">HyulianGrader</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646576">parent</a><span>|</span><a href="#40647274">next</a><span>|</span><label class="collapse" for="c-40646662">[-]</label><label class="expand" for="c-40646662">[6 more]</label></div><br/><div class="children"><div class="content">Nobody in their right mind is updating a bootloader in the field OTA, let alone one inaccessible on a mountain top.</div><br/><div id="40646840" class="c"><input type="checkbox" id="c-40646840" checked=""/><div class="controls bullet"><span class="by">dave78</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646662">parent</a><span>|</span><a href="#40646814">next</a><span>|</span><label class="collapse" for="c-40646840">[-]</label><label class="expand" for="c-40646840">[1 more]</label></div><br/><div class="children"><div class="content">I used to work on a product where we did exactly that, and the devices literally ran on mountain tops. Our development and testing process was very rigorous and would be unrecognizable to most developers today, however. We certainly weren&#x27;t shipping new code to those devices after every sprint.</div><br/></div></div><div id="40646814" class="c"><input type="checkbox" id="c-40646814" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646662">parent</a><span>|</span><a href="#40646840">prev</a><span>|</span><a href="#40647274">next</a><span>|</span><label class="collapse" for="c-40646814">[-]</label><label class="expand" for="c-40646814">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree, but it leads to the question from the security guy:  how do you fix CVEs in the bootloader after it&#x27;s shipped (aka in the field)?</div><br/><div id="40647178" class="c"><input type="checkbox" id="c-40647178" checked=""/><div class="controls bullet"><span class="by">HyulianGrader</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646814">parent</a><span>|</span><a href="#40647186">next</a><span>|</span><label class="collapse" for="c-40647178">[-]</label><label class="expand" for="c-40647178">[2 more]</label></div><br/><div class="children"><div class="content">If you anticipate the need to update the bootloader, you would use a multistage bootloader approach where the first is never altered (as the bootloader should never be altered) and its main function is to select which updatable second stage bootloader to load from multiple options (multiple so that even if one is interrupted mid-update by the application, there is a valid fallback).<p>My gut says if you&#x27;re worried about this in the bootloader, it might be doing too much.</div><br/><div id="40649512" class="c"><input type="checkbox" id="c-40649512" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40647178">parent</a><span>|</span><a href="#40647186">next</a><span>|</span><label class="collapse" for="c-40649512">[-]</label><label class="expand" for="c-40649512">[1 more]</label></div><br/><div class="children"><div class="content">Particularly neat approach to both reducing the attack surface of the bootloader and improving the reliability of the actual OTA update process is to have only the bootloader flash the active application&#x2F;second-stage flash partition. The idea is that the normal application code somehow acquires the new version, verifies it and writes it into separate flash partition and then reboots, bootloader sees that record and, does minimal check for correctness and flashes that to right location. That way the bootloader does not have to know anything about how to get the new firmware image and does not process any untrusted input.</div><br/></div></div></div></div><div id="40647186" class="c"><input type="checkbox" id="c-40647186" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646814">parent</a><span>|</span><a href="#40647178">prev</a><span>|</span><a href="#40647274">next</a><span>|</span><label class="collapse" for="c-40647186">[-]</label><label class="expand" for="c-40647186">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t.<p>When I actually have these conversations with security guys, it&#x27;s because they&#x27;ve either missed their window on contributing to part selection (in one case because that team hadn&#x27;t been hired yet!) or no one consulted them in the first place. In both cases the solution is to write some guidelines and get the EEs to use them during part selection in the future.</div><br/></div></div></div></div></div></div><div id="40647274" class="c"><input type="checkbox" id="c-40647274" checked=""/><div class="controls bullet"><span class="by">dgroshev</span><span>|</span><a href="#40646474">root</a><span>|</span><a href="#40646576">parent</a><span>|</span><a href="#40646662">prev</a><span>|</span><a href="#40646548">next</a><span>|</span><label class="collapse" for="c-40647274">[-]</label><label class="expand" for="c-40647274">[1 more]</label></div><br/><div class="children"><div class="content">You can have several bootloader stages, and in fact that&#x27;s how the RP2040 works [1]!<p>Stage 1 bootloader is the one in ROM and it normally just reads stage 2 from the flash chip. Stage 2 then initialises the flash properly, and you can have further stages like [2] to implement the trial-rollback procedure.<p>Stage 1 is a safety net, even if the trial-rollback procedure goes terribly wrong the device can still be unbricked over USB.<p>[1]: <a href="https:&#x2F;&#x2F;blog.usedbytes.com&#x2F;2021&#x2F;12&#x2F;pico-serial-bootloader&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.usedbytes.com&#x2F;2021&#x2F;12&#x2F;pico-serial-bootloader&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;embassy.dev&#x2F;book&#x2F;#_bootloader" rel="nofollow">https:&#x2F;&#x2F;embassy.dev&#x2F;book&#x2F;#_bootloader</a></div><br/></div></div></div></div></div></div><div id="40646548" class="c"><input type="checkbox" id="c-40646548" checked=""/><div class="controls bullet"><span class="by">perbu</span><span>|</span><a href="#40646474">parent</a><span>|</span><a href="#40646496">prev</a><span>|</span><a href="#40647209">next</a><span>|</span><label class="collapse" for="c-40646548">[-]</label><label class="expand" for="c-40646548">[1 more]</label></div><br/><div class="children"><div class="content">The bootloader is read-only, the firmware it boots is updateable.<p>The bootloader allows you to update the device with new firmware. MCU are different than computers. And since you can&#x27;t overwrite the bootloader, you can&#x27;t brick the MCU. You can always just reset it.<p>fwiw; I&#x27;ve never bricked an MCU buy flashing something weird onto it. The hobbyist MCUs sold are typically quite easy to re-flash with new firmware.</div><br/></div></div><div id="40647209" class="c"><input type="checkbox" id="c-40647209" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#40646474">parent</a><span>|</span><a href="#40646548">prev</a><span>|</span><a href="#40646556">next</a><span>|</span><label class="collapse" for="c-40647209">[-]</label><label class="expand" for="c-40647209">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s saying that firmware updates are not persistent.  You have to apply them every time at boot time.  So if it boots once, it will boot every time.  If you ever get bad firmware, you just rollback or roll further forward in your boot media.</div><br/></div></div><div id="40647208" class="c"><input type="checkbox" id="c-40647208" checked=""/><div class="controls bullet"><span class="by">mkj</span><span>|</span><a href="#40646474">parent</a><span>|</span><a href="#40646556">prev</a><span>|</span><a href="#40648560">next</a><span>|</span><label class="collapse" for="c-40647208">[-]</label><label class="expand" for="c-40647208">[1 more]</label></div><br/><div class="children"><div class="content">Unbrickable for the RP2040 itself, but most SPI flash chips (including ones on the RP Pico) have permanently lockable regions. You can lock them open though.</div><br/></div></div></div></div><div id="40648560" class="c"><input type="checkbox" id="c-40648560" checked=""/><div class="controls bullet"><span class="by">127</span><span>|</span><a href="#40646474">prev</a><span>|</span><a href="#40648893">next</a><span>|</span><label class="collapse" for="c-40648560">[-]</label><label class="expand" for="c-40648560">[2 more]</label></div><br/><div class="children"><div class="content">PIO is fantastic. Revolutionary. Not trivial to use but extremely powerful and adaptable.
Too bad about the ADC. To be clear: the ADC is not &quot;OK&quot;. It&#x27; s BAD.</div><br/><div id="40650620" class="c"><input type="checkbox" id="c-40650620" checked=""/><div class="controls bullet"><span class="by">GeorgeTirebiter</span><span>|</span><a href="#40648560">parent</a><span>|</span><a href="#40648893">next</a><span>|</span><label class="collapse" for="c-40650620">[-]</label><label class="expand" for="c-40650620">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, the poor ADC performance is due to a design &#x2F; simulation error; at least you have to give them credit that they &#x27;came clean&#x27; on the crappy performance, and explained it in the official documentation:  <a href="https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.pdf" rel="nofollow">https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;rp2040&#x2F;rp2040-datasheet.p...</a>  section 4.9<p>See <a href="https:&#x2F;&#x2F;pico-adc.markomo.me&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pico-adc.markomo.me&#x2F;</a> for a thorough analysis of the problems.<p>Especially look at the DNL.</div><br/></div></div></div></div><div id="40648893" class="c"><input type="checkbox" id="c-40648893" checked=""/><div class="controls bullet"><span class="by">AtillaBosma</span><span>|</span><a href="#40648560">prev</a><span>|</span><a href="#40648176">next</a><span>|</span><label class="collapse" for="c-40648893">[-]</label><label class="expand" for="c-40648893">[1 more]</label></div><br/><div class="children"><div class="content">I want to shout out the fighting game community with: <a href="https:&#x2F;&#x2F;gp2040-ce.info&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gp2040-ce.info&#x2F;</a><p>It has been using the RP2040 to create cheap and easy to make controllers for fighting games while providing the lowest possible input delay.<p>The RP2040 does a great job acting as a chip for the base of a gamepad, so it doesn&#x27;t even have to be for a fighting game controller, but any controller you want to create.</div><br/></div></div><div id="40648176" class="c"><input type="checkbox" id="c-40648176" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#40648893">prev</a><span>|</span><a href="#40646696">next</a><span>|</span><label class="collapse" for="c-40648176">[-]</label><label class="expand" for="c-40648176">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Dozens of slightly different controllers. Why?<p>Many of those listed are the same controllers in various modules. Espressif has a bunch of different ÂµC series, but not <i>that</i> many. In contrast, aside of the whole Pico dev board, Raspberry Pi does not offer <i>any</i> ready-made module with RP2040.</div><br/></div></div><div id="40646696" class="c"><input type="checkbox" id="c-40646696" checked=""/><div class="controls bullet"><span class="by">tiku</span><span>|</span><a href="#40648176">prev</a><span>|</span><a href="#40648805">next</a><span>|</span><label class="collapse" for="c-40646696">[-]</label><label class="expand" for="c-40646696">[1 more]</label></div><br/><div class="children"><div class="content">My Switch is unlocked by a rp2040. A lot of devices could be modded with it, given the size etc.</div><br/></div></div><div id="40648805" class="c"><input type="checkbox" id="c-40648805" checked=""/><div class="controls bullet"><span class="by">fxtentacle</span><span>|</span><a href="#40646696">prev</a><span>|</span><a href="#40648010">next</a><span>|</span><label class="collapse" for="c-40648805">[-]</label><label class="expand" for="c-40648805">[1 more]</label></div><br/><div class="children"><div class="content">The real competition is the STM32 line-up, in my opinion. Much more computing power at a comparable price. Or half price if you only need a few MHz.</div><br/></div></div><div id="40651326" class="c"><input type="checkbox" id="c-40651326" checked=""/><div class="controls bullet"><span class="by">Teknoman117</span><span>|</span><a href="#40648010">prev</a><span>|</span><a href="#40648211">next</a><span>|</span><label class="collapse" for="c-40651326">[-]</label><label class="expand" for="c-40651326">[2 more]</label></div><br/><div class="children"><div class="content">Admittedly this is from a hobbyist perspective, but I&#x27;m hard pressed to reach for an ATmega for basically anything these days due to the RP2040, the Pico, and its clones.<p>I do wish there were more ADC channels though. Even an external analog mux costs more than the whole RP2040...</div><br/><div id="40651379" class="c"><input type="checkbox" id="c-40651379" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#40651326">parent</a><span>|</span><a href="#40648211">next</a><span>|</span><label class="collapse" for="c-40651379">[-]</label><label class="expand" for="c-40651379">[1 more]</label></div><br/><div class="children"><div class="content">I much prefer the ESP32, the RP2040 doesn&#x27;t even have WiFi or bluetooth, you would think every microcontroller should have those things these days.</div><br/></div></div></div></div><div id="40648211" class="c"><input type="checkbox" id="c-40648211" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#40651326">prev</a><span>|</span><a href="#40647160">next</a><span>|</span><label class="collapse" for="c-40648211">[-]</label><label class="expand" for="c-40648211">[2 more]</label></div><br/><div class="children"><div class="content">RP2040 is awkward in my experience.<p>Everyone needs Flash, and RP2040 has none. Very few projects need more than 32kB of SRAM (especially on an anemic Cortex-M0+ core). You&#x27;re missing an FPU (like on Cortex-M4 or higher chip), so DSP capabilities are awful even if your clock speed is high.<p>RP2040 has awful power consumption: 20mA. The M0+ competitors are 10mA, 5mA, or even sub 1mA. Once we get to more recent Cortex-M23 or Cortex-M33 (or the 8-bitters)... many competitors sleep in the under 1uA (!!!) regime, meaning &quot;always on&quot; chips (when you&#x27;re under 15uA or so, you&#x27;re undercutting many battery&#x27;s internal leakage currents, so your chip&#x27;s current usage becomes a rounding error). RP2040 is incapable of &quot;always on&quot; computation like this, so this limits applicability.<p>RP2040 has some peripherals, but its missing common modern components. Many competitors (AVR DB, TI&#x27;s MSP430 and MSPM0, STM32G4) have OpAmps for mixed-signal conditioning. Most competitors have multiple analog-comparators. DACs are somewhat uncommon but AVR and TI offer them.<p>-------<p>So comes the question: what kind of project are people using RP2040 for? It can&#x27;t be cost-optimized, because by the time you buy a flash-chip and external oscillator you&#x27;ve overrun the costs of the competitors.<p>Its not power-efficiency, because RP2040 is a power-hog. You&#x27;re getting far less battery life compared to competitors. (Case in point: the microcontroller that handles your wireless credit-card transactions is battery-less, running purely off of the energy of latent energy waves in the NFC protocol. RP2040 will never reach these low levels of power consumption).<p>Where I see RP2040 as useful, is utilizing its absurd 264kB SRAM (far, far larger figure than most chips). If you need a graphics framebuffer for a small 300x200 8-bit color screen or something, then RP2040 is probably the right choice. (60kB for the framebuffer, and likely 2 or 3 of them for various computations on the frame buffer).<p>But outside of a display driver, its difficult for me to find projects where RP2040 is actually the correct choice. Besides, screens are relatively expensive (in both $ and in power consumption), so if you&#x27;re getting a screen you probably can upgrade to a SAM9x75 with full 2D GPU, DDR3L 800MHz and Linux support for like $12 for those SiP packages.<p>-------<p>At a minimum, the next version of RP2040 needs to include on-board Flash &#x2F; on-board programming. This is something _every_ project needs (RP2040 needs to run its code off of _something_ anyway). The fact that it ships flash-free is incredibly absurd to me at least.<p>RP2040 forces a microprocessor-mindset (&quot;one chip&quot; where you add a bunch of addons) inside of the low-cost microcontroller market segment. Its very strange.</div><br/><div id="40651300" class="c"><input type="checkbox" id="c-40651300" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40648211">parent</a><span>|</span><a href="#40647160">next</a><span>|</span><label class="collapse" for="c-40651300">[-]</label><label class="expand" for="c-40651300">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At a minimum, the next version of RP2040 needs to include on-board Flash &#x2F; on-board programming. This is something _every_ project needs (RP2040 needs to run its code off of _something_ anyway). The fact that it ships flash-free is incredibly absurd to me at least.<p>You might get your wish there with their next chips, their last investor report revealed that it will be the &quot;RP235x family&quot;. Based on the naming scheme they established with the RP2040 that would be two Cortex-M3 cores with ~512kb RAM, and the &quot;X&quot; placeholder being the amount of onboard flash where the RP2040 had a &quot;0&quot; for &quot;no flash&quot;, so that implies there will be a range of models with different amounts of integrated flash.</div><br/></div></div></div></div><div id="40647160" class="c"><input type="checkbox" id="c-40647160" checked=""/><div class="controls bullet"><span class="by">snufkin97</span><span>|</span><a href="#40648211">prev</a><span>|</span><a href="#40646893">next</a><span>|</span><label class="collapse" for="c-40647160">[-]</label><label class="expand" for="c-40647160">[1 more]</label></div><br/><div class="children"><div class="content">YES!
TL;DR: its more powerful yet cheaper than most of MCU market, well documented and very straightforward yet extendable on many levels<p>I agree with the post in 100%, I use RP2040 for both hobby projects and my keyboard startup project (arrowmechanics.com in case sb was interested).<p>IMHO What RP foundation did is the greatest breakthrough in the world of embedded tech projects since the popularization of atmegas.</div><br/></div></div><div id="40646893" class="c"><input type="checkbox" id="c-40646893" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40647160">prev</a><span>|</span><a href="#40652794">next</a><span>|</span><label class="collapse" for="c-40646893">[-]</label><label class="expand" for="c-40646893">[16 more]</label></div><br/><div class="children"><div class="content">I have just one question: is this product meant for the &quot;hobbyist&quot; space only?</div><br/><div id="40647058" class="c"><input type="checkbox" id="c-40647058" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#40646893">parent</a><span>|</span><a href="#40646950">next</a><span>|</span><label class="collapse" for="c-40647058">[-]</label><label class="expand" for="c-40647058">[8 more]</label></div><br/><div class="children"><div class="content">I was on the fence about using it for a small commercial project I&#x27;m doing, but the lifetime has been put out long enough (2041 at this point), and it&#x27;s so freaking cheap that I&#x27;m going to do a one-time buy of 10 years worth of parts.<p>Lack of code security and onboard flash weren&#x27;t dealbreakers for me here, but others will have more stringent requirements. QSPI is so incredibly cheap now.</div><br/><div id="40647168" class="c"><input type="checkbox" id="c-40647168" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647058">parent</a><span>|</span><a href="#40646950">next</a><span>|</span><label class="collapse" for="c-40647168">[-]</label><label class="expand" for="c-40647168">[7 more]</label></div><br/><div class="children"><div class="content">Ok. One thing I&#x27;m worried about is that the tooling is made for hobbyists only. Is there a way to do everything from the commandline with FOSS tools and without installing e.g. the Arduino-IDE?</div><br/><div id="40648749" class="c"><input type="checkbox" id="c-40648749" checked=""/><div class="controls bullet"><span class="by">dave78</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647168">parent</a><span>|</span><a href="#40647823">next</a><span>|</span><label class="collapse" for="c-40648749">[-]</label><label class="expand" for="c-40648749">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is there a way to do everything from the commandline with FOSS tools and without installing e.g. the Arduino-IDE?<p>Yes. In fact, the official getting started guide[0] is all command-line based, with an optional chapter later on about using VS Code if you wish.<p>I have a low volume product in production using the RP2040 and I&#x27;ve never once opened up any sort of GUI for developing the software or programming it.<p>[0] <a href="https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;pico&#x2F;getting-started-with-pico.pdf" rel="nofollow">https:&#x2F;&#x2F;datasheets.raspberrypi.com&#x2F;pico&#x2F;getting-started-with...</a></div><br/></div></div><div id="40647823" class="c"><input type="checkbox" id="c-40647823" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647168">parent</a><span>|</span><a href="#40648749">prev</a><span>|</span><a href="#40647564">next</a><span>|</span><label class="collapse" for="c-40647823">[-]</label><label class="expand" for="c-40647823">[1 more]</label></div><br/><div class="children"><div class="content">Since the RP2040 uses external flash you can pre-program the flash chips before they even get soldered on to the board.  Other standard methods still work like breaking out the debug pins to some spot on your PCB so you can quickly &quot;pogo flash&quot; it as part of an assembly process.</div><br/></div></div><div id="40647564" class="c"><input type="checkbox" id="c-40647564" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647168">parent</a><span>|</span><a href="#40647823">prev</a><span>|</span><a href="#40647457">next</a><span>|</span><label class="collapse" for="c-40647564">[-]</label><label class="expand" for="c-40647564">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using the CircuitPython environment. I&#x27;m editing in vi and writing directly to the USB storage on the RP2040, which reboots upon write and runs the code. It&#x27;s no big deal. There&#x27;s also a virtual UART off that USB connection for light debugging.</div><br/></div></div><div id="40647457" class="c"><input type="checkbox" id="c-40647457" checked=""/><div class="controls bullet"><span class="by">mordae</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647168">parent</a><span>|</span><a href="#40647564">prev</a><span>|</span><a href="#40648103">next</a><span>|</span><label class="collapse" for="c-40647457">[-]</label><label class="expand" for="c-40647457">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Pico SDK is C with CMake and Rust is bare metal (I think).</div><br/></div></div><div id="40648103" class="c"><input type="checkbox" id="c-40648103" checked=""/><div class="controls bullet"><span class="by">silvanocerza</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647168">parent</a><span>|</span><a href="#40647457">prev</a><span>|</span><a href="#40647435">next</a><span>|</span><label class="collapse" for="c-40648103">[-]</label><label class="expand" for="c-40648103">[1 more]</label></div><br/><div class="children"><div class="content">Maybe with the Arduino CLI?</div><br/></div></div><div id="40647435" class="c"><input type="checkbox" id="c-40647435" checked=""/><div class="controls bullet"><span class="by">dgroshev</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647168">parent</a><span>|</span><a href="#40648103">prev</a><span>|</span><a href="#40646950">next</a><span>|</span><label class="collapse" for="c-40647435">[-]</label><label class="expand" for="c-40647435">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure how things are in the C land, but if you write Rust take a look at this book [1], Embassy has a very good support for the RP2040.<p>Probe-rs [2] works perfectly well with GDB and the CLion debugger.<p>[1]: <a href="https:&#x2F;&#x2F;embassy.dev&#x2F;book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;embassy.dev&#x2F;book&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;probe.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;probe.rs&#x2F;</a></div><br/></div></div></div></div></div></div><div id="40646950" class="c"><input type="checkbox" id="c-40646950" checked=""/><div class="controls bullet"><span class="by">mmoskal</span><span>|</span><a href="#40646893">parent</a><span>|</span><a href="#40647058">prev</a><span>|</span><a href="#40647015">next</a><span>|</span><label class="collapse" for="c-40646950">[-]</label><label class="expand" for="c-40646950">[6 more]</label></div><br/><div class="children"><div class="content">Definitely not. My understanding is they got significant market share on lunch - since it was during the pandemic chip shortage and they were the only ones with sub year lead times.</div><br/><div id="40647003" class="c"><input type="checkbox" id="c-40647003" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40646950">parent</a><span>|</span><a href="#40647015">next</a><span>|</span><label class="collapse" for="c-40647003">[-]</label><label class="expand" for="c-40647003">[5 more]</label></div><br/><div class="children"><div class="content">Ok, but does it fulfill military or automotive standards?</div><br/><div id="40647974" class="c"><input type="checkbox" id="c-40647974" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647003">parent</a><span>|</span><a href="#40647469">next</a><span>|</span><label class="collapse" for="c-40647974">[-]</label><label class="expand" for="c-40647974">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about military standards but there&#x27;s only ONE automotive standard and it&#x27;s ISO 26262:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISO_26262" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISO_26262</a><p>There&#x27;s nothing in ISO 26262 that would prevent someone from using an RP2040 in a car.  You&#x27;d just have to be redundant about everything which you have to do <i>anyway</i> regardless of the chip you choose.<p>Also, ISO 26262 is not a law.  It&#x27;s up to the auto manufacturer whether or not they&#x27;d require it and no single chip on its own can claim to be &quot;certified&quot; (or similar) for ISO 26262 since the focus is on redundancy and error checking (which means one chip would check the status of the other and vice versa, not some special internal consistency checking feature...  That&#x27;s just marketing).<p>Most &quot;automotive&quot; versions of chips (e.g. Atmel&#x27;s stuff) are just branded that way.  Atmel will make a claim like, &quot;this chip has been tested to function properly under these sort of extreme conditions...&quot; (that happen to match what car manufacturers are looking for) and then a car company would just <i>trust</i> that and make it so that only chips that are marked &quot;automotive&quot; and manufactured by Atmel will be allowed to be used by their electrical engineers (or suppliers).<p>It&#x27;s all entirely arbitrary though:  If you can convince the manufacturer that your board works fine under the conditions they require they&#x27;ll probably buy it.  Well, they won&#x27;t hold it against you that you used one chip or the other.  They just want some assurances.</div><br/><div id="40648460" class="c"><input type="checkbox" id="c-40648460" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647974">parent</a><span>|</span><a href="#40647469">next</a><span>|</span><label class="collapse" for="c-40648460">[-]</label><label class="expand" for="c-40648460">[2 more]</label></div><br/><div class="children"><div class="content">There are several automotive standards for electronic components. GP was probably asking about e.g. AEC-Q100, AEC-Q101, and&#x2F;or AEC-Q200. These establish that the device is going to work in automotive environments (temperature, humidity, vibration &amp; shock) by verifying functionality while subjecting them to those conditions. A component may work without these tests, but you are merely hoping that that is the case if they haven&#x27;t been tested. Hope is not a viable strategy for product design.</div><br/><div id="40649195" class="c"><input type="checkbox" id="c-40649195" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40648460">parent</a><span>|</span><a href="#40647469">next</a><span>|</span><label class="collapse" for="c-40649195">[-]</label><label class="expand" for="c-40649195">[1 more]</label></div><br/><div class="children"><div class="content">The AEC standards aren&#x27;t enforced by anything and are mostly just <i>promises</i> that chip manufacturers make (the AEC itself is a private entity).  Specifically, that any given chip will still be available in 15 years and that it&#x27;ll operate fine within certain temperature ranges.<p>If some part claims to be AEC compliant it&#x27;s basically just the manufacturer saying so.  There&#x27;s no independent body or even standardized tests to prove a part adheres to any given AEC document.  Their own docs state as much:<p><pre><code>    AEC Certification
    
    Note that there are no &quot;certifications&quot; for AEC-Q100 qualification and there
    is no certification board run by AEC to qualify parts. Each supplier
    performs their qualification to AEC standards, considers customer
    requirements and submits the data to the user to verify compliance to Q100
</code></pre>
In other words, it would be up to any given car manufacturer to verify the claims of any chip vendor using their own testing methods.  Since they&#x27;re going to have to do that <i>anyway</i>, slapping AEC-(whatever) on a product doesn&#x27;t mean much.<p>If you test your part in similar conditions and make some availability promises you too can slap an AEC-Q100 label on to your chip!</div><br/></div></div></div></div></div></div><div id="40647469" class="c"><input type="checkbox" id="c-40647469" checked=""/><div class="controls bullet"><span class="by">mordae</span><span>|</span><a href="#40646893">root</a><span>|</span><a href="#40647003">parent</a><span>|</span><a href="#40647974">prev</a><span>|</span><a href="#40647015">next</a><span>|</span><label class="collapse" for="c-40647469">[-]</label><label class="expand" for="c-40647469">[1 more]</label></div><br/><div class="children"><div class="content">Probably yes, but it doesn&#x27;t have the paperwork AFAIK.</div><br/></div></div></div></div></div></div><div id="40647015" class="c"><input type="checkbox" id="c-40647015" checked=""/><div class="controls bullet"><span class="by">dgroshev</span><span>|</span><a href="#40646893">parent</a><span>|</span><a href="#40646950">prev</a><span>|</span><a href="#40652794">next</a><span>|</span><label class="collapse" for="c-40647015">[-]</label><label class="expand" for="c-40647015">[1 more]</label></div><br/><div class="children"><div class="content">Personally I wouldn&#x27;t put it into a toothbrush (the benefit of right sizing is too high when you produce tens of millions of those), but for lower volumes I&#x27;d go for it.<p>Fwiw I&#x27;m working on my own consumer product&#x2F;dev tool and I&#x27;m very happy with the RP2040.</div><br/></div></div></div></div><div id="40652794" class="c"><input type="checkbox" id="c-40652794" checked=""/><div class="controls bullet"><span class="by">15155</span><span>|</span><a href="#40646893">prev</a><span>|</span><label class="collapse" for="c-40652794">[-]</label><label class="expand" for="c-40652794">[1 more]</label></div><br/><div class="children"><div class="content">Give me a USB high-speed PHY.<p>Otherwise, NXP FlexIO is very similar to PIO and these are much more capable chips.</div><br/></div></div></div></div></div></div></div></body></html>