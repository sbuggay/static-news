<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695027663760" as="style"/><link rel="stylesheet" href="styles.css?v=1695027663760"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pineapple-one.github.io/">Pineapple ONE: open-source 32 bit RISC-V CPU that you can make at home</a> <span class="domain">(<a href="https://pineapple-one.github.io">pineapple-one.github.io</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>51 comments</span></div><br/><div><div id="37548842" class="c"><input type="checkbox" id="c-37548842" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#37550728">next</a><span>|</span><label class="collapse" for="c-37548842">[-]</label><label class="expand" for="c-37548842">[24 more]</label></div><br/><div class="children"><div class="content">&quot;No FPGAs, no microcontrollers, just discrete logic&quot;<p>Very hard to believe that. .. How? Is it a SUBLEQ-style Turing tarpit that uses a very high clock and simple hardware to run RISC-V &quot;in software&quot; at a slower clock? Do the discrete logic gates get woven into an ad-hoc FPGA?<p>Considering the breadboard CPUs I saw a few years ago, it just doesn&#x27;t look like enough board space... I could be wrong.</div><br/><div id="37549550" class="c"><input type="checkbox" id="c-37549550" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#37548842">parent</a><span>|</span><a href="#37548948">next</a><span>|</span><label class="collapse" for="c-37549550">[-]</label><label class="expand" for="c-37549550">[8 more]</label></div><br/><div class="children"><div class="content">A few years ago I considered trying to build a simple 32-bit RISC processor out of 74xx series logic chips. I had just taken parts 1 and 3 of the the MITx MOOC 6.004x, &quot;Computation Structures&quot;.<p>Part 1 covered CMOS, combinatorial logic, sequential logic, FSMs and stuff like that, and performance considerations, and culminated with designing a 32-bit ALU, which did add, sub, all 16 logic ops, compares, and shifts (logical or arithmetic) of 0 to 31 bits in either direction.<p>In part 2 the students design a 32-bit processor and implement it in the simulator. The design is all at the gate level, except we were given two things as black boxes: (1) a register file of 32 32-bit registers, and (2) a ROM with 64 18-bit words.<p>Part 3 adds caching and other performance.<p>Here was the parts list I came up with for my design, not counting whatever it would have to do the 32x32 register file and the 64x18 ROM. In the follows the name of a logic element (NOR, MUX, etc) followed by a number means an element with that number of inputs. E.g, NOR2 is a 2 input NOT gate, and MUX4 is a 4 input multiplexor. DREG is something that can store 1 bit, which would probably be a D flip flop.<p>The parts list:<p><pre><code>  295 AND2
    8 AND3

   32 DREG

    3 NOR2
    4 OR2
   96 OR3
   20 OR4

  226 XOR2

    6 NOT

  563 MUX2
  161 MUX4
</code></pre>
That came out to around 350 chips. My biggest breadboard could hold about 32 chips, so I&#x27;d need around 11 or 12 of those, plus whatever more would be needed for the register file and ROM.<p>353 of those 563 MUX2s are in the shifter in the ALU, which can handle left or right arithmetic or logical shift by 0 to 31 in one clock cycle. If I added a new instruction that just does a logic right shift by 1 and made the old shift instructions all trap so they can be handled in software that would get rid of most of those 353 MUX2s.<p>That would cut the chip count to around 270. That was still more than I was willing to deal with so that was the end of that.<p>Given that with a PCB instead of a breadboard you&#x27;d get higher density, I think mine would have easily fit (even with the full shifter) in the amount of space that it looks like they are using with plenty left over, if I&#x27;m estimating the size of their boards right from the photos, so I don&#x27;t see anything obviously implausible about their project.</div><br/><div id="37549669" class="c"><input type="checkbox" id="c-37549669" checked=""/><div class="controls bullet"><span class="by">codedokode</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37549550">parent</a><span>|</span><a href="#37551919">next</a><span>|</span><label class="collapse" for="c-37549669">[-]</label><label class="expand" for="c-37549669">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If I added a new instruction that just does a logic right shift by 1 and made the old shift instructions all trap<p>You can use microcode for that. Also microcode can be used to implement multiply&#x2F;divide by adding&#x2F;subtracting in a loop. Microcode is very bad for performance, but in a DIY project it can save lot of chips. Microcode was used in 60s and 70s computers.<p>And the simplest microcode sequencer is made of 1 (one) register and 1 (one) ROM. Although, for a RISC-V you would probably need more than 1 ROM (microcode is usually very wide, 16- or more bits).</div><br/><div id="37551832" class="c"><input type="checkbox" id="c-37551832" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37549669">parent</a><span>|</span><a href="#37551919">next</a><span>|</span><label class="collapse" for="c-37551832">[-]</label><label class="expand" for="c-37551832">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t microcode used in today’s CPUs all the time? Or is this different meaning of microcode?</div><br/><div id="37551878" class="c"><input type="checkbox" id="c-37551878" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37551832">parent</a><span>|</span><a href="#37551919">next</a><span>|</span><label class="collapse" for="c-37551878">[-]</label><label class="expand" for="c-37551878">[1 more]</label></div><br/><div class="children"><div class="content">I would guess they used to use it because hardware was very expensive, and now they use it because performance is very cheap.</div><br/></div></div></div></div></div></div><div id="37551919" class="c"><input type="checkbox" id="c-37551919" checked=""/><div class="controls bullet"><span class="by">jewillco</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37549550">parent</a><span>|</span><a href="#37549669">prev</a><span>|</span><a href="#37549622">next</a><span>|</span><label class="collapse" for="c-37551919">[-]</label><label class="expand" for="c-37551919">[2 more]</label></div><br/><div class="children"><div class="content">For counting chips, remember that each 74xx chip typically has multiple gates. For example, one of them has four AND gates, and another has six inverters.</div><br/><div id="37552370" class="c"><input type="checkbox" id="c-37552370" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37551919">parent</a><span>|</span><a href="#37549622">next</a><span>|</span><label class="collapse" for="c-37552370">[-]</label><label class="expand" for="c-37552370">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes, many gates!  The 74xx series shows the progress of semiconductor technology over time.  Later 74xx series chips are MSI.  Oh, that term is quite antiquated now isn&#x27;t it?  Medium-scale integration.  (Just about everything is far beyond VLSI these days.  Very large scale integration.)<p>The 7400, the first device in the series, was just four NAND gates in one IC.  NAND is the easiest function to implement in TTL (and most other logic families).  The somewhat later 7476 is a dual JK flip-flop. It takes eight NAND gates to make a JK flip-flop, so a 7476 is about four times denser than the 7400.  And devices like the even later 74161 4-bit synchronous binary counter have many dozens of gates [1], being roughly four times as much integration again over the 7476.<p>The 7400, 7476, and 74161 were at the cutting edge of integration in 1963, 1966, 1969, respectively.<p>[1] <a href="https:&#x2F;&#x2F;makeyourownchip.tripod.com&#x2F;74161.GIF" rel="nofollow noreferrer">https:&#x2F;&#x2F;makeyourownchip.tripod.com&#x2F;74161.GIF</a></div><br/></div></div></div></div><div id="37549622" class="c"><input type="checkbox" id="c-37549622" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37549550">parent</a><span>|</span><a href="#37551919">prev</a><span>|</span><a href="#37548948">next</a><span>|</span><label class="collapse" for="c-37549622">[-]</label><label class="expand" for="c-37549622">[2 more]</label></div><br/><div class="children"><div class="content">do you mean 74xx series logic? or 70xx series voltage detectors?</div><br/><div id="37550085" class="c"><input type="checkbox" id="c-37550085" checked=""/><div class="controls bullet"><span class="by">tzs</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37549622">parent</a><span>|</span><a href="#37548948">next</a><span>|</span><label class="collapse" for="c-37550085">[-]</label><label class="expand" for="c-37550085">[1 more]</label></div><br/><div class="children"><div class="content">Oops, yeah 74xx. I&#x27;ve fixed it.</div><br/></div></div></div></div></div></div><div id="37548948" class="c"><input type="checkbox" id="c-37548948" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37548842">parent</a><span>|</span><a href="#37549550">prev</a><span>|</span><a href="#37548907">next</a><span>|</span><label class="collapse" for="c-37548948">[-]</label><label class="expand" for="c-37548948">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a logisim simulation of the uarch.  Assuming that matches the boards, it looks like a relatively straightforward pipeline-less implementation of a RISC.<p>And it&#x27;d be much larger on a breadboard.  Breadboards don&#x27;t really allow your wiring and connections to be nearly as dense as even two layer boards.  This project seems doable to me with relatively high scale integration chips handling a lot of heavy lifting, and maybe an EEPROM or two as a poor man&#x27;s PLD for certain kinds of combinatory logic.</div><br/><div id="37549253" class="c"><input type="checkbox" id="c-37549253" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37548948">parent</a><span>|</span><a href="#37548907">next</a><span>|</span><label class="collapse" for="c-37549253">[-]</label><label class="expand" for="c-37549253">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>and maybe an EEPROM or two as a poor man&#x27;s PLD for certain kinds of combinatory logic.</i><p>The entire ALU and Control Unit of the CPU are programmed in EEPROMs. The ALU uses 7 ROMs [1], the Control Unit uses 3 ROMs [2], the program counter uses 5 ROMs [3], the bit shifter uses another ROM [4], so I see 16 EEPROMs in total. Thus, hundreds if not thousands of logic gates are replaced by bitstreams in EEPROMs. This CPU certainly is based on the design philosophy of &quot;EEPROMs as poor-man&#x27;s FPGA&quot; (not meant to be interpreted in a discouraging way, I found this design is still rather interesting).<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;alu&#x2F;doc&#x2F;ALU.pdf">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;al...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;control-unit&#x2F;doc&#x2F;Control_unit.pdf">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;co...</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;program-counter&#x2F;doc&#x2F;Program_counter.pdf">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;pr...</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;shifter&#x2F;doc&#x2F;Shifter.pdf">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;sh...</a></div><br/><div id="37552384" class="c"><input type="checkbox" id="c-37552384" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37549253">parent</a><span>|</span><a href="#37548907">next</a><span>|</span><label class="collapse" for="c-37552384">[-]</label><label class="expand" for="c-37552384">[2 more]</label></div><br/><div class="children"><div class="content">Yeah that is cool, because I hear that the tooling for FPGAs is still very proprietary. And it doesn&#x27;t do much good if one&#x27;s CPU is &quot;Click the CPU button on the FPGA GUI&quot;<p>EEPROMS, I assume, you can build your own programmer pretty easily?</div><br/><div id="37552743" class="c"><input type="checkbox" id="c-37552743" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37552384">parent</a><span>|</span><a href="#37548907">next</a><span>|</span><label class="collapse" for="c-37552743">[-]</label><label class="expand" for="c-37552743">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>EEPROMS, I assume, you can build your own programmer pretty easily?</i><p>Programming a EEPROM by bitbanging it from a microcontroller is a basic programming exercise. First, send a special unlock sequence according to the datasheet (usually with a lot of 0x55 0xAA). Next, put all the address bits on the address lines, strobe that in via a control line. Finally, put all the data bits on the data lines, strobe that in via a control line. You only need around 100 lines of code to create a basic programmer (although making a universal one capable of programming all existing models on the market would be non-trivial, as it requires a massive look-up table similar to the one in &quot;flashrom&quot;).</div><br/></div></div></div></div></div></div></div></div><div id="37548907" class="c"><input type="checkbox" id="c-37548907" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#37548842">parent</a><span>|</span><a href="#37548948">prev</a><span>|</span><a href="#37550969">next</a><span>|</span><label class="collapse" for="c-37548907">[-]</label><label class="expand" for="c-37548907">[4 more]</label></div><br/><div class="children"><div class="content">From the picture, the logic chips are all in SOIC packages. The use of surface-mount components with 4-layer PCB should already significantly boost routing density compared to a breadboard with DIP chips. All the chips can be tightly packed together.<p>Furthermore, both the ALU and the Control Unit are entirely in EEPROMs. The ALU uses 7 ROMs [2], the Control Unit uses 3 ROMs [3], the program counter uses 5 ROMs [4], the bit shifter uses another ROM [5], so I already see 16 EEPROMs in total. This means all the discrete components needed for random logic are largely eliminated, consolidating possibly hundreds (or thousands?) of gates into just a few chips and some lookup tables to program. In fact anther maker already demonstrated that it&#x27;s sufficient to design a functional CPU entirely using RAM and ROM with just 15 chips in total. [6]<p>Programmmers usually think ROMs as data storage devices, but they are also the most rudimentary form of programmable logic, as they transform x-bit of address inputs into arbitrary y-bit data outputs, so they can implement arbitrary combinational logic. In fact, lookup tables are the heart of modern FPGAs. As a result, you may argue that this means any ROM-based design has ad-hoc FPGAs (especially when EEPROMs are so large after the 1980s, 64 K for 16-bit chips). But the use of Mask ROMs and PLAs in Control Units has always been a legitimate and standard way to design CPUs even back in the 70s, so I won&#x27;t call it &quot;cheating&quot; (and using ROMs for ALUs or Control Unit wouldn&#x27;t really be much different from using a pre-made 74181 or AMD Am2900 anyway).<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;control-unit&#x2F;doc&#x2F;Control_unit.pdf">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;co...</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;alu&#x2F;doc&#x2F;ALU.pdf">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;al...</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;program-counter&#x2F;doc&#x2F;Program_counter.pdf">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;pr...</a><p>[5] <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;shifter&#x2F;doc&#x2F;Shifter.pdf">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle&#x2F;blob&#x2F;main&#x2F;sh...</a><p>[6] <a href="https:&#x2F;&#x2F;bailleux.net&#x2F;pub&#x2F;ob-project-gray1.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;bailleux.net&#x2F;pub&#x2F;ob-project-gray1.pdf</a></div><br/><div id="37553284" class="c"><input type="checkbox" id="c-37553284" checked=""/><div class="controls bullet"><span class="by">mips_r4300i</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37548907">parent</a><span>|</span><a href="#37548959">next</a><span>|</span><label class="collapse" for="c-37553284">[-]</label><label class="expand" for="c-37553284">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for pointing this out.
 In the olden days it used to be fairly common to use eeproms (or just proms) with a few latches as a state machine. This way it was possible to accomplish many of the things you&#x27;d need a CPU for, but without needing one at all.<p>It&#x27;s not too far to add an ALU and some control flow after that, hehe.</div><br/><div id="37553452" class="c"><input type="checkbox" id="c-37553452" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37553284">parent</a><span>|</span><a href="#37548959">next</a><span>|</span><label class="collapse" for="c-37553452">[-]</label><label class="expand" for="c-37553452">[1 more]</label></div><br/><div class="children"><div class="content">The use of microcode in CPUs began like this too. Originally, people replaced random logic in a CPU&#x27;s Control Unit with a Mask ROM or a PLA. The goal was simply to avoid the trouble of building decoders from gates one by one. Although it&#x27;s a form of programmable logic, few would describe these simple ROM lookup tables as &quot;programs&quot;. Later, people pushed the idea further to build a small state machine to control the ALUs, and the microcode in ROM would then be used in turn to control that state machine. This marked the birth of &quot;micro-sequencers&quot;. In addition to the internal use in integrated circuits, they also found applications as universal blocking blocks for custom discrete CPUs in the 1980s, examples included the AMD Am2900, Am29100 and Am29300 series chips. Building a CPU became as easy as connecting these logic blocks together and writing some microcode for the micro-sequencer. Continue the development of microcode further, and you eventually get the final form, which is a CPU within a CPU, and you may argue that the CPU is not really hardware anymore, but is driven by software.<p>At which point does the use of microcode makes a CPU software rather than hardware? There&#x27;s really no clear boundary, so the microcode always exists on the blurring line between hardware and software. This issue was also a heavily-contented subject in several lawsuits that involved cloning CPUs, as hardware is not covered by copyright, but software is.</div><br/></div></div></div></div><div id="37548959" class="c"><input type="checkbox" id="c-37548959" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37548907">parent</a><span>|</span><a href="#37553284">prev</a><span>|</span><a href="#37550969">next</a><span>|</span><label class="collapse" for="c-37548959">[-]</label><label class="expand" for="c-37548959">[1 more]</label></div><br/><div class="children"><div class="content">Very cool! Someone else mentioned breadboard vs. PCB density of course.<p>So if it&#x27;s real, maybe I&#x27;ll get one.</div><br/></div></div></div></div><div id="37550969" class="c"><input type="checkbox" id="c-37550969" checked=""/><div class="controls bullet"><span class="by">gbraad</span><span>|</span><a href="#37548842">parent</a><span>|</span><a href="#37548907">prev</a><span>|</span><a href="#37548861">next</a><span>|</span><label class="collapse" for="c-37550969">[-]</label><label class="expand" for="c-37550969">[1 more]</label></div><br/><div class="children"><div class="content">I miss some nice clear board shots to see what is used. Harts to open the kicad&#x2F;eagle file on a mobile device</div><br/></div></div><div id="37548861" class="c"><input type="checkbox" id="c-37548861" checked=""/><div class="controls bullet"><span class="by">Pixelbrick</span><span>|</span><a href="#37548842">parent</a><span>|</span><a href="#37550969">prev</a><span>|</span><a href="#37549105">next</a><span>|</span><label class="collapse" for="c-37548861">[-]</label><label class="expand" for="c-37548861">[1 more]</label></div><br/><div class="children"><div class="content">The same way it used to be done before we had LSI&#x2F;VLSI!</div><br/></div></div><div id="37549105" class="c"><input type="checkbox" id="c-37549105" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#37548842">parent</a><span>|</span><a href="#37548861">prev</a><span>|</span><a href="#37548892">next</a><span>|</span><label class="collapse" for="c-37549105">[-]</label><label class="expand" for="c-37549105">[2 more]</label></div><br/><div class="children"><div class="content">Interestingly it&#x27;s only 500kHz clockrate</div><br/><div id="37550149" class="c"><input type="checkbox" id="c-37550149" checked=""/><div class="controls bullet"><span class="by">vitiral</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37549105">parent</a><span>|</span><a href="#37548892">next</a><span>|</span><label class="collapse" for="c-37550149">[-]</label><label class="expand" for="c-37550149">[1 more]</label></div><br/><div class="children"><div class="content">Common for large scale systems. IIUC wire lengths and connectors&#x2F;joints add impedence</div><br/></div></div></div></div><div id="37548892" class="c"><input type="checkbox" id="c-37548892" checked=""/><div class="controls bullet"><span class="by">0xDEF</span><span>|</span><a href="#37548842">parent</a><span>|</span><a href="#37549105">prev</a><span>|</span><a href="#37550728">next</a><span>|</span><label class="collapse" for="c-37548892">[-]</label><label class="expand" for="c-37548892">[3 more]</label></div><br/><div class="children"><div class="content">There is no way it implements the entire RV32I base profile. Maybe it only implements the instructions that are relevant for CS students taking a computer architecture class. That is typically what these breadboard CPUs implement.</div><br/><div id="37549027" class="c"><input type="checkbox" id="c-37549027" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37548892">parent</a><span>|</span><a href="#37550728">next</a><span>|</span><label class="collapse" for="c-37549027">[-]</label><label class="expand" for="c-37549027">[2 more]</label></div><br/><div class="children"><div class="content">RV32I is pretty tiny.  Particularly when you can squint hard enough at the spec.  FENCE can be a nop.  EBREAK and ECALL can be something like a halt of the machine.</div><br/><div id="37551312" class="c"><input type="checkbox" id="c-37551312" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#37548842">root</a><span>|</span><a href="#37549027">parent</a><span>|</span><a href="#37550728">next</a><span>|</span><label class="collapse" for="c-37551312">[-]</label><label class="expand" for="c-37551312">[1 more]</label></div><br/><div class="children"><div class="content">Arguably, RV32I <i>is</i> &quot;only the instructions that are relevant for CS students taking a computer architecture class&quot;, judging by the history in its earliest published spec [0].<p>[0] <a href="https:&#x2F;&#x2F;www2.eecs.berkeley.edu&#x2F;Pubs&#x2F;TechRpts&#x2F;2011&#x2F;EECS-2011-62.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www2.eecs.berkeley.edu&#x2F;Pubs&#x2F;TechRpts&#x2F;2011&#x2F;EECS-2011-...</a></div><br/></div></div></div></div></div></div></div></div><div id="37550728" class="c"><input type="checkbox" id="c-37550728" checked=""/><div class="controls bullet"><span class="by">pvachon</span><span>|</span><a href="#37548842">prev</a><span>|</span><a href="#37549630">next</a><span>|</span><label class="collapse" for="c-37550728">[-]</label><label class="expand" for="c-37550728">[1 more]</label></div><br/><div class="children"><div class="content">Where were these kids when Tom West was forming the team for what became the Data General MV&#x2F;8000?! Not many people building 32-bit CPUs out of discrete logic these days (and even in those days!).<p>(For those of you who don&#x27;t get the reference, I highly recommend &quot;The Soul of a New Machine&quot; by Tracy Kidder.)</div><br/></div></div><div id="37549630" class="c"><input type="checkbox" id="c-37549630" checked=""/><div class="controls bullet"><span class="by">ObscureMind</span><span>|</span><a href="#37550728">prev</a><span>|</span><a href="#37551394">next</a><span>|</span><label class="collapse" for="c-37549630">[-]</label><label class="expand" for="c-37549630">[2 more]</label></div><br/><div class="children"><div class="content">Along the lines of building a full computer out of discrete logic parts, slu4 created the Minimal 64, described in his Youtube channel: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;@slu467">https:&#x2F;&#x2F;www.youtube.com&#x2F;@slu467</a></div><br/><div id="37551635" class="c"><input type="checkbox" id="c-37551635" checked=""/><div class="controls bullet"><span class="by">TechBro8615</span><span>|</span><a href="#37549630">parent</a><span>|</span><a href="#37551394">next</a><span>|</span><label class="collapse" for="c-37551635">[-]</label><label class="expand" for="c-37551635">[1 more]</label></div><br/><div class="children"><div class="content">This guy built a 32-bit RISC-V CPU in Terraria: <a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=zXPiqk0-zDY">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=zXPiqk0-zDY</a></div><br/></div></div></div></div><div id="37551394" class="c"><input type="checkbox" id="c-37551394" checked=""/><div class="controls bullet"><span class="by">niccl</span><span>|</span><a href="#37549630">prev</a><span>|</span><a href="#37548761">next</a><span>|</span><label class="collapse" for="c-37551394">[-]</label><label class="expand" for="c-37551394">[1 more]</label></div><br/><div class="children"><div class="content">the video embedded in the page says over 230 discrete logic and memory devices. All SMD.<p>So the key, as someone else commented, is that there is a _lot_ of stuff going on in the eeproms. I don&#x27;t think it means this is any less of an amazing result</div><br/></div></div><div id="37548761" class="c"><input type="checkbox" id="c-37548761" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#37551394">prev</a><span>|</span><a href="#37549262">next</a><span>|</span><label class="collapse" for="c-37548761">[-]</label><label class="expand" for="c-37548761">[2 more]</label></div><br/><div class="children"><div class="content">Looking at their github: <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;</a> what exactly is this?  What&#x27;s the key repository with source?</div><br/><div id="37548980" class="c"><input type="checkbox" id="c-37548980" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37548761">parent</a><span>|</span><a href="#37549262">next</a><span>|</span><label class="collapse" for="c-37548980">[-]</label><label class="expand" for="c-37548980">[1 more]</label></div><br/><div class="children"><div class="content">Hardware seems to be at <a href="https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle">https:&#x2F;&#x2F;github.com&#x2F;pineapple-one&#x2F;hardware-eagle</a></div><br/></div></div></div></div><div id="37549262" class="c"><input type="checkbox" id="c-37549262" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#37548761">prev</a><span>|</span><a href="#37549343">next</a><span>|</span><label class="collapse" for="c-37549262">[-]</label><label class="expand" for="c-37549262">[8 more]</label></div><br/><div class="children"><div class="content">Hmmm.<p>Is a vertical stack like that really the best? Even if you are using large discrete chips like NAND gates or multiplexers, those connectors and 0.1&quot; headers obviously take up so much space.<p>And then the parasitics... Connectors like that will have resistance, capacitance and inductance that grossly complicates the flow of electricity.<p>I mean, PCB traces also have parasitic elements, but we humans are better able to understand a microstrip transmission line than... well.... Whatever is going on in that vertical stack.<p>It&#x27;s impressive nonetheless and a show of good work. My immediate revision would be maybe mounting the board vertically and running fewer layers. Some connectors and 0.1&quot; pin headers are useful, but you really shouldn&#x27;t have this meany IMO.</div><br/><div id="37549301" class="c"><input type="checkbox" id="c-37549301" checked=""/><div class="controls bullet"><span class="by">teraflop</span><span>|</span><a href="#37549262">parent</a><span>|</span><a href="#37549343">next</a><span>|</span><label class="collapse" for="c-37549301">[-]</label><label class="expand" for="c-37549301">[7 more]</label></div><br/><div class="children"><div class="content">At a 500kHz clock rate, with reasonable rise&#x2F;fall times, the electrical effect of some 0.1&quot; headers is minuscule. &quot;Microstrip transmission lines&quot; are enormous overkill.</div><br/><div id="37549683" class="c"><input type="checkbox" id="c-37549683" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#37549262">root</a><span>|</span><a href="#37549301">parent</a><span>|</span><a href="#37549449">next</a><span>|</span><label class="collapse" for="c-37549683">[-]</label><label class="expand" for="c-37549683">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Can do&quot; vs &quot;must do&quot; is the key here.<p>On a PCB, you &quot;can&quot; or you &quot;may&quot; perform advanced transmission line analysis upon your PCB traces. I don&#x27;t think that a project like this needs much more than a 2-layer board (so microstrips are definitely overkill), but that doesn&#x27;t change the fact that PCB parasitics analysis is basically a solved problem today and available on a lot of software packages.<p>Anyway, my overall point is that large contiguous blocks of PCB are easier than thinking about connector issues (or for the matter: being forced to solder and manage all those connectors or headers).<p>Not only is it easier to go header-free (and use a larger PCB), its better engineering due to tighter specs and analysis available.<p>------------<p>Now a bit of connector doodads and having fun is probably fun and all. But a stackup of 9x PCBs is reaching the point of absurdity. I can&#x27;t think of any good engineering reason to have so many connectors.<p>That&#x27;s 9-separate PCBs on this design, meaning at a minimum, 9-separate ground planes on this design. Is that... good engineering? I don&#x27;t think so. Its horribly complex but for seemingly no appreciable reason. Maybe sound &#x2F; analog circuits go on a separate board, but I&#x27;m not seeing any sound here...<p>------------<p>That being said: I agree that at 500kHz maybe this level of analysis is not needed. But... on the other hand... these 74xxxx chips all have 30ns rise&#x2F;fall times, so its not outside the realm of reality to be running this computer at 5MHz or 10MHz or so, 10x to 20x faster. At those higher speeds, you&#x27;ll possibly need to think about these issues a bit more (or perhaps... more appropriately I should say... the author of this project &quot;could have&quot; aimed at a higher-speed target if they so chose)</div><br/><div id="37550019" class="c"><input type="checkbox" id="c-37550019" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#37549262">root</a><span>|</span><a href="#37549683">parent</a><span>|</span><a href="#37549449">next</a><span>|</span><label class="collapse" for="c-37550019">[-]</label><label class="expand" for="c-37550019">[2 more]</label></div><br/><div class="children"><div class="content">What open source software would you recommend for PCB parasitics analysis?</div><br/><div id="37552671" class="c"><input type="checkbox" id="c-37552671" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#37549262">root</a><span>|</span><a href="#37550019">parent</a><span>|</span><a href="#37549449">next</a><span>|</span><label class="collapse" for="c-37552671">[-]</label><label class="expand" for="c-37552671">[1 more]</label></div><br/><div class="children"><div class="content">I dunno if anything is open source here... but the most important parameters are available on Javascript applications all over the place.<p><a href="https:&#x2F;&#x2F;saturnpcb.com&#x2F;saturn-pcb-toolkit&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;saturnpcb.com&#x2F;saturn-pcb-toolkit&#x2F;</a><p>I don&#x27;t think this tool is open source, but via inductance, various heat-equations, trace-width calculations and the like are available on this tool.<p>Its my understanding that higher-end PCB software integrates tools like these directly into the PCB-designers.<p>---------<p>KiCAD has simple calculators like the SaturnPCB.com one (though with fewer features). I&#x27;m not sure if more advanced calculators exist though.</div><br/></div></div></div></div></div></div><div id="37549449" class="c"><input type="checkbox" id="c-37549449" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#37549262">root</a><span>|</span><a href="#37549301">parent</a><span>|</span><a href="#37549683">prev</a><span>|</span><a href="#37549343">next</a><span>|</span><label class="collapse" for="c-37549449">[-]</label><label class="expand" for="c-37549449">[3 more]</label></div><br/><div class="children"><div class="content">Unless you want to get a beautiful spectrum on a EMI&#x2F;EMC test receiver, but it&#x27;s certainly not relevant in this project... Building a discrete CPU at some MHz and passing modern EMI&#x2F;EMC tests sound like a fun (and somewhat expensive [1]) nerd-snipping project to do.<p>[1] The expense of EMI&#x2F;EMC tests at an actual lab is well-known. Doing it in a home lab at a much lower expense is possible with pre-compliance tools like a TEM cell, a broadband antenna and a spectrum analyzer, but these equipment still costs a few thousand dollars.</div><br/><div id="37553331" class="c"><input type="checkbox" id="c-37553331" checked=""/><div class="controls bullet"><span class="by">mips_r4300i</span><span>|</span><a href="#37549262">root</a><span>|</span><a href="#37549449">parent</a><span>|</span><a href="#37549343">next</a><span>|</span><label class="collapse" for="c-37553331">[-]</label><label class="expand" for="c-37553331">[2 more]</label></div><br/><div class="children"><div class="content">If he uses HC logic and is careful to keep traces pulled back from the edge of the pcbs, and also carefully deals with the interconnects (those might be the killer) then he could probably pass EMC. Maybe some series termination on the clock tree.<p>At the speed it&#x27;s running, the edge rates of the IO drivers and the input&#x2F;output of the entire thing are the problem.</div><br/><div id="37553568" class="c"><input type="checkbox" id="c-37553568" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#37549262">root</a><span>|</span><a href="#37553331">parent</a><span>|</span><a href="#37549343">next</a><span>|</span><label class="collapse" for="c-37553568">[-]</label><label class="expand" for="c-37553568">[1 more]</label></div><br/><div class="children"><div class="content">A simple improvement of the interconnect is using two rows of pin headers, one rows for signals and another rows for dedicated grounds. This should significantly reduce the loop area. I once did a quick simulation and found that even controlled impedance is somewhat possible with 1.27 mm headers, although I haven&#x27;t done any experiment with it (yet)... Another possible modification is converting all I&#x2F;Os to differential signaling before they leave the board, a classic use is eliminating the radiation from long ribbon cables. Ribbon cables with ground planes also do exist if one&#x27;s willing to pay...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37549343" class="c"><input type="checkbox" id="c-37549343" checked=""/><div class="controls bullet"><span class="by">xrd</span><span>|</span><a href="#37549262">prev</a><span>|</span><a href="#37548936">next</a><span>|</span><label class="collapse" for="c-37549343">[-]</label><label class="expand" for="c-37549343">[3 more]</label></div><br/><div class="children"><div class="content">Everyone that comments here, please note a lot of this is based on the work of a high school kid from Czech Republic. That&#x27;s alone worth upvoting!<p>I am currently reading &quot;Gaming the Iron Curtain&quot; (<a href="https:&#x2F;&#x2F;ironcurtain.svelch.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ironcurtain.svelch.com&#x2F;</a>).  It&#x27;s about the incredible innovations happening in the Czech Republic before the fall of the wall and what people there did to participate in the computer revolution. This kid seems like he comes from that heritage!</div><br/><div id="37549977" class="c"><input type="checkbox" id="c-37549977" checked=""/><div class="controls bullet"><span class="by">ngcc_hk</span><span>|</span><a href="#37549343">parent</a><span>|</span><a href="#37549698">next</a><span>|</span><label class="collapse" for="c-37549977">[-]</label><label class="expand" for="c-37549977">[1 more]</label></div><br/><div class="children"><div class="content">You do not aware of this dimension if you just concentrate on the technical side.  Great comment.</div><br/></div></div></div></div><div id="37548862" class="c"><input type="checkbox" id="c-37548862" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37548936">prev</a><span>|</span><label class="collapse" for="c-37548862">[-]</label><label class="expand" for="c-37548862">[8 more]</label></div><br/><div class="children"><div class="content">&gt;Our goal is to prove that designing a “modern” CPU isn’t that hard<p>I don&#x27;t understand what is modern about the CPU that was designed. It looks like a toy CPU that got a marketing campaign made for it.</div><br/><div id="37549080" class="c"><input type="checkbox" id="c-37549080" checked=""/><div class="controls bullet"><span class="by">sethhochberg</span><span>|</span><a href="#37548862">parent</a><span>|</span><a href="#37549601">next</a><span>|</span><label class="collapse" for="c-37549080">[-]</label><label class="expand" for="c-37549080">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s fair enough in this case to say “modern” probably means “modern programming languages can compile to and run on it”<p>There’s some question in the comments here about how much of the ISA is actually implemented but it should theoretically be possible to write Rust code and run it on this thing, for example. There are many other toy CPU designs out there which are much more limited in terms of what can compile to run on them.</div><br/></div></div><div id="37549601" class="c"><input type="checkbox" id="c-37549601" checked=""/><div class="controls bullet"><span class="by">ninjha</span><span>|</span><a href="#37548862">parent</a><span>|</span><a href="#37549080">prev</a><span>|</span><a href="#37552231">next</a><span>|</span><label class="collapse" for="c-37549601">[-]</label><label class="expand" for="c-37549601">[1 more]</label></div><br/><div class="children"><div class="content">Architecture-wise, even a regular modern CPU isn&#x27;t <i>that</i> hard. For example, Berkeley has the BOOMv3 core[0] which is performance-competitive[1] with commercial chips taped out in the last few years. I think commercial chips are faster because of improvements in analog design, and not some super special architecture sauce (although I&#x27;m sure there&#x27;s <i>some</i> special sauce -- it&#x27;s probably not the defining factor).<p>[0]: <a href="https:&#x2F;&#x2F;boom-core.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;boom-core.org</a><p>[1]: <a href="https:&#x2F;&#x2F;carrv.github.io&#x2F;2020&#x2F;papers&#x2F;CARRV2020_paper_15_Zhao.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;carrv.github.io&#x2F;2020&#x2F;papers&#x2F;CARRV2020_paper_15_Zhao....</a></div><br/></div></div><div id="37552231" class="c"><input type="checkbox" id="c-37552231" checked=""/><div class="controls bullet"><span class="by">unmole</span><span>|</span><a href="#37548862">parent</a><span>|</span><a href="#37549601">prev</a><span>|</span><a href="#37551101">next</a><span>|</span><label class="collapse" for="c-37552231">[-]</label><label class="expand" for="c-37552231">[1 more]</label></div><br/><div class="children"><div class="content">Right because a RISC-V CPU isn&#x27;t <i>modern</i>.</div><br/></div></div><div id="37551101" class="c"><input type="checkbox" id="c-37551101" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#37548862">parent</a><span>|</span><a href="#37552231">prev</a><span>|</span><a href="#37551117">next</a><span>|</span><label class="collapse" for="c-37551101">[-]</label><label class="expand" for="c-37551101">[2 more]</label></div><br/><div class="children"><div class="content">A modern CPU needs two things:<p>1. Privilege levels with preemption.<p>2. Hardware support for virtual memory.<p>At that point, it can run OSes broadly similar to what most people are using in practice.</div><br/><div id="37551241" class="c"><input type="checkbox" id="c-37551241" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37548862">root</a><span>|</span><a href="#37551101">parent</a><span>|</span><a href="#37551117">next</a><span>|</span><label class="collapse" for="c-37551241">[-]</label><label class="expand" for="c-37551241">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. Modern refers to using the learnings and improvements that have been made over the last few decades of designing CPUs. To me including 2 features doesn&#x27;t necessarily make a design modern.</div><br/></div></div></div></div><div id="37551117" class="c"><input type="checkbox" id="c-37551117" checked=""/><div class="controls bullet"><span class="by">JBiserkov</span><span>|</span><a href="#37548862">parent</a><span>|</span><a href="#37551101">prev</a><span>|</span><label class="collapse" for="c-37551117">[-]</label><label class="expand" for="c-37551117">[2 more]</label></div><br/><div class="children"><div class="content">They put modern in quotes. What does that tell us?</div><br/><div id="37551274" class="c"><input type="checkbox" id="c-37551274" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#37548862">root</a><span>|</span><a href="#37551117">parent</a><span>|</span><label class="collapse" for="c-37551274">[-]</label><label class="expand" for="c-37551274">[1 more]</label></div><br/><div class="children"><div class="content">That they are building their design using discrete parts which is not a modern way thing to synthesize logic to.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>