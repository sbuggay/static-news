<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727341275470" as="style"/><link rel="stylesheet" href="styles.css?v=1727341275470"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://duriansoftware.com/joe/the-lost-language-extensions-of-metaware%27s-high-c-compiler">The lost language extensions of MetaWare&#x27;s High C compiler (2023)</a> <span class="domain">(<a href="https://duriansoftware.com">duriansoftware.com</a>)</span></div><div class="subtext"><span>PaulDavisThe1st</span> | <span>90 comments</span></div><br/><div><div id="41648525" class="c"><input type="checkbox" id="c-41648525" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#41650835">next</a><span>|</span><label class="collapse" for="c-41648525">[-]</label><label class="expand" for="c-41648525">[6 more]</label></div><br/><div class="children"><div class="content">I wrote up the iterator-driven for back in 2011, because it was one of those things that had been long-since forgotten about; along with what it would look like were it to be incorporated into the (then) C++ standard.<p>I am fortunate enough to own a copy of the High C&#x2F;C++ Language Reference in English.  (-:<p>* <a href="http:&#x2F;&#x2F;jdebp.uk.&#x2F;FGA&#x2F;metaware-iterator-driven-for.html" rel="nofollow">http:&#x2F;&#x2F;jdebp.uk.&#x2F;FGA&#x2F;metaware-iterator-driven-for.html</a><p>* <a href="http:&#x2F;&#x2F;jdebp.uk.&#x2F;Proposals&#x2F;metaware-iterator-driven-for.html" rel="nofollow">http:&#x2F;&#x2F;jdebp.uk.&#x2F;Proposals&#x2F;metaware-iterator-driven-for.html</a></div><br/><div id="41649404" class="c"><input type="checkbox" id="c-41649404" checked=""/><div class="controls bullet"><span class="by">jkcxn</span><span>|</span><a href="#41648525">parent</a><span>|</span><a href="#41650744">next</a><span>|</span><label class="collapse" for="c-41649404">[-]</label><label class="expand" for="c-41649404">[4 more]</label></div><br/><div class="children"><div class="content">Do you know how the break&#x2F;return would get compiled down to? Would the yield function need to be transformed to return a status code and checked at the callsite?</div><br/><div id="41649586" class="c"><input type="checkbox" id="c-41649586" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#41648525">root</a><span>|</span><a href="#41649404">parent</a><span>|</span><a href="#41651288">next</a><span>|</span><label class="collapse" for="c-41649586">[-]</label><label class="expand" for="c-41649586">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a non-local goto, also a MetaWare language extension, out of the anonymous nested function that the for statement body becomes to (effectively) an anonymous label right after the for statement.<p>Another part of the High C&#x2F;C++ Language Reference describes non-local labels and jumps to them.  It doesn&#x27;t go into great detail, but it does talk about stack unwinding, so expect something similar to how High C&#x2F;C++ implemented throwing exceptions.</div><br/></div></div><div id="41651288" class="c"><input type="checkbox" id="c-41651288" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#41648525">root</a><span>|</span><a href="#41649404">parent</a><span>|</span><a href="#41649586">prev</a><span>|</span><a href="#41650744">next</a><span>|</span><label class="collapse" for="c-41651288">[-]</label><label class="expand" for="c-41651288">[2 more]</label></div><br/><div class="children"><div class="content">Not sure, but imo you could do it with basically reversing the call&#x2F;return mechanism - that is, whenever the iterator function returns, it saves its state to the stack, just like if it would during a function call, and conversely, when the outside context hands back the control to the iterator, it would restore its state, analogous to how a return from an outside context would work.</div><br/><div id="41651720" class="c"><input type="checkbox" id="c-41651720" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#41648525">root</a><span>|</span><a href="#41651288">parent</a><span>|</span><a href="#41650744">next</a><span>|</span><label class="collapse" for="c-41651720">[-]</label><label class="expand" for="c-41651720">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not at all how MetaWare implemented iterator-driven for, though.<p>As Joe Groff said in the headlined post, MetaWare implemented it by turning the nested body of the for statement into an anonymous nested function, which is called back (through a &quot;full function pointer&quot;) from the iterator function whenever there&#x27;s a &quot;yield()&quot; in that latter.<p>So there&#x27;s no &quot;whenever the iterator function returns&quot;.  It only returns when it has finished.  The body of the for statement is called by and returns to the iterator function, which is in its turn called by and returns to the function that the for statement is in.<p>All of the &quot;saving state to the stack&quot; that happens is just the quite normal mechanics of function calling, with merely some special mechanics to pass around a pointer to the lexically outer function&#x27;s activation record (which is why a &quot;full function pointer&quot; is not a plain &quot;function pointer&quot;) as a hidden parameter so that the (anonymous) lexically inner function knows where the outer one&#x27;s automatic storage duration variables are.<p>MetaWare also had non-local goto from within nested functions back out into lexically enclosing scopes, and since the for statement body is a nested function, it&#x27;s just a question of employing that already available implementation mechanism (which in turn does the same sorts of things as throwing exceptions does, unwinding the stack through the iterator function) for break&#x2F;continue&#x2F;return (and of course goto) inside the for body.</div><br/></div></div></div></div></div></div><div id="41650744" class="c"><input type="checkbox" id="c-41650744" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#41648525">parent</a><span>|</span><a href="#41649404">prev</a><span>|</span><a href="#41650835">next</a><span>|</span><label class="collapse" for="c-41650744">[-]</label><label class="expand" for="c-41650744">[1 more]</label></div><br/><div class="children"><div class="content">Is that supposed to be an upside-down smiley face?</div><br/></div></div></div></div><div id="41650835" class="c"><input type="checkbox" id="c-41650835" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41648525">prev</a><span>|</span><a href="#41650845">next</a><span>|</span><label class="collapse" for="c-41650835">[-]</label><label class="expand" for="c-41650835">[14 more]</label></div><br/><div class="children"><div class="content">D (also in Das BetterC) has:<p>1. underscores in literals:<p><pre><code>    int a = 1_234_567;
</code></pre>
2. case ranges:<p><pre><code>    case 5 .. case 6:
</code></pre>
3. named arguments:<p><pre><code>    void test(int a, int b);

    void foo() { test(b:3, a:4); }
</code></pre>
4. nested functions:<p><pre><code>    int foo(int i) {
      int plus(int a) { return a + i; }
      return plus(3);
    }
</code></pre>
5. static nested functions:<p><pre><code>    int foo(int i) {
      static int plus(int a) { return a + i; }
      return plus(3);
    }

    Error: `static` function `test.foo.plus` cannot access variable `i` in frame of function `test.foo`
</code></pre>
6. a feature similar to generators <a href="https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;statement.html#foreach_over_struct_and_classes" rel="nofollow">https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;statement.html#foreach_over_struct_an...</a></div><br/><div id="41651013" class="c"><input type="checkbox" id="c-41651013" checked=""/><div class="controls bullet"><span class="by">nialv7</span><span>|</span><a href="#41650835">parent</a><span>|</span><a href="#41654632">next</a><span>|</span><label class="collapse" for="c-41651013">[-]</label><label class="expand" for="c-41651013">[11 more]</label></div><br/><div class="children"><div class="content">I was thinking about D the whole way while reading this. I just know I am going to see Walter Bright in the comments XD.</div><br/><div id="41653677" class="c"><input type="checkbox" id="c-41653677" checked=""/><div class="controls bullet"><span class="by">amy-petrik-214</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41651013">parent</a><span>|</span><a href="#41651831">next</a><span>|</span><label class="collapse" for="c-41653677">[-]</label><label class="expand" for="c-41653677">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking D but also there is basically a superset of D and HighC that incorporates best of both worlds, some people here may know it, it&#x27;s called &quot;Holy C&quot; and it was the basis for a new operating system in the same way C was tightly integrated with UNIX.  Written by Saint Terry</div><br/></div></div><div id="41651831" class="c"><input type="checkbox" id="c-41651831" checked=""/><div class="controls bullet"><span class="by">hermanhermitage</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41651013">parent</a><span>|</span><a href="#41653677">prev</a><span>|</span><a href="#41654632">next</a><span>|</span><label class="collapse" for="c-41651831">[-]</label><label class="expand" for="c-41651831">[9 more]</label></div><br/><div class="children"><div class="content">Every time Walter posts it reminds me my dream language would simply be C with <a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a> and probably go lang style interfaces. Maybe a little less UB and some extensions for memory safety proofs.</div><br/><div id="41651953" class="c"><input type="checkbox" id="c-41651953" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41651831">parent</a><span>|</span><a href="#41652887">next</a><span>|</span><label class="collapse" for="c-41651953">[-]</label><label class="expand" for="c-41651953">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why DasBetterC has done very well! You could call it C with array bounds checking.<p>I occasionally look at statistics on the sources of bugs and security problems in released software. Array bounds overflows far and away are the top cause.<p>Why aren&#x27;t people just sick of array overflows? In the latest C and C++ versions, all kinds of new features are trumpeted, but again no progress on array overflows.<p>I can confidently say that in the 2 decades of D in production use, the incidence of array overflows has dropped to essentially zero. (To trigger a runtime array overflow, you have to write @system code and throw a compiler switch.)<p>The solution for C I proposed is backwards compatible, and does not make existing code slower.<p>It would be the greatest feature added to C, singularly worth more than all the other stuff in C23.</div><br/><div id="41655694" class="c"><input type="checkbox" id="c-41655694" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41651953">parent</a><span>|</span><a href="#41652863">next</a><span>|</span><label class="collapse" for="c-41655694">[-]</label><label class="expand" for="c-41655694">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t even understand how the flip from having C++ collection frameworks being bounds checked by default (Turbo Vision, BIDS, OWL, MFC, Powerplant,...) ended happing, with C++98 getting a standard library that does exactly the opposite by default, and a strong cultural resistance on WG21 to change it until goverments started talking about security liabilities and what programming languages to accept in public projects.<p>As for WG14, I have no hope, they ignored several proposals, and seem keen in having C being as safe as hand writing Assembly code, and even then, Assembly tends to be safer, as UB only happens when doing something the CPU did not expect, macro assemblers don&#x27;t do clever optimizations.</div><br/></div></div><div id="41652863" class="c"><input type="checkbox" id="c-41652863" checked=""/><div class="controls bullet"><span class="by">bakul</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41651953">parent</a><span>|</span><a href="#41655694">prev</a><span>|</span><a href="#41652159">next</a><span>|</span><label class="collapse" for="c-41652863">[-]</label><label class="expand" for="c-41652863">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The solution for C I proposed is backwards compatible, and does not make existing code slower.<p>Where can I read about it? The only way to make ptrs to array elements also safe that I can think of, is to replace them with triples: (base, element ptr, limit).</div><br/><div id="41653058" class="c"><input type="checkbox" id="c-41653058" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41652863">parent</a><span>|</span><a href="#41652159">next</a><span>|</span><label class="collapse" for="c-41653058">[-]</label><label class="expand" for="c-41653058">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a></div><br/><div id="41654534" class="c"><input type="checkbox" id="c-41654534" checked=""/><div class="controls bullet"><span class="by">bakul</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41653058">parent</a><span>|</span><a href="#41652159">next</a><span>|</span><label class="collapse" for="c-41654534">[-]</label><label class="expand" for="c-41654534">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. I got interested in this topic as people are talking about writing OS kernel code in Rust but a) it only helps new code and b) very hard to justify rewriting millions of lines of C code in Rust (plus rewrites are never 100% faithful feature wise). If on the other hand if C can be made safer, may be through a stepwise process where the code is rewritten incrementally to pass through C-&gt;C0-&gt;C1-&gt;Cn compilers, each making incremental language changes, much more of code can be made safer. It will never be as good as Rust but I do think this space is worth exploring.</div><br/></div></div></div></div></div></div><div id="41652159" class="c"><input type="checkbox" id="c-41652159" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41651953">parent</a><span>|</span><a href="#41652863">prev</a><span>|</span><a href="#41652887">next</a><span>|</span><label class="collapse" for="c-41652159">[-]</label><label class="expand" for="c-41652159">[1 more]</label></div><br/><div class="children"><div class="content">I don’t always agree but I’ll join you on this particular hill!</div><br/></div></div></div></div><div id="41652887" class="c"><input type="checkbox" id="c-41652887" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41651831">parent</a><span>|</span><a href="#41651953">prev</a><span>|</span><a href="#41654984">next</a><span>|</span><label class="collapse" for="c-41652887">[-]</label><label class="expand" for="c-41652887">[1 more]</label></div><br/><div class="children"><div class="content">When writing software I almost never find myself in a situation where UB is a design concern or needs to be factored around in the structure.<p>I almost always find myself struggling to name and namespace things correctly for long term durability.  Almost all compiled languages get this wrong.  They generally force you to consider this before you start writing code so you can explore the shape of the solution first.<p>I think lisp is the only language I&#x27;ve used where this wasn&#x27;t a burden,  but in reality,  lisp then forces you to deeply ponder your data structures and access ideology first,  so I didn&#x27;t find it to be that rewarding in the long run.<p>I love that Go lets you bang simple &quot;method like functions&quot; straight onto the type.  This solves the first layer of namespace problems.  It does nothing for the second though,  and in fact makes it worse,  by applying &quot;style guidelines&quot; to the names of the containing types.  I am constantly let down by this when writing Go code and I find it hard to write &quot;good looking&quot; code in the language which is all the more frustrating because this was what the guidelines were supposed to solve in the first place.<p>I really just want C and I want to namespace my functions that act on structs into the structs themselves.  Then I can name stuff however I want and I don&#x27;t have to prefix_every_single_function() just so the me and the assembler can fully agree on the unmangled symbol table name which I will almost certainly never care about in 99% of what I compile.<p>There&#x27;s a real joy to the fast initial development and easy refactoring you can find in scripting languages.  Too bad they all have wacky C interfaces and are slower than molasses.</div><br/></div></div><div id="41654984" class="c"><input type="checkbox" id="c-41654984" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#41650835">root</a><span>|</span><a href="#41651831">parent</a><span>|</span><a href="#41652887">prev</a><span>|</span><a href="#41654632">next</a><span>|</span><label class="collapse" for="c-41654984">[-]</label><label class="expand" for="c-41654984">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps C3? It has interfaces, slices, array iterators and bills itself as &quot;an evolution of C (not revolution) with full ABI compatibility&quot;.<p>--<p>1: <a href="https:&#x2F;&#x2F;c3-lang.org&#x2F;generic-programming&#x2F;anyinterfaces&#x2F;" rel="nofollow">https:&#x2F;&#x2F;c3-lang.org&#x2F;generic-programming&#x2F;anyinterfaces&#x2F;</a></div><br/></div></div></div></div></div></div><div id="41654632" class="c"><input type="checkbox" id="c-41654632" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#41650835">parent</a><span>|</span><a href="#41651013">prev</a><span>|</span><a href="#41652613">next</a><span>|</span><label class="collapse" for="c-41654632">[-]</label><label class="expand" for="c-41654632">[1 more]</label></div><br/><div class="children"><div class="content">Questions?<p>You got any idea why people hate the concept of nested functions in C?<p>Why named named arguments test( a:4, b:3) instead of test(.a=4, b.=3);<p>Have any idea how you would handle first class types in C.</div><br/></div></div></div></div><div id="41650845" class="c"><input type="checkbox" id="c-41650845" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#41650835">prev</a><span>|</span><a href="#41648959">next</a><span>|</span><label class="collapse" for="c-41650845">[-]</label><label class="expand" for="c-41650845">[1 more]</label></div><br/><div class="children"><div class="content">Related: The &#x27;lcc-win&#x27; C compiler added operator overloading, default function arguments, and function overloading (see &quot;generic functions&quot;) [1]. The Plan 9 C compiler introduced several language extensions, some of which, like anonymous structs&#x2F;unions would eventually be incorporated into the C standard. Present day GCC accepts the -fplan9-extensions flag [2] which enables some nifty features, like automatically converting a struct pointer to an anonymous field for function calls and assignments.<p>[1] <a href="https:&#x2F;&#x2F;lcc-win32.services.net&#x2F;C-Tutorial.pdf" rel="nofollow">https:&#x2F;&#x2F;lcc-win32.services.net&#x2F;C-Tutorial.pdf</a><p>[2] <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Unnamed-Fields.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Unnamed-Fields.html</a></div><br/></div></div><div id="41648959" class="c"><input type="checkbox" id="c-41648959" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#41650845">prev</a><span>|</span><a href="#41648502">next</a><span>|</span><label class="collapse" for="c-41648959">[-]</label><label class="expand" for="c-41648959">[8 more]</label></div><br/><div class="children"><div class="content">Who was the genius behind these features?  Someone was incredibly forward looking in that company.  Too bad it never got out into the world and impacted the language standards.  It is surprising to see that so long ago.<p>Also previously covered here on Hacker News: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38938402">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38938402</a><p>Is there a PDF copy of this somewhere?</div><br/><div id="41650545" class="c"><input type="checkbox" id="c-41650545" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41648959">parent</a><span>|</span><a href="#41650024">next</a><span>|</span><label class="collapse" for="c-41650545">[-]</label><label class="expand" for="c-41650545">[3 more]</label></div><br/><div class="children"><div class="content">CLU had <i>for</i> loops with iterators (generators) and <i>yield</i> in the mid–late 1970s [0]. The Icon programming language around the same time had similar generator features [1] (with <i>yield</i> spelled “suspend”). Ada (1983) also had such features I believe. These weren’t completely unknown language features.<p>[0] <a href="https:&#x2F;&#x2F;publications.csail.mit.edu&#x2F;lcs&#x2F;pubs&#x2F;pdf&#x2F;MIT-LCS-TR-225.pdf" rel="nofollow">https:&#x2F;&#x2F;publications.csail.mit.edu&#x2F;lcs&#x2F;pubs&#x2F;pdf&#x2F;MIT-LCS-TR-2...</a><p>[1] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;800055.802034" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;800055.802034</a></div><br/><div id="41651241" class="c"><input type="checkbox" id="c-41651241" checked=""/><div class="controls bullet"><span class="by">Agingcoder</span><span>|</span><a href="#41648959">root</a><span>|</span><a href="#41650545">parent</a><span>|</span><a href="#41650024">next</a><span>|</span><label class="collapse" for="c-41651241">[-]</label><label class="expand" for="c-41651241">[2 more]</label></div><br/><div class="children"><div class="content">Ada didn’t have generators back then and still doesn’t ( I think its being considered for inclusion soon ).  But it had all the other features.</div><br/><div id="41653432" class="c"><input type="checkbox" id="c-41653432" checked=""/><div class="controls bullet"><span class="by">LiamPowell</span><span>|</span><a href="#41648959">root</a><span>|</span><a href="#41651241">parent</a><span>|</span><a href="#41650024">next</a><span>|</span><label class="collapse" for="c-41653432">[-]</label><label class="expand" for="c-41653432">[1 more]</label></div><br/><div class="children"><div class="content">A task type with an entry is effectively a generator.</div><br/></div></div></div></div></div></div><div id="41650024" class="c"><input type="checkbox" id="c-41650024" checked=""/><div class="controls bullet"><span class="by">dfawcus</span><span>|</span><a href="#41648959">parent</a><span>|</span><a href="#41650545">prev</a><span>|</span><a href="#41651054">next</a><span>|</span><label class="collapse" for="c-41650024">[-]</label><label class="expand" for="c-41650024">[1 more]</label></div><br/><div class="children"><div class="content">Bitsavers has a copy of the HC 1.2 reference manual (1985)<p>It describes underscores in numbers, case ranges, named parameters, nested functions, and full function variables.<p><pre><code>    https:&#x2F;&#x2F;bitsavers.org&#x2F;pdf&#x2F;metaware&#x2F;High_C_Language_Reference_Manual_1.2_Nov85.pdf
</code></pre>
See Appendix A - 50 odd pages from the end of the file.</div><br/></div></div><div id="41651054" class="c"><input type="checkbox" id="c-41651054" checked=""/><div class="controls bullet"><span class="by">jmspring</span><span>|</span><a href="#41648959">parent</a><span>|</span><a href="#41650024">prev</a><span>|</span><a href="#41655730">next</a><span>|</span><label class="collapse" for="c-41651054">[-]</label><label class="expand" for="c-41651054">[1 more]</label></div><br/><div class="children"><div class="content">Metaware was a prolific compiler company based out of Santa Cruz in the 80s&#x2F;90s.  Loved what they did, they also had a very interesting culture.  I knew about them through <i>cough</i> <i>shady</i> <i>cough</i> sites when learning and writing code back in the day.</div><br/></div></div><div id="41655730" class="c"><input type="checkbox" id="c-41655730" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41648959">parent</a><span>|</span><a href="#41651054">prev</a><span>|</span><a href="#41651085">next</a><span>|</span><label class="collapse" for="c-41655730">[-]</label><label class="expand" for="c-41655730">[1 more]</label></div><br/><div class="children"><div class="content">Not really, if you dig into archives of high level programming languages since FORTRAN, Lisp, ALGOL and COBOL sprung into existence, you will see lots of these language ideas.<p>You will also discover the rich history of systems programming languages, and how similar C and Go design&#x27;s are in ignoring what was being done in other ecosystems, and past experiences.</div><br/></div></div><div id="41651085" class="c"><input type="checkbox" id="c-41651085" checked=""/><div class="controls bullet"><span class="by">canucker2016</span><span>|</span><a href="#41648959">parent</a><span>|</span><a href="#41655730">prev</a><span>|</span><a href="#41648502">next</a><span>|</span><label class="collapse" for="c-41651085">[-]</label><label class="expand" for="c-41651085">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s sad to see those features as novel features instead of part of the standard list of features most programming languages supply.<p>There&#x27;s a link to the compiler manuals at <a href="https:&#x2F;&#x2F;winworldpc.com&#x2F;product&#x2F;metaware-high-c-cpp&#x2F;33x" rel="nofollow">https:&#x2F;&#x2F;winworldpc.com&#x2F;product&#x2F;metaware-high-c-cpp&#x2F;33x</a><p>The C manual PDF file mentions a 2007 copyright.</div><br/></div></div></div></div><div id="41648502" class="c"><input type="checkbox" id="c-41648502" checked=""/><div class="controls bullet"><span class="by">stefanos82</span><span>|</span><a href="#41648959">prev</a><span>|</span><a href="#41649075">next</a><span>|</span><label class="collapse" for="c-41648502">[-]</label><label class="expand" for="c-41648502">[4 more]</label></div><br/><div class="children"><div class="content">Previous submission with comments <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38938402">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38938402</a></div><br/><div id="41648617" class="c"><input type="checkbox" id="c-41648617" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#41648502">parent</a><span>|</span><a href="#41648549">next</a><span>|</span><label class="collapse" for="c-41648617">[-]</label><label class="expand" for="c-41648617">[1 more]</label></div><br/><div class="children"><div class="content">It has no doubt come up again here because Joe Groff just drew attention to it today on the FediVerse.<p>* <a href="https:&#x2F;&#x2F;f.duriansoftware.com&#x2F;@joe&#x2F;113195961485703110" rel="nofollow">https:&#x2F;&#x2F;f.duriansoftware.com&#x2F;@joe&#x2F;113195961485703110</a></div><br/></div></div><div id="41648549" class="c"><input type="checkbox" id="c-41648549" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41648502">parent</a><span>|</span><a href="#41648617">prev</a><span>|</span><a href="#41649075">next</a><span>|</span><label class="collapse" for="c-41648549">[-]</label><label class="expand" for="c-41648549">[2 more]</label></div><br/><div class="children"><div class="content">Seems that the author of the piece reposted the same contents at a different URL yesterday. Odd.</div><br/><div id="41648577" class="c"><input type="checkbox" id="c-41648577" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41648502">root</a><span>|</span><a href="#41648549">parent</a><span>|</span><a href="#41649075">next</a><span>|</span><label class="collapse" for="c-41648577">[-]</label><label class="expand" for="c-41648577">[1 more]</label></div><br/><div class="children"><div class="content">Because cohost is shutting down <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41492807">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41492807</a></div><br/></div></div></div></div></div></div><div id="41649075" class="c"><input type="checkbox" id="c-41649075" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41648502">prev</a><span>|</span><a href="#41654116">next</a><span>|</span><label class="collapse" for="c-41649075">[-]</label><label class="expand" for="c-41649075">[6 more]</label></div><br/><div class="children"><div class="content">For anyone wondering why the string literals in the pictured examples end with ¥n rather than \n, it looks like these code examples were written in Shift-JIS, and Shift-JIS puts ¥ where ASCII has \.</div><br/><div id="41650366" class="c"><input type="checkbox" id="c-41650366" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41649075">parent</a><span>|</span><a href="#41651368">next</a><span>|</span><label class="collapse" for="c-41650366">[-]</label><label class="expand" for="c-41650366">[2 more]</label></div><br/><div class="children"><div class="content">This was originally just JIS Roman [0], the Japanese ASCII variant from 1969. Shift-JIS is what much later then added double-byte character set support.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;JIS_X_0201" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;JIS_X_0201</a></div><br/><div id="41653106" class="c"><input type="checkbox" id="c-41653106" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41649075">root</a><span>|</span><a href="#41650366">parent</a><span>|</span><a href="#41651368">next</a><span>|</span><label class="collapse" for="c-41653106">[-]</label><label class="expand" for="c-41653106">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the correction; you&#x27;re right.</div><br/></div></div></div></div><div id="41651368" class="c"><input type="checkbox" id="c-41651368" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#41649075">parent</a><span>|</span><a href="#41650366">prev</a><span>|</span><a href="#41650271">next</a><span>|</span><label class="collapse" for="c-41651368">[-]</label><label class="expand" for="c-41651368">[1 more]</label></div><br/><div class="children"><div class="content">The problem with that is that the ASCII code for a backslash is also used as the second byte in a 2 byte character in Shift-JIS, which can sometimes cause Japanese string literals to not work properly in C. EUC-JP is better for this purpose, because it does not have that problem. (Using Shift-JIS with Pascal also does not have this problem, if you are using the (* *) comments instead of the { } comments.)</div><br/></div></div><div id="41650271" class="c"><input type="checkbox" id="c-41650271" checked=""/><div class="controls bullet"><span class="by">Eduard</span><span>|</span><a href="#41649075">parent</a><span>|</span><a href="#41651368">prev</a><span>|</span><a href="#41649128">next</a><span>|</span><label class="collapse" for="c-41650271">[-]</label><label class="expand" for="c-41650271">[1 more]</label></div><br/><div class="children"><div class="content">The author didn&#x27;t provide information about when this book came out, nor is there any information to find on it. But I think at the book&#x27;s release, Shift-JIS (the standard) didn&#x27;t exist yet.<p>Rather JIS X 0201 ( <a href="https:&#x2F;&#x2F;en.m.wikipedia.org.org&#x2F;wiki&#x2F;JIS_X_0201" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org.org&#x2F;wiki&#x2F;JIS_X_0201</a> ) was used, on which Shift-JIS is based.</div><br/></div></div><div id="41649128" class="c"><input type="checkbox" id="c-41649128" checked=""/><div class="controls bullet"><span class="by">nazgulsenpai</span><span>|</span><a href="#41649075">parent</a><span>|</span><a href="#41650271">prev</a><span>|</span><a href="#41654116">next</a><span>|</span><label class="collapse" for="c-41649128">[-]</label><label class="expand" for="c-41649128">[1 more]</label></div><br/><div class="children"><div class="content">Similarly, Japanese DOS prompts are C:¥ instead of C:\</div><br/></div></div></div></div><div id="41654116" class="c"><input type="checkbox" id="c-41654116" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#41649075">prev</a><span>|</span><a href="#41649112">next</a><span>|</span><label class="collapse" for="c-41654116">[-]</label><label class="expand" for="c-41654116">[1 more]</label></div><br/><div class="children"><div class="content">The generators remind me of Rust&#x27;s internal&#x2F;external iteration question and try_fold() (<a href="https:&#x2F;&#x2F;scribe.rip&#x2F;@veedrac&#x2F;rust-is-slow-and-i-am-the-cure-32facc0fdcb" rel="nofollow">https:&#x2F;&#x2F;scribe.rip&#x2F;@veedrac&#x2F;rust-is-slow-and-i-am-the-cure-3...</a>).</div><br/></div></div><div id="41649112" class="c"><input type="checkbox" id="c-41649112" checked=""/><div class="controls bullet"><span class="by">lexicality</span><span>|</span><a href="#41654116">prev</a><span>|</span><a href="#41650256">next</a><span>|</span><label class="collapse" for="c-41649112">[-]</label><label class="expand" for="c-41649112">[2 more]</label></div><br/><div class="children"><div class="content">Content aside, I&#x27;m fascinated by the typography in this book. It&#x27;s simultaneously beautiful and horrendous!<p>I don&#x27;t know enough about Japanese orthography or keming rules to be sure but it looks very much like they took a variable width font with both kanji and latin characters and then hard formatted it into fixed width cells?<p>Either way, it&#x27;s nice that the code examples aren&#x27;t in 8pt font like a lot of the books I have...</div><br/><div id="41649197" class="c"><input type="checkbox" id="c-41649197" checked=""/><div class="controls bullet"><span class="by">_delirium</span><span>|</span><a href="#41649112">parent</a><span>|</span><a href="#41650256">next</a><span>|</span><label class="collapse" for="c-41649197">[-]</label><label class="expand" for="c-41649197">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty common in Japanese typography that mixes in Latin characters, especially in older fonts. Pretty decent explanation here: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;typography&#x2F;comments&#x2F;vvfmpu&#x2F;comment&#x2F;ifk0f6k&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;typography&#x2F;comments&#x2F;vvfmpu&#x2F;comment&#x2F;...</a></div><br/></div></div></div></div><div id="41650256" class="c"><input type="checkbox" id="c-41650256" checked=""/><div class="controls bullet"><span class="by">AdmiralAsshat</span><span>|</span><a href="#41649112">prev</a><span>|</span><a href="#41648996">next</a><span>|</span><label class="collapse" for="c-41650256">[-]</label><label class="expand" for="c-41650256">[3 more]</label></div><br/><div class="children"><div class="content">Question: Was the book from the screenshots composed in Japanese, or composed in English and then translated into Japanese?<p>Since it&#x27;s apparently from Fujitsu, I could see it being the former, but if so, I&#x27;m impressed with the quality of the English in the printf statements and code comments from non-native English speakers.</div><br/><div id="41655486" class="c"><input type="checkbox" id="c-41655486" checked=""/><div class="controls bullet"><span class="by">steinuil</span><span>|</span><a href="#41650256">parent</a><span>|</span><a href="#41650599">next</a><span>|</span><label class="collapse" for="c-41655486">[-]</label><label class="expand" for="c-41655486">[1 more]</label></div><br/><div class="children"><div class="content">The engineers who wrote the High C compiler must have been able to read and write english well enough to have read documentation and source code for existing compilers, and I would imagine that this book was written by the creators of the language.</div><br/></div></div><div id="41650599" class="c"><input type="checkbox" id="c-41650599" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41650256">parent</a><span>|</span><a href="#41655486">prev</a><span>|</span><a href="#41648996">next</a><span>|</span><label class="collapse" for="c-41650599">[-]</label><label class="expand" for="c-41650599">[1 more]</label></div><br/><div class="children"><div class="content">It’s funny they’re using different fonts within the string literals.</div><br/></div></div></div></div><div id="41648996" class="c"><input type="checkbox" id="c-41648996" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41650256">prev</a><span>|</span><a href="#41650665">next</a><span>|</span><label class="collapse" for="c-41648996">[-]</label><label class="expand" for="c-41648996">[1 more]</label></div><br/><div class="children"><div class="content">Old memories, I had access to the MS-DOS version of it, still preferred Borland though.</div><br/></div></div><div id="41650665" class="c"><input type="checkbox" id="c-41650665" checked=""/><div class="controls bullet"><span class="by">dsp_person</span><span>|</span><a href="#41648996">prev</a><span>|</span><a href="#41648991">next</a><span>|</span><label class="collapse" for="c-41650665">[-]</label><label class="expand" for="c-41650665">[1 more]</label></div><br/><div class="children"><div class="content">Are there are good unofficial gcc plugins&#x2F;extensions out there? It would be cool to extend C with a thing or two without adopting a full blown compiler like C2 or C3.</div><br/></div></div><div id="41648991" class="c"><input type="checkbox" id="c-41648991" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#41650665">prev</a><span>|</span><a href="#41650712">next</a><span>|</span><label class="collapse" for="c-41648991">[-]</label><label class="expand" for="c-41648991">[8 more]</label></div><br/><div class="children"><div class="content">This seems way ahead of its time, especially with generators.  Maybe Fujitsu was able to just do it because they didn&#x27;t bother with any of the lengthy standardization processes, but that&#x27;s probably also why all these extensions seemed relatively unknown and had to be rediscovered and reinvented in modern C&#x2F;C++ decades later.</div><br/><div id="41649478" class="c"><input type="checkbox" id="c-41649478" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#41648991">parent</a><span>|</span><a href="#41649122">next</a><span>|</span><label class="collapse" for="c-41649478">[-]</label><label class="expand" for="c-41649478">[1 more]</label></div><br/><div class="children"><div class="content">It was not Fujitsu.  It was MetaWare, which had a fair degree of experience with compilers.  It had a contemporaneous Pascal compiler, which was quite well known, and Pascal already had nested functions.</div><br/></div></div><div id="41649122" class="c"><input type="checkbox" id="c-41649122" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#41648991">parent</a><span>|</span><a href="#41649478">prev</a><span>|</span><a href="#41649697">next</a><span>|</span><label class="collapse" for="c-41649122">[-]</label><label class="expand" for="c-41649122">[5 more]</label></div><br/><div class="children"><div class="content">C could have been a much nicer language if it wasn’t captured by people who insisted that not even two’s complement can be in the standard.</div><br/><div id="41649707" class="c"><input type="checkbox" id="c-41649707" checked=""/><div class="controls bullet"><span class="by">dxuh</span><span>|</span><a href="#41648991">root</a><span>|</span><a href="#41649122">parent</a><span>|</span><a href="#41653973">next</a><span>|</span><label class="collapse" for="c-41649707">[-]</label><label class="expand" for="c-41649707">[1 more]</label></div><br/><div class="children"><div class="content">I guess those people were parts of the embedded software industry before 2000 (maybe today, I don&#x27;t know). It&#x27;s a very good thing that C, the lingua franca of modern computing, actually runs on everything and not just on the stuff we use to browse the internet.</div><br/></div></div><div id="41653973" class="c"><input type="checkbox" id="c-41653973" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#41648991">root</a><span>|</span><a href="#41649122">parent</a><span>|</span><a href="#41649707">prev</a><span>|</span><a href="#41649846">next</a><span>|</span><label class="collapse" for="c-41653973">[-]</label><label class="expand" for="c-41653973">[2 more]</label></div><br/><div class="children"><div class="content">There was a lot more innovation in computer architectures in the 80s and 90s. C89 is designed to permit implementation on unconventional hardware like the Lisp machine. C&#x27;s flexible targeting is its greatest asset.</div><br/><div id="41654655" class="c"><input type="checkbox" id="c-41654655" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#41648991">root</a><span>|</span><a href="#41653973">parent</a><span>|</span><a href="#41649846">next</a><span>|</span><label class="collapse" for="c-41654655">[-]</label><label class="expand" for="c-41654655">[1 more]</label></div><br/><div class="children"><div class="content">Yep right when everyone<p><pre><code>   1. Standardized on two&#x27;s complement.
   2. Little endian.
   3. We went from word based memory systems to line based ones.
   4. RISC lost out to super scalar designs.</code></pre></div><br/></div></div></div></div><div id="41649846" class="c"><input type="checkbox" id="c-41649846" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41648991">root</a><span>|</span><a href="#41649122">parent</a><span>|</span><a href="#41653973">prev</a><span>|</span><a href="#41649697">next</a><span>|</span><label class="collapse" for="c-41649846">[-]</label><label class="expand" for="c-41649846">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it was unreasonable at the time ANSI did the standardization originally. As with Common Lisp, they had to consider the numerous already-existing implementations and code written with them in mind.</div><br/></div></div></div></div><div id="41649697" class="c"><input type="checkbox" id="c-41649697" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41648991">parent</a><span>|</span><a href="#41649122">prev</a><span>|</span><a href="#41650712">next</a><span>|</span><label class="collapse" for="c-41649697">[-]</label><label class="expand" for="c-41649697">[1 more]</label></div><br/><div class="children"><div class="content">Coroutines and generators were already well-understood then (see Icon!), so I think it is indeed mostly about not having to worry about standardization.</div><br/></div></div></div></div><div id="41650712" class="c"><input type="checkbox" id="c-41650712" checked=""/><div class="controls bullet"><span class="by">Sad90sNerd</span><span>|</span><a href="#41648991">prev</a><span>|</span><a href="#41650732">next</a><span>|</span><label class="collapse" for="c-41650712">[-]</label><label class="expand" for="c-41650712">[3 more]</label></div><br/><div class="children"><div class="content">These extensions are Ada features.<p>Ada has:<p>- Labels in the form of: Call (Param_A =&gt; 1, Param_B =&gt; &quot;Foo&quot;);<p>- Underscores can be used in numbers of any base: X : Integer := 1_000;<p>- Nested subprograms<p>- Range based tests</div><br/><div id="41653466" class="c"><input type="checkbox" id="c-41653466" checked=""/><div class="controls bullet"><span class="by">LiamPowell</span><span>|</span><a href="#41650712">parent</a><span>|</span><a href="#41650732">next</a><span>|</span><label class="collapse" for="c-41653466">[-]</label><label class="expand" for="c-41653466">[2 more]</label></div><br/><div class="children"><div class="content">As mentioned in the article, Pascal had these even before Ada, and a task type with an entry is effectively a generator. I think people often forget that C was incredibly primitive for its time compared to multiple other languages.</div><br/><div id="41655748" class="c"><input type="checkbox" id="c-41655748" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41650712">root</a><span>|</span><a href="#41653466">parent</a><span>|</span><a href="#41650732">next</a><span>|</span><label class="collapse" for="c-41655748">[-]</label><label class="expand" for="c-41655748">[1 more]</label></div><br/><div class="children"><div class="content">Many are sold on the story of C&#x27;s greatness design, without bothering with historical fact checking.<p>C rode the wave of UNIX&#x27;s success, it is like someone getting into computers in 2024 and praising Javascript&#x27;s greatness for Web development.<p>ESPOL in 1961 already had unsafe code blocks, almost a decade before C came to be.</div><br/></div></div></div></div></div></div><div id="41650732" class="c"><input type="checkbox" id="c-41650732" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#41650712">prev</a><span>|</span><a href="#41648709">next</a><span>|</span><label class="collapse" for="c-41650732">[-]</label><label class="expand" for="c-41650732">[1 more]</label></div><br/><div class="children"><div class="content">The file does not display because the browser insists on percent-encoding the apostrophe but the server insists that the apostrophe should not be percent-encoded, therefore resulting in an error message that it won&#x27;t redirect properly. I can download the file properly with curl, though.<p>I think these are good ideas.<p>- Underscores in numeric literals: I think it is a good idea and is also what I had wanted to do before, too. (It should be allowed in hexadecimal as well as decimal)<p>- Case ranges: GNU C has this feature, too.<p>- Named arguments: This is possible with GNU C, although it doesn&#x27;t work without writing it to handle this (although you can use macros to allow it to work with existing functions). You can pass a structure, either directly to the function, or using a macro containing a ({ }) block which extracts the values from the structure and passes them to the function (the compiler will hopefully optimize out this block and just pass the values directly). You can then use the named initialization syntax (which also allows arguments without named), and GNU C also allows you to have duplicates in which case only one of them will work, which allows you to use macros to provide default values. (I have tested this and it works.)<p>- Nested functions: GNU C also has it, but does not have the &quot;full function value&quot; like this one does, and I think it might be helpful. Nonlocal exits can also be helpful. (I also think the GNU&#x27;s nested functions could be improved, by allowing them to be declared as &quot;static&quot; and&#x2F;or &quot;register&quot; in order to avoid the need of trampoline implementations, although &quot;static&quot; and &quot;register&quot; would both have their own additional restrictions; &quot;static&quot; can&#x27;t access local variables and functions from the function it is contained in unless they are also declared as &quot;static&quot;, and &quot;register&quot; means the address can&#x27;t be taken (therefore allowing the compiler to pass the local variables as arguments to the nested function).)<p>- Generator functions: I like this too and I think that it is useful (I had wanted things like this before, too). It is also interesting how it can work well with the nested functions.<p>There are some other things that I also think should be added into a C compiler (in addition to existing GNU extensions), such as:<p>- Allowing structures to contain members declared as &quot;static&quot;. This is a global value whose name is scoped to the strucure within the file being compiled (so, like anything else declared as static, the name is not exported), so any accesses will access the single shared value. Even in the case of e.g. (x-&gt;y) if y is a static member then x does not need to be dereferenced so it is OK if it is a null pointer.<p>- Scoped macros, which work after the preprocessor works. It may be scoped to a function, a {} block inside of a function, a file, a structure, etc. The macro is only expanded where that name is in scope, and not in contexts where a new name is expected (e.g. the name of a variable or argument being declared) (in this case the macro is no longer in scope).<p>- Allow defining aliases. The name being aliased can be any sequence of bytes (that is valid as a name on the target computer), even if it is not otherwise valid in C (e.g. due to being a reserved word). Any static declaration that does not declare the value may declare the alias.<p>- Compile-time execution (with explicit declaration).<p>- Custom output sections, which can be used or moved into standard sections in a portable way. These sections might not even be mapped, and may have assertions, alignment, overlapping, etc.<p>- Allow functions to be declared as &quot;register&quot;. If a function is declared as &quot;static register&quot; (so that the name is not exported), then the compiler is allowed to change the calling convention to work better with the rest of the program.</div><br/></div></div><div id="41648709" class="c"><input type="checkbox" id="c-41648709" checked=""/><div class="controls bullet"><span class="by">notorandit</span><span>|</span><a href="#41650732">prev</a><span>|</span><a href="#41648580">next</a><span>|</span><label class="collapse" for="c-41648709">[-]</label><label class="expand" for="c-41648709">[5 more]</label></div><br/><div class="children"><div class="content">I for one think that we have lost a number of good opportunities to make C language a better and .ore powerful one.<p>IMHO what I would need with C is a powerful pre-processor like jinja2 and some symbol manipulation features too.</div><br/><div id="41649030" class="c"><input type="checkbox" id="c-41649030" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41648709">parent</a><span>|</span><a href="#41648580">next</a><span>|</span><label class="collapse" for="c-41649030">[-]</label><label class="expand" for="c-41649030">[4 more]</label></div><br/><div class="children"><div class="content">Including having proper slices, but not even one of the language authors was able to change WG14 mind on the matter.<p>That is what happens to languages that leave their authors behind and embrace design by committee.</div><br/><div id="41655825" class="c"><input type="checkbox" id="c-41655825" checked=""/><div class="controls bullet"><span class="by">notorandit</span><span>|</span><a href="#41648709">root</a><span>|</span><a href="#41649030">parent</a><span>|</span><a href="#41649387">next</a><span>|</span><label class="collapse" for="c-41655825">[-]</label><label class="expand" for="c-41655825">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but the language itself is OK-ish besides a pre-processor that&#x27;s too skinny.<p>Standardizing libraries is one thing I really favor.
But force fitting them into the language itself maybe like over-engineering.<p>Let me have an example. qsort() and bsearch() are powerful but the call&#x2F;return overhead is really unbearable. A (much) more powerful pre-processor which is really part of the language (and maybe syntax-aware) could help in creating templates that would generate solid code for either function with the bare minimum overhead.<p>I am not saying like C++ templates, but like C++ templates.</div><br/></div></div><div id="41649387" class="c"><input type="checkbox" id="c-41649387" checked=""/><div class="controls bullet"><span class="by">AlbertoGP</span><span>|</span><a href="#41648709">root</a><span>|</span><a href="#41649030">parent</a><span>|</span><a href="#41655825">prev</a><span>|</span><a href="#41648580">next</a><span>|</span><label class="collapse" for="c-41649387">[-]</label><label class="expand" for="c-41649387">[2 more]</label></div><br/><div class="children"><div class="content">I’m interested in that, do you happen to have a link or reference to that discussion?</div><br/><div id="41649685" class="c"><input type="checkbox" id="c-41649685" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41648709">root</a><span>|</span><a href="#41649387">parent</a><span>|</span><a href="#41648580">next</a><span>|</span><label class="collapse" for="c-41649685">[-]</label><label class="expand" for="c-41649685">[1 more]</label></div><br/><div class="children"><div class="content">This has the old days, what exists is Dennis&#x27;s fat pointers proposal.<p><a href="https:&#x2F;&#x2F;www.bell-labs.com&#x2F;usr&#x2F;dmr&#x2F;www&#x2F;vararray.html" rel="nofollow">https:&#x2F;&#x2F;www.bell-labs.com&#x2F;usr&#x2F;dmr&#x2F;www&#x2F;vararray.html</a></div><br/></div></div></div></div></div></div></div></div><div id="41648580" class="c"><input type="checkbox" id="c-41648580" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41648709">prev</a><span>|</span><a href="#41648532">next</a><span>|</span><label class="collapse" for="c-41648580">[-]</label><label class="expand" for="c-41648580">[13 more]</label></div><br/><div class="children"><div class="content">As a side note, these days you can fake named arguments in C, if you’re OK with every argument being 0 by default:<p><pre><code>  &#x2F;&#x2F; Declaration:
  void plot(float xlo, float xhi, float ylo, float yhi, float xinc, float yinc);
  struct plot_a { float xlo, xhi, ylo, yhi, xinc, yinc; };
  static inline void plot_i(struct plot_a _a) {
      &#x2F;&#x2F; inline thunk to allow arguments to be passed in registers
      plot(_a.xlo, _a.xhi, _a.ylo, _a.yho, _a.xinc, _a.yinc);
  }
  #define plot(...) (plot_i((struct plot_a){ __VA_ARGS__ }))

  &#x2F;&#x2F; Call:
  plot(alo, ahi, blo*2.0, bhi*2.0, .yinc = y, .xinc = f(x+z));</code></pre></div><br/><div id="41648672" class="c"><input type="checkbox" id="c-41648672" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#41648580">parent</a><span>|</span><a href="#41654308">next</a><span>|</span><label class="collapse" for="c-41648672">[-]</label><label class="expand" for="c-41648672">[10 more]</label></div><br/><div class="children"><div class="content">Note: this breaks if you want to pass struct literals:<p><pre><code>   plot((myfoo){x,y})
</code></pre>
Macros will take the struct literals as multiple parameters:<p><pre><code>    plot(
      .arg0=(myfoo){x,
      .arg1=y}
    )
</code></pre>
C macros are best left unused when possible.</div><br/><div id="41648778" class="c"><input type="checkbox" id="c-41648778" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41648580">root</a><span>|</span><a href="#41648672">parent</a><span>|</span><a href="#41648873">next</a><span>|</span><label class="collapse" for="c-41648778">[-]</label><label class="expand" for="c-41648778">[1 more]</label></div><br/><div class="children"><div class="content">Nope! In general, that can be a problem, but not for this specific technique:<p><pre><code>  $ cpp -P
  void plot(float xlo, float xhi, float ylo, float yhi, float xinc, float yinc);
  struct plot_a { float xlo, xhi, ylo, yhi, xinc, yinc; };
  static inline void plot_i(struct plot_a _a) {
      &#x2F;&#x2F; inline thunk to allow arguments to go in registers
      plot(_a.xlo, _a.xhi, _a.ylo, _a.yho, _a.xinc, _a.yinc);
  }
  #define plot(...) (plot_i((struct plot_a){ __VA_ARGS__ }))
  
  plot((myfoo){x,y})
  plot(.yinc=(myfoo){x,y})
  ^D
  [...]
  (plot_i((struct plot_a){ (myfoo){x,y} }))
  (plot_i((struct plot_a){ .yinc=(myfoo){x,y} }))
</code></pre>
You could argue this is excessively clever, but when you need it, you really need it, so it could deserve known idiom status in the right situation.</div><br/></div></div><div id="41648873" class="c"><input type="checkbox" id="c-41648873" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#41648580">root</a><span>|</span><a href="#41648672">parent</a><span>|</span><a href="#41648778">prev</a><span>|</span><a href="#41648810">next</a><span>|</span><label class="collapse" for="c-41648873">[-]</label><label class="expand" for="c-41648873">[2 more]</label></div><br/><div class="children"><div class="content">Say that to the Linux kernel or any embedded system</div><br/><div id="41651359" class="c"><input type="checkbox" id="c-41651359" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#41648580">root</a><span>|</span><a href="#41648873">parent</a><span>|</span><a href="#41648810">next</a><span>|</span><label class="collapse" for="c-41651359">[-]</label><label class="expand" for="c-41651359">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written both kernel code and embedded systems. It&#x27;s easier to maintain the code when the preprocessor is avoided.</div><br/></div></div></div></div><div id="41648782" class="c"><input type="checkbox" id="c-41648782" checked=""/><div class="controls bullet"><span class="by">CamperBob2</span><span>|</span><a href="#41648580">root</a><span>|</span><a href="#41648672">parent</a><span>|</span><a href="#41648810">prev</a><span>|</span><a href="#41654308">next</a><span>|</span><label class="collapse" for="c-41648782">[-]</label><label class="expand" for="c-41648782">[5 more]</label></div><br/><div class="children"><div class="content"><i>C macros are best left unused when possible.</i><p>Blame the committee for failing to specify an obvious and widely-demanded feature like named parameters.<p>The only explanation is that the people in charge of the language don&#x27;t write much code.</div><br/><div id="41648882" class="c"><input type="checkbox" id="c-41648882" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#41648580">root</a><span>|</span><a href="#41648782">parent</a><span>|</span><a href="#41649823">next</a><span>|</span><label class="collapse" for="c-41648882">[-]</label><label class="expand" for="c-41648882">[1 more]</label></div><br/><div class="children"><div class="content">Or they do and don’t want to learn stuff as “everything can be done the old way anyway”</div><br/></div></div><div id="41649823" class="c"><input type="checkbox" id="c-41649823" checked=""/><div class="controls bullet"><span class="by">jimbob45</span><span>|</span><a href="#41648580">root</a><span>|</span><a href="#41648782">parent</a><span>|</span><a href="#41648882">prev</a><span>|</span><a href="#41654308">next</a><span>|</span><label class="collapse" for="c-41649823">[-]</label><label class="expand" for="c-41649823">[3 more]</label></div><br/><div class="children"><div class="content">There are a lot of syntactic sugar improvements the committee could make that they simply refuse to. Named parameters and function pointer syntax are compile-time fixes that would have zero runtime costs, yet it&#x27;s 2024 and we&#x27;ve hardly budged from ANSI C.</div><br/><div id="41650495" class="c"><input type="checkbox" id="c-41650495" checked=""/><div class="controls bullet"><span class="by">CamperBob2</span><span>|</span><a href="#41648580">root</a><span>|</span><a href="#41649823">parent</a><span>|</span><a href="#41654308">next</a><span>|</span><label class="collapse" for="c-41650495">[-]</label><label class="expand" for="c-41650495">[2 more]</label></div><br/><div class="children"><div class="content">Exactly.  I actually think default parameters are hazardous without named-parameter support.  When they added one, IMO they should have added the other as well, so that you can specify exactly which non-default parameters you&#x27;re passing.</div><br/><div id="41654018" class="c"><input type="checkbox" id="c-41654018" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#41648580">root</a><span>|</span><a href="#41650495">parent</a><span>|</span><a href="#41654308">next</a><span>|</span><label class="collapse" for="c-41654018">[-]</label><label class="expand" for="c-41654018">[1 more]</label></div><br/><div class="children"><div class="content">I think this is more an appeasement of the C++ committee because they don&#x27;t like the order of evaluation to be ambiguous when constructors with side effects come into play. Witness how they completely gimped the primary utility of designated initializers with the requirement to have the fields in order.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41654308" class="c"><input type="checkbox" id="c-41654308" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#41648580">parent</a><span>|</span><a href="#41648672">prev</a><span>|</span><a href="#41649491">next</a><span>|</span><label class="collapse" for="c-41654308">[-]</label><label class="expand" for="c-41654308">[1 more]</label></div><br/><div class="children"><div class="content">Pretty Neat.<p>Have a link to any articles&#x2F;sites&#x2F;books which has a compendium of more tricks ?</div><br/></div></div></div></div><div id="41648532" class="c"><input type="checkbox" id="c-41648532" checked=""/><div class="controls bullet"><span class="by">amszmidt</span><span>|</span><a href="#41648580">prev</a><span>|</span><label class="collapse" for="c-41648532">[-]</label><label class="expand" for="c-41648532">[12 more]</label></div><br/><div class="children"><div class="content">So ... GCC has had some of these for ages.<p><pre><code>    Pascal lets you match a range of values with case low..high; wouldn&#x27;t it be great if C had that feature? High C does, another feature standard C and C++ never adopted.

</code></pre>
<a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Case-Ranges.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Case-Ranges.html</a><p><pre><code>    Nested functions

</code></pre>
<a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Nested-Functions.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Nested-Functions.html</a><p><pre><code>    Generators

</code></pre>
GCC doesn&#x27;t do those --- looks like a fun feature though!<p>My favourite, which was sadly removed was doing:<p><pre><code>    foo ? zork : bork = 123;
</code></pre>
Oh well...</div><br/><div id="41648807" class="c"><input type="checkbox" id="c-41648807" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#41648532">parent</a><span>|</span><a href="#41648897">next</a><span>|</span><label class="collapse" for="c-41648807">[-]</label><label class="expand" for="c-41648807">[4 more]</label></div><br/><div class="children"><div class="content">Not &quot;ages&quot; in comparison to how long MetaWare had them.  High C had this stuff back in the early 1990s and 1980s.<p>The headlined article doesn&#x27;t mention it, but High C&#x2F;C++ had modules all of those years ago, too.  Anybase literals, as well.  Tom Pennello participated in the standardization efforts back then, too, but none of this stuff made it in.</div><br/><div id="41649118" class="c"><input type="checkbox" id="c-41649118" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41648532">root</a><span>|</span><a href="#41648807">parent</a><span>|</span><a href="#41648897">next</a><span>|</span><label class="collapse" for="c-41649118">[-]</label><label class="expand" for="c-41649118">[3 more]</label></div><br/><div class="children"><div class="content">Is the manual online anywhere? The one for version 1.2 on Bitsavers[1] doesn’t mention any of those.<p>[1] <a href="https:&#x2F;&#x2F;bitsavers.computerhistory.org&#x2F;pdf&#x2F;metaware&#x2F;High_C_Language_Reference_Manual_1.2_Nov85.pdf" rel="nofollow">https:&#x2F;&#x2F;bitsavers.computerhistory.org&#x2F;pdf&#x2F;metaware&#x2F;High_C_La...</a></div><br/><div id="41649431" class="c"><input type="checkbox" id="c-41649431" checked=""/><div class="controls bullet"><span class="by">mezentius</span><span>|</span><a href="#41648532">root</a><span>|</span><a href="#41649118">parent</a><span>|</span><a href="#41649271">next</a><span>|</span><label class="collapse" for="c-41649431">[-]</label><label class="expand" for="c-41649431">[1 more]</label></div><br/><div class="children"><div class="content">A later version is available here (along with the compiler itself): <a href="https:&#x2F;&#x2F;winworldpc.com&#x2F;product&#x2F;metaware-high-c-cpp&#x2F;33x" rel="nofollow">https:&#x2F;&#x2F;winworldpc.com&#x2F;product&#x2F;metaware-high-c-cpp&#x2F;33x</a></div><br/></div></div><div id="41649271" class="c"><input type="checkbox" id="c-41649271" checked=""/><div class="controls bullet"><span class="by">JdeBP</span><span>|</span><a href="#41648532">root</a><span>|</span><a href="#41649118">parent</a><span>|</span><a href="#41649431">prev</a><span>|</span><a href="#41648897">next</a><span>|</span><label class="collapse" for="c-41649271">[-]</label><label class="expand" for="c-41649271">[1 more]</label></div><br/><div class="children"><div class="content">I suspect not.  I am lucky enough to be consulting this copy: <a href="https:&#x2F;&#x2F;mastodonapp.uk&#x2F;@JdeBP&#x2F;113199154771277394" rel="nofollow">https:&#x2F;&#x2F;mastodonapp.uk&#x2F;@JdeBP&#x2F;113199154771277394</a><p>(-:</div><br/></div></div></div></div></div></div><div id="41648897" class="c"><input type="checkbox" id="c-41648897" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41648532">parent</a><span>|</span><a href="#41648807">prev</a><span>|</span><a href="#41649620">next</a><span>|</span><label class="collapse" for="c-41648897">[-]</label><label class="expand" for="c-41648897">[2 more]</label></div><br/><div class="children"><div class="content">You can still do<p><pre><code>    *(foo ? &amp;zork : &amp;bork) = 123;</code></pre></div><br/><div id="41652895" class="c"><input type="checkbox" id="c-41652895" checked=""/><div class="controls bullet"><span class="by">rescbr</span><span>|</span><a href="#41648532">root</a><span>|</span><a href="#41648897">parent</a><span>|</span><a href="#41649620">next</a><span>|</span><label class="collapse" for="c-41652895">[-]</label><label class="expand" for="c-41652895">[1 more]</label></div><br/><div class="children"><div class="content">What a cursed thing. I like it.</div><br/></div></div></div></div><div id="41649620" class="c"><input type="checkbox" id="c-41649620" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#41648532">parent</a><span>|</span><a href="#41648897">prev</a><span>|</span><a href="#41648929">next</a><span>|</span><label class="collapse" for="c-41649620">[-]</label><label class="expand" for="c-41649620">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; foo ? zork : bork = 123;
</code></pre>
That&#x27;s kind of horrifying.</div><br/></div></div><div id="41648929" class="c"><input type="checkbox" id="c-41648929" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#41648532">parent</a><span>|</span><a href="#41649620">prev</a><span>|</span><a href="#41649133">next</a><span>|</span><label class="collapse" for="c-41648929">[-]</label><label class="expand" for="c-41648929">[1 more]</label></div><br/><div class="children"><div class="content">GCC’s different implementation is mentioned in the article.</div><br/></div></div><div id="41649133" class="c"><input type="checkbox" id="c-41649133" checked=""/><div class="controls bullet"><span class="by">qalmakka</span><span>|</span><a href="#41648532">parent</a><span>|</span><a href="#41648929">prev</a><span>|</span><a href="#41649495">next</a><span>|</span><label class="collapse" for="c-41649133">[-]</label><label class="expand" for="c-41649133">[2 more]</label></div><br/><div class="children"><div class="content">GCC nested functions are atrocious and deserve being banned from existence. Like the article rightfully says they&#x27;ve been implemented using weird hacks that make basically impossible to use them safely. There&#x27;s a reason why Clang has categorically refused to implement them.</div><br/></div></div></div></div></div></div></div></div></div></body></html>