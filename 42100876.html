<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731315674157" as="style"/><link rel="stylesheet" href="styles.css?v=1731315674157"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://shipilev.net/jvm/anatomy-quarks/">JVM Anatomy Quarks</a> <span class="domain">(<a href="https://shipilev.net">shipilev.net</a>)</span></div><div class="subtext"><span>lichtenberger</span> | <span>60 comments</span></div><br/><div><div id="42103080" class="c"><input type="checkbox" id="c-42103080" checked=""/><div class="controls bullet"><span class="by">lukeh</span><span>|</span><a href="#42102780">next</a><span>|</span><label class="collapse" for="c-42103080">[-]</label><label class="expand" for="c-42103080">[1 more]</label></div><br/><div class="children"><div class="content">Tangential: Apple has a new Swift Java bridge which is pretty cool, supporting both JNI and Panama. I’ve been porting it to Android this past week.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;swiftlang&#x2F;swift-java">https:&#x2F;&#x2F;github.com&#x2F;swiftlang&#x2F;swift-java</a></div><br/></div></div><div id="42102780" class="c"><input type="checkbox" id="c-42102780" checked=""/><div class="controls bullet"><span class="by">lsuresh</span><span>|</span><a href="#42103080">prev</a><span>|</span><a href="#42105331">next</a><span>|</span><label class="collapse" for="c-42102780">[-]</label><label class="expand" for="c-42102780">[1 more]</label></div><br/><div class="children"><div class="content">Happy to see this gem shared here. I&#x27;ve learnt a lot about the JVM going through these.<p>This article about the &quot;stack allocation&quot; misnomer in Java in particular is one of my favorites: <a href="https:&#x2F;&#x2F;shipilev.net&#x2F;jvm&#x2F;anatomy-quarks&#x2F;18-scalar-replacement&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shipilev.net&#x2F;jvm&#x2F;anatomy-quarks&#x2F;18-scalar-replacemen...</a>. What the JVM really does is escape analysis + scalar replacement.</div><br/></div></div><div id="42105331" class="c"><input type="checkbox" id="c-42105331" checked=""/><div class="controls bullet"><span class="by">wging</span><span>|</span><a href="#42102780">prev</a><span>|</span><a href="#42101715">next</a><span>|</span><label class="collapse" for="c-42105331">[-]</label><label class="expand" for="c-42105331">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone know why the name of this series was changed from ‘JVM Anatomy Park’?</div><br/></div></div><div id="42101715" class="c"><input type="checkbox" id="c-42101715" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#42105331">prev</a><span>|</span><a href="#42103874">next</a><span>|</span><label class="collapse" for="c-42101715">[-]</label><label class="expand" for="c-42101715">[1 more]</label></div><br/><div class="children"><div class="content">I love the &quot;size&quot; of these posts. Kinda neat to just read through one in a few mins and maybe run the bench locally.</div><br/></div></div><div id="42103874" class="c"><input type="checkbox" id="c-42103874" checked=""/><div class="controls bullet"><span class="by">plandis</span><span>|</span><a href="#42101715">prev</a><span>|</span><a href="#42101276">next</a><span>|</span><label class="collapse" for="c-42103874">[-]</label><label class="expand" for="c-42103874">[1 more]</label></div><br/><div class="children"><div class="content">If you work for a few years with JVM based languages this set of articles are so interesting! I remember reading through these for the first time several years ago.</div><br/></div></div><div id="42101276" class="c"><input type="checkbox" id="c-42101276" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42103874">prev</a><span>|</span><a href="#42103046">next</a><span>|</span><label class="collapse" for="c-42101276">[-]</label><label class="expand" for="c-42101276">[28 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;shipilev.net&#x2F;jvm&#x2F;anatomy-quarks&#x2F;17-trust-nonstatic-final-fields&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shipilev.net&#x2F;jvm&#x2F;anatomy-quarks&#x2F;17-trust-nonstatic-f...</a> is a damned shame. User code misses out on an important optimization available only to system-provided classes because certain frameworks have abused JNI and reflection to mutate final fields, which by all rights should be immutable.<p>Platforms, especially compilers and runtimes, need to be absolutely strict in <i>enforcing</i> semantic restrictions so as to preserve optimization opportunities for the future.</div><br/><div id="42101948" class="c"><input type="checkbox" id="c-42101948" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#42101276">parent</a><span>|</span><a href="#42101406">next</a><span>|</span><label class="collapse" for="c-42101948">[-]</label><label class="expand" for="c-42101948">[1 more]</label></div><br/><div class="children"><div class="content">As part of our &quot;integrity by default&quot; strategy [1] we&#x27;re changing that. There will be a JEP about it soon.<p>The idea is that because not much code actually needs to mutate finals (and even if it does, that operation is already limited today to classes in the code&#x27;s own modules or ones explicitly &quot;open&quot; to it), the application will need to grant a permission to a module that wants to mutate finals, similar to how we&#x27;ve recently done things with native calls and unsafe memory access.<p>[1]: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8305968" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8305968</a></div><br/></div></div><div id="42101406" class="c"><input type="checkbox" id="c-42101406" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#42101276">parent</a><span>|</span><a href="#42101948">prev</a><span>|</span><a href="#42101455">next</a><span>|</span><label class="collapse" for="c-42101406">[-]</label><label class="expand" for="c-42101406">[1 more]</label></div><br/><div class="children"><div class="content">the System.out thing is Java itself<p><a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;jls&#x2F;se7&#x2F;html&#x2F;jls-17.html#jls-17.5.4" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;jls&#x2F;se7&#x2F;html&#x2F;jls-17.htm...</a><p>given this it&#x27;s not surprising others thought it was acceptable also</div><br/></div></div><div id="42101455" class="c"><input type="checkbox" id="c-42101455" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#42101276">parent</a><span>|</span><a href="#42101406">prev</a><span>|</span><a href="#42101402">next</a><span>|</span><label class="collapse" for="c-42101455">[-]</label><label class="expand" for="c-42101455">[18 more]</label></div><br/><div class="children"><div class="content">I wonder if it thanks to some people blindly following Effective Java book that made a sin by saying &quot;final all the things&quot;. So now we cannot easily mock final classes in tests. And mocking tools have to resort to bytecode manipulation to mock the final classes.<p>E.g. Effective Java is a requirement inside Google, so even public GDrive APIs have final classes. External APIs is exactly the thing you&#x27;d want to mock.</div><br/><div id="42101549" class="c"><input type="checkbox" id="c-42101549" checked=""/><div class="controls bullet"><span class="by">adamnew123456</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101455">parent</a><span>|</span><a href="#42105147">next</a><span>|</span><label class="collapse" for="c-42101549">[-]</label><label class="expand" for="c-42101549">[6 more]</label></div><br/><div class="children"><div class="content">I would say less overuse of final, more underuse of interfaces. If everything takes&#x2F;returns&#x2F;stores values by interfaces (excluding data containers with no behavior) then you don&#x27;t need to &quot;jailbreak&quot; any class to mock it.<p>Of course you get code bloat defining interfaces for everything you intend to implement once, and you have to enforce these rules, but this is something that could be made easier. Not in Java, but imagine a language where:<p>- Concrete classes can only be used in new, or in some platform provided DI container.<p>- Methods can only accept interface types and return interface types.<p>- Fields are private only, all public&#x2F;protected is via properties (or getters&#x2F;setters, it just has to be declarable in an interface)<p>- You have a &quot;.interface&quot; syntax (akin to &quot;.class&quot; but for types) that refers to the public members of a class without tying you to the concrete class itself. You can use this as a shorthand instead of declaring separate interfaces for everything.<p>Eg.<p>```<p>final class GDrive { ... }<p>public Download file(GDrive.interface drive) { ... }<p>class MockDrive implements GDrive.interface { ... }<p>```<p>The closest I can think of is a hypothetical typed variant of NewSpeak, but maybe something like this exists already?</div><br/><div id="42102650" class="c"><input type="checkbox" id="c-42102650" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101549">parent</a><span>|</span><a href="#42101589">next</a><span>|</span><label class="collapse" for="c-42102650">[-]</label><label class="expand" for="c-42102650">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I would say less overuse of final, more underuse of interfaces.<p>Interfaces with one implementation are terrible. They just clutter everything and make the code navigation a pain, so it&#x27;s good that people are avoiding them.<p>Perhaps a special &quot;test-only&quot; mode that allows to patch finals is a better idea.</div><br/><div id="42105436" class="c"><input type="checkbox" id="c-42105436" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42102650">parent</a><span>|</span><a href="#42105367">next</a><span>|</span><label class="collapse" for="c-42105436">[-]</label><label class="expand" for="c-42105436">[1 more]</label></div><br/><div class="children"><div class="content">Custom classloaders and Java agents allow to modify bytecode before it loads into JVM, so it&#x27;s possible to remove `final`, modify visibility scope and perform basically anything.</div><br/></div></div><div id="42105367" class="c"><input type="checkbox" id="c-42105367" checked=""/><div class="controls bullet"><span class="by">self_awareness</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42102650">parent</a><span>|</span><a href="#42105436">prev</a><span>|</span><a href="#42101589">next</a><span>|</span><label class="collapse" for="c-42105367">[-]</label><label class="expand" for="c-42105367">[2 more]</label></div><br/><div class="children"><div class="content">I always wonder what is the motivation when people do interfaces with
just one implementation.<p>I mean, using this logic, every single function can be hidden behind an
interface. Even the sole implementation of the interface can be hidden
behind a <i>yet</i> another interface.<p>If there&#x27;s just one implementation, then the interface is not necessary!</div><br/><div id="42105448" class="c"><input type="checkbox" id="c-42105448" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42105367">parent</a><span>|</span><a href="#42101589">next</a><span>|</span><label class="collapse" for="c-42105448">[-]</label><label class="expand" for="c-42105448">[1 more]</label></div><br/><div class="children"><div class="content">One motivation is to separate interface and implementation. Using interface allows one to easily observe available methods in a one place. With class, one must use IDEs to filter out hundreds irrelevant lines just to find out class contract. If you ever used Delphi or C++, it provides much better experience by clearly separating class interface and class implementation.</div><br/></div></div></div></div></div></div><div id="42101589" class="c"><input type="checkbox" id="c-42101589" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101549">parent</a><span>|</span><a href="#42102650">prev</a><span>|</span><a href="#42105147">next</a><span>|</span><label class="collapse" for="c-42101589">[-]</label><label class="expand" for="c-42101589">[1 more]</label></div><br/><div class="children"><div class="content">You just invented Java AutoValue and Kotlin Data Classes.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;auto&#x2F;blob&#x2F;main&#x2F;value&#x2F;userguide&#x2F;index.md">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;auto&#x2F;blob&#x2F;main&#x2F;value&#x2F;userguide&#x2F;ind...</a></div><br/></div></div></div></div><div id="42105147" class="c"><input type="checkbox" id="c-42105147" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101455">parent</a><span>|</span><a href="#42101549">prev</a><span>|</span><a href="#42101568">next</a><span>|</span><label class="collapse" for="c-42105147">[-]</label><label class="expand" for="c-42105147">[1 more]</label></div><br/><div class="children"><div class="content">I would say that anything that requires monkey patching in a strong typed language is a sign of bad architecture and application design in first place.</div><br/></div></div><div id="42101568" class="c"><input type="checkbox" id="c-42101568" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101455">parent</a><span>|</span><a href="#42105147">prev</a><span>|</span><a href="#42101615">next</a><span>|</span><label class="collapse" for="c-42101568">[-]</label><label class="expand" for="c-42101568">[1 more]</label></div><br/><div class="children"><div class="content">The trouble is final is not final in Java, private is not private.  I mean you can lock it down but you usually won’t.  With reflective access, breaking the rules is one method call away.  Common Java libraries such as meta factories (Spring, Guice), serializers (Jackson, GSON) and test frameworks regularly cheated in the JDK 8 era and a lot of us are running with protections for the stdlib turned off.<p>Normally a JDK 21 would let you get private&#x2F;final reflective access to your own “module” but not to the stdlib modules but so many libraries want private access to stdlib objects such as all the various date and time objects.</div><br/></div></div><div id="42101615" class="c"><input type="checkbox" id="c-42101615" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101455">parent</a><span>|</span><a href="#42101568">prev</a><span>|</span><a href="#42101586">next</a><span>|</span><label class="collapse" for="c-42101615">[-]</label><label class="expand" for="c-42101615">[3 more]</label></div><br/><div class="children"><div class="content">I do not like Bloch, and see him as the architect of some of Java’s woes. Generics didn’t have to be so stupid. Gilad Bracha (who did a lot of the work on generics) quit the moment they were done to go try something very different - gradual typing. I hope he’s keeping an eye on what Elixir is trying, because Set Theoretic Typing has the potential to be big, and it can be applied gradually.<p>I can no longer recall exactly what Bloch said, I may have to search through some of by old writing to find it, but at one point he admitted he didn’t really understand type theory when he designed the collections API. And while I appreciate the honesty, and the reason (he was trying to illustrate that this stuff is still too hard if “even he” didn’t get it), I think it paints him rather worse.<p>But I already knew that about him from working with that code for years and understanding LSP, which he clearly did not.<p>I don’t know <i>why</i> they thought he should be the one writing about how to use Java effectively when he was materially responsible for it being harder to use, but I’m not going to give him any money to reward him. And there are other places to get the same education. “Refactoring” should be a cornerstone of every education, for much the same reason learning to fall without hurting yourself is the first thing some martial arts teach you. Learn to clean up before you learn to make messes.<p>He said at one point that he had thought of a different way to decompose the interfaces for collections that had less need for variance, with read and write separated, but he thought there were too many interfaces and they would confuse people. But when I tried the same experiment (I spent years thinking about writing my own language)… the thing is when you’re only consuming a collection, a lot of the types have the same semantics, so they don’t need separate read interfaces, and the variance declarations are much simpler. It’s only when you manipulate them that you run into trouble with Liskov, and things that are structurally similar have different contracts. The difference in type count to achieve parity with Collections was maybe 20% more, not double. So to this day I don’t know what he’s talking about.<p>Most APIs should only consume collections from callers, so friction against mutation in your interface is actually a good thing.</div><br/><div id="42101897" class="c"><input type="checkbox" id="c-42101897" checked=""/><div class="controls bullet"><span class="by">roadbuster</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101615">parent</a><span>|</span><a href="#42101586">next</a><span>|</span><label class="collapse" for="c-42101897">[-]</label><label class="expand" for="c-42101897">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; the thing is when you’re only consuming a collection,
    &gt; a lot of the types have the same semantics, so they 
    &gt; don’t need separate read interfaces


    &gt; Most APIs should only consume collections from callers
</code></pre>
I&#x27;m having trouble understanding what you mean by &quot;consuming a collection.&quot; Can you expand?</div><br/><div id="42102276" class="c"><input type="checkbox" id="c-42102276" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101897">parent</a><span>|</span><a href="#42101586">next</a><span>|</span><label class="collapse" for="c-42102276">[-]</label><label class="expand" for="c-42102276">[1 more]</label></div><br/><div class="children"><div class="content">Read-only use of an externally provided collection, presumably.</div><br/></div></div></div></div></div></div><div id="42101586" class="c"><input type="checkbox" id="c-42101586" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101455">parent</a><span>|</span><a href="#42101615">prev</a><span>|</span><a href="#42104270">next</a><span>|</span><label class="collapse" for="c-42101586">[-]</label><label class="expand" for="c-42101586">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So now we cannot easily mock final classes in tests<p>&gt; And mocking tools have to resort to bytecode manipulation to mock the final classes<p>Well which is it?  Presumably you use said mocking tool anyway, so it&#x27;s not your effort that&#x27;s being expended.<p>&quot;Final all the things&quot; really doesn&#x27;t go far enough.  There is little point substituting a mutable hashmap for a &quot;final&quot; mutable hashmap, when the actual solution is for the standard library to ship proper immutable collection classes.<p>In any case, I prefer to avoid mockito anyway, so it&#x27;s a non-issue for me.  Just do plain ol&#x27; dependency injection by passing in dependencies into constructors.</div><br/><div id="42101665" class="c"><input type="checkbox" id="c-42101665" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101586">parent</a><span>|</span><a href="#42104270">next</a><span>|</span><label class="collapse" for="c-42101665">[-]</label><label class="expand" for="c-42101665">[1 more]</label></div><br/><div class="children"><div class="content">As I mentioned in another reply, Josh Bloch experimented with a different type structure for the Collections API that could have yielded read only collections but he thought it was too confusing and went back to… this.<p>And I’ve never forgiven him for it</div><br/></div></div></div></div><div id="42104270" class="c"><input type="checkbox" id="c-42104270" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101455">parent</a><span>|</span><a href="#42101586">prev</a><span>|</span><a href="#42101530">next</a><span>|</span><label class="collapse" for="c-42104270">[-]</label><label class="expand" for="c-42104270">[2 more]</label></div><br/><div class="children"><div class="content">In my experience I don’t see many people use final classes. Mostly just final fields.</div><br/><div id="42104295" class="c"><input type="checkbox" id="c-42104295" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42104270">parent</a><span>|</span><a href="#42101530">next</a><span>|</span><label class="collapse" for="c-42104295">[-]</label><label class="expand" for="c-42104295">[1 more]</label></div><br/><div class="children"><div class="content">The only final classes I can remember are stuff like java.lang.String, which needed to be immutable so a SecurityManager could consume them for policy decisions.</div><br/></div></div></div></div><div id="42101530" class="c"><input type="checkbox" id="c-42101530" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101455">parent</a><span>|</span><a href="#42104270">prev</a><span>|</span><a href="#42101402">next</a><span>|</span><label class="collapse" for="c-42101530">[-]</label><label class="expand" for="c-42101530">[2 more]</label></div><br/><div class="children"><div class="content">If you are rigorous as to make classes final, you should also be rigorous to never provide a non-interface as an Application Programming <i>Interface</i>.<p>Google uses mocks and fakes implementations of interfaces, and provides dependency injection frameworks for managing these (Guice and Dagger).</div><br/><div id="42102427" class="c"><input type="checkbox" id="c-42102427" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101530">parent</a><span>|</span><a href="#42101402">next</a><span>|</span><label class="collapse" for="c-42102427">[-]</label><label class="expand" for="c-42102427">[1 more]</label></div><br/><div class="children"><div class="content">I once worked with a guy who obsessively made interfaces for every java class. Even domain objects. He was extremely proud of this.<p>It was garbage.</div><br/></div></div></div></div></div></div><div id="42101402" class="c"><input type="checkbox" id="c-42101402" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#42101276">parent</a><span>|</span><a href="#42101455">prev</a><span>|</span><a href="#42101399">next</a><span>|</span><label class="collapse" for="c-42101402">[-]</label><label class="expand" for="c-42101402">[1 more]</label></div><br/><div class="children"><div class="content">I’ll be the first to admit that I’ve written the evil three liner to “un-final”, mutate, re-final a member off in some long forgotten internal library to dodge a gnarly refactor.<p>I do wish that I couldn’t have done so, shrug, business needs</div><br/></div></div><div id="42101399" class="c"><input type="checkbox" id="c-42101399" checked=""/><div class="controls bullet"><span class="by">J-Kuhn</span><span>|</span><a href="#42101276">parent</a><span>|</span><a href="#42101402">prev</a><span>|</span><a href="#42101848">next</a><span>|</span><label class="collapse" for="c-42101399">[-]</label><label class="expand" for="c-42101399">[3 more]</label></div><br/><div class="children"><div class="content">Yes, but you would be surprised how many people want to change static final fields for various reasons - be it testing, or other things.<p>When telling those that it doesn&#x27;t work, and that it can not work without violating the semantics of the JVM, they will wave their hand and say &quot;look, it does work here&quot;. And it looks like, yes, if the stars align in that specific constellation, it may work.</div><br/><div id="42101693" class="c"><input type="checkbox" id="c-42101693" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101399">parent</a><span>|</span><a href="#42101447">next</a><span>|</span><label class="collapse" for="c-42101693">[-]</label><label class="expand" for="c-42101693">[1 more]</label></div><br/><div class="children"><div class="content">Also a part of why Singletons are the black sheep of the Patterns family. They’re nasty during bootstrapping and hell during functional testing.</div><br/></div></div></div></div><div id="42101848" class="c"><input type="checkbox" id="c-42101848" checked=""/><div class="controls bullet"><span class="by">elric</span><span>|</span><a href="#42101276">parent</a><span>|</span><a href="#42101399">prev</a><span>|</span><a href="#42101463">next</a><span>|</span><label class="collapse" for="c-42101848">[-]</label><label class="expand" for="c-42101848">[1 more]</label></div><br/><div class="children"><div class="content">IIRC illegal access can be locked down and be controlled in a fine grained manner with the add-opens and illegal-access flags on newer JVMs.</div><br/></div></div><div id="42101463" class="c"><input type="checkbox" id="c-42101463" checked=""/><div class="controls bullet"><span class="by">rusk</span><span>|</span><a href="#42101276">parent</a><span>|</span><a href="#42101848">prev</a><span>|</span><a href="#42103046">next</a><span>|</span><label class="collapse" for="c-42101463">[-]</label><label class="expand" for="c-42101463">[2 more]</label></div><br/><div class="children"><div class="content">Field modifiers are a semantic constraint not a security constraint. It is right and proper that you should be able to bypass them with the appropriate backflips.<p>The main issue is safety cause you might modify something that isn’t modifiable and cause a SEGV and that is precisely the concern access modifiers are meant to address.</div><br/><div id="42101519" class="c"><input type="checkbox" id="c-42101519" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#42101276">root</a><span>|</span><a href="#42101463">parent</a><span>|</span><a href="#42103046">next</a><span>|</span><label class="collapse" for="c-42101519">[-]</label><label class="expand" for="c-42101519">[1 more]</label></div><br/><div class="children"><div class="content">they certainly were a security constraint back in the day before Java gave up on trying to use the type system for security<p>e.g. SecurityManager for applets will not let you setAccessible(true) on private fields of system classes</div><br/></div></div></div></div></div></div><div id="42102444" class="c"><input type="checkbox" id="c-42102444" checked=""/><div class="controls bullet"><span class="by">azinman2</span><span>|</span><a href="#42103046">prev</a><span>|</span><label class="collapse" for="c-42102444">[-]</label><label class="expand" for="c-42102444">[25 more]</label></div><br/><div class="children"><div class="content">I’ve basically forgotten about Java. It would never occur to me to start a new project in it. Am I the only one? It feels like I’d reach for python if I want fast development and flexibility, Go if I want to handle a bunch of I&#x2F;O concurrency in a garbage collected way, Swift if I want a nice language that’s compiled and balanced, or Rust if I want performance and safety in a compiled language. Those are just my personal leanings. I know kotlin has made Java more ergonomic, and yet….</div><br/><div id="42102757" class="c"><input type="checkbox" id="c-42102757" checked=""/><div class="controls bullet"><span class="by">dcminter</span><span>|</span><a href="#42102444">parent</a><span>|</span><a href="#42102861">next</a><span>|</span><label class="collapse" for="c-42102757">[-]</label><label class="expand" for="c-42102757">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not the only one I&#x27;m sure, but sounds like you don&#x27;t need it. Its major strengths are:<p>• Bottomless resource of developers with Java experience<p>• Vast array of existing libraries many of which are enterprise focused<p>• Managing very large codebases with many contributors is straightforward<p>• Standard VM that&#x27;s very solid (decades of development), reasonably fast, and supported on essentially all platforms.<p>It doesn&#x27;t have quite the stranglehold (even in Enterprise) that it had in perhaps the early 2000s and it&#x27;s the archetypical &quot;blub&quot; language, but it&#x27;s a perfectly reasonable language to choose if you&#x27;re expecting Enterprise scale and pure performance is less valuable to you than scaling out with large numbers of developers.<p>I like Rust, but it&#x27;s Java that puts bread on my table.</div><br/><div id="42103758" class="c"><input type="checkbox" id="c-42103758" checked=""/><div class="controls bullet"><span class="by">sriram_malhar</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42102757">parent</a><span>|</span><a href="#42102861">next</a><span>|</span><label class="collapse" for="c-42103758">[-]</label><label class="expand" for="c-42103758">[3 more]</label></div><br/><div class="children"><div class="content">I fully agree with you about the solidity of the VM. The others I am not so sure about.<p>&gt; Bottomless resources of developers with Java experience.<p>With Java experience, but what fraction have a systems outlook? What fraction have an experience with other languages to ensure that the code they write is simple and understandable and direct? My own experience is that too many come out addled by Enterprise Java idioms, and when you actually write some code in Erlang or Go you realize systems aren&#x27;t as complicated as they have been made out to be.<p>&gt; Managing very large codebases ...<p>I wonder if this is self-fulfilling. My theory is that these codebases are huge because their designs are enterprisey. The primary drivers of complexity are indirection: factories, dependency injection, microservices, these are all part of the same malaise.</div><br/><div id="42103902" class="c"><input type="checkbox" id="c-42103902" checked=""/><div class="controls bullet"><span class="by">plandis</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42103758">parent</a><span>|</span><a href="#42105297">next</a><span>|</span><label class="collapse" for="c-42103902">[-]</label><label class="expand" for="c-42103902">[1 more]</label></div><br/><div class="children"><div class="content">&gt; With Java experience, but what fraction have a systems outlook?<p>It depends what you mean by systems outlook but JVM based code is pretty common (to the point I’d say ubiquitous) in large distributed systems.<p>In open source it’s much the same. Many of the large Apache projects are in JVM languages, for example.<p>&gt; The primary drivers of complexity are indirection: factories, dependency injection, microservices, these are all part of the same malaise<p>The indirection in Java does drive me crazy. But dependency injection is a problem to solve in every language and libraries that can do code generation at compile time like Dagger2 make this predictable, debuggable, and fairly easy to reason about on the JVM.<p>Microservices are, in my opinion, more of a business organization solution than one tied to any specific language. If you haven’t read Steve Yegge’s blog post about Amazon vs Google I think it’s good reading on why&#x2F;when SoA is a good idea.</div><br/></div></div><div id="42105297" class="c"><input type="checkbox" id="c-42105297" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42103758">parent</a><span>|</span><a href="#42103902">prev</a><span>|</span><a href="#42102861">next</a><span>|</span><label class="collapse" for="c-42105297">[-]</label><label class="expand" for="c-42105297">[1 more]</label></div><br/><div class="children"><div class="content">There are more Java devs out there than people living in my country. I don&#x27;t think generalizing this way is helpful, there are many different styles of Java development, and developers have vastly different skill sets.</div><br/></div></div></div></div></div></div><div id="42102861" class="c"><input type="checkbox" id="c-42102861" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#42102444">parent</a><span>|</span><a href="#42102757">prev</a><span>|</span><a href="#42105109">next</a><span>|</span><label class="collapse" for="c-42102861">[-]</label><label class="expand" for="c-42102861">[1 more]</label></div><br/><div class="children"><div class="content">In addition to other answers: Java absolutely does have the qualities necessary for startups, so using it for new projects makes sense.<p>1. Modern frameworks and AI assistance can help ramping up a decent backend in days. Solo tech co-founder needs to know only Java or Kotlin and some frontend stack to build MVP quickly and will spend such amount of time on non-coding tasks where language features will be irrelevant. Swift can be the second language if you go mobile-native.<p>2. Scaling isn’t the problem you are going to have for quite a while. It is quite likely, that problem of scaling the team will come first and any performance bottlenecks will be noticeable much later. Java is good for large teams.<p>That said, from business perspective, if you want larger talent pool, fast delivery cycles and something that may remain as your core stack in the long term - Java or Kotlin is probably the best choice. If you want fancy tech as a perk to attract certain cohort of developers or you have that rare business case, you can choose Go or Rust. Python is popular in academia and bootcamps, but TBH I struggle to see the business value of it for generic backends.</div><br/></div></div><div id="42105109" class="c"><input type="checkbox" id="c-42105109" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42102444">parent</a><span>|</span><a href="#42102861">prev</a><span>|</span><a href="#42105292">next</a><span>|</span><label class="collapse" for="c-42105109">[-]</label><label class="expand" for="c-42105109">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an interesting parallel development that people are complaining about the bad original language on both JS and JVM platforms and often using other languages (Kotlin, TypeScript, Clojure&#x2F;ClojureScript, etc). I guess even Swift instead of Objective-C on the Apple side counts here in a way.</div><br/><div id="42105192" class="c"><input type="checkbox" id="c-42105192" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42105109">parent</a><span>|</span><a href="#42105292">next</a><span>|</span><label class="collapse" for="c-42105192">[-]</label><label class="expand" for="c-42105192">[1 more]</label></div><br/><div class="children"><div class="content">What I find sad in some of the guest languages communities, like Kotlin and Scala ones, is how so many happen to disdain the platform that makes their ecosystem possible in first place.<p>No one is going to rewrite the JVM, even though there are several implementations, all of them are a mix of C, C++, Assembly and Java, zero Kotlin and Scala.<p>Yet as usual there is this little island of Kotlin or Scala ecosystem, with their own replacement of everything, and continuous talks how it is possible that the platform that makes their existence possible hasn&#x27;t been rewriten into them.<p>Typescript and Clojure folks are traditionally more welcoming of the platform, they rather appreciate the symbiotic relationship with the host, and much more fun to hang around with.</div><br/></div></div></div></div><div id="42105292" class="c"><input type="checkbox" id="c-42105292" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42102444">parent</a><span>|</span><a href="#42105109">prev</a><span>|</span><a href="#42102464">next</a><span>|</span><label class="collapse" for="c-42105292">[-]</label><label class="expand" for="c-42105292">[1 more]</label></div><br/><div class="children"><div class="content">Flamewar-y reply to a flamewar-y comment:<p>Java is better than Go on every count, and almost all of your cases are 90% done by Java, so it&#x27;s quite clearly a very good choice for almost everything.</div><br/></div></div><div id="42102464" class="c"><input type="checkbox" id="c-42102464" checked=""/><div class="controls bullet"><span class="by">mpenet</span><span>|</span><a href="#42102444">parent</a><span>|</span><a href="#42105292">prev</a><span>|</span><a href="#42102473">next</a><span>|</span><label class="collapse" for="c-42102464">[-]</label><label class="expand" for="c-42102464">[1 more]</label></div><br/><div class="children"><div class="content">There are plenty of very ergonomic languages on the JVM (for instance clojure).<p>I wouldn’t dismiss the JVM as a whole, it is a marvel of engineering and is evolving quickly nowadays (see loom, panama, leyden, etc…).</div><br/></div></div><div id="42102473" class="c"><input type="checkbox" id="c-42102473" checked=""/><div class="controls bullet"><span class="by">pianoben</span><span>|</span><a href="#42102444">parent</a><span>|</span><a href="#42102464">prev</a><span>|</span><a href="#42102669">next</a><span>|</span><label class="collapse" for="c-42102473">[-]</label><label class="expand" for="c-42102473">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s not <i>just</i> you, but certainly not everyone.  Kotlin with Java 21+ is my go-to choice for an I&#x2F;O-bound service, or really <i>any</i> service.  It&#x27;s just so ergonomic, and with virtual threads the code can be as simple and efficient as Go - while also taking advantage of possibly the best and largest library ecosystem in the world.<p>I&#x27;m not knocking Go or Python - if those are your preferred tools, they&#x27;re more than adequate.  Java, however, isn&#x27;t nearly as irrelevant as you may perceive.</div><br/><div id="42105434" class="c"><input type="checkbox" id="c-42105434" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42102473">parent</a><span>|</span><a href="#42102669">next</a><span>|</span><label class="collapse" for="c-42105434">[-]</label><label class="expand" for="c-42105434">[1 more]</label></div><br/><div class="children"><div class="content">Go is definitely not an ergonomic language.</div><br/></div></div></div></div><div id="42102669" class="c"><input type="checkbox" id="c-42102669" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42102444">parent</a><span>|</span><a href="#42102473">prev</a><span>|</span><a href="#42102668">next</a><span>|</span><label class="collapse" for="c-42102669">[-]</label><label class="expand" for="c-42102669">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Am I the only one?<p>Probably not. Java had stagnated for quite a while, entirely missing the lightweight threading and&#x2F;or async&#x2F;await revolution of the last decade. The JVM ergonomics also just sucks, a lot of apps _still_ have to use -Xmx switches to allocate the RAM, as if we&#x27;re still using a freaking Macintosh System 6!<p>On the other hand, it&#x27;s a very mature ecosystem with plenty of established battle-tested libraries.</div><br/><div id="42105438" class="c"><input type="checkbox" id="c-42105438" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42102669">parent</a><span>|</span><a href="#42103992">next</a><span>|</span><label class="collapse" for="c-42105438">[-]</label><label class="expand" for="c-42105438">[1 more]</label></div><br/><div class="children"><div class="content">Java is one of the couple of platforms that do have virtual threads (others being Erlang, go and Haskell), and by far the biggest among these..<p>Is it not you who stagnated a bit?..</div><br/></div></div><div id="42103992" class="c"><input type="checkbox" id="c-42103992" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42102669">parent</a><span>|</span><a href="#42105438">prev</a><span>|</span><a href="#42105326">next</a><span>|</span><label class="collapse" for="c-42103992">[-]</label><label class="expand" for="c-42103992">[4 more]</label></div><br/><div class="children"><div class="content">I think your information is outdated.  Java has had lightweight threads for several releases now.  It also has type pattern matching switches, and a bunch of modern ergonomics.<p>async&#x2F;await is not really a revolution, so much as a bandaid bringing a modicum of parallelism to certain programming languages that don&#x27;t have a good threading model.<p>Xmx is mostly a thing if you have very small RAM, or some sort of grievously misconfigured container setup.  By default it grow up to 25% of the system RAM, which is a relatively sane default.</div><br/><div id="42104702" class="c"><input type="checkbox" id="c-42104702" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42103992">parent</a><span>|</span><a href="#42105326">next</a><span>|</span><label class="collapse" for="c-42104702">[-]</label><label class="expand" for="c-42104702">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I think your information is outdated. Java has had lightweight threads for several releases now.<p>Well, yes. It was released as a part of JDK 21 a year ago. So far, the adoption has been spotty. They are also implemented not in the best possible way.<p>&gt; Xmx is mostly a thing if you have very small RAM, or some sort of grievously misconfigured container setup. By default it grow up to 25% of the system RAM, which is a relatively sane default.<p>Other more sane runtimes (like Go) do not even have developers care about the heap sizing. It just works.</div><br/><div id="42105009" class="c"><input type="checkbox" id="c-42105009" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42104702">parent</a><span>|</span><a href="#42105443">next</a><span>|</span><label class="collapse" for="c-42105009">[-]</label><label class="expand" for="c-42105009">[1 more]</label></div><br/><div class="children"><div class="content">It’s valid criticism because you do need to think about it less in other runtimes, but it doesn’t always just work. There’s a reason why GOMEMLIMIT and other knobs for high allocation programs were introduced.<p>IIRC .NET just sets it to 75% of available memory.</div><br/></div></div><div id="42105443" class="c"><input type="checkbox" id="c-42105443" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42104702">parent</a><span>|</span><a href="#42105009">prev</a><span>|</span><a href="#42105326">next</a><span>|</span><label class="collapse" for="c-42105443">[-]</label><label class="expand" for="c-42105443">[1 more]</label></div><br/><div class="children"><div class="content">Java does the sane thing within containers, and you definitely not have to set memory settings anywhere else, unless you want some very specific behavior.</div><br/></div></div></div></div></div></div><div id="42105326" class="c"><input type="checkbox" id="c-42105326" checked=""/><div class="controls bullet"><span class="by">self_awareness</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42102669">parent</a><span>|</span><a href="#42103992">prev</a><span>|</span><a href="#42102878">next</a><span>|</span><label class="collapse" for="c-42105326">[-]</label><label class="expand" for="c-42105326">[1 more]</label></div><br/><div class="children"><div class="content">The async&#x2F;await is not a revolution, but rather is a tool only for
specific use cases. It shouldn&#x27;t be used <i>by default</i>, as it makes the
project unnecessarily complicated. If your requirements are to do heavy
parallelism where everything uses I&#x2F;O, then use async, but for the rest
of cases? Probably not worth it.</div><br/></div></div><div id="42102878" class="c"><input type="checkbox" id="c-42102878" checked=""/><div class="controls bullet"><span class="by">azinman2</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42102669">parent</a><span>|</span><a href="#42105326">prev</a><span>|</span><a href="#42102668">next</a><span>|</span><label class="collapse" for="c-42102878">[-]</label><label class="expand" for="c-42102878">[2 more]</label></div><br/><div class="children"><div class="content">Omg I forgot about that. So there’s no way to say just grab the memory you need and that’s that?</div><br/><div id="42102993" class="c"><input type="checkbox" id="c-42102993" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42102878">parent</a><span>|</span><a href="#42102668">next</a><span>|</span><label class="collapse" for="c-42102993">[-]</label><label class="expand" for="c-42102993">[1 more]</label></div><br/><div class="children"><div class="content">That’s in the works, where it adapts from 16mb to terabyte heaps. The current GCs have a max, with lazy allocation and ability to release back to the system periodically, but are not as system aware.<p>1. <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8329758" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8329758</a><p>2. <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=wcENUyuzMNM&amp;embeds_referring_euri=https%3A%2F%2Fwww.reddit.com%2F" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=wcENUyuzMNM&amp;embeds_referring_e...</a></div><br/></div></div></div></div></div></div><div id="42102668" class="c"><input type="checkbox" id="c-42102668" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#42102444">parent</a><span>|</span><a href="#42102669">prev</a><span>|</span><label class="collapse" for="c-42102668">[-]</label><label class="expand" for="c-42102668">[4 more]</label></div><br/><div class="children"><div class="content">For posters like you I always wonder: why are you posting? Why did you even click on the article if you dislike Java so much?<p>Is this posturing? Do you feel cool? Why did you come here and bloviate over something as silly as a language choice?</div><br/><div id="42102926" class="c"><input type="checkbox" id="c-42102926" checked=""/><div class="controls bullet"><span class="by">azinman2</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42102668">parent</a><span>|</span><label class="collapse" for="c-42102926">[-]</label><label class="expand" for="c-42102926">[3 more]</label></div><br/><div class="children"><div class="content">Are you the reason I got downvoted? I was very surprised by that.<p>I’ve spent years writing Java and later Scala, in academia and later production. I’ve always followed to see how the JVM and the language&#x2F;ecosystem has progressed. And now I don’t use it at all. Is it really that odd to take a temperature on a site filled with other tech folks? I don’t understand why you took it so negatively and use words like bloviate, or attack me as just posturing to look cool (how does one look cool on a geeky Internet forum?). One of the HN tenants is to “converse curiously,” which is exactly my mindset when I wrote my comment. And if you look at the other replies, it seems others took it that way as well with healthy discussion.</div><br/><div id="42103325" class="c"><input type="checkbox" id="c-42103325" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#42102444">root</a><span>|</span><a href="#42102926">parent</a><span>|</span><a href="#42103206">next</a><span>|</span><label class="collapse" for="c-42103325">[-]</label><label class="expand" for="c-42103325">[1 more]</label></div><br/><div class="children"><div class="content">Your comment is generic off-topic that has only Java in common with original post. The way it is written, it gives certain vibes and doesn’t sound like genuine invitation to compare Java with other technologies. If that was your intention, maybe you should write your own post and ask there instead.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>