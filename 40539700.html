<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717232452301" as="style"/><link rel="stylesheet" href="styles.css?v=1717232452301"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.dolthub.com/blog/2024-05-31-benchmarking-go-error-handling/">Go: Sentinel errors and errors.Is() slow your code down by 3000%</a> <span class="domain">(<a href="https://www.dolthub.com">www.dolthub.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>65 comments</span></div><br/><div><div id="40542035" class="c"><input type="checkbox" id="c-40542035" checked=""/><div class="controls bullet"><span class="by">zachmu</span><span>|</span><a href="#40542102">next</a><span>|</span><label class="collapse" for="c-40542035">[-]</label><label class="expand" for="c-40542035">[9 more]</label></div><br/><div class="children"><div class="content">Blog author here with a regretful correction. This result is not accurate, mea culpa. The headline should read: errors.Is() is 500% slower.<p>Basically: the critical functions in the benchmark are small enough they were being inlined by the compiler, which means it&#x27;s possible for the compiler to further optimize the loop to avoid all comparisons in some cases, producing an inaccurate result for some of the benchmarks. You can fix this by adding noinline directives to the methods.<p>I&#x27;ll be publishing an update to the article and a post-mortem on how this slipped past review. The rank ordering of techniques in the article is unchanged, but the magnitude of the difference is not nearly so large.</div><br/><div id="40543432" class="c"><input type="checkbox" id="c-40543432" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#40542035">parent</a><span>|</span><a href="#40542440">next</a><span>|</span><label class="collapse" for="c-40543432">[-]</label><label class="expand" for="c-40543432">[1 more]</label></div><br/><div class="children"><div class="content">The thing with programming language evolution is that quite often everything except the error handling gets faster over time. If you have an app that makes aggressive use of errors, you’re not going to see the same speedups from version to version that others are seeing.<p>Particularly in JITed languages, if the multiplier is hyperbole today, there may be a day in the future where it’s accurate.</div><br/></div></div><div id="40542440" class="c"><input type="checkbox" id="c-40542440" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#40542035">parent</a><span>|</span><a href="#40543432">prev</a><span>|</span><a href="#40543007">next</a><span>|</span><label class="collapse" for="c-40542440">[-]</label><label class="expand" for="c-40542440">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for posting the update here. I was going to point out that 0.5ns for anything is almost always a sign of benchmarks being optimized away.<p>But even if those numbers had been accurate, it is important to think about how they compare to the operations being performed. Taking 4 nanoseconds to check for an error sentinel is not a huge deal when you&#x27;ve spent microseconds or even milliseconds waiting for a network service.</div><br/><div id="40542451" class="c"><input type="checkbox" id="c-40542451" checked=""/><div class="controls bullet"><span class="by">zachmu</span><span>|</span><a href="#40542035">root</a><span>|</span><a href="#40542440">parent</a><span>|</span><a href="#40543007">next</a><span>|</span><label class="collapse" for="c-40542451">[-]</label><label class="expand" for="c-40542451">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll never get those 4 nanoseconds of your life back though</div><br/><div id="40543938" class="c"><input type="checkbox" id="c-40543938" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#40542035">root</a><span>|</span><a href="#40542451">parent</a><span>|</span><a href="#40543007">next</a><span>|</span><label class="collapse" for="c-40543938">[-]</label><label class="expand" for="c-40543938">[1 more]</label></div><br/><div class="children"><div class="content">4 nanoseconds spent calling high quality functions is 4 nanoseconds well spent</div><br/></div></div></div></div></div></div><div id="40543007" class="c"><input type="checkbox" id="c-40543007" checked=""/><div class="controls bullet"><span class="by">zachmu</span><span>|</span><a href="#40542035">parent</a><span>|</span><a href="#40542440">prev</a><span>|</span><a href="#40542286">next</a><span>|</span><label class="collapse" for="c-40543007">[-]</label><label class="expand" for="c-40543007">[1 more]</label></div><br/><div class="children"><div class="content">Corrections and new title are now live. Thank you for your forbearance.</div><br/></div></div><div id="40542286" class="c"><input type="checkbox" id="c-40542286" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40542035">parent</a><span>|</span><a href="#40543007">prev</a><span>|</span><a href="#40542102">next</a><span>|</span><label class="collapse" for="c-40542286">[-]</label><label class="expand" for="c-40542286">[3 more]</label></div><br/><div class="children"><div class="content">Do you notice any difference if you update `BenchmarkFoundErrorsIs()` to the following?<p><pre><code>  func BenchmarkFoundErrorsIs(b *testing.B) {
    var es errStore
    for i := 0; i &lt; b.N; i++ {
      val, err := es.GetValue(true)
      if err != nil {
        if errors.Is(err, notFoundErr) {
          b.Fatal(&quot;expected found&quot;)
        } else {
          b.Fatal(err)
        }
      }
      if val == nil {
        b.Fatal(&quot;expected not nil&quot;)
      }
    }
  }</code></pre></div><br/><div id="40542459" class="c"><input type="checkbox" id="c-40542459" checked=""/><div class="controls bullet"><span class="by">zachmu</span><span>|</span><a href="#40542035">root</a><span>|</span><a href="#40542286">parent</a><span>|</span><a href="#40542102">next</a><span>|</span><label class="collapse" for="c-40542459">[-]</label><label class="expand" for="c-40542459">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the BenchmarkFoundErrorsIsNilCheck variation, and it eliminates the performance penalty on the happy path. Still just as bad on the error path.</div><br/><div id="40542548" class="c"><input type="checkbox" id="c-40542548" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40542035">root</a><span>|</span><a href="#40542459">parent</a><span>|</span><a href="#40542102">next</a><span>|</span><label class="collapse" for="c-40542548">[-]</label><label class="expand" for="c-40542548">[1 more]</label></div><br/><div class="children"><div class="content">My apologies! I missed that you covered that variation too. (Good to know it works as I expected though!)</div><br/></div></div></div></div></div></div></div></div><div id="40542102" class="c"><input type="checkbox" id="c-40542102" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40542035">prev</a><span>|</span><a href="#40541790">next</a><span>|</span><label class="collapse" for="c-40542102">[-]</label><label class="expand" for="c-40542102">[3 more]</label></div><br/><div class="children"><div class="content">Anyone who’s curious why `errors.Is()` is so slow (relatively speaking) should read the implementation [0]. It’s pretty obvious once you read the code—it relies on reflection followed by a tree-walking algorithm.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;9b43bfbc51c469ec13fca24960834a75b2bf66eb&#x2F;src&#x2F;errors&#x2F;wrap.go#L27-L78">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;9b43bfbc51c469ec13fca24960...</a></div><br/><div id="40542182" class="c"><input type="checkbox" id="c-40542182" checked=""/><div class="controls bullet"><span class="by">esprehn</span><span>|</span><a href="#40542102">parent</a><span>|</span><a href="#40541790">next</a><span>|</span><label class="collapse" for="c-40542182">[-]</label><label class="expand" for="c-40542182">[2 more]</label></div><br/><div class="children"><div class="content">The happy path is still just nil comparison though:<p><pre><code>  if err == nil || target == nil {
      return err == target
  }
</code></pre>
So the overhead is the function call and 2 comparisons. I wonder if the `isComparable := reflectlite.TypeOf(target).Comparable()` line was moved into a separate function if the compiler would inline Is() reducing the perf impact.<p>Possibly related: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;61502">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;61502</a><p>Looks like they&#x27;re working on improving the inliner.</div><br/></div></div></div></div><div id="40541790" class="c"><input type="checkbox" id="c-40541790" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#40542102">prev</a><span>|</span><a href="#40543947">next</a><span>|</span><label class="collapse" for="c-40541790">[-]</label><label class="expand" for="c-40541790">[1 more]</label></div><br/><div class="children"><div class="content">I think this doesn&#x27;t mean you shouldn&#x27;t ever use sentinel errors, just that you should be mindful of the performance cost, as it isn&#x27;t free. If you&#x27;re doing this for a loop where the iteration of the loop is <i>vastly</i> slower, e.g. because it is performing some sort of I&#x2F;O in each iteration, or if you&#x27;re doing this for a loop where you know the worst-case amount of iterations is very low, then you can probably safely continue to eat the cost of using sentinel errors. The only time where it is genuinely better to avoid a performance pitfall at all costs is when scaling comes into play, since then it&#x27;s very likely that it will creep up fast and make the performance absolutely unusably bad seemingly out of nowhere.<p>In practice, if you are <i>really</i> writing performance critical code, you kind of just need to benchmark and determine which bottlenecks are holding you back. Knowing the performance hit of some patterns is still useful, but it&#x27;s not a substitute for actually measuring the performance.<p>That said, the even better solution would probably be if future Go versions could just make the idiomatic code faster somehow, so that it is less likely to be a bottleneck. But, this is the case for many patterns in Go, as Go and its stdlib doesn&#x27;t really prioritize performance or zero (runtime) cost abstractions. (They justify this with data; in developers surveys, time and time again Go developers greatly express their priority in having robust, &quot;safer&quot; code over higher performance code.)</div><br/></div></div><div id="40543947" class="c"><input type="checkbox" id="c-40543947" checked=""/><div class="controls bullet"><span class="by">Ferret7446</span><span>|</span><a href="#40541790">prev</a><span>|</span><a href="#40541468">next</a><span>|</span><label class="collapse" for="c-40543947">[-]</label><label class="expand" for="c-40543947">[1 more]</label></div><br/><div class="children"><div class="content">This calls for the classic quote: &quot;Premature optimization is the root of all evil&quot;<p>I expect the vast majority of code spends so little time in errors.Is() that trying to optimize it saves nothing.  Profile first, and change it later if needed; as Go is statically typed such a change is trivial.</div><br/></div></div><div id="40541468" class="c"><input type="checkbox" id="c-40541468" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40543947">prev</a><span>|</span><a href="#40543467">next</a><span>|</span><label class="collapse" for="c-40541468">[-]</label><label class="expand" for="c-40541468">[10 more]</label></div><br/><div class="children"><div class="content">Sorry, that&#x27;s still not a reason to use bools instead of &quot;errors&quot; and<p><pre><code>    An error should by default be considered non-recoverable, to be returned when something goes very wrong. Semantically, a table not existing isn&#x27;t really an error, it&#x27;s something you expect to happen all the time. 
</code></pre>
remains a bad idea.<p>Seems like the reason for this article is the reaction to that one: <a href="https:&#x2F;&#x2F;www.dolthub.com&#x2F;blog&#x2F;2024-05-10-ok-considered-harmful&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.dolthub.com&#x2F;blog&#x2F;2024-05-10-ok-considered-harmfu...</a></div><br/><div id="40542144" class="c"><input type="checkbox" id="c-40542144" checked=""/><div class="controls bullet"><span class="by">zachmu</span><span>|</span><a href="#40541468">parent</a><span>|</span><a href="#40543900">next</a><span>|</span><label class="collapse" for="c-40542144">[-]</label><label class="expand" for="c-40542144">[1 more]</label></div><br/><div class="children"><div class="content">Agree to disagree here. And yes, this article is a follow-up to the linked one.<p>The last section of the blog has a discussion of aesthetic and philosophical concerns around using errors for control flow. I&#x27;m against it, for the reasons I provide. YMMV.</div><br/></div></div><div id="40543900" class="c"><input type="checkbox" id="c-40543900" checked=""/><div class="controls bullet"><span class="by">trustno2</span><span>|</span><a href="#40541468">parent</a><span>|</span><a href="#40542144">prev</a><span>|</span><a href="#40542454">next</a><span>|</span><label class="collapse" for="c-40543900">[-]</label><label class="expand" for="c-40543900">[1 more]</label></div><br/><div class="children"><div class="content">Go returns bool for map access, not errors...</div><br/></div></div><div id="40542454" class="c"><input type="checkbox" id="c-40542454" checked=""/><div class="controls bullet"><span class="by">aaomidi</span><span>|</span><a href="#40541468">parent</a><span>|</span><a href="#40543900">prev</a><span>|</span><a href="#40541882">next</a><span>|</span><label class="collapse" for="c-40542454">[-]</label><label class="expand" for="c-40542454">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you.<p>The go standard library uses sentinel errors. ErrNotFound is actually good to use, because otherwise, a `Get` call can end up returning `nil, nil` (*Value, error). Which is just bad.</div><br/></div></div><div id="40541882" class="c"><input type="checkbox" id="c-40541882" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40541468">parent</a><span>|</span><a href="#40542454">prev</a><span>|</span><a href="#40543467">next</a><span>|</span><label class="collapse" for="c-40541882">[-]</label><label class="expand" for="c-40541882">[6 more]</label></div><br/><div class="children"><div class="content">That quote conflates errors and exceptions. An error is an <i>unsuccessful</i> result. An exception, however, precludes any result at all. Sometimes they are the same, but in many cases they are different.<p>Asking to retrieve a table that doesn&#x27;t exist is an error, because the answer is that there is no table; the operation was unsuccessful. There failed to be retrieved any table, but as the table always could have either existed or not, this is not an exceptional case. Nothing went wrong: you simply asked to retrieve a table and no table was found, so you get that back as an error.<p>However, trying to perform a table operation on that unsuccessful result generates an exception, because you violated a contract: you can&#x27;t operate on something that doesn&#x27;t exist. Sure, you can operate on the representation of nonexistence (that is, null), but you attempted to operate on a table and you don&#x27;t have one.<p>The computation stops prematurely with an exception because the operation expects the table to necessarily exist. There is no unsuccessful result to be returned because the operation didn&#x27;t even make it to the point of failing; the <i>performance itself</i> of the operation failed. The operation is entirely invalid and returning any result would be incorrect.<p>At least, that is my personal understanding of the terms.<p>For example, most things in Rust are errors and not exceptions, because exceptions (panics) generally terminate the thread, or abort the process, depending on user preference or runtime environment. Anything that isn&#x27;t fatally unrecoverable deserves to be an error - in other words, a `Result::Err` - which can be handled by the caller, as opposed to panics, which are not guaranteed to be catchable (unwinding is not a required part of the language, it is an optional convenience).<p>Most failures in JavaScript are exceptions, because you are not made to check anything, and everything is dynamically typed, so if you make an assumption that isn&#x27;t true, an exception has to be raised to stop you. Luckily, there is try&#x2F;catch. It can also be difficult to represent errors without exceptions, you instead have things called &quot;error <i>states</i>&quot; which are basically certain non-errors being treated as errors by user code, when either that result is undesired even if perfectly normal, or that result is the only&#x2F;easiest way for the error to be reported by the source.<p>Anyway, my point is that the article probably means to use the term exception and say that a boolean is better than an exception when the error isn&#x27;t an exceptional case. And in that case I would agree. In Rust, I don&#x27;t want my program to crash when I ask for a nonexistent table - I only want that to happen later if <i>I</i> decide that the table&#x27;s nonexistence is a fatal error in the context of the whole thread.</div><br/><div id="40543606" class="c"><input type="checkbox" id="c-40543606" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#40541468">root</a><span>|</span><a href="#40541882">parent</a><span>|</span><a href="#40542709">next</a><span>|</span><label class="collapse" for="c-40543606">[-]</label><label class="expand" for="c-40543606">[4 more]</label></div><br/><div class="children"><div class="content">You are explaining the diferrence between error results and panics in Rust, and maybe this also applies to Go. But this is very much not how exceptions (a word these languages don&#x27;t even use) are understood in languages which have them.<p>In Java, C#, C++, for example, exceptions are meant for any situation where the operation you asked for can&#x27;t be completed successfully, for whatever reason. The most common example is IOException: if you asked to read 200 bytes from a socket, but the connection got interrupted after 100 bytes, that&#x27;s an IOException. This would not be appropriate as a panic in Go or Rust, for a comparison of the difference in philosophy.</div><br/><div id="40543681" class="c"><input type="checkbox" id="c-40543681" checked=""/><div class="controls bullet"><span class="by">spockz</span><span>|</span><a href="#40541468">root</a><span>|</span><a href="#40543606">parent</a><span>|</span><a href="#40543960">next</a><span>|</span><label class="collapse" for="c-40543681">[-]</label><label class="expand" for="c-40543681">[2 more]</label></div><br/><div class="children"><div class="content">I like your example. Although I do remember that there are also read operations where you ask for 200 bytes and you can get 100 back. And it is up to the caller to check for this. Otoh, if the socket is closed you indeed get a socket closed exception. But that is because the docker was closed while reading. What is the rust behaviour in this case?</div><br/><div id="40544041" class="c"><input type="checkbox" id="c-40544041" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40541468">root</a><span>|</span><a href="#40543681">parent</a><span>|</span><a href="#40543960">next</a><span>|</span><label class="collapse" for="c-40544041">[-]</label><label class="expand" for="c-40544041">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I do remember that there are also read operations where you ask for 200 bytes and you can get 100 back.<p>Those are read operations where you say you have 200 bytes to store the result, rather than where you ask for exactly 200 bytes. But yes, they certainly exist, the ones that ask for exact numbers of bytes are typically built on repeated calls to the ones that can return less.<p>&gt; Otoh, if the socket is closed you indeed get a socket closed exception. But that is because the docker was closed while reading.<p>I think this depends on how it closed, sometimes you just get EOF, which is an error state but not an exception (unless your language is clinically insane like Python). Obviously if it&#x27;s interrupted in such a way that there would probably have been more data but you can no longer get it, that&#x27;s a different error than EOF (and some languages use exceptional control flow to report mere errors, it is just that Rust does not do this).<p>&gt; What is the rust behaviour in this case?<p>Read calls can return less data than you asked for. If they return <i>no</i> data, that is a successful EOS. They can also report I&#x2F;O errors as distinct from a successful result.<p>There <i>is</i> an I&#x2F;O error for &quot;<i>unexpected</i> EOF&quot;, where you <i>require</i> more data than is present, and the fact that it&#x27;s not present is an error. I believe `read_exact` uses this if anything happens before it has entirely filled the buffer, including completely normal connection closure.</div><br/></div></div></div></div><div id="40543960" class="c"><input type="checkbox" id="c-40543960" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40541468">root</a><span>|</span><a href="#40543606">parent</a><span>|</span><a href="#40543681">prev</a><span>|</span><a href="#40542709">next</a><span>|</span><label class="collapse" for="c-40543960">[-]</label><label class="expand" for="c-40543960">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You are explaining the diferrence between error results and panics in Rust<p>That is indeed an example I included, yes<p>&gt; In Java, C#, C++, for example, exceptions are meant for any situation where the operation you asked for can&#x27;t be completed successfully, for whatever reason. The most common example is IOException: if you asked to read 200 bytes from a socket, but the connection got interrupted after 100 bytes, that&#x27;s an IOException.<p>- Java has checked exceptions, which... ugh, I&#x27;m not going to get too much into this, but this is basically their terrible way of representing expected errors while reusing the try&#x2F;catch syntax. Yes, the thing is called exceptions at the language level. Yes, they do interrupt control flow. But fundamentally I consider them mere errors.<p>- C++ overuses exceptions in a similar way, except they&#x27;re not checked because fuck you, nothing in C++ is checked.<p>The relevant quote&#x27;s talking about <i>semantics</i>, so I&#x27;m talking about errors and exceptions as something that transcends the individual programming language. Different languages are different and don&#x27;t always (even usually don&#x27;t) map these concepts 1:1.</div><br/></div></div></div></div><div id="40542709" class="c"><input type="checkbox" id="c-40542709" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40541468">root</a><span>|</span><a href="#40541882">parent</a><span>|</span><a href="#40543606">prev</a><span>|</span><a href="#40543467">next</a><span>|</span><label class="collapse" for="c-40542709">[-]</label><label class="expand" for="c-40542709">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Sometimes they are the same</i><p>Your understanding otherwise seems on point, but I&#x27;m not sure they can ever be the same. An exception is the representation of programmer fault. An error, on the other hand, is the representation of faults outside of the programmer&#x27;s control.<p>Like you point out, operating on a missing table is a mistake made by the programmer. This fault could have been avoided when the code was written. The table not being there is not within the control of the developer (with some assumptions of what table is meant to mean here) and no amount of perfect coding could have avoided the situation.<p><i>&gt; Most failures in JavaScript are exceptions</i><p>Idiomatic Javascript suggests handling errors using its exception handling mechanism, but the payload is still error in nature. In fact, the base object the idioms suggest you use to hold error data, passed using the exception handler, is literally called Error.<p>Javascript may be confused by having no official &quot;Exception&quot; type. Although arguably it does not need one as you can simply throw a string, which is all you need for an exception. The exception handler will tack on the rest of the information you need to know automatically. Java takes a different opinion, though, having two different, albeit poorly named, built-in classes for errors (Exception) and exceptions (RuntimeException).</div><br/></div></div></div></div></div></div><div id="40543467" class="c"><input type="checkbox" id="c-40543467" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#40541468">prev</a><span>|</span><a href="#40541719">next</a><span>|</span><label class="collapse" for="c-40543467">[-]</label><label class="expand" for="c-40543467">[1 more]</label></div><br/><div class="children"><div class="content">Nice write-up.<p>It&#x27;s a shame that errors.Is is slow for general use, and at least some of that seems attributable to the Comparable change requiring reflection. Multi-errors seems to have bloated the switch. And of course the lack of a happy-path that was fixed in [1].<p>Since Go already has two ways of handling exceptional state: return or panic, it does feel like a stretch to also introduce a &quot;not found&quot; path too. All bets are off in tight inner loops, but I think as a general coding practice, it&#x27;ll make the language (de facto) more complicated&#x2F;ambiguous.<p>But my take away is that the question has been kicked off: can wrapped errors be made more efficient?<p>1. <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;commit&#x2F;af43932c20d5b59cdffca45406754dbccbb46dfa">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;commit&#x2F;af43932c20d5b59cdffca454...</a></div><br/></div></div><div id="40541719" class="c"><input type="checkbox" id="c-40541719" checked=""/><div class="controls bullet"><span class="by">L-four</span><span>|</span><a href="#40543467">prev</a><span>|</span><a href="#40541201">next</a><span>|</span><label class="collapse" for="c-40541719">[-]</label><label class="expand" for="c-40541719">[3 more]</label></div><br/><div class="children"><div class="content">It shouldn&#x27;t surprise anyone that a checking a bool is faster than calling a function and checking the bool it returns.</div><br/><div id="40542133" class="c"><input type="checkbox" id="c-40542133" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40541719">parent</a><span>|</span><a href="#40542028">next</a><span>|</span><label class="collapse" for="c-40542133">[-]</label><label class="expand" for="c-40542133">[1 more]</label></div><br/><div class="children"><div class="content">The function call itself isn’t really the culprit (the cost of the function call itself is negligible in this case). It’s the implementation of the function [0].<p>[0]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40542102">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40542102</a></div><br/></div></div></div></div><div id="40541201" class="c"><input type="checkbox" id="c-40541201" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#40541719">prev</a><span>|</span><a href="#40542568">next</a><span>|</span><label class="collapse" for="c-40541201">[-]</label><label class="expand" for="c-40541201">[1 more]</label></div><br/><div class="children"><div class="content">I like posts like this.<p>I learn something about a tool I love and have used for 10 years and it isn&#x27;t snarky, flamebait nor preachy.</div><br/></div></div><div id="40542568" class="c"><input type="checkbox" id="c-40542568" checked=""/><div class="controls bullet"><span class="by">eightnoteight</span><span>|</span><a href="#40541201">prev</a><span>|</span><a href="#40543415">next</a><span>|</span><label class="collapse" for="c-40542568">[-]</label><label class="expand" for="c-40542568">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The problem is that sentinel errors, as typically and idiomatically used, in fact are special, and are more expensive to deal with than other values. My suggestion to use boolean values outperforms them by a lot, 30x in fairly common idiomatic usage.<p>while I agree to some degree, but when performance comes into picture, what really matters more is normal path vs surprise path rather than happy path vs error path<p>it&#x27;s hard to argue what is a happy path in the code, but it&#x27;s not wrong to say that io.EOF check is a normal path of the code i.e. not a surprise in production. the bad performance of errors.Is is something to be improved upon but it&#x27;s not a surprise in production when there are a large number of `errors.Is` checks during normal path of the code<p>now coming to the surprise path of the code, here&#x27;s where performance gets really important, no one wants their code to suddenly hog 100% CPU because of some special error case - <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;cloudflare-outage" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;cloudflare-outage</a> . but such surprise paths often contain a large amount of business logic that weigh much more than how slow errors.Is function is compared to a boolean check<p>it would be interesting to see where this line of reasoning is valid but IMO performance isn&#x27;t a good argument against why errors are not normal outcomes of operations in production<p>but thumbs up for the article, now I know what to reference for backing the below pattern that I often use, when I first saw the errors.Is it was pretty obvious that its going to be slow but just didn&#x27;t have time to prove it and use below pattern<p>```<p>if err != nil &amp;&amp; errors.Is(err, x) {<p>} else if err != nil  &amp;&amp; errors.Is(err, y) {<p>} else if err != nil {<p><pre><code>    &#x2F;&#x2F; handling unknown error
</code></pre>
}<p>```</div><br/></div></div><div id="40543415" class="c"><input type="checkbox" id="c-40543415" checked=""/><div class="controls bullet"><span class="by">ongy</span><span>|</span><a href="#40542568">prev</a><span>|</span><a href="#40541451">next</a><span>|</span><label class="collapse" for="c-40543415">[-]</label><label class="expand" for="c-40543415">[1 more]</label></div><br/><div class="children"><div class="content">@zachmu can you upload the code you ran to a public repo?<p>I&#x27;d like to play with it a bit, to compare patterns I&#x27;ve done before and am too lazy to copy+paste ;)</div><br/></div></div><div id="40541451" class="c"><input type="checkbox" id="c-40541451" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#40543415">prev</a><span>|</span><a href="#40541944">next</a><span>|</span><label class="collapse" for="c-40541451">[-]</label><label class="expand" for="c-40541451">[5 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a tangential issue in Rust where there&#x27;s a concern around if a library should be exposing the error types of its dependencies. If they are exposed, semver is broken anytime a dependency is updated in a semver breaking fashion. I, in general, agree that this breaks encapsulation and is not good. However, and maybe I&#x27;m doing things wrong, but often enough there are edge cases where it is important to distinguish between different errors and adjust control flow. Often, library authors will not be able to foresee all possible usecases for their error types, so one can end up doing some horrible type casting or worse hacks to get at the actual underlying data. I&#x27;m still torn as to what is the better way forward.</div><br/><div id="40542207" class="c"><input type="checkbox" id="c-40542207" checked=""/><div class="controls bullet"><span class="by">tempaccount420</span><span>|</span><a href="#40541451">parent</a><span>|</span><a href="#40541694">next</a><span>|</span><label class="collapse" for="c-40542207">[-]</label><label class="expand" for="c-40542207">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think errors should have to follow semver. Please, break my match on non-major version bumps, if I didn&#x27;t explicitly add a catch-all case.</div><br/></div></div><div id="40541694" class="c"><input type="checkbox" id="c-40541694" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#40541451">parent</a><span>|</span><a href="#40542207">prev</a><span>|</span><a href="#40541944">next</a><span>|</span><label class="collapse" for="c-40541694">[-]</label><label class="expand" for="c-40541694">[3 more]</label></div><br/><div class="children"><div class="content">java has the &quot;rootCause&quot; constructor which wraps another Exception (actually Throwable) of any type passed in.  so the idiomatic way would be to create your own error types, but to pass the lower-level exception in as the rootCause so you can trace the exceptions down the stack if desired.  Since the type is Throwable rather than a dependency-specific exception, this isn&#x27;t exposed in the <i>interface</i> unless you go out of your way to cast things in an obviously dangerous way.<p>Does that not exist in Rust?</div><br/><div id="40542276" class="c"><input type="checkbox" id="c-40542276" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40541451">root</a><span>|</span><a href="#40541694">parent</a><span>|</span><a href="#40541944">next</a><span>|</span><label class="collapse" for="c-40542276">[-]</label><label class="expand" for="c-40542276">[2 more]</label></div><br/><div class="children"><div class="content">When you say &quot;obviously dangerous&quot; do you mean &quot;obviously breaking encapsulation&quot; or is there a bigger issue?  If there&#x27;s a bigger issue then I&#x27;m not sure how it&#x27;s useful for solving this problem of wanting the details.</div><br/><div id="40543180" class="c"><input type="checkbox" id="c-40543180" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#40541451">root</a><span>|</span><a href="#40542276">parent</a><span>|</span><a href="#40541944">next</a><span>|</span><label class="collapse" for="c-40543180">[-]</label><label class="expand" for="c-40543180">[1 more]</label></div><br/><div class="children"><div class="content">&quot;obviously breaking encapsulation&quot;, like if you pull some interface from the dependency through yours, then yeah, you&#x27;re broken when they break things.  That&#x27;s a generalized interface problem and java can&#x27;t help you anymore than rust can.  But I guess it&#x27;s true that it may not be obvious that library interfaces may churn unexpectedly etc, you are dependent on the good behavior of others unless you specifically take steps to abstract it.<p>(although you do absolutely have to be careful about what you are returning in a client-facing error message etc.  don&#x27;t return the parts of the stack trace that leak information about your application to an actual client, they should be caught by your framework and turned into generic &quot;4xx git rekt&quot;&#x2F;&quot;5xx we made a fucky wucky&quot; messages that don&#x27;t reveal too much about your environment.)<p>not a java problem specifically for either of those, it just seems odd coming from that world that there&#x27;s not a concept of a &quot;recursive exception stack&quot; like that in rust?</div><br/></div></div></div></div></div></div></div></div><div id="40541944" class="c"><input type="checkbox" id="c-40541944" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#40541451">prev</a><span>|</span><a href="#40541679">next</a><span>|</span><label class="collapse" for="c-40541944">[-]</label><label class="expand" for="c-40541944">[5 more]</label></div><br/><div class="children"><div class="content">Wish `errors.Is` immediately checked whether err is `nil` and returned `false`. Could have simply solved this issue I think.</div><br/><div id="40542158" class="c"><input type="checkbox" id="c-40542158" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40541944">parent</a><span>|</span><a href="#40541679">next</a><span>|</span><label class="collapse" for="c-40542158">[-]</label><label class="expand" for="c-40542158">[4 more]</label></div><br/><div class="children"><div class="content">The first 3 lines of `errors.Is()` [0] are the following:<p><pre><code>  if err == nil || target == nil {
    return err == target
  }
</code></pre>
[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;9b43bfbc51c469ec13fca24960834a75b2bf66eb&#x2F;src&#x2F;errors&#x2F;wrap.go#L45-L47">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;9b43bfbc51c469ec13fca24960...</a></div><br/><div id="40542425" class="c"><input type="checkbox" id="c-40542425" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#40541944">root</a><span>|</span><a href="#40542158">parent</a><span>|</span><a href="#40541679">next</a><span>|</span><label class="collapse" for="c-40542425">[-]</label><label class="expand" for="c-40542425">[3 more]</label></div><br/><div class="children"><div class="content">Glad to know they have fixed this. In Go 1.22.3 (the latest release), the first 3 lines of `errors.is` [0] are the following:<p><pre><code>    if target == nil {
      return err == target
    }
</code></pre>
[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;go1.22.3&#x2F;src&#x2F;errors&#x2F;wrap.go#L45-L47">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;go1.22.3&#x2F;src&#x2F;errors&#x2F;wrap.g...</a></div><br/><div id="40542626" class="c"><input type="checkbox" id="c-40542626" checked=""/><div class="controls bullet"><span class="by">zachmu</span><span>|</span><a href="#40541944">root</a><span>|</span><a href="#40542425">parent</a><span>|</span><a href="#40541679">next</a><span>|</span><label class="collapse" for="c-40542626">[-]</label><label class="expand" for="c-40542626">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting, because I ran the benchmarks on that version of Go.</div><br/><div id="40542746" class="c"><input type="checkbox" id="c-40542746" checked=""/><div class="controls bullet"><span class="by">richbell</span><span>|</span><a href="#40541944">root</a><span>|</span><a href="#40542626">parent</a><span>|</span><a href="#40541679">next</a><span>|</span><label class="collapse" for="c-40542746">[-]</label><label class="expand" for="c-40542746">[1 more]</label></div><br/><div class="children"><div class="content">The `err == nil` check was added in April to avoid expensive and unnecessary reflection. Perhaps 1.23, or whichever release that ends 
up in, would be faster?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;commit&#x2F;af43932c20d5b59cdffca45406754dbccbb46dfa">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;commit&#x2F;af43932c20d5b59cdffca454...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40541679" class="c"><input type="checkbox" id="c-40541679" checked=""/><div class="controls bullet"><span class="by">zitterbewegung</span><span>|</span><a href="#40541944">prev</a><span>|</span><a href="#40541457">next</a><span>|</span><label class="collapse" for="c-40541679">[-]</label><label class="expand" for="c-40541679">[1 more]</label></div><br/><div class="children"><div class="content">In error handling or even reporting status there seems to be a part of being unaware that using stdout or some other strategy is either designed incorrectly which leads to slowdowns or people don’t understand when to use it. Sure languages also have this slowdown or have some documentation about it but many people just use what seems to be correct.</div><br/></div></div><div id="40541457" class="c"><input type="checkbox" id="c-40541457" checked=""/><div class="controls bullet"><span class="by">manlobster</span><span>|</span><a href="#40541679">prev</a><span>|</span><a href="#40542316">next</a><span>|</span><label class="collapse" for="c-40541457">[-]</label><label class="expand" for="c-40541457">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Here&#x27;s one of them, which follows a common recommendation in the Go community to use a sentinel error to represent the &quot;value not found&quot; condition.<p>Is this really a common recommendation in the Go community? Seems like returning `bool` to indicate if the value was found is somewhat of a no-brainer, since it follows the familiar approach used for map lookups and type assertions.</div><br/><div id="40541507" class="c"><input type="checkbox" id="c-40541507" checked=""/><div class="controls bullet"><span class="by">segfaltnh</span><span>|</span><a href="#40541457">parent</a><span>|</span><a href="#40541727">next</a><span>|</span><label class="collapse" for="c-40541507">[-]</label><label class="expand" for="c-40541507">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve certainly seen and emulated this pattern in a lot of Go code. I don&#x27;t know if I am representative of the larger community. I often use bool unless there are other error conditions (and there often are), but this article is definitely making me wonder if this is ideal.</div><br/></div></div><div id="40541727" class="c"><input type="checkbox" id="c-40541727" checked=""/><div class="controls bullet"><span class="by">abound</span><span>|</span><a href="#40541457">parent</a><span>|</span><a href="#40541507">prev</a><span>|</span><a href="#40542316">next</a><span>|</span><label class="collapse" for="c-40541727">[-]</label><label class="expand" for="c-40541727">[2 more]</label></div><br/><div class="children"><div class="content">There are at least two places in the standard library that behave like this: sql.ErrNoRows and the error thrown by os.Open when a file doesn&#x27;t exist.</div><br/><div id="40542043" class="c"><input type="checkbox" id="c-40542043" checked=""/><div class="controls bullet"><span class="by">manlobster</span><span>|</span><a href="#40541457">root</a><span>|</span><a href="#40541727">parent</a><span>|</span><a href="#40542316">next</a><span>|</span><label class="collapse" for="c-40542043">[-]</label><label class="expand" for="c-40542043">[1 more]</label></div><br/><div class="children"><div class="content">True, but both of these are for relatively slow operations, where the performance of the error checking is relatively insignificant.</div><br/></div></div></div></div></div></div><div id="40542316" class="c"><input type="checkbox" id="c-40542316" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#40541457">prev</a><span>|</span><a href="#40542078">next</a><span>|</span><label class="collapse" for="c-40542316">[-]</label><label class="expand" for="c-40542316">[1 more]</label></div><br/><div class="children"><div class="content">Is the performance lost in the panic recover() not the actual panic?<p>Just a guess, I&#x27;m not a Go person.<p>If there&#x27;s no attempt to recover in the code, then panic() wouldn&#x27;t need to save any state and the compiler might just optimise out anything needed for recover()y.</div><br/></div></div><div id="40542078" class="c"><input type="checkbox" id="c-40542078" checked=""/><div class="controls bullet"><span class="by">SPascareli13</span><span>|</span><a href="#40542316">prev</a><span>|</span><a href="#40541206">next</a><span>|</span><label class="collapse" for="c-40542078">[-]</label><label class="expand" for="c-40542078">[2 more]</label></div><br/><div class="children"><div class="content">How is this not a compiler bug? What would justify a nil check being many times more expensive then a bool check?</div><br/><div id="40542333" class="c"><input type="checkbox" id="c-40542333" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#40542078">parent</a><span>|</span><a href="#40541206">next</a><span>|</span><label class="collapse" for="c-40542333">[-]</label><label class="expand" for="c-40542333">[1 more]</label></div><br/><div class="children"><div class="content">The nil check is not more expensive.</div><br/></div></div></div></div><div id="40541206" class="c"><input type="checkbox" id="c-40541206" checked=""/><div class="controls bullet"><span class="by">richbell</span><span>|</span><a href="#40542078">prev</a><span>|</span><a href="#40542378">next</a><span>|</span><label class="collapse" for="c-40541206">[-]</label><label class="expand" for="c-40541206">[8 more]</label></div><br/><div class="children"><div class="content">&gt; errors.Is() is expensive. If you use it, check the error is non-nil first to avoid a pretty big performance penalty on the happy path.<p>Am I missing something, or could this be partially mitigated by adding a check for `err == nil &amp;&amp; target != nil` and vice versa, rather than `err == target`?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;9b43bfbc51c469ec13fca24960834a75b2bf66eb&#x2F;src&#x2F;errors&#x2F;wrap.go#L44">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;9b43bfbc51c469ec13fca24960...</a></div><br/><div id="40541658" class="c"><input type="checkbox" id="c-40541658" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40541206">parent</a><span>|</span><a href="#40541549">next</a><span>|</span><label class="collapse" for="c-40541658">[-]</label><label class="expand" for="c-40541658">[3 more]</label></div><br/><div class="children"><div class="content">What he is missing is that if the max. 3 pointer comparisons in (together with the function call of `Is`)<p><pre><code>    if err == nil || target == nil {
        return err == target
    }
</code></pre>
are a &quot;pretty big performance penalty&quot;, there isn&#x27;t much work going on. I mean, of course, these 2 or 3 comparisons + the function call of `Is` are at least double that of<p><pre><code>      err != nil
</code></pre>
even if `Is` would have been inlined by the compiler.</div><br/><div id="40542767" class="c"><input type="checkbox" id="c-40542767" checked=""/><div class="controls bullet"><span class="by">richbell</span><span>|</span><a href="#40541206">root</a><span>|</span><a href="#40541658">parent</a><span>|</span><a href="#40541549">next</a><span>|</span><label class="collapse" for="c-40542767">[-]</label><label class="expand" for="c-40542767">[2 more]</label></div><br/><div class="children"><div class="content">Actually, the `err == nil` check doesn&#x27;t exist in the latest release. It was added recently, which would explain the significant performance cost. If err is nil, it doesn&#x27;t return early.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blame&#x2F;adbfb672ba485630d75f8b5598228a63f4af08a4&#x2F;src&#x2F;errors&#x2F;wrap.go#L44">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blame&#x2F;adbfb672ba485630d75f8b559...</a></div><br/><div id="40543373" class="c"><input type="checkbox" id="c-40543373" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#40541206">root</a><span>|</span><a href="#40542767">parent</a><span>|</span><a href="#40541549">next</a><span>|</span><label class="collapse" for="c-40543373">[-]</label><label class="expand" for="c-40543373">[1 more]</label></div><br/><div class="children"><div class="content">Nice find. This commit: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;commit&#x2F;af43932c20d5b59cdffca45406754dbccbb46dfa">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;commit&#x2F;af43932c20d5b59cdffca454...</a> from April 4.</div><br/></div></div></div></div></div></div><div id="40541549" class="c"><input type="checkbox" id="c-40541549" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40541206">parent</a><span>|</span><a href="#40541658">prev</a><span>|</span><a href="#40542378">next</a><span>|</span><label class="collapse" for="c-40541549">[-]</label><label class="expand" for="c-40541549">[4 more]</label></div><br/><div class="children"><div class="content">I wonder why the compiler can&#x27;t be smart enough to optimize such a case.</div><br/><div id="40542667" class="c"><input type="checkbox" id="c-40542667" checked=""/><div class="controls bullet"><span class="by">Tomis02</span><span>|</span><a href="#40541206">root</a><span>|</span><a href="#40541549">parent</a><span>|</span><a href="#40542778">next</a><span>|</span><label class="collapse" for="c-40542667">[-]</label><label class="expand" for="c-40542667">[1 more]</label></div><br/><div class="children"><div class="content">We probably don&#x27;t need programmers either, the compiler should be smart enough to know what the stakeholders mean.</div><br/></div></div><div id="40542778" class="c"><input type="checkbox" id="c-40542778" checked=""/><div class="controls bullet"><span class="by">richbell</span><span>|</span><a href="#40541206">root</a><span>|</span><a href="#40541549">parent</a><span>|</span><a href="#40542667">prev</a><span>|</span><a href="#40542369">next</a><span>|</span><label class="collapse" for="c-40542778">[-]</label><label class="expand" for="c-40542778">[1 more]</label></div><br/><div class="children"><div class="content">The answer is apparently that the code I linked isn&#x27;t released yet.<p>The latest available release only checks if target is nil.</div><br/></div></div><div id="40542369" class="c"><input type="checkbox" id="c-40542369" checked=""/><div class="controls bullet"><span class="by">flexagoon</span><span>|</span><a href="#40541206">root</a><span>|</span><a href="#40541549">parent</a><span>|</span><a href="#40542778">prev</a><span>|</span><a href="#40542378">next</a><span>|</span><label class="collapse" for="c-40542369">[-]</label><label class="expand" for="c-40542369">[1 more]</label></div><br/><div class="children"><div class="content">It already does</div><br/></div></div></div></div></div></div><div id="40542378" class="c"><input type="checkbox" id="c-40542378" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#40541206">prev</a><span>|</span><a href="#40542942">next</a><span>|</span><label class="collapse" for="c-40542378">[-]</label><label class="expand" for="c-40542378">[1 more]</label></div><br/><div class="children"><div class="content">For other fun surprises that are rather obvious from the implementation but still surprise people quite regularly: wait until you see how much slower context keys are when compared to thread locals, particularly since it&#x27;s normal for contexts to contain MANY layers (as opposed to errors, which are frequently* returned without wrapping at almost any level).  It&#x27;s a glorified linked-list lookup, and it re-walks the whole path every time.<p>But for both contexts and errors: imo the tradeoff is overwhelmingly in favor of wrapping more, not less, in the <i>vast</i> majority of code.  Context is useful and standard for many things, and wrapped errors carry a lot more useful information, and both of those are absolutely crucial for healthy interop with other code.  Performance sensitive stuff can do whatever it needs, these are obviously <i>terrible</i> choices there so just don&#x27;t even consider it.<p>* but not always! and it may change with time. Still, my contexts are regularly 10+ layers deep while my errors are rarely more than one or two.</div><br/></div></div><div id="40542942" class="c"><input type="checkbox" id="c-40542942" checked=""/><div class="controls bullet"><span class="by">-mlv</span><span>|</span><a href="#40542378">prev</a><span>|</span><a href="#40542925">next</a><span>|</span><label class="collapse" for="c-40542942">[-]</label><label class="expand" for="c-40542942">[1 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t want to be that guy, but I think the author meant to say &#x27;96.77%&#x27; instead of &#x27;3000%&#x27;, or &#x27;96.66%&#x27; instead of &#x27;30x&#x27;.</div><br/></div></div><div id="40542925" class="c"><input type="checkbox" id="c-40542925" checked=""/><div class="controls bullet"><span class="by">12345hn6789</span><span>|</span><a href="#40542942">prev</a><span>|</span><a href="#40542875">next</a><span>|</span><label class="collapse" for="c-40542925">[-]</label><label class="expand" for="c-40542925">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the updates and article.<p>If this is s big deal perhaps you should be choosing a different language :)<p>Also BTW the nested `errors.Is` bench is wrong. Each function is wrapping the errors instead of constructing them preemptively and this is benching the time to create nested errors. Don&#x27;t do this, in the test or real code. It makes it tough to read as a client.</div><br/></div></div><div id="40542875" class="c"><input type="checkbox" id="c-40542875" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40542925">prev</a><span>|</span><a href="#40542509">next</a><span>|</span><label class="collapse" for="c-40542875">[-]</label><label class="expand" for="c-40542875">[1 more]</label></div><br/><div class="children"><div class="content">The numbers in the benchmark are unsurprising for Go.<p>Comparable code (for errors.Is()) written in C# takes about 4ns on M1 Pro:<p>(made unidiomatic and abstracion-heavy-ish for demonstration purposes)<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;neon-sunset&#x2F;65a8deeaac745ba159f990c78681f313" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;neon-sunset&#x2F;65a8deeaac745ba159f990c7...</a><p>Of course were it rewritten to a TryGet or (object, bool), it would bring that to 1-3 CPU cycles, as everything would get inlined and lowered to a few branches.</div><br/></div></div><div id="40542509" class="c"><input type="checkbox" id="c-40542509" checked=""/><div class="controls bullet"><span class="by">neild</span><span>|</span><a href="#40542875">prev</a><span>|</span><label class="collapse" for="c-40542509">[-]</label><label class="expand" for="c-40542509">[3 more]</label></div><br/><div class="children"><div class="content">There are some interesting results in here, but the slower cases are a bit misleading. The majority of time in the slow cases is spent constructing errors, not in errors.Is.<p>Some background for anyone not familiar with Go errors:<p>A Go error is an interface value with an Error method that returns the error&#x27;s text. A simple error can be constructed with the errors.New function:<p><pre><code>  var ErrNotFound = errors.New(&quot;not found&quot;)
</code></pre>
A nil error indicates success, and a non-nil error indicates some other condition. This is the infamous &quot;if err != nil {}&quot; check. Comparing an error to nil is pretty fast, since it&#x27;s just a single pointer comparison. On my laptop, it&#x27;s about 0.5ns. Comparing a bool is about 0.3ns, so &quot;err != nil&quot; is quite a bit slower than &quot;!found&quot;, but it&#x27;s really unlikely the 0.2ns is going to be relevant outside of extremely hot loops.<p>We can also compare an error to some value: &quot;if err == ErrNotFound {}&quot;. In this case, we say that ErrNotFound is a &quot;sentinel&quot; (some error value that you compare against). This is about 2.3ns on my laptop; there are two pointer comparisons in this case and a bit more overhead in comparing interface values. (You can actually make this check almost arbitrarily expensive; you could have an error value that&#x27;s a gigabyte-large array, for example.)<p>It&#x27;s common to annotate an error, adding some more useful information to it. For example, we might want our &quot;not found&quot; error to say what was not found:<p><pre><code>  return fmt.Errorf(&quot;%q: not found&quot;, name) &#x2F;&#x2F; &quot;foo&quot;: not found
</code></pre>
This is quite a bit more expensive than &quot;return ErrNotFound&quot;. The fmt.Errorf function will parse a format string, produce the error text, and make two allocations (one for the error string, one for a small struct that holds it). This is about 84ns on my laptop--168 times slower than the fast path! But 84ns is still pretty fast, and you can&#x27;t get away from the need for at least one allocation if you want to return an error that&#x27;s varies based on the inputs of the function that produced it. (You can get faster than fmt.Errorf if it matters, but this comment is already getting large.)<p>A problem with using fmt.Errorf in this way is that you can&#x27;t test the error against a sentinel any more. This was addressed a while back in Go 1.13 with the addition of error wrapping. You can return an error that <i>wraps</i> the sentinel (note the %w format verb):<p><pre><code>  return fmt.Errorf(&quot;%q: %w&quot;, name, ErrNotFound) &#x2F;&#x2F; &quot;foo&quot;: not found
</code></pre>
And you can then use the errors.Is function to ask whether an error is equal to ErrNotFound, or if it wraps ErrNotFound:<p><pre><code>  if errors.Is(err, ErrNotFound) { ... }
</code></pre>
On my laptop, producing a wrapping error like this and testing it with &quot;err != nil&quot; is about 91ns, and testing it with &quot;errors.Is(err, ErrNotFound)&quot; is about 98ns. So using Is is adding 7ns of overhead, which is not nothing, but is also pretty much lost in the noise compared to creating the error in the first place.<p>The example in this blog post went a step further, though, and created an error with not just a single layer of wrapping but one with four. The error text in the wrapped error cases is:<p><pre><code>  GetValue couldn&#x27;t get a value: queryValueStore couldn&#x27;t get a value: queryDisk couldn&#x27;t get a value: not found
</code></pre>
(That is, by the way, a very difficult error to read. Don&#x27;t hand users errors that look like that.)<p>Creating a stack of four wrapped errors like this on my laptop is 396ns, and inspecting it with errors.Is is another 21ns. 21ns is waaaaay more than the 0.5ns for a simple &quot;err != nil&quot; check, but again the runtime here is massively dominated by the expense of creating the error--which in this case involves repeatedly creating formatted strings and throwing them away, and two allocations for each layer in the stack.<p>In general, when doing low level optimization of Go code, avoiding allocations is the biggest bang for your buck. If microseconds matter, you absolutely should pay attention to the cost of constructing error values. But the cost of <i>inspecting</i> those values doesn&#x27;t usually become an issue unless nanoseconds count, and will generally be dominated by the cost of construction.<p>Also, even the slowest cases here are running about 0.5-1.5μs, which absolutely matters in some cases, but is irrelevant in many others.</div><br/><div id="40543814" class="c"><input type="checkbox" id="c-40543814" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#40542509">parent</a><span>|</span><a href="#40543045">next</a><span>|</span><label class="collapse" for="c-40543814">[-]</label><label class="expand" for="c-40543814">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In general, when doing low level optimization of Go code, avoiding allocations is the biggest bang for your buck.<p>I have found this to be the truth. I&#x27;m making a game in Go, and have learned that a smooth framerate depends on programming with allocation awareness. Always know where and when your memory is coming from.</div><br/></div></div><div id="40543045" class="c"><input type="checkbox" id="c-40543045" checked=""/><div class="controls bullet"><span class="by">zachmu</span><span>|</span><a href="#40542509">parent</a><span>|</span><a href="#40543814">prev</a><span>|</span><label class="collapse" for="c-40543045">[-]</label><label class="expand" for="c-40543045">[1 more]</label></div><br/><div class="children"><div class="content">This is true.<p>We have in the past eliminated sentinel errors and gotten measurable gains from doing so, but this is mostly because our errors were both common (occurring several times on every request) and expensive to construct. The direct cost of errors.Is() was minor compared to the cost of building the error itself.<p>And you might be surprised how common it is for people to insist on wrapping an error at every layer of the stack. I&#x27;ve gotten in arguments with these people online, they&#x27;re out there.</div><br/></div></div></div></div></div></div></div></div></div></body></html>