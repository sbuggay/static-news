<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713776468192" as="style"/><link rel="stylesheet" href="styles.css?v=1713776468192"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://without.boats/blog/coroutines-and-effects/">Coroutines and effects</a> <span class="domain">(<a href="https://without.boats">without.boats</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>52 comments</span></div><br/><div><div id="40112461" class="c"><input type="checkbox" id="c-40112461" checked=""/><div class="controls bullet"><span class="by">orthoxerox</span><span>|</span><a href="#40108819">next</a><span>|</span><label class="collapse" for="c-40112461">[-]</label><label class="expand" for="c-40112461">[1 more]</label></div><br/><div class="children"><div class="content">&gt; as far as I understand it is not possible to meaningfully handle the diverging effect<p>I don&#x27;t know if that counts, but I think `call_with_timeout(duration, function_that_diverges, timeout_return_value, args...)` handles the diverging effect of its function argument.</div><br/></div></div><div id="40108819" class="c"><input type="checkbox" id="c-40108819" checked=""/><div class="controls bullet"><span class="by">et1337</span><span>|</span><a href="#40112461">prev</a><span>|</span><a href="#40100516">next</a><span>|</span><label class="collapse" for="c-40108819">[-]</label><label class="expand" for="c-40108819">[5 more]</label></div><br/><div class="children"><div class="content">Wow I’ve been thinking of something exactly like this! Sort of a super charged, statically typed version of Go’s context.Context. It would allow you to describe the capabilities (or effects) of every function, including IO, memory allocation, cancellation, deadlines, concurrency, and whatever application-specific stuff you need on there (like logging).<p>Then you could implement something like Google capslock [0] just by looking at type signatures.<p>0. <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;capslock">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;capslock</a></div><br/><div id="40111065" class="c"><input type="checkbox" id="c-40111065" checked=""/><div class="controls bullet"><span class="by">valcron1000</span><span>|</span><a href="#40108819">parent</a><span>|</span><a href="#40110300">next</a><span>|</span><label class="collapse" for="c-40111065">[-]</label><label class="expand" for="c-40111065">[1 more]</label></div><br/><div class="children"><div class="content">You already have something like this (production ready) through effect systems in Haskell (ex. <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;effectful" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;effectful</a>)</div><br/></div></div><div id="40110300" class="c"><input type="checkbox" id="c-40110300" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#40108819">parent</a><span>|</span><a href="#40111065">prev</a><span>|</span><a href="#40111442">next</a><span>|</span><label class="collapse" for="c-40110300">[-]</label><label class="expand" for="c-40110300">[1 more]</label></div><br/><div class="children"><div class="content">See also aspect-oriented programming (AoP): <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aspect-oriented_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aspect-oriented_programming</a> Algebraic effects might be a little too strict and narrowly defined for something as generic as, e.g., injecting ad hoc logging. With algebraic effects you need to reify in the type system the specific control flow behaviors you care about, and then get code to use those types and operators accordingly. AoP seems like a higher-level (if looser) concept that isn&#x27;t necessarily specifically bound to the particular details of the type system. That modeling freedom seems necessary unless you&#x27;re creating a language from scratch or confining yourself to a very limited set of control effects that can be shoe-horned into the existing type system and control flow operators.</div><br/></div></div><div id="40111442" class="c"><input type="checkbox" id="c-40111442" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#40108819">parent</a><span>|</span><a href="#40110300">prev</a><span>|</span><a href="#40109976">next</a><span>|</span><label class="collapse" for="c-40111442">[-]</label><label class="expand" for="c-40111442">[1 more]</label></div><br/><div class="children"><div class="content">Like clockwork, every few years, smart people will re-invent introspection.</div><br/></div></div><div id="40109976" class="c"><input type="checkbox" id="c-40109976" checked=""/><div class="controls bullet"><span class="by">ordinaryradical</span><span>|</span><a href="#40108819">parent</a><span>|</span><a href="#40111442">prev</a><span>|</span><a href="#40100516">next</a><span>|</span><label class="collapse" for="c-40109976">[-]</label><label class="expand" for="c-40109976">[1 more]</label></div><br/><div class="children"><div class="content">Do itttttt :)</div><br/></div></div></div></div><div id="40100516" class="c"><input type="checkbox" id="c-40100516" checked=""/><div class="controls bullet"><span class="by">nsm</span><span>|</span><a href="#40108819">prev</a><span>|</span><a href="#40108956">next</a><span>|</span><label class="collapse" for="c-40100516">[-]</label><label class="expand" for="c-40100516">[1 more]</label></div><br/><div class="children"><div class="content">I am not an expert on this either, although very interested. Note that delimited continuations, which are a superset of coroutines are identical to effects in the sense of yielding control to the handler, not the caller. In languages like Racket&#x2F;Scheme which allows associating tags with handlers, you can also model the same function having multiple effects.<p>In general, coroutines seem vastly easier to understand&#x2F;type compared to effects unless your language can do a lot of effect inference.</div><br/></div></div><div id="40108956" class="c"><input type="checkbox" id="c-40108956" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#40100516">prev</a><span>|</span><a href="#40110763">next</a><span>|</span><label class="collapse" for="c-40108956">[-]</label><label class="expand" for="c-40108956">[20 more]</label></div><br/><div class="children"><div class="content">This touches on something I’d like to see in more mainstream languages, but it doesn’t quite get there.<p>&gt; For example, Koka has a “diverging” effect, which means that an expression may diverge (that is to say, it may not finish evaluating). An expression containing a diverging expression is also diverging. So you can distinguish in the type system between a function that is guaranteed to finish and a function that may not finish (this is imperfect, of course, because of the undecidability of the halting problem; some functions that do not diverge will be marked diverging).<p>As I think about it (and I’m not a programming language theorist, nor have I done much serious work in any language with any sort of effect system), there are two vague categories of effect: control-flow effects like exceptions, yields, async waits (Pending, sleep, or however you feel like modeling it) and non-control-flow effects (divergence, various forms of unsafety, nondeterminism, impurity, reads or writes of global state, syscalls in models that don’t treat IO in and of itself as an effect), etc.<p>I would like to be able to run and write code that is <i>definitely</i> free of certain kinds of effects. Xz should not be unsafe or do IO, for example. Leftpad is an entirely pure, non-diverging function. And I should be able to ask my language to enforce that, ideally with trivial code. Maybe even by default.<p>But mainstream languages seem to mostly limit their use of effect-like systems on the control flow part, like this:<p>&gt; Overall, coroutines strike me as the most promising way to handle many kinds of effectful functions because they seem to be in the design sweet spot: They are statically typed, lexically scoped, and unlayered.</div><br/><div id="40111820" class="c"><input type="checkbox" id="c-40111820" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40108956">parent</a><span>|</span><a href="#40109032">next</a><span>|</span><label class="collapse" for="c-40111820">[-]</label><label class="expand" for="c-40111820">[1 more]</label></div><br/><div class="children"><div class="content">D has a lot of these kinds of &quot;effects&quot;, though they&#x27;re called &quot;attributes&quot; [1] like &quot;nothrow&quot;, &quot;pure&quot;, &quot;safe&quot;, &quot;mustuse&quot;, &quot;nogc&quot;... there&#x27;s also the &quot;noreturn&quot; type for functions that will never return [2] (infinite loop or throws).<p>[1] <a href="https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;attribute.html#return" rel="nofollow">https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;attribute.html#return</a><p>[2] <a href="https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;type.html#noreturn" rel="nofollow">https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;type.html#noreturn</a></div><br/></div></div><div id="40109032" class="c"><input type="checkbox" id="c-40109032" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#40108956">parent</a><span>|</span><a href="#40111820">prev</a><span>|</span><a href="#40109096">next</a><span>|</span><label class="collapse" for="c-40109032">[-]</label><label class="expand" for="c-40109032">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the motivations of algebraic effects: you can have fine grained control over which effects are allowed.</div><br/></div></div><div id="40109096" class="c"><input type="checkbox" id="c-40109096" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#40108956">parent</a><span>|</span><a href="#40109032">prev</a><span>|</span><a href="#40109445">next</a><span>|</span><label class="collapse" for="c-40109096">[-]</label><label class="expand" for="c-40109096">[1 more]</label></div><br/><div class="children"><div class="content">There are two aspects to effects as a language feature- first there is the runtime behavior, and then there is the type system. Ruling out categories of effects is the job of the type system, and you don&#x27;t have to commit to (or avoid) any particular runtime approach to use it that way.<p>This is related to the vagueness of your two categories. While exceptions, yields, and awaits don&#x27;t really make sense without a handler, all that matters to the type system is which operations an expression might perform <i>in addition to</i> producing a result of their primary type. Handlers only interact with the type system in the sense that they remove an effect from their handle-ee expression.<p>So even in a language that committed to coroutines as its approach handling effects at runtime, the type system could still track and rule out effects like divergence or system calls. (For what it&#x27;s worth, nondeterminism, state, etc. can all also be defined in terms of handlers. And at the same time, though, unsafety is not an effect because it is not entirely captured by &quot;can this expression perform operation X.&quot;)</div><br/></div></div><div id="40109445" class="c"><input type="checkbox" id="c-40109445" checked=""/><div class="controls bullet"><span class="by">newpavlov</span><span>|</span><a href="#40108956">parent</a><span>|</span><a href="#40109096">prev</a><span>|</span><a href="#40110041">next</a><span>|</span><label class="collapse" for="c-40109445">[-]</label><label class="expand" for="c-40109445">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, the whole blog post reads like &quot;if you worked too much with a hammer, everything starts looking like a nail&quot;. In other words, it puts the cart before the horse.<p>Effects is a MUCH more general and powerful technique than coroutines. An effect system can help greatly with implementing a coroutine system (instead of dealing with the unfortunate type-level hack Rust uses), but trying to implement an effect system on top of a coroutine system will give you a very limited emulation in the best case and another incoherent mess in the worst.<p>It would&#x27;ve been really great if Rust had a proper effect system, but it&#x27;s very hard to introduce it into an existing language similarly to how you can not easily introduce borrow checker to C&#x2F;C++. The messy &quot;keyword generics&quot; proposals only serve as a good demonstration for this. So we probably have to wait for Rust 2 or a different successor language.</div><br/></div></div><div id="40110041" class="c"><input type="checkbox" id="c-40110041" checked=""/><div class="controls bullet"><span class="by">vendiddy</span><span>|</span><a href="#40108956">parent</a><span>|</span><a href="#40109445">prev</a><span>|</span><a href="#40110008">next</a><span>|</span><label class="collapse" for="c-40110041">[-]</label><label class="expand" for="c-40110041">[3 more]</label></div><br/><div class="children"><div class="content">I would love something like this where to write a function with side effects I&#x27;d have to annotate it as such.<p>Then the compiler could recursively understand whether any given function is pure.</div><br/><div id="40111873" class="c"><input type="checkbox" id="c-40111873" checked=""/><div class="controls bullet"><span class="by">cryptoxchange</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40110041">parent</a><span>|</span><a href="#40111900">next</a><span>|</span><label class="collapse" for="c-40111873">[-]</label><label class="expand" for="c-40111873">[1 more]</label></div><br/><div class="children"><div class="content">The solidity language for smart contracts works like this.</div><br/></div></div><div id="40111900" class="c"><input type="checkbox" id="c-40111900" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40110041">parent</a><span>|</span><a href="#40111873">prev</a><span>|</span><a href="#40110008">next</a><span>|</span><label class="collapse" for="c-40111900">[-]</label><label class="expand" for="c-40111900">[1 more]</label></div><br/><div class="children"><div class="content">I write code like this every day in Haskell.</div><br/></div></div></div></div><div id="40110008" class="c"><input type="checkbox" id="c-40110008" checked=""/><div class="controls bullet"><span class="by">kuchenbecker</span><span>|</span><a href="#40108956">parent</a><span>|</span><a href="#40110041">prev</a><span>|</span><a href="#40109885">next</a><span>|</span><label class="collapse" for="c-40110008">[-]</label><label class="expand" for="c-40110008">[1 more]</label></div><br/><div class="children"><div class="content">Hack programming language (Facebook&#x27;s php++). They are called coeffects and can range from &quot;this is pure with no side effect&quot; to &quot;this can modify local members&quot; to &quot;this has I&#x2F;O&quot;.</div><br/></div></div><div id="40109885" class="c"><input type="checkbox" id="c-40109885" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#40108956">parent</a><span>|</span><a href="#40110008">prev</a><span>|</span><a href="#40110067">next</a><span>|</span><label class="collapse" for="c-40109885">[-]</label><label class="expand" for="c-40109885">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Leftpad is an entirely pure, non-diverging function.<p>`leftpad(string, int) -&gt; string` needs to allocate so not fully pure that way. You could pass in the resulting string but then it would have to mutate, which is not really pure either.</div><br/><div id="40110621" class="c"><input type="checkbox" id="c-40110621" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40109885">parent</a><span>|</span><a href="#40109932">next</a><span>|</span><label class="collapse" for="c-40110621">[-]</label><label class="expand" for="c-40110621">[1 more]</label></div><br/><div class="children"><div class="content">It’s certainly pure in the Haskell sense: the inputs are two immutable values, and the output is another immutable value.  It’s even pure in some Rusty senses: it could take String or &amp;str as input and returns a String — in a model where String is a value, it’s pure.<p>A lot of modern programming logically involves telling a computer to what to compute and not particularly caring <i>how</i> it gets computed. Yet we mostly lack a language in which one can specify computations and then then run the result portably and safely.</div><br/></div></div><div id="40109932" class="c"><input type="checkbox" id="c-40109932" checked=""/><div class="controls bullet"><span class="by">atlintots</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40109885">parent</a><span>|</span><a href="#40110621">prev</a><span>|</span><a href="#40110067">next</a><span>|</span><label class="collapse" for="c-40109932">[-]</label><label class="expand" for="c-40109932">[6 more]</label></div><br/><div class="children"><div class="content">It would be pure in languages without manual memory management</div><br/><div id="40109955" class="c"><input type="checkbox" id="c-40109955" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40109932">parent</a><span>|</span><a href="#40110067">next</a><span>|</span><label class="collapse" for="c-40109955">[-]</label><label class="expand" for="c-40109955">[5 more]</label></div><br/><div class="children"><div class="content">Unless it can&#x27;t allocate, and then the whole program terminates. There are unfortunately limitations everywhere.</div><br/><div id="40110051" class="c"><input type="checkbox" id="c-40110051" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40109955">parent</a><span>|</span><a href="#40112291">next</a><span>|</span><label class="collapse" for="c-40110051">[-]</label><label class="expand" for="c-40110051">[1 more]</label></div><br/><div class="children"><div class="content">Of course as well as limiting the total amount of memory a running program is allowed to allocate, we can also limit how many CPU instructions it can execute and numerous other (OS dependent) resource uses. Accounting for this all operations are fallible, which no practical language copes with.<p>It&#x27;s very normal in a Unix to be allowed to limit total runtime for example.</div><br/></div></div><div id="40112291" class="c"><input type="checkbox" id="c-40112291" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40109955">parent</a><span>|</span><a href="#40110051">prev</a><span>|</span><a href="#40109993">next</a><span>|</span><label class="collapse" for="c-40112291">[-]</label><label class="expand" for="c-40112291">[1 more]</label></div><br/><div class="children"><div class="content">If the whole program terminates, the purity of the function is still intact, the computer just can&#x27;t compute it :D</div><br/></div></div><div id="40109993" class="c"><input type="checkbox" id="c-40109993" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40109955">parent</a><span>|</span><a href="#40112291">prev</a><span>|</span><a href="#40110067">next</a><span>|</span><label class="collapse" for="c-40109993">[-]</label><label class="expand" for="c-40109993">[2 more]</label></div><br/><div class="children"><div class="content">Is it really worth worrying about?  This strikes me as pedantic.  Once a program can no longer allocate memory, it&#x27;s very likely toast anyway.<p>Edit: @naasking, all good points.  Still, isn&#x27;t the general strategy to ensure memory isn&#x27;t exhausted, rather than handling such a situation &quot;gracefully&quot;, whatever that means? :)</div><br/><div id="40110035" class="c"><input type="checkbox" id="c-40110035" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40109993">parent</a><span>|</span><a href="#40110067">next</a><span>|</span><label class="collapse" for="c-40110035">[-]</label><label class="expand" for="c-40110035">[1 more]</label></div><br/><div class="children"><div class="content">It depends what your program is for. Some programs need guarantees because of bounded resources, so you may want resource allocation to be a visible effect (like embedded systems), or because you&#x27;re running potentially untrusted code (like JS or WASM in a browser), or because you want sane failure handling (like running modules in a web server).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40110067" class="c"><input type="checkbox" id="c-40110067" checked=""/><div class="controls bullet"><span class="by">dustingetz</span><span>|</span><a href="#40108956">parent</a><span>|</span><a href="#40109885">prev</a><span>|</span><a href="#40110763">next</a><span>|</span><label class="collapse" for="c-40110067">[-]</label><label class="expand" for="c-40110067">[3 more]</label></div><br/><div class="children"><div class="content">don’t forget unbounded loops diverge - while(true){} and fn f() {f()} - also impure are blocking “pure” computations like fib(50)</div><br/><div id="40111380" class="c"><input type="checkbox" id="c-40111380" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40110067">parent</a><span>|</span><a href="#40110763">next</a><span>|</span><label class="collapse" for="c-40111380">[-]</label><label class="expand" for="c-40111380">[2 more]</label></div><br/><div class="children"><div class="content">In proof languages where you want a proof that a function will succeed <i>without running it,</i> knowing that it doesn&#x27;t diverge is important.<p>But if you&#x27;re going to do the calculation, there&#x27;s no difference between an infinite loop and a loop that finishes, but will take longer than you&#x27;re willing to wait. Either way, it looks like the program hung.<p>So in practical programming languages, I&#x27;m not sure that the &quot;diverge&quot; effect is useful? You still need to kill it if it hangs. If it will take a long time, returning some kind of progress indicator would be nice. Maybe writing it as an iterator would help with that?</div><br/><div id="40111811" class="c"><input type="checkbox" id="c-40111811" checked=""/><div class="controls bullet"><span class="by">codebje</span><span>|</span><a href="#40108956">root</a><span>|</span><a href="#40111380">parent</a><span>|</span><a href="#40110763">next</a><span>|</span><label class="collapse" for="c-40111811">[-]</label><label class="expand" for="c-40111811">[1 more]</label></div><br/><div class="children"><div class="content">It may depend on what you mean by &#x27;practical&#x27;, perhaps, but in a Haskell-like language divergence (as opposed to induction) more or less takes the form &quot;let x = x in x&quot; with varying degrees of ceremony. If you can provide to the compiler that you don&#x27;t have any such thing in your fragment of code it can omit black-hole updates and checks during garbage collection for a small (possibly negligible or nil, if divergence still exists in the language anyway) performance boost.<p>As you suggest, explicitly adding a provably-reducing value like a maximum iteration limit lets you show progress, give up at a &quot;reasonable&quot; time, and avoid divergence. This is how unlifted programming languages permit general recursion - that, and allowing inductive types to merely prove they&#x27;re productive within a finite time bound (eg, a stream of values only needs to show it produces the next value eventually, not that it produces all values eventually).</div><br/></div></div></div></div></div></div></div></div><div id="40110763" class="c"><input type="checkbox" id="c-40110763" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#40108956">prev</a><span>|</span><a href="#40110215">next</a><span>|</span><label class="collapse" for="c-40110763">[-]</label><label class="expand" for="c-40110763">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The key difference between coroutines and effect handlers is that coroutines yield control to their caller, but effectful expressions yield control to their handler. The difference of affordance this implies is the materially significant advantage of coroutines over effect handlers.<p>Should that last bit be: &quot;advantage of effect handlers over coroutines&quot;?<p>EDIT: Oh, maybe I should have read the rest of the article first. It might be going the other way than that one example suggested. :)</div><br/></div></div><div id="40110215" class="c"><input type="checkbox" id="c-40110215" checked=""/><div class="controls bullet"><span class="by">Avi-D-coder</span><span>|</span><a href="#40110763">prev</a><span>|</span><a href="#40110815">next</a><span>|</span><label class="collapse" for="c-40110215">[-]</label><label class="expand" for="c-40110215">[2 more]</label></div><br/><div class="children"><div class="content">&gt; understand when the effect occurs requires examining the type signature of every function that is called. Since this is meaningful control flow, it seems very valuable to be able to identify points at which an error occurs without examining the signatures of each function call.<p>This is currently the case in rust. IO and other effects are frequently implicit. You don’t have to use ? or await they are *sugar. I have frequently seen reinventions of exceptions, unwind nonsense, adhoc interpreted tagged effects, etc..<p>Explicit  syntax for effectfull calls should not be a goal. We don’t actually have that today.</div><br/><div id="40110429" class="c"><input type="checkbox" id="c-40110429" checked=""/><div class="controls bullet"><span class="by">skavi</span><span>|</span><a href="#40110215">parent</a><span>|</span><a href="#40110815">next</a><span>|</span><label class="collapse" for="c-40110429">[-]</label><label class="expand" for="c-40110429">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s incredibly useful today to have both of these annotations.<p>I frequently scan for all instances of `?` or `.await` in functions (though, unfortunately, for various reasons this won’t show you everywhere these effects are produced).<p>I would rather not have to rely on an IDE to get that functionality.</div><br/></div></div></div></div><div id="40110815" class="c"><input type="checkbox" id="c-40110815" checked=""/><div class="controls bullet"><span class="by">kodablah</span><span>|</span><a href="#40110215">prev</a><span>|</span><a href="#40108695">next</a><span>|</span><label class="collapse" for="c-40110815">[-]</label><label class="expand" for="c-40110815">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Overall, coroutines strike me as the most promising way to handle many kinds of effectful functions<p>This is basically what we do at Temporal, which is essentially deterministic coroutines with externalized effects. This gives another nice property: using coroutines to wrap effects lets the non-effect logic replay&#x2F;resume durably.</div><br/></div></div><div id="40108695" class="c"><input type="checkbox" id="c-40108695" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40110815">prev</a><span>|</span><a href="#40108548">next</a><span>|</span><label class="collapse" for="c-40108695">[-]</label><label class="expand" for="c-40108695">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not really understanding the comparison (or isomorphism) between coroutines and effects.  Feels like comparing Lists with functions, or promises with interfaces.</div><br/><div id="40109013" class="c"><input type="checkbox" id="c-40109013" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#40108695">parent</a><span>|</span><a href="#40108983">next</a><span>|</span><label class="collapse" for="c-40109013">[-]</label><label class="expand" for="c-40109013">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know your background, so I don&#x27;t know at what level to pitch an explanation. Here&#x27;s an attempt that assumes some knowledge of modern PLs.<p>Effects require 1) well-defined control flow (think of IO; you need to know in what order output occurs) and 2) manipulation of control flow (think of error handling or concurrency).<p>We can model effects as a back-and-forth between effect handlers, which carry out effects, and the user program. The user program passes control to the effect handler to carry out some effect, and the effect handler passes control back to the user program (potentially a different part of the user program; think error handling) when the effect has been performed. Continuations give complete control over control flow, so in their full generality effects require continuations (or some equivalent like monads). Coroutines are a slightly stilted form of continuations, that you can model much, but not all, control flow with.</div><br/><div id="40109363" class="c"><input type="checkbox" id="c-40109363" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40108695">root</a><span>|</span><a href="#40109013">parent</a><span>|</span><a href="#40108983">next</a><span>|</span><label class="collapse" for="c-40109363">[-]</label><label class="expand" for="c-40109363">[6 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t coroutines generally one-shot, whereas continuations could potentially be resumed to multiple times? This seems to be a relevant difference between these concepts.</div><br/><div id="40111707" class="c"><input type="checkbox" id="c-40111707" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#40108695">root</a><span>|</span><a href="#40109363">parent</a><span>|</span><a href="#40109509">next</a><span>|</span><label class="collapse" for="c-40111707">[-]</label><label class="expand" for="c-40111707">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s my understanding, and why you need full continuations to handle all effects. In my mental model a coroutine gives you an execution point that you can resume, but you are not allowed to resume execution points you have previously resumed. You cannot, for example, implement backtracking search with just coroutines as you need to to return to previous execution points. (Look, you can implement anything with anything. Turing completeness etc. This is about implementing it in a natural way using the effect handlers.)</div><br/></div></div><div id="40109509" class="c"><input type="checkbox" id="c-40109509" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#40108695">root</a><span>|</span><a href="#40109363">parent</a><span>|</span><a href="#40111707">prev</a><span>|</span><a href="#40108983">next</a><span>|</span><label class="collapse" for="c-40109509">[-]</label><label class="expand" for="c-40109509">[4 more]</label></div><br/><div class="children"><div class="content">No, the whole point of coroutines is that you can resume them multiple times, otherwise it&#x27;s just a simple function call.</div><br/><div id="40109858" class="c"><input type="checkbox" id="c-40109858" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#40108695">root</a><span>|</span><a href="#40109509">parent</a><span>|</span><a href="#40108983">next</a><span>|</span><label class="collapse" for="c-40109858">[-]</label><label class="expand" for="c-40109858">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what &quot;resume multiple times&quot; is referring to here. You can typically only resume a coroutine once <i>per yield,</i> while a continuation generally allows you to return to the <i>same place</i> multiple times.</div><br/><div id="40111145" class="c"><input type="checkbox" id="c-40111145" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#40108695">root</a><span>|</span><a href="#40109858">parent</a><span>|</span><a href="#40109965">next</a><span>|</span><label class="collapse" for="c-40111145">[-]</label><label class="expand" for="c-40111145">[1 more]</label></div><br/><div class="children"><div class="content">One lets you save and return to an execution state (program counter and local environment), the other lets you create and call an execution state that is saved between calls to it.<p>There are obvious implementation differences but I&#x27;m not sure it makes any difference here, in both cases you can return to the same execution state multiple times.</div><br/></div></div><div id="40109965" class="c"><input type="checkbox" id="c-40109965" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#40108695">root</a><span>|</span><a href="#40109858">parent</a><span>|</span><a href="#40111145">prev</a><span>|</span><a href="#40108983">next</a><span>|</span><label class="collapse" for="c-40109965">[-]</label><label class="expand" for="c-40109965">[1 more]</label></div><br/><div class="children"><div class="content">Roughly, coroutine = a type of continuation with all mutable state, and continuation = a type of immutable coroutine.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40108983" class="c"><input type="checkbox" id="c-40108983" checked=""/><div class="controls bullet"><span class="by">alephaleph</span><span>|</span><a href="#40108695">parent</a><span>|</span><a href="#40109013">prev</a><span>|</span><a href="#40108548">next</a><span>|</span><label class="collapse" for="c-40108983">[-]</label><label class="expand" for="c-40108983">[3 more]</label></div><br/><div class="children"><div class="content">A coroutine is a computation that can `yield`, suspending itself and passing control back up to the caller. It can then be resumed at the caller&#x27;s leisure.<p>An function with an effect (in this sense) is a function which can ask a handler to `perform` some effect for it. This suspends the function and passes control to whichever handler is in scope for that call, allowing that handler to resume the function at its leisure.<p>I suspect that you&#x27;re misunderstanding what is meant by effect, because despite buzz about them and backend support for them in OCaml 5, they aren&#x27;t yet implemented with syntax and type-level support in any mainstream languages I&#x27;m aware of.</div><br/><div id="40111465" class="c"><input type="checkbox" id="c-40111465" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#40108695">root</a><span>|</span><a href="#40108983">parent</a><span>|</span><a href="#40108548">next</a><span>|</span><label class="collapse" for="c-40111465">[-]</label><label class="expand" for="c-40111465">[2 more]</label></div><br/><div class="children"><div class="content">&gt; An function with an effect (in this sense) is a function which can ask a handler to `perform` some effect for it.<p>Why does it need to ask a &quot;handler&quot; to do something, why can&#x27;t it just call a  function that does the &quot;action&quot; for it?</div><br/><div id="40111797" class="c"><input type="checkbox" id="c-40111797" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40108695">root</a><span>|</span><a href="#40111465">parent</a><span>|</span><a href="#40108548">next</a><span>|</span><label class="collapse" for="c-40111797">[-]</label><label class="expand" for="c-40111797">[1 more]</label></div><br/><div class="children"><div class="content">By making effects explicit, you reap the benefit of being able to write non-effectful code.<p>Depending on what your language tracked as an effect, you could make your business-logic always terminate, or perform no allocations, if you had effects for Mutation&#x2F;GeneralRecursion&#x2F;Allocation.<p>But no, I certainly don&#x27;t understand the function-&gt;handler control flow here.  It has to be handler-&gt;function, otherwise you&#x27;ve got two handlers!</div><br/></div></div></div></div></div></div></div></div><div id="40108548" class="c"><input type="checkbox" id="c-40108548" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#40108695">prev</a><span>|</span><a href="#40108478">next</a><span>|</span><label class="collapse" for="c-40108548">[-]</label><label class="expand" for="c-40108548">[2 more]</label></div><br/><div class="children"><div class="content">What’s the difference between an effect and a “coroutine” where calls in the function body to other coroutines are implicitly yielded? Or is that not a real coroutine?<p>That’s what Kotlin’s `suspend fun` does.</div><br/><div id="40108636" class="c"><input type="checkbox" id="c-40108636" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#40108548">parent</a><span>|</span><a href="#40108478">next</a><span>|</span><label class="collapse" for="c-40108636">[-]</label><label class="expand" for="c-40108636">[1 more]</label></div><br/><div class="children"><div class="content">Both effects and coroutines can (and typically do) work implicitly across calls like that. The version with forwarding operators like in this post is something of a Rust-ism, or more generally an async&#x2F;await-ism, or a stackless coroutine-ism.<p>The more fundamental difference between effects and coroutines is that a `yield` in a coroutine always goes to the one unique resumer, and carries a single type of value. On the other hand, an expression may have several effects, each of which may be handled in a different place, in the same way that distinct exception types may be caught in different places.</div><br/></div></div></div></div><div id="40108478" class="c"><input type="checkbox" id="c-40108478" checked=""/><div class="controls bullet"><span class="by">angiosperm</span><span>|</span><a href="#40108548">prev</a><span>|</span><a href="#40108624">next</a><span>|</span><label class="collapse" for="c-40108478">[-]</label><label class="expand" for="c-40108478">[6 more]</label></div><br/><div class="children"><div class="content">After scrutiny this seems to be &quot;Coroutines and Effects&quot; in, particularly, Rust.</div><br/><div id="40109017" class="c"><input type="checkbox" id="c-40109017" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40108478">parent</a><span>|</span><a href="#40108624">next</a><span>|</span><label class="collapse" for="c-40109017">[-]</label><label class="expand" for="c-40109017">[5 more]</label></div><br/><div class="children"><div class="content">Given that withoutboats is a long-time major contributor to Rust, I suspect they titled the blog post with the audience of regular readers of their blog in mind rather than a more general audience like Hacker News</div><br/><div id="40109107" class="c"><input type="checkbox" id="c-40109107" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40108478">root</a><span>|</span><a href="#40109017">parent</a><span>|</span><a href="#40108624">next</a><span>|</span><label class="collapse" for="c-40109107">[-]</label><label class="expand" for="c-40109107">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more than that: <a href="https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;without.boats&#x2F;post&#x2F;3kql3yr3goc23" rel="nofollow">https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;without.boats&#x2F;post&#x2F;3kql3yr3goc23</a><p>&gt; Btw this is the beginning of me trying to shift away from blogging about rust to blogging about PL design in general. I find that I have very little to say about Rust that I haven’t already said.</div><br/><div id="40110003" class="c"><input type="checkbox" id="c-40110003" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40108478">root</a><span>|</span><a href="#40109107">parent</a><span>|</span><a href="#40110807">next</a><span>|</span><label class="collapse" for="c-40110003">[-]</label><label class="expand" for="c-40110003">[2 more]</label></div><br/><div class="children"><div class="content">Right, this is a post which kinda assumes you <i>know</i> Rust, but AFAICT it isn&#x27;t a post specifically <i>about</i> Rust.<p>In 2014 that would be extremely presumptuous or targeted at a very niche audience, however in 2024 a <i>lot</i> of people know Rust and so it seems much more reasonable.</div><br/><div id="40112176" class="c"><input type="checkbox" id="c-40112176" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40108478">root</a><span>|</span><a href="#40110003">parent</a><span>|</span><a href="#40110807">next</a><span>|</span><label class="collapse" for="c-40112176">[-]</label><label class="expand" for="c-40112176">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Rust is the language that the smart kids are using to think about higher-order programming concepts. It has begun to supplant Lisp and Haskell in that regard.</div><br/></div></div></div></div><div id="40110807" class="c"><input type="checkbox" id="c-40110807" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40108478">root</a><span>|</span><a href="#40109107">parent</a><span>|</span><a href="#40110003">prev</a><span>|</span><a href="#40108624">next</a><span>|</span><label class="collapse" for="c-40110807">[-]</label><label class="expand" for="c-40110807">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, I hadn&#x27;t seen that context!</div><br/></div></div></div></div></div></div></div></div><div id="40108624" class="c"><input type="checkbox" id="c-40108624" checked=""/><div class="controls bullet"><span class="by">rc_mob</span><span>|</span><a href="#40108478">prev</a><span>|</span><label class="collapse" for="c-40108624">[-]</label><label class="expand" for="c-40108624">[1 more]</label></div><br/><div class="children"><div class="content">I just upvoted this because I love the domain name.</div><br/></div></div></div></div></div></div></div></body></html>