<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732611672515" as="style"/><link rel="stylesheet" href="styles.css?v=1732611672515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.optics.dev/Monocle/">Monocle: Optics Library for Scala</a> <span class="domain">(<a href="https://www.optics.dev">www.optics.dev</a>)</span></div><div class="subtext"><span>curling_grad</span> | <span>39 comments</span></div><br/><div><div id="42239838" class="c"><input type="checkbox" id="c-42239838" checked=""/><div class="controls bullet"><span class="by">openplatypus</span><span>|</span><a href="#42239815">next</a><span>|</span><label class="collapse" for="c-42239838">[-]</label><label class="expand" for="c-42239838">[1 more]</label></div><br/><div class="children"><div class="content">Yes, using Monocle for years now. So happy to have rich ecosystem of libraries in Scala land.</div><br/></div></div><div id="42239815" class="c"><input type="checkbox" id="c-42239815" checked=""/><div class="controls bullet"><span class="by">solid_fuel</span><span>|</span><a href="#42239838">prev</a><span>|</span><a href="#42241286">next</a><span>|</span><label class="collapse" for="c-42239815">[-]</label><label class="expand" for="c-42239815">[10 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t encountered this pattern before.  Is there some more information on what problems this is designed to solve?</div><br/><div id="42243273" class="c"><input type="checkbox" id="c-42243273" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#42239815">parent</a><span>|</span><a href="#42240640">next</a><span>|</span><label class="collapse" for="c-42243273">[-]</label><label class="expand" for="c-42243273">[1 more]</label></div><br/><div class="children"><div class="content">Aside from making it convenient to build getters and setters for nested data, optics also have conditional accessors and collection accessors as building blocks.<p>Conditional accessors have since become a popular language feature with e.g. the elvis operator ?. in C#. Optics make it possible to innovate on features like that in library code rather than as language features.<p>Something I&#x27;ve yet to see made into a language feature that is common in optics libraries are iterating accessors. E.g. to reset all counters we can, with optics, say something like (in Haskell syntax, since that is what I know)<p><pre><code>    stats.each.count .= 0
</code></pre>
and that sets the count to zero for all objects in the stats array. If not all stats objects have a count (some might be of a gauge type, for example) we can compose in a conditional accessor that resolves the count field only if it is not null:<p><pre><code>    stats.each.count._Just .= 0
</code></pre>
In the above statement, nothing is language syntax --it&#x27;s all library functions and operators. But it still combines really well on the page. Once one knows optics, one rarely has to think very hard about how to do any get or update operation, even when the data types become complicated.</div><br/></div></div><div id="42240640" class="c"><input type="checkbox" id="c-42240640" checked=""/><div class="controls bullet"><span class="by">dkarl</span><span>|</span><a href="#42239815">parent</a><span>|</span><a href="#42243273">prev</a><span>|</span><a href="#42239928">next</a><span>|</span><label class="collapse" for="c-42240640">[-]</label><label class="expand" for="c-42240640">[5 more]</label></div><br/><div class="children"><div class="content">The problem most programmers would be familiar with is making an update inside a deeply nested immutable data structure. For example, suppose you want to update a user&#x27;s billing address, and you have an immutable data structure that looks like this:<p><pre><code>    user { billingInfo: { card, address }, name, subscription { level, expiration }, status { level, since } }
</code></pre>
The structure is immutable, so you can&#x27;t make the update in place. On the other hand, you&#x27;re only changing one field, so it would be wasteful to make a complete deep copy. The efficient way to create an updated instance is to create a new user instance and a new billingInfo instance while reusing the name, subscription, and status instances.<p>You can think of this as the equivalent of a <i>setter</i> for immutable data structures.<p>This is an artificial example, because the cost of making a deep copy of this user structure is probably not that bad, and the boilerplate to make an efficient update is not all that bad, either. You would use an optics library when 1) you need efficient updates and 2) it&#x27;s worth investing a little effort to hide the boilerplate.<p>Optics also let you concisely express access into a deeply nested structure, the <i>getter</i> paired with the <i>setter</i>. In my experience, updates are the motivation for setting up optics, and concise access is a nice thing you get as a bonus.</div><br/><div id="42241441" class="c"><input type="checkbox" id="c-42241441" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#42239815">root</a><span>|</span><a href="#42240640">parent</a><span>|</span><a href="#42239928">next</a><span>|</span><label class="collapse" for="c-42241441">[-]</label><label class="expand" for="c-42241441">[4 more]</label></div><br/><div class="children"><div class="content">Does it offer creating a mutable view on top of the immutable structure that can be used to accumulate a whole set of changes to later be materialized into a copy with the changes? (or to be used directly, at whatever cost would be required) That&#x27;s something I&#x27;ve been wondering why it&#x27;s not more of an established thing. It would basically be docker, but for in-memory reference graphs instead of filesystems.</div><br/><div id="42241830" class="c"><input type="checkbox" id="c-42241830" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#42239815">root</a><span>|</span><a href="#42241441">parent</a><span>|</span><a href="#42241502">next</a><span>|</span><label class="collapse" for="c-42241830">[-]</label><label class="expand" for="c-42241830">[1 more]</label></div><br/><div class="children"><div class="content">Immer does this for JS&#x2F;TS.<p><a href="https:&#x2F;&#x2F;immerjs.github.io&#x2F;immer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;immerjs.github.io&#x2F;immer&#x2F;</a></div><br/></div></div><div id="42241502" class="c"><input type="checkbox" id="c-42241502" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#42239815">root</a><span>|</span><a href="#42241441">parent</a><span>|</span><a href="#42241830">prev</a><span>|</span><a href="#42241973">next</a><span>|</span><label class="collapse" for="c-42241502">[-]</label><label class="expand" for="c-42241502">[1 more]</label></div><br/><div class="children"><div class="content">You are perhaps looking for software transactional memory.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Software_transactional_memory" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Software_transactional_memory</a></div><br/></div></div><div id="42241973" class="c"><input type="checkbox" id="c-42241973" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42239815">root</a><span>|</span><a href="#42241441">parent</a><span>|</span><a href="#42241502">prev</a><span>|</span><a href="#42239928">next</a><span>|</span><label class="collapse" for="c-42241973">[-]</label><label class="expand" for="c-42241973">[1 more]</label></div><br/><div class="children"><div class="content">You can compose together a bunch of edit operations (an edit command, if you like) and apply them at once at the end, is that what you mean?</div><br/></div></div></div></div></div></div><div id="42239928" class="c"><input type="checkbox" id="c-42239928" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#42239815">parent</a><span>|</span><a href="#42240640">prev</a><span>|</span><a href="#42240319">next</a><span>|</span><label class="collapse" for="c-42239928">[-]</label><label class="expand" for="c-42239928">[1 more]</label></div><br/><div class="children"><div class="content">If monads are programmable semicolons (ways to chain operation), lenses are programmable dots (ways to delegate access to data). Other optics are largely generalizations of that pattern.</div><br/></div></div><div id="42240319" class="c"><input type="checkbox" id="c-42240319" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42239815">parent</a><span>|</span><a href="#42239928">prev</a><span>|</span><a href="#42240550">next</a><span>|</span><label class="collapse" for="c-42240319">[-]</label><label class="expand" for="c-42240319">[1 more]</label></div><br/><div class="children"><div class="content">Lens are the functional version of getters and setters. A lens takes a product type (struct, class, etc) and allows you to view or update part of it. Prisms are something similar for sum types (variants) that allow you to look at a value if it&#x27;s present and err otherwise.<p>The optical analogy comes from how these operations resemble zooming in on structures with a magnifying glass and the entire family of related transformations is called optics.</div><br/></div></div><div id="42240550" class="c"><input type="checkbox" id="c-42240550" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#42239815">parent</a><span>|</span><a href="#42240319">prev</a><span>|</span><a href="#42241286">next</a><span>|</span><label class="collapse" for="c-42240550">[-]</label><label class="expand" for="c-42240550">[1 more]</label></div><br/><div class="children"><div class="content">Lenses make it easier to read and update members deep in a hierarchy of read-only data structures.</div><br/></div></div></div></div><div id="42241286" class="c"><input type="checkbox" id="c-42241286" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#42239815">prev</a><span>|</span><a href="#42239788">next</a><span>|</span><label class="collapse" for="c-42241286">[-]</label><label class="expand" for="c-42241286">[3 more]</label></div><br/><div class="children"><div class="content">Does the LSP provide clear autocomplete on what properties can be accessed on the bound _ ?<p>Asking as someone that doesn&#x27;t use Scala at all, but has seen the hit-and-miss of some FP language LSPs.</div><br/><div id="42242192" class="c"><input type="checkbox" id="c-42242192" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#42241286">parent</a><span>|</span><a href="#42242087">next</a><span>|</span><label class="collapse" for="c-42242192">[-]</label><label class="expand" for="c-42242192">[1 more]</label></div><br/><div class="children"><div class="content">Yes it does, otherwise the code would actually not compile.</div><br/></div></div><div id="42242087" class="c"><input type="checkbox" id="c-42242087" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42241286">parent</a><span>|</span><a href="#42242192">prev</a><span>|</span><a href="#42239788">next</a><span>|</span><label class="collapse" for="c-42242087">[-]</label><label class="expand" for="c-42242087">[1 more]</label></div><br/><div class="children"><div class="content">IntelliJ or the older Scala-IDE for Eclipse certainly does, so I&#x27;d be very disappointed if the LSP impl (which the Scala maintainers have been pushing as the official IDE replacement these days) didn&#x27;t.</div><br/></div></div></div></div><div id="42239788" class="c"><input type="checkbox" id="c-42239788" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#42241286">prev</a><span>|</span><a href="#42240831">next</a><span>|</span><label class="collapse" for="c-42239788">[-]</label><label class="expand" for="c-42239788">[1 more]</label></div><br/><div class="children"><div class="content">Also available for TypeScript:<p><a href="https:&#x2F;&#x2F;gcanti.github.io&#x2F;monocle-ts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gcanti.github.io&#x2F;monocle-ts&#x2F;</a></div><br/></div></div><div id="42240831" class="c"><input type="checkbox" id="c-42240831" checked=""/><div class="controls bullet"><span class="by">itronitron</span><span>|</span><a href="#42239788">prev</a><span>|</span><a href="#42240190">next</a><span>|</span><label class="collapse" for="c-42240831">[-]</label><label class="expand" for="c-42240831">[9 more]</label></div><br/><div class="children"><div class="content">This has nothing to do with optics, which is a branch of physics that studies the behavior and properties of light.</div><br/><div id="42241343" class="c"><input type="checkbox" id="c-42241343" checked=""/><div class="controls bullet"><span class="by">solomonb</span><span>|</span><a href="#42240831">parent</a><span>|</span><a href="#42241631">next</a><span>|</span><label class="collapse" for="c-42241343">[-]</label><label class="expand" for="c-42241343">[1 more]</label></div><br/><div class="children"><div class="content">Words can have many uses.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Optic_(disambiguation)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Optic_(disambiguation)</a><p>&gt; In computer science, optics are a general class of bidirectional transformations</div><br/></div></div><div id="42241631" class="c"><input type="checkbox" id="c-42241631" checked=""/><div class="controls bullet"><span class="by">signaru</span><span>|</span><a href="#42240831">parent</a><span>|</span><a href="#42241343">prev</a><span>|</span><a href="#42242517">next</a><span>|</span><label class="collapse" for="c-42241631">[-]</label><label class="expand" for="c-42241631">[1 more]</label></div><br/><div class="children"><div class="content">The name, monocle, also further misleads those expecting the physics topic. They actually have a nice logo with a lens and the lambda symbol which is often the symbol used for wavelength.</div><br/></div></div><div id="42242517" class="c"><input type="checkbox" id="c-42242517" checked=""/><div class="controls bullet"><span class="by">dkarl</span><span>|</span><a href="#42240831">parent</a><span>|</span><a href="#42241631">prev</a><span>|</span><a href="#42241118">next</a><span>|</span><label class="collapse" for="c-42242517">[-]</label><label class="expand" for="c-42242517">[1 more]</label></div><br/><div class="children"><div class="content">Virtually everything in computer science is a metaphor. A <i>computer</i> was a human being before it was a machine. A <i>block</i> of <i>memory</i>, an <i>array</i> of <i>values</i>, an <i>index</i> into a <i>structure</i>, most of the vocabulary we use every day is built out of metaphors.</div><br/></div></div><div id="42241118" class="c"><input type="checkbox" id="c-42241118" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#42240831">parent</a><span>|</span><a href="#42242517">prev</a><span>|</span><a href="#42241135">next</a><span>|</span><label class="collapse" for="c-42241118">[-]</label><label class="expand" for="c-42241118">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;lens+%28in+computer+science%29" rel="nofollow">https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;lens+%28in+computer+science%29</a></div><br/></div></div><div id="42241135" class="c"><input type="checkbox" id="c-42241135" checked=""/><div class="controls bullet"><span class="by">fn-mote</span><span>|</span><a href="#42240831">parent</a><span>|</span><a href="#42241118">prev</a><span>|</span><a href="#42241728">next</a><span>|</span><label class="collapse" for="c-42241135">[-]</label><label class="expand" for="c-42241135">[1 more]</label></div><br/><div class="children"><div class="content">This is why I read the comments before I click on the link. :)</div><br/></div></div><div id="42241728" class="c"><input type="checkbox" id="c-42241728" checked=""/><div class="controls bullet"><span class="by">evertedsphere</span><span>|</span><a href="#42240831">parent</a><span>|</span><a href="#42241135">prev</a><span>|</span><a href="#42240906">next</a><span>|</span><label class="collapse" for="c-42241728">[-]</label><label class="expand" for="c-42241728">[1 more]</label></div><br/><div class="children"><div class="content">&quot;this has nothing to do with classes, which in sociology and related fields are strata which society can be analysed as being divided into&quot;</div><br/></div></div><div id="42240906" class="c"><input type="checkbox" id="c-42240906" checked=""/><div class="controls bullet"><span class="by">Xophmeister</span><span>|</span><a href="#42240831">parent</a><span>|</span><a href="#42241728">prev</a><span>|</span><a href="#42242492">next</a><span>|</span><label class="collapse" for="c-42240906">[-]</label><label class="expand" for="c-42240906">[1 more]</label></div><br/><div class="children"><div class="content">It’s a metaphor.</div><br/></div></div><div id="42242492" class="c"><input type="checkbox" id="c-42242492" checked=""/><div class="controls bullet"><span class="by">dpratt</span><span>|</span><a href="#42240831">parent</a><span>|</span><a href="#42240906">prev</a><span>|</span><a href="#42240190">next</a><span>|</span><label class="collapse" for="c-42242492">[-]</label><label class="expand" for="c-42242492">[1 more]</label></div><br/><div class="children"><div class="content">Imagine my disappointment when I spent the time to set up a Cassandra instance and it did not immediately materialize a demigod woman who knew the answers to everything but was cursed to have no one believe her.</div><br/></div></div></div></div><div id="42240190" class="c"><input type="checkbox" id="c-42240190" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42240831">prev</a><span>|</span><a href="#42239930">next</a><span>|</span><label class="collapse" for="c-42240190">[-]</label><label class="expand" for="c-42240190">[1 more]</label></div><br/><div class="children"><div class="content">Also in F#: <a href="https:&#x2F;&#x2F;fsprojects.github.io&#x2F;FSharpPlus&#x2F;lens.html" rel="nofollow">https:&#x2F;&#x2F;fsprojects.github.io&#x2F;FSharpPlus&#x2F;lens.html</a></div><br/></div></div><div id="42239930" class="c"><input type="checkbox" id="c-42239930" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#42240190">prev</a><span>|</span><a href="#42240112">next</a><span>|</span><label class="collapse" for="c-42239930">[-]</label><label class="expand" for="c-42239930">[6 more]</label></div><br/><div class="children"><div class="content">Every scala code base I have worked on, that wasnt written by small team of experts, turned into a huge pile of crap. A small squad of people that treat the language like a religion create an impenetrable masterpiece</div><br/><div id="42240712" class="c"><input type="checkbox" id="c-42240712" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42239930">parent</a><span>|</span><a href="#42243428">next</a><span>|</span><label class="collapse" for="c-42240712">[-]</label><label class="expand" for="c-42240712">[1 more]</label></div><br/><div class="children"><div class="content">A lot of work has been done in Scala 3 to simplify everything.<p>And with the arrival of virtual threads in the JVM there are new concurrency libraries e.g. Ox [1] and Gears [2] which remove the need to use FP concepts like monads. Which have been the major source of much of the complexity.<p>For all its problems it is a seriously under-rated platform especially Scala.js which IMHO is far better and simpler than Typescript.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;softwaremill&#x2F;ox">https:&#x2F;&#x2F;github.com&#x2F;softwaremill&#x2F;ox</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;lampepfl&#x2F;gears">https:&#x2F;&#x2F;github.com&#x2F;lampepfl&#x2F;gears</a></div><br/></div></div><div id="42243428" class="c"><input type="checkbox" id="c-42243428" checked=""/><div class="controls bullet"><span class="by">wiml</span><span>|</span><a href="#42239930">parent</a><span>|</span><a href="#42240712">prev</a><span>|</span><a href="#42240456">next</a><span>|</span><label class="collapse" for="c-42243428">[-]</label><label class="expand" for="c-42243428">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re going to have that problem with any codebase written by people who don&#x27;t particularly know the language. Typescript written by PHP programmers, Python written by Java programmers, you&#x27;ll quickly get a huge impenetrable pile of crap.<p>You can optimize your codebase to be modified by an ever rotating group of people who don&#x27;t fully understand it, or by a smaller group of people who do. Both are legitimate choices in specific contexts. But if you take a codebase written one way and try to maintain it the other way, your productivity will tank.</div><br/></div></div><div id="42240456" class="c"><input type="checkbox" id="c-42240456" checked=""/><div class="controls bullet"><span class="by">Sunscratch</span><span>|</span><a href="#42239930">parent</a><span>|</span><a href="#42243428">prev</a><span>|</span><a href="#42240652">next</a><span>|</span><label class="collapse" for="c-42240456">[-]</label><label class="expand" for="c-42240456">[2 more]</label></div><br/><div class="children"><div class="content">Every &lt;insert any language here&gt; code base I have worked on, that wasnt written by small team of experts, turned into a huge pile of crap…</div><br/><div id="42240600" class="c"><input type="checkbox" id="c-42240600" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#42239930">root</a><span>|</span><a href="#42240456">parent</a><span>|</span><a href="#42240652">next</a><span>|</span><label class="collapse" for="c-42240600">[-]</label><label class="expand" for="c-42240600">[1 more]</label></div><br/><div class="children"><div class="content">:-)</div><br/></div></div></div></div><div id="42240652" class="c"><input type="checkbox" id="c-42240652" checked=""/><div class="controls bullet"><span class="by">wtfparanoid</span><span>|</span><a href="#42239930">parent</a><span>|</span><a href="#42240456">prev</a><span>|</span><a href="#42240112">next</a><span>|</span><label class="collapse" for="c-42240652">[-]</label><label class="expand" for="c-42240652">[1 more]</label></div><br/><div class="children"><div class="content">well aligned scala teams are a great thing, impenetrable code is not - maybe a poor choice of adjective?</div><br/></div></div></div></div><div id="42240112" class="c"><input type="checkbox" id="c-42240112" checked=""/><div class="controls bullet"><span class="by">henning</span><span>|</span><a href="#42239930">prev</a><span>|</span><label class="collapse" for="c-42240112">[-]</label><label class="expand" for="c-42240112">[7 more]</label></div><br/><div class="children"><div class="content">So behind the scenes, every one of those statements will make a whole new user object with a whole new address object so that it remains immutable? And whether that will actually have any real-world performance impact is I guess entirely situational. Still, what happens if you do that with a big object graph?<p>Also, the original strong need for immutable data in the first place is safety under concurrency and parallelism?</div><br/><div id="42240507" class="c"><input type="checkbox" id="c-42240507" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#42240112">parent</a><span>|</span><a href="#42240213">next</a><span>|</span><label class="collapse" for="c-42240507">[-]</label><label class="expand" for="c-42240507">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Still, what happens if you do that with a big object graph?<p>The only thing that really matters here is how deep the graph is. Any unchanged object can just be reused as-is.</div><br/></div></div><div id="42240213" class="c"><input type="checkbox" id="c-42240213" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42240112">parent</a><span>|</span><a href="#42240507">prev</a><span>|</span><a href="#42240588">next</a><span>|</span><label class="collapse" for="c-42240213">[-]</label><label class="expand" for="c-42240213">[1 more]</label></div><br/><div class="children"><div class="content">This is in general how &quot;mutations&quot; are supposed to be done in a language like Scala (and is not unique to this library).  Yes, Scala does have a set of mutable collections, but the immutable collections are heavily optimized to make creating a &quot;new&quot; collection with a mutation much cheaper than having to copy the entire collection.<p>Of course, copying a case class in order to change a field likely does require a full copy of the object, though since this is the JVM, things like strings can be shared between them.<p>Ultimately this pattern is... fine.  Most uses don&#x27;t end up caring about the extra overhead vs. that of direct mutation.  I don&#x27;t recall if the Scala compiler does this, but another optimization that can be used is to actually mutate an immutable object when the compiler knows the original copy isn&#x27;t used anywhere else after the mutation.<p>&gt; <i>Also, the original strong need for immutable data in the first place is safety under concurrency and parallelism?</i><p>That&#x27;s one of the uses, but multiple ownership in general is another, without the presence of concurrency.<p>On top of that, there&#x27;s the general belief (which I subscribe to) that mutation introduces higher cognitive load on someone understanding the code.  Immutable data is much easier to reason about.</div><br/></div></div><div id="42240588" class="c"><input type="checkbox" id="c-42240588" checked=""/><div class="controls bullet"><span class="by">sriram_malhar</span><span>|</span><a href="#42240112">parent</a><span>|</span><a href="#42240213">prev</a><span>|</span><a href="#42241999">next</a><span>|</span><label class="collapse" for="c-42240588">[-]</label><label class="expand" for="c-42240588">[1 more]</label></div><br/><div class="children"><div class="content">Yes, behind the scenes every one of those statements will make a shallow copy of the object. But it isn&#x27;t just that object necessarily. For example, if you modify a tree node, then not only does that node needs cloning, its parent does too (since the modified parent needs to point to the new node), and so on until the root, which results in h = O(log(n)) new objects to create an entirely new tree. (h is the height of the tree).<p>What you get out if it is (a) safety, (b) understandability, which are wonderful properties to have as long as the end result is performing adequately. Implementing concurrent tree or graph traversals under conventional mutation is painful; the Java collection libraries simply throw a ConcurrentModificationException.  
The equivalent code for readonly traversals of immutable data structures is simplicity itself. You also get versioning and undo&#x27;s for free.</div><br/></div></div><div id="42241999" class="c"><input type="checkbox" id="c-42241999" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42240112">parent</a><span>|</span><a href="#42240588">prev</a><span>|</span><a href="#42242210">next</a><span>|</span><label class="collapse" for="c-42241999">[-]</label><label class="expand" for="c-42241999">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So behind the scenes, every one of those statements will make a whole new user object with a whole new address object so that it remains immutable?<p>Not a &quot;whole new&quot; one since it will use shared references to the parts that didn&#x27;t change (which is valid since they&#x27;re immutable). And in principle the VM could even recognise that the new object is replacing the old one so it can be edited in place.<p>&gt; Still, what happens if you do that with a big object graph?<p>I&#x27;ve literally never seen it cause a real-world performance problem, even if it theoretically could.<p>&gt; Also, the original strong need for immutable data in the first place is safety under concurrency and parallelism?<p>Partly that, but honestly mostly development sanity and maintainability. You can iterate a lot faster on immutable-first codebases, because it takes much less test coverage etc. to have the same level of confidence in your code.</div><br/></div></div><div id="42242210" class="c"><input type="checkbox" id="c-42242210" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#42240112">parent</a><span>|</span><a href="#42241999">prev</a><span>|</span><a href="#42240728">next</a><span>|</span><label class="collapse" for="c-42242210">[-]</label><label class="expand" for="c-42242210">[1 more]</label></div><br/><div class="children"><div class="content">Your question is a bit like someone asking &quot;so what does the garbage collector actually do? Does it X or Y? What impact does it have?&quot;<p>And the answer is: no need to care about it. Unless you need to really optimize for high performance (not necessary in 99% of the cases, otherwise you&#x27;d use a different language from the beginning anyways).<p>&gt; Also, the original strong need for immutable data in the first place is safety under concurrency and parallelism?<p>One of the reasons is that you really can just completely stop thinking about it. Just like you can stop thinking of (de)allocations. Except for some edge-cases when performance matters a lot.</div><br/></div></div><div id="42240728" class="c"><input type="checkbox" id="c-42240728" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42240112">parent</a><span>|</span><a href="#42242210">prev</a><span>|</span><label class="collapse" for="c-42240728">[-]</label><label class="expand" for="c-42240728">[1 more]</label></div><br/><div class="children"><div class="content">&gt; actually have any real-world performance impact<p>There are many techniques like this within Scala that would never be feasible if it wasn&#x27;t for the fact that the JVM is ridiculously fast. You could write the worst code imaginable and in many cases would still have better performance than Python, Javascript etc.</div><br/></div></div></div></div></div></div></div></div></div></body></html>