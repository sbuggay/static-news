<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737450056386" as="style"/><link rel="stylesheet" href="styles.css?v=1737450056386"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ninkovic.dev/blog/2025/think-twice-before-using-github-actions">I&#x27;ll think twice before using GitHub Actions again</a> <span class="domain">(<a href="https://ninkovic.dev">ninkovic.dev</a>)</span></div><div class="subtext"><span>nemwiz</span> | <span>172 comments</span></div><br/><div><div id="42766316" class="c"><input type="checkbox" id="c-42766316" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42766768">next</a><span>|</span><label class="collapse" for="c-42766316">[-]</label><label class="expand" for="c-42766316">[78 more]</label></div><br/><div class="children"><div class="content">&gt; no way of running actions locally<p>My policy is to never let pipeline DSLs contain any actual logic outside orchestration for the task, relying solely on one-liner build or test commands. If the task is more complicated than a one-liner, make a script for it in the repo to make it a one-liner. Doesn&#x27;t matter if it&#x27;s GitHub Actions, Jenkins, Azure DevOps (which has super cursed yaml), etc.<p>This in turn means that you can do what the pipeline does with a one-liner too, whether manually, from a vscode launch command, a git hook, etc.<p>This same approach can fix the mess of path-specific validation too - write a regular script (shell, python, JS, whatever you fancy) that checks what has changed and calls the appropriate validation script. The GitHub action is only used to run the script on PR and to prepare the CI container for whatever the script needs, and the same pipeline will always run.</div><br/><div id="42766610" class="c"><input type="checkbox" id="c-42766610" checked=""/><div class="controls bullet"><span class="by">Tainnor</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42777465">next</a><span>|</span><label class="collapse" for="c-42766610">[-]</label><label class="expand" for="c-42766610">[4 more]</label></div><br/><div class="children"><div class="content">The reason why many CI configs devolve into such a mess isn&#x27;t typically that they don&#x27;t extract complicated logic into scripts, it&#x27;s about all the interactions with the CI system itself. This includes caching, sharing of artifacts, generating reports, configuring permissions, ordering of jobs, deciding when which jobs will run, deciding what to do when jobs fail, etc. All of this can get quite messy in a large enough project.</div><br/><div id="42774872" class="c"><input type="checkbox" id="c-42774872" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42766610">parent</a><span>|</span><a href="#42772978">next</a><span>|</span><label class="collapse" for="c-42774872">[-]</label><label class="expand" for="c-42774872">[2 more]</label></div><br/><div class="children"><div class="content">You should generate your report with regular scripts. You need ci config to deploy them but that is the only part that should be different.</div><br/><div id="42775663" class="c"><input type="checkbox" id="c-42775663" checked=""/><div class="controls bullet"><span class="by">evilduck</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42774872">parent</a><span>|</span><a href="#42772978">next</a><span>|</span><label class="collapse" for="c-42775663">[-]</label><label class="expand" for="c-42775663">[1 more]</label></div><br/><div class="children"><div class="content">This doesn’t really work when you start sharding tests.</div><br/></div></div></div></div><div id="42772978" class="c"><input type="checkbox" id="c-42772978" checked=""/><div class="controls bullet"><span class="by">pydry</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42766610">parent</a><span>|</span><a href="#42774872">prev</a><span>|</span><a href="#42777465">next</a><span>|</span><label class="collapse" for="c-42772978">[-]</label><label class="expand" for="c-42772978">[1 more]</label></div><br/><div class="children"><div class="content">It never becomes unbearably messy this way though.<p>The reason it gets unbearably messy is because most people google &quot;how to do x in github actions&quot; (e.g. send a slack message) and there <i>is</i> a way and it&#x27;s almost always worse than scripting it yourself.</div><br/></div></div></div></div><div id="42777465" class="c"><input type="checkbox" id="c-42777465" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42766610">prev</a><span>|</span><a href="#42773879">next</a><span>|</span><label class="collapse" for="c-42777465">[-]</label><label class="expand" for="c-42777465">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m increasingly designing CI stuff around rake tasks. Then I run rake in the workflow.<p>But that caters only for each individual command... as you mention the orchestration is still coded in, and duplicated from what rake knows and would do.<p>So I&#x27;m currently trying stuff that has a pluggable output: one output (the default) is that it runs stuff, but with just a rake var, instead of generating then running commands it generates workflow content that ultimately gets merged in an ERB workflow template.<p>The model I like the most though is Nix-style distributed builds: it doesn&#x27;t matter if you do `nix build foo#bar` (local) or `nix build -j0 foo#bar` (zero local jobs =&gt; use a remote builder†), the `foo#bar` &quot;task&quot; and its dependents gets &quot;built&quot; (a.k.a run).<p>† builders get picked matching target platform and label-like &quot;features&quot; constraints.<p>Ever since there has been gitlab-runner, I&#x27;ve wondered why the hell can&#x27;t I just submit some job to a (list of) runner(s) - some of which could be local - without the whole push-to-repo+CI orchestrator? I mean I don&#x27;t think it would be out of this world to write a CLI command that locally parses whatever-ci.yml, creates jobs out of it, and submit them to a local runner.</div><br/></div></div><div id="42773879" class="c"><input type="checkbox" id="c-42773879" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42777465">prev</a><span>|</span><a href="#42773026">next</a><span>|</span><label class="collapse" for="c-42773879">[-]</label><label class="expand" for="c-42773879">[8 more]</label></div><br/><div class="children"><div class="content">100%. The ci&#x2F;cd job should be nothing more than a wrapper around the actual logic which is code in your repo.<p>I write a script called `deploy.sh` which is my wrapper for my ci&#x2F;cd jobs. It takes options and uses those options to find the piece of code to run.<p>The ci&#x2F;cd job can be parameterized or matrixed. The eventually-run individual jobs have arguments, and those are passed to deploy.sh. Secrets&#x2F;environment variables are set from the ci&#x2F;cd system, also parameterized&#x2F;matrixed (or alternately, a self-hosted runner can provide deploy.sh access to a vault).<p>End result: from my laptop I can run `deploy.sh deploy --env test --modules webserver` to deploy the webserver to <i>test</i>, and the CI&#x2F;CD job also runs the same job the same way. The only thing I maintain that&#x27;s CI&#x2F;CD-specific is the GitHub Action-specific logic of how to get ready to run `deploy.sh`, which I write once and never change. Thus I could use 20 different CI&#x2F;CD systems, but never have to refactor my actual deployment code, which also always works on my laptop. Vendor lock-in is impossible, thanks to a little abstraction.<p>(If you have ever worked with a team with 1,000 Jenkins jobs and the team has basically decided they can never move off of Jenkins because it would take too much work to rewrite all the jobs, you&#x27;ll understand why I do it this way)</div><br/><div id="42775003" class="c"><input type="checkbox" id="c-42775003" checked=""/><div class="controls bullet"><span class="by">hardwaresofton</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773879">parent</a><span>|</span><a href="#42773026">next</a><span>|</span><label class="collapse" for="c-42775003">[-]</label><label class="expand" for="c-42775003">[7 more]</label></div><br/><div class="children"><div class="content">Hey if you’ve never heard of it consider using just[0], it’s a better makefile and supports shell scripting explicitly (so at least equivalent in power, though so is Make)<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;casey&#x2F;just">https:&#x2F;&#x2F;github.com&#x2F;casey&#x2F;just</a></div><br/><div id="42777235" class="c"><input type="checkbox" id="c-42777235" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42775003">parent</a><span>|</span><a href="#42775499">next</a><span>|</span><label class="collapse" for="c-42777235">[-]</label><label class="expand" for="c-42777235">[1 more]</label></div><br/><div class="children"><div class="content">The shell also supports shell scripting!  You don&#x27;t need Just or Make<p>Especially for Github Actions, which is stateless.  If you want to reuse computation within their VMs (i.e. not do a fresh build &#x2F; test &#x2F; whatever), you can&#x27;t rely on Just or Make<p>A problem with Make is that it literally shells out, and the syntax collides.  For example, the PID in Make is $$$$, because it&#x27;s $$ in shell, and then you have to escape $ as $$ with Make.<p>I believe Just has similar syntax collisions.  It&#x27;s fine for simple things, but when it gets complex, now you have {{ just vars }} as well as $shell_vars.<p>It&#x27;s simpler to &quot;just&quot; use shell vars, and to &quot;just&quot; use shell.<p>Shell already has a lot of footguns, and both Just and Make only add to that, because they add their own syntax on top, while also depending on shell.</div><br/></div></div><div id="42775499" class="c"><input type="checkbox" id="c-42775499" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42775003">parent</a><span>|</span><a href="#42777235">prev</a><span>|</span><a href="#42773026">next</a><span>|</span><label class="collapse" for="c-42775499">[-]</label><label class="expand" for="c-42775499">[5 more]</label></div><br/><div class="children"><div class="content">Thank you, I have seen it, but I prefer Make.</div><br/><div id="42776932" class="c"><input type="checkbox" id="c-42776932" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42775499">parent</a><span>|</span><a href="#42773026">next</a><span>|</span><label class="collapse" for="c-42776932">[-]</label><label class="expand" for="c-42776932">[4 more]</label></div><br/><div class="children"><div class="content">I bet all your targets are .PHONY?</div><br/><div id="42777391" class="c"><input type="checkbox" id="c-42777391" checked=""/><div class="controls bullet"><span class="by">derkades</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42776932">parent</a><span>|</span><a href="#42773026">next</a><span>|</span><label class="collapse" for="c-42777391">[-]</label><label class="expand" for="c-42777391">[3 more]</label></div><br/><div class="children"><div class="content">But I can install it on any Linux system from the base repository</div><br/><div id="42777436" class="c"><input type="checkbox" id="c-42777436" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42777391">parent</a><span>|</span><a href="#42773026">next</a><span>|</span><label class="collapse" for="c-42777436">[-]</label><label class="expand" for="c-42777436">[2 more]</label></div><br/><div class="children"><div class="content">If all your targets are .PHONY, you might as well just as bash (or your favourite shell) directly.<p>Make targets look suspiciously like functions (or procedures), but they actually aren&#x27;t.</div><br/><div id="42777795" class="c"><input type="checkbox" id="c-42777795" checked=""/><div class="controls bullet"><span class="by">hardwaresofton</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42777436">parent</a><span>|</span><a href="#42773026">next</a><span>|</span><label class="collapse" for="c-42777795">[-]</label><label class="expand" for="c-42777795">[1 more]</label></div><br/><div class="children"><div class="content">One of the benefits of just -- it isn&#x27;t a build system, it&#x27;s a command runner.<p>Good facilities for arguments, builtins like absolute locations -- there are a ton of benefits (see the README).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42773026" class="c"><input type="checkbox" id="c-42773026" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42773879">prev</a><span>|</span><a href="#42773258">next</a><span>|</span><label class="collapse" for="c-42773026">[-]</label><label class="expand" for="c-42773026">[1 more]</label></div><br/><div class="children"><div class="content">I’ll go so far as to say the massive add on&#x2F;plugin list and featuritis of CI&#x2F;CD tools is actively harmful to the sanity of your team.<p>The only functionality a CI tool should be providing is:<p>- starting and running an environment to build shit in<p>- accurately tracking success or failure<p>- accurate association of builds with artifacts<p>- telemetry (either their own or integration) and audit trails<p>- correlation with project planning software<p>- scheduled builds<p>- build chaining<p>That’s a lot, but it’s a lot less than any CI tool made in the last 15 years does, and that’s enough.<p>There’s a big difference for instance between having a tool that understands Maven information enough to present a build summary, and one with a Maven fetch&#x2F;push task. The latter is a black box you can’t test locally, and your lead devs can’t either, so when it breaks, it triggers helplessness.<p>If the only answer to a build failure is to stare at config and wait for enlightenment, you fucked up.</div><br/></div></div><div id="42773258" class="c"><input type="checkbox" id="c-42773258" checked=""/><div class="controls bullet"><span class="by">ukoki</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42773026">prev</a><span>|</span><a href="#42767120">next</a><span>|</span><label class="collapse" for="c-42773258">[-]</label><label class="expand" for="c-42773258">[5 more]</label></div><br/><div class="children"><div class="content">&gt; My policy is to never let pipeline DSLs contain any actual logic outside orchestration for the task,<p>I call this “isomorphic CI” — ie: as long as you set the correct env vars, it should run identically on GitHub actions, Jenkins, your local machine, a VM etc</div><br/><div id="42773274" class="c"><input type="checkbox" id="c-42773274" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773258">parent</a><span>|</span><a href="#42776877">next</a><span>|</span><label class="collapse" for="c-42773274">[-]</label><label class="expand" for="c-42773274">[2 more]</label></div><br/><div class="children"><div class="content">This is the only DevOps way. Abstract the build into a single step.</div><br/><div id="42773810" class="c"><input type="checkbox" id="c-42773810" checked=""/><div class="controls bullet"><span class="by">vvillena</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773274">parent</a><span>|</span><a href="#42776877">next</a><span>|</span><label class="collapse" for="c-42773810">[-]</label><label class="expand" for="c-42773810">[1 more]</label></div><br/><div class="children"><div class="content">And yet, you would be surprised at the amount of people who react like that&#x27;s an ignorant statement (&quot;not feasible in real world conditions&quot;), an utopic goal (&quot;too much time to implement&quot;), an impossible feat (&quot;automation difficults human oversight&quot;), or, my favorite, the &quot;this is beneath us&quot; excuse (&quot;see, we are special and this wouldn&#x27;t work here&quot;).<p>Automation renders knowledge into a set of executable steps, which is much better than rendering knowledge into documentation, or leaving it to rot in people&#x27;s minds. Compiling all rendered knowledge into a single step is the easiest way to ensure all elements around the build and deployment lifecycle work in unison and are guarded around failures.</div><br/></div></div></div></div><div id="42776877" class="c"><input type="checkbox" id="c-42776877" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773258">parent</a><span>|</span><a href="#42773274">prev</a><span>|</span><a href="#42777831">next</a><span>|</span><label class="collapse" for="c-42776877">[-]</label><label class="expand" for="c-42776877">[1 more]</label></div><br/><div class="children"><div class="content">Yep. I remember at a previous company multiple teams had manually created steps in TeamCity (and it wasn&#x27;t even being backed up in .xml files).<p>I just did my own thing and wrapped everything deploy.sh and test.sh and when the shift to another system came... well it was still kind of annoying, but at least I wasn&#x27;t recreating the whole thing.</div><br/></div></div><div id="42777831" class="c"><input type="checkbox" id="c-42777831" checked=""/><div class="controls bullet"><span class="by">NilMostChill</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773258">parent</a><span>|</span><a href="#42776877">prev</a><span>|</span><a href="#42767120">next</a><span>|</span><label class="collapse" for="c-42777831">[-]</label><label class="expand" for="c-42777831">[1 more]</label></div><br/><div class="children"><div class="content">i like this term</div><br/></div></div></div></div><div id="42767120" class="c"><input type="checkbox" id="c-42767120" checked=""/><div class="controls bullet"><span class="by">jicea</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42773258">prev</a><span>|</span><a href="#42775349">next</a><span>|</span><label class="collapse" for="c-42767120">[-]</label><label class="expand" for="c-42767120">[36 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why this is not the evident approach for everyone writing GitHub Actions&#x2F;GitLab CI&#x2F;CD yaml etc....<p>I&#x27;ve struggled in some teams to explained why it&#x27;s better to extract your command in scripts (ShellCheck on it, scripts are simple to run locally etc...) instead of writing a Frankenstein of YAML and shell commands. I hope someday to find an authoritative guidelines on writing pipeline that promote this approach so at least I can point to this link instead of defending myself being a dinosaur!</div><br/><div id="42767261" class="c"><input type="checkbox" id="c-42767261" checked=""/><div class="controls bullet"><span class="by">mrweasel</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767120">parent</a><span>|</span><a href="#42775712">next</a><span>|</span><label class="collapse" for="c-42767261">[-]</label><label class="expand" for="c-42767261">[9 more]</label></div><br/><div class="children"><div class="content">In a previous job we had a team tasked with designing these &quot;modern&quot; CI&#x2F;CD pipeline solutions, mostly meant for Kubernetes, but it was suppose to work for everything. They had such a hard on for tools that would run each step as a separate isolated task and did not want pipelines to &quot;devolve&quot; into shell scripts.<p>Getting anything done in such environments are just a pain. You spend more time fighting the systems than you do actually solving problems. It is my opinion that a CI&#x2F;CD system needs just the following features: Triggers (source code repo, http endpoints or manually triggered), secret management and shell script execution. That&#x27;s it, you can build anything using that.</div><br/><div id="42768692" class="c"><input type="checkbox" id="c-42768692" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767261">parent</a><span>|</span><a href="#42775045">next</a><span>|</span><label class="collapse" for="c-42768692">[-]</label><label class="expand" for="c-42768692">[1 more]</label></div><br/><div class="children"><div class="content">I think what they really wanted was something like bazel. The only real benefit I can think right now for not &quot;devolving&quot; into shell scripts is distributed caching with hermetic builds. It has very real benefits but it also requires real effort to work correctly.</div><br/></div></div><div id="42775045" class="c"><input type="checkbox" id="c-42775045" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767261">parent</a><span>|</span><a href="#42768692">prev</a><span>|</span><a href="#42774018">next</a><span>|</span><label class="collapse" for="c-42775045">[-]</label><label class="expand" for="c-42775045">[2 more]</label></div><br/><div class="children"><div class="content">Mostly agreed, but (maybe orthogonal) IME, popular CI&#x2F;CD vendors like TeamCity* can make even basic things like shell script execution problematic.<p>* TC offers sh, full stop. If you want to script something that depends on bash, it&#x27;s a PITA and you end up with a kludge to run bash in sh in docker in docker.</div><br/><div id="42776362" class="c"><input type="checkbox" id="c-42776362" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42775045">parent</a><span>|</span><a href="#42774018">next</a><span>|</span><label class="collapse" for="c-42776362">[-]</label><label class="expand" for="c-42776362">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you need a specific interpreter to be used, specify shebang (for example, #!&#x2F;bin&#x2F;bash) as the first line of the script.<p><a href="https:&#x2F;&#x2F;www.jetbrains.com&#x2F;help&#x2F;teamcity&#x2F;command-line.html#:~:text=for%20example%2C%20%23!%2Fbin%2Fbash" rel="nofollow">https:&#x2F;&#x2F;www.jetbrains.com&#x2F;help&#x2F;teamcity&#x2F;command-line.html#:~...</a><p>Your &quot;docker in docker&quot; comment makes me wonder if you&#x27;re conflating the <i>image</i> that you are using, that just happens to be run by TeamCity, versus some inherent limitation of TC. I believe a <i>boatload</i> of the Hashicorp images ship with dash, or busybox or worse, and practically anything named &quot;slim&quot; or &quot;alpine&quot; similarly</div><br/></div></div></div></div><div id="42774018" class="c"><input type="checkbox" id="c-42774018" checked=""/><div class="controls bullet"><span class="by">datavirtue</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767261">parent</a><span>|</span><a href="#42775045">prev</a><span>|</span><a href="#42774052">next</a><span>|</span><label class="collapse" for="c-42774018">[-]</label><label class="expand" for="c-42774018">[4 more]</label></div><br/><div class="children"><div class="content">I just joined as the enterprise architect for company that has never had one. There is an existing devops team that is making everyone pull their hair out and I haven&#x27;t had a single spare minute to dig in on their mess but this sounds early familiar.</div><br/><div id="42774324" class="c"><input type="checkbox" id="c-42774324" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42774018">parent</a><span>|</span><a href="#42774052">next</a><span>|</span><label class="collapse" for="c-42774324">[-]</label><label class="expand" for="c-42774324">[3 more]</label></div><br/><div class="children"><div class="content">Is this really the job of an enterprise architect? To dig into the details of a devops team&#x27;s mess?</div><br/><div id="42776967" class="c"><input type="checkbox" id="c-42776967" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42774324">parent</a><span>|</span><a href="#42775503">next</a><span>|</span><label class="collapse" for="c-42776967">[-]</label><label class="expand" for="c-42776967">[1 more]</label></div><br/><div class="children"><div class="content">The job of senior people should mostly be to make sure the organisation runs smoothly.<p>If no one else is doing anything about the mess, then it falls to the senior person to sort it out.<p>As a rule of thumb:<p>- Ideally your people do the Right Thing by themselves by the magic of &#x27;leadership&#x27;.
- Second best: you chase the people to do the Right Thing.
- Third: you as the senior person do the Right Thing.
- Least ideal: no one fixes the mess nor implements the proper way.<p>I guess some people can achieve the ideal outcome with pure charisma (or fear?) alone, but I find that occasionally getting your hands dirty (option 3) helps earn the respect to make the &#x27;leadership&#x27; work.  It can also help ground you in the reality of the day to day work.<p>However, you are right that a senior person shouldn&#x27;t get bogged down with such work.  You need to cut your losses at some point.</div><br/></div></div><div id="42775503" class="c"><input type="checkbox" id="c-42775503" checked=""/><div class="controls bullet"><span class="by">datavirtue</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42774324">parent</a><span>|</span><a href="#42776967">prev</a><span>|</span><a href="#42774052">next</a><span>|</span><label class="collapse" for="c-42775503">[-]</label><label class="expand" for="c-42775503">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more about giving the team and the overall strategy a thumbs up or down, so yes.</div><br/></div></div></div></div></div></div></div></div><div id="42775712" class="c"><input type="checkbox" id="c-42775712" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767120">parent</a><span>|</span><a href="#42767261">prev</a><span>|</span><a href="#42767246">next</a><span>|</span><label class="collapse" for="c-42775712">[-]</label><label class="expand" for="c-42775712">[1 more]</label></div><br/><div class="children"><div class="content">I think I can summarize it in a rough, general way.<p><pre><code>  CI&#x2F;CD is a method to automate tasks in the background that you would otherwise run on your laptop. The output
  of the tasks are used as quality gates for merging commits, and for deployments.
  
  - Step 1. Your &quot;laptop in the cloud&quot; requires some configuration (credentials, installed software, cached artifacts)
    before a job can be run.
    - Requires logic specific to the CI&#x2F;CD system
  
  - Step 2. Running many jobs in parallel, passing data from step to step, etc requires some instructions.
    - Requires logic specific to the CI&#x2F;CD system
  
  - Step 3. The job itself is the execution of a program (or programs), with some inputs and outputs.
    - Works the same on any computer (assuming the same software, environment, inputs, etc)
    - Using a container in Step 1. makes this practical and easy
  
  - Step 4. After the job finishes, artifacts need to be saved, results collected, and notifications sent.
    - Some steps are specific to the CI&#x2F;CD system, others can be a reusable job
  
  Step 3 does not require being hard-coded into the config format of the CI&#x2F;CD system. If it is instead
  just executable code in the repo, it allows developers to use (and work on) the code locally without
  the CI&#x2F;CD system being involved. It also allows moving to a different CI&#x2F;CD system without ever rewriting
  all the jobs; the only thing that needs to be rewritten are the CI&#x2F;CD-specific parts, which should be
  generic and apply to all jobs pretty much the same.
  
  Moving the CI&#x2F;CD-specific parts to a central library of configuration allows you to write some code
  once and reuse it many times (making it DRY). CircleCI Orbs, GitHub Actions, Jenkins Shared Libraries&#x2F;
  Groovy Libraries, etc are examples of these. Write your code once, fix a bug once, reuse it everywhere.</code></pre></div><br/></div></div><div id="42767246" class="c"><input type="checkbox" id="c-42767246" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767120">parent</a><span>|</span><a href="#42775712">prev</a><span>|</span><a href="#42777094">next</a><span>|</span><label class="collapse" for="c-42767246">[-]</label><label class="expand" for="c-42767246">[4 more]</label></div><br/><div class="children"><div class="content">My &quot;favorite&quot; is when I see people go all in, writing thousands of lines of Jenkins-flavor Groovy that parses JSON build specifications of arbitrary complexity to sort out how to build that particular project.<p>&quot;But then we can reuse the same pipeline for all our projects!&quot;</div><br/><div id="42775771" class="c"><input type="checkbox" id="c-42775771" checked=""/><div class="controls bullet"><span class="by">baby_souffle</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767246">parent</a><span>|</span><a href="#42774130">next</a><span>|</span><label class="collapse" for="c-42775771">[-]</label><label class="expand" for="c-42775771">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;But then we can reuse the same pipeline for all our projects!&quot;<p>oh god just reading that gave me PTSD flash backs.<p>At $priorGig there was the &quot;omni-chart&quot;. It was a helm chart that was so complex it needed to be wrapped in terraform and used composable terraform modules w&#x2F; user var overrides as needed.<p>Debugging anything about it meant clearing your calendar for the day and probably the following day, too.</div><br/></div></div><div id="42774130" class="c"><input type="checkbox" id="c-42774130" checked=""/><div class="controls bullet"><span class="by">ozim</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767246">parent</a><span>|</span><a href="#42775771">prev</a><span>|</span><a href="#42773545">next</a><span>|</span><label class="collapse" for="c-42774130">[-]</label><label class="expand" for="c-42774130">[1 more]</label></div><br/><div class="children"><div class="content">I think that is pitfall of software devs.<p>For me it was an epiphany as software dev - not to write reusable extensible scripts - I am so much more productive after that.</div><br/></div></div><div id="42773545" class="c"><input type="checkbox" id="c-42773545" checked=""/><div class="controls bullet"><span class="by">lowercased</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767246">parent</a><span>|</span><a href="#42774130">prev</a><span>|</span><a href="#42777094">next</a><span>|</span><label class="collapse" for="c-42773545">[-]</label><label class="expand" for="c-42773545">[1 more]</label></div><br/><div class="children"><div class="content">I can rarely reuse the same pipeline for the same project 6 months down the road, much less reuse for anything else.<p>The few bits that end up getting reused are the externalized bash scripts.</div><br/></div></div></div></div><div id="42777094" class="c"><input type="checkbox" id="c-42777094" checked=""/><div class="controls bullet"><span class="by">dpkirchner</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767120">parent</a><span>|</span><a href="#42767246">prev</a><span>|</span><a href="#42776785">next</a><span>|</span><label class="collapse" for="c-42777094">[-]</label><label class="expand" for="c-42777094">[2 more]</label></div><br/><div class="children"><div class="content">This all reminds me of the systemd ini-like syntax vs shell scripts debate. Shell scripts are superior, of course, but they do require deeper knowledge of unix-like systems.</div><br/><div id="42777169" class="c"><input type="checkbox" id="c-42777169" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42777094">parent</a><span>|</span><a href="#42776785">next</a><span>|</span><label class="collapse" for="c-42777169">[-]</label><label class="expand" for="c-42777169">[1 more]</label></div><br/><div class="children"><div class="content">yeah if you author CI jobs, you should know linux, otherwise a person should not even touch the CI system with 10ft pole</div><br/></div></div></div></div><div id="42776785" class="c"><input type="checkbox" id="c-42776785" checked=""/><div class="controls bullet"><span class="by">harrall</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767120">parent</a><span>|</span><a href="#42777094">prev</a><span>|</span><a href="#42767279">next</a><span>|</span><label class="collapse" for="c-42776785">[-]</label><label class="expand" for="c-42776785">[6 more]</label></div><br/><div class="children"><div class="content">A shell script has many extremely sharp edges like dealing with stdin, stderr, stdout, subprocesses, exit codes, environmental variables, etc.<p>Most programmers have never written a shell script and writing CI files is already frustrating because sometimes you have to deploy, run, fix, deploy, run, fix, which means nobody is going to stop in the middle of that and try to learn shell scripting.<p>Instead, they copy commands from their terminal into the file and the CI runner takes care of all the rough edges.<p>I ALWAYS advise writing a shell script but I know it&#x27;s because I actually know how to write them. But I guess that&#x27;s why some people are paid more big bux.</div><br/><div id="42776973" class="c"><input type="checkbox" id="c-42776973" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42776785">parent</a><span>|</span><a href="#42767279">next</a><span>|</span><label class="collapse" for="c-42776973">[-]</label><label class="expand" for="c-42776973">[5 more]</label></div><br/><div class="children"><div class="content">GitHub&#x27;s CI yaml also accepts eg Python.  (Or anything else, actually.)<p>That&#x27;s generally a bit less convenient, ie it takes a few more lines, but it has significantly fewer sharp edges than your typical shell script.  And more people have written Python scripts, I guess?</div><br/><div id="42777006" class="c"><input type="checkbox" id="c-42777006" checked=""/><div class="controls bullet"><span class="by">harrall</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42776973">parent</a><span>|</span><a href="#42767279">next</a><span>|</span><label class="collapse" for="c-42777006">[-]</label><label class="expand" for="c-42777006">[4 more]</label></div><br/><div class="children"><div class="content">I find that Python scripts that deal with calling other programs have even more sharp edges because now you have to deal with stdin, stderr and stdout much more explicitly. Now you need to both know shell scripting AND Python.<p>Python’s subprocess has communicate(), check_output() and other helpers which takes care of a lot but (a) you need to know what method you should actually call and (b) if you need to do something outside of that, you have to use Popen directly and it’s much more work than just writing a shell script. All doable if you understand pipes and all that but if you don’t, you’ll be just throwing stuff at the wall until something sticks.</div><br/><div id="42777255" class="c"><input type="checkbox" id="c-42777255" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42777006">parent</a><span>|</span><a href="#42777172">next</a><span>|</span><label class="collapse" for="c-42777255">[-]</label><label class="expand" for="c-42777255">[2 more]</label></div><br/><div class="children"><div class="content">1) If possible, don&#x27;t run shell scripts with Python. Evaluate why you are trying to do that and don&#x27;t.
2) Python has a bunch of infrastructure compared to shell, you can use it. Shell scripts don&#x27;t.
3) Apply the same you used for the script to what it calls. CI calls control script for job, script calls tools&#x2F;libraries for heavy lifting.<p>Often the shell script just calls a python&#x2F;Ruby&#x2F;rust exec anyways...<p>Shell scripts are for scripting...the shell. Nothing else.</div><br/></div></div><div id="42777172" class="c"><input type="checkbox" id="c-42777172" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42777006">parent</a><span>|</span><a href="#42777255">prev</a><span>|</span><a href="#42767279">next</a><span>|</span><label class="collapse" for="c-42777172">[-]</label><label class="expand" for="c-42777172">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but at least that&#x27;s all fairly obvious---you might not know how to solve the problem, but at least you know you have a problem that needs solving.  Compare that to the hidden pitfalls of eg dealing with whitespace in filenames in shell scripts.  Or misspelled variable names that accidentally refer to non-existent variables but get treated as if they are set to be &quot;&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="42767279" class="c"><input type="checkbox" id="c-42767279" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767120">parent</a><span>|</span><a href="#42776785">prev</a><span>|</span><a href="#42776943">next</a><span>|</span><label class="collapse" for="c-42767279">[-]</label><label class="expand" for="c-42767279">[1 more]</label></div><br/><div class="children"><div class="content">To make the thing actually fast at scale, a lot of the logic ends up being specific to the provider; requiring tokens, artifacts etc that aren&#x27;t available locally. You end up with something that tries to detect if you&#x27;re running locally or in CI, and then you end up in exactly the same situation.</div><br/></div></div><div id="42776943" class="c"><input type="checkbox" id="c-42776943" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767120">parent</a><span>|</span><a href="#42767279">prev</a><span>|</span><a href="#42773129">next</a><span>|</span><label class="collapse" for="c-42776943">[-]</label><label class="expand" for="c-42776943">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [...] instead of writing a Frankenstein of YAML and shell commands.<p>The &#x27;Frankenstein&#x27; approach isn&#x27;t what makes it necessarily worse.  Eg Makefiles work like that, too, and while I have my reservations about Make, it&#x27;s not really because they embed shell scripts.</div><br/></div></div><div id="42773129" class="c"><input type="checkbox" id="c-42773129" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767120">parent</a><span>|</span><a href="#42776943">prev</a><span>|</span><a href="#42774896">next</a><span>|</span><label class="collapse" for="c-42773129">[-]</label><label class="expand" for="c-42773129">[10 more]</label></div><br/><div class="children"><div class="content">it can be quite hard to write proper scripts that work consistently... different shells have different behaviours, availability of local tools, paths, etc<p>and it feels like fighting against the flow when you&#x27;re trying to make it reusable across many repos</div><br/><div id="42773616" class="c"><input type="checkbox" id="c-42773616" checked=""/><div class="controls bullet"><span class="by">akdev1l</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773129">parent</a><span>|</span><a href="#42776981">next</a><span>|</span><label class="collapse" for="c-42773616">[-]</label><label class="expand" for="c-42773616">[8 more]</label></div><br/><div class="children"><div class="content">Containerize the build environment so everything is captured (dependencies, build tools, etc)</div><br/><div id="42773731" class="c"><input type="checkbox" id="c-42773731" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773616">parent</a><span>|</span><a href="#42773842">next</a><span>|</span><label class="collapse" for="c-42773731">[-]</label><label class="expand" for="c-42773731">[6 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re not containerizing your CI&#x2F;CD, you&#x27;re really lost.</div><br/><div id="42774392" class="c"><input type="checkbox" id="c-42774392" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773731">parent</a><span>|</span><a href="#42776653">next</a><span>|</span><label class="collapse" for="c-42774392">[-]</label><label class="expand" for="c-42774392">[2 more]</label></div><br/><div class="children"><div class="content">How do I containerize building desktop apps for windows with MSVC?</div><br/><div id="42776986" class="c"><input type="checkbox" id="c-42776986" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42774392">parent</a><span>|</span><a href="#42776653">next</a><span>|</span><label class="collapse" for="c-42776986">[-]</label><label class="expand" for="c-42776986">[1 more]</label></div><br/><div class="children"><div class="content">Wine?<p>Less snarky: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;virtualization&#x2F;windowscontainers&#x2F;about&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;virtualization&#x2F;windowscont...</a> seems to be a thing?<p>And in any case, you can use VMs instead of containers.</div><br/></div></div></div></div><div id="42776653" class="c"><input type="checkbox" id="c-42776653" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773731">parent</a><span>|</span><a href="#42774392">prev</a><span>|</span><a href="#42775985">next</a><span>|</span><label class="collapse" for="c-42776653">[-]</label><label class="expand" for="c-42776653">[1 more]</label></div><br/><div class="children"><div class="content">Only if your tech stack is bad (i.e. Python). My maven builds work anywhere with an even vaguely recent maven and JVM (and will fail-fast with a clear and simple error if you try to run them in something too old), no need to put an extra layer of wrapping around that.</div><br/></div></div><div id="42775985" class="c"><input type="checkbox" id="c-42775985" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773731">parent</a><span>|</span><a href="#42776653">prev</a><span>|</span><a href="#42773842">next</a><span>|</span><label class="collapse" for="c-42775985">[-]</label><label class="expand" for="c-42775985">[2 more]</label></div><br/><div class="children"><div class="content">That might be the case if Docker did in fact guarantee (or at least make it easy to guarantee) deterministic builds -- but it doesn&#x27;t really even try:<p>1. Image tags (&quot;latest&quot;, etc.) can change over time. Does any layer in your Dockerfile -- including inside transitive deps -- build on an existing layer identified by tag? If so, you never had reproducibility.<p>2. Plenty of Dockerfiles include things like &quot;apt-get some-tool&quot; or its moral equivalent, which will pull down whatever is the latest version of that tool.<p>It&#x27;s currently common and considered normal to use these &quot;features&quot;. Until that changes, Docker mostly adds only <i>the impression of</i> reproducibility, but genuine weight and pain.</div><br/><div id="42777377" class="c"><input type="checkbox" id="c-42777377" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42775985">parent</a><span>|</span><a href="#42773842">next</a><span>|</span><label class="collapse" for="c-42777377">[-]</label><label class="expand" for="c-42777377">[1 more]</label></div><br/><div class="children"><div class="content">The advantage that Docker brings isn&#x27;t perfect guaranteed reusability, it&#x27;s complete independence (or as close you can easily get while not wasting resources on VMs) from the system on which the build is running, plus some resuability in practice in a certain period of time, and given other good practices.<p>Sure, if I try to rebuild a docker image from 5 years ago, it may fail, or produce something different, because it was pulling in some packages that have changed significantly in apt, or perhaps pip has changed encryption and no longer accepts TLS1.1 or whatever. And if you use &#x27;:latest&#x27; or if your team has a habit of reusing build numbers or custom tags, you may break the assumptions even sooner.<p>But even so, especially if using always incremented build numbers as image tags, a docker image will work the same way om the Jenkins system, the GitHub Actions pipeline, and every coworker&#x27;s local build, for a while.</div><br/></div></div></div></div></div></div><div id="42773842" class="c"><input type="checkbox" id="c-42773842" checked=""/><div class="controls bullet"><span class="by">darthwalsh</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773616">parent</a><span>|</span><a href="#42773731">prev</a><span>|</span><a href="#42776981">next</a><span>|</span><label class="collapse" for="c-42773842">[-]</label><label class="expand" for="c-42773842">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sold on using containers for macOS desktop apps...</div><br/></div></div></div></div><div id="42776981" class="c"><input type="checkbox" id="c-42776981" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773129">parent</a><span>|</span><a href="#42773616">prev</a><span>|</span><a href="#42774896">next</a><span>|</span><label class="collapse" for="c-42776981">[-]</label><label class="expand" for="c-42776981">[1 more]</label></div><br/><div class="children"><div class="content">Pick a single shell and treat it like a programming language.<p>Or write your stuff in eg Python in the first place.  GitHub&#x27;s CI yaml supports scripts in arbitrary languages, not just shell.</div><br/></div></div></div></div><div id="42774896" class="c"><input type="checkbox" id="c-42774896" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767120">parent</a><span>|</span><a href="#42773129">prev</a><span>|</span><a href="#42775349">next</a><span>|</span><label class="collapse" for="c-42774896">[-]</label><label class="expand" for="c-42774896">[1 more]</label></div><br/><div class="children"><div class="content">The reason for this is that nobody took the time to write a proper background document on Github Actions. The kind of information that you or I might convey if asked to explain it at the whiteboard to junior hires, or senior management.<p>This syndrome is very common these days. Things are explained differentially: it&#x27;s like Circle CI but in the GH repo. Well that&#x27;s no use if the audience wasn&#x27;t around when  Circle CI was first new and readily explained (It&#x27;s like Jenkins but in the cloud...).</div><br/></div></div></div></div><div id="42775349" class="c"><input type="checkbox" id="c-42775349" checked=""/><div class="controls bullet"><span class="by">cnunciato</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42767120">prev</a><span>|</span><a href="#42774521">next</a><span>|</span><label class="collapse" for="c-42775349">[-]</label><label class="expand" for="c-42775349">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Lack of local development. It&#x27;s a known thing that there is no way of running GitHub Actions locally.<p>This is one thing I really love about Buildkite[0] -- being able to run the agent locally. (Full disclosure: I also work for Buildkite.) The Buildkite agent runs as a normal process too (rather than as a Docker container), which makes the process of workflow development way simpler, IMO. I also keep a handful of agents running locally on my laptop for personal projects, which is nice. (Why run those processes on someone else&#x27;s infra if I don&#x27;t have to?)<p>&gt;Reusability and YAML<p>This is another one that I believe is unique to Buildkite and that I also find super useful. You can write your workflows in YAML of course -- but you can also write them in your language of choice, and then serialize to YAML or JSON when you&#x27;re ready to start the run (or even add onto the run as it&#x27;s running if you need to). This lets you encapsulate and reuse (and test, etc.) workflow logic as you need. We have many large customers that do some amazing things with this capability.<p>[0]: <a href="https:&#x2F;&#x2F;buildkite.com&#x2F;docs&#x2F;agent&#x2F;v3" rel="nofollow">https:&#x2F;&#x2F;buildkite.com&#x2F;docs&#x2F;agent&#x2F;v3</a></div><br/></div></div><div id="42774521" class="c"><input type="checkbox" id="c-42774521" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42775349">prev</a><span>|</span><a href="#42767294">next</a><span>|</span><label class="collapse" for="c-42774521">[-]</label><label class="expand" for="c-42774521">[3 more]</label></div><br/><div class="children"><div class="content">The actual subtle issue here is that sometimes you actually need CI features around caching and the like, so you are forced to engage with the format a bit.<p>You can, of course, chew it down to a bare minimum. But I really wish more CI systems would just show up with &quot;you configure us with scripts&quot; instead of the &quot;declarative&quot; nonsense.</div><br/><div id="42774580" class="c"><input type="checkbox" id="c-42774580" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42774521">parent</a><span>|</span><a href="#42767294">next</a><span>|</span><label class="collapse" for="c-42774580">[-]</label><label class="expand" for="c-42774580">[2 more]</label></div><br/><div class="children"><div class="content">CI that isn&#x27;t running on your servers wants very deep understanding of how your process works so they can minimize their costs (this is true whether or not you pay for using CI)</div><br/><div id="42775139" class="c"><input type="checkbox" id="c-42775139" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42774580">parent</a><span>|</span><a href="#42767294">next</a><span>|</span><label class="collapse" for="c-42775139">[-]</label><label class="expand" for="c-42775139">[1 more]</label></div><br/><div class="children"><div class="content">Totally! It&#x27;s a legitimate thing! I just wish that I had more tools for dynamically providing this information to CI so that it could work better but I could also write relatively general tooling with a general purpose language.<p>The ideal for me is (this is very silly and glib and a total category error) LSP but for CI. Tooling that is relatively normalized, letting me (for example) have a pytest plugin that &quot;does sharding&quot; cleanly across multiple CI operators.<p>There&#x27;s some stuff and conventions already of course, but in particular caching and spinning up jobs dynamically are still not there.</div><br/></div></div></div></div></div></div><div id="42767294" class="c"><input type="checkbox" id="c-42767294" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42774521">prev</a><span>|</span><a href="#42777489">next</a><span>|</span><label class="collapse" for="c-42767294">[-]</label><label class="expand" for="c-42767294">[4 more]</label></div><br/><div class="children"><div class="content">That’s usually very hard or impossible for many things. The AzDo yaml consists of a lot of steps that are specific to the CI environment (fetching secrets, running tests on multiple nodes, storing artifacts of various kinds).<p>Even if the ”meat” of the script is a single build.ps oneliner, I quickly end up with 200 line yaml scripts which have no chance of working locally.</div><br/><div id="42767659" class="c"><input type="checkbox" id="c-42767659" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767294">parent</a><span>|</span><a href="#42777489">next</a><span>|</span><label class="collapse" for="c-42767659">[-]</label><label class="expand" for="c-42767659">[3 more]</label></div><br/><div class="children"><div class="content">Azure DevOps specifically has a very broken approach to YAML pipelines, because they effectively took their old graphical pipeline builder and just made a YAML representation of it.<p>The trick to working with this is that you <i>don&#x27;t</i> need any of their custom Azure DevOps task types, and can use the shell type (which has a convenient shorthand) just as well as in any other CI environment. Even the installer tasks are redundant - in other CI systems, you either use a container image with what you need, or install stuff at the start, and Azure DevOps works with both of these strategies.<p>So no, it&#x27;s neither hard nor impossible, but Microsoft&#x27;s half-assed approach to maintaining Azure DevOps and overall overcomplicated legacy design makes it a bit hard to realize that doing what their documentation suggests is a bad idea, and that you can use it in a modern way just fine. At least their docs do not recommend that you use the dedicated NPM-type task for `npm install` anymore...<p>(I could rant for ages about Azure DevOps and how broken and unloved it is from Microsoft&#x27;s side. From what I can tell, they&#x27;re just putting in the minimum effort to keep old Enterprise customers that have been there through every rename since Team Foundation Server from jumping ship - maybe just until Github&#x27;s enterprise side has matured enough? Azure DevOps doesn&#x27;t even integrate well with Azure, despite its name!)</div><br/><div id="42776739" class="c"><input type="checkbox" id="c-42776739" checked=""/><div class="controls bullet"><span class="by">noen</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767659">parent</a><span>|</span><a href="#42776155">next</a><span>|</span><label class="collapse" for="c-42776739">[-]</label><label class="expand" for="c-42776739">[1 more]</label></div><br/><div class="children"><div class="content">It has been on life support for a long time AFAIK. I designed Visual Studio Online (the first launch of AzDO) - and every engineer, PM, and executive I worked with is either in leadership at GitHub or retired.</div><br/></div></div><div id="42776155" class="c"><input type="checkbox" id="c-42776155" checked=""/><div class="controls bullet"><span class="by">mplanchard</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42767659">parent</a><span>|</span><a href="#42776739">prev</a><span>|</span><a href="#42777489">next</a><span>|</span><label class="collapse" for="c-42776155">[-]</label><label class="expand" for="c-42776155">[1 more]</label></div><br/><div class="children"><div class="content">This doesn’t seem to address the parent comment’s point at all, which was about required non-shell configuration such as for secrets, build parallelism, etc.</div><br/></div></div></div></div></div></div><div id="42777489" class="c"><input type="checkbox" id="c-42777489" checked=""/><div class="controls bullet"><span class="by">Sparkyte</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42767294">prev</a><span>|</span><a href="#42777321">next</a><span>|</span><label class="collapse" for="c-42777489">[-]</label><label class="expand" for="c-42777489">[1 more]</label></div><br/><div class="children"><div class="content">When I automate my github actions I keep everything task orientated and if anything is pushing code or builds it has user step to verify the work by the automation. You approve and then merge it kicks off promotional pipelines not necessarily for deployment but to promote a build as stable through tagging.</div><br/></div></div><div id="42777321" class="c"><input type="checkbox" id="c-42777321" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42777489">prev</a><span>|</span><a href="#42768310">next</a><span>|</span><label class="collapse" for="c-42777321">[-]</label><label class="expand" for="c-42777321">[1 more]</label></div><br/><div class="children"><div class="content">This is my preferred way of doing things as well. Not being able to run the exact same thing that&#x27;s running in CI easily locally is a bit of a red flag in my opinion. I think the only exception I&#x27;ve ever encountered to this is when working on client software for HSMs, which had some end-to-end tests that couldn&#x27;t be run without actually connecting to the specific hardware that took some setup to be able to access when running tests locally.</div><br/></div></div><div id="42768310" class="c"><input type="checkbox" id="c-42768310" checked=""/><div class="controls bullet"><span class="by">riperoni</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42777321">prev</a><span>|</span><a href="#42775606">next</a><span>|</span><label class="collapse" for="c-42768310">[-]</label><label class="expand" for="c-42768310">[1 more]</label></div><br/><div class="children"><div class="content">I agree with wrapping things like build scripts to test locally.<p>Still, some actions or CI steps are also not meant to be run locally. Like when it publishes to a repo or needs any credentials that are used by more than one person.<p>Btw, Github actions and corresponding YAML are derived from Azure DevOps and are just as cursed.<p>The whole concept of Github CI is just pure misuse of containers when you need huge VM images - container is technically correct, but a far fetched word for this - that have all kinds of preinstalled garbage to run typescript-wrapped code to call shell scripts.</div><br/></div></div><div id="42775606" class="c"><input type="checkbox" id="c-42775606" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42768310">prev</a><span>|</span><a href="#42776618">next</a><span>|</span><label class="collapse" for="c-42775606">[-]</label><label class="expand" for="c-42775606">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Anything else is just asking for trouble.<p>CI must <i>only</i> be an application of tools available to developers locally.<p>This, other than for practical reasons, is a tax on complexity.</div><br/></div></div><div id="42776618" class="c"><input type="checkbox" id="c-42776618" checked=""/><div class="controls bullet"><span class="by">ironfootnz</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42775606">prev</a><span>|</span><a href="#42773299">next</a><span>|</span><label class="collapse" for="c-42776618">[-]</label><label class="expand" for="c-42776618">[1 more]</label></div><br/><div class="children"><div class="content">That’s my policy too. I see way too many Jenkins&#x2F;Actions scripts with big logic blocks jammed into YAML. If the entire build and test process is just a single script call, we can run it locally, in a GitHub workflow, or anywhere else. Makes it less painful to switch CI systems, and devs can debug easily without pushing blind commits. It’s surprising how many teams don’t realize local testing alone saves huge amounts of time.</div><br/></div></div><div id="42773299" class="c"><input type="checkbox" id="c-42773299" checked=""/><div class="controls bullet"><span class="by">InvertedRhodium</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42776618">prev</a><span>|</span><a href="#42776304">next</a><span>|</span><label class="collapse" for="c-42773299">[-]</label><label class="expand" for="c-42773299">[2 more]</label></div><br/><div class="children"><div class="content">I use gitlab-ci-local to run Gitlab pipelines locally - does such a thing not exist for GitHub actions?</div><br/><div id="42774198" class="c"><input type="checkbox" id="c-42774198" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42773299">parent</a><span>|</span><a href="#42776304">next</a><span>|</span><label class="collapse" for="c-42774198">[-]</label><label class="expand" for="c-42774198">[1 more]</label></div><br/><div class="children"><div class="content">Oh, yeah, I remember looking at that a while back. I don&#x27;t recall how much it had implemented at the time but it seems that firecow took a vastly different approach than nektos&#x2F;act did, going so far as to spend what must have been an enormous amount of time&#x2F;energy to cook up <a href="https:&#x2F;&#x2F;github.com&#x2F;firecow&#x2F;gitlab-ci-local&#x2F;blob&#x2F;4.56.2&#x2F;src&#x2F;schema&#x2F;schema.ts">https:&#x2F;&#x2F;github.com&#x2F;firecow&#x2F;gitlab-ci-local&#x2F;blob&#x2F;4.56.2&#x2F;src&#x2F;s...</a> (and, of course, choosing a dynamically typed language versus golang)</div><br/></div></div></div></div><div id="42776304" class="c"><input type="checkbox" id="c-42776304" checked=""/><div class="controls bullet"><span class="by">sirlone</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42773299">prev</a><span>|</span><a href="#42767440">next</a><span>|</span><label class="collapse" for="c-42776304">[-]</label><label class="expand" for="c-42776304">[1 more]</label></div><br/><div class="children"><div class="content">So for example, my action builds on 4 different platforms (win-64, linux-amd64, mac-intel, mac-arm), it does this in parallel then gets the artifacts for all for and bundles them into a single package.<p>How would you suggest I do this following your advice?</div><br/></div></div><div id="42767440" class="c"><input type="checkbox" id="c-42767440" checked=""/><div class="controls bullet"><span class="by">potamic</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42776304">prev</a><span>|</span><a href="#42774461">next</a><span>|</span><label class="collapse" for="c-42767440">[-]</label><label class="expand" for="c-42767440">[1 more]</label></div><br/><div class="children"><div class="content">This is the right way to use CI&#x2F;CD systems, as dumb orchestrators without inherent knowledge of your software stack. But the problem is, everything from their documentation, templates, marketplace encourage you to do exactly the opposite and couple your build tightly with their system. It&#x27;s poor product design imo, clearly optimising for vendor lock-in over usability.</div><br/></div></div><div id="42774461" class="c"><input type="checkbox" id="c-42774461" checked=""/><div class="controls bullet"><span class="by">Norfair</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42767440">prev</a><span>|</span><a href="#42769260">next</a><span>|</span><label class="collapse" for="c-42774461">[-]</label><label class="expand" for="c-42774461">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;nix-ci.com" rel="nofollow">https:&#x2F;&#x2F;nix-ci.com</a> does this by construction.</div><br/></div></div><div id="42769260" class="c"><input type="checkbox" id="c-42769260" checked=""/><div class="controls bullet"><span class="by">nunez</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42774461">prev</a><span>|</span><a href="#42775080">next</a><span>|</span><label class="collapse" for="c-42769260">[-]</label><label class="expand" for="c-42769260">[2 more]</label></div><br/><div class="children"><div class="content">While youre correct, environmental considerations are another advantage that testing locally SHOULD be able to provide (i.e. you can test your scripts or Make targets or whatever in the same runner that runs in the actual build system.)<p>This is not possible with GHA.</div><br/><div id="42769415" class="c"><input type="checkbox" id="c-42769415" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42769260">parent</a><span>|</span><a href="#42775080">next</a><span>|</span><label class="collapse" for="c-42769415">[-]</label><label class="expand" for="c-42769415">[1 more]</label></div><br/><div class="children"><div class="content">Of course you can, just specify a container image of your choice and run the same container for testing locally.<p>However, replicating environmental details is only relevant where the details are known to matter. A lot of effort has been wasted and workflows crippled by the idea that <i>everything</i> must be 100% identical irrespective of actual dependencies and real effects.</div><br/></div></div></div></div><div id="42775080" class="c"><input type="checkbox" id="c-42775080" checked=""/><div class="controls bullet"><span class="by">thatxliner</span><span>|</span><a href="#42766316">parent</a><span>|</span><a href="#42769260">prev</a><span>|</span><a href="#42766768">next</a><span>|</span><label class="collapse" for="c-42775080">[-]</label><label class="expand" for="c-42775080">[2 more]</label></div><br/><div class="children"><div class="content">How would you set up tool installations? Inside the CI or inside the script?</div><br/><div id="42777148" class="c"><input type="checkbox" id="c-42777148" checked=""/><div class="controls bullet"><span class="by">atkbrah</span><span>|</span><a href="#42766316">root</a><span>|</span><a href="#42775080">parent</a><span>|</span><a href="#42766768">next</a><span>|</span><label class="collapse" for="c-42777148">[-]</label><label class="expand" for="c-42777148">[1 more]</label></div><br/><div class="children"><div class="content">In our environment (our product is a windows desktop application) we use packer to build a custom windows server 2022 image with all the required tools installed. Build agents run on a azure vm scale set that uses the said image for the instance os.</div><br/></div></div></div></div></div></div><div id="42766768" class="c"><input type="checkbox" id="c-42766768" checked=""/><div class="controls bullet"><span class="by">benrutter</span><span>|</span><a href="#42766316">prev</a><span>|</span><a href="#42773841">next</a><span>|</span><label class="collapse" for="c-42766768">[-]</label><label class="expand" for="c-42766768">[13 more]</label></div><br/><div class="children"><div class="content">Oh boy, there&#x27;s a special kind of hell I enter into everytime I set up new github actions. I wrote a blog post a few months ago about my pain[0] but one of the main things I&#x27;ve found over the years is you can massively reduce how horrible writing github actions is by <i>avoiding</i> prebuilt actions, and just using it as a handy shell runner.<p>If you write behaviour in python&#x2F;ruby&#x2F;bash&#x2F;hell-rust-if-you-really-want and leave your github action at `run: python some&#x2F;script.py` then you&#x27;ll have something that&#x27;s <i>much</i> easy to test locally, and save yourself a lot of pain, even if you wind up with slightly more boilerplate.<p>[0] <a href="https:&#x2F;&#x2F;benrutter.github.io&#x2F;posts&#x2F;github-actions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;benrutter.github.io&#x2F;posts&#x2F;github-actions&#x2F;</a></div><br/><div id="42768240" class="c"><input type="checkbox" id="c-42768240" checked=""/><div class="controls bullet"><span class="by">riperoni</span><span>|</span><a href="#42766768">parent</a><span>|</span><a href="#42776377">next</a><span>|</span><label class="collapse" for="c-42768240">[-]</label><label class="expand" for="c-42768240">[10 more]</label></div><br/><div class="children"><div class="content">At this point, just pause with Github Actions and compare it to how GiLab handles CI.<p>Much more intuitive, taking shell scripts and other script commands natively and not devolving into a mess of obfuscated typescript wrapped actions that need a shit ton of dependencies.</div><br/><div id="42773713" class="c"><input type="checkbox" id="c-42773713" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#42766768">root</a><span>|</span><a href="#42768240">parent</a><span>|</span><a href="#42770277">next</a><span>|</span><label class="collapse" for="c-42773713">[-]</label><label class="expand" for="c-42773713">[6 more]</label></div><br/><div class="children"><div class="content">The problem with Gitlab CI is that now you need to use Gitlab.<p>I’m not even sure when I started feeling like that was a bad thing. Probably when they started glueing a bunch of badly executed security crud onto the main product.</div><br/><div id="42774917" class="c"><input type="checkbox" id="c-42774917" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42766768">root</a><span>|</span><a href="#42773713">parent</a><span>|</span><a href="#42773978">next</a><span>|</span><label class="collapse" for="c-42774917">[-]</label><label class="expand" for="c-42774917">[1 more]</label></div><br/><div class="children"><div class="content">The earliest warning sign I had for GitLab was when they eliminated any pricing tier below their equivalent of GitHub&#x27;s Enterprise tier.<p>That day, they very effectively communicated that they had decided they were only interested in serving Enterprises, and everything about their product has predictably degraded ever since, to the point where now they&#x27;re now branding themselves &quot;the most comprehensive AI-powered DevSecOps Platform&quot; with a straight face.</div><br/></div></div><div id="42773978" class="c"><input type="checkbox" id="c-42773978" checked=""/><div class="controls bullet"><span class="by">Espressosaurus</span><span>|</span><a href="#42766768">root</a><span>|</span><a href="#42773713">parent</a><span>|</span><a href="#42774917">prev</a><span>|</span><a href="#42774162">next</a><span>|</span><label class="collapse" for="c-42773978">[-]</label><label class="expand" for="c-42773978">[1 more]</label></div><br/><div class="children"><div class="content">GitLab can&#x27;t even show you more than a few lines of context without requiring you to manually click a bunch of times. Forget the CI functionality, for pull requests it&#x27;s absolutely awful.</div><br/></div></div><div id="42774162" class="c"><input type="checkbox" id="c-42774162" checked=""/><div class="controls bullet"><span class="by">plagiarist</span><span>|</span><a href="#42766768">root</a><span>|</span><a href="#42773713">parent</a><span>|</span><a href="#42773978">prev</a><span>|</span><a href="#42770277">next</a><span>|</span><label class="collapse" for="c-42774162">[-]</label><label class="expand" for="c-42774162">[3 more]</label></div><br/><div class="children"><div class="content">I decided it was a bad thing when they sent password reset emails to addresses given by unauthenticated users. Not that I ever used them. But now it is a hard no, permanently.<p>They have since had other also severe CVEs. That has made me feel pretty confident in my decision.</div><br/><div id="42777760" class="c"><input type="checkbox" id="c-42777760" checked=""/><div class="controls bullet"><span class="by">reshlo</span><span>|</span><a href="#42766768">root</a><span>|</span><a href="#42774162">parent</a><span>|</span><a href="#42770277">next</a><span>|</span><label class="collapse" for="c-42777760">[-]</label><label class="expand" for="c-42777760">[2 more]</label></div><br/><div class="children"><div class="content">If password reset emails shouldn’t be sent to unauthenticated users, how would users reset their passwords?</div><br/><div id="42777832" class="c"><input type="checkbox" id="c-42777832" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42766768">root</a><span>|</span><a href="#42777760">parent</a><span>|</span><a href="#42770277">next</a><span>|</span><label class="collapse" for="c-42777832">[-]</label><label class="expand" for="c-42777832">[1 more]</label></div><br/><div class="children"><div class="content">there was a pretty bad bug (though I think it was a rails footgun)- that allowed you to append an arbitrary email to the reset request.<p>The only difficult part for the attacker was finding an email address that was used by the target; though thats hsually the same as you use for git commits; and gitlab “handily” has an email address assigned to each user-id incrementing from 1;<p>Usually low numbers are admins, so, a pretty big attack vector when combined.</div><br/></div></div></div></div></div></div></div></div><div id="42770277" class="c"><input type="checkbox" id="c-42770277" checked=""/><div class="controls bullet"><span class="by">danillonunes</span><span>|</span><a href="#42766768">root</a><span>|</span><a href="#42768240">parent</a><span>|</span><a href="#42773713">prev</a><span>|</span><a href="#42773158">next</a><span>|</span><label class="collapse" for="c-42770277">[-]</label><label class="expand" for="c-42770277">[2 more]</label></div><br/><div class="children"><div class="content">But you can do the same with GitHub, right? Although most docs and articles focus on 3rd party actions, nothing stops you to just run everything in your own shell script.</div><br/><div id="42773537" class="c"><input type="checkbox" id="c-42773537" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42766768">root</a><span>|</span><a href="#42770277">parent</a><span>|</span><a href="#42773158">next</a><span>|</span><label class="collapse" for="c-42773537">[-]</label><label class="expand" for="c-42773537">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you can, and we do at my current job. Much of the time it&#x27;s not even really the harder approach compared to using someone else&#x27;s action, it&#x27;s just that the existence of third party actions makes people feel obliged to use them because they wouldn&#x27;t want to be accused of Not Invented Here Syndrome.</div><br/></div></div></div></div><div id="42773158" class="c"><input type="checkbox" id="c-42773158" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42766768">root</a><span>|</span><a href="#42768240">parent</a><span>|</span><a href="#42770277">prev</a><span>|</span><a href="#42776377">next</a><span>|</span><label class="collapse" for="c-42773158">[-]</label><label class="expand" for="c-42773158">[1 more]</label></div><br/><div class="children"><div class="content">if anything, gitlab&#x27;s ci seems even worse...</div><br/></div></div></div></div><div id="42776377" class="c"><input type="checkbox" id="c-42776377" checked=""/><div class="controls bullet"><span class="by">jbaber</span><span>|</span><a href="#42766768">parent</a><span>|</span><a href="#42768240">prev</a><span>|</span><a href="#42766808">next</a><span>|</span><label class="collapse" for="c-42776377">[-]</label><label class="expand" for="c-42776377">[1 more]</label></div><br/><div class="children"><div class="content">I had this idea the other day when dealing with CI and thought it must be dumb because everyone&#x27;s not already doing it.  It would make your CI portable to other runners in future, too.</div><br/></div></div><div id="42766808" class="c"><input type="checkbox" id="c-42766808" checked=""/><div class="controls bullet"><span class="by">Imustaskforhelp</span><span>|</span><a href="#42766768">parent</a><span>|</span><a href="#42776377">prev</a><span>|</span><a href="#42773841">next</a><span>|</span><label class="collapse" for="c-42766808">[-]</label><label class="expand" for="c-42766808">[1 more]</label></div><br/><div class="children"><div class="content">theoretically we could also use <a href="https:&#x2F;&#x2F;just.systems&#x2F;" rel="nofollow">https:&#x2F;&#x2F;just.systems&#x2F;</a> or <a href="https:&#x2F;&#x2F;mise.jdx.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mise.jdx.dev&#x2F;</a> instead of directly calling gh actions but I haven&#x27;t tried gh actions personally yet , If its really the nightmare you are saying , then that&#x27;s sad.</div><br/></div></div></div></div><div id="42773841" class="c"><input type="checkbox" id="c-42773841" checked=""/><div class="controls bullet"><span class="by">spooneybarger</span><span>|</span><a href="#42766768">prev</a><span>|</span><a href="#42773924">next</a><span>|</span><label class="collapse" for="c-42773841">[-]</label><label class="expand" for="c-42773841">[2 more]</label></div><br/><div class="children"><div class="content">A lot of folks in this thread are focusing on the monorepo aspect of things. The &quot;Pull request and required checks&quot; problem exists regardless of monorepo or not.<p>GitHub Actions allows you to only run checks if certain conditions are met, like &quot;only lint markdown if the PR contains *.md files&quot;. The moment you decide to use such rules, you have the &quot;Pull request and required checks&quot; problem. No &quot;monorepo&quot; required.<p>GitHub required checks at this time allow you to use with external services where GitHub has no idea what might run. For this reason, required checks HAVE to pass. There&#x27;s no &quot;if it runs&quot; step. A required check on an external service might never run, or it might be delayed. Therefore, if GH doesn&#x27;t have an affirmation that it passed, you can&#x27;t merge.<p>It would be wonderful if for jobs that run on GH where GH can know if the action is supposed to run, if required checks could be &quot;require all these checks if they will be triggered&quot;.<p>I have encountered this problem on every non-trivial project I use with GitHub actions; monorepo or not.</div><br/><div id="42775325" class="c"><input type="checkbox" id="c-42775325" checked=""/><div class="controls bullet"><span class="by">saxonww</span><span>|</span><a href="#42773841">parent</a><span>|</span><a href="#42773924">next</a><span>|</span><label class="collapse" for="c-42775325">[-]</label><label class="expand" for="c-42775325">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t really the problem, though. This is an easy problem to solve; the real problem is that it costs money to do so.<p>Also: I&#x27;m not asserting that the below is good, just that it works.<p>First, don&#x27;t make every check a required check. You probably don&#x27;t need to require that linting of your markdown files passes (maybe you do! it&#x27;s an example).<p>Second, consider not using the `on:&lt;event&gt;:paths`, but instead something like `dorny&#x2F;paths-filter`. Your workflow now runs every time; a no-op takes substantially less than 1 minute unless you have a gargantuan repo.<p>Third, make all of your workflows have a &#x27;success&#x27; job that just runs and succeeds. Again, this will take less than 1 minute.<p>At this point, a no-op is still likely taking less than 1 minute, so it will bill at 1 minute, which is going to be $.008 if you&#x27;re paying.<p>Fourth, you can use `needs` and `if` now to control when your &#x27;success&#x27; job runs. Yes, managing the `if` can be tricky, but it does work.<p>We are in the middle of a very large migration into GitHub Actions from a self-hosted GitLab. It was something we chose, but also due to some corporate choices our options were essentially GitHub Actions or a massive rethink of CI for several dozen projects. We have already moved into code generation for some aspects of GitHub Actions code, and that&#x27;s the fifth and perhaps final frontier for addressing this situation. Figure out how to describe a graph and associated completion requirements for your workflow(s), and write something to translate that into the `if` statements for your &#x27;success&#x27; jobs.</div><br/></div></div></div></div><div id="42773924" class="c"><input type="checkbox" id="c-42773924" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#42773841">prev</a><span>|</span><a href="#42777793">next</a><span>|</span><label class="collapse" for="c-42773924">[-]</label><label class="expand" for="c-42773924">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a workaround for the &#x27;pull request and required check&#x27; issue.
You create an alternative &#x27;no op&#x27; version of each required check workflow that just does nothing and exits with code 0 with the inverse of the trigger for the &quot;real&quot; one.<p>The required check configuration on github is just based off of job name, so either the trigger condition is true, and the real one has to succeed or the trigger condition is false and the no op one satisfies the PR completion rules instead.<p>It seems crazy to me that such basic functionality needs such a hacky workaround, but there it is.</div><br/></div></div><div id="42777793" class="c"><input type="checkbox" id="c-42777793" checked=""/><div class="controls bullet"><span class="by">aswerty</span><span>|</span><a href="#42773924">prev</a><span>|</span><a href="#42769233">next</a><span>|</span><label class="collapse" for="c-42777793">[-]</label><label class="expand" for="c-42777793">[1 more]</label></div><br/><div class="children"><div class="content">I once used Team City and Octopus Deploy in a company. And ever since then, dealing with Gitlab Pipelines and Github Actions, I find them so much poorer as a toolkit.<p>We are very much in the part of the platform cycle where best-in-breed is losing out to all-in-one. Hopefully we see things swing in the other direction in the next few years where composable best-in-breed solutions recapture the hearts and minds of the community.</div><br/></div></div><div id="42769233" class="c"><input type="checkbox" id="c-42769233" checked=""/><div class="controls bullet"><span class="by">nunez</span><span>|</span><a href="#42777793">prev</a><span>|</span><a href="#42775284">next</a><span>|</span><label class="collapse" for="c-42769233">[-]</label><label class="expand" for="c-42769233">[3 more]</label></div><br/><div class="children"><div class="content">Posts like this make me miss Travis. Travis CI was incredible, especially for testing CI locally. (I agree with the author that act is a well done hack. I&#x27;ve stopped using it because of how often I&#x27;d have something pass in act and fail in GHA.)<p>&gt; GitHub doesn&#x27;t care<p>My take: GitHub only built Actions to compete against GitLab CI, as built-in CI was taking large chunks of market share from them in the enterprise.</div><br/><div id="42777337" class="c"><input type="checkbox" id="c-42777337" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#42769233">parent</a><span>|</span><a href="#42773063">next</a><span>|</span><label class="collapse" for="c-42777337">[-]</label><label class="expand" for="c-42777337">[1 more]</label></div><br/><div class="children"><div class="content">How so?  I don’t recall this, and I used Travis, and then migrated to GitHub actions.<p>As far as I can tell, they are identical as far as testing locally.  If you want to test locally, then put as much logic in shell scripts as possible, decoupled from the CI.</div><br/></div></div><div id="42773063" class="c"><input type="checkbox" id="c-42773063" checked=""/><div class="controls bullet"><span class="by">sureIy</span><span>|</span><a href="#42769233">parent</a><span>|</span><a href="#42777337">prev</a><span>|</span><a href="#42775284">next</a><span>|</span><label class="collapse" for="c-42773063">[-]</label><label class="expand" for="c-42773063">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, GitHub also charges for Actions minutes and storage, so it&#x27;s one of the few pieces that do generate revenue.</div><br/></div></div></div></div><div id="42775284" class="c"><input type="checkbox" id="c-42775284" checked=""/><div class="controls bullet"><span class="by">ripped_britches</span><span>|</span><a href="#42769233">prev</a><span>|</span><a href="#42774090">next</a><span>|</span><label class="collapse" for="c-42775284">[-]</label><label class="expand" for="c-42775284">[3 more]</label></div><br/><div class="children"><div class="content">My man&#x2F;woman - you gotta try buildkite. It’s a bit more extra setup since you have to interface with another company, more API keys, etc. But when you outgrow GH actions, this is the way. Have used buildkite in my last two jobs (big US tech companies) and it has been the only pleasant part of CI.</div><br/><div id="42776773" class="c"><input type="checkbox" id="c-42776773" checked=""/><div class="controls bullet"><span class="by">habosa</span><span>|</span><a href="#42775284">parent</a><span>|</span><a href="#42777310">next</a><span>|</span><label class="collapse" for="c-42776773">[-]</label><label class="expand" for="c-42776773">[1 more]</label></div><br/><div class="children"><div class="content">+1<p>I&#x27;ve use Jenkins, Travis, Circle, Cirrus, GitHub Actions, and Buildkite. Buildkite is leagues ahead of all of the others. It&#x27;s the only enjoyable CI system I&#x27;ve used.</div><br/></div></div><div id="42777310" class="c"><input type="checkbox" id="c-42777310" checked=""/><div class="controls bullet"><span class="by">cjk</span><span>|</span><a href="#42775284">parent</a><span>|</span><a href="#42776773">prev</a><span>|</span><a href="#42774090">next</a><span>|</span><label class="collapse" for="c-42777310">[-]</label><label class="expand" for="c-42777310">[1 more]</label></div><br/><div class="children"><div class="content">This is indeed the way.</div><br/></div></div></div></div><div id="42774090" class="c"><input type="checkbox" id="c-42774090" checked=""/><div class="controls bullet"><span class="by">ryanisnan</span><span>|</span><a href="#42775284">prev</a><span>|</span><a href="#42777684">next</a><span>|</span><label class="collapse" for="c-42774090">[-]</label><label class="expand" for="c-42774090">[5 more]</label></div><br/><div class="children"><div class="content">One really interesting omission to this post is how the architecture of GitHub actions encourages (or at the very least makes deceivingly easy) making bad security decisions.<p>Common examples are secrets. Organization or repository secrets are very convenient, but they are also massive security holes just waiting for unsuspecting victims to fall into.<p>Repository environments have the ability to have distinct secrets, but you have to ensure that the right workflows can only access the right environments. It&#x27;s a real pain to manage at scale.<p>Being able to `inherit` secrets also is a massive footgun, just waiting to leak credentials to a shared action. Search for and leak `AWS_ACCESS_KEY_ID` anyone?<p>Cross-repository workflow triggering is also a disaster, and in some circumstances you can abuse the differences in configuration to do things the source repository didn&#x27;t intend.<p>Other misc. things about GHA also are cool in theory, but fall down in practice. One example is the wait-timer concept of environments. If you have a multi-job workflow using the same environment, wait-timer applies to EACH JOB in the environment. So if you have a build-and-test workflow with 2 jobs, one for build, and one for test, each step will wait `wait-timer` before it executes. This makes things like multi-environment deployment pipelines impossible to use this feature, unless you refactor your workflows.<p>Overall, I&#x27;d recommend against using GHA and looking elsewhere.</div><br/><div id="42776429" class="c"><input type="checkbox" id="c-42776429" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#42774090">parent</a><span>|</span><a href="#42774360">next</a><span>|</span><label class="collapse" for="c-42776429">[-]</label><label class="expand" for="c-42776429">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Search for and leak `AWS_ACCESS_KEY_ID` anyone?<p>Well that&#x27;s just someone being a dumbass, since AssumeRoleWithWebIdentity (and its Azure and GCP equivalent) have existed for quite a while. It works flawlessly and if someone <i>does</i> do something stupid like `export HURP_DURP=$AWS_ACCESS_KEY_ID; printenv` in a log, that key is only live for about 15 minutes so the attacker better hurry<p>Further, at least in AWS and GCP (I haven&#x27;t tried such a thing in Azure) on can also guard the cred with &quot;if the organization and repo are not ...&quot; then the AssumeRole 403s to ensure that my-awesome-org&#x2F;junior-dev-test-repo doesn&#x27;t up and start doing fun prod stuff in GHA<p>I hate GHA probably more than most, but one can footgun themselves in any setup</div><br/></div></div><div id="42774360" class="c"><input type="checkbox" id="c-42774360" checked=""/><div class="controls bullet"><span class="by">junto</span><span>|</span><a href="#42774090">parent</a><span>|</span><a href="#42776429">prev</a><span>|</span><a href="#42775189">next</a><span>|</span><label class="collapse" for="c-42774360">[-]</label><label class="expand" for="c-42774360">[1 more]</label></div><br/><div class="children"><div class="content">Whilst I do detest much of Azure DevOps, one thing I do like about their pipelines is that we can securely use service connections and key vaults in Azure to secure pipeline tasks that require credentials to be managed securely.</div><br/></div></div><div id="42775189" class="c"><input type="checkbox" id="c-42775189" checked=""/><div class="controls bullet"><span class="by">wrboyce</span><span>|</span><a href="#42774090">parent</a><span>|</span><a href="#42774360">prev</a><span>|</span><a href="#42774475">next</a><span>|</span><label class="collapse" for="c-42775189">[-]</label><label class="expand" for="c-42775189">[1 more]</label></div><br/><div class="children"><div class="content">While I do agree with you regarding encouraging bad secret management practices, one fairly nice solution I’ve landed on is using terraform to manage such things. I guess you could even take it a step further to have a custom lint step (running on GHA, naturally) that disallows secrets configured in a certain manner and blocks a deploy (again, on GHA) on failure.<p>I guess what I’m saying is, it’s GHA all the way down.</div><br/></div></div><div id="42774475" class="c"><input type="checkbox" id="c-42774475" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#42774090">parent</a><span>|</span><a href="#42775189">prev</a><span>|</span><a href="#42777684">next</a><span>|</span><label class="collapse" for="c-42774475">[-]</label><label class="expand" for="c-42774475">[1 more]</label></div><br/><div class="children"><div class="content">What’s your suggestion for not-GHA?</div><br/></div></div></div></div><div id="42777684" class="c"><input type="checkbox" id="c-42777684" checked=""/><div class="controls bullet"><span class="by">robertritz</span><span>|</span><a href="#42774090">prev</a><span>|</span><a href="#42765911">next</a><span>|</span><label class="collapse" for="c-42777684">[-]</label><label class="expand" for="c-42777684">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s simple. Don&#x27;t believe that the company purchased by Microsoft wants anything other than for you to use more compute.</div><br/></div></div><div id="42765911" class="c"><input type="checkbox" id="c-42765911" checked=""/><div class="controls bullet"><span class="by">bramblerose</span><span>|</span><a href="#42777684">prev</a><span>|</span><a href="#42776607">next</a><span>|</span><label class="collapse" for="c-42765911">[-]</label><label class="expand" for="c-42765911">[8 more]</label></div><br/><div class="children"><div class="content">In the end, this is the age old &quot;I built by thing on top of a 3rd party platform, it doesn&#x27;t quite match my use case (anymore) and now I&#x27;m stuck&quot;.<p>Would GitLab have been better? Maybe. But chances are that there is another edge case that is not handled well there. You&#x27;re in a PaaS world, don&#x27;t expect the platform to adjust to your workflow; adjust your workflow to the platform.<p>You could of course choose to &quot;step down&quot; (PaaS to IaaS) by just having a &quot;ci&quot; script in your repo that is called by GA&#x2F;other CI tooling. That gives you immense flexibility but also you lose specific features (e.g. pipeline display).</div><br/><div id="42774312" class="c"><input type="checkbox" id="c-42774312" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42765911">parent</a><span>|</span><a href="#42766351">next</a><span>|</span><label class="collapse" for="c-42774312">[-]</label><label class="expand" for="c-42774312">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that your &quot;ci&quot; script often needs some information from the host system, like what is the target git commit? Is this triggered by a pull request, or a push to a branch? Is it triggered by a release? And if so, what is the version of the release?<p>IME, much of the complexity in using Github Actions (or Gitlab CI, or Travis) is around communicating that information to scripts or build tools.<p>That and running different tasks in parallel, and making sure everything you want passes.</div><br/></div></div><div id="42766351" class="c"><input type="checkbox" id="c-42766351" checked=""/><div class="controls bullet"><span class="by">perlgeek</span><span>|</span><a href="#42765911">parent</a><span>|</span><a href="#42774312">prev</a><span>|</span><a href="#42766878">next</a><span>|</span><label class="collapse" for="c-42766351">[-]</label><label class="expand" for="c-42766351">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Would GitLab have been better?<p>My impression of gitlab CI is that it&#x27;s also not built for monorepos.<p>(I&#x27;m a casual gitlab CI user).</div><br/><div id="42766714" class="c"><input type="checkbox" id="c-42766714" checked=""/><div class="controls bullet"><span class="by">dezgeg</span><span>|</span><a href="#42765911">root</a><span>|</span><a href="#42766351">parent</a><span>|</span><a href="#42766878">next</a><span>|</span><label class="collapse" for="c-42766714">[-]</label><label class="expand" for="c-42766714">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if there&#x27;s a monorepo vs polyrepo difference; just that anything complex is pretty painful in gitlab. YAML &quot;programming&quot; just doesn&#x27;t scale.</div><br/></div></div></div></div><div id="42766878" class="c"><input type="checkbox" id="c-42766878" checked=""/><div class="controls bullet"><span class="by">Hamuko</span><span>|</span><a href="#42765911">parent</a><span>|</span><a href="#42766351">prev</a><span>|</span><a href="#42776607">next</a><span>|</span><label class="collapse" for="c-42766878">[-]</label><label class="expand" for="c-42766878">[4 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t everything in GitLab go into a single pipeline? GitHub at least makes splitting massive CI&#x2F;CD setups easier by allowing you to write them as separate workflows that are separate files.</div><br/><div id="42767269" class="c"><input type="checkbox" id="c-42767269" checked=""/><div class="controls bullet"><span class="by">dijksterhuis</span><span>|</span><a href="#42765911">root</a><span>|</span><a href="#42766878">parent</a><span>|</span><a href="#42766964">next</a><span>|</span><label class="collapse" for="c-42767269">[-]</label><label class="expand" for="c-42767269">[2 more]</label></div><br/><div class="children"><div class="content">&gt; GitHub at least makes splitting massive CI&#x2F;CD setups easier by allowing you to write them as separate workflows that are separate files.<p>this makes me feel like you’re really asking “can i split up my gitlab CICD yaml file or does everything need to be in one file”.<p>if that’s the case:<p>yes it does eventually all end up in a single pipeline (ignoring child pipelines).<p>but you can split everything up and then use the `include` statement to pull it all together in one main pipeline file which makes dealing with massive amounts of yaml much easier.<p><a href="https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;ci&#x2F;yaml&#x2F;includes.html" rel="nofollow">https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;ci&#x2F;yaml&#x2F;includes.html</a><p>you can also use `include` to pull in a yaml config from another project to add things like SAST on the fly.<p>previous workplace i had like 4 CICD template repos and constructed all 30 odd actual build repos from those four templates.<p>used `include` to pull in some yaml template jobs, which i made run when by doing something like (it’s been a while, might get this wrong)<p><pre><code>    include:
      project: &#x27;cicd&#x2F;templates&#x27;
      file: &#x27;builds.yml&#x27;


    stages:
      - build

    job_a:
      stage: build
      extends: .job_a_from_template
      variables:
        IMAGE_NAME: &quot;myimage&quot;
        IMAGE_REPO: &quot;somerepo.org&quot;

</code></pre>
this doesn’t run anything for `job_b_from_template` … you just end up defining the things you want to run for each case, plus any variables you need to provide &#x2F; override.<p>you can also override stuff like rules on when it should run if you want to. which is handy.<p>gitlab CICD can be really modular when you get into it.<p>if that wasn’t the case: on me.<p>edit: switched to some yaml instead of text which may or may not be wrong. dunno. i have yet to drink coffee.</div><br/><div id="42768576" class="c"><input type="checkbox" id="c-42768576" checked=""/><div class="controls bullet"><span class="by">dijksterhuis</span><span>|</span><a href="#42765911">root</a><span>|</span><a href="#42767269">parent</a><span>|</span><a href="#42766964">next</a><span>|</span><label class="collapse" for="c-42768576">[-]</label><label class="expand" for="c-42768576">[1 more]</label></div><br/><div class="children"><div class="content">addendum you can also do something like this, which means you don’t have to redefine every job in your main ci file, just define <i>the ones you don’t want to run</i><p><pre><code>    include:
      project: &#x27;cicd&#x2F;templates&#x27;
      file: &#x27;builds.yml&#x27;

    variables:
      IMAGE_NAME: something
      IMAGE_REPO: some.org

    job_b:
      rules:
        - when: never
</code></pre>
where the template you import has a job_a and job_b definition. both get pulled in, but job_b gets overwritten so it never runs.<p>less useful when just splitting things into multiple files to make life simpler.<p>super useful when using the same templates across multiple independent repositories to make everything build in as close to the same way as possible.</div><br/></div></div></div></div><div id="42766964" class="c"><input type="checkbox" id="c-42766964" checked=""/><div class="controls bullet"><span class="by">dezgeg</span><span>|</span><a href="#42765911">root</a><span>|</span><a href="#42766878">parent</a><span>|</span><a href="#42767269">prev</a><span>|</span><a href="#42776607">next</a><span>|</span><label class="collapse" for="c-42766964">[-]</label><label class="expand" for="c-42766964">[1 more]</label></div><br/><div class="children"><div class="content">You can have pipelines trigger child pipelines in gitlab, but usability of them is pretty bad, viewing logs&#x2F;results of those always needs extra clicking.</div><br/></div></div></div></div></div></div><div id="42776607" class="c"><input type="checkbox" id="c-42776607" checked=""/><div class="controls bullet"><span class="by">ironfootnz</span><span>|</span><a href="#42765911">prev</a><span>|</span><a href="#42774204">next</a><span>|</span><label class="collapse" for="c-42776607">[-]</label><label class="expand" for="c-42776607">[1 more]</label></div><br/><div class="children"><div class="content">I’ve seen many teams get stuck when they rely too heavily on GitHub Actions’ magic. The key issue is how tightly your build logic and config become tied to one CI tool. If the declarative YAML gets too big and tries to handle complex branching or monorepos, it devolves into a maintenance headache—especially when you can’t test it locally and must push blind changes just to see what happens.<p>A healthier workflow is to keep all the logic (build, test, deploy) in portable scripts and let the CI only orchestrate each script as a single step. It’s easier to troubleshoot, possible to run everything on a dev machine, and simpler if you ever migrate away from GitHub.<p>For monorepos, required checks are maddening. This should be a first-class feature where CI can dynamically mark which checks apply on a PR, then require only those. Otherwise, you do hacky “no-op” jobs or you force your entire pipeline to run every time.<p>In short, GitHub Actions can be powerful for smaller codebases or straightforward pipelines, but if your repo is big and you want advanced control, it starts to feel like you’re fighting the tool. If there’s no sign that GitHub wants to address these issues, it’s totally reasonable to look elsewhere or build your own thin orchestration on top of more flexible CI runners.</div><br/></div></div><div id="42774204" class="c"><input type="checkbox" id="c-42774204" checked=""/><div class="controls bullet"><span class="by">posix86</span><span>|</span><a href="#42776607">prev</a><span>|</span><a href="#42767423">next</a><span>|</span><label class="collapse" for="c-42774204">[-]</label><label class="expand" for="c-42774204">[3 more]</label></div><br/><div class="children"><div class="content">One thing that sounds very nice about Github are merge queues: Once your PR is ready, rather than merging, you submit it to the merge queue, which will rebase it on the last PR also on the merge queue. It then runs the CI on each PR, and finally merges them automatically once successful. If CI fails, doesn&#x27;t get merged, and the next PR skips yours on the chain.<p>Still a lot of computation &amp; some wait time, but you can just click &amp; forget. You can also parallelize it; since branches are rebased on each other, you can run CI in advance and, assuming your predecessor is also successful, reuse the result from yours.<p>Only available for enterprise orgs though.</div><br/><div id="42775002" class="c"><input type="checkbox" id="c-42775002" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#42774204">parent</a><span>|</span><a href="#42774320">next</a><span>|</span><label class="collapse" for="c-42775002">[-]</label><label class="expand" for="c-42775002">[1 more]</label></div><br/><div class="children"><div class="content">There is room for improvement: <a href="https:&#x2F;&#x2F;matklad.github.io&#x2F;2023&#x2F;06&#x2F;18&#x2F;GitHub-merge-queue.html" rel="nofollow">https:&#x2F;&#x2F;matklad.github.io&#x2F;2023&#x2F;06&#x2F;18&#x2F;GitHub-merge-queue.html</a></div><br/></div></div><div id="42774320" class="c"><input type="checkbox" id="c-42774320" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42774204">parent</a><span>|</span><a href="#42775002">prev</a><span>|</span><a href="#42767423">next</a><span>|</span><label class="collapse" for="c-42774320">[-]</label><label class="expand" for="c-42774320">[1 more]</label></div><br/><div class="children"><div class="content">That sounds roughly like what happens for Rust. I write a Rust PR, somebody reviews it, they have feedback, I modify the PR, they&#x27;re happy, and it passes to bors (originally: <a href="https:&#x2F;&#x2F;github.com&#x2F;graydon&#x2F;bors">https:&#x2F;&#x2F;github.com&#x2F;graydon&#x2F;bors</a>) which then tries to see whether this can be merged with Rust and if so does so.<p>It is nice to know that if humans thought your change is OK, you&#x27;re done. I&#x27;ve only committed small changes (compiler diagnostics, documentation) nothing huge, so perhaps if you really get up in it that&#x27;s more work, but it was definitely a pleasant experience.<p>... and sure enough it turns out that work on one of the bors successors was in fact discontinued because you should just use this GitHub feature. TIL.</div><br/></div></div></div></div><div id="42767423" class="c"><input type="checkbox" id="c-42767423" checked=""/><div class="controls bullet"><span class="by">bhaney</span><span>|</span><a href="#42774204">prev</a><span>|</span><a href="#42773357">next</a><span>|</span><label class="collapse" for="c-42767423">[-]</label><label class="expand" for="c-42767423">[3 more]</label></div><br/><div class="children"><div class="content">Article title: &quot;[Common thing] doesn&#x27;t work very well!&quot;<p>Article body: &quot;So we use a monorepo and-&quot;<p>Tale as old as time</div><br/><div id="42773267" class="c"><input type="checkbox" id="c-42773267" checked=""/><div class="controls bullet"><span class="by">rasso</span><span>|</span><a href="#42767423">parent</a><span>|</span><a href="#42774612">next</a><span>|</span><label class="collapse" for="c-42773267">[-]</label><label class="expand" for="c-42773267">[1 more]</label></div><br/><div class="children"><div class="content">I‘m also struggling with gh actions. And none of my repos is a monorepo.</div><br/></div></div></div></div><div id="42773357" class="c"><input type="checkbox" id="c-42773357" checked=""/><div class="controls bullet"><span class="by">zxor</span><span>|</span><a href="#42767423">prev</a><span>|</span><a href="#42773528">next</a><span>|</span><label class="collapse" for="c-42773357">[-]</label><label class="expand" for="c-42773357">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The problem is that this step will only run when I change something in the web-app1 folder. So if my pull request only made changes in api1 I will never be able to merge my pull request!<p>This just seems like a bad implementation to me?<p>There are definitely ways to set up your actions so that they run all of the unit tests without changes if you&#x27;d like, or so that api1&#x27;s unit tests are not required for a web-app1 related PR to be merged.</div><br/><div id="42773801" class="c"><input type="checkbox" id="c-42773801" checked=""/><div class="controls bullet"><span class="by">hightrix</span><span>|</span><a href="#42773357">parent</a><span>|</span><a href="#42773528">next</a><span>|</span><label class="collapse" for="c-42773801">[-]</label><label class="expand" for="c-42773801">[2 more]</label></div><br/><div class="children"><div class="content">Absolutely correct.  When creating a new workflow, I always disable push&#x2F;pull_request triggered builds and instead use the manually triggered `workflow_dispatch` method.  This makes testing a new workflow much easier.<p>Additionally, you can use conditionals based on inputs in the `workflow_dispatch` meaning that you could easily setup a &quot;skip api tests&quot; or &quot;include web tests&quot; option.</div><br/><div id="42775117" class="c"><input type="checkbox" id="c-42775117" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#42773357">root</a><span>|</span><a href="#42773801">parent</a><span>|</span><a href="#42773528">next</a><span>|</span><label class="collapse" for="c-42775117">[-]</label><label class="expand" for="c-42775117">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like they have the logic to skip certain things if nothing has changed. The problem is around pull request gates and the lack of dynamic &quot;these tests must be passing before merging is allowed&quot;. There are setting on a repository in the ruleset &#x2F; status checks area that are configured outside of the dynamic yaml of the GHA workflow</div><br/></div></div></div></div></div></div><div id="42773528" class="c"><input type="checkbox" id="c-42773528" checked=""/><div class="controls bullet"><span class="by">SamuelAdams</span><span>|</span><a href="#42773357">prev</a><span>|</span><a href="#42766310">next</a><span>|</span><label class="collapse" for="c-42773528">[-]</label><label class="expand" for="c-42773528">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Our code sits in a monorepo which is further divided into folders. Every folder is independent of each other and can be tested, built, and deployed separately.<p>If this is true, and you still have problems running specific  Actions, why not break this into separate repositories?</div><br/><div id="42775070" class="c"><input type="checkbox" id="c-42775070" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#42773528">parent</a><span>|</span><a href="#42774753">next</a><span>|</span><label class="collapse" for="c-42775070">[-]</label><label class="expand" for="c-42775070">[1 more]</label></div><br/><div class="children"><div class="content">There is a mono vs poly repo tradeoff. Pros &amp; cons to each approach. If you are doing monorepo, it would be antithetical to break it up into the poly paradigm. You really don&#x27;t want both</div><br/></div></div><div id="42774753" class="c"><input type="checkbox" id="c-42774753" checked=""/><div class="controls bullet"><span class="by">Always42</span><span>|</span><a href="#42773528">parent</a><span>|</span><a href="#42775070">prev</a><span>|</span><a href="#42766310">next</a><span>|</span><label class="collapse" for="c-42774753">[-]</label><label class="expand" for="c-42774753">[1 more]</label></div><br/><div class="children"><div class="content">My immediate response as well.</div><br/></div></div></div></div><div id="42766310" class="c"><input type="checkbox" id="c-42766310" checked=""/><div class="controls bullet"><span class="by">androa</span><span>|</span><a href="#42773528">prev</a><span>|</span><a href="#42765919">next</a><span>|</span><label class="collapse" for="c-42766310">[-]</label><label class="expand" for="c-42766310">[6 more]</label></div><br/><div class="children"><div class="content">GitHub (Actions) is simply not built to support monorepos. Square peg in a round hole and all that. We&#x27;ve opted for using `meta` to simulate monorepos, while being able to use GitHub Actions without too much downsides.</div><br/><div id="42774630" class="c"><input type="checkbox" id="c-42774630" checked=""/><div class="controls bullet"><span class="by">justin_oaks</span><span>|</span><a href="#42766310">parent</a><span>|</span><a href="#42766626">next</a><span>|</span><label class="collapse" for="c-42774630">[-]</label><label class="expand" for="c-42774630">[1 more]</label></div><br/><div class="children"><div class="content">Which makes me wonder if there is a way to simulate multiple repos while maintaining a mono repo. Or mirror a portion of a monorepo as a single repo.<p>Obviously this would be a real pain to implement just to fix the underlying problem, but it&#x27;s an interesting (awful) solution</div><br/></div></div><div id="42766626" class="c"><input type="checkbox" id="c-42766626" checked=""/><div class="controls bullet"><span class="by">Imustaskforhelp</span><span>|</span><a href="#42766310">parent</a><span>|</span><a href="#42774630">prev</a><span>|</span><a href="#42765919">next</a><span>|</span><label class="collapse" for="c-42766626">[-]</label><label class="expand" for="c-42766626">[4 more]</label></div><br/><div class="children"><div class="content">hey could you please share the`meta` tool you mentioned , sounds interesting ! couldn&#x27;t find it on internet [skill issue]</div><br/><div id="42766709" class="c"><input type="checkbox" id="c-42766709" checked=""/><div class="controls bullet"><span class="by">joshka</span><span>|</span><a href="#42766310">root</a><span>|</span><a href="#42766626">parent</a><span>|</span><a href="#42765919">next</a><span>|</span><label class="collapse" for="c-42766709">[-]</label><label class="expand" for="c-42766709">[3 more]</label></div><br/><div class="children"><div class="content">Guessing it&#x27;s <a href="https:&#x2F;&#x2F;github.com&#x2F;mateodelnorte&#x2F;meta">https:&#x2F;&#x2F;github.com&#x2F;mateodelnorte&#x2F;meta</a> googlefu &quot;meta github repo&quot;</div><br/><div id="42766775" class="c"><input type="checkbox" id="c-42766775" checked=""/><div class="controls bullet"><span class="by">Imustaskforhelp</span><span>|</span><a href="#42766310">root</a><span>|</span><a href="#42766709">parent</a><span>|</span><a href="#42765919">next</a><span>|</span><label class="collapse" for="c-42766775">[-]</label><label class="expand" for="c-42766775">[2 more]</label></div><br/><div class="children"><div class="content">hey thanks!<p>definitely interesting!<p>I do wonder if this <i>really</i> solves the author problem because by the looks of it , you just have to run meta command and it would run over each of the sub directory. While at the same time , I think I like it because this is what I think people refer to as &quot;modular monolith&quot;<p>Combining this with nats <a href="https:&#x2F;&#x2F;nats.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nats.io&#x2F;</a> (hey if you don&#x27;t want it to be over the network , you could use nats with the memory model of your application itself to reduce any overhead) and essentially just get yourself a really modular monolith in which you can then seperate things selectively (ahem , microservices) afterwards rather easily.</div><br/><div id="42767231" class="c"><input type="checkbox" id="c-42767231" checked=""/><div class="controls bullet"><span class="by">HumanOstrich</span><span>|</span><a href="#42766310">root</a><span>|</span><a href="#42766775">parent</a><span>|</span><a href="#42765919">next</a><span>|</span><label class="collapse" for="c-42767231">[-]</label><label class="expand" for="c-42767231">[1 more]</label></div><br/><div class="children"><div class="content">Modular monolith refers to the architecture of your application[1]. It&#x27;s a different concept from &quot;monorepo&quot;, although they can be used together.<p>I&#x27;m not sure what NATS has to do with anything in this post or discussion. Also, a modular monolith is almost the antithesis of microservices.<p>[1]: <a href="https:&#x2F;&#x2F;www.thoughtworks.com&#x2F;en-us&#x2F;insights&#x2F;blog&#x2F;microservices&#x2F;modular-monolith-better-way-build-software" rel="nofollow">https:&#x2F;&#x2F;www.thoughtworks.com&#x2F;en-us&#x2F;insights&#x2F;blog&#x2F;microservic...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="42765919" class="c"><input type="checkbox" id="c-42765919" checked=""/><div class="controls bullet"><span class="by">tevon</span><span>|</span><a href="#42766310">prev</a><span>|</span><a href="#42777796">next</a><span>|</span><label class="collapse" for="c-42765919">[-]</label><label class="expand" for="c-42765919">[9 more]</label></div><br/><div class="children"><div class="content">I call writing GitHub Actions &quot;Search and Deploy&quot;, constantly pushing to a branch to get an action to run is a terrible pattern...<p>You&#x27;d think, especially with the deep VS Code integration, they&#x27;d have at least a basic sanity-check locally, even if not running the full pipeline.</div><br/><div id="42766706" class="c"><input type="checkbox" id="c-42766706" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#42765919">parent</a><span>|</span><a href="#42773096">next</a><span>|</span><label class="collapse" for="c-42766706">[-]</label><label class="expand" for="c-42766706">[6 more]</label></div><br/><div class="children"><div class="content">Not just me then? I was trying to fix a GitHub action just today but I have no clue how I&#x27;m supposed to tear it, so I just keep making tiny changes and pushing.... Not a good system but I&#x27;m still within the free tier so I&#x27;m willing to put up with it I guess.</div><br/><div id="42773207" class="c"><input type="checkbox" id="c-42773207" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42765919">root</a><span>|</span><a href="#42766706">parent</a><span>|</span><a href="#42767218">next</a><span>|</span><label class="collapse" for="c-42773207">[-]</label><label class="expand" for="c-42773207">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    git commit --allow-empty -m &quot;bump ci&quot;
</code></pre>
unless your pipeline does magic with trying to detect changed files</div><br/><div id="42776311" class="c"><input type="checkbox" id="c-42776311" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#42765919">root</a><span>|</span><a href="#42773207">parent</a><span>|</span><a href="#42776923">next</a><span>|</span><label class="collapse" for="c-42776311">[-]</label><label class="expand" for="c-42776311">[1 more]</label></div><br/><div class="children"><div class="content">If this is to troubleshoot non-code related failures (perm issues, connection timed out, whatever influences success that doesn&#x27;t require a code change) then surely the repo&#x27;s history would benefit from one just clicking &quot;Re-run Job&quot;, or its equivalent $(gh ...) invocation, right?</div><br/></div></div><div id="42776923" class="c"><input type="checkbox" id="c-42776923" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#42765919">root</a><span>|</span><a href="#42773207">parent</a><span>|</span><a href="#42776311">prev</a><span>|</span><a href="#42767218">next</a><span>|</span><label class="collapse" for="c-42776923">[-]</label><label class="expand" for="c-42776923">[1 more]</label></div><br/><div class="children"><div class="content">I use Mercurial + hg-git like a weirdo. Not sure if Mercurial supports empty commits, I don&#x27;t think it does.</div><br/></div></div></div></div><div id="42767218" class="c"><input type="checkbox" id="c-42767218" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42765919">root</a><span>|</span><a href="#42766706">parent</a><span>|</span><a href="#42773207">prev</a><span>|</span><a href="#42773096">next</a><span>|</span><label class="collapse" for="c-42767218">[-]</label><label class="expand" for="c-42767218">[2 more]</label></div><br/><div class="children"><div class="content">I think it’s everyone, debugging GH actions is absolute hell, and it gets terrifying when the action interacts with the world (e.g. creating and deploying packages to a registry).</div><br/><div id="42767394" class="c"><input type="checkbox" id="c-42767394" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#42765919">root</a><span>|</span><a href="#42767218">parent</a><span>|</span><a href="#42773096">next</a><span>|</span><label class="collapse" for="c-42767394">[-]</label><label class="expand" for="c-42767394">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it gets terrifying when the action interacts with the world (e.g. creating and deploying packages to a registry).<p>To be fair, testing actions with side effects on the wider world is terrifying even if you’re running it locally, maybe more so because your nonstandard local environment may have surprises (e.g. an env var you set then forgot) while the remote environment mostly only has stuff you set&#x2F;installed explicitly, and you can be sloppier (e.g. accidentally running .&#x2F;deploy when you wanted to run .&#x2F;test). That part isn’t a GH Actions problem.</div><br/></div></div></div></div></div></div><div id="42773096" class="c"><input type="checkbox" id="c-42773096" checked=""/><div class="controls bullet"><span class="by">pavon</span><span>|</span><a href="#42765919">parent</a><span>|</span><a href="#42766706">prev</a><span>|</span><a href="#42769350">next</a><span>|</span><label class="collapse" for="c-42773096">[-]</label><label class="expand" for="c-42773096">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, I have a git alias created specifically for the &quot;we don&#x27;t know what it does until we push it&quot; world of CI:<p>&gt; yolo = &quot;!git commit --all --amend --no-edit &amp;&amp; git push --force #&quot;</div><br/></div></div><div id="42769350" class="c"><input type="checkbox" id="c-42769350" checked=""/><div class="controls bullet"><span class="by">nunez</span><span>|</span><a href="#42765919">parent</a><span>|</span><a href="#42773096">prev</a><span>|</span><a href="#42777796">next</a><span>|</span><label class="collapse" for="c-42769350">[-]</label><label class="expand" for="c-42769350">[1 more]</label></div><br/><div class="children"><div class="content">Biggest pet peeve of GHA by a country mile.</div><br/></div></div></div></div><div id="42777796" class="c"><input type="checkbox" id="c-42777796" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#42765919">prev</a><span>|</span><a href="#42776766">next</a><span>|</span><label class="collapse" for="c-42777796">[-]</label><label class="expand" for="c-42777796">[1 more]</label></div><br/><div class="children"><div class="content">assuming that every folder is independent sounds like bad design.<p>if they&#x27;re really independent  out them in separate repos.</div><br/></div></div><div id="42776766" class="c"><input type="checkbox" id="c-42776766" checked=""/><div class="controls bullet"><span class="by">habosa</span><span>|</span><a href="#42777796">prev</a><span>|</span><a href="#42777300">next</a><span>|</span><label class="collapse" for="c-42776766">[-]</label><label class="expand" for="c-42776766">[1 more]</label></div><br/><div class="children"><div class="content">Shameless plug but I built GitGuard (<a href="https:&#x2F;&#x2F;gitguard.dev" rel="nofollow">https:&#x2F;&#x2F;gitguard.dev</a>) to solve the &quot;Pull request and required checks&quot; problem mentioned here (and other problems).<p>Basically: you set GitGuard as your required check and then write a simple GitGuard workflow like this:<p><pre><code>    if anymatch(pull_files,&quot;src&#x2F;backend&#x2F;.*&quot;) {
      assert(checkpassed(&quot;backend-tests&quot;))
    }
</code></pre>
Email in my bio for anyone interested.</div><br/></div></div><div id="42777300" class="c"><input type="checkbox" id="c-42777300" checked=""/><div class="controls bullet"><span class="by">cjk</span><span>|</span><a href="#42776766">prev</a><span>|</span><a href="#42774235">next</a><span>|</span><label class="collapse" for="c-42777300">[-]</label><label class="expand" for="c-42777300">[1 more]</label></div><br/><div class="children"><div class="content">I have never used a CI system more flaky and slow than GitHub Actions. The one and only positive thing about it is that you get some Actions usage for free.<p>The Azure machines GitHub uses for the runners by default have terrible performance in almost every regard (network, disk, CPU). Presumably it would be more reliable when using your own runners, but even the Actions control plane is flaky and doesn&#x27;t always schedule jobs correctly.<p>We switched to Buildkite at $DAYJOB and haven&#x27;t looked back.</div><br/></div></div><div id="42774235" class="c"><input type="checkbox" id="c-42774235" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42777300">prev</a><span>|</span><a href="#42770463">next</a><span>|</span><label class="collapse" for="c-42774235">[-]</label><label class="expand" for="c-42774235">[5 more]</label></div><br/><div class="children"><div class="content">Re: monorepo<p>&gt; In GitHub you can specify a &quot;required check&quot;, the name of the step in your pipeline that always has to be green before a pull request is merged. As an example, I can say that web-app1 - Unit tests are required to pass. The problem is that this step will only run when I change something in the web-app1 folder. So if my pull request only made changes in api1 I will never be able to merge my pull request!<p>Continuous Integration is not continuous <i>integration</i> if we don’t test that a change has no deleterious side effects on the rest of the system. That’s what integration <i>is</i>. So if you aren’t running all of the tests because they’re slow, then you’re engaging in false economy. Make your tests run faster. Modern hardware with reasonable test runners should be able to whack out 10k unit tests in under a minute. The time to run the tests goes up by a factor of ~7-10 depending on framework as you climb each step in the testing pyramid. And while it takes more tests to cover the same ground, with a little care you can still almost halve the run time replacing one test with a handful of tests that check the same requirement one layer down, or about 70% moving down two layers.<p>One thing that’s been missing from most of the recent CI pipelines I’ve used is being able to see that a build is going to fail before the tests finish. The earlier the reporting of the failure the better the ergonomics for the person who triggered the build. That’s why the testing pyramid even exists.</div><br/><div id="42776882" class="c"><input type="checkbox" id="c-42776882" checked=""/><div class="controls bullet"><span class="by">ecosystem</span><span>|</span><a href="#42774235">parent</a><span>|</span><a href="#42774442">next</a><span>|</span><label class="collapse" for="c-42776882">[-]</label><label class="expand" for="c-42776882">[1 more]</label></div><br/><div class="children"><div class="content">This comment is way too far down the page.<p>If the unit tests are slow enough to want to skip them, they likely are not unit tests but some kind of service-level tests or tests that are hitting external APIs or some other source of a bad smell. If the slow thing is the build, then cache the artifact keyed off the directory contents so the step is fast if code is unchanged. If the unit tests only run for a package when the code changes, there is a lack of e2e&#x2F;integration testing. So, what is OP&#x27;s testing strategy? Caching? It seems like following good testing practices would make this problem disappear.</div><br/></div></div><div id="42774442" class="c"><input type="checkbox" id="c-42774442" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#42774235">parent</a><span>|</span><a href="#42776882">prev</a><span>|</span><a href="#42774404">next</a><span>|</span><label class="collapse" for="c-42774442">[-]</label><label class="expand" for="c-42774442">[2 more]</label></div><br/><div class="children"><div class="content">I agree hardware should be that quick, but CI and cloud hardware is woefully underpowered unless you actively seek it out. I’ve also never seen a test framework spew out even close to that in practice. I’m not even sure most frameworks would do that with noop tests, which is sad.</div><br/><div id="42775140" class="c"><input type="checkbox" id="c-42775140" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42774235">root</a><span>|</span><a href="#42774442">parent</a><span>|</span><a href="#42774404">next</a><span>|</span><label class="collapse" for="c-42775140">[-]</label><label class="expand" for="c-42775140">[1 more]</label></div><br/><div class="children"><div class="content">10 years ago my very testing-competent coworker had us running 4200 tests in 37 seconds. In NodeJS. We should be doing as well that today without a gifted maintainer.</div><br/></div></div></div></div><div id="42774404" class="c"><input type="checkbox" id="c-42774404" checked=""/><div class="controls bullet"><span class="by">rustd</span><span>|</span><a href="#42774235">parent</a><span>|</span><a href="#42774442">prev</a><span>|</span><a href="#42770463">next</a><span>|</span><label class="collapse" for="c-42774404">[-]</label><label class="expand" for="c-42774404">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, most of the CI tools don&#x27;t help in getting feedback early to the developers. I shouldn&#x27;t have to wait hours for my CI job to complete. Harness is a  tool that can reduce build times by caching build artifacts, docker layers and only running a subset of tests that were impacted the by the code change.</div><br/></div></div></div></div><div id="42770463" class="c"><input type="checkbox" id="c-42770463" checked=""/><div class="controls bullet"><span class="by">xinayder</span><span>|</span><a href="#42774235">prev</a><span>|</span><a href="#42777472">next</a><span>|</span><label class="collapse" for="c-42770463">[-]</label><label class="expand" for="c-42770463">[4 more]</label></div><br/><div class="children"><div class="content">I tried to use GitHub Actions on Forgejo and... It&#x27;s so much worse than using an actual CI pipeline.<p>With Woodpecker&#x2F;Jenkins you know exactly what your pipeline is doing. With GitHub actions, not even the developers of the actions themselves know what the runner does.</div><br/><div id="42773516" class="c"><input type="checkbox" id="c-42773516" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42770463">parent</a><span>|</span><a href="#42773684">next</a><span>|</span><label class="collapse" for="c-42773516">[-]</label><label class="expand" for="c-42773516">[1 more]</label></div><br/><div class="children"><div class="content">&gt; use GitHub Actions on Forgejo<p>What does this even mean? Are you talking about Forgejo Actions, or are you somehow hosting your code on a Forgejo instance but running CI through GitHub?<p>&gt; With Woodpecker&#x2F;Jenkins you know exactly what your pipeline is doing.<p>If you wrote it from the ground up, sure. On the other hand, I&#x27;ve inherited Jenkins pipelines that were written years before I got there and involved three to four different plugins, and they&#x27;re <i>way</i> worse to work with than the GitHub Actions that I inherited.</div><br/></div></div><div id="42773684" class="c"><input type="checkbox" id="c-42773684" checked=""/><div class="controls bullet"><span class="by">myaccountonhn</span><span>|</span><a href="#42770463">parent</a><span>|</span><a href="#42773516">prev</a><span>|</span><a href="#42777472">next</a><span>|</span><label class="collapse" for="c-42773684">[-]</label><label class="expand" for="c-42773684">[2 more]</label></div><br/><div class="children"><div class="content">Best one I&#x27;ve used is the CI of sourcehut. So simple and so damn easy to set up.</div><br/><div id="42774056" class="c"><input type="checkbox" id="c-42774056" checked=""/><div class="controls bullet"><span class="by">gabeio</span><span>|</span><a href="#42770463">root</a><span>|</span><a href="#42773684">parent</a><span>|</span><a href="#42777472">next</a><span>|</span><label class="collapse" for="c-42774056">[-]</label><label class="expand" for="c-42774056">[1 more]</label></div><br/><div class="children"><div class="content">You basically achieve the same result on github actions if you just ignore all of the github action yaml “magic” settings in the syntax and let your makefile&#x2F;script do the logic which also makes it trivial to debug locally. But upvote because I do love sourcehut, it’s just so clean!</div><br/></div></div></div></div></div></div><div id="42777472" class="c"><input type="checkbox" id="c-42777472" checked=""/><div class="controls bullet"><span class="by">Sparkyte</span><span>|</span><a href="#42770463">prev</a><span>|</span><a href="#42770532">next</a><span>|</span><label class="collapse" for="c-42777472">[-]</label><label class="expand" for="c-42777472">[1 more]</label></div><br/><div class="children"><div class="content">Blindly using automation or implementing it with validation will always bite a person in the butt. Been there done that. It is good but it should always be event driven with a point of user validation.</div><br/></div></div><div id="42770532" class="c"><input type="checkbox" id="c-42770532" checked=""/><div class="controls bullet"><span class="by">OptionOfT</span><span>|</span><a href="#42777472">prev</a><span>|</span><a href="#42775049">next</a><span>|</span><label class="collapse" for="c-42770532">[-]</label><label class="expand" for="c-42770532">[1 more]</label></div><br/><div class="children"><div class="content">So the way I&#x27;ve solved the multiple folders with independent checks is like this:<p><pre><code>    all-done:
      name: All done
      # this is the job that should be marked as required on GitHub. It&#x27;s the only one that&#x27;ll reliably trigger
      # when any upstream fails: success
      # when all upstream skips: pass
      # when all upstream success: success
      # combination of upstream skip and success: success
      runs-on: ubuntu-latest
      needs:
        - calculate-version
        - cargo-build
        - cargo-fmt
        - cargo-clippy-and-report
        - cargo-test-and-report
        - docker-build
        - docker-publish
      if: |
        always()
      steps:
        - name: Fail!
          shell: bash
          if: |
            contains(needs.*.result, &#x27;failure&#x27;) ||
            contains(needs.*.result, &#x27;cancelled&#x27;)
          run: |
            echo &quot;One &#x2F; more upstream failed or was cancelled. Failing job...&quot;
  
            exit 1
  
        - name: Success!
          shell: bash
          run: |
            echo &quot;Great success!&quot;

</code></pre>
That way it is resilient against checks not running because they&#x27;re not needed, but it still fails when any upstream actually fails.<p>Now, I did end up running the tests of the front-end and back-end because they upload coverage, and if my coverage tool doesn&#x27;t get both, it&#x27;ll consider it as a drop in coverage and fail its check.<p>But in general, I agree with the writer of the post that it all feels like it&#x27;s not getting enough love.<p>For example, there is no support for yaml anchors, which really hampers reusability on things that cannot be extracted to separate flows (not to mention separate flows can only be nested 4 deep).<p>There is also the issue that any commit made by GitHub actions doesn&#x27;t trigger another build. This is understandable, as you want to avoid endless builds, but sometimes it&#x27;s needed, and then you need to do the ugly workaround with a PAT (and I believe it can&#x27;t even be a fine-grained one). Combine that with policies that set a maximum time limit on tokens, your build becomes brittle, as now you need to chase down the person with admin access.<p>Then there is the issue of Docker actions. They tell you to pin the action to an sha to prevent replacements. Except the action itself points to a replaceable tag.<p>Lastly, there is a bug where when you create a report for your action, you cannot specify the parent it belongs to. So your ESLint report could be made a child of your coverage report.</div><br/></div></div><div id="42775049" class="c"><input type="checkbox" id="c-42775049" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#42770532">prev</a><span>|</span><a href="#42766657">next</a><span>|</span><label class="collapse" for="c-42775049">[-]</label><label class="expand" for="c-42775049">[1 more]</label></div><br/><div class="children"><div class="content">Monorepos come with a different set of tradeoffs from polyrepos. Both have their pains. We have a similar setup with Jenkins, and have used CUE to tame a number of these issues. We did so by creating (1) a software catalog (2) per-branch config for versions and CI switches<p>Similarly, we are adopting Dagger, more as part of a larger &quot;containerize all of our CI steps&quot; which works great for bringing parity to CI &amp; local dev work. There are a number of secondary benefits and the TUI &#x2F; WUI logs are awesome.<p>Between the two, I have removed much of the yaml engineering in my work</div><br/></div></div><div id="42766657" class="c"><input type="checkbox" id="c-42766657" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42775049">prev</a><span>|</span><a href="#42774044">next</a><span>|</span><label class="collapse" for="c-42766657">[-]</label><label class="expand" for="c-42766657">[5 more]</label></div><br/><div class="children"><div class="content">IMHO the main problem with GH Actions is that the runners are so slow. Feels like running your build on a frigging C64 sometimes ;)</div><br/><div id="42774430" class="c"><input type="checkbox" id="c-42774430" checked=""/><div class="controls bullet"><span class="by">rustd</span><span>|</span><a href="#42766657">parent</a><span>|</span><a href="#42766896">next</a><span>|</span><label class="collapse" for="c-42774430">[-]</label><label class="expand" for="c-42774430">[1 more]</label></div><br/><div class="children"><div class="content">GH hosted runners use shared hardware so the performance is never good. There are quite a few options available. Harness CI offers hyper optimized build infrastructure, paired with software intelligence (caching, running subset of tests based on the code change) can reduce build times up-to 4X compared to GH Actions.</div><br/></div></div><div id="42766896" class="c"><input type="checkbox" id="c-42766896" checked=""/><div class="controls bullet"><span class="by">Hamuko</span><span>|</span><a href="#42766657">parent</a><span>|</span><a href="#42774430">prev</a><span>|</span><a href="#42767154">next</a><span>|</span><label class="collapse" for="c-42766896">[-]</label><label class="expand" for="c-42766896">[1 more]</label></div><br/><div class="children"><div class="content">Are you hosting your own runners or relying on GitHub&#x27;s?</div><br/></div></div><div id="42767154" class="c"><input type="checkbox" id="c-42767154" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#42766657">parent</a><span>|</span><a href="#42766896">prev</a><span>|</span><a href="#42774263">next</a><span>|</span><label class="collapse" for="c-42767154">[-]</label><label class="expand" for="c-42767154">[1 more]</label></div><br/><div class="children"><div class="content">Blacksmith is your buddy. Its free and just has better images for single-core operations. Unless you&#x27;re Google, I can guarantee it&#x27;s faster.</div><br/></div></div></div></div><div id="42774044" class="c"><input type="checkbox" id="c-42774044" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#42766657">prev</a><span>|</span><a href="#42773654">next</a><span>|</span><label class="collapse" for="c-42774044">[-]</label><label class="expand" for="c-42774044">[1 more]</label></div><br/><div class="children"><div class="content">I do not use GitHub Actions for these purposes, and if I did, I would want to ensure that it is a file that can run locally or whatever else just as well. I don&#x27;t use GitHub Actions to prevent pull requests from being merged (I will always manage them manually), and do not use GitHub Actions to manage writing the program, for testing the program (it would be possible to do this, but I would insist on doing it in a way that is not vendor-locked to GitHub, and by putting most of the stuff outside of the GitHub Actions file itself), etc.<p>I do have a GitHub Actions file for a purpose which is not related to the program itself; specifically, for auto-assignment of issues. In this case, it is clearly not intended to run locally (although in this case you could do so anyways if you could install the &quot;gh&quot; program on your computer and run the command mentioned there locally, but it is not necessary since GitHub will do it automatically on their computer).<p><pre><code>  on:
    issues:
      types:
        - opened
    pull_request:
      types:
        - opened
  permissions:
    contents: read
    issues: write
    pull-requests: write
  jobs:
    default:
      runs-on: ubuntu-latest
      steps:
        - run: gh issue edit ${{ github.event.issue.number }} --add-assignee ${{ github.repository_owner }}
          env:
            GH_TOKEN: ${{ github.token }}
            GH_REPO: ${{ github.repository }}</code></pre></div><br/></div></div><div id="42773654" class="c"><input type="checkbox" id="c-42773654" checked=""/><div class="controls bullet"><span class="by">ashishb</span><span>|</span><a href="#42774044">prev</a><span>|</span><a href="#42777093">next</a><span>|</span><label class="collapse" for="c-42773654">[-]</label><label class="expand" for="c-42773654">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of subtle pitfalls as well. Like no default timeouts, excess permissions etc.<p>I wrote about it in detail <a href="https:&#x2F;&#x2F;ashishb.net&#x2F;tech&#x2F;common-pitfalls-of-github-actions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ashishb.net&#x2F;tech&#x2F;common-pitfalls-of-github-actions&#x2F;</a>
And even created a tool to generate good configs <a href="http:&#x2F;&#x2F;github.com&#x2F;ashishb&#x2F;gabo">http:&#x2F;&#x2F;github.com&#x2F;ashishb&#x2F;gabo</a></div><br/></div></div><div id="42777093" class="c"><input type="checkbox" id="c-42777093" checked=""/><div class="controls bullet"><span class="by">webprofusion</span><span>|</span><a href="#42773654">prev</a><span>|</span><a href="#42767305">next</a><span>|</span><label class="collapse" for="c-42777093">[-]</label><label class="expand" for="c-42777093">[1 more]</label></div><br/><div class="children"><div class="content">GitHub Action has supported your own locally hosted runners for years, so I presume &quot;there is no way of running GitHub Actions locally&quot; is referring to something else.</div><br/></div></div><div id="42767305" class="c"><input type="checkbox" id="c-42767305" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#42777093">prev</a><span>|</span><label class="collapse" for="c-42767305">[-]</label><label class="expand" for="c-42767305">[5 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t run AWS lambda or DyanmoDB locally too (well you can but it&#x27;s a hassle). So by that logic, we shouldn&#x27;t use them at all. I don&#x27;t like working with CI too but I&#x27;ll take GitHub Actions over Jenkins&#x2F;CircleCI&#x2F;TravisCI any day.</div><br/><div id="42767477" class="c"><input type="checkbox" id="c-42767477" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#42767305">parent</a><span>|</span><a href="#42773243">next</a><span>|</span><label class="collapse" for="c-42767477">[-]</label><label class="expand" for="c-42767477">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You can&#x27;t run AWS lambda or DyanmoDB locally too (well you can but it&#x27;s a hassle). So by that logic, we shouldn&#x27;t use them at all.<p>No, applying the logic to something like Lambda would mean implementing handlers like:<p><pre><code>    function handle(lambdaRequest, lambdaContext) {
      return myFunction(
        stuffExtractedFromLambdaRequest(lambdaRequest),
        stuffExtractedFromLambdaContext(lambdaContext)
      );
    }
</code></pre>
Then there&#x27;s no need to go through the hassle of running Lambda functions locally; since we can just run `myFunction` locally instead.<p>Dynamo isn&#x27;t the same, since it&#x27;s just a service&#x2F;API that we call; we don&#x27;t implement its logic, like we do for CI tasks, Lambda functions, etc.<p>Whilst you&#x27;re right that it&#x27;s a hassle to run DynamoDB locally (although not too bad, in my experience); that&#x27;s also not necessary. It&#x27;s fine to run code locally which talks to a remote DynamoDB; just set up the credentials appropriately.</div><br/><div id="42767520" class="c"><input type="checkbox" id="c-42767520" checked=""/><div class="controls bullet"><span class="by">rednafi</span><span>|</span><a href="#42767305">root</a><span>|</span><a href="#42767477">parent</a><span>|</span><a href="#42773243">next</a><span>|</span><label class="collapse" for="c-42767520">[-]</label><label class="expand" for="c-42767520">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, and that doesn&#x27;t stop us from using either of them. What I tried to convey is that GHA isn&#x27;t ideal and it has a few warts but it&#x27;s still better than most of the options available out there.</div><br/></div></div></div></div><div id="42773243" class="c"><input type="checkbox" id="c-42773243" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42767305">parent</a><span>|</span><a href="#42767477">prev</a><span>|</span><a href="#42772985">next</a><span>|</span><label class="collapse" for="c-42773243">[-]</label><label class="expand" for="c-42773243">[1 more]</label></div><br/><div class="children"><div class="content">lambda: <a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;serverless-application-model&#x2F;latest&#x2F;developerguide&#x2F;using-sam-cli-local.html" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;serverless-application-model&#x2F;lat...</a><p>dynamodb: <a href="https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;amazondynamodb&#x2F;latest&#x2F;developerguide&#x2F;DynamoDBLocal.DownloadingAndRunning.html#docker" rel="nofollow">https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;amazondynamodb&#x2F;latest&#x2F;developerg...</a><p>doesn&#x27;t seem any harder than running any other db</div><br/></div></div><div id="42772985" class="c"><input type="checkbox" id="c-42772985" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42767305">parent</a><span>|</span><a href="#42773243">prev</a><span>|</span><label class="collapse" for="c-42772985">[-]</label><label class="expand" for="c-42772985">[1 more]</label></div><br/><div class="children"><div class="content">The problem with the analogy is that GHA&#x27;s interface is quite thick.</div><br/></div></div></div></div></div></div></div></div></div></body></html>