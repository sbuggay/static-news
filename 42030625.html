<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730624464106" as="style"/><link rel="stylesheet" href="styles.css?v=1730624464106"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://slawlor.github.io/ractor/quickstart/">Ractor – a Rust Actor Framework</a> <span class="domain">(<a href="https://slawlor.github.io">slawlor.github.io</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>12 comments</span></div><br/><div><div id="42031752" class="c"><input type="checkbox" id="c-42031752" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#42031706">next</a><span>|</span><label class="collapse" for="c-42031752">[-]</label><label class="expand" for="c-42031752">[1 more]</label></div><br/><div class="children"><div class="content">Ractor is cool, but I&#x27;ve been wondering why it uses the async `async_trait` rather than native async traits. Is it just because it came out before async traits were stabilized, and now code relies on it and it would be a breaking change to migrate?<p>For context, the `async_trait` crate makes futures from trait methods that are wrapped in `Pin&lt;Box&lt;dyn Future&lt;...&gt;&gt;&gt;`, which means that every async call to a trait method must make a heap allocation. This is currently a necessary thing to do if async trait methods were invoked with dynamic dispatch (through `dyn Actor`), but the `Actor` trait has associated methods, so that is already not generally possible.<p>I realize that methods on the `Actor` trait return futures that are `Send`, but specifically for an actor framework that feels like a very specific design choice that isn&#x27;t universally good or necessary. Another design would give let the spawned task that executes the actor&#x27;s messages exclusive access to the actor (so `handle()` could take `&amp;mut self`).<p>I&#x27;ve ended up implementing a simple alternative design in my own project (it&#x27;s not fundamentally very hard, but doesn&#x27;t have all the features, like supervision) because the per-message heap allocations and internal locking became wasteful for my use case.</div><br/></div></div><div id="42031706" class="c"><input type="checkbox" id="c-42031706" checked=""/><div class="controls bullet"><span class="by">rapsey</span><span>|</span><a href="#42031752">prev</a><span>|</span><a href="#42031403">next</a><span>|</span><label class="collapse" for="c-42031706">[-]</label><label class="expand" for="c-42031706">[7 more]</label></div><br/><div class="children"><div class="content">Sorry for being so negative but why do people keep building these Actor frameworks for Rust? None of them get any usage.</div><br/><div id="42031904" class="c"><input type="checkbox" id="c-42031904" checked=""/><div class="controls bullet"><span class="by">babo</span><span>|</span><a href="#42031706">parent</a><span>|</span><a href="#42031730">next</a><span>|</span><label class="collapse" for="c-42031904">[-]</label><label class="expand" for="c-42031904">[1 more]</label></div><br/><div class="children"><div class="content">This seems to be used at Meta: &quot;Ractor had a session at RustConf’24 about how it’s used for distributed overload protection in Rust Thrift servers at Meta.&quot;</div><br/></div></div><div id="42031730" class="c"><input type="checkbox" id="c-42031730" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#42031706">parent</a><span>|</span><a href="#42031904">prev</a><span>|</span><a href="#42031735">next</a><span>|</span><label class="collapse" for="c-42031730">[-]</label><label class="expand" for="c-42031730">[1 more]</label></div><br/><div class="children"><div class="content">For reasonable reasons in my view.<p>The actor model is imo a great way of doing concurrency in the absence of the data race guarantee that safe rust provides at compile time. If you know you have no data races, I don&#x27;t think actors give you that much.<p>That said, some people just really like actors as a mental model and&#x2F;or they want to interoperate with actor-based systems written in other languages or provide an actor substrate written in rust that will be embedded into another language perhaps?  It&#x27;s definitely a niche usage.</div><br/></div></div><div id="42031828" class="c"><input type="checkbox" id="c-42031828" checked=""/><div class="controls bullet"><span class="by">biorach</span><span>|</span><a href="#42031706">parent</a><span>|</span><a href="#42031735">prev</a><span>|</span><a href="#42031726">next</a><span>|</span><label class="collapse" for="c-42031828">[-]</label><label class="expand" for="c-42031828">[1 more]</label></div><br/><div class="children"><div class="content">&gt; None of them get any usage.<p>Github stats show some uptake so clearly someone finds them useful</div><br/></div></div><div id="42031726" class="c"><input type="checkbox" id="c-42031726" checked=""/><div class="controls bullet"><span class="by">bowsamic</span><span>|</span><a href="#42031706">parent</a><span>|</span><a href="#42031828">prev</a><span>|</span><a href="#42031403">next</a><span>|</span><label class="collapse" for="c-42031726">[-]</label><label class="expand" for="c-42031726">[2 more]</label></div><br/><div class="children"><div class="content">It’s kind of like Java. It’s a way to feel like you’re doing work without actually doing anything</div><br/><div id="42031804" class="c"><input type="checkbox" id="c-42031804" checked=""/><div class="controls bullet"><span class="by">rochak</span><span>|</span><a href="#42031706">root</a><span>|</span><a href="#42031726">parent</a><span>|</span><a href="#42031403">next</a><span>|</span><label class="collapse" for="c-42031804">[-]</label><label class="expand" for="c-42031804">[1 more]</label></div><br/><div class="children"><div class="content">Couldn’t have said it any better myself</div><br/></div></div></div></div></div></div><div id="42031403" class="c"><input type="checkbox" id="c-42031403" checked=""/><div class="controls bullet"><span class="by">jatins</span><span>|</span><a href="#42031706">prev</a><span>|</span><a href="#42031466">next</a><span>|</span><label class="collapse" for="c-42031403">[-]</label><label class="expand" for="c-42031403">[1 more]</label></div><br/><div class="children"><div class="content">That looks interesting! What&#x27;s the distributed story of Ractor? Would you need a central store like Redis  to serve as Actor registry?<p>One of the promises of Elixir&#x2F;Erlang is that you can call a process&#x2F;Actor on different machine just like you can one on same once you put together a bunch of machines in a cluster</div><br/></div></div><div id="42031466" class="c"><input type="checkbox" id="c-42031466" checked=""/><div class="controls bullet"><span class="by">victorbjorklund</span><span>|</span><a href="#42031403">prev</a><span>|</span><a href="#42031546">next</a><span>|</span><label class="collapse" for="c-42031466">[-]</label><label class="expand" for="c-42031466">[1 more]</label></div><br/><div class="children"><div class="content">This is nice. Any way to also make it an Erlang complient node so it can be called from a erlang cluster?</div><br/></div></div><div id="42031546" class="c"><input type="checkbox" id="c-42031546" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#42031466">prev</a><span>|</span><label class="collapse" for="c-42031546">[-]</label><label class="expand" for="c-42031546">[1 more]</label></div><br/><div class="children"><div class="content">how does it compare with bastion?</div><br/></div></div></div></div></div></div></div></body></html>