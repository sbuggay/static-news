<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724058071688" as="style"/><link rel="stylesheet" href="styles.css?v=1724058071688"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://okmij.org/ftp/ML/generalization.html">How the OCaml type checker works (2022)</a>Â <span class="domain">(<a href="https://okmij.org">okmij.org</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>35 comments</span></div><br/><div><div id="41282415" class="c"><input type="checkbox" id="c-41282415" checked=""/><div class="controls bullet"><span class="by">incognito124</span><span>|</span><a href="#41283363">next</a><span>|</span><label class="collapse" for="c-41282415">[-]</label><label class="expand" for="c-41282415">[5 more]</label></div><br/><div class="children"><div class="content">Before opening the article, my first thought was &quot;wdym, it&#x27;s HM and Algorithm W&quot;<p>The very first sentence was:
&gt; There is more to Hindley-Milner type inference than the Algorithm W.<p>I guess congratulations to the author for knowing the audience well enough</div><br/><div id="41282576" class="c"><input type="checkbox" id="c-41282576" checked=""/><div class="controls bullet"><span class="by">Drup</span><span>|</span><a href="#41282415">parent</a><span>|</span><a href="#41282500">next</a><span>|</span><label class="collapse" for="c-41282576">[-]</label><label class="expand" for="c-41282576">[3 more]</label></div><br/><div class="children"><div class="content">That remark is actually more interesting than you think. As groundbreaking as it was, algorithm W iss far too slow for non-toy languages. All modern HM languages (that I know of) use some form of union-find trickeries, as pioneered by the one presented in the blog post (but also present in resolution-by-constraints approaches employed by Haskell and Scala).<p>So, in fact, it&#x27;s actually never algorithm W in non-toy languages. ;)<p>Side note: this article is originally from 2013 and is considered a must-read by any would-be hackers trying to modify the OCaml typechecker (it&#x27;s cited in the documentation).</div><br/><div id="41283633" class="c"><input type="checkbox" id="c-41283633" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#41282415">root</a><span>|</span><a href="#41282576">parent</a><span>|</span><a href="#41282715">next</a><span>|</span><label class="collapse" for="c-41283633">[-]</label><label class="expand" for="c-41283633">[1 more]</label></div><br/><div class="children"><div class="content">In fact, those union-find trickeries come from the <i>same</i> paper that presented algorithm W, where they were named algorithm J. W was known from the start to be more useful for proofs than implementation:<p>&gt; As it stands, W is hardly an efficient algorithm; substitutions are applied too often. It was formulated to aid the proof of soundness. We now present a simpler algorithm J which simulates W in a precise sense.<p><a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1016&#x2F;0022-0000(78)90014-4" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1016&#x2F;0022-0000(78)90014-4</a></div><br/></div></div><div id="41282715" class="c"><input type="checkbox" id="c-41282715" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#41282415">root</a><span>|</span><a href="#41282576">parent</a><span>|</span><a href="#41283633">prev</a><span>|</span><a href="#41282500">next</a><span>|</span><label class="collapse" for="c-41282715">[-]</label><label class="expand" for="c-41282715">[1 more]</label></div><br/><div class="children"><div class="content">The Wikipedia articles claims that W is efficient, but only for a core language without highly desirable features like recursion, polymorphism, and subtyping.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Hindley%E2%80%93Milner_type_system" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Hindley%E2%80%93Milner_type_...</a></div><br/></div></div></div></div><div id="41282500" class="c"><input type="checkbox" id="c-41282500" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#41282415">parent</a><span>|</span><a href="#41282576">prev</a><span>|</span><a href="#41283363">next</a><span>|</span><label class="collapse" for="c-41282500">[-]</label><label class="expand" for="c-41282500">[1 more]</label></div><br/><div class="children"><div class="content">The subtitle, &quot;or what polymorphism and garbage collection have in common&quot;, is another hint there may be more to TFA than its HN submission title indicates.</div><br/></div></div></div></div><div id="41283363" class="c"><input type="checkbox" id="c-41283363" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41282415">prev</a><span>|</span><a href="#41284689">next</a><span>|</span><label class="collapse" for="c-41283363">[-]</label><label class="expand" for="c-41283363">[2 more]</label></div><br/><div class="children"><div class="content">&gt; OCaml generalization is based on tracking of so-called levels of a type.<p>The level tracking reminds me of a recent paper exploring SimpleSub[0], a simpler alternative of adding subtyping to ML-style type systems. It also gets rid of the algorithm W&#x27;s repeated generalization (introducing foralls and turning a type into a polytype) and instantiation (changing the universally quantified type variables to fresh type variables). They have slightly different operations on levels, e.g. extrude. I wonder if this level tracking is independently invented again.<p>[0]: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3409006" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3409006</a></div><br/><div id="41283477" class="c"><input type="checkbox" id="c-41283477" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41283363">parent</a><span>|</span><a href="#41284689">next</a><span>|</span><label class="collapse" for="c-41283477">[-]</label><label class="expand" for="c-41283477">[1 more]</label></div><br/><div class="children"><div class="content">Not independently invented again. Lionel is fully aware of the level tracking in the OCaml type-checker; in fact the OP is cited in the Simple-sub paper (section 3.5.1, page 15).</div><br/></div></div></div></div><div id="41284689" class="c"><input type="checkbox" id="c-41284689" checked=""/><div class="controls bullet"><span class="by">nj5rq</span><span>|</span><a href="#41283363">prev</a><span>|</span><a href="#41288490">next</a><span>|</span><label class="collapse" for="c-41284689">[-]</label><label class="expand" for="c-41284689">[1 more]</label></div><br/><div class="children"><div class="content">Say whatever you want, but this is how websites should be designed.</div><br/></div></div><div id="41288490" class="c"><input type="checkbox" id="c-41288490" checked=""/><div class="controls bullet"><span class="by">sdeframond</span><span>|</span><a href="#41284689">prev</a><span>|</span><a href="#41282002">next</a><span>|</span><label class="collapse" for="c-41288490">[-]</label><label class="expand" for="c-41288490">[1 more]</label></div><br/><div class="children"><div class="content">Beginner question: where to start to understand how to design a type system?</div><br/></div></div><div id="41282002" class="c"><input type="checkbox" id="c-41282002" checked=""/><div class="controls bullet"><span class="by">eska</span><span>|</span><a href="#41288490">prev</a><span>|</span><a href="#41283210">next</a><span>|</span><label class="collapse" for="c-41282002">[-]</label><label class="expand" for="c-41282002">[16 more]</label></div><br/><div class="children"><div class="content">OT: how come there are so many OCaml posts recently? Genuinely curious!</div><br/><div id="41282796" class="c"><input type="checkbox" id="c-41282796" checked=""/><div class="controls bullet"><span class="by">mattarm</span><span>|</span><a href="#41282002">parent</a><span>|</span><a href="#41282857">next</a><span>|</span><label class="collapse" for="c-41282796">[-]</label><label class="expand" for="c-41282796">[5 more]</label></div><br/><div class="children"><div class="content">Some popular streamers have dabbled in OCaml this year, sometimes calling it &quot;the Go of functional programming&quot;, which probably set off a small wave of people tinkering with the language. OCaml has also gotten gradually better in recent years in terms of tooling, documentation, standard library, etc.</div><br/><div id="41282888" class="c"><input type="checkbox" id="c-41282888" checked=""/><div class="controls bullet"><span class="by">adambrod</span><span>|</span><a href="#41282002">root</a><span>|</span><a href="#41282796">parent</a><span>|</span><a href="#41286746">next</a><span>|</span><label class="collapse" for="c-41282888">[-]</label><label class="expand" for="c-41282888">[2 more]</label></div><br/><div class="children"><div class="content">I think they were saying that Gleam was Go of functional programming? OCaml may be like Go compared to Haskell but IMHO Gleam really embraces simplicity and pragmatism.</div><br/><div id="41283053" class="c"><input type="checkbox" id="c-41283053" checked=""/><div class="controls bullet"><span class="by">myaccountonhn</span><span>|</span><a href="#41282002">root</a><span>|</span><a href="#41282888">parent</a><span>|</span><a href="#41286746">next</a><span>|</span><label class="collapse" for="c-41283053">[-]</label><label class="expand" for="c-41283053">[1 more]</label></div><br/><div class="children"><div class="content">I would say some other reasons OCaml is similar to Go is that the runtime is very simple, performance is on par and the compilation times are very fast. It also markets itself as a GC&#x27;d systems language similar to Go. I think a seasoned OCaml would be able to guess the generated assembler code.<p>I suspect that Gleam is quite different in that regard.</div><br/></div></div></div></div><div id="41286746" class="c"><input type="checkbox" id="c-41286746" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#41282002">root</a><span>|</span><a href="#41282796">parent</a><span>|</span><a href="#41282888">prev</a><span>|</span><a href="#41282857">next</a><span>|</span><label class="collapse" for="c-41286746">[-]</label><label class="expand" for="c-41286746">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;Go of functional languages&quot; title should go to Haskell.<p>The Haskell&#x27;s STM and channels implemented in it allow for most (or all) of the Go &quot;select&quot; statement, but in a library, not language.</div><br/><div id="41287344" class="c"><input type="checkbox" id="c-41287344" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#41282002">root</a><span>|</span><a href="#41286746">parent</a><span>|</span><a href="#41282857">next</a><span>|</span><label class="collapse" for="c-41287344">[-]</label><label class="expand" for="c-41287344">[1 more]</label></div><br/><div class="children"><div class="content">Go prioritizes simplicity and pragmatism which is much more like OCaml than Haskell.<p>Haskell is more like a Rust of FP. But Rust is also much more pragmatic than Haskell.</div><br/></div></div></div></div></div></div><div id="41282857" class="c"><input type="checkbox" id="c-41282857" checked=""/><div class="controls bullet"><span class="by">sporkl</span><span>|</span><a href="#41282002">parent</a><span>|</span><a href="#41282796">prev</a><span>|</span><a href="#41282845">next</a><span>|</span><label class="collapse" for="c-41282857">[-]</label><label class="expand" for="c-41282857">[4 more]</label></div><br/><div class="children"><div class="content">Anecdotally, I feel like OCaml is growing in popularity, probably due to ecosystem improvements. Stuff like dune and other OCaml Platform tools becoming mature, multicore support, recently first-class Windows support, etc.</div><br/><div id="41283019" class="c"><input type="checkbox" id="c-41283019" checked=""/><div class="controls bullet"><span class="by">myaccountonhn</span><span>|</span><a href="#41282002">root</a><span>|</span><a href="#41282857">parent</a><span>|</span><a href="#41282984">next</a><span>|</span><label class="collapse" for="c-41283019">[-]</label><label class="expand" for="c-41283019">[2 more]</label></div><br/><div class="children"><div class="content">I also suspect that people are more open to a language like OCaml. With Rust and javascript being so popular, a lot of constructs in OCaml will not seem so foreign.<p>OCaml is in many ways a sane Typescript or a functional version of Go.</div><br/><div id="41283074" class="c"><input type="checkbox" id="c-41283074" checked=""/><div class="controls bullet"><span class="by">adambrod</span><span>|</span><a href="#41282002">root</a><span>|</span><a href="#41283019">parent</a><span>|</span><a href="#41282984">next</a><span>|</span><label class="collapse" for="c-41283074">[-]</label><label class="expand" for="c-41283074">[1 more]</label></div><br/><div class="children"><div class="content">Ditto, it feels like more people are coming around to the ML style type systems. I&#x27;m hoping Gleam will fill the void with a scalable BEAM backend and compiling to JS with Lustre on the frontend (or even just serverside with htmx).</div><br/></div></div></div></div><div id="41282984" class="c"><input type="checkbox" id="c-41282984" checked=""/><div class="controls bullet"><span class="by">ericjmorey</span><span>|</span><a href="#41282002">root</a><span>|</span><a href="#41282857">parent</a><span>|</span><a href="#41283019">prev</a><span>|</span><a href="#41282845">next</a><span>|</span><label class="collapse" for="c-41282984">[-]</label><label class="expand" for="c-41282984">[1 more]</label></div><br/><div class="children"><div class="content">OCAML on Windows was such a pain several years back. It&#x27;s good to hear that they&#x27;ve improved on it.</div><br/></div></div></div></div><div id="41282845" class="c"><input type="checkbox" id="c-41282845" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#41282002">parent</a><span>|</span><a href="#41282857">prev</a><span>|</span><a href="#41282633">next</a><span>|</span><label class="collapse" for="c-41282845">[-]</label><label class="expand" for="c-41282845">[3 more]</label></div><br/><div class="children"><div class="content">Before OCaml multi core it was a non starter for many applications. Now, OCaml can be used for almost anything!</div><br/><div id="41282900" class="c"><input type="checkbox" id="c-41282900" checked=""/><div class="controls bullet"><span class="by">adambrod</span><span>|</span><a href="#41282002">root</a><span>|</span><a href="#41282845">parent</a><span>|</span><a href="#41282633">next</a><span>|</span><label class="collapse" for="c-41282900">[-]</label><label class="expand" for="c-41282900">[2 more]</label></div><br/><div class="children"><div class="content">I really rooting for the Riot framework. It&#x27;s based on the actor model and makes using multi core in OCaml a breeze.</div><br/><div id="41283231" class="c"><input type="checkbox" id="c-41283231" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#41282002">root</a><span>|</span><a href="#41282900">parent</a><span>|</span><a href="#41282633">next</a><span>|</span><label class="collapse" for="c-41283231">[-]</label><label class="expand" for="c-41283231">[1 more]</label></div><br/><div class="children"><div class="content">Well its feature list seems positively delightful: <a href="https:&#x2F;&#x2F;github.com&#x2F;riot-ml&#x2F;riot">https:&#x2F;&#x2F;github.com&#x2F;riot-ml&#x2F;riot</a> !<p>Basically, it seems, it&#x27;s Erlang for OCaml. Hot reloading would be a cool feature, though, but I can see why it&#x27;s not implemented, at least not yet.. I recall the OCaml native toplevel is able to load code in dynamically, so that could be the mechanism to do it.<p>It seems to use open types for handling messages (per just looking at <a href="https:&#x2F;&#x2F;github.com&#x2F;riot-ml&#x2F;riot&#x2F;tree&#x2F;main&#x2F;examples&#x2F;3-message-passing">https:&#x2F;&#x2F;github.com&#x2F;riot-ml&#x2F;riot&#x2F;tree&#x2F;main&#x2F;examples&#x2F;3-message...</a>) reducing the benefits of exhaustiveness checking, but it still seems rather interesting!</div><br/></div></div></div></div></div></div><div id="41282633" class="c"><input type="checkbox" id="c-41282633" checked=""/><div class="controls bullet"><span class="by">pieix</span><span>|</span><a href="#41282002">parent</a><span>|</span><a href="#41282845">prev</a><span>|</span><a href="#41282174">next</a><span>|</span><label class="collapse" for="c-41282633">[-]</label><label class="expand" for="c-41282633">[1 more]</label></div><br/><div class="children"><div class="content">OCaml is the one language Iâve used whose standard library is great to read. Itâs a very developer-friendly language but in all of the ways that make it popular on HN and rarely used in the real world.</div><br/></div></div><div id="41282174" class="c"><input type="checkbox" id="c-41282174" checked=""/><div class="controls bullet"><span class="by">kinow</span><span>|</span><a href="#41282002">parent</a><span>|</span><a href="#41282633">prev</a><span>|</span><a href="#41283190">next</a><span>|</span><label class="collapse" for="c-41282174">[-]</label><label class="expand" for="c-41282174">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if there&#x27;s any reason like a project, derived language, or some new feature. But there are always posts and comments about OCalm at <a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;functionalprogramming&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;functionalprogramming&#x2F;</a>. So it&#x27;s not really a surprise to me that it gets some waves of posts every now and then.</div><br/></div></div><div id="41283190" class="c"><input type="checkbox" id="c-41283190" checked=""/><div class="controls bullet"><span class="by">carapace</span><span>|</span><a href="#41282002">parent</a><span>|</span><a href="#41282174">prev</a><span>|</span><a href="#41283210">next</a><span>|</span><label class="collapse" for="c-41283190">[-]</label><label class="expand" for="c-41283190">[1 more]</label></div><br/><div class="children"><div class="content">It feels like we&#x27;re (IT, hackers, et. al.) finally growing up.</div><br/></div></div></div></div><div id="41283210" class="c"><input type="checkbox" id="c-41283210" checked=""/><div class="controls bullet"><span class="by">bbminner</span><span>|</span><a href="#41282002">prev</a><span>|</span><a href="#41282671">next</a><span>|</span><label class="collapse" for="c-41283210">[-]</label><label class="expand" for="c-41283210">[6 more]</label></div><br/><div class="children"><div class="content">A complete novice question: I think I remember reading that Rust is moving from one of the standard type checking algorithms (this one?) to general purpose Z3 SMT for speed. Does type checking happen to have the same complexity as SMT? Or Z3 is just so insanely well optimized with heuristics and all that it happens to give better overall performance then problem specific checking algorithms with better theoretical performance (eg this one)?</div><br/><div id="41283428" class="c"><input type="checkbox" id="c-41283428" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41283210">parent</a><span>|</span><a href="#41283838">next</a><span>|</span><label class="collapse" for="c-41283428">[-]</label><label class="expand" for="c-41283428">[3 more]</label></div><br/><div class="children"><div class="content">I think you remember wrong. Rust is moving towards using a datalog engine, but for lifetime resolution (the project is called Polonius), not for type checking. Datalog engines have some similarities with SMT solvers so this might be what you&#x27;re thinking of.</div><br/><div id="41283688" class="c"><input type="checkbox" id="c-41283688" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#41283210">root</a><span>|</span><a href="#41283428">parent</a><span>|</span><a href="#41283909">next</a><span>|</span><label class="collapse" for="c-41283688">[-]</label><label class="expand" for="c-41283688">[1 more]</label></div><br/><div class="children"><div class="content">The Polonius rules were formulated using Datalog, but the implementation that will ship in rustc does not use Datalog: <a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;10&#x2F;06&#x2F;polonius-update.html" rel="nofollow">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;10&#x2F;06&#x2F;polonius-u...</a></div><br/></div></div><div id="41283909" class="c"><input type="checkbox" id="c-41283909" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#41283210">root</a><span>|</span><a href="#41283428">parent</a><span>|</span><a href="#41283688">prev</a><span>|</span><a href="#41283838">next</a><span>|</span><label class="collapse" for="c-41283909">[-]</label><label class="expand" for="c-41283909">[1 more]</label></div><br/><div class="children"><div class="content">The implementation based on the datalog engine was also found to be generally too slow and was replaced with an ad-hoc dataflow algorithm.</div><br/></div></div></div></div><div id="41283838" class="c"><input type="checkbox" id="c-41283838" checked=""/><div class="controls bullet"><span class="by">jahewson</span><span>|</span><a href="#41283210">parent</a><span>|</span><a href="#41283428">prev</a><span>|</span><a href="#41284612">next</a><span>|</span><label class="collapse" for="c-41283838">[-]</label><label class="expand" for="c-41283838">[1 more]</label></div><br/><div class="children"><div class="content">Having built a type checker with Z3 in the past, the simple answer to âdoes type checking happen to have the same complexity as SMT?â is no. Thatâs because the âTâ in SMT, âtheoriesâ can be pretty much anything - theyâre essentially plugins.<p>A more nuanced answer is that many problems are reducible to SAT, meaning that the answer can technically be yes, but a type checker that simply prints the message âUNSATâ upon failure isnât very useful!</div><br/></div></div><div id="41284612" class="c"><input type="checkbox" id="c-41284612" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41283210">parent</a><span>|</span><a href="#41283838">prev</a><span>|</span><a href="#41282671">next</a><span>|</span><label class="collapse" for="c-41284612">[-]</label><label class="expand" for="c-41284612">[1 more]</label></div><br/><div class="children"><div class="content">Unification is at the heart of type checking and unification is doable with a SMT solver. So a SMT solver can be a type checker if you want which should show that SMT is indeed much more complex than type checking.</div><br/></div></div></div></div><div id="41282671" class="c"><input type="checkbox" id="c-41282671" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#41283210">prev</a><span>|</span><label class="collapse" for="c-41282671">[-]</label><label class="expand" for="c-41282671">[3 more]</label></div><br/><div class="children"><div class="content">Title should say (2013) not (2022)</div><br/><div id="41282917" class="c"><input type="checkbox" id="c-41282917" checked=""/><div class="controls bullet"><span class="by">escape_key</span><span>|</span><a href="#41282671">parent</a><span>|</span><label class="collapse" for="c-41282917">[-]</label><label class="expand" for="c-41282917">[2 more]</label></div><br/><div class="children"><div class="content">Is says &quot;Last updated January 9, 2022&quot; at the bottom of the page.
But I guess the article is about the type checker version of February 2013?</div><br/><div id="41283513" class="c"><input type="checkbox" id="c-41283513" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41282671">root</a><span>|</span><a href="#41282917">parent</a><span>|</span><label class="collapse" for="c-41283513">[-]</label><label class="expand" for="c-41283513">[1 more]</label></div><br/><div class="children"><div class="content">This was updated in 2022 but was indeed written and originally published in 2013.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>