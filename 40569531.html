<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717491672767" as="style"/><link rel="stylesheet" href="styles.css?v=1717491672767"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tree-diffusion.github.io/">Diffusion on syntax trees for program synthesis</a> <span class="domain">(<a href="https://tree-diffusion.github.io">tree-diffusion.github.io</a>)</span></div><div class="subtext"><span>pouwerkerk</span> | <span>55 comments</span></div><br/><div><div id="40572202" class="c"><input type="checkbox" id="c-40572202" checked=""/><div class="controls bullet"><span class="by">grondilu</span><span>|</span><a href="#40570985">next</a><span>|</span><label class="collapse" for="c-40572202">[-]</label><label class="expand" for="c-40572202">[1 more]</label></div><br/><div class="children"><div class="content">The application to graphics is interesting.  It seems to me that current image generation models struggle with stylized pictures (&quot;ligne claire&quot; in comics, geometric shapes and so on).  After all this kinds of pictures should be easy to encode in vectoriel formats (like SVG), which are basically programming languages.</div><br/></div></div><div id="40570985" class="c"><input type="checkbox" id="c-40570985" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#40572202">prev</a><span>|</span><a href="#40569887">next</a><span>|</span><label class="collapse" for="c-40570985">[-]</label><label class="expand" for="c-40570985">[1 more]</label></div><br/><div class="children"><div class="content">This sounds more similar to what people have done with Racket and hint generation for MOOCs. Not sure which university it is again, but I saw a presentation about how they generate hints for students by mutating the syntax tree and analyzing how they had to modify it, to get to a target solution. It was presented at some RacketCon, maybe a decade ago already. Perhaps that knowledge how to do it can be combined with newer machine learning approaches?<p>EDIT: I found the talk: <a href="https:&#x2F;&#x2F;invidious.baczek.me&#x2F;watch?v=ijyFC36kVis" rel="nofollow">https:&#x2F;&#x2F;invidious.baczek.me&#x2F;watch?v=ijyFC36kVis</a></div><br/></div></div><div id="40569887" class="c"><input type="checkbox" id="c-40569887" checked=""/><div class="controls bullet"><span class="by">pmayrgundter</span><span>|</span><a href="#40570985">prev</a><span>|</span><a href="#40571436">next</a><span>|</span><label class="collapse" for="c-40569887">[-]</label><label class="expand" for="c-40569887">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny, this kind of subtree mutation was looked at pretty deeply by Koza and Adamı in the 90s under the rubric of Genetic Algorithms, but with a slightly different optimization function<p>One ref in the paper to 2000 for GAs for fast generation of program trees, but that&#x27;s missing the main show<p>Hope they&#x27;re reading this and dig into those guys work</div><br/><div id="40570480" class="c"><input type="checkbox" id="c-40570480" checked=""/><div class="controls bullet"><span class="by">verdverm</span><span>|</span><a href="#40569887">parent</a><span>|</span><a href="#40571788">next</a><span>|</span><label class="collapse" for="c-40570480">[-]</label><label class="expand" for="c-40570480">[1 more]</label></div><br/><div class="children"><div class="content">Some more recent alternatives to Koza&#x27;s GP use some very different search mechanisms. FFX &amp; PGE are both very fast.<p><a href="https:&#x2F;&#x2F;seminars.math.binghamton.edu&#x2F;ComboSem&#x2F;worm-chiu.pge_gecco2013.pdf" rel="nofollow">https:&#x2F;&#x2F;seminars.math.binghamton.edu&#x2F;ComboSem&#x2F;worm-chiu.pge_...</a><p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2209.09675" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2209.09675</a><p>I authored PGE and have thought that RL, and more recently diffusion techniques, might help these algos. All of the algos need better ways to guide the search, or help it get unstuck from local optima, which happens surprisingly fast. Most work in GP &#x2F; EVO is about avoiding premature convergence.</div><br/></div></div><div id="40571788" class="c"><input type="checkbox" id="c-40571788" checked=""/><div class="controls bullet"><span class="by">teruakohatu</span><span>|</span><a href="#40569887">parent</a><span>|</span><a href="#40570480">prev</a><span>|</span><a href="#40570083">next</a><span>|</span><label class="collapse" for="c-40571788">[-]</label><label class="expand" for="c-40571788">[1 more]</label></div><br/><div class="children"><div class="content">These kind of Genetic Algorithms are still being researched in academia. I attended a seminar a couple of years ago on the subject. It’s still a total dead end imho.</div><br/></div></div><div id="40570083" class="c"><input type="checkbox" id="c-40570083" checked=""/><div class="controls bullet"><span class="by">tithe</span><span>|</span><a href="#40569887">parent</a><span>|</span><a href="#40571788">prev</a><span>|</span><a href="#40569953">next</a><span>|</span><label class="collapse" for="c-40570083">[-]</label><label class="expand" for="c-40570083">[1 more]</label></div><br/><div class="children"><div class="content">Are these the references?<p>- <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20021224053225&#x2F;http:&#x2F;&#x2F;smi-web.stanford.edu&#x2F;pubs&#x2F;SMI_Abstracts&#x2F;SMI-2000-0851.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20021224053225&#x2F;http:&#x2F;&#x2F;smi-web.st...</a><p>- <a href="https:&#x2F;&#x2F;www.genetic-programming.com&#x2F;jkpdf&#x2F;tr1314.pdf" rel="nofollow">https:&#x2F;&#x2F;www.genetic-programming.com&#x2F;jkpdf&#x2F;tr1314.pdf</a></div><br/></div></div><div id="40569953" class="c"><input type="checkbox" id="c-40569953" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#40569887">parent</a><span>|</span><a href="#40570083">prev</a><span>|</span><a href="#40571436">next</a><span>|</span><label class="collapse" for="c-40569953">[-]</label><label class="expand" for="c-40569953">[4 more]</label></div><br/><div class="children"><div class="content">You can also say backpropagation is the chain rule from centuries ago.</div><br/><div id="40570615" class="c"><input type="checkbox" id="c-40570615" checked=""/><div class="controls bullet"><span class="by">telotortium</span><span>|</span><a href="#40569887">root</a><span>|</span><a href="#40569953">parent</a><span>|</span><a href="#40570471">next</a><span>|</span><label class="collapse" for="c-40570615">[-]</label><label class="expand" for="c-40570615">[2 more]</label></div><br/><div class="children"><div class="content">It is a computationally clever application of the chain rule to minimize the amount of computation needed to compute gradients for all parameters in the network.</div><br/><div id="40571182" class="c"><input type="checkbox" id="c-40571182" checked=""/><div class="controls bullet"><span class="by">om8</span><span>|</span><a href="#40569887">root</a><span>|</span><a href="#40570615">parent</a><span>|</span><a href="#40570471">next</a><span>|</span><label class="collapse" for="c-40571182">[-]</label><label class="expand" for="c-40571182">[1 more]</label></div><br/><div class="children"><div class="content">&gt; to minimize the amount of computation<p>IMO backprop is the most trivial implementation of differentiation in neural networks. Do you know an easier way to compute gradients with larger overhead? If so, please share it.</div><br/></div></div></div></div><div id="40570471" class="c"><input type="checkbox" id="c-40570471" checked=""/><div class="controls bullet"><span class="by">elijahbenizzy</span><span>|</span><a href="#40569887">root</a><span>|</span><a href="#40569953">parent</a><span>|</span><a href="#40570615">prev</a><span>|</span><a href="#40571436">next</a><span>|</span><label class="collapse" for="c-40570471">[-]</label><label class="expand" for="c-40570471">[1 more]</label></div><br/><div class="children"><div class="content">Backpropogration is just an application of the chain rule -- cool that we all learned it in high school!</div><br/></div></div></div></div></div></div><div id="40571436" class="c"><input type="checkbox" id="c-40571436" checked=""/><div class="controls bullet"><span class="by">lwansbrough</span><span>|</span><a href="#40569887">prev</a><span>|</span><a href="#40571258">next</a><span>|</span><label class="collapse" for="c-40571436">[-]</label><label class="expand" for="c-40571436">[1 more]</label></div><br/><div class="children"><div class="content">I’d like to see it with SDFs!</div><br/></div></div><div id="40571258" class="c"><input type="checkbox" id="c-40571258" checked=""/><div class="controls bullet"><span class="by">flakiness</span><span>|</span><a href="#40571436">prev</a><span>|</span><a href="#40570850">next</a><span>|</span><label class="collapse" for="c-40571258">[-]</label><label class="expand" for="c-40571258">[1 more]</label></div><br/><div class="children"><div class="content">The PDF is super slow to render, I guess because it contains commands from programmatically generated figures. It gives it a kind of an academic-paper-feel I miss these days.<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2405.20519" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2405.20519</a></div><br/></div></div><div id="40570850" class="c"><input type="checkbox" id="c-40570850" checked=""/><div class="controls bullet"><span class="by">gastonmorixe</span><span>|</span><a href="#40571258">prev</a><span>|</span><a href="#40570252">next</a><span>|</span><label class="collapse" for="c-40570850">[-]</label><label class="expand" for="c-40570850">[6 more]</label></div><br/><div class="children"><div class="content">could diffusion work at binary level? I mean, could we train a diffusion model to generate a final binary of a program given a prompt? probably AST may be better but the binary I feel is extremely easy to at least test fast if it works or not. Though there may be a lot of drawbacks, if this is possible I can&#x27;t wait until we ask &quot;give me an app that does that&quot; and the diffusion model starts generating all te bytes the app to do the job. Just wondering</div><br/><div id="40571093" class="c"><input type="checkbox" id="c-40571093" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#40570850">parent</a><span>|</span><a href="#40570901">next</a><span>|</span><label class="collapse" for="c-40571093">[-]</label><label class="expand" for="c-40571093">[1 more]</label></div><br/><div class="children"><div class="content">Editing with feedback from program output, like in this work, could be more closely applicable if you first disassemble the binary and have it edit things in the assembly language AST, then reassemble. This would result in a higher likelihood of creating a valid program.</div><br/></div></div><div id="40570901" class="c"><input type="checkbox" id="c-40570901" checked=""/><div class="controls bullet"><span class="by">dcreater</span><span>|</span><a href="#40570850">parent</a><span>|</span><a href="#40571093">prev</a><span>|</span><a href="#40570252">next</a><span>|</span><label class="collapse" for="c-40570901">[-]</label><label class="expand" for="c-40570901">[4 more]</label></div><br/><div class="children"><div class="content">That would be mind blowing. Why go through all the lost intermediary steps, especially through Python and JS, when you can generate machine code directly</div><br/><div id="40570979" class="c"><input type="checkbox" id="c-40570979" checked=""/><div class="controls bullet"><span class="by">eternauta3k</span><span>|</span><a href="#40570850">root</a><span>|</span><a href="#40570901">parent</a><span>|</span><a href="#40570926">next</a><span>|</span><label class="collapse" for="c-40570979">[-]</label><label class="expand" for="c-40570979">[2 more]</label></div><br/><div class="children"><div class="content">If your model is error-prone, having control structures, types and other compile-time checks is very valuable. It&#x27;s harder to constrain arbitrary machine code to make something sensible.</div><br/><div id="40571688" class="c"><input type="checkbox" id="c-40571688" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#40570850">root</a><span>|</span><a href="#40570979">parent</a><span>|</span><a href="#40570926">next</a><span>|</span><label class="collapse" for="c-40571688">[-]</label><label class="expand" for="c-40571688">[1 more]</label></div><br/><div class="children"><div class="content">Intuitively it makes sense, but I am not fully convinced about this. You could give it only a few register and discard invalid operations for certain registers or plain known invalid operations.</div><br/></div></div></div></div><div id="40570926" class="c"><input type="checkbox" id="c-40570926" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#40570850">root</a><span>|</span><a href="#40570901">parent</a><span>|</span><a href="#40570979">prev</a><span>|</span><a href="#40570252">next</a><span>|</span><label class="collapse" for="c-40570926">[-]</label><label class="expand" for="c-40570926">[1 more]</label></div><br/><div class="children"><div class="content">Interpretability, reasoning about the generated code, portability, etc.  Probably also demands a larger model with a higher cost of training (and likely more training data) to target a more unstructured &quot;language&quot; like machine code.</div><br/></div></div></div></div></div></div><div id="40570252" class="c"><input type="checkbox" id="c-40570252" checked=""/><div class="controls bullet"><span class="by">dinobones</span><span>|</span><a href="#40570850">prev</a><span>|</span><a href="#40571137">next</a><span>|</span><label class="collapse" for="c-40570252">[-]</label><label class="expand" for="c-40570252">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand the &quot;magic&quot; here.<p>In a traditional approach, you would generate random images, calculate some distance metric, then use some optimization method like simulated annealing to minimize the distance.<p>I get that the difference between the image representations is being optimzied here, but how is it possible that changing tokens in a program is differentiable?</div><br/><div id="40570278" class="c"><input type="checkbox" id="c-40570278" checked=""/><div class="controls bullet"><span class="by">revalo</span><span>|</span><a href="#40570252">parent</a><span>|</span><a href="#40571137">next</a><span>|</span><label class="collapse" for="c-40570278">[-]</label><label class="expand" for="c-40570278">[1 more]</label></div><br/><div class="children"><div class="content">Changing tokens in a program is not differentiable. For me, the key idea is that you can train a neural model to suggest edits to programs by randomly mutating nodes. And when you run this neural model, you get to make edits that are syntactically correct (i.e., a number will only replace a number etc.) according to a context-free grammar.</div><br/></div></div></div></div><div id="40571137" class="c"><input type="checkbox" id="c-40571137" checked=""/><div class="controls bullet"><span class="by">aquarius0</span><span>|</span><a href="#40570252">prev</a><span>|</span><a href="#40570264">next</a><span>|</span><label class="collapse" for="c-40571137">[-]</label><label class="expand" for="c-40571137">[1 more]</label></div><br/><div class="children"><div class="content">The application to inverse graphics tasks reminds me of this paper which was released one week earlier: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2405.15306" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2405.15306</a></div><br/></div></div><div id="40570264" class="c"><input type="checkbox" id="c-40570264" checked=""/><div class="controls bullet"><span class="by">montyanderson</span><span>|</span><a href="#40571137">prev</a><span>|</span><a href="#40569821">next</a><span>|</span><label class="collapse" for="c-40570264">[-]</label><label class="expand" for="c-40570264">[2 more]</label></div><br/><div class="children"><div class="content">This is fascinating. I&#x27;ve been trying to envisage how the new language models will have deeper or lower-level role in software production than simple code generation.</div><br/><div id="40572046" class="c"><input type="checkbox" id="c-40572046" checked=""/><div class="controls bullet"><span class="by">passion__desire</span><span>|</span><a href="#40570264">parent</a><span>|</span><a href="#40569821">next</a><span>|</span><label class="collapse" for="c-40572046">[-]</label><label class="expand" for="c-40572046">[1 more]</label></div><br/><div class="children"><div class="content">I think browsers could be the next iteration. Website backend will have premade flows. e.g. a transfer money from my account to another account, etc. And through fluidic UIs, the website will collect info need, necessary approvals before flow submission. AI-based browser DOM manipulation.</div><br/></div></div></div></div><div id="40569821" class="c"><input type="checkbox" id="c-40569821" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#40570264">prev</a><span>|</span><a href="#40570024">next</a><span>|</span><label class="collapse" for="c-40569821">[-]</label><label class="expand" for="c-40569821">[7 more]</label></div><br/><div class="children"><div class="content">This is very cool! My first thought is: can this be applied to converting raster graphics to vector graphics (eg PNG to SVG)? Seems like a very similar problem, though probably much more computationally expensive.</div><br/><div id="40569888" class="c"><input type="checkbox" id="c-40569888" checked=""/><div class="controls bullet"><span class="by">szvsw</span><span>|</span><a href="#40569821">parent</a><span>|</span><a href="#40570024">next</a><span>|</span><label class="collapse" for="c-40569888">[-]</label><label class="expand" for="c-40569888">[6 more]</label></div><br/><div class="children"><div class="content">&gt; We apply our approach to inverse graphics tasks, where our model learns to convert images into programs that produce those images.<p>I would argue that at least on a philosophical level, this is, definitionally, the process of converting raster graphics to vector graphics, as long as you by the premise that the difference between the two is simply that vector gfx is a programmatic&#x2F;imperative representation of image generation, while raster is a data structure&#x2F;declarative representation of images.<p>In other words, simply put, raster images are just arrays, vector images are sequences of instructions. Raster images are naturally much closer to the “raw” data needed by the output mechanism, while vector images require a much more complex interpreter.</div><br/><div id="40571891" class="c"><input type="checkbox" id="c-40571891" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#40569821">root</a><span>|</span><a href="#40569888">parent</a><span>|</span><a href="#40569932">next</a><span>|</span><label class="collapse" for="c-40571891">[-]</label><label class="expand" for="c-40571891">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  vector gfx is a programmatic&#x2F;imperative representation of image generation, while raster is a data structure&#x2F;declarative representation of images.<p>This seems a bit off to me.<p>Aside from oddities such as Postscript, most vector formats are canonical examples of declarative code. The distinction is more about what is being represented rather than how it is represented.</div><br/></div></div><div id="40569932" class="c"><input type="checkbox" id="c-40569932" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#40569821">root</a><span>|</span><a href="#40569888">parent</a><span>|</span><a href="#40571891">prev</a><span>|</span><a href="#40570024">next</a><span>|</span><label class="collapse" for="c-40569932">[-]</label><label class="expand" for="c-40569932">[4 more]</label></div><br/><div class="children"><div class="content">Or, raster and vector images are philosophically <i>the same thing</i>. The only difference is that vector has more operations than raster. Raster just has &quot;draw unit square at integer coordinates&quot;.</div><br/><div id="40571112" class="c"><input type="checkbox" id="c-40571112" checked=""/><div class="controls bullet"><span class="by">DougBTX</span><span>|</span><a href="#40569821">root</a><span>|</span><a href="#40569932">parent</a><span>|</span><a href="#40569972">next</a><span>|</span><label class="collapse" for="c-40571112">[-]</label><label class="expand" for="c-40571112">[2 more]</label></div><br/><div class="children"><div class="content">On the other hand, A Pixel Is Not A Little Square[0] would disagree, a raster is a grid sample of a continuous function.<p>[0] <a href="http:&#x2F;&#x2F;alvyray.com&#x2F;Memos&#x2F;CG&#x2F;Microsoft&#x2F;6_pixel.pdf" rel="nofollow">http:&#x2F;&#x2F;alvyray.com&#x2F;Memos&#x2F;CG&#x2F;Microsoft&#x2F;6_pixel.pdf</a></div><br/><div id="40571422" class="c"><input type="checkbox" id="c-40571422" checked=""/><div class="controls bullet"><span class="by">code_biologist</span><span>|</span><a href="#40569821">root</a><span>|</span><a href="#40571112">parent</a><span>|</span><a href="#40569972">next</a><span>|</span><label class="collapse" for="c-40571422">[-]</label><label class="expand" for="c-40571422">[1 more]</label></div><br/><div class="children"><div class="content">Though I agree with the point that paper makes (it makes a good case that the little square mental model of a pixel is mostly inappropriate) it does seem focused on imaging and does not mention places where the little square mental model is appropriate.<p>Pictures of cats, subpixel rendered text, or company logo SVGs as displayed on a web page are point samples and not little squares.<p>User interfaces are good examples of often being little squares. Calling HN&#x27;s beige background a point sampled discrete representation of an underlying continuous function seems pretty tortured — to me it seems like a bunch of beige little squares.</div><br/></div></div></div></div><div id="40569972" class="c"><input type="checkbox" id="c-40569972" checked=""/><div class="controls bullet"><span class="by">szvsw</span><span>|</span><a href="#40569821">root</a><span>|</span><a href="#40569932">parent</a><span>|</span><a href="#40571112">prev</a><span>|</span><a href="#40570024">next</a><span>|</span><label class="collapse" for="c-40569972">[-]</label><label class="expand" for="c-40569972">[1 more]</label></div><br/><div class="children"><div class="content">Yep, I agree with this - tried to hint at that when I said “vector images require a much more complex interpreter”.</div><br/></div></div></div></div></div></div></div></div><div id="40570024" class="c"><input type="checkbox" id="c-40570024" checked=""/><div class="controls bullet"><span class="by">pamelafox</span><span>|</span><a href="#40569821">prev</a><span>|</span><a href="#40570336">next</a><span>|</span><label class="collapse" for="c-40570024">[-]</label><label class="expand" for="c-40570024">[1 more]</label></div><br/><div class="children"><div class="content">I would love to see them try this with the Processing&#x2F;P5Js libraries. Thats what the ASTs reminded me of. It could potentially be used to help students trying to figure out how to fix their programs. I used AST-based hints for my ProcessingJS courses on Khan Academy, but I handwrote the AST patterns for those hints.</div><br/></div></div><div id="40570336" class="c"><input type="checkbox" id="c-40570336" checked=""/><div class="controls bullet"><span class="by">artninja1988</span><span>|</span><a href="#40570024">prev</a><span>|</span><a href="#40570112">next</a><span>|</span><label class="collapse" for="c-40570336">[-]</label><label class="expand" for="c-40570336">[7 more]</label></div><br/><div class="children"><div class="content">Surprised to see Stuart Russells name on this as I thought he was fully consumed by the doomsday cult. Although he&#x27;s last author so he&#x27;s probably only on it because he&#x27;s the head of the lab</div><br/><div id="40571809" class="c"><input type="checkbox" id="c-40571809" checked=""/><div class="controls bullet"><span class="by">robxorb</span><span>|</span><a href="#40570336">parent</a><span>|</span><a href="#40570562">next</a><span>|</span><label class="collapse" for="c-40571809">[-]</label><label class="expand" for="c-40571809">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s with the last author&#x2F;first author thing in science papers?<p>I&#x27;ve read several times that the author listed last is usually the most significant contributor, and the first author the least significant, due to some kind of tradition around modesty plus favourably introducing new names. (Which then of course doesn&#x27;t work, if everyone knows it&#x27;s happening...)<p>Here, you&#x27;ve interpreted it as the reverse, and by that I mean in the sensible way - did you not know about the tradition, or are you wrong? And how can we know either way for sure?</div><br/><div id="40572066" class="c"><input type="checkbox" id="c-40572066" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#40570336">root</a><span>|</span><a href="#40571809">parent</a><span>|</span><a href="#40571876">next</a><span>|</span><label class="collapse" for="c-40572066">[-]</label><label class="expand" for="c-40572066">[1 more]</label></div><br/><div class="children"><div class="content">Conventions vary by field, but within a specific field they&#x27;re usually pretty consistent. In natural sciences (except large physics papers) the convention is that the first author is the one doing most of the practical work. The last author is the PI (principal investigator) of the group who had a hand in designing the experiments and oversaw the research. Now, the latter can mean anything from barely doing any work on the paper to being deeply involved in the research.<p>If you&#x27;re reading papers most of the time the last author is more meaningful to you because they&#x27;re the senior researcher, you know their research interests and what kind of papers they produce. The first authors are PhD students and PostDocs, they change much more often.</div><br/></div></div><div id="40571876" class="c"><input type="checkbox" id="c-40571876" checked=""/><div class="controls bullet"><span class="by">optimalsolver</span><span>|</span><a href="#40570336">root</a><span>|</span><a href="#40571809">parent</a><span>|</span><a href="#40572066">prev</a><span>|</span><a href="#40570562">next</a><span>|</span><label class="collapse" for="c-40571876">[-]</label><label class="expand" for="c-40571876">[1 more]</label></div><br/><div class="children"><div class="content">&gt;the author listed last is usually the most significant contributor<p>Where did you read that?<p>That&#x27;s definitely not the case in machine learning.</div><br/></div></div></div></div><div id="40570562" class="c"><input type="checkbox" id="c-40570562" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40570336">parent</a><span>|</span><a href="#40571809">prev</a><span>|</span><a href="#40570701">next</a><span>|</span><label class="collapse" for="c-40570562">[-]</label><label class="expand" for="c-40570562">[2 more]</label></div><br/><div class="children"><div class="content">A lot of doomers work on AI. While frowning, and shaking their heads very gravely, so you know they don&#x27;t approve.</div><br/><div id="40571573" class="c"><input type="checkbox" id="c-40571573" checked=""/><div class="controls bullet"><span class="by">optimalsolver</span><span>|</span><a href="#40570336">root</a><span>|</span><a href="#40570562">parent</a><span>|</span><a href="#40570701">next</a><span>|</span><label class="collapse" for="c-40571573">[-]</label><label class="expand" for="c-40571573">[1 more]</label></div><br/><div class="children"><div class="content">If we don&#x27;t get to AGI first, the bad guys will.</div><br/></div></div></div></div><div id="40570701" class="c"><input type="checkbox" id="c-40570701" checked=""/><div class="controls bullet"><span class="by">ngruhn</span><span>|</span><a href="#40570336">parent</a><span>|</span><a href="#40570562">prev</a><span>|</span><a href="#40570112">next</a><span>|</span><label class="collapse" for="c-40570701">[-]</label><label class="expand" for="c-40570701">[1 more]</label></div><br/><div class="children"><div class="content">I haven’t heard anyone make sane case against the doomsday argument. Only attacks.</div><br/></div></div></div></div><div id="40570112" class="c"><input type="checkbox" id="c-40570112" checked=""/><div class="controls bullet"><span class="by">dwlg00</span><span>|</span><a href="#40570336">prev</a><span>|</span><a href="#40570425">next</a><span>|</span><label class="collapse" for="c-40570112">[-]</label><label class="expand" for="c-40570112">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m failing to see how this is novel. It looks like they&#x27;re doing diffusion on a representation system for 2D graphics, which is very different than an actual program (they do address this limitation to be fair)</div><br/><div id="40570290" class="c"><input type="checkbox" id="c-40570290" checked=""/><div class="controls bullet"><span class="by">revalo</span><span>|</span><a href="#40570112">parent</a><span>|</span><a href="#40570425">next</a><span>|</span><label class="collapse" for="c-40570290">[-]</label><label class="expand" for="c-40570290">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this is true! These are more like expressions rather than programs. We were mostly following the language used by previous work, <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1906.04604" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1906.04604</a></div><br/></div></div></div></div><div id="40570425" class="c"><input type="checkbox" id="c-40570425" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#40570112">prev</a><span>|</span><a href="#40569786">next</a><span>|</span><label class="collapse" for="c-40570425">[-]</label><label class="expand" for="c-40570425">[1 more]</label></div><br/><div class="children"><div class="content">How is it different from genetic algorithms that mutate the syntax tree until the target output is achieved?</div><br/></div></div></div></div></div></div></div></body></html>