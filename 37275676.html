<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693126853352" as="style"/><link rel="stylesheet" href="styles.css?v=1693126853352"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cacm.acm.org/news/275684-historic-algorithms-help-unlock-shortest-path-problem-breakthrough/fulltext">Historic algorithms help unlock shortest-path problem breakthrough</a> <span class="domain">(<a href="https://cacm.acm.org">cacm.acm.org</a>)</span></div><div class="subtext"><span>nxten</span> | <span>38 comments</span></div><br/><div><div id="37277448" class="c"><input type="checkbox" id="c-37277448" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#37279236">next</a><span>|</span><label class="collapse" for="c-37277448">[-]</label><label class="expand" for="c-37277448">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2203.03456" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2203.03456</a> And  <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2203.00671" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2203.00671</a> Are the relevant papers</div><br/></div></div><div id="37279236" class="c"><input type="checkbox" id="c-37279236" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#37277448">prev</a><span>|</span><a href="#37276162">next</a><span>|</span><label class="collapse" for="c-37279236">[-]</label><label class="expand" for="c-37279236">[2 more]</label></div><br/><div class="children"><div class="content">What is meant by &quot;nodes&quot; in this article?<p>&gt; sum of the number of nodes and connections<p>&gt; Bellman-Ford instead needs many more steps: The total is based on the product of the number of nodes and vertices.<p>&gt; reduced the complexity to the square root of the number of vertices multiplied by the number of nodes<p>At first I thought it was a synonym for vertices, in the same way the article inconsistently uses &quot;connections&quot; for edges. But then &quot;nodes&quot; gets used in the same breath as &quot;vertices&quot; in a way that contradicts that hypothesis.</div><br/><div id="37279726" class="c"><input type="checkbox" id="c-37279726" checked=""/><div class="controls bullet"><span class="by">brutusborn</span><span>|</span><a href="#37279236">parent</a><span>|</span><a href="#37276162">next</a><span>|</span><label class="collapse" for="c-37279726">[-]</label><label class="expand" for="c-37279726">[1 more]</label></div><br/><div class="children"><div class="content">I only had a quick skim but the first paper describes a graph transformation to remove cycles. So I think that nodes are essentially a subgraph of vertices that contain cycles.</div><br/></div></div></div></div><div id="37276162" class="c"><input type="checkbox" id="c-37276162" checked=""/><div class="controls bullet"><span class="by">ozarker</span><span>|</span><a href="#37279236">prev</a><span>|</span><a href="#37276118">next</a><span>|</span><label class="collapse" for="c-37276162">[-]</label><label class="expand" for="c-37276162">[32 more]</label></div><br/><div class="children"><div class="content">What’s an application where you’d absolutely have to have a graph with negative weights? Couldn’t you just preprocess the edges and normalize their weights?</div><br/><div id="37276563" class="c"><input type="checkbox" id="c-37276563" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#37276162">parent</a><span>|</span><a href="#37276726">next</a><span>|</span><label class="collapse" for="c-37276563">[-]</label><label class="expand" for="c-37276563">[7 more]</label></div><br/><div class="children"><div class="content">A prototypical example today is to take battery range into account in navigation.  You charge your battery going downhill, corresponding to a negative edge weight.  If you&#x27;re driving from the top of a mountain, through a valley, to the top of a hill, many of the available routes might end up with a negative cost!<p>Preprocessing is certainly possible, but the result is to densify the graph.  That densification can turn a sparse graph with O(n) edges into a dense graph with O(n^2) edges.  When the goal is to keep pathfinding to a nearly-linear (roughly O(vertices + edges) with log factors) runtime in the presence of negative weight edges, naive preprocessing blows the budget before you even start pathfinding.<p>The article at hand presents long-sought after algorithms which hit the near-linear runtime goal at the cost of a combination of clever preprocessing and a novel divide&amp;conquer approach.  So yes, preprocessing, no, not &quot;just&quot; preprocessing.</div><br/><div id="37277342" class="c"><input type="checkbox" id="c-37277342" checked=""/><div class="controls bullet"><span class="by">thethirdone</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276563">parent</a><span>|</span><a href="#37276726">next</a><span>|</span><label class="collapse" for="c-37277342">[-]</label><label class="expand" for="c-37277342">[6 more]</label></div><br/><div class="children"><div class="content">You can preprocess the battery range problem quite efficiently. If is not possible to gain more charge than the gravitational potential between the endpoints for any path. You can change all of the edge weights from battery charge changes into battery charge as compared to a perfectly efficient car.<p>This would make a downhill edge A-&gt;B and uphill edge B-&gt;A both have approximately the cost of the average between them which should be decidedly non-negative.</div><br/><div id="37277983" class="c"><input type="checkbox" id="c-37277983" checked=""/><div class="controls bullet"><span class="by">Retric</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37277342">parent</a><span>|</span><a href="#37277429">next</a><span>|</span><label class="collapse" for="c-37277983">[-]</label><label class="expand" for="c-37277983">[4 more]</label></div><br/><div class="children"><div class="content">The potential energy from going down hill varies based on vehicle load.  A pickup truck filled with gravel or an SUV hauling a trailer would be in a very different situation than the same vehicle making the trip empty the next day.<p>Driver behavior, wind, heater use, preconditioning the battery, etc mean this stuff really should be computed in real time by the vehicle in question.</div><br/><div id="37278078" class="c"><input type="checkbox" id="c-37278078" checked=""/><div class="controls bullet"><span class="by">thethirdone</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37277983">parent</a><span>|</span><a href="#37277429">next</a><span>|</span><label class="collapse" for="c-37278078">[-]</label><label class="expand" for="c-37278078">[3 more]</label></div><br/><div class="children"><div class="content">Vehicle load will also affect charge loss on flat ground. The entire graph would need to be updated for a different vehicle or load setup.<p>I was simply stating that it is possible to update a graph with negative edges into one with only positive edges in O(E) preprocessing time for this usecase.</div><br/><div id="37278646" class="c"><input type="checkbox" id="c-37278646" checked=""/><div class="controls bullet"><span class="by">Retric</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37278078">parent</a><span>|</span><a href="#37277429">next</a><span>|</span><label class="collapse" for="c-37278646">[-]</label><label class="expand" for="c-37278646">[2 more]</label></div><br/><div class="children"><div class="content">Even that’s a false assumption, the weighs may depend both on the vehicle’s starting position and the path it took.<p>Suppose you’re starting at 1 mile of altitude and your destination is at sea level.  You might gain change over the trip, except if the vehicles battery ever hits full charge you can’t store the excess charge you should be gaining.<p>Net result you there are multiple paths to finish the trip with higher charge than you started with and the goal is pick the optimal one of those. The most efficient trip could therefore involve minimizing drops in altitude until you’ve freed up enough battery to contain that excess energy.</div><br/><div id="37278796" class="c"><input type="checkbox" id="c-37278796" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37278646">parent</a><span>|</span><a href="#37277429">next</a><span>|</span><label class="collapse" for="c-37278796">[-]</label><label class="expand" for="c-37278796">[1 more]</label></div><br/><div class="children"><div class="content">The problem with capacity limits is harder yet again and I don&#x27;t think the discussed algorithms help you (except in so far as if their optimal choice doesn&#x27;t hit the capacity limit, then its the optimal choice).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37276726" class="c"><input type="checkbox" id="c-37276726" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#37276162">parent</a><span>|</span><a href="#37276563">prev</a><span>|</span><a href="#37276232">next</a><span>|</span><label class="collapse" for="c-37276726">[-]</label><label class="expand" for="c-37276726">[2 more]</label></div><br/><div class="children"><div class="content">Its pretty hard to give <i>any</i> problem which you absolutely <i>have</i> to solve using only one particular technique.  Nevertheless, there are some problems which require more than just being able to add positive numbers together in order to solve.<p>Consider, for example, the problem of moving an electric car with regenerative braking along a grid of very hilly roads, using minimal charge from the battery. When you go down a hill, sure, you can add energy to your battery by hitting the brakes.   But when you go uphill again, you may have to drain your battery of charge.<p>Indeed, if you can find a course which is largely downhill, you may very well end uo with a &quot;negative amount of energy charged&quot; to the battery :-)</div><br/><div id="37277101" class="c"><input type="checkbox" id="c-37277101" checked=""/><div class="controls bullet"><span class="by">ozarker</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276726">parent</a><span>|</span><a href="#37276232">next</a><span>|</span><label class="collapse" for="c-37277101">[-]</label><label class="expand" for="c-37277101">[1 more]</label></div><br/><div class="children"><div class="content">That’s a great example. Thank you</div><br/></div></div></div></div><div id="37276232" class="c"><input type="checkbox" id="c-37276232" checked=""/><div class="controls bullet"><span class="by">bhl</span><span>|</span><a href="#37276162">parent</a><span>|</span><a href="#37276726">prev</a><span>|</span><a href="#37276531">next</a><span>|</span><label class="collapse" for="c-37276232">[-]</label><label class="expand" for="c-37276232">[9 more]</label></div><br/><div class="children"><div class="content">The issue with negative weighted edges is that a cycle would result in an infinite loop when finding shortest path, compared to when all edges are non-negative, cycles can be safely skipped.<p>Compared to Dijkstra&#x27;s original algorithm of E + V log V, naively pre-processing edges would require V^2 work assuming an edge can exist between each vertex.<p>Edit: the algorithm you’re describing exists btw <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Johnson%27s_algorithm" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Johnson%27s_algorithm</a></div><br/><div id="37276387" class="c"><input type="checkbox" id="c-37276387" checked=""/><div class="controls bullet"><span class="by">schneems</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276232">parent</a><span>|</span><a href="#37277166">next</a><span>|</span><label class="collapse" for="c-37276387">[-]</label><label class="expand" for="c-37276387">[4 more]</label></div><br/><div class="children"><div class="content">I think the question isn’t “what is the issue with negative weights” rather “what is a real world example of negative weights” which the article doesn’t really explain.<p>I don’t know any off hand. I would guess its when a path has a benefit incurred rather than a cost. I.e. in a monopoly board it might be shorter to get to a destination by getting thrown in jail first, but the longer path around the whole board comes with a benefit I.e. negative weight of receiving $200 by crossing the start.<p>Your reply does help clarify the “why not normalize” which is helpful. I’m still curious for other examples of negative weights.</div><br/><div id="37276433" class="c"><input type="checkbox" id="c-37276433" checked=""/><div class="controls bullet"><span class="by">bhl</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276387">parent</a><span>|</span><a href="#37277166">next</a><span>|</span><label class="collapse" for="c-37276433">[-]</label><label class="expand" for="c-37276433">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In finance, for example, there may be situations in currency or options trading where buying and selling in one sequence is more profitable than taking a different path, and these can be modeled using negative weights as long as the search algorithm is fast enough.<p>This is a non-contrived example. You could do this as a mini-project where you scrape various foreign exchange or cryptocurrency data, and try to find some arbitrage opportunities by running these shortest path algorithms.</div><br/><div id="37276720" class="c"><input type="checkbox" id="c-37276720" checked=""/><div class="controls bullet"><span class="by">schneems</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276433">parent</a><span>|</span><a href="#37277166">next</a><span>|</span><label class="collapse" for="c-37276720">[-]</label><label class="expand" for="c-37276720">[2 more]</label></div><br/><div class="children"><div class="content">To try to restate that. Someone owns currency A then buys B which is a cost, but it has a good exchange rate with currency C and C has a good exchange rate with A. So the B-C-A move yields a profit which would be representative as a negative weight. Is that right?</div><br/><div id="37278490" class="c"><input type="checkbox" id="c-37278490" checked=""/><div class="controls bullet"><span class="by">bhl</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276720">parent</a><span>|</span><a href="#37277166">next</a><span>|</span><label class="collapse" for="c-37278490">[-]</label><label class="expand" for="c-37278490">[1 more]</label></div><br/><div class="children"><div class="content">Yes, if trading BCA results in a profit, either BC or CA has negative weight. Negative weight here just means you can sell a currency more than its cost basis, and or buy a currency for cheaper than its cost basis.<p>Though with arbitrage, you typically want to find a cycle like BCAB so you have more of the initial currency you started off with.</div><br/></div></div></div></div></div></div></div></div><div id="37277166" class="c"><input type="checkbox" id="c-37277166" checked=""/><div class="controls bullet"><span class="by">empath-nirvana</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276232">parent</a><span>|</span><a href="#37276387">prev</a><span>|</span><a href="#37276967">next</a><span>|</span><label class="collapse" for="c-37277166">[-]</label><label class="expand" for="c-37277166">[2 more]</label></div><br/><div class="children"><div class="content">If I understand correctly, if you find such a loop in a graph of currency exchange rates, that would represent an arbitrage opportunity where you can basically make &quot;infinite money&quot; (although typically those loops close quickly if they&#x27;re exploitable in the real world).</div><br/><div id="37278465" class="c"><input type="checkbox" id="c-37278465" checked=""/><div class="controls bullet"><span class="by">bhl</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37277166">parent</a><span>|</span><a href="#37276967">next</a><span>|</span><label class="collapse" for="c-37278465">[-]</label><label class="expand" for="c-37278465">[1 more]</label></div><br/><div class="children"><div class="content">Yep! Executing arbitrage is definitely harder than finding they exist though.</div><br/></div></div></div></div><div id="37276967" class="c"><input type="checkbox" id="c-37276967" checked=""/><div class="controls bullet"><span class="by">heavenlyblue</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276232">parent</a><span>|</span><a href="#37277166">prev</a><span>|</span><a href="#37276531">next</a><span>|</span><label class="collapse" for="c-37276967">[-]</label><label class="expand" for="c-37276967">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The issue with negative weighted edges is that a cycle would result in an infinite loop when finding shortest path<p>No it &quot;could&quot; result in an infinite loop. For driving situations negative weights would probably never yield infinite cycles due to negative weight. For that to happen some laws of physics would need to change drastically (i.e. a longer path yielding lower energy usage the longer it gets is nonsensical in any sense that is sensical in the physical world)</div><br/><div id="37277028" class="c"><input type="checkbox" id="c-37277028" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276967">parent</a><span>|</span><a href="#37276531">next</a><span>|</span><label class="collapse" for="c-37277028">[-]</label><label class="expand" for="c-37277028">[1 more]</label></div><br/><div class="children"><div class="content">I use regenerative braking as a driving application -- you gain energy by going downhill.  A negative cycle would look like an Escher drawing.</div><br/></div></div></div></div></div></div><div id="37276531" class="c"><input type="checkbox" id="c-37276531" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#37276162">parent</a><span>|</span><a href="#37276232">prev</a><span>|</span><a href="#37276963">next</a><span>|</span><label class="collapse" for="c-37276531">[-]</label><label class="expand" for="c-37276531">[1 more]</label></div><br/><div class="children"><div class="content">The problem lies in the non-monotonous structure of the sequence of weight when combining positive and negative weights, which is incompatible with Dijkstra&#x27;s greedy search, which requires monotonous weight sequences in the traversal.</div><br/></div></div><div id="37276963" class="c"><input type="checkbox" id="c-37276963" checked=""/><div class="controls bullet"><span class="by">riedel</span><span>|</span><a href="#37276162">parent</a><span>|</span><a href="#37276531">prev</a><span>|</span><a href="#37276881">next</a><span>|</span><label class="collapse" for="c-37276963">[-]</label><label class="expand" for="c-37276963">[2 more]</label></div><br/><div class="children"><div class="content">&gt;In finance, for example, there may be situations in currency or options trading where buying and selling in one sequence is more profitable than taking a different path, and these can be modeled using negative weights as long as the search algorithm is fast enough. But those negative weights can throw Dijkstra&#x27;s shortest-path algorithm for a loop.</div><br/><div id="37278737" class="c"><input type="checkbox" id="c-37278737" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276963">parent</a><span>|</span><a href="#37276881">next</a><span>|</span><label class="collapse" for="c-37278737">[-]</label><label class="expand" for="c-37278737">[1 more]</label></div><br/><div class="children"><div class="content">The obvious model of that to me would involve all positive weights representing the exchange ratio, but a path through a graph like that wouldn&#x27;t be summing the edge weights. I guess the idea is that you weight the edges with the log of the exchange ratio?</div><br/></div></div></div></div><div id="37276881" class="c"><input type="checkbox" id="c-37276881" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#37276162">parent</a><span>|</span><a href="#37276963">prev</a><span>|</span><a href="#37277254">next</a><span>|</span><label class="collapse" for="c-37276881">[-]</label><label class="expand" for="c-37276881">[4 more]</label></div><br/><div class="children"><div class="content">What kind of normalization are you thinking of?
Like adding a constant to all edge weights?</div><br/><div id="37277468" class="c"><input type="checkbox" id="c-37277468" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276881">parent</a><span>|</span><a href="#37277254">next</a><span>|</span><label class="collapse" for="c-37277468">[-]</label><label class="expand" for="c-37277468">[3 more]</label></div><br/><div class="children"><div class="content">A sibling comment linking to Johnson&#x27;s algorithm shows a way to do it.<p>To me, adding a constant to all edges seems like an obvious idea to try-- but one issue is that it will distort the ranking for paths that have different numbers of edges.  Ideally a normalisation would preserve the ranking of paths so that a path with minimal unnormalised weight would also be a path of minimal normalised weight. But ranking won&#x27;t be preserved by adding a constant C to all edge weights, now paths with more edges will be unfairly penalised.</div><br/><div id="37278289" class="c"><input type="checkbox" id="c-37278289" checked=""/><div class="controls bullet"><span class="by">pedrosorio</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37277468">parent</a><span>|</span><a href="#37278428">next</a><span>|</span><label class="collapse" for="c-37278289">[-]</label><label class="expand" for="c-37278289">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To me, adding a constant to all edges seems like an obvious idea to try<p>Yeah, as you explained that is not useful because it does not preserve the shortest-path of the original graph (which is the reason we are making all edges non-negative in the first place).<p>That is why Johnson&#x27;s algorithm adds an edge-dependent weight to each of the edges.</div><br/></div></div><div id="37278428" class="c"><input type="checkbox" id="c-37278428" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37277468">parent</a><span>|</span><a href="#37278289">prev</a><span>|</span><a href="#37277254">next</a><span>|</span><label class="collapse" for="c-37278428">[-]</label><label class="expand" for="c-37278428">[1 more]</label></div><br/><div class="children"><div class="content">Johnson&#x27;s algorithm appears to run Bellman–Ford as a sub-routine.<p>At that point you are already spending |V||E| time, so you are not getting anywhere close to the performance of Dijkstra and the new algorithm.<p>But I guess you are saying that this preprocessing is OK if you need to run many single-source-shortest-path queries on the graph.</div><br/></div></div></div></div></div></div><div id="37277254" class="c"><input type="checkbox" id="c-37277254" checked=""/><div class="controls bullet"><span class="by">gnull</span><span>|</span><a href="#37276162">parent</a><span>|</span><a href="#37276881">prev</a><span>|</span><a href="#37276578">next</a><span>|</span><label class="collapse" for="c-37277254">[-]</label><label class="expand" for="c-37277254">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Couldn’t you just preprocess the edges and normalize their weights?<p>How exactly?</div><br/><div id="37278734" class="c"><input type="checkbox" id="c-37278734" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37277254">parent</a><span>|</span><a href="#37279414">next</a><span>|</span><label class="collapse" for="c-37278734">[-]</label><label class="expand" for="c-37278734">[1 more]</label></div><br/><div class="children"><div class="content">Just find the most negative weight and add that to all of the weights?<p>Edit: Oops, as another commenter points out above, this penalizes paths with more steps. I knew it was too easy. :P</div><br/></div></div><div id="37279414" class="c"><input type="checkbox" id="c-37279414" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37277254">parent</a><span>|</span><a href="#37278734">prev</a><span>|</span><a href="#37276578">next</a><span>|</span><label class="collapse" for="c-37279414">[-]</label><label class="expand" for="c-37279414">[1 more]</label></div><br/><div class="children"><div class="content">Assuming a directed graph. At the entry to each negative edge collect all the nodes reachable in 1 extra hop from that edge and compute the total cost. All that have a positive weight, add as edges from the source of the negative edge. If they still have a negative weight, expand further. Once you&#x27;re done, drop all the negative edges.  This essentially replaces every negative edge with a set of &#x27;shortcuts&#x27; that encode all the places the negative edge could have gotten you, such that the shortcuts have positive cost.  Use regular Dijkstra on the augmented graph.<p>This obviously has a potentially exponential complexity, though it will work if there isn&#x27;t too much negativity.  It should at least be enough to convince you that preprocessing is possible absent the existence of negative cost loops.</div><br/></div></div></div></div><div id="37276578" class="c"><input type="checkbox" id="c-37276578" checked=""/><div class="controls bullet"><span class="by">bunabhucan</span><span>|</span><a href="#37276162">parent</a><span>|</span><a href="#37277254">prev</a><span>|</span><a href="#37276898">next</a><span>|</span><label class="collapse" for="c-37276578">[-]</label><label class="expand" for="c-37276578">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m an uber eats driver picking up a long delivery but notifications comes in for grubhub and Doordash for two short deliveries with pickups and dropoffs along my existing route.</div><br/><div id="37278171" class="c"><input type="checkbox" id="c-37278171" checked=""/><div class="controls bullet"><span class="by">zaroth</span><span>|</span><a href="#37276162">root</a><span>|</span><a href="#37276578">parent</a><span>|</span><a href="#37276898">next</a><span>|</span><label class="collapse" for="c-37278171">[-]</label><label class="expand" for="c-37278171">[1 more]</label></div><br/><div class="children"><div class="content">But if you make all those stops while my food gets cold, I’m definitely going to call support and reduce the tip!</div><br/></div></div></div></div></div></div><div id="37278334" class="c"><input type="checkbox" id="c-37278334" checked=""/><div class="controls bullet"><span class="by">pradn</span><span>|</span><a href="#37276118">prev</a><span>|</span><label class="collapse" for="c-37278334">[-]</label><label class="expand" for="c-37278334">[1 more]</label></div><br/><div class="children"><div class="content">This is precisely the sort of article where a bit of notation and interactive graphics would go far in presenting the information. Anyone who can understand this article knows big-O notation. It&#x27;s silly to assume the article is more accessible just because it&#x27;s in English.</div><br/></div></div></div></div></div></div></div></body></html>