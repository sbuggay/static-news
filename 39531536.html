<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709110850068" as="style"/><link rel="stylesheet" href="styles.css?v=1709110850068"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://testcontainers.com/">Testcontainers</a> <span class="domain">(<a href="https://testcontainers.com">testcontainers.com</a>)</span></div><div class="subtext"><span>floriangosse</span> | <span>149 comments</span></div><br/><div><div id="39533936" class="c"><input type="checkbox" id="c-39533936" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#39532187">next</a><span>|</span><label class="collapse" for="c-39533936">[-]</label><label class="expand" for="c-39533936">[13 more]</label></div><br/><div class="children"><div class="content">I did not come in here expecting to read such effusive praise for testcontainers. If you’re coming from a place where docker wasn’t really a thing I can see how it looks beautiful. And in a fair amount of use cases it can be really nice. But if you want it to play well with any other containerized workflow, good freaking luck.<p>Testcontainers is <i>the</i> library that convinced me that shelling out to docker as an abstraction via bash calls embedded in a library is a bad idea. Not because containerization as an abstraction is a bad idea. Rather it’s that having a library that custom shell calls to the docker CLI as part of its core functionality creates problems and complexity as soon as one introduces other containerized workflows. The library has the nasty habit of assuming it’s running on a host machine and nothing else docker related is running, and footguns itself with limitations accordingly. This makes it not much better than some non dockerized library in most cases and oftentimes much much worse.</div><br/><div id="39535618" class="c"><input type="checkbox" id="c-39535618" checked=""/><div class="controls bullet"><span class="by">razemio</span><span>|</span><a href="#39533936">parent</a><span>|</span><a href="#39534475">next</a><span>|</span><label class="collapse" for="c-39535618">[-]</label><label class="expand" for="c-39535618">[1 more]</label></div><br/><div class="children"><div class="content">Never had any issues. We have 100+ build jobs running on Jenkins and most of them have some Testcontainer tests. These never collide if implemented correctly (randomised ports with check for e.g.) even when run in parallel. 
On my machine running several docker dev environments it was also never an issue.
Can you specify what issues you had? Also I am pretty sure the library does not work as you describe. Isn&#x27;t it using the Docker Engine API? I could be mistaken, never checked the source code.<p>Edit: Just checked the documentation. According to the docs it is using the Docker API.</div><br/></div></div><div id="39534475" class="c"><input type="checkbox" id="c-39534475" checked=""/><div class="controls bullet"><span class="by">simonkagedal</span><span>|</span><a href="#39533936">parent</a><span>|</span><a href="#39535618">prev</a><span>|</span><a href="#39535391">next</a><span>|</span><label class="collapse" for="c-39534475">[-]</label><label class="expand" for="c-39534475">[5 more]</label></div><br/><div class="children"><div class="content">Testcontainers is not shelling out to the docker CLI; at least on Java, it is using a Java implementation of the docker network protocol, and I believe that’s the case also for the other platforms.<p>Not sure this matters for the core argument you are making, just thought I’d point it out.</div><br/><div id="39534944" class="c"><input type="checkbox" id="c-39534944" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39533936">root</a><span>|</span><a href="#39534475">parent</a><span>|</span><a href="#39535391">next</a><span>|</span><label class="collapse" for="c-39534944">[-]</label><label class="expand" for="c-39534944">[4 more]</label></div><br/><div class="children"><div class="content">The comment you are replying to makes so many mistakes about how Testcontainers works on Java that I&#x27;m not sure what source code the commenter is looking at.</div><br/><div id="39535633" class="c"><input type="checkbox" id="c-39535633" checked=""/><div class="controls bullet"><span class="by">CodeNest</span><span>|</span><a href="#39533936">root</a><span>|</span><a href="#39534944">parent</a><span>|</span><a href="#39535089">next</a><span>|</span><label class="collapse" for="c-39535633">[-]</label><label class="expand" for="c-39535633">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t matter if it interfaces via CLI or not. Testcontainers tends to make things work but also introduces difficulty in resolution. You seem to have missed the point.</div><br/></div></div><div id="39535089" class="c"><input type="checkbox" id="c-39535089" checked=""/><div class="controls bullet"><span class="by">perbu</span><span>|</span><a href="#39533936">root</a><span>|</span><a href="#39534944">parent</a><span>|</span><a href="#39535633">prev</a><span>|</span><a href="#39535391">next</a><span>|</span><label class="collapse" for="c-39535089">[-]</label><label class="expand" for="c-39535089">[2 more]</label></div><br/><div class="children"><div class="content">Why don&#x27;t you point them out, please. We already know about testcontainers not using the shell, but rather talking to the HTTP API.<p>Making comments like &quot;this is wrong, but I&#x27;m not gonna explain why&quot; has no place here, imho.</div><br/><div id="39535626" class="c"><input type="checkbox" id="c-39535626" checked=""/><div class="controls bullet"><span class="by">collyw</span><span>|</span><a href="#39533936">root</a><span>|</span><a href="#39535089">parent</a><span>|</span><a href="#39535391">next</a><span>|</span><label class="collapse" for="c-39535626">[-]</label><label class="expand" for="c-39535626">[1 more]</label></div><br/><div class="children"><div class="content">Try criticizing agile.<p>&quot;You aren&#x27;t doing it right&quot;</div><br/></div></div></div></div></div></div></div></div><div id="39535391" class="c"><input type="checkbox" id="c-39535391" checked=""/><div class="controls bullet"><span class="by">theK</span><span>|</span><a href="#39533936">parent</a><span>|</span><a href="#39534475">prev</a><span>|</span><a href="#39534765">next</a><span>|</span><label class="collapse" for="c-39535391">[-]</label><label class="expand" for="c-39535391">[1 more]</label></div><br/><div class="children"><div class="content">I have had a similar intuition from when trying out testcontainers some years ago.<p>I do not know how the project has developed but at the time I tried it it felt very orthogonal or even incompabtible to more complex (as in multi language monorepo) projects, cde and containerized ci approaches.<p>I do not know how this has developed since, the emergence of cde standards like devcontainer and devfile might have improved this situation. Yet all projects I have started in the past 5 years where plain multilingual cde projects based on (mostly) a compose.yml file and not much more so no idea how really widespread their usage is.</div><br/></div></div><div id="39534765" class="c"><input type="checkbox" id="c-39534765" checked=""/><div class="controls bullet"><span class="by">choeger</span><span>|</span><a href="#39533936">parent</a><span>|</span><a href="#39535391">prev</a><span>|</span><a href="#39535247">next</a><span>|</span><label class="collapse" for="c-39534765">[-]</label><label class="expand" for="c-39534765">[1 more]</label></div><br/><div class="children"><div class="content">Came here with exactly this on my mind. Thanks for confirming my suspicion.<p>That being said, having specific requirements for the environment of your integration tests is not necessarily bad IMO. It&#x27;s just a question of checking these requirement and reporting any mismatches.</div><br/></div></div><div id="39535247" class="c"><input type="checkbox" id="c-39535247" checked=""/><div class="controls bullet"><span class="by">Jnr</span><span>|</span><a href="#39533936">parent</a><span>|</span><a href="#39534765">prev</a><span>|</span><a href="#39533979">next</a><span>|</span><label class="collapse" for="c-39535247">[-]</label><label class="expand" for="c-39535247">[1 more]</label></div><br/><div class="children"><div class="content">Similarly to CI agents, I run them in docker-in-docker container, which makes it a lot harder to break anything on the host.</div><br/></div></div><div id="39533979" class="c"><input type="checkbox" id="c-39533979" checked=""/><div class="controls bullet"><span class="by">cdata</span><span>|</span><a href="#39533936">parent</a><span>|</span><a href="#39535247">prev</a><span>|</span><a href="#39535173">next</a><span>|</span><label class="collapse" for="c-39533979">[-]</label><label class="expand" for="c-39533979">[1 more]</label></div><br/><div class="children"><div class="content">I would guess that this speaks to an unattended (developer) user story related to other workflows, or perhaps the container-adjacent ecosystem overall. Testing with any workflow is always tricky to get just right, and tools that make it easy (like, &quot;install a package and go&quot; easy) are underrated.</div><br/></div></div><div id="39535173" class="c"><input type="checkbox" id="c-39535173" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#39533936">parent</a><span>|</span><a href="#39533979">prev</a><span>|</span><a href="#39532187">next</a><span>|</span><label class="collapse" for="c-39535173">[-]</label><label class="expand" for="c-39535173">[2 more]</label></div><br/><div class="children"><div class="content">Does anyone happen to know which testcontainer implementations shell out, if any?</div><br/><div id="39535304" class="c"><input type="checkbox" id="c-39535304" checked=""/><div class="controls bullet"><span class="by">nrabulinski</span><span>|</span><a href="#39533936">root</a><span>|</span><a href="#39535173">parent</a><span>|</span><a href="#39532187">next</a><span>|</span><label class="collapse" for="c-39535304">[-]</label><label class="expand" for="c-39535304">[1 more]</label></div><br/><div class="children"><div class="content">Seems like the „community-maintained” ones they endorse, like the Rust implementation, do<p>I did not realize Rust wasn’t officially supported until I didn’t go to their GitHub and see in the readme that it’s a community project, and not their „official” one</div><br/></div></div></div></div></div></div><div id="39532187" class="c"><input type="checkbox" id="c-39532187" checked=""/><div class="controls bullet"><span class="by">dm03514</span><span>|</span><a href="#39533936">prev</a><span>|</span><a href="#39532454">next</a><span>|</span><label class="collapse" for="c-39532187">[-]</label><label class="expand" for="c-39532187">[22 more]</label></div><br/><div class="children"><div class="content">Test containers is such a game changer for integration testing, they have language specific docker apis that make it trivial to bring up containers and verify that they are fully initialized and ready to accept connections.<p>Pretty much every project I create now has testcontainers for integration testing :)<p>I setup CI so it lints, builds, unit tests then integration tests (using testcontainers)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;turbolytics&#x2F;latte&#x2F;blob&#x2F;main&#x2F;.github&#x2F;workflows&#x2F;ci.yml#L22">https:&#x2F;&#x2F;github.com&#x2F;turbolytics&#x2F;latte&#x2F;blob&#x2F;main&#x2F;.github&#x2F;workf...</a><p>Their language bindings provide nice helper functions for common database operations (like generating a connection uri from a container user)<p><a href="https:&#x2F;&#x2F;github.com&#x2F;turbolytics&#x2F;latte&#x2F;blob&#x2F;main&#x2F;internal&#x2F;source&#x2F;metric&#x2F;mongodb&#x2F;integration_test.go#L16">https:&#x2F;&#x2F;github.com&#x2F;turbolytics&#x2F;latte&#x2F;blob&#x2F;main&#x2F;internal&#x2F;sour...</a><p>I use them in $day job use them in side projects use them everywhere :)</div><br/><div id="39533753" class="c"><input type="checkbox" id="c-39533753" checked=""/><div class="controls bullet"><span class="by">gui77aume</span><span>|</span><a href="#39532187">parent</a><span>|</span><a href="#39532851">next</a><span>|</span><label class="collapse" for="c-39533753">[-]</label><label class="expand" for="c-39533753">[6 more]</label></div><br/><div class="children"><div class="content">If you are testing a microservices &quot;ball of mud&quot;, you can (and probably should) setup a testing environment and do your integration tests right there, against real dependencies. The tool seems nice for simple dependencies and local testing but I fail to see it as a game changer.</div><br/><div id="39534381" class="c"><input type="checkbox" id="c-39534381" checked=""/><div class="controls bullet"><span class="by">root_axis</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39533753">parent</a><span>|</span><a href="#39534232">next</a><span>|</span><label class="collapse" for="c-39534381">[-]</label><label class="expand" for="c-39534381">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>and local testing</i><p>You mention this as an afterthought but that&#x27;s the critical feature. Giving developers the ability to run integration tests locally is a massive win in a &quot;ball of mud&quot; environment. There are other ways to accomplish this locally, but the test-infrastructure-as-test-code approach is a powerful and conceptually elegant abstraction, especially when used as a tool to design testcontainers for your own services that can be imported as packages into dependent services.</div><br/></div></div><div id="39534232" class="c"><input type="checkbox" id="c-39534232" checked=""/><div class="controls bullet"><span class="by">AdrenalinMd</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39533753">parent</a><span>|</span><a href="#39534381">prev</a><span>|</span><a href="#39534126">next</a><span>|</span><label class="collapse" for="c-39534232">[-]</label><label class="expand" for="c-39534232">[1 more]</label></div><br/><div class="children"><div class="content">I agree with this. At work we use both approaches but at different levels of the test pyramid.<p>To test integration with 1 dependency at class level we can use test containers.<p>But to test the integration of the whole microservice with other microservices + dependencies we use a test environment and some test code. 
It&#x27;s a bit like an E2E test for an API.<p>I would argue that the test environment is more useful if I had to choose between the two as it can test the service contract fully, unlike lower type testing which requires a lot of mocking.</div><br/></div></div><div id="39534126" class="c"><input type="checkbox" id="c-39534126" checked=""/><div class="controls bullet"><span class="by">TeeWEE</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39533753">parent</a><span>|</span><a href="#39534232">prev</a><span>|</span><a href="#39533856">next</a><span>|</span><label class="collapse" for="c-39534126">[-]</label><label class="expand" for="c-39534126">[2 more]</label></div><br/><div class="children"><div class="content">This is useful too but expensive.<p>Test containers provide a middle ground.<p>For example we have pure unit tests. But also some tests that boot up Postgres. Test the db migration and gives you a db to play with for your specific “unit” test test case.<p>No need for a complete environment with Kafka etc. It provides a cost effective stepping stone to what you describe.<p>What would be nice if test containers could create a complete environment, on the test machine and delete it again.<p>Still a deploy with some smoke tests on a real env are nice.</div><br/><div id="39534978" class="c"><input type="checkbox" id="c-39534978" checked=""/><div class="controls bullet"><span class="by">AdrenalinMd</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39534126">parent</a><span>|</span><a href="#39533856">next</a><span>|</span><label class="collapse" for="c-39534978">[-]</label><label class="expand" for="c-39534978">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not really a middle ground if you&#x27;re not testing your service in the same conditions as in production environment.<p>If you&#x27;re not testing integration with Kafka, and the producer, your service is still lacking integration tests.<p>Testing classes in isolation with testcontainer is fine. But I observed that with microservice architecture the line between E2E tests and integration tests are blurred.<p>Microservices can and should be tested from the client perspective.</div><br/></div></div></div></div><div id="39533856" class="c"><input type="checkbox" id="c-39533856" checked=""/><div class="controls bullet"><span class="by">circusfly</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39533753">parent</a><span>|</span><a href="#39534126">prev</a><span>|</span><a href="#39532851">next</a><span>|</span><label class="collapse" for="c-39533856">[-]</label><label class="expand" for="c-39533856">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, this is the best way, testcontainers are over hyped.</div><br/></div></div></div></div><div id="39532851" class="c"><input type="checkbox" id="c-39532851" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#39532187">parent</a><span>|</span><a href="#39533753">prev</a><span>|</span><a href="#39533363">next</a><span>|</span><label class="collapse" for="c-39532851">[-]</label><label class="expand" for="c-39532851">[9 more]</label></div><br/><div class="children"><div class="content">FYI Docker already has a RESTful API, and programming container start&#x2F;stop is trivial to do in any language. I haven&#x27;t used Testcontainers before, and can kinda see the utility, but IMO it really isn&#x27;t worth it in the long term to take on a new external dependency for a bit of code that (1) is a critical part of the team&#x27;s development and release process and (2) can be written in-house in maybe an hour.</div><br/><div id="39533150" class="c"><input type="checkbox" id="c-39533150" checked=""/><div class="controls bullet"><span class="by">andrewxdiamond</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39532851">parent</a><span>|</span><a href="#39534004">next</a><span>|</span><label class="collapse" for="c-39533150">[-]</label><label class="expand" for="c-39533150">[2 more]</label></div><br/><div class="children"><div class="content">Conveniently as of a few days ago, you don’t need to be worried about this anymore. TestContainers is no longer a third-party!<p><a href="https:&#x2F;&#x2F;www.docker.com&#x2F;blog&#x2F;docker-whale-comes-atomicjar-maker-of-testcontainers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.docker.com&#x2F;blog&#x2F;docker-whale-comes-atomicjar-mak...</a></div><br/><div id="39535305" class="c"><input type="checkbox" id="c-39535305" checked=""/><div class="controls bullet"><span class="by">comprev</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39533150">parent</a><span>|</span><a href="#39534004">next</a><span>|</span><label class="collapse" for="c-39535305">[-]</label><label class="expand" for="c-39535305">[1 more]</label></div><br/><div class="children"><div class="content">If only Docker used a Sperm Whale as their mascot….</div><br/></div></div></div></div><div id="39534004" class="c"><input type="checkbox" id="c-39534004" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39532851">parent</a><span>|</span><a href="#39533150">prev</a><span>|</span><a href="#39533363">next</a><span>|</span><label class="collapse" for="c-39534004">[-]</label><label class="expand" for="c-39534004">[6 more]</label></div><br/><div class="children"><div class="content">&gt; it really isn&#x27;t worth it in the long term to take on a new external dependency for a bit of code that (1) is a critical part of the team&#x27;s development and release process and (2) can be written in-house in maybe an hour.<p>This seems to be quite a contradiction. If it&#x27;s so easy to just write from scratch, then why would it be scary to depend on? Of course, it&#x27;s not that easy to write from scratch. You could make a proof-of-concept in maybe an hour... Maybe. But they already took the proof of concept to a complete phase. Made it work with Podman. Added tons of integration code to make it easy to use with many common services. Ported it to several different languages. And, built a community around it.<p>If you do this from scratch, you have to go through most of the effort and problems they already did, except if you write your own solution, you have to maintain it right from the git-go, whereas if you choose Testcontainers, you&#x27;ll only wind up having to maintain it if the project is left for dead and starts to bitrot. The Docker API is pretty stable though, so honestly, this doesn&#x27;t seem likely to be a huge issue.<p>Testcontainers is exactly the sort of thing open source is great for; it&#x27;s something where everyone gets to benefit from the wisdom and battle-testing of everyone else. For most of the problems you might run into, there is a pretty decent chance someone already did, so there&#x27;s a pretty decent chance it&#x27;s already been fixed.<p>Most people have GitHub and Dockerhub dependencies in their critical dependency path for builds and deployment. Services go down, change their policies, deprecate APIs, and go under, but code continues to work if you replicate the environment it originally worked in. The biggest risk with code dependencies (for non-production code like test code) is usually that it blocks you from updating some other software. The biggest risk with <i>services</i> is that they completely disappear and you are completely blocked until you fully remove the dependency.<p>I think people depending on Testcontainers are fine and doing very well with their risk analysis.</div><br/><div id="39534415" class="c"><input type="checkbox" id="c-39534415" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39534004">parent</a><span>|</span><a href="#39534489">next</a><span>|</span><label class="collapse" for="c-39534415">[-]</label><label class="expand" for="c-39534415">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This seems to be quite a contradiction. If it&#x27;s so easy to just write from scratch, then why would it be scary to depend on?<p>It&#x27;s easy to write an implementation specific to your existing project&#x27;s development environment and workflow correctly.<p>It&#x27;s hard to write a generic version that works in any environment. It&#x27;s hard to write a version that lets you build a company and make money.<p>It&#x27;s scary to depend on this generic version because it&#x27;s too generic, and it&#x27;s built by a for-profit company now who wants to upsell you to some &quot;testcontainer cloud&quot; crap, which doesn&#x27;t exactly incentivize them to make the OSS version perfect.<p>For example, we were already using bazel, so writing a version using bazel to create a correct bare rootfs for a dependency + using runc to execute it in tests resulted in something with a roughly 3ms warm startup time that fulfilled all our needs, and cached correctly (since bazel has good caching).<p>A junior engineer, starry-eyed at test-containers, switched some code over to it, and the warm startup time went up by 1000x from 3ms to 3s, as did the flake-rate, and docker&#x27;s caching is far worse than bazel&#x27;s so the several minute cold-starts also happened even more often.<p>&gt; Testcontainers is exactly the sort of thing open source is great for; it&#x27;s something where everyone gets to benefit from the wisdom and battle-testing of everyone else.<p>You get to have a mismatched mess of solutions to everyone&#x27;s problems, including solution&#x27;s to problems you don&#x27;t have. You get code of the quality of the average OSS programmer which, while higher than the average programmer, is still pretty crap.<p>Free Software is great when it&#x27;s run by a small group of smart opinionated people. As soon as you try to build a company around that OSS and, god forbid, hire some enterprise sales people and product managers, it quickly becomes worse at the actual small developer problem than what even a mediocre developer could hack out in an hour.<p>Depending on testcontainers is fine, but if you know what you&#x27;re doing, writing something purpose-built is fine too, and probably gives you something much nicer in the end.</div><br/><div id="39534487" class="c"><input type="checkbox" id="c-39534487" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39534415">parent</a><span>|</span><a href="#39534489">next</a><span>|</span><label class="collapse" for="c-39534487">[-]</label><label class="expand" for="c-39534487">[2 more]</label></div><br/><div class="children"><div class="content">To be honest, it doesn&#x27;t sound like you really had a good use case for Testcontainers anyways. Where it excels the most is in just pulling in some external containers, especially databases, e.g. PostgreSQL and Redis, directly in your test harness. In those cases, it works well.</div><br/><div id="39535192" class="c"><input type="checkbox" id="c-39535192" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39534487">parent</a><span>|</span><a href="#39534489">next</a><span>|</span><label class="collapse" for="c-39535192">[-]</label><label class="expand" for="c-39535192">[1 more]</label></div><br/><div class="children"><div class="content">Our use-case was redis servers, one of your supposedly good use-cases for testcontainers.<p>I didn&#x27;t mention, but the testcontainer code also preferred to add that network io to the actual test runtime, which made measuring the test&#x27;s performance harder, and meant we couldn&#x27;t as safely cache the test&#x27;s results. The bazel version made it easy to build the test&#x27;s dependency as part of the test compilation process (as it should be) so the test runtime didn&#x27;t have to do external network IO.<p>&quot;Excels&quot; is also a stretch; we had a few hundred tests launching dedicated redis servers, and with hand-rolled code, that worked fine with zero flakes. With testcontainers, it regularly flaked with some opaque docker network error or sometimes just plain a timeout because apparently launching 100s of containers in parallel is a hard problem for docker or something.<p>I&#x27;m sure it works well for some people, but if those people wanted to build out their own version without docker and testcontainers, specific to their development tooling and environment, it would probably work better in most cases I think.</div><br/></div></div></div></div></div></div><div id="39534489" class="c"><input type="checkbox" id="c-39534489" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39534004">parent</a><span>|</span><a href="#39534415">prev</a><span>|</span><a href="#39533363">next</a><span>|</span><label class="collapse" for="c-39534489">[-]</label><label class="expand" for="c-39534489">[2 more]</label></div><br/><div class="children"><div class="content">When writing something like this for yourself you would only support one database, one programming language, one unit testing framework, much less documentation and none of the edge cases that someone else requires.<p>The effort would not be equal to replicating the whole project. It wouldn’t be the same quality of course. Question is do you need all of it or not.</div><br/><div id="39534589" class="c"><input type="checkbox" id="c-39534589" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39534489">parent</a><span>|</span><a href="#39533363">next</a><span>|</span><label class="collapse" for="c-39534589">[-]</label><label class="expand" for="c-39534589">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, but that&#x27;s kind of the thing, you get less battle testing most likely for also less surface area. If you pull in a project like this, it makes it vastly easier when you need more, because if it happens to already have built-in support, you don&#x27;t need to spend additional engineer time on it.<p>To me it seems straightforwardly a win to start with Testcontainer and move to something else when it proves insufficient.</div><br/></div></div></div></div></div></div></div></div><div id="39533363" class="c"><input type="checkbox" id="c-39533363" checked=""/><div class="controls bullet"><span class="by">pitah1</span><span>|</span><a href="#39532187">parent</a><span>|</span><a href="#39532851">prev</a><span>|</span><a href="#39532740">next</a><span>|</span><label class="collapse" for="c-39533363">[-]</label><label class="expand" for="c-39533363">[2 more]</label></div><br/><div class="children"><div class="content">I think they make the biggest difference when testing data pipelines (which have historically been difficult to test). You can now easily test out compatibility between different versions of databases, verify data types, embed as part of your build, etc.<p>I believe the next step, once using test containers, would be automating data generation and validation. Then you will have an automated pipeline of integration tests that are independent, fast and reliable.</div><br/><div id="39533637" class="c"><input type="checkbox" id="c-39533637" checked=""/><div class="controls bullet"><span class="by">afro88</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39533363">parent</a><span>|</span><a href="#39532740">next</a><span>|</span><label class="collapse" for="c-39533637">[-]</label><label class="expand" for="c-39533637">[1 more]</label></div><br/><div class="children"><div class="content">You can automate data validation with snapshot tests. I do it this way with a data pipeline and have a function that queries the destination DBs and puts them unto json to be written validated with a snapshot</div><br/></div></div></div></div><div id="39532740" class="c"><input type="checkbox" id="c-39532740" checked=""/><div class="controls bullet"><span class="by">weq</span><span>|</span><a href="#39532187">parent</a><span>|</span><a href="#39533363">prev</a><span>|</span><a href="#39532454">next</a><span>|</span><label class="collapse" for="c-39532740">[-]</label><label class="expand" for="c-39532740">[4 more]</label></div><br/><div class="children"><div class="content">Can you explain more in more detail why this is a game changer if i already have an inhouse framework that is similiar in using docker for integration tests? Does it start docker up faster then you could do normally? Is it just the out of the box apis it provides?<p>I dont know why integration testing like this is considered a gamechanger. the testing pyramid is a testing pyramid for a reason and its always considered them important. Sometimes starting with integration tests in your project is right because your dont waste time doing manual point and clicks. Instead you design your system around being able to integration test, this includes when you choose dependancies. You think to yourself &quot;how easily will that be able to be stood up on its own from a command?&quot; If the answer is &quot;not very good&quot; then you move on.</div><br/><div id="39532828" class="c"><input type="checkbox" id="c-39532828" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39532740">parent</a><span>|</span><a href="#39532454">next</a><span>|</span><label class="collapse" for="c-39532828">[-]</label><label class="expand" for="c-39532828">[3 more]</label></div><br/><div class="children"><div class="content">If you have an existing in-house framework for anything, maybe it&#x27;s not worth switching over. It does help though when a best practice bubbles to the top and makes this in reach for those who don&#x27;t have an existing in-house framework and who wouldn&#x27;t know how to get started on one. It also helps for more people to have a shared understanding about a subject like this thanks to a popular implementation.<p>Meanwhile, Testcontainers is done quite well. It&#x27;s not perfect, but it&#x27;s sure better than the in-house stuff I built in the past (for the same basic concept).<p>No, it does not start faster than other Docker containers.<p>I do challenge the testing pyramid, though. At the risk of repeating my other comment on a different branch of the discussion: the value of integration tests is high, as the cost of integration tests has decreased, it makes sense to do more integration testing, at the expense of unit testing. The cost has decreased exactly due to Docker and mature application frameworks (like in Java: Spring). (See: Testing Trophy.)</div><br/><div id="39533063" class="c"><input type="checkbox" id="c-39533063" checked=""/><div class="controls bullet"><span class="by">debosmit</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39532828">parent</a><span>|</span><a href="#39532454">next</a><span>|</span><label class="collapse" for="c-39533063">[-]</label><label class="expand" for="c-39533063">[2 more]</label></div><br/><div class="children"><div class="content">one thing i have seen with testcontainers (been a user for a few years) is the ergonomic SDKs that they have 
especially in languages like golang, it makes spinning containers up&#x2F;down, accessing the ports (eg: a mongodb container for some e2e test flow) super trivial - its like a nicety layer on top of vanilla docker (w&#x2F; the cost of including their sdk in your test build process)<p>yes, 100% can be done using docker directly or docker rest api (and def doesn&#x27;t make sense to migrate if you have already made an investment in an in-house framework <i>that doesn&#x27;t require much upkeep</i>)</div><br/><div id="39533304" class="c"><input type="checkbox" id="c-39533304" checked=""/><div class="controls bullet"><span class="by">weq</span><span>|</span><a href="#39532187">root</a><span>|</span><a href="#39533063">parent</a><span>|</span><a href="#39532454">next</a><span>|</span><label class="collapse" for="c-39533304">[-]</label><label class="expand" for="c-39533304">[1 more]</label></div><br/><div class="children"><div class="content">thanks for the responses, i just wanted to cut through the marketing. taking on standardised tools is a win for me, i just wanted to know about real world experience and use-case. Indeed taking on deps is not something i do lightly.<p>&gt; value of test pyramid<p>I mean more from the perspective of covering your bases, you never just want one kind of testing pattern in your project. Each codebase is different and i agree that taking on high value test styles&#x2F;cases is a project by project challange that should be tailored by many variables. The shape of your testing pyramid may be different to others. If your inheriting a legacy system, maybe its top heavy because the effort&#x2F;reward ratio just isnt there. In this circumstances i usually take on the approach of &quot;add more layers when bugs are found&quot; to hone in on places that could use more or less test coverage.<p>Our inhouse framework is really just a wrapper around certain tools that fill different gaps (think docker&#x2F;selenium etc) in order for different projects to build suites that are compatible with our ci&#x2F;cd pipelines that do things like generate environments on demand to run test suites against. So dropping in testcontainers to replace the home-grown docker will be trivial. Keeping test frameworks fresh and compatible with the cloud vendors that agreesively upgrade is a challange just like keeping the API bleed of other programming deps is. Our test suites essentially have a domain language that is consistant. We can upgrade selenium, swap functions for different operations, without having to change any tests. Same goes for unit or integration tests - they are exactly the same in terms of assertions, syntax etc, they may just just have different environment setup logic. CI&#x2F;CD can inject and overrride logic as it needs. Sometimes its suitable, in some cases, to mock certain external hard deps in integration tests for instance to having all the unit testing tools availible a plus. Or in other cases, we may take a unit test written against mocks, and inject real deps into it for certain CI&#x2F;CD scenarios.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39532454" class="c"><input type="checkbox" id="c-39532454" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39532187">prev</a><span>|</span><a href="#39533785">next</a><span>|</span><label class="collapse" for="c-39532454">[-]</label><label class="expand" for="c-39532454">[23 more]</label></div><br/><div class="children"><div class="content">Not sure how I hadn&#x27;t encountered this before, I LOVE this pattern.<p>I find integration tests that exercise actual databases&#x2F;Elasticsearch&#x2F;Redis&#x2F;Varnish etc to be massively more valuable than traditional unit tests. In the past I&#x27;ve gone to pretty deep lengths to do things like spin up a new Elasticsearch index for the duration of a test suite and spin it down again at the end.<p>It looks like Testcontainers does all of that work for me.<p>My testing strategy is to have as much of my application&#x27;s functionality covered by proper end-to-end integration-style tests as possible - think tests that simulate an incoming HTTP request and then run assertions against the response (and increasingly Playwright-powered browser automation tests for anything with heavy JavaScript).<p>I&#x27;ll use unit tests sparingly, just for the bits of my code that have very clear input&#x2F;output pairs that afford unit testing.<p>I only use mocks for things that I don&#x27;t have any chance of controlling - calls to external APIs for example, where I can&#x27;t control if the API provider will be flaky or not.</div><br/><div id="39533938" class="c"><input type="checkbox" id="c-39533938" checked=""/><div class="controls bullet"><span class="by">CobrastanJorji</span><span>|</span><a href="#39532454">parent</a><span>|</span><a href="#39533960">next</a><span>|</span><label class="collapse" for="c-39533938">[-]</label><label class="expand" for="c-39533938">[14 more]</label></div><br/><div class="children"><div class="content">I love integration tests. You know why? Because I can safely refactor all I want!<p>Unit tests are great, but if you significantly refactor how several classes talk to each other, and each of those classes had their own, isolated unit tests that mocked out all of the others, you&#x27;re suddenly refactoring with no tests. But a black box integration tests? Refactor all your code, replace your databases, do whatever you want, integration test still passes.<p>Unit test speed is a huge win, and they&#x27;re incredibly useful for quickly testing weird little edge cases that are annoying to write integration tests for, but if I can write an integration test for it, I prefer the integration test.</div><br/><div id="39534958" class="c"><input type="checkbox" id="c-39534958" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39533938">parent</a><span>|</span><a href="#39534505">next</a><span>|</span><label class="collapse" for="c-39534958">[-]</label><label class="expand" for="c-39534958">[4 more]</label></div><br/><div class="children"><div class="content">Thanks for saying this out loud. I’m a solo dev and in my project I’m doing exactly this: 90% black box integration tests and 10% unit tests for edge cases I cannot trigger otherwise. It buys me precious time to not adjust tests after refactoring. Yet it made me feel like a heretic: everyone knows the testing pyramid and it comes from Google so I must be very wrong.</div><br/><div id="39535188" class="c"><input type="checkbox" id="c-39535188" checked=""/><div class="controls bullet"><span class="by">fiznool</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39534958">parent</a><span>|</span><a href="#39534505">next</a><span>|</span><label class="collapse" for="c-39535188">[-]</label><label class="expand" for="c-39535188">[3 more]</label></div><br/><div class="children"><div class="content">You might be interested in the ‘testing trophy’ as an alternative to the traditional pyramid.<p><a href="https:&#x2F;&#x2F;kentcdodds.com&#x2F;blog&#x2F;write-tests" rel="nofollow">https:&#x2F;&#x2F;kentcdodds.com&#x2F;blog&#x2F;write-tests</a></div><br/><div id="39535330" class="c"><input type="checkbox" id="c-39535330" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39535188">parent</a><span>|</span><a href="#39534505">next</a><span>|</span><label class="collapse" for="c-39535330">[-]</label><label class="expand" for="c-39535330">[2 more]</label></div><br/><div class="children"><div class="content">This advice is so misguided that I&#x27;m concerned for our industry it&#x27;s getting so much traction.<p>&gt; You really want to avoid testing implementation details because it doesn&#x27;t give you very much confidence that your application is working and it slows you down when refactoring. You should very rarely have to change tests when you refactor code.<p>Unit tests don&#x27;t need to test implementation details. You could just as well make that mistake with integration or E2E tests. Black box testing is a good practice at all layers.<p>What unit tests do is confirm that the smallest pieces of the system work as expected in isolation. Yes, you should also test them in combination with each other, but it serves you no good if you get a green integration test, when it&#x27;s likely only testing a small fraction of the functionality of the units themselves.<p>This whole &quot;unit tests slow you down&quot; mentality is incredibly toxic. You know what genuinely slows me down? A suite with hundreds of integration tests, each taking several seconds to run, and depend on external systems. But hey, testcontainers to the rescue, right?<p>Tests shouldn&#x27;t be a chore, but an integral part of software development. These days I suppose we can offload some of that work to AI, but even that should be done very carefully to ensure that the code is high quality and actually tests what we need.<p>Test code is as important as application code. It&#x27;s lazy to think otherwise.</div><br/><div id="39535644" class="c"><input type="checkbox" id="c-39535644" checked=""/><div class="controls bullet"><span class="by">ric2b</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39535330">parent</a><span>|</span><a href="#39534505">next</a><span>|</span><label class="collapse" for="c-39535644">[-]</label><label class="expand" for="c-39535644">[1 more]</label></div><br/><div class="children"><div class="content">If by &quot;smallest pieces of the system&quot; you mean something like individual classes then you are definitely testing implementation details.<p>Whenever you change a method&#x27;s parameters in one of those internal classes you&#x27;ll have unit tests breaking, even though you&#x27;re just refactoring code.<p>Unit testing at the smallest piece level calcifies the codebase by making refactors much more costly.</div><br/></div></div></div></div></div></div></div></div><div id="39534505" class="c"><input type="checkbox" id="c-39534505" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39533938">parent</a><span>|</span><a href="#39534958">prev</a><span>|</span><a href="#39535222">next</a><span>|</span><label class="collapse" for="c-39534505">[-]</label><label class="expand" for="c-39534505">[1 more]</label></div><br/><div class="children"><div class="content">Legit.  Probably an unpopular opinion but if I had to chose only one type of test (queue a long discussion with no resolution over defining exact taxonomic boundaries), I&#x27;d go with integration over unit.  Especially if you&#x27;re a new contributor to a project.  I think it comes down to exercising the flow between... Well, integrations across components.<p>Even better?  Take your integration test, put it on a cronjob in your VPN&#x2F;vpc, use real endpoints and make bespoke auth credentials + namespace, and now you have canaries.  Canaries are IMHO God tier for whole system observability.<p>Then take your canary, clean it up, and now you have examples for documentation.<p>Unit tests are for me mostly testing domain+codomain of functions and adherence to business logic, but a good type system along with discipline for actually making schemas&#x2F;POJOs etc instead of just tossing around maps strings and ints everywhere already accomplishes a lot of that (still absolutely needed though!)</div><br/></div></div><div id="39535222" class="c"><input type="checkbox" id="c-39535222" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39533938">parent</a><span>|</span><a href="#39534505">prev</a><span>|</span><a href="#39534509">next</a><span>|</span><label class="collapse" for="c-39535222">[-]</label><label class="expand" for="c-39535222">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard this aversion to unit tests a few times in my career, and I&#x27;m unable to make sense of it.<p>Sure, integration tests &quot;save&quot; you from writing pesky unit tests, and changing them frequently after every refactor.<p>But how do you quickly locate the reason that integration test failed? There could be hundreds of moving parts involved, and any one of them malfunctioning, or any unexpected interaction between them, could cause it to fail. The error itself would likely not be clear enough, if it&#x27;s covered by layers of indirection.<p>Unit tests give you that ability. If written correctly, they should be the first to fail (which is a good thing!), and if an integration test fails, it should ideally also be accompanied by at least one unit test failure. This way it immediately pinpoints the root cause.<p>The higher up the stack you test, the harder it is to debug. With E2E tests you&#x27;re essentially debugging the entire system, which is why we don&#x27;t exclusively write E2E tests, even though they&#x27;re very useful.<p>To me the traditional test pyramid is still the best way to think about tests. Tests shouldn&#x27;t be an afterthought or a chore. Maintaining a comprehensive and effective test suite takes as much hard work as, if not more than, maintaining the application itself, and it should test all layers of the system. But if you do have that, it gives you superpowers to safely and reliably work on any part of the system.</div><br/><div id="39535584" class="c"><input type="checkbox" id="c-39535584" checked=""/><div class="controls bullet"><span class="by">ric2b</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39535222">parent</a><span>|</span><a href="#39535351">next</a><span>|</span><label class="collapse" for="c-39535584">[-]</label><label class="expand" for="c-39535584">[1 more]</label></div><br/><div class="children"><div class="content">If the test fails consistently (as it should) it is usually just a question of using a debugger and stepping through some suspect sections of the code to find the issue.<p>Compared to the amount of time saved by not rewriting unit tests every time you refactor stuff, it&#x27;s a great trade-off.</div><br/></div></div><div id="39535351" class="c"><input type="checkbox" id="c-39535351" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39535222">parent</a><span>|</span><a href="#39535584">prev</a><span>|</span><a href="#39535420">next</a><span>|</span><label class="collapse" for="c-39535351">[-]</label><label class="expand" for="c-39535351">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But how do you quickly locate the reason that integration test failed? There could be hundreds of moving parts involved, and any one of them malfunctioning, or any unexpected interaction between them, could cause it to fail. The error itself would likely not be clear enough, if it&#x27;s covered by layers of indirection.<p>As long as the error is reproducible, never in my career have I had a hard time locating the source of the error. Bisection does wonders (as a general concept, not specifically referring to git bisect).<p>That said, I have encountered plenty of non-reproducible test failures. Moral of the story: make things reproducible, especially tests.<p>Easier said than done.</div><br/></div></div><div id="39535420" class="c"><input type="checkbox" id="c-39535420" checked=""/><div class="controls bullet"><span class="by">mk89</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39535222">parent</a><span>|</span><a href="#39535351">prev</a><span>|</span><a href="#39534509">next</a><span>|</span><label class="collapse" for="c-39535420">[-]</label><label class="expand" for="c-39535420">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I&#x27;ve heard this aversion to unit tests a few times in my career, and I&#x27;m unable to make sense of it.<p>It&#x27;s very simple: most of the time people are told by management that they MUST achieve a 80-90-95% of code coverage (with unit tests), which leads to a lot of absolutely worthless tests - tests for the sake of it. The irony is that the pieces that really count don&#x27;t get tested properly, because you unit-test the happy-path and maybe 1 or 2 negative scenarios, and that&#x27;s it, missing out a bunch of potential regressions.<p>EDIT: This just to say that I don&#x27;t believe the author of the comment said &quot;don&#x27;t write unit tests&quot; (I hope not, at least!) but, if I can rephrase it, &quot;well, the integration tests give you a better dopamine effect because they actually help you catch bugs&quot;. Which would be partially true also with properly written unit tests (and they would do so in a fraction of the time you need with integration tests).</div><br/></div></div></div></div><div id="39534509" class="c"><input type="checkbox" id="c-39534509" checked=""/><div class="controls bullet"><span class="by">cyptus</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39533938">parent</a><span>|</span><a href="#39535222">prev</a><span>|</span><a href="#39533960">next</a><span>|</span><label class="collapse" for="c-39534509">[-]</label><label class="expand" for="c-39534509">[4 more]</label></div><br/><div class="children"><div class="content">how do you handle resetting a sql database after every integration test? Testcontainers may help here by spinning up a new instance for every test but that seems very slow</div><br/><div id="39534622" class="c"><input type="checkbox" id="c-39534622" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39534509">parent</a><span>|</span><a href="#39535197">next</a><span>|</span><label class="collapse" for="c-39534622">[-]</label><label class="expand" for="c-39534622">[2 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m using Django I let Django&#x27;s default test harness handle that for me - it runs each test in a transaction and rolls it back at the end of the test, which is pretty fast. <a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.0&#x2F;topics&#x2F;testing&#x2F;overview&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.0&#x2F;topics&#x2F;testing&#x2F;overvie...</a><p>For my other projects I&#x27;m generally using SQLite where starting a new in-memory database is so fast it&#x27;s effectively free.</div><br/><div id="39535400" class="c"><input type="checkbox" id="c-39535400" checked=""/><div class="controls bullet"><span class="by">dkdbejwi383</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39534622">parent</a><span>|</span><a href="#39535197">next</a><span>|</span><label class="collapse" for="c-39535400">[-]</label><label class="expand" for="c-39535400">[1 more]</label></div><br/><div class="children"><div class="content">How does that work when the system under test uses transactions itself?</div><br/></div></div></div></div><div id="39535197" class="c"><input type="checkbox" id="c-39535197" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39534509">parent</a><span>|</span><a href="#39534622">prev</a><span>|</span><a href="#39533960">next</a><span>|</span><label class="collapse" for="c-39535197">[-]</label><label class="expand" for="c-39535197">[1 more]</label></div><br/><div class="children"><div class="content">I do this a lot for Postgres testing. In my setup, I create a single database for the entire test run. Each test creates its own schema in that database and applies the latest table definitions.<p>With this setup, I only eat the container creation once, while allowing every test to operate in isolation from one another, be parallelized, and test against a real database.<p>I do a similar trick for S3 containers by applying a unique guid prefix to the buckets in each test.</div><br/></div></div></div></div></div></div><div id="39533960" class="c"><input type="checkbox" id="c-39533960" checked=""/><div class="controls bullet"><span class="by">theonething</span><span>|</span><a href="#39532454">parent</a><span>|</span><a href="#39533938">prev</a><span>|</span><a href="#39533767">next</a><span>|</span><label class="collapse" for="c-39533960">[-]</label><label class="expand" for="c-39533960">[1 more]</label></div><br/><div class="children"><div class="content">I once failed a take home assignment because of this. It was writing a couple of api endpoints and for testing, I focused on  integration over unit.  I even explained my reasoning in the writeup.  There was no indication that the company preferred unit tests, but the feedback was &quot;didn&#x27;t have enough unit tests&quot;.  What a dumb company.</div><br/></div></div><div id="39533767" class="c"><input type="checkbox" id="c-39533767" checked=""/><div class="controls bullet"><span class="by">briHass</span><span>|</span><a href="#39532454">parent</a><span>|</span><a href="#39533960">prev</a><span>|</span><a href="#39533272">next</a><span>|</span><label class="collapse" for="c-39533767">[-]</label><label class="expand" for="c-39533767">[2 more]</label></div><br/><div class="children"><div class="content">Another technique I&#x27;ve found very useful is generative integration tests (kind of like fuzzing), especially for idempotent API endpoints (GETs).<p>For example, assuming you have a test database with realistic data (or scrubbed production data), write tests that are based on generalizable business rules, e.g: the total line of an &#x27;invoice&#x27; GET response should be the sum of all the &#x27;sections&#x27; endpoint responses tied to that invoice id. Then, just have a process that runs before the tests create a bunch of test cases (invoice IDs to try), randomly selected from all the IDs in the database. Limit the number of cases to something reasonable for total test duration.<p>As one would expect, overly tight assertions can often lead to many false positives, but really tough edge cases hidden in diverse&#x2F;unexpected data (null refs) can be found that usually escape the artificial or &#x27;happy path&#x27; pre-selected cases.</div><br/><div id="39534712" class="c"><input type="checkbox" id="c-39534712" checked=""/><div class="controls bullet"><span class="by">mzi</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39533767">parent</a><span>|</span><a href="#39533272">next</a><span>|</span><label class="collapse" for="c-39534712">[-]</label><label class="expand" for="c-39534712">[1 more]</label></div><br/><div class="children"><div class="content">Running unit tests as integration tests will explode in your face. In any decent complex code base testing time will go through the roof and you will have a hard time getting the genie back in the bottle.<p>Testing that you actually run &quot;sum()&quot; is a unit test.</div><br/></div></div></div></div><div id="39533272" class="c"><input type="checkbox" id="c-39533272" checked=""/><div class="controls bullet"><span class="by">DanHulton</span><span>|</span><a href="#39532454">parent</a><span>|</span><a href="#39533767">prev</a><span>|</span><a href="#39533253">next</a><span>|</span><label class="collapse" for="c-39533272">[-]</label><label class="expand" for="c-39533272">[1 more]</label></div><br/><div class="children"><div class="content">This is exactly the strategy I have discovered to bring the most value as well.  And honestly, something that simplifies the setup of those containers is pretty great.</div><br/></div></div><div id="39533253" class="c"><input type="checkbox" id="c-39533253" checked=""/><div class="controls bullet"><span class="by">trevor-e</span><span>|</span><a href="#39532454">parent</a><span>|</span><a href="#39533272">prev</a><span>|</span><a href="#39533785">next</a><span>|</span><label class="collapse" for="c-39533253">[-]</label><label class="expand" for="c-39533253">[4 more]</label></div><br/><div class="children"><div class="content">Do you find this results in less overall test code to maintain since you likely have fewer but higher quality&#x2F;signal tests?</div><br/><div id="39534573" class="c"><input type="checkbox" id="c-39534573" checked=""/><div class="controls bullet"><span class="by">stingraycharles</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39533253">parent</a><span>|</span><a href="#39533315">next</a><span>|</span><label class="collapse" for="c-39534573">[-]</label><label class="expand" for="c-39534573">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you just focus on a few high level behaviors that you want to validate, instead of the units. It’s more difficult to pull these tests off, as there are more chances for them to become flaky tests, but if they work they provide much more value.<p>I’d prefer a dozen well written integration tests over a hundred unit tests.<p>Having said that, both solve different problems, ideally you have both. But when time-constrained, I always focus on integration tests with actual services underneath.</div><br/></div></div><div id="39533315" class="c"><input type="checkbox" id="c-39533315" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39533253">parent</a><span>|</span><a href="#39534573">prev</a><span>|</span><a href="#39533785">next</a><span>|</span><label class="collapse" for="c-39533315">[-]</label><label class="expand" for="c-39533315">[2 more]</label></div><br/><div class="children"><div class="content">Yeah - I find that sticking to tests like this means I don&#x27;t have hundreds of tiny unit tests that rely on mocks, and it&#x27;s still very supportive of refactoring - I can make some pretty big changes and be confident that I&#x27;ve not broken anything because a given request continues to return the expected response.</div><br/><div id="39533591" class="c"><input type="checkbox" id="c-39533591" checked=""/><div class="controls bullet"><span class="by">gorjusborg</span><span>|</span><a href="#39532454">root</a><span>|</span><a href="#39533315">parent</a><span>|</span><a href="#39533785">next</a><span>|</span><label class="collapse" for="c-39533591">[-]</label><label class="expand" for="c-39533591">[1 more]</label></div><br/><div class="children"><div class="content">The choice isn&#x27;t unit tests vs . end-to-end tests, its between testing things you don&#x27;t really care about and those you do.<p>You care about real use cases and verifying design constraints are met. You don&#x27;t care about internal implementation details.<p>The nuance is that there are often things one cares about at multiple levels.</div><br/></div></div></div></div></div></div></div></div><div id="39533785" class="c"><input type="checkbox" id="c-39533785" checked=""/><div class="controls bullet"><span class="by">et1337</span><span>|</span><a href="#39532454">prev</a><span>|</span><a href="#39531892">next</a><span>|</span><label class="collapse" for="c-39533785">[-]</label><label class="expand" for="c-39533785">[1 more]</label></div><br/><div class="children"><div class="content">I looked at testcontainers and ended up rolling my own version. One issue I had is that Docker is a very leaky abstraction. I needed to write one test and have it run in all these scenarios:<p>- on a Mac<p>- on a Linux VM<p>- in a Docker container on a Linux VM, with a Docker socket mounted<p>The networking for each of these is completely different. I had to make some opinionated choices to get code that could run in all cases. And running inside Docker prevented the test from being able to mount arbitrary files into the test containers, which turns out to be a requirement often. I ended up writing code to build a new image for each container, using ADD to inject files.<p>I also wanted all the tests to run in parallel and spit out readable logs from every container (properly associated with the correct test).<p>Not sure if any of these things have changed in testcontainers since I last looked, but these are the things I ran into. It took maybe a month of off and on tweaking, contrary to some people here claiming it can be done in an hour. As always, the devil is in the details.<p>edit: I did end up stealing ryuk. That thing can’t really be improved upon.</div><br/></div></div><div id="39531892" class="c"><input type="checkbox" id="c-39531892" checked=""/><div class="controls bullet"><span class="by">redact207</span><span>|</span><a href="#39533785">prev</a><span>|</span><a href="#39532520">next</a><span>|</span><label class="collapse" for="c-39531892">[-]</label><label class="expand" for="c-39531892">[17 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t quite understand why this was made. We create our local test environments using docker-compose, and so I read:<p>&gt; Creating reliable and fully-initialized service dependencies using raw Docker commands or using Docker Compose requires good knowledge of Docker internals and how to best run specific technologies in a container<p>This sounds like a &lt;your programming language&gt; abstraction over docker-compose, which lets you define your docker environment without learning the syntax of docker-compose itself. But then<p>&gt; port conflicts, containers not being fully initialized or ready for interactions when the tests start, etc.<p>means you&#x27;d still need a good understanding of docker networking, dependencies, healthchecks to know if your test environment is ready to be used.<p>Am I missing something? Is this basically change what&#x27;s starting your docker test containers?</div><br/><div id="39532016" class="c"><input type="checkbox" id="c-39532016" checked=""/><div class="controls bullet"><span class="by">c0balt</span><span>|</span><a href="#39531892">parent</a><span>|</span><a href="#39531979">next</a><span>|</span><label class="collapse" for="c-39532016">[-]</label><label class="expand" for="c-39532016">[3 more]</label></div><br/><div class="children"><div class="content">Going to the sections for language interactions shows a lot more stuff, e.g., the first full go example: <a href="https:&#x2F;&#x2F;testcontainers.com&#x2F;guides&#x2F;getting-started-with-testcontainers-for-go&#x2F;#_write_test_for_repository_using_testcontainers_g" rel="nofollow">https:&#x2F;&#x2F;testcontainers.com&#x2F;guides&#x2F;getting-started-with-testc...</a><p>Shows how you can embed the declaration of  db for testing in a unit test:<p>&gt; pgContainer, err := postgres.RunContainer(ctx,
&gt;  testcontainers.WithImage(&quot;postgres:15.3-alpine&quot;),
&gt; postgres.WithInitScripts(filepath.Join(&quot;..&quot;, &quot;testdata&quot;, &quot;init-db.sql&quot;)),
&gt;  postgres.WithDatabase(&quot;test-db&quot;),
&gt;  postgres.WithUsername(&quot;postgres&quot;),
&gt;  postgres.WithPassword(&quot;postgres&quot;),
&gt;  testcontainers.WithWaitStrategy(
&gt;   wait.ForLog(&quot;database system is ready to accept connections&quot;).<p>This does look quite neat for setting up test specific database instances instead of spawning one outside of the test context with docker(compose). It should also make it possible to run tests that require their own instance in parallel.</div><br/><div id="39532421" class="c"><input type="checkbox" id="c-39532421" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39531892">root</a><span>|</span><a href="#39532016">parent</a><span>|</span><a href="#39531979">next</a><span>|</span><label class="collapse" for="c-39532421">[-]</label><label class="expand" for="c-39532421">[2 more]</label></div><br/><div class="children"><div class="content">On Hacker News you need to indent code examples with four spaces - like this:<p><pre><code>    pgContainer, err := postgres.RunContainer(
        ctx, testcontainers.WithImage(&quot;postgres:15.3-alpine&quot;
    ),
    postgres.WithInitScripts(filepath.Join(&quot;..&quot;, &quot;testdata&quot;, &quot;init-db.sql&quot;)),
     postgres.WithDatabase(&quot;test-db&quot;),
     postgres.WithUsername(&quot;postgres&quot;),
     postgres.WithPassword(&quot;postgres&quot;),
     testcontainers.WithWaitStrategy(
      wait.ForLog(&quot;database system is ready to accept connections&quot;).</code></pre></div><br/><div id="39532560" class="c"><input type="checkbox" id="c-39532560" checked=""/><div class="controls bullet"><span class="by">altairprime</span><span>|</span><a href="#39531892">root</a><span>|</span><a href="#39532421">parent</a><span>|</span><a href="#39531979">next</a><span>|</span><label class="collapse" for="c-39532560">[-]</label><label class="expand" for="c-39532560">[1 more]</label></div><br/><div class="children"><div class="content">And, to quote non-code text, you have to do it manually; there is no formatting operator and the code-indent method won’t work (unreadable at many browser widths). I tend to do it like so:<p>&gt; *Paragraph one.*<p>&gt; *Paragraph two. Etc.*<p>Which produces the desired effect:<p>&gt; <i>Paragraph ‘one’.</i><p>&gt; <i>Paragraph two.</i><p>(To use a * in a paragraph that’s italic-wrapped, backslash it.)</div><br/></div></div></div></div></div></div><div id="39531979" class="c"><input type="checkbox" id="c-39531979" checked=""/><div class="controls bullet"><span class="by">mleo</span><span>|</span><a href="#39531892">parent</a><span>|</span><a href="#39532016">prev</a><span>|</span><a href="#39531935">next</a><span>|</span><label class="collapse" for="c-39531979">[-]</label><label class="expand" for="c-39531979">[3 more]</label></div><br/><div class="children"><div class="content">It’s not coming across in your comment, but Testcontainers can work with unit tests to start a container, run the unit tests and shutdown. For example, to verify database operations against the actual database, the unit test can start an instance of Postgres run tests and then shut it down. If running tests in parallel, each test can start its own container and shutdown at the end.</div><br/><div id="39534119" class="c"><input type="checkbox" id="c-39534119" checked=""/><div class="controls bullet"><span class="by">DanHulton</span><span>|</span><a href="#39531892">root</a><span>|</span><a href="#39531979">parent</a><span>|</span><a href="#39531935">next</a><span>|</span><label class="collapse" for="c-39534119">[-]</label><label class="expand" for="c-39534119">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t that just massively, _massively_ slow down your tests, if each test was spinning up its own Postgres container?<p>I ask because I really like this and would love to use it, but I&#x27;m concerned that that would add just an insane amount of overhead to the point where the convenience isn&#x27;t worth the immense amount of extra time it would take.</div><br/><div id="39535436" class="c"><input type="checkbox" id="c-39535436" checked=""/><div class="controls bullet"><span class="by">orphea</span><span>|</span><a href="#39531892">root</a><span>|</span><a href="#39534119">parent</a><span>|</span><a href="#39531935">next</a><span>|</span><label class="collapse" for="c-39535436">[-]</label><label class="expand" for="c-39535436">[1 more]</label></div><br/><div class="children"><div class="content">A better approach is to spin up one container and a _template_ database before the tests. Apply migrations to that database. Then, each test creates its own database from the template, runs, and drops the database.<p>Tests can be run in parallel, and they are fast because the database is prepared just once, tests simply make a copy.<p>We&#x27;re doing this in my company, I&#x27;m happy how it works.</div><br/></div></div></div></div></div></div><div id="39531935" class="c"><input type="checkbox" id="c-39531935" checked=""/><div class="controls bullet"><span class="by">stonecolddevin</span><span>|</span><a href="#39531892">parent</a><span>|</span><a href="#39531979">prev</a><span>|</span><a href="#39531963">next</a><span>|</span><label class="collapse" for="c-39531935">[-]</label><label class="expand" for="c-39531935">[1 more]</label></div><br/><div class="children"><div class="content">Testcontainers is great.  It&#x27;s got seamless junit integration and really Just Works.  I&#x27;ve never once had to even think about any of the docker aspects of it.  There&#x27;s really not much to it.</div><br/></div></div><div id="39531963" class="c"><input type="checkbox" id="c-39531963" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#39531892">parent</a><span>|</span><a href="#39531935">prev</a><span>|</span><a href="#39533099">next</a><span>|</span><label class="collapse" for="c-39531963">[-]</label><label class="expand" for="c-39531963">[4 more]</label></div><br/><div class="children"><div class="content">Testcontainers are for testing individual components, apart from the application.<p>I built a new service registry recently, its unit tests spins up a zookeeper instance for the duration of the test, and then kills it.<p>Also very nice with databases.  Spin up a clean db, run migrations, then test db code with zero worries about accidentally leaving stuff in a table that poisons other tests.<p>I guess the killer feature is how well it works.</div><br/><div id="39532004" class="c"><input type="checkbox" id="c-39532004" checked=""/><div class="controls bullet"><span class="by">dns_snek</span><span>|</span><a href="#39531892">root</a><span>|</span><a href="#39531963">parent</a><span>|</span><a href="#39533099">next</a><span>|</span><label class="collapse" for="c-39532004">[-]</label><label class="expand" for="c-39532004">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Also very nice with databases. Spin up a clean db, run migrations, then test db code with zero worries about accidentally leaving stuff in a table that poisons other tests.<p>Are you spinning up a new instance between every test case? Because that sounds painfully slow.<p>I would just define a function which DELETEs all the data and call it between every test.</div><br/><div id="39532097" class="c"><input type="checkbox" id="c-39532097" checked=""/><div class="controls bullet"><span class="by">NomDePlum</span><span>|</span><a href="#39531892">root</a><span>|</span><a href="#39532004">parent</a><span>|</span><a href="#39532075">next</a><span>|</span><label class="collapse" for="c-39532097">[-]</label><label class="expand" for="c-39532097">[1 more]</label></div><br/><div class="children"><div class="content">It supports both patterns (and variations in between). So you get to pick between isolation at a test level or if you want less overhead, rolling back the commit or other ways to cleanup.<p>Can only speak for the Golang version of the lib, but spinning up new instances was surprisingly quick.</div><br/></div></div><div id="39532075" class="c"><input type="checkbox" id="c-39532075" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#39531892">root</a><span>|</span><a href="#39532004">parent</a><span>|</span><a href="#39532097">prev</a><span>|</span><a href="#39533099">next</a><span>|</span><label class="collapse" for="c-39532075">[-]</label><label class="expand" for="c-39532075">[1 more]</label></div><br/><div class="children"><div class="content">I usually do one per suite with a reset method run before each test.<p>It&#x27;s a decent compromise between performance and isolation, since weird interactions can only originate from the same suite, rather than anywhere in any test.  Also permits parallel execution of db test suites.</div><br/></div></div></div></div></div></div><div id="39533099" class="c"><input type="checkbox" id="c-39533099" checked=""/><div class="controls bullet"><span class="by">codeonline</span><span>|</span><a href="#39531892">parent</a><span>|</span><a href="#39531963">prev</a><span>|</span><a href="#39532010">next</a><span>|</span><label class="collapse" for="c-39533099">[-]</label><label class="expand" for="c-39533099">[3 more]</label></div><br/><div class="children"><div class="content">This looks to be like just language specific bindings over the docker compose syntax. You&#x27;re right that docker compose handles all of the situations they describe.</div><br/><div id="39533289" class="c"><input type="checkbox" id="c-39533289" checked=""/><div class="controls bullet"><span class="by">mickael-kerjean</span><span>|</span><a href="#39531892">root</a><span>|</span><a href="#39533099">parent</a><span>|</span><a href="#39532010">next</a><span>|</span><label class="collapse" for="c-39533289">[-]</label><label class="expand" for="c-39533289">[2 more]</label></div><br/><div class="children"><div class="content">The major issue I had with docker compose in my CI environment is flaky tests when a port is already used by another job I don&#x27;t control. With testcontainers, I haven&#x27;t seen any false positive as I can use whatever port is available and not a hardcoded one hoping it won&#x27;t conflict with what other people are doing.</div><br/><div id="39534018" class="c"><input type="checkbox" id="c-39534018" checked=""/><div class="controls bullet"><span class="by">Ajedi32</span><span>|</span><a href="#39531892">root</a><span>|</span><a href="#39533289">parent</a><span>|</span><a href="#39532010">next</a><span>|</span><label class="collapse" for="c-39534018">[-]</label><label class="expand" for="c-39534018">[1 more]</label></div><br/><div class="children"><div class="content">Unless I&#x27;m mistaken, this is only a problem if you&#x27;re forwarding ports from the Docker containers to the host machine, which isn&#x27;t necessary if the test itself is running from inside a Docker container on the same bridge network as your dependencies. (Which compose will set up for you by default.)</div><br/></div></div></div></div></div></div><div id="39532010" class="c"><input type="checkbox" id="c-39532010" checked=""/><div class="controls bullet"><span class="by">ath3nd</span><span>|</span><a href="#39531892">parent</a><span>|</span><a href="#39533099">prev</a><span>|</span><a href="#39532087">next</a><span>|</span><label class="collapse" for="c-39532010">[-]</label><label class="expand" for="c-39532010">[1 more]</label></div><br/><div class="children"><div class="content">As a user of testcontainers I can tell you they are very powerful yet simple.<p>Indeed all they do is provide an abstraction for your language, but this is soo useful for unit&#x2F;integration tests.<p>At my work we have many microservices in both Java and python, all of which use testcontainers to set up the local env or integration tests. The integration with localstack and the ability to programmatically set it up without fighting with compose files, is somewhat I find very useful.</div><br/></div></div><div id="39532087" class="c"><input type="checkbox" id="c-39532087" checked=""/><div class="controls bullet"><span class="by">cosmosgenius</span><span>|</span><a href="#39531892">parent</a><span>|</span><a href="#39532010">prev</a><span>|</span><a href="#39532520">next</a><span>|</span><label class="collapse" for="c-39532087">[-]</label><label class="expand" for="c-39532087">[1 more]</label></div><br/><div class="children"><div class="content">I just started using them specifically to test docker container implementation (Correctness of Dockerfile, entrypoint etc.)</div><br/></div></div></div></div><div id="39532520" class="c"><input type="checkbox" id="c-39532520" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#39531892">prev</a><span>|</span><a href="#39534178">next</a><span>|</span><label class="collapse" for="c-39532520">[-]</label><label class="expand" for="c-39532520">[13 more]</label></div><br/><div class="children"><div class="content">&gt; No more need for mocks or complicated environment configurations. Define your test dependencies as code, then simply run your tests and containers will be created and then deleted.<p>Wait what? They think you don&#x27;t need unit tests because you can run integration tests with containers?<p>It&#x27;s trivial to set up a docker container with one of your dependencies, but starting containers is painful and slow.</div><br/><div id="39532672" class="c"><input type="checkbox" id="c-39532672" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#39532520">parent</a><span>|</span><a href="#39533718">next</a><span>|</span><label class="collapse" for="c-39532672">[-]</label><label class="expand" for="c-39532672">[7 more]</label></div><br/><div class="children"><div class="content">1) At least in the Java world, the term &quot;unit testing&quot; is often confused by &quot;things you do in JUnit&quot;, which runs both &quot;pure&quot; unit tests and project-level integration tests, i.e. spinning up an application context (like Spring) and testing against real REST endpoints etc.<p>2) While unit tests are cheaper and quicker than (project-level) integration tests, they also in many cases don&#x27;t provide results as good a result and level of confidence, because a lot of run-time aspects (serialization, HTTP responses, database responses, etc.) are not as straightforward to mock. There&#x27;s been some noise about The Testing Trophy, instead of the Testing Pyramid where, in short, there are still unit tests where it makes sense, but a lot of testing has moved to the (project-level) integration tests. These are slower, but only by so much that the trade-off is often worth it. Whether it&#x27;s worth it, depends heavily on what you&#x27;re testing. If it&#x27;s a CRUD API: I use integration tests. If it&#x27;s something algorithmic, or string manipulation, etc.: I use unit tests.<p>When I saw the Testing Trophy presented, it came with the asterisk that (project-level) integration testing has gotten easier and cheaper over time, thus allowing a shift in trade-off. Testcontainers is one of the primary reasons why this shift has happened. (And... I respect that it&#x27;s not for everyone.)<p>Some references:
<a href="https:&#x2F;&#x2F;kentcdodds.com&#x2F;blog&#x2F;the-testing-trophy-and-testing-classifications" rel="nofollow">https:&#x2F;&#x2F;kentcdodds.com&#x2F;blog&#x2F;the-testing-trophy-and-testing-c...</a>
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=t-HmXomntCA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=t-HmXomntCA</a></div><br/><div id="39532899" class="c"><input type="checkbox" id="c-39532899" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#39532520">root</a><span>|</span><a href="#39532672">parent</a><span>|</span><a href="#39533718">next</a><span>|</span><label class="collapse" for="c-39532899">[-]</label><label class="expand" for="c-39532899">[6 more]</label></div><br/><div class="children"><div class="content">Yeah, certainly I see the value of those kinds of tests. And clearly as you say the simpler tests don&#x27;t provide as realistic a simulation as the more expensive tests.<p>But on the test philosophy angle, my take on what&#x27;s happening is just that developers traditionally look for any reason to skip tests. I&#x27;ve seen this in a few different forms.<p>- right now containers make it trivial to run all of your dependencies. That&#x27;s much easier than creating a mock or a fake, so we do that and don&#x27;t bother creating a mock&#x2F;fake.<p>- compiler folks have created great static analysis tools. That&#x27;s easier than writing a bunch of tests, so we&#x27;ll just assume static analysis will catch our bugs for us.<p>- &lt;my language&gt;&#x27;s types system does a bunch of work type checking, so I don&#x27;t need tests. Or maybe I just need randomly generated property tests.<p>- no tests can sufficiently emulate our production environment, so tests are noise and we&#x27;ll work out issues in dev and prod.<p>What I&#x27;ve noticed, though, is that looking across a wide number of software projects is there&#x27;s a clear difference in quality between projects that have a strong testing discipline and those that convince themselves they don&#x27;t need tests because of &lt;containers, or types, or whatever else&gt;.<p>Sure it&#x27;s possible that tests don&#x27;t cause the quality difference (maybe there&#x27;s a third factor for example that causes both). And of course if you have limited resources you have to make a decision about which quality assurance steps to cut.<p>But personally I respect a project more if they just say they don&#x27;t have the bandwidth to test properly so they&#x27;re just skipping to the integration stage (or whatever) rather than convince themselves that those tests weren&#x27;t important any way. Because I&#x27;ve seen so many projects that would have been much better with even a small number of unit tests where they only had integration tests.</div><br/><div id="39534327" class="c"><input type="checkbox" id="c-39534327" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#39532520">root</a><span>|</span><a href="#39532899">parent</a><span>|</span><a href="#39533787">next</a><span>|</span><label class="collapse" for="c-39534327">[-]</label><label class="expand" for="c-39534327">[1 more]</label></div><br/><div class="children"><div class="content">I think testing is very important. But it&#x27;s very hard to test everything. (It is not hard to get 100% test coverage by some metric, but that does not mean that all scenarios or even the most useful ones are covered.) So it&#x27;s an economics game: how can you get the most value for the least amount of money? Or if you want me to rephrase that in a more-positive way: how can you get the most value out of the time that you have available? And I contend that a shift &quot;up&quot; in the pyramid (at which time it looses that shape, hence the &quot;testing trophy&quot;) is where the current sweet spot lies. You have to use the tools that you have.</div><br/></div></div><div id="39533787" class="c"><input type="checkbox" id="c-39533787" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39532520">root</a><span>|</span><a href="#39532899">parent</a><span>|</span><a href="#39534327">prev</a><span>|</span><a href="#39533718">next</a><span>|</span><label class="collapse" for="c-39533787">[-]</label><label class="expand" for="c-39533787">[4 more]</label></div><br/><div class="children"><div class="content">Sounds like some kind of protestant work ethic mentality: testing should be hard work, the harder writing your tests was the better your soul and the better your system.<p>I&#x27;ve seen plenty of projects that made oodles of mocks and fakes and unit tests and just sucked, outright didn&#x27;t work at all in a way that would&#x27;ve been obvious if they&#x27;d done testcontainers-based integration tests or even just manual testing in prod. I would absolutely trust a project that was written in Haskell and had no tests, or only integration tests, ahead of one that had lots of unit tests. Indeed if anything I&#x27;d say the number of mocks&#x2F;fakes is negatively correlated with the actual project quality.</div><br/><div id="39534341" class="c"><input type="checkbox" id="c-39534341" checked=""/><div class="controls bullet"><span class="by">sverhagen</span><span>|</span><a href="#39532520">root</a><span>|</span><a href="#39533787">parent</a><span>|</span><a href="#39533718">next</a><span>|</span><label class="collapse" for="c-39534341">[-]</label><label class="expand" for="c-39534341">[3 more]</label></div><br/><div class="children"><div class="content">Just to add, there&#x27;s also a (Chicago) school of thought that pushes back against mocks and fakes, so even if you&#x27;re religiously (to stick with the metaphore) writing unit tests, you might still not invest in mocks and fakes.</div><br/><div id="39534629" class="c"><input type="checkbox" id="c-39534629" checked=""/><div class="controls bullet"><span class="by">Mavvie</span><span>|</span><a href="#39532520">root</a><span>|</span><a href="#39534341">parent</a><span>|</span><a href="#39533718">next</a><span>|</span><label class="collapse" for="c-39534629">[-]</label><label class="expand" for="c-39534629">[2 more]</label></div><br/><div class="children"><div class="content">Can you (or someone else) explain what the alternatives are? How can I write unit tests without mocks or fakes?</div><br/><div id="39535174" class="c"><input type="checkbox" id="c-39535174" checked=""/><div class="controls bullet"><span class="by">hyperadvanced</span><span>|</span><a href="#39532520">root</a><span>|</span><a href="#39534629">parent</a><span>|</span><a href="#39533718">next</a><span>|</span><label class="collapse" for="c-39535174">[-]</label><label class="expand" for="c-39535174">[1 more]</label></div><br/><div class="children"><div class="content">They might mean that rather than using a mock, use a real typed object&#x2F;instance of a real thing and inject it into the unit that you’re testing. Admittedly, that might meet the definition of a fake&#x2F;mock once you get down to the level of testing something that needs db access. Another way of interpreting that is that you can use in memory versions of your deps to mirror the interface of your dependency without needing to repeatedly, and possibly haphazardly mock certain functions of your dependency.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39533718" class="c"><input type="checkbox" id="c-39533718" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#39532520">parent</a><span>|</span><a href="#39532672">prev</a><span>|</span><a href="#39532573">next</a><span>|</span><label class="collapse" for="c-39533718">[-]</label><label class="expand" for="c-39533718">[1 more]</label></div><br/><div class="children"><div class="content">I have been doing E2E testing exclusively for close to a decade on several apps and it works great.<p>Note, not integration, E2E. I can go from bare vm to fully tested system in under 15 minutes. I can re run that test in 1-5 (depending on project) ...<p>Im creating 100&#x27;s of records in that time, and fuzzing a lot of data entry. I could get it to go &quot;even faster&quot; if I went in and removed some of the stepwise testing... A-&gt;B-&gt;C-&gt;D could be broken out to a-&gt;b, a-&gt;c, a-&gt;d.<p>Because my tests are external, they would be durable across a system re-write (if I need to change language, platform etc). They can also be re-used&#x2F;tweeked to test system perf under load (something unit tests could never do).</div><br/></div></div><div id="39532573" class="c"><input type="checkbox" id="c-39532573" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#39532520">parent</a><span>|</span><a href="#39533718">prev</a><span>|</span><a href="#39534178">next</a><span>|</span><label class="collapse" for="c-39532573">[-]</label><label class="expand" for="c-39532573">[4 more]</label></div><br/><div class="children"><div class="content">No mocks doesn&#x27;t mean no tests. It means running tests against the full code path which includes requests to running instances of the services you might otherwise mock. For many apps and use cases, the overhead in managing container state is worth it.</div><br/><div id="39532676" class="c"><input type="checkbox" id="c-39532676" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#39532520">root</a><span>|</span><a href="#39532573">parent</a><span>|</span><a href="#39534178">next</a><span>|</span><label class="collapse" for="c-39532676">[-]</label><label class="expand" for="c-39532676">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It means running tests against the full code path which includes requests to running instances of the services you might otherwise mock.<p>Yeah, those are called end to end tests and you run them after integration tests which you run after unit tests. It sounds to me like they&#x27;re saying just skip to the end to end tests.<p>&gt; For many apps and use cases, the overhead in managing container state is worth it.<p>Yeah, and typically you&#x27;d run them after you run unit and integration tests. If I have 10 libraries to test that have database access, I have to run 10 database containers simultaneously every few minutes as part of the development process? That&#x27;s overkill.</div><br/><div id="39533816" class="c"><input type="checkbox" id="c-39533816" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39532520">root</a><span>|</span><a href="#39532676">parent</a><span>|</span><a href="#39533048">next</a><span>|</span><label class="collapse" for="c-39533816">[-]</label><label class="expand" for="c-39533816">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yeah, and typically you&#x27;d run them after you run unit and integration tests. If I have 10 libraries to test that have database access, I have to run 10 database containers simultaneously every few minutes as part of the development process? That&#x27;s overkill.<p>If it&#x27;s actually causing you problems, then by all means replace some of them with more lightweight tests, at the cost of some test environment faithfulness. But don&#x27;t optimise prematurely.</div><br/></div></div></div></div></div></div></div></div><div id="39534178" class="c"><input type="checkbox" id="c-39534178" checked=""/><div class="controls bullet"><span class="by">jake_morrison</span><span>|</span><a href="#39532520">prev</a><span>|</span><a href="#39532591">next</a><span>|</span><label class="collapse" for="c-39534178">[-]</label><label class="expand" for="c-39534178">[2 more]</label></div><br/><div class="children"><div class="content">You can do something similar with docker compose, driving the system from the outside. Create dockerized versions of dependencies like the database, build and run tests, and then run tests against the production app container.
It&#x27;s particularly useful for testing a set of microservices.<p>See <a href="https:&#x2F;&#x2F;github.com&#x2F;cogini&#x2F;phoenix_container_example">https:&#x2F;&#x2F;github.com&#x2F;cogini&#x2F;phoenix_container_example</a> for a full example.
This blog post describes it in detail: <a href="https:&#x2F;&#x2F;www.cogini.com&#x2F;blog&#x2F;breaking-up-the-monolith-building-testing-and-deploying-microservices&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cogini.com&#x2F;blog&#x2F;breaking-up-the-monolith-buildin...</a></div><br/><div id="39534225" class="c"><input type="checkbox" id="c-39534225" checked=""/><div class="controls bullet"><span class="by">m00x</span><span>|</span><a href="#39534178">parent</a><span>|</span><a href="#39532591">next</a><span>|</span><label class="collapse" for="c-39534225">[-]</label><label class="expand" for="c-39534225">[1 more]</label></div><br/><div class="children"><div class="content">We use docker environments like this for tests, but it does have its issues.<p>You often need to add custom behavior like waiting for the app to load and start serving, healthchecks, etc. Having it all in code is pretty useful, and it&#x27;s self-contained within the code itself vs having to set up the environment in different places (CI, Github actions, local dev, etc).<p>The negative is that code isn&#x27;t portable to prod, it doesn&#x27;t test your environment as well (important for staging), and you&#x27;re missing out on sharing some environment settings.<p>I feel like it definitely has its place in the stack and in certain companies.</div><br/></div></div></div></div><div id="39532591" class="c"><input type="checkbox" id="c-39532591" checked=""/><div class="controls bullet"><span class="by">nonethewiser</span><span>|</span><a href="#39534178">prev</a><span>|</span><a href="#39534046">next</a><span>|</span><label class="collapse" for="c-39532591">[-]</label><label class="expand" for="c-39532591">[1 more]</label></div><br/><div class="children"><div class="content">Its great but I find it harder to debug. And I have to say, I usually dont need it. Typically i just have some command which spins everything up from docker-compose files. I prefer this over putting configuration in code like you often do with test containers. You can also load from docker compose files but at that point the test container API isn’t really doing much.<p>Its pretty much required when you want to setup&#x2F;teardown in between tests though. This just usually isnt the case for me.</div><br/></div></div><div id="39534046" class="c"><input type="checkbox" id="c-39534046" checked=""/><div class="controls bullet"><span class="by">avensec</span><span>|</span><a href="#39532591">prev</a><span>|</span><a href="#39535026">next</a><span>|</span><label class="collapse" for="c-39534046">[-]</label><label class="expand" for="c-39534046">[1 more]</label></div><br/><div class="children"><div class="content">Reading through the comments, I&#x27;m quite shocked to see how many deterrent conversations are happening without any understanding of the underlying tech stacks being tested. Testcontainers can be fantastic, especially when you are facing test environment overhead challenges, <i>assuming</i> you have the appropriate architectures &#x2F; service boundaries to support it. I believe there is more code out there in existence with architectures that make using Testcontainers more challenging than it is worth.</div><br/></div></div><div id="39535026" class="c"><input type="checkbox" id="c-39535026" checked=""/><div class="controls bullet"><span class="by">iamkoch</span><span>|</span><a href="#39534046">prev</a><span>|</span><a href="#39534061">next</a><span>|</span><label class="collapse" for="c-39535026">[-]</label><label class="expand" for="c-39535026">[1 more]</label></div><br/><div class="children"><div class="content">If you build inside docker, running tests that use docker is a pain.<p>Go has a lot of in-memory versions of things for tests, which run so much quicker than leaning on docker. Similarly, I found C# has in-memory versions of deps you can lean on.<p>I really feel that test containers, although solving a problem, often introduces others for no great benefit</div><br/></div></div><div id="39534061" class="c"><input type="checkbox" id="c-39534061" checked=""/><div class="controls bullet"><span class="by">badoongi</span><span>|</span><a href="#39535026">prev</a><span>|</span><a href="#39532076">next</a><span>|</span><label class="collapse" for="c-39534061">[-]</label><label class="expand" for="c-39534061">[1 more]</label></div><br/><div class="children"><div class="content">I see testcontainers being used in tests making the test code style feel more like typical unit tests with fake implementations for system components. Which is misleading as these are more on the integration testing side typically. In essence this is another DSL (per language) for managing containers locally. And this DSL comes in addition to whatever system is actually used for managing containers in production for the project.</div><br/></div></div><div id="39532076" class="c"><input type="checkbox" id="c-39532076" checked=""/><div class="controls bullet"><span class="by">senorrib</span><span>|</span><a href="#39534061">prev</a><span>|</span><a href="#39532380">next</a><span>|</span><label class="collapse" for="c-39532076">[-]</label><label class="expand" for="c-39532076">[20 more]</label></div><br/><div class="children"><div class="content">Pulling up infra to run unit tests is an anti-pattern. This is a great tool for integration tests, though.</div><br/><div id="39532432" class="c"><input type="checkbox" id="c-39532432" checked=""/><div class="controls bullet"><span class="by">maxdaten</span><span>|</span><a href="#39532076">parent</a><span>|</span><a href="#39532103">next</a><span>|</span><label class="collapse" for="c-39532432">[-]</label><label class="expand" for="c-39532432">[3 more]</label></div><br/><div class="children"><div class="content">honest question: how are you writing integration tests? We are writing these as separate test suite often with the same test style. And in this scenario testcontainers are very valuable.</div><br/><div id="39533102" class="c"><input type="checkbox" id="c-39533102" checked=""/><div class="controls bullet"><span class="by">codeonline</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532432">parent</a><span>|</span><a href="#39532103">next</a><span>|</span><label class="collapse" for="c-39533102">[-]</label><label class="expand" for="c-39533102">[2 more]</label></div><br/><div class="children"><div class="content">Why not use docker compose, bring up your infra in one container, your application in a second and your tests access it the application from a third.</div><br/><div id="39534409" class="c"><input type="checkbox" id="c-39534409" checked=""/><div class="controls bullet"><span class="by">imp0cat</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39533102">parent</a><span>|</span><a href="#39532103">next</a><span>|</span><label class="collapse" for="c-39534409">[-]</label><label class="expand" for="c-39534409">[1 more]</label></div><br/><div class="children"><div class="content">Because you don&#x27;t have to muck around with docker-compose. I guess some people might find that more attractive.</div><br/></div></div></div></div></div></div><div id="39532103" class="c"><input type="checkbox" id="c-39532103" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#39532076">parent</a><span>|</span><a href="#39532432">prev</a><span>|</span><a href="#39532380">next</a><span>|</span><label class="collapse" for="c-39532103">[-]</label><label class="expand" for="c-39532103">[16 more]</label></div><br/><div class="children"><div class="content">What if you are unit testing something that is dependent on infra?</div><br/><div id="39534791" class="c"><input type="checkbox" id="c-39534791" checked=""/><div class="controls bullet"><span class="by">occz</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532103">parent</a><span>|</span><a href="#39534686">next</a><span>|</span><label class="collapse" for="c-39534791">[-]</label><label class="expand" for="c-39534791">[1 more]</label></div><br/><div class="children"><div class="content">Arguably you&#x27;re no longer testing a unit if the unit involves an integration with an external component, making it an integration test per definition.<p>Integration tests are fine, but they test something else - that your component integrates as intended with &lt;something&gt;, while a unit test moreso tests that your unit behaves in accordance with its specification.</div><br/></div></div><div id="39534686" class="c"><input type="checkbox" id="c-39534686" checked=""/><div class="controls bullet"><span class="by">politelemon</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532103">parent</a><span>|</span><a href="#39534791">prev</a><span>|</span><a href="#39532964">next</a><span>|</span><label class="collapse" for="c-39534686">[-]</label><label class="expand" for="c-39534686">[1 more]</label></div><br/><div class="children"><div class="content">If you aren&#x27;t mocking away the infra, that&#x27;s an integration test.</div><br/></div></div><div id="39532964" class="c"><input type="checkbox" id="c-39532964" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532103">parent</a><span>|</span><a href="#39534686">prev</a><span>|</span><a href="#39532178">next</a><span>|</span><label class="collapse" for="c-39532964">[-]</label><label class="expand" for="c-39532964">[3 more]</label></div><br/><div class="children"><div class="content">You unit test your own code, not its underlying dependencies. If the dependencies cannot be easily mocked then the code is in need of a refactor.</div><br/><div id="39533074" class="c"><input type="checkbox" id="c-39533074" checked=""/><div class="controls bullet"><span class="by">metaltyphoon</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532964">parent</a><span>|</span><a href="#39532178">next</a><span>|</span><label class="collapse" for="c-39533074">[-]</label><label class="expand" for="c-39533074">[2 more]</label></div><br/><div class="children"><div class="content">This makes no sense tho. Simple example, your code needs to reach into Cosmos &#x2F; DynamoDB, why mock this service when u can get so much wrong by assuming how things work?</div><br/><div id="39533142" class="c"><input type="checkbox" id="c-39533142" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39533074">parent</a><span>|</span><a href="#39532178">next</a><span>|</span><label class="collapse" for="c-39533142">[-]</label><label class="expand" for="c-39533142">[1 more]</label></div><br/><div class="children"><div class="content">Mocking doesn&#x27;t mean you have to reimplement the fully featured service. In the simplest form your internal library which calls out to Cosmos is mocked, the mock records the request parameters and returns ok, and the test verifies that the expected data was passed in the call.</div><br/></div></div></div></div></div></div><div id="39532178" class="c"><input type="checkbox" id="c-39532178" checked=""/><div class="controls bullet"><span class="by">devthane</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532103">parent</a><span>|</span><a href="#39532964">prev</a><span>|</span><a href="#39532172">next</a><span>|</span><label class="collapse" for="c-39532178">[-]</label><label class="expand" for="c-39532178">[9 more]</label></div><br/><div class="children"><div class="content">Typically you mock them in unit tests.</div><br/><div id="39532233" class="c"><input type="checkbox" id="c-39532233" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532178">parent</a><span>|</span><a href="#39532242">next</a><span>|</span><label class="collapse" for="c-39532233">[-]</label><label class="expand" for="c-39532233">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve rarely found this to be worth it, for the effort required for a proper mock, in a complex system. I&#x27;ve seen most people mock in ways that are so superficial that it&#x27;s basically a no-op.</div><br/><div id="39532352" class="c"><input type="checkbox" id="c-39532352" checked=""/><div class="controls bullet"><span class="by">CuriouslyC</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532233">parent</a><span>|</span><a href="#39532242">next</a><span>|</span><label class="collapse" for="c-39532352">[-]</label><label class="expand" for="c-39532352">[3 more]</label></div><br/><div class="children"><div class="content">Mocks are a contentious topic as you&#x27;ve probably guessed.  In my opinion they&#x27;re a sign of coupled code, you should be able to hit very high coverage without a single mock, but if you&#x27;re a dev in an org that tracks code coverage you&#x27;ll probably end up writing a fair number of them since the odds are high you&#x27;ll be consuming coupled code.</div><br/><div id="39532434" class="c"><input type="checkbox" id="c-39532434" checked=""/><div class="controls bullet"><span class="by">jerrygenser</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532352">parent</a><span>|</span><a href="#39532242">next</a><span>|</span><label class="collapse" for="c-39532434">[-]</label><label class="expand" for="c-39532434">[2 more]</label></div><br/><div class="children"><div class="content">If you have a dependency like a third party API (or even internal code), and you write an API client, then depend on that client, would it be considered couple code?<p>In such cases, if I am using dependency injection and creating a (stub?) versions of that client which returns a hardcoded or configured output, would that be  considered a mock? OR would this be OK and not &quot;coupled&quot;?</div><br/><div id="39532589" class="c"><input type="checkbox" id="c-39532589" checked=""/><div class="controls bullet"><span class="by">aleksiy123</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532434">parent</a><span>|</span><a href="#39532242">next</a><span>|</span><label class="collapse" for="c-39532589">[-]</label><label class="expand" for="c-39532589">[1 more]</label></div><br/><div class="children"><div class="content">I think mocking with DI makes perfect sense.<p>Most people will say something like for unit tests you should test your functions by passing the state as parameters to test. I&#x27;m going to call this &quot;outside in&quot; loose coupling.<p>Mocking is for the inverse. When you want to test a unit of code that is calling some other outside unit code. Its really not any different just &quot;inside out&quot;.<p>So imo with DI you gain loose coupling through dependency inversion. But because of dependency inversion you need to mock instead of passing state as params.<p>So I think if you are injecting a mocked stub this is still loose coupling because you are testing against its interface.<p>You&#x27;re still passing state through your test but its coming from inside instead of outside, hence the mock.<p>Another way I have thought about this is: framework (framework calls you) vs library (you call library).<p>Frameworks naturally lend themselves to a more mock way of testing. Library lends itself to a more traditional way of testing.<p>Testing something that accepts a callback is also essentially a mock.<p>I hope that thought made sense.</div><br/></div></div></div></div></div></div></div></div><div id="39532242" class="c"><input type="checkbox" id="c-39532242" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532178">parent</a><span>|</span><a href="#39532233">prev</a><span>|</span><a href="#39532172">next</a><span>|</span><label class="collapse" for="c-39532242">[-]</label><label class="expand" for="c-39532242">[4 more]</label></div><br/><div class="children"><div class="content">Seems like such a test would be strictly less useful than a test that runs against the real dependeny.</div><br/><div id="39532312" class="c"><input type="checkbox" id="c-39532312" checked=""/><div class="controls bullet"><span class="by">vilunov</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532242">parent</a><span>|</span><a href="#39532309">next</a><span>|</span><label class="collapse" for="c-39532312">[-]</label><label class="expand" for="c-39532312">[1 more]</label></div><br/><div class="children"><div class="content">Then don&#x27;t do it in unit tests and write an integration test.</div><br/></div></div><div id="39532309" class="c"><input type="checkbox" id="c-39532309" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532242">parent</a><span>|</span><a href="#39532312">prev</a><span>|</span><a href="#39532172">next</a><span>|</span><label class="collapse" for="c-39532309">[-]</label><label class="expand" for="c-39532309">[2 more]</label></div><br/><div class="children"><div class="content">But vastly faster.<p>A good rule of thumb for a unit test is that you should be able to run it a few thousand times in a relatively brief period (think: minutes or less) and it shouldn&#x27;t ever fail&#x2F;flake.<p>If a unit test (suite) takes more than a single digit number of seconds to run, it isn&#x27;t a unit test. Integration tests are good to have, but unit tests should be really cheap and fundamentally a tool for iterative and interactive development. I should be able to run some of my unit tests on every save, and have them keep pace with my linter.</div><br/><div id="39532386" class="c"><input type="checkbox" id="c-39532386" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#39532076">root</a><span>|</span><a href="#39532309">parent</a><span>|</span><a href="#39532172">next</a><span>|</span><label class="collapse" for="c-39532386">[-]</label><label class="expand" for="c-39532386">[1 more]</label></div><br/><div class="children"><div class="content">Testcontainers don&#x27;t typically add more than a few seconds to a suite though.  They are very fast.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39532380" class="c"><input type="checkbox" id="c-39532380" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39532076">prev</a><span>|</span><a href="#39532794">next</a><span>|</span><label class="collapse" for="c-39532380">[-]</label><label class="expand" for="c-39532380">[2 more]</label></div><br/><div class="children"><div class="content">I was intrigued to see that they have PyPI packages for a ton of different things - like <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;testcontainers-postgres" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;testcontainers-postgres</a><p>That wheel file is only 2.9KB, so I grabbed a copy to see how it works. I&#x27;ve put the contents in a Gist here: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;simonw&#x2F;c53f80a525d573533a730f5f28858f84" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;simonw&#x2F;c53f80a525d573533a730f5f28858...</a><p>It&#x27;s pretty neat - it depends on testcontainers-core, sqlalchemy and psycopg2-binary and then defines a PostgresContainer class which fires up a &quot;postgres:latest&quot; container and provides a helper function for getting the right connection URL.</div><br/><div id="39532642" class="c"><input type="checkbox" id="c-39532642" checked=""/><div class="controls bullet"><span class="by">gv83</span><span>|</span><a href="#39532380">parent</a><span>|</span><a href="#39532794">next</a><span>|</span><label class="collapse" for="c-39532642">[-]</label><label class="expand" for="c-39532642">[1 more]</label></div><br/><div class="children"><div class="content">This is also its downfall as my organization uses asyncpg and compatibility with it is still absent iirc :(</div><br/></div></div></div></div><div id="39532794" class="c"><input type="checkbox" id="c-39532794" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#39532380">prev</a><span>|</span><a href="#39532133">next</a><span>|</span><label class="collapse" for="c-39532794">[-]</label><label class="expand" for="c-39532794">[1 more]</label></div><br/><div class="children"><div class="content">I read through the docs and am still confused about what this actually does beyond running a single docker run command in the background and returning control to your code when the container is up.</div><br/></div></div><div id="39532133" class="c"><input type="checkbox" id="c-39532133" checked=""/><div class="controls bullet"><span class="by">alifaziz</span><span>|</span><a href="#39532794">prev</a><span>|</span><a href="#39533549">next</a><span>|</span><label class="collapse" for="c-39532133">[-]</label><label class="expand" for="c-39532133">[4 more]</label></div><br/><div class="children"><div class="content">Unit test suppose to be fast. Especially during coding. I wonder how this is necessary &amp; not affecting the test feedback speed</div><br/><div id="39532271" class="c"><input type="checkbox" id="c-39532271" checked=""/><div class="controls bullet"><span class="by">alemanek</span><span>|</span><a href="#39532133">parent</a><span>|</span><a href="#39532253">next</a><span>|</span><label class="collapse" for="c-39532271">[-]</label><label class="expand" for="c-39532271">[2 more]</label></div><br/><div class="children"><div class="content">This is for integration tests.</div><br/><div id="39532783" class="c"><input type="checkbox" id="c-39532783" checked=""/><div class="controls bullet"><span class="by">thomasfromcdnjs</span><span>|</span><a href="#39532133">root</a><span>|</span><a href="#39532271">parent</a><span>|</span><a href="#39532253">next</a><span>|</span><label class="collapse" for="c-39532783">[-]</label><label class="expand" for="c-39532783">[1 more]</label></div><br/><div class="children"><div class="content">Homepage hero says &quot;Unit tests with real dependencies&quot;</div><br/></div></div></div></div><div id="39532253" class="c"><input type="checkbox" id="c-39532253" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#39532133">parent</a><span>|</span><a href="#39532271">prev</a><span>|</span><a href="#39533549">next</a><span>|</span><label class="collapse" for="c-39532253">[-]</label><label class="expand" for="c-39532253">[1 more]</label></div><br/><div class="children"><div class="content">Testcontainers are surprisingly fast.  Like seconds of runtime for a suite.</div><br/></div></div></div></div><div id="39533549" class="c"><input type="checkbox" id="c-39533549" checked=""/><div class="controls bullet"><span class="by">nslindtner</span><span>|</span><a href="#39532133">prev</a><span>|</span><a href="#39534115">next</a><span>|</span><label class="collapse" for="c-39533549">[-]</label><label class="expand" for="c-39533549">[1 more]</label></div><br/><div class="children"><div class="content">Wow ... the syntax reminds me so much of aspire (microsoft new &quot;composer&quot;-syntax). Makes a lot of sense.<p>Why not keep this information in code .. often the developers are ending up doing those task anyway. (not recommended .. but seen it so many times)<p>Link: Microsoft aspire (<a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;aspire&#x2F;get-started&#x2F;aspire-overview" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;aspire&#x2F;get-started&#x2F;...</a>)</div><br/></div></div><div id="39534115" class="c"><input type="checkbox" id="c-39534115" checked=""/><div class="controls bullet"><span class="by">febed</span><span>|</span><a href="#39533549">prev</a><span>|</span><a href="#39533387">next</a><span>|</span><label class="collapse" for="c-39534115">[-]</label><label class="expand" for="c-39534115">[1 more]</label></div><br/><div class="children"><div class="content">I tried to use Testcontainers just last week but ended up using simple docker commands instead. I didn’t find an easy way to connect an already running set of containers started via docker compose. Was straightforward to do with a set of scripts that just call docker exec.</div><br/></div></div><div id="39533387" class="c"><input type="checkbox" id="c-39533387" checked=""/><div class="controls bullet"><span class="by">pylua</span><span>|</span><a href="#39534115">prev</a><span>|</span><a href="#39533365">next</a><span>|</span><label class="collapse" for="c-39533387">[-]</label><label class="expand" for="c-39533387">[1 more]</label></div><br/><div class="children"><div class="content">I found test containers to be slow to startup last year. It wasn’t worth the effort considering how long it took to run compared to traditional spring IT h2 hibernate.</div><br/></div></div><div id="39533365" class="c"><input type="checkbox" id="c-39533365" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#39533387">prev</a><span>|</span><a href="#39534429">next</a><span>|</span><label class="collapse" for="c-39533365">[-]</label><label class="expand" for="c-39533365">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Unit tests with real dependencies</i><p>That&#x27;s an integration test. These are integration tests. You&#x27;re literally testing multiple units (e.g., Redis, and the thing using Redis) to see if they&#x27;re integrating.<p>Why do we even have words.<p>These are valuable in their own right. They&#x27;re just complicated &amp; often incredibly slow compared to a unit test. Which is why I prefer mocks, too: they&#x27;re speedy. You just have to get the mock right … and that <i>can</i> be tricky, particularly since some APIs are just woefully underdocumented, or the documentation is just full of lies. But the mocks I&#x27;ve written in the past steadily improve over time. Learn to stop worrying, and love each for what they are.<p>(Our CI system actually used to pretty much directly support this pattern. Then we moved to Github Actions. GHA has &quot;service containers&quot;, but unfortunately the feature is too basic to address real-world use cases: it assumes a container image can just … boot! … and only talk to the code via the network. Real world use cases often require serialized steps between the test &amp; the dependencies, e.g., to create or init database dirs, set up certs, etc.)</div><br/></div></div><div id="39534429" class="c"><input type="checkbox" id="c-39534429" checked=""/><div class="controls bullet"><span class="by">joeevans1000</span><span>|</span><a href="#39533365">prev</a><span>|</span><a href="#39533897">next</a><span>|</span><label class="collapse" for="c-39534429">[-]</label><label class="expand" for="c-39534429">[2 more]</label></div><br/><div class="children"><div class="content">Forgive the question... but... why can&#x27;t &#x27;test&#x27; containers be &#x27;prod&#x27; containers?</div><br/><div id="39534541" class="c"><input type="checkbox" id="c-39534541" checked=""/><div class="controls bullet"><span class="by">jamesdepp</span><span>|</span><a href="#39534429">parent</a><span>|</span><a href="#39533897">next</a><span>|</span><label class="collapse" for="c-39534541">[-]</label><label class="expand" for="c-39534541">[1 more]</label></div><br/><div class="children"><div class="content">Some tests might have side effects. Probably not a great idea to test the function “bill customer” on a prod deployment. That’s why containers for testing is great—it’s easy to spin up an environment that can be messed around with without consequences (even if things go wrong or your tests have side effects).</div><br/></div></div></div></div><div id="39533897" class="c"><input type="checkbox" id="c-39533897" checked=""/><div class="controls bullet"><span class="by">leonardXu</span><span>|</span><a href="#39534429">prev</a><span>|</span><a href="#39533934">next</a><span>|</span><label class="collapse" for="c-39533897">[-]</label><label class="expand" for="c-39533897">[1 more]</label></div><br/><div class="children"><div class="content">My team maintain a lot of flink connectors, We&#x27;ve changed external test resources to testcontainer as much as possible, it makes things simple and saves money as well.</div><br/></div></div><div id="39533934" class="c"><input type="checkbox" id="c-39533934" checked=""/><div class="controls bullet"><span class="by">asciii</span><span>|</span><a href="#39533897">prev</a><span>|</span><a href="#39532419">next</a><span>|</span><label class="collapse" for="c-39533934">[-]</label><label class="expand" for="c-39533934">[1 more]</label></div><br/><div class="children"><div class="content">Never heard of this, also the label in footer for careers said &quot;We&#x27;re hiring&quot; but then lists no open positions :&#x2F;</div><br/></div></div><div id="39532419" class="c"><input type="checkbox" id="c-39532419" checked=""/><div class="controls bullet"><span class="by">mrAssHat</span><span>|</span><a href="#39533934">prev</a><span>|</span><a href="#39532634">next</a><span>|</span><label class="collapse" for="c-39532419">[-]</label><label class="expand" for="c-39532419">[6 more]</label></div><br/><div class="children"><div class="content">Testcontainers aren&#x27;t even compatible with kubernetes, that&#x27;s a tool from the past.</div><br/><div id="39532452" class="c"><input type="checkbox" id="c-39532452" checked=""/><div class="controls bullet"><span class="by">the_jeremy</span><span>|</span><a href="#39532419">parent</a><span>|</span><a href="#39532565">next</a><span>|</span><label class="collapse" for="c-39532452">[-]</label><label class="expand" for="c-39532452">[1 more]</label></div><br/><div class="children"><div class="content">We use [kubedock](<a href="https:&#x2F;&#x2F;github.com&#x2F;joyrex2001&#x2F;kubedock">https:&#x2F;&#x2F;github.com&#x2F;joyrex2001&#x2F;kubedock</a>) to run testcontainers in kubernetes clusters. As long as you&#x27;re only pulling the images, not building or loading them (explicitly not supported by kubedock), it works pretty well.</div><br/></div></div><div id="39532565" class="c"><input type="checkbox" id="c-39532565" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#39532419">parent</a><span>|</span><a href="#39532452">prev</a><span>|</span><a href="#39532866">next</a><span>|</span><label class="collapse" for="c-39532565">[-]</label><label class="expand" for="c-39532565">[3 more]</label></div><br/><div class="children"><div class="content">Why&#x27;d you run them in kubernetes?  Seems like extreme overkill for launching a short lived container for an integration test.  What could kubernetes possibly add to that?</div><br/><div id="39532749" class="c"><input type="checkbox" id="c-39532749" checked=""/><div class="controls bullet"><span class="by">mrAssHat</span><span>|</span><a href="#39532419">root</a><span>|</span><a href="#39532565">parent</a><span>|</span><a href="#39532866">next</a><span>|</span><label class="collapse" for="c-39532749">[-]</label><label class="expand" for="c-39532749">[2 more]</label></div><br/><div class="children"><div class="content">Because we are a big company and would like to utilize resources better.<p>We also want homogeneity in tech when possible (we already heavily use kubernetes, we don&#x27;t want to keep docker hosts anymore).<p>Teams of testers need to be accounted in terms of resource quotas and RBAC.<p>What exactly do you see as an overkill in wanting to run short-lived containers in kubernetes rather than in docker (if we already have kubernetes and &quot;cook&quot; it ourselves)?</div><br/><div id="39534722" class="c"><input type="checkbox" id="c-39534722" checked=""/><div class="controls bullet"><span class="by">politelemon</span><span>|</span><a href="#39532419">root</a><span>|</span><a href="#39532749">parent</a><span>|</span><a href="#39532866">next</a><span>|</span><label class="collapse" for="c-39534722">[-]</label><label class="expand" for="c-39534722">[1 more]</label></div><br/><div class="children"><div class="content">That reasoning seems more like one from policy&#x2F;cargo cult rather than reasoning specific to your org. For something short lived and meant to be isolated I wouldn&#x27;t want to subject them to even more infrastructural dependencies outside their control.</div><br/></div></div></div></div></div></div><div id="39532866" class="c"><input type="checkbox" id="c-39532866" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#39532419">parent</a><span>|</span><a href="#39532565">prev</a><span>|</span><a href="#39532634">next</a><span>|</span><label class="collapse" for="c-39532866">[-]</label><label class="expand" for="c-39532866">[1 more]</label></div><br/><div class="children"><div class="content">ROAC &quot;runs on any computer&quot;, which k8s does not.</div><br/></div></div></div></div><div id="39532634" class="c"><input type="checkbox" id="c-39532634" checked=""/><div class="controls bullet"><span class="by">bloopernova</span><span>|</span><a href="#39532419">prev</a><span>|</span><a href="#39533892">next</a><span>|</span><label class="collapse" for="c-39532634">[-]</label><label class="expand" for="c-39532634">[2 more]</label></div><br/><div class="children"><div class="content">Somewhat related: anyone here using AWS Neptune graphql database? How do you develop locally against Neptune? Apart from Localstack, is there a way to mock Neptune for local testing and development?</div><br/><div id="39532859" class="c"><input type="checkbox" id="c-39532859" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#39532634">parent</a><span>|</span><a href="#39533892">next</a><span>|</span><label class="collapse" for="c-39532859">[-]</label><label class="expand" for="c-39532859">[1 more]</label></div><br/><div class="children"><div class="content">You might take a look at Tinkerpop: <a href="https:&#x2F;&#x2F;tinkerpop.apache.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tinkerpop.apache.org&#x2F;</a></div><br/></div></div></div></div><div id="39533892" class="c"><input type="checkbox" id="c-39533892" checked=""/><div class="controls bullet"><span class="by">circusfly</span><span>|</span><a href="#39532634">prev</a><span>|</span><a href="#39533335">next</a><span>|</span><label class="collapse" for="c-39533892">[-]</label><label class="expand" for="c-39533892">[1 more]</label></div><br/><div class="children"><div class="content">No thanks, I will continue to roll my own to control it full, at home and at work.</div><br/></div></div><div id="39533335" class="c"><input type="checkbox" id="c-39533335" checked=""/><div class="controls bullet"><span class="by">paulv</span><span>|</span><a href="#39533892">prev</a><span>|</span><a href="#39534781">next</a><span>|</span><label class="collapse" for="c-39533335">[-]</label><label class="expand" for="c-39533335">[3 more]</label></div><br/><div class="children"><div class="content">Does this work with podman or is it docker only?</div><br/><div id="39533766" class="c"><input type="checkbox" id="c-39533766" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#39533335">parent</a><span>|</span><a href="#39533833">next</a><span>|</span><label class="collapse" for="c-39533766">[-]</label><label class="expand" for="c-39533766">[1 more]</label></div><br/><div class="children"><div class="content">If your running podman you should pull your production deployment configs down and tweak those. You will get a much more complete env that way (routing, network, scale, load balance)<p><a href="https:&#x2F;&#x2F;www.redhat.com&#x2F;sysadmin&#x2F;kubernetes-workloads-podman-systemd" rel="nofollow">https:&#x2F;&#x2F;www.redhat.com&#x2F;sysadmin&#x2F;kubernetes-workloads-podman-...</a> &lt;&lt; as a for instance ;)</div><br/></div></div><div id="39533833" class="c"><input type="checkbox" id="c-39533833" checked=""/><div class="controls bullet"><span class="by">ozarker</span><span>|</span><a href="#39533335">parent</a><span>|</span><a href="#39533766">prev</a><span>|</span><a href="#39534781">next</a><span>|</span><label class="collapse" for="c-39533833">[-]</label><label class="expand" for="c-39533833">[1 more]</label></div><br/><div class="children"><div class="content">I’ve used it with podman before, worked fine</div><br/></div></div></div></div><div id="39534781" class="c"><input type="checkbox" id="c-39534781" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39533335">prev</a><span>|</span><a href="#39532632">next</a><span>|</span><label class="collapse" for="c-39534781">[-]</label><label class="expand" for="c-39534781">[1 more]</label></div><br/><div class="children"><div class="content">I never really liked testcontainers. Too complicated. And I don&#x27;t want to have my tests make too many assumptions about what level of control there is over their environment. IMHO it&#x27;s just the wrong place to be messing with docker.<p>I don&#x27;t like layering abstractions on top of abstractions that were fine to begin with. Docker-compose is pretty much perfect for the job. An added complexity is that the before&#x2F;after semantics of the test suite in things like JUnit are a bit handwavy and hard to control. Unlike testng, there&#x27;s no @BeforeSuite (which is really what you want). The @BeforeAll that junit has is actually too late in the process to be messing around with docker. And more importantly, if I&#x27;m developing, I don&#x27;t want my docker containers to be wasting time restarting in between tests. That&#x27;s 20-30 seconds I don&#x27;t want to add on top of the already lengthy runtime of compiling&#x2F;building, firing up Spring and letting it do it&#x27;s thing before my test runs in about 1-2 seconds.<p>All this is trivially solved by doing docker stuff at the right time: before your test process starts.<p>So, I do that using good old docker compose and a simple gradle plugin that calls it before our tests run and then again to shut it down right after. If it&#x27;s already running (it simply probes the port) it skips the startup and shut down sequence and just leaves it running. It&#x27;s not perfect but it&#x27;s very simple. I have docker-compose up most of my working day. Sometimes for days on end. My tests don&#x27;t have to wait for it to come up because it&#x27;s already up. On CI (github actions), gradle starts docker compose, waits for it to come up, runs the tests, and then shuts it down.<p>This has another big advantage that the process of running a standalone development server for manual testing, running our integration tests, and running our production server are very similar. Exactly the same actually; the only difference configuration and some light bootstrapping logic (schema creation). Configuration basically involves telling our server the hosts and ports of all the stuff it needs to run. Which in our case is postgres, redis, and elasticsearch.<p>Editing the setup is easy; just edit the docker compose and modify some properties. Works with jvm based stuff and it&#x27;s equally easy to replicate with other stuff.<p>There are a few more tricks I use to keep things fast. I have ~300 integration tests that use db, redis, and elasticsearch. They run concurrently in under 1 minute on my mac. I cannot emphesize how important fast integration tests are as a key enabler for developer productivity. Enabling this sort of thing requires some planning but it pays off hugely.<p>I wrote up a detailed article on how to do this some years ago. <a href="https:&#x2F;&#x2F;www.jillesvangurp.com&#x2F;blog&#x2F;2016-05-25-functional-tests-and-flakyness.html" rel="nofollow">https:&#x2F;&#x2F;www.jillesvangurp.com&#x2F;blog&#x2F;2016-05-25-functional-tes...</a><p>That&#x27;s still what I do a few projects and companies later.</div><br/></div></div><div id="39532632" class="c"><input type="checkbox" id="c-39532632" checked=""/><div class="controls bullet"><span class="by">sigmonsays</span><span>|</span><a href="#39534781">prev</a><span>|</span><a href="#39532657">next</a><span>|</span><label class="collapse" for="c-39532632">[-]</label><label class="expand" for="c-39532632">[1 more]</label></div><br/><div class="children"><div class="content">been doing this for years, I would not say this gets rid of testing though.<p>Running integration tests are significantly more complicated to write and take longer to run.<p>There is also race conditions present that you need to account for programmatically.. Such as waiting for a db to come up and schema to be applied. Or waiting for a specific event to occur in the daemon.<p>That being said, this looks like a decent start. One thing that seems to be missing is the ability to tail logs and assert specific marks in the logs. Often you need to do an operation and wait until you see an event.</div><br/></div></div><div id="39532657" class="c"><input type="checkbox" id="c-39532657" checked=""/><div class="controls bullet"><span class="by">m3kw9</span><span>|</span><a href="#39532632">prev</a><span>|</span><a href="#39533237">next</a><span>|</span><label class="collapse" for="c-39532657">[-]</label><label class="expand" for="c-39532657">[3 more]</label></div><br/><div class="children"><div class="content">Not everything can be placed in a docker which seem as a requirement.</div><br/><div id="39533172" class="c"><input type="checkbox" id="c-39533172" checked=""/><div class="controls bullet"><span class="by">PaoloBarbolini</span><span>|</span><a href="#39532657">parent</a><span>|</span><a href="#39533237">next</a><span>|</span><label class="collapse" for="c-39533172">[-]</label><label class="expand" for="c-39533172">[2 more]</label></div><br/><div class="children"><div class="content">Could you provide an example?</div><br/><div id="39534044" class="c"><input type="checkbox" id="c-39534044" checked=""/><div class="controls bullet"><span class="by">gui77aume</span><span>|</span><a href="#39532657">root</a><span>|</span><a href="#39533172">parent</a><span>|</span><a href="#39533237">next</a><span>|</span><label class="collapse" for="c-39534044">[-]</label><label class="expand" for="c-39534044">[1 more]</label></div><br/><div class="children"><div class="content">Legacy systems I guess, maybe cloud specific services</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>