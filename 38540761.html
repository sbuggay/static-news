<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701853256376" as="style"/><link rel="stylesheet" href="styles.css?v=1701853256376"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://aphyr.com/posts/367-why-is-jepsen-written-in-clojure">Why is Jepsen written in Clojure?</a> <span class="domain">(<a href="https://aphyr.com">aphyr.com</a>)</span></div><div class="subtext"><span>manicennui</span> | <span>53 comments</span></div><br/><div><div id="38541475" class="c"><input type="checkbox" id="c-38541475" checked=""/><div class="controls bullet"><span class="by">jwr</span><span>|</span><a href="#38541028">next</a><span>|</span><label class="collapse" for="c-38541475">[-]</label><label class="expand" for="c-38541475">[2 more]</label></div><br/><div class="children"><div class="content">As a heavy user of Clojure (my SaaS is written in Clojure&#x2F;ClojureScript) for 10 years or so, I would fully agree with what Kyle wrote. In addition, things that I found very valuable:<p>* most of my domain code is in cljc files, so these get compiled both server-side and client-side and I get a huge boost from that<p>* transducers and transducer pipelines are an under-appreciated feature, I get huge mileage out of them, because of performance, composability and reusability<p>* stability and longevity: Clojure was created by a very experienced system designer and programmer (Rich Hickey) and it shows. Backwards compatibility is hugely important, and I can focus on my application rather than rely on tools that are a moving target. It&#x27;s not an accident that an average &quot;Clojure programmer&quot; (I dislike these kinds of tags, but let&#x27;s run with it here) has 12+ years of experience and earns a salary in the top quartile at least.</div><br/><div id="38541635" class="c"><input type="checkbox" id="c-38541635" checked=""/><div class="controls bullet"><span class="by">drikerf</span><span>|</span><a href="#38541475">parent</a><span>|</span><a href="#38541028">next</a><span>|</span><label class="collapse" for="c-38541635">[-]</label><label class="expand" for="c-38541635">[1 more]</label></div><br/><div class="children"><div class="content">Similar story. I&#x27;m also running my SaaS on Clojure and maintenance has been a dream compared to other languages. Things rarely break and are easy to upgrade.<p>Developer experience is fantastic too with HMR, REPL and cljc files. It&#x27;s fun to write Clojure code :)</div><br/></div></div></div></div><div id="38541028" class="c"><input type="checkbox" id="c-38541028" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38541475">prev</a><span>|</span><a href="#38541332">next</a><span>|</span><label class="collapse" for="c-38541028">[-]</label><label class="expand" for="c-38541028">[10 more]</label></div><br/><div class="children"><div class="content">Clojure’s biggest issue is definitely the ecosystem. As far as the bell curve goes for accessible and usable tooling it’s usually either on the far left end and terrible but easily accessible (but doesn’t follow the functional paradigms well) or it’s on the far right end -extremely esoteric, LOTR quote in the readme, everything is data to the n-th degree, only accessible to dragons who can write emacs plugins blindfolded and upside down. The language itself is amazing, and Java interop is much better than Aphyr makes it sound. If there was a rails or Django for Clojure for instance (or better yet, a Phoenix) it would be an easier sell and methinks more widely adopted. The juice needs to be worth the squeeze - particularly when you’re convincing a team to jump from Algol style imperative languages to lisp. But at this time you need to reinvent the wheel on virtually any project, aside from fundamentals like http routing (which is also a rough scene) But the fact that literally any maven package can be used is tremendous. Plus it compiles to a jar, so anywhere a jar will run - so will clojure.</div><br/><div id="38541730" class="c"><input type="checkbox" id="c-38541730" checked=""/><div class="controls bullet"><span class="by">raspasov</span><span>|</span><a href="#38541028">parent</a><span>|</span><a href="#38541377">next</a><span>|</span><label class="collapse" for="c-38541730">[-]</label><label class="expand" for="c-38541730">[1 more]</label></div><br/><div class="children"><div class="content">&quot;either on the far left end and terrible but easily accessible&quot;<p>Examples? I&#x27;ve been using Clojure since ~2013 and I can&#x27;t think of &quot;terrible + easily accessible&quot; tooling.<p>Most of the popular libraries are excellent. They are head and shoulders above in terms of stability&#x2F;backwards compatibility&#x2F;simplicity than most other ecosystems that I&#x27;m aware of.</div><br/></div></div><div id="38541377" class="c"><input type="checkbox" id="c-38541377" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#38541028">parent</a><span>|</span><a href="#38541730">prev</a><span>|</span><a href="#38541523">next</a><span>|</span><label class="collapse" for="c-38541377">[-]</label><label class="expand" for="c-38541377">[1 more]</label></div><br/><div class="children"><div class="content">This just seems like a random Clojure comment rather than anything to do with Jepsen or the article.</div><br/></div></div><div id="38541523" class="c"><input type="checkbox" id="c-38541523" checked=""/><div class="controls bullet"><span class="by">LouDNL</span><span>|</span><a href="#38541028">parent</a><span>|</span><a href="#38541377">prev</a><span>|</span><a href="#38541308">next</a><span>|</span><label class="collapse" for="c-38541523">[-]</label><label class="expand" for="c-38541523">[1 more]</label></div><br/><div class="children"><div class="content">You obviously dont code in Clojure for a loving. Clojure&#x27;s eco system and community is well maintained. Clojure comes in multiple flavors where Clojure and Clojurescript are 2 mainly used. Ofcourse there is also Babashka, Scittle etc., but all derive from clj or cljs.
As far as development tooling it all depends on the platform you code on and what ide suits your needs.
Emacs, Neovim, VScode, IntelliJ for example have different tooling.
Build systems differ and suits ones needs, for clj deps.edn is the current lost used followed by leiningen. For cljs there is shadowcljs and many more.
I agree that as new comer this can be quite overwhelming, but the community is great and always helpful.
I program for a living and have done so in multiple languages, Clojure is by far my most favorite.</div><br/></div></div><div id="38541308" class="c"><input type="checkbox" id="c-38541308" checked=""/><div class="controls bullet"><span class="by">silcoon</span><span>|</span><a href="#38541028">parent</a><span>|</span><a href="#38541523">prev</a><span>|</span><a href="#38541332">next</a><span>|</span><label class="collapse" for="c-38541308">[-]</label><label class="expand" for="c-38541308">[6 more]</label></div><br/><div class="children"><div class="content">You should definitely check out Calva, a wonderful plugin for VSCode which bring the REPL and much more (live documentation) for an easy way to use Clojure. I&#x27;m using it everyday at work.<p><a href="https:&#x2F;&#x2F;calva.io" rel="nofollow noreferrer">https:&#x2F;&#x2F;calva.io</a></div><br/><div id="38541337" class="c"><input type="checkbox" id="c-38541337" checked=""/><div class="controls bullet"><span class="by">civilitty</span><span>|</span><a href="#38541028">root</a><span>|</span><a href="#38541308">parent</a><span>|</span><a href="#38541332">next</a><span>|</span><label class="collapse" for="c-38541337">[-]</label><label class="expand" for="c-38541337">[5 more]</label></div><br/><div class="children"><div class="content">Situation: There are three competing Clojure development environments.<p>Three!? Ridiculous! We need to develop one universal Clojure environment that covers everyone&#x27;s use cases.<p>Situation: There are fourteen competing Clojure development environments.</div><br/><div id="38541387" class="c"><input type="checkbox" id="c-38541387" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#38541028">root</a><span>|</span><a href="#38541337">parent</a><span>|</span><a href="#38541332">next</a><span>|</span><label class="collapse" for="c-38541387">[-]</label><label class="expand" for="c-38541387">[4 more]</label></div><br/><div class="children"><div class="content">This comment has been repeated many times. I think there is even an XKCD.<p>Anyway, it’s not very helpful. If the 3 existing solutions are all deficient in some way then a new standard may be a good idea. And besides that, we may not realize that what we have is deficient until someone explores the space a bit.<p>Edit: Please forgive my tone, I’m weary from seeing this repeated so many times and you have unfairly taken the brunt of that!</div><br/><div id="38541600" class="c"><input type="checkbox" id="c-38541600" checked=""/><div class="controls bullet"><span class="by">pzs</span><span>|</span><a href="#38541028">root</a><span>|</span><a href="#38541387">parent</a><span>|</span><a href="#38541437">next</a><span>|</span><label class="collapse" for="c-38541600">[-]</label><label class="expand" for="c-38541600">[1 more]</label></div><br/><div class="children"><div class="content">Indeed there is an XKCD on this: <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;927&#x2F;</a></div><br/></div></div><div id="38541437" class="c"><input type="checkbox" id="c-38541437" checked=""/><div class="controls bullet"><span class="by">civilitty</span><span>|</span><a href="#38541028">root</a><span>|</span><a href="#38541387">parent</a><span>|</span><a href="#38541600">prev</a><span>|</span><a href="#38541332">next</a><span>|</span><label class="collapse" for="c-38541437">[-]</label><label class="expand" for="c-38541437">[2 more]</label></div><br/><div class="children"><div class="content"><i>woosh</i><p>They&#x27;ve been exploring going on 16 years. It&#x27;s time to stop exploring and start exploiting.</div><br/><div id="38541605" class="c"><input type="checkbox" id="c-38541605" checked=""/><div class="controls bullet"><span class="by">pharmakom</span><span>|</span><a href="#38541028">root</a><span>|</span><a href="#38541437">parent</a><span>|</span><a href="#38541332">next</a><span>|</span><label class="collapse" for="c-38541605">[-]</label><label class="expand" for="c-38541605">[1 more]</label></div><br/><div class="children"><div class="content">It takes decades for programming tools to settle. Consider that most working developers today are using languages that wouldn’t have impressed a PL researcher in the 80s.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38541332" class="c"><input type="checkbox" id="c-38541332" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#38541028">prev</a><span>|</span><a href="#38541774">next</a><span>|</span><label class="collapse" for="c-38541332">[-]</label><label class="expand" for="c-38541332">[4 more]</label></div><br/><div class="children"><div class="content">Last time I spent a couple klines trying to write some clojure (+ clojurescript), the big thing was that most of the tooling had some really nasty error states. Python has some of this (ctrl+C out of most Python programs and get that stack trace with a bunch of inscrutible stuff), but given I was just starting out it was tough for me to move forwards.<p>I do think the language + ecosystem has so many innovative and interesting ideas built in. Definitely worth at least reading the history of Clojure paper and internalizing most of the lessons.<p>This is going to be anathema to everyone  but I think there&#x27;s a nice little ecosystem space for a scripting language that is as serious about performance and code ergonomics as Clojure... but without the parens[0] (and I could do without the nil-punning, but at least there&#x27;s a bit of a foundation there)<p>[0]: yes I know that (f x y) is nicer than f(x, y). My problem is more when it comes to things like let forms introducing indentation (I shouldn&#x27;t have to pay an indent + paren cost when trying to give a value a name!) and other things that just feel like line noise when coming from a language like Python, that just uses the indentation I&#x27;m going to put in my code anyways as information</div><br/><div id="38541347" class="c"><input type="checkbox" id="c-38541347" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38541332">parent</a><span>|</span><a href="#38541774">next</a><span>|</span><label class="collapse" for="c-38541347">[-]</label><label class="expand" for="c-38541347">[3 more]</label></div><br/><div class="children"><div class="content">&gt; let forms introducing indentation<p>this is a symptom of using let forms too copiously, rather than using a functional style, where there&#x27;s very few requirements to attach names to intermediate arguments being passed between functions.<p>Often, you would use threading macros (the -&gt; and -&gt;&gt; stuff) to implicitly pass arguments from one function to the next, or define transformations which are themselves just pure functions (so you would define it at the top level).<p>It&#x27;s understandable that some interop require a lot of let forms - mainly those that mutate an argument in a chain of procedures (looking at you, java jwt libraries...you know who you are).</div><br/><div id="38541590" class="c"><input type="checkbox" id="c-38541590" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#38541332">root</a><span>|</span><a href="#38541347">parent</a><span>|</span><a href="#38541774">next</a><span>|</span><label class="collapse" for="c-38541590">[-]</label><label class="expand" for="c-38541590">[2 more]</label></div><br/><div class="children"><div class="content">Well-named intermediary variables often help tremendously with readability though. A language discouraging their use seems like the wrong trade-off decision to me.</div><br/><div id="38541766" class="c"><input type="checkbox" id="c-38541766" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38541332">root</a><span>|</span><a href="#38541590">parent</a><span>|</span><a href="#38541774">next</a><span>|</span><label class="collapse" for="c-38541766">[-]</label><label class="expand" for="c-38541766">[1 more]</label></div><br/><div class="children"><div class="content">that&#x27;s because you have assumed that the code would _need_ such an intermediate variable, which is often the case in imperative code.<p>I argue that if your code _does not need_ this intermediate variable, it makes the code even more readable as it removes more cognitive friction - having fewer things makes it easier to understand.</div><br/></div></div></div></div></div></div></div></div><div id="38541774" class="c"><input type="checkbox" id="c-38541774" checked=""/><div class="controls bullet"><span class="by">dsign</span><span>|</span><a href="#38541332">prev</a><span>|</span><a href="#38541555">next</a><span>|</span><label class="collapse" for="c-38541774">[-]</label><label class="expand" for="c-38541774">[2 more]</label></div><br/><div class="children"><div class="content">This is what happens:<p>- Dev Foor Barry needs to solve problem X. Mr. Barry thinks about the problem for a long time, picks a technology stack YZ that is suitable to the solution and to his experience, and goes to work.<p>- Some time later, Mr. Barry meets dev Alice Mallory. She didn&#x27;t know X was a problem, and she didn&#x27;t know Mr. Barry either. But less than a minute into their conversation and being a mutual acquaintance, Ms. Mallory is convinced that technology stack YZ is the WRONG tool for the job. She can&#x27;t stop herself from asking &quot;Foor, why YZ? Wouldn&#x27;t it has been better to use KY?&quot;<p>I&#x27;ve been involved in this ploy (sometimes as Mr. Barry, and sometimes as Ms. Mallory) any number of times, for any number of technologies, from mainstream ones to more obscure ones. For the last few years, I&#x27;ve been trying to act more as Steve: &quot;Use whatever you want.&quot; I have to admit though, that kind of acceptance is a difficult, uphill spiritual path. And I have met plenty of architects in their sixties and seventies who saw the hill and took a wide berth, and keep acting like Mallory.</div><br/></div></div><div id="38541555" class="c"><input type="checkbox" id="c-38541555" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#38541774">prev</a><span>|</span><a href="#38541324">next</a><span>|</span><label class="collapse" for="c-38541555">[-]</label><label class="expand" for="c-38541555">[3 more]</label></div><br/><div class="children"><div class="content">In short:<p>- being on JVM means Jepsen can use JDBC drivers to interact with databases<p>- Clojure was designed to facilitate concurrent programming (via software transactional memory and persistent data structures)<p>- Clojure&#x27;s interactivity allows quick prototyping<p>- Clojure&#x27;s community has a strong emphasis on backwards compatibility<p>- macros allow a great deal of code reuse<p>- while there are some big drawbacks (niche language, no strong static typing, ...), it isnt an issue in practice since Jepsen is only worked on by 1-3 people at a time<p>I agree with most of these points, but it seems overly simplistic of an explanation. I really wanted to see what other languages were used for prototyping and why they were deemed insufficient. For instance, Haskell is mentioned but the most treatment it gets is that it was too &quot;dogmatic&quot; for writing Jepsen. There was no comparison on how easy it is to interact with databases from Haskell as opposed to Clojure. Moreover, Jepsen was prototyped &quot;in a few different languages&quot;, but they are not compared to Clojure, let alone mentioned.</div><br/><div id="38541671" class="c"><input type="checkbox" id="c-38541671" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#38541555">parent</a><span>|</span><a href="#38541784">next</a><span>|</span><label class="collapse" for="c-38541671">[-]</label><label class="expand" for="c-38541671">[1 more]</label></div><br/><div class="children"><div class="content">Based on the title and intro, I think part of the point of this post was to have something to link to for a “good enough” answer to this common question. I’m guessing he wrote this relatively quickly. It was a choice made over ten years ago. Trying to recreate the decision would likely be rather time consuming, prone to mistakes, and really only invite <i>more</i> discussion.</div><br/></div></div></div></div><div id="38541324" class="c"><input type="checkbox" id="c-38541324" checked=""/><div class="controls bullet"><span class="by">silcoon</span><span>|</span><a href="#38541555">prev</a><span>|</span><a href="#38540883">next</a><span>|</span><label class="collapse" for="c-38541324">[-]</label><label class="expand" for="c-38541324">[2 more]</label></div><br/><div class="children"><div class="content">For all of you new to Clojure, check out this interactive tutorial: <a href="https:&#x2F;&#x2F;tryclojure.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;tryclojure.org</a></div><br/><div id="38541354" class="c"><input type="checkbox" id="c-38541354" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#38541324">parent</a><span>|</span><a href="#38540883">next</a><span>|</span><label class="collapse" for="c-38541354">[-]</label><label class="expand" for="c-38541354">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;4clojure.oxal.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;4clojure.oxal.org&#x2F;</a><p>that is an even better interactive set of lessons starting from easy to intermediate to hard.</div><br/></div></div></div></div><div id="38540883" class="c"><input type="checkbox" id="c-38540883" checked=""/><div class="controls bullet"><span class="by">leoszliard</span><span>|</span><a href="#38541324">prev</a><span>|</span><a href="#38540855">next</a><span>|</span><label class="collapse" for="c-38540883">[-]</label><label class="expand" for="c-38540883">[2 more]</label></div><br/><div class="children"><div class="content">Also, Clojure&#x27;s fun</div><br/><div id="38541189" class="c"><input type="checkbox" id="c-38541189" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#38540883">parent</a><span>|</span><a href="#38540855">next</a><span>|</span><label class="collapse" for="c-38541189">[-]</label><label class="expand" for="c-38541189">[1 more]</label></div><br/><div class="children"><div class="content">This is underrated. I know it sounds unprofessional, but funness is also the reason Basecamp and Ruby on Rails was built in Ruby. Rails dominated web dev in the 2010s and tons of super successful startups were built on it. So while many folks like to scoff at engineers &quot;playing with toys&quot;, a lot of good things we have now used to be toys (edit: Linux is another good example of this)</div><br/></div></div></div></div><div id="38540855" class="c"><input type="checkbox" id="c-38540855" checked=""/><div class="controls bullet"><span class="by">contrarian1234</span><span>|</span><a href="#38540883">prev</a><span>|</span><a href="#38541777">next</a><span>|</span><label class="collapse" for="c-38540855">[-]</label><label class="expand" for="c-38540855">[1 more]</label></div><br/><div class="children"><div class="content">out of curiosity, does it use core.async or manifold for concurrency? (and what are the tradeoffs)</div><br/></div></div><div id="38541777" class="c"><input type="checkbox" id="c-38541777" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38540855">prev</a><span>|</span><a href="#38540891">next</a><span>|</span><label class="collapse" for="c-38541777">[-]</label><label class="expand" for="c-38541777">[2 more]</label></div><br/><div class="children"><div class="content">I guess Jepsen is useful and stuff, but the _really_ important contributions are the &quot;interviews&quot;:<p><a href="https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;340-reversing-the-technical-interview" rel="nofollow noreferrer">https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;340-reversing-the-technical-intervie...</a><p><a href="https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;341-hexing-the-technical-interview" rel="nofollow noreferrer">https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;341-hexing-the-technical-interview</a><p><a href="https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;342-typing-the-technical-interview" rel="nofollow noreferrer">https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;342-typing-the-technical-interview</a><p><a href="https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;353-rewriting-the-technical-interview" rel="nofollow noreferrer">https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;353-rewriting-the-technical-intervie...</a><p><a href="https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;354-unifying-the-technical-interview" rel="nofollow noreferrer">https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;354-unifying-the-technical-interview</a></div><br/></div></div><div id="38540891" class="c"><input type="checkbox" id="c-38540891" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#38541777">prev</a><span>|</span><a href="#38541396">next</a><span>|</span><label class="collapse" for="c-38540891">[-]</label><label class="expand" for="c-38540891">[17 more]</label></div><br/><div class="children"><div class="content">Sort of a meta comment -- the article starts saying that people keep asking &quot;why Clojure&quot;.<p>Why such an emphasis on what language stuff is written in? Why does it even matter? Sounds like it was a good engineering choice given the constraints of the problem, get over yourself ffs.</div><br/><div id="38540929" class="c"><input type="checkbox" id="c-38540929" checked=""/><div class="controls bullet"><span class="by">simongray</span><span>|</span><a href="#38540891">parent</a><span>|</span><a href="#38540955">next</a><span>|</span><label class="collapse" for="c-38540929">[-]</label><label class="expand" for="c-38540929">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s probably because the author keeps getting comments from other developers about his choice of language and he&#x27;s tired of explaining why.<p>There was a HN submission yesterday about another project of his (also in Clojure) and many of the comments were &quot;Why is this made in Clojure?&quot;.<p>Unfortunately, a large segment of developers think there is no value in venturing beyond C-style languages.<p>Another dimension in recent years is the static type checking cult, whose adherents must warn everyone else in the cult whenever they spot any kind of dynamically typed programming language, e.g. causing a separate thread about the lack of static type checking in any comment section about a Clojure project.</div><br/><div id="38541276" class="c"><input type="checkbox" id="c-38541276" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#38540891">root</a><span>|</span><a href="#38540929">parent</a><span>|</span><a href="#38541018">next</a><span>|</span><label class="collapse" for="c-38541276">[-]</label><label class="expand" for="c-38541276">[2 more]</label></div><br/><div class="children"><div class="content">I came from C#&#x2F;Java to JavaScript and it was extremely painful. I didn&#x27;t care that much about typing until I experienced a dozen types of error that should have been impossible. (Shouldn&#x27;t even compile, let alone silently poison your data at runtime...)<p>For years I thought it was a dynamic&#x2F;static issue. Then I used Python (without type hints), and almost all the JS errors were impossible in Python too! Turns out it&#x27;s about weak&#x2F;strong typing instead.<p>Put simply: when given something that is an obvious error, throw an error. This sounds obvious, but given an obvious error, in many cases JavaScript remains silent and passes garbage data to the rest of the program.<p>I think if JS added a &quot;use strong&quot;, it would remove 80-90% of the need for TypeScript.</div><br/><div id="38541397" class="c"><input type="checkbox" id="c-38541397" checked=""/><div class="controls bullet"><span class="by">yett</span><span>|</span><a href="#38540891">root</a><span>|</span><a href="#38541276">parent</a><span>|</span><a href="#38541018">next</a><span>|</span><label class="collapse" for="c-38541397">[-]</label><label class="expand" for="c-38541397">[1 more]</label></div><br/><div class="children"><div class="content">Javascript does have &#x27;use strict&#x27;
<a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Strict_mode" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/></div></div></div></div><div id="38541018" class="c"><input type="checkbox" id="c-38541018" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#38540891">root</a><span>|</span><a href="#38540929">parent</a><span>|</span><a href="#38541276">prev</a><span>|</span><a href="#38541103">next</a><span>|</span><label class="collapse" for="c-38541018">[-]</label><label class="expand" for="c-38541018">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Another dimension in recent years is the static type checking cult, whose adherents must warn everyone else in the cult whenever they spot any kind of dynamically typed programming language<p>Shun the nonbeliever!</div><br/></div></div><div id="38541103" class="c"><input type="checkbox" id="c-38541103" checked=""/><div class="controls bullet"><span class="by">Scarbutt</span><span>|</span><a href="#38540891">root</a><span>|</span><a href="#38540929">parent</a><span>|</span><a href="#38541018">prev</a><span>|</span><a href="#38540955">next</a><span>|</span><label class="collapse" for="c-38541103">[-]</label><label class="expand" for="c-38541103">[1 more]</label></div><br/><div class="children"><div class="content">The blog post does mentioned the lack of a static type system as a drawback. Although it sounds that what he really wants (cause of his prototyping remarks) is gradual typing similar to typescript.</div><br/></div></div></div></div><div id="38540955" class="c"><input type="checkbox" id="c-38540955" checked=""/><div class="controls bullet"><span class="by">p-e-w</span><span>|</span><a href="#38540891">parent</a><span>|</span><a href="#38540929">prev</a><span>|</span><a href="#38540945">next</a><span>|</span><label class="collapse" for="c-38540955">[-]</label><label class="expand" for="c-38540955">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Why such an emphasis on what language stuff is written in?<p>Because it&#x27;s <i>by far</i> the most important decision made during the creation of any software project, and to a large extent, it sets the boundaries of what the software will ever be able to do.<p>Experience also teaches that language choice strongly correlates with overall project quality. When I see a CLI project written in JavaScript (Node), I know that it&#x27;s probably not worth my time to take a closer look. With Rust, Clojure, Haskell, F# etc, the opposite is the case. This is a cultural effect, rather than a technological one, but that doesn&#x27;t make it any less real.</div><br/><div id="38541756" class="c"><input type="checkbox" id="c-38541756" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38540891">root</a><span>|</span><a href="#38540955">parent</a><span>|</span><a href="#38540945">next</a><span>|</span><label class="collapse" for="c-38541756">[-]</label><label class="expand" for="c-38541756">[1 more]</label></div><br/><div class="children"><div class="content">While the cultural effect might indeed be quite important, I really don&#x27;t agree that it is <i>by far</i> the most important decision.<p>E.g. from a performance perspective, the design of you program is orders of magnitude more important than the language itself. Also, not every platform is as limiting - you could for example start a clojure project, and extend it in java without any fuss.</div><br/></div></div></div></div><div id="38540945" class="c"><input type="checkbox" id="c-38540945" checked=""/><div class="controls bullet"><span class="by">NateEag</span><span>|</span><a href="#38540891">parent</a><span>|</span><a href="#38540955">prev</a><span>|</span><a href="#38541109">next</a><span>|</span><label class="collapse" for="c-38540945">[-]</label><label class="expand" for="c-38540945">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Why such an emphasis on what language stuff is written in? Why does it even matter?<p>polyglot programmers are the exception, not the rule, and even for people who have mastered &gt;5 languages, there&#x27;s still no one who&#x27;s mastered the top 50, let alone all the languages out there.<p>Language impacts both codebase contributor pool size and codebase reviewer pool size. In large, conservative orgs, the latter can matter a lot - good luck getting an insurance megaco&#x27;s security review board to approve the cool new tool you found that&#x27;s written in Eiffel - none of them know it, so none of them can review it intelligently.<p>Language diversity is a good thing, IMO, and there are many different factors impacting what you choose, and that makes your choice more important, not less.</div><br/><div id="38541768" class="c"><input type="checkbox" id="c-38541768" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38540891">root</a><span>|</span><a href="#38540945">parent</a><span>|</span><a href="#38541554">next</a><span>|</span><label class="collapse" for="c-38541768">[-]</label><label class="expand" for="c-38541768">[1 more]</label></div><br/><div class="children"><div class="content">Taking up a new language that shares some roots with one you are a master at is&#x2F;should be trivial to any good programmer, and can be done in weeks&#x2F;a few months tops.</div><br/></div></div></div></div><div id="38541109" class="c"><input type="checkbox" id="c-38541109" checked=""/><div class="controls bullet"><span class="by">tasuki</span><span>|</span><a href="#38540891">parent</a><span>|</span><a href="#38540945">prev</a><span>|</span><a href="#38541202">next</a><span>|</span><label class="collapse" for="c-38541109">[-]</label><label class="expand" for="c-38541109">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand your comment.<p>Of course people ask &quot;why clojure&quot;, we&#x27;re curious!<p>&gt; Why such an emphasis on what language stuff is written in? Why does it even matter?<p>Because different languages (and especially different paradigms) are different. The choice of language affects the project&#x27;s future prospects, productivity, expressivity, maintainability, developer satisfaction, ease of finding developers, and a million other things.</div><br/></div></div><div id="38541202" class="c"><input type="checkbox" id="c-38541202" checked=""/><div class="controls bullet"><span class="by">contrarian1234</span><span>|</span><a href="#38540891">parent</a><span>|</span><a href="#38541109">prev</a><span>|</span><a href="#38540939">next</a><span>|</span><label class="collapse" for="c-38541202">[-]</label><label class="expand" for="c-38541202">[1 more]</label></div><br/><div class="children"><div class="content">Bc the whole &quot;data-drive development&quot; is fundamentally a pretty different programming paradigm. You can do similar things piece wise or with a library in other languages but the Clojure language and all your dependencies are structured around it in a cohesive way<p>You wouldn&#x27;t be able to translate Clojure to another language line by line unless you brought in some framework or library</div><br/></div></div><div id="38540939" class="c"><input type="checkbox" id="c-38540939" checked=""/><div class="controls bullet"><span class="by">Uehreka</span><span>|</span><a href="#38540891">parent</a><span>|</span><a href="#38541202">prev</a><span>|</span><a href="#38541056">next</a><span>|</span><label class="collapse" for="c-38540939">[-]</label><label class="expand" for="c-38540939">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why such an emphasis on what language stuff is written in?<p>Because people are interested in the way that languages affect your ability to think and solve problems? Because different languages have different tradeoffs and the tradeoffs involved in less used languages are often underexplored? Jeez dog, ease up.</div><br/></div></div><div id="38541056" class="c"><input type="checkbox" id="c-38541056" checked=""/><div class="controls bullet"><span class="by">cpitman</span><span>|</span><a href="#38540891">parent</a><span>|</span><a href="#38540939">prev</a><span>|</span><a href="#38540979">next</a><span>|</span><label class="collapse" for="c-38541056">[-]</label><label class="expand" for="c-38541056">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Law_of_triviality" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Law_of_triviality</a></div><br/></div></div><div id="38540979" class="c"><input type="checkbox" id="c-38540979" checked=""/><div class="controls bullet"><span class="by">lemper</span><span>|</span><a href="#38540891">parent</a><span>|</span><a href="#38541056">prev</a><span>|</span><a href="#38541396">next</a><span>|</span><label class="collapse" for="c-38540979">[-]</label><label class="expand" for="c-38540979">[2 more]</label></div><br/><div class="children"><div class="content">because it&#x27;s not rust, bro! if it&#x27;s rust, people will accept it and move along.<p>aphyr should&#x27;ve written it in ada, though.</div><br/><div id="38541207" class="c"><input type="checkbox" id="c-38541207" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#38540891">root</a><span>|</span><a href="#38540979">parent</a><span>|</span><a href="#38541396">next</a><span>|</span><label class="collapse" for="c-38541207">[-]</label><label class="expand" for="c-38541207">[1 more]</label></div><br/><div class="children"><div class="content">Erlang</div><br/></div></div></div></div></div></div><div id="38540843" class="c"><input type="checkbox" id="c-38540843" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#38541396">prev</a><span>|</span><label class="collapse" for="c-38540843">[-]</label><label class="expand" for="c-38540843">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Jepsen’s (gosh) about a decade old now<p>I thought Jepsen is more like 12 years old now, going by when I first heard about it circa 2011.</div><br/><div id="38540969" class="c"><input type="checkbox" id="c-38540969" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#38540843">parent</a><span>|</span><a href="#38540953">next</a><span>|</span><label class="collapse" for="c-38540969">[-]</label><label class="expand" for="c-38540969">[1 more]</label></div><br/><div class="children"><div class="content">From a certain perspective, Jepsen is 38 years old.</div><br/></div></div><div id="38540953" class="c"><input type="checkbox" id="c-38540953" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#38540843">parent</a><span>|</span><a href="#38540969">prev</a><span>|</span><a href="#38540975">next</a><span>|</span><label class="collapse" for="c-38540953">[-]</label><label class="expand" for="c-38540953">[1 more]</label></div><br/><div class="children"><div class="content">The song that inspired the name was released in 2011. Aphyr&#x27;s &quot;Call Me Maybe&quot; blog series&#x2F;talk started in 2013, and the commercial audits we&#x27;ve come to love came later.</div><br/></div></div><div id="38540975" class="c"><input type="checkbox" id="c-38540975" checked=""/><div class="controls bullet"><span class="by">michaelsbradley</span><span>|</span><a href="#38540843">parent</a><span>|</span><a href="#38540953">prev</a><span>|</span><label class="collapse" for="c-38540975">[-]</label><label class="expand" for="c-38540975">[1 more]</label></div><br/><div class="children"><div class="content">less than 15, “about” can go +&#x2F;-</div><br/></div></div></div></div></div></div></div></div></div></body></html>