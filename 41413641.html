<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725181262576" as="style"/><link rel="stylesheet" href="styles.css?v=1725181262576"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.davidhang.com/blog/2024-09-01-taming-the-django-orm/">Taming the beast that is the Django ORM – An introduction</a> <span class="domain">(<a href="https://www.davidhang.com">www.davidhang.com</a>)</span></div><div class="subtext"><span>AbundantSalmon</span> | <span>53 comments</span></div><br/><div><div id="41415139" class="c"><input type="checkbox" id="c-41415139" checked=""/><div class="controls bullet"><span class="by">santiagobasulto</span><span>|</span><a href="#41414945">next</a><span>|</span><label class="collapse" for="c-41415139">[-]</label><label class="expand" for="c-41415139">[5 more]</label></div><br/><div class="children"><div class="content">I think Django&#x27;s ORM is just AMAZING. And as with every other tool, it has to be used wisely.<p>First, it let&#x27;s you get started quickly and prototype. You can write unit tests, make sure everything is working as expected, then count queries and make sure you&#x27;re being efficient with your SQL engine.<p>Second, and even more importantly, it&#x27;s crucial in the definition of the app and the Schema. Thinking in high level &quot;classes and objects&quot; helps with the abstraction and the design of the apps. Even if you then default to raw SQU queries, thinking and building your model with class abstractions is huge.<p>Finally, there are some &quot;tiny details&quot; (but in my eyes, very important) that everybody oversees:<p>* Migrations: the way Django has designed migrations is just marvelous. We&#x27;ve migrated tons of data and changed the structure of our DB multiple times without any issues.<p>* Troubleshooting and &quot;reporting&quot;: the ability to fire a quick shell, load a few models in Django&#x27;s REPL, and do a few `.filters()` is for me key. On top of that, we add a Jupyter server connected to our read replica and we can do all sorts of reporting VERY QUICKLY. Not everybody needs a Data Lake :)<p>PS: We&#x27;ve ran Django sites accessed by millions of people per month. And we never had an issue with the ORM. Yes, sometimes I have to tell more junior devs that the gymnastics they&#x27;re doing with `select_related` and `prefetch_related` can be more easily and effectively resolved with a query. But that&#x27;s it. I&#x27;d say less than 1% of all the queries in our codebase have to be migrated to raw SQL.</div><br/><div id="41415146" class="c"><input type="checkbox" id="c-41415146" checked=""/><div class="controls bullet"><span class="by">santiagobasulto</span><span>|</span><a href="#41415139">parent</a><span>|</span><a href="#41415295">next</a><span>|</span><label class="collapse" for="c-41415146">[-]</label><label class="expand" for="c-41415146">[2 more]</label></div><br/><div class="children"><div class="content">One common pitfall with Django ORM&#x27;s is that it makes it very easy the use of inheritance in models. But as we know, the &quot;impedance mismatch&quot; between OOP and the Relational model is a problem.<p>It has happened that a dev in our team was populating an endpoint that used inheritance and when looking at the number of queries we were over 100.<p>But the solution in those cases is just OUTER JOINs and CASE. Especially since we use Postgres in the backend and it works so well.<p>So yes, there are some pitfalls, but they&#x27;re greatly overshadowed by the advantages of the ORM.</div><br/><div id="41415353" class="c"><input type="checkbox" id="c-41415353" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#41415139">root</a><span>|</span><a href="#41415146">parent</a><span>|</span><a href="#41415295">next</a><span>|</span><label class="collapse" for="c-41415353">[-]</label><label class="expand" for="c-41415353">[1 more]</label></div><br/><div class="children"><div class="content">You have to use the ORM with a bit of awareness of the query it it generates. Django provides plenty of tools and great documentation for reducing, combining and managing queries. It&#x27;s not like it&#x27;s a deep dark corner.<p>It&#x27;s like understanding memory allocation if you&#x27;re writing c. It&#x27;s just part of the job</div><br/></div></div></div></div><div id="41415295" class="c"><input type="checkbox" id="c-41415295" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#41415139">parent</a><span>|</span><a href="#41415146">prev</a><span>|</span><a href="#41414945">next</a><span>|</span><label class="collapse" for="c-41415295">[-]</label><label class="expand" for="c-41415295">[2 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve had serious trouble with migration merges when two people work on different parts of the code, yet in the same module, and they both generate a &quot;migration nr. 6&quot; on their feature branches.</div><br/><div id="41415344" class="c"><input type="checkbox" id="c-41415344" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#41415139">root</a><span>|</span><a href="#41415295">parent</a><span>|</span><a href="#41414945">next</a><span>|</span><label class="collapse" for="c-41415344">[-]</label><label class="expand" for="c-41415344">[1 more]</label></div><br/><div class="children"><div class="content">Not at my desk but from memory, this is a something with a clearly documented &quot;solution&quot;.<p>I put that word in quotes because I don&#x27;t want to imply it&#x27;s a problem - it&#x27;s just something you need to know how to handle.</div><br/></div></div></div></div></div></div><div id="41414945" class="c"><input type="checkbox" id="c-41414945" checked=""/><div class="controls bullet"><span class="by">rowanseymour</span><span>|</span><a href="#41415139">prev</a><span>|</span><a href="#41414974">next</a><span>|</span><label class="collapse" for="c-41414945">[-]</label><label class="expand" for="c-41414945">[7 more]</label></div><br/><div class="children"><div class="content">I adore the Django ORM but as listed under cons... it makes it very hard to avoid accidental N+1 queries, and they don&#x27;t seem interested in addressing this (<a href="https:&#x2F;&#x2F;code.djangoproject.com&#x2F;ticket&#x2F;30874" rel="nofollow">https:&#x2F;&#x2F;code.djangoproject.com&#x2F;ticket&#x2F;30874</a>). Yes lazy loading is neat when you&#x27;re messing around on the shell, but you should absolutely not be leaning on it in production at any kind of scale. So instead you have to use unit tests to hopefully catch any N+1 queries.</div><br/><div id="41415007" class="c"><input type="checkbox" id="c-41415007" checked=""/><div class="controls bullet"><span class="by">LaundroMat</span><span>|</span><a href="#41414945">parent</a><span>|</span><a href="#41415192">next</a><span>|</span><label class="collapse" for="c-41415007">[-]</label><label class="expand" for="c-41415007">[1 more]</label></div><br/><div class="children"><div class="content">Just to say there are libraries to help you find n+1 queries too (when your code is running).<p>I use <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;django-nplusone&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;django-nplusone&#x2F;</a> for instance. Sentry also warns of these by the way.</div><br/></div></div><div id="41415192" class="c"><input type="checkbox" id="c-41415192" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41414945">parent</a><span>|</span><a href="#41415007">prev</a><span>|</span><a href="#41414958">next</a><span>|</span><label class="collapse" for="c-41415192">[-]</label><label class="expand" for="c-41415192">[1 more]</label></div><br/><div class="children"><div class="content">&gt; they don&#x27;t seem interested in addressing this (<a href="https:&#x2F;&#x2F;code.djangoproject.com&#x2F;ticket&#x2F;30874" rel="nofollow">https:&#x2F;&#x2F;code.djangoproject.com&#x2F;ticket&#x2F;30874</a>).<p>Actually it seems they are: <a href="https:&#x2F;&#x2F;code.djangoproject.com&#x2F;ticket&#x2F;22492#comment:11" rel="nofollow">https:&#x2F;&#x2F;code.djangoproject.com&#x2F;ticket&#x2F;22492#comment:11</a></div><br/></div></div><div id="41414958" class="c"><input type="checkbox" id="c-41414958" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#41414945">parent</a><span>|</span><a href="#41415192">prev</a><span>|</span><a href="#41414974">next</a><span>|</span><label class="collapse" for="c-41414958">[-]</label><label class="expand" for="c-41414958">[4 more]</label></div><br/><div class="children"><div class="content">What would be the best way?</div><br/><div id="41414998" class="c"><input type="checkbox" id="c-41414998" checked=""/><div class="controls bullet"><span class="by">rowanseymour</span><span>|</span><a href="#41414945">root</a><span>|</span><a href="#41414958">parent</a><span>|</span><a href="#41415227">next</a><span>|</span><label class="collapse" for="c-41414998">[-]</label><label class="expand" for="c-41414998">[2 more]</label></div><br/><div class="children"><div class="content">If it were up to me there&#x27;d be a way to completely disable it globally for all models. Let me explicitly enable it when I&#x27;m just shelling around or checking results in unit tests. It is not a feature for production environments.</div><br/><div id="41415034" class="c"><input type="checkbox" id="c-41415034" checked=""/><div class="controls bullet"><span class="by">geraneum</span><span>|</span><a href="#41414945">root</a><span>|</span><a href="#41414998">parent</a><span>|</span><a href="#41415227">next</a><span>|</span><label class="collapse" for="c-41415034">[-]</label><label class="expand" for="c-41415034">[1 more]</label></div><br/><div class="children"><div class="content">Would auto-joins be better in production envs?</div><br/></div></div></div></div><div id="41415227" class="c"><input type="checkbox" id="c-41415227" checked=""/><div class="controls bullet"><span class="by">andreareina</span><span>|</span><a href="#41414945">root</a><span>|</span><a href="#41414958">parent</a><span>|</span><a href="#41414998">prev</a><span>|</span><a href="#41414974">next</a><span>|</span><label class="collapse" for="c-41415227">[-]</label><label class="expand" for="c-41415227">[1 more]</label></div><br/><div class="children"><div class="content">Static lint wouldn&#x27;t be a bad way</div><br/></div></div></div></div></div></div><div id="41414974" class="c"><input type="checkbox" id="c-41414974" checked=""/><div class="controls bullet"><span class="by">abc-1</span><span>|</span><a href="#41414945">prev</a><span>|</span><a href="#41414356">next</a><span>|</span><label class="collapse" for="c-41414974">[-]</label><label class="expand" for="c-41414974">[4 more]</label></div><br/><div class="children"><div class="content">ORMs do a great job at making easy things even easier and hard things a lot harder. If that sounds like a bad deal to you- it’s because it is!</div><br/><div id="41415067" class="c"><input type="checkbox" id="c-41415067" checked=""/><div class="controls bullet"><span class="by">rowanseymour</span><span>|</span><a href="#41414974">parent</a><span>|</span><a href="#41414356">next</a><span>|</span><label class="collapse" for="c-41415067">[-]</label><label class="expand" for="c-41415067">[3 more]</label></div><br/><div class="children"><div class="content">The Django ORM makes migrating database state (a hard problem) super easy. It also makes GROUP BY queries (a relatively easy problem) oddly difficult. Use an ORM where it helps, use SQL where it doesn&#x27;t.</div><br/><div id="41415256" class="c"><input type="checkbox" id="c-41415256" checked=""/><div class="controls bullet"><span class="by">AmericanChopper</span><span>|</span><a href="#41414974">root</a><span>|</span><a href="#41415067">parent</a><span>|</span><a href="#41414356">next</a><span>|</span><label class="collapse" for="c-41415256">[-]</label><label class="expand" for="c-41415256">[2 more]</label></div><br/><div class="children"><div class="content">I personally don’t think DB migrations are that difficult, and I’d say they can be done a lot safer without an ORM. I’ve also never found an ORM that was easier to learn and overall easier to use than SQL. I’ve never understood how ORMs became so popular, I don’t get how somebody can look at how opaque and complicated they are and conclude that learning an ORM is easier than just learning SQL.</div><br/><div id="41415346" class="c"><input type="checkbox" id="c-41415346" checked=""/><div class="controls bullet"><span class="by">thestepafter</span><span>|</span><a href="#41414974">root</a><span>|</span><a href="#41415256">parent</a><span>|</span><a href="#41414356">next</a><span>|</span><label class="collapse" for="c-41415346">[-]</label><label class="expand" for="c-41415346">[1 more]</label></div><br/><div class="children"><div class="content">100%. ORMs are good for basic queries but the messes I have seen written joining 20 plus tables with conditions and left joins, etc, oof. Just use SQL, it’s much cleaner and easier to maintain.</div><br/></div></div></div></div></div></div></div></div><div id="41414356" class="c"><input type="checkbox" id="c-41414356" checked=""/><div class="controls bullet"><span class="by">WesleyJohnson</span><span>|</span><a href="#41414974">prev</a><span>|</span><a href="#41415089">next</a><span>|</span><label class="collapse" for="c-41414356">[-]</label><label class="expand" for="c-41414356">[3 more]</label></div><br/><div class="children"><div class="content">Pretty decent introduction. Will there be additional parts that cover how to create GROUP BY queries in the ORM? I find even seasoned Django developers struggle with these.<p>Also, I believe your code for creating an empty &quot;data&quot; migration is missing the &quot;makemigration&quot; command itself.</div><br/><div id="41414737" class="c"><input type="checkbox" id="c-41414737" checked=""/><div class="controls bullet"><span class="by">vandahm</span><span>|</span><a href="#41414356">parent</a><span>|</span><a href="#41415089">next</a><span>|</span><label class="collapse" for="c-41414737">[-]</label><label class="expand" for="c-41414737">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Will there be additional parts that cover how to create GROUP BY queries in the ORM? I find even seasoned Django developers struggle with these.<p>The last time I needed to do that, I ended up crying &quot;uncle&quot; and writing manual SQL. I wasn&#x27;t happy about doing it, but I was happy that the framework left me an escape hatch so that I could.</div><br/><div id="41414830" class="c"><input type="checkbox" id="c-41414830" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#41414356">root</a><span>|</span><a href="#41414737">parent</a><span>|</span><a href="#41415089">next</a><span>|</span><label class="collapse" for="c-41414830">[-]</label><label class="expand" for="c-41414830">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually easy once you get it, it&#x27;s just that they choose bizarre terminology that doesn&#x27;t translate directly from sql. .values() and .annotate() ?!</div><br/></div></div></div></div></div></div><div id="41415089" class="c"><input type="checkbox" id="c-41415089" checked=""/><div class="controls bullet"><span class="by">ebcode</span><span>|</span><a href="#41414356">prev</a><span>|</span><a href="#41415315">next</a><span>|</span><label class="collapse" for="c-41415089">[-]</label><label class="expand" for="c-41415089">[1 more]</label></div><br/><div class="children"><div class="content">Anytime I hear ORM, I always think of this: <a href="https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;object-relational-mapping-is-the-vietnam-of-computer-science&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;object-relational-mapping-is-t...</a></div><br/></div></div><div id="41415315" class="c"><input type="checkbox" id="c-41415315" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#41415089">prev</a><span>|</span><a href="#41414856">next</a><span>|</span><label class="collapse" for="c-41415315">[-]</label><label class="expand" for="c-41415315">[1 more]</label></div><br/><div class="children"><div class="content">orms are exercises in OCD.<p>Databases are the bottleneck your classic website. We choose to query these databases in a extremely high level language called SQL. This language is so high level that you need to come up with tricks and query analyzers in order to hack the high level query into something performant.<p>A better abstraction would be one that&#x27;s a bit more similar to a standard programming language with an std that has query related operations&#x2F;optimizers that can be composed so programmers can compose and choose query operations and avoid optimization issues that are hidden by high level languages like SQL.<p>We are unfortunately, sort of stuck with SQL (there are other options, but SQL remains popular because years of development has made it pretty good in spite of the fact that it&#x27;s a poor initial design choice). This is already a historical mistake that we have to live with. Same with javascript (which has been paved over with typescript), same with CSS, etc. The web is full of this stuff. It&#x27;s fine. My main problem is the ORM.<p>The ORM is just another layer of indirection. You already have a high level language you&#x27;re dealing with, now you want to put Another High level language on top of it? ORMs are basically high level languages that compile into SQL.<p>What is the point? The ORM isn&#x27;t actually making things easier because SQL is pretty much as high level of a language you can get outside of having an LLM translating direct english.<p>The point is OCD. Programmers find it jarring to work with SQL strings inside their beautiful language so they want to chop up a SQL string into web app language primitives that they can compose together. Query builders operate on the same concept but are better because they aren&#x27;t as high level.<p>This is basically the main reason why Many programmers experience the strange counter intuitive phenomena about why ORMs actually makes things harder. You have to Hack SQL to optimize it. Now you have to hack another ORM on top of it in order to get it to compile it into the hacked query.</div><br/></div></div><div id="41414856" class="c"><input type="checkbox" id="c-41414856" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#41415315">prev</a><span>|</span><a href="#41413642">next</a><span>|</span><label class="collapse" for="c-41414856">[-]</label><label class="expand" for="c-41414856">[4 more]</label></div><br/><div class="children"><div class="content">For me the killer feature of django is the auto-generated admin UI. I initially started my last project using Spring boot, but I was astonished to find there was no equivalent.<p>I don&#x27;t know how people build websites in any speed without such a tool. I guess they just waste time duplicating effort on an admin UI or pay for one of those tools that can generate one from an API (meaning they have to also build an API).<p>It&#x27;s such a massive time-saver I switched to django after a week or so.</div><br/><div id="41415169" class="c"><input type="checkbox" id="c-41415169" checked=""/><div class="controls bullet"><span class="by">switch007</span><span>|</span><a href="#41414856">parent</a><span>|</span><a href="#41415015">next</a><span>|</span><label class="collapse" for="c-41415169">[-]</label><label class="expand" for="c-41415169">[1 more]</label></div><br/><div class="children"><div class="content">It can be quite difficult to do anything mildly advanced with the admin UI, IIRC<p>And it encourages CRUD thinking instead of thinking about business processes and user experience<p>It&#x27;s great for tiny&#x2F;personal projects but in an organisation it can be a trap IMO</div><br/></div></div><div id="41415015" class="c"><input type="checkbox" id="c-41415015" checked=""/><div class="controls bullet"><span class="by">savolai</span><span>|</span><a href="#41414856">parent</a><span>|</span><a href="#41415169">prev</a><span>|</span><a href="#41415017">next</a><span>|</span><label class="collapse" for="c-41415015">[-]</label><label class="expand" for="c-41415015">[1 more]</label></div><br/><div class="children"><div class="content">I used to think this too. LLms make generating such UIs in other frameworks too much easier. Also the admin UI gets clumsy very fast and you’ll need to roll your own for a good UX.</div><br/></div></div><div id="41415017" class="c"><input type="checkbox" id="c-41415017" checked=""/><div class="controls bullet"><span class="by">Ingaz</span><span>|</span><a href="#41414856">parent</a><span>|</span><a href="#41415015">prev</a><span>|</span><a href="#41413642">next</a><span>|</span><label class="collapse" for="c-41415017">[-]</label><label class="expand" for="c-41415017">[1 more]</label></div><br/><div class="children"><div class="content">I would say even more:<p>- the main reason to use django today is the admin UI<p>- and the only reason to use django ORM is the admin UI</div><br/></div></div></div></div><div id="41414088" class="c"><input type="checkbox" id="c-41414088" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#41413642">prev</a><span>|</span><a href="#41414815">next</a><span>|</span><label class="collapse" for="c-41414088">[-]</label><label class="expand" for="c-41414088">[24 more]</label></div><br/><div class="children"><div class="content">Django’s ORM is the first one that I ever spent a lot of time with. Throughout my career I’ve interacted with other ORMs from time to time. It wasn’t until I’d done that, that I realised, even though it’s not perfect, how fantastic the Django ORM is. I thought they’d all be that good, but no.<p>I’ve read a lot of criticisms of ORMs, as I’m sure everyone else has. Some of them are certainly valid criticisms that are immovable and just inherent in what an ORM tries to do. Some of them just seem to be caused by not very many ORMs being good, and the writer not having used one of the better ones.</div><br/><div id="41414485" class="c"><input type="checkbox" id="c-41414485" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41414088">parent</a><span>|</span><a href="#41414277">next</a><span>|</span><label class="collapse" for="c-41414485">[-]</label><label class="expand" for="c-41414485">[3 more]</label></div><br/><div class="children"><div class="content">The awkward part is realizing Django has been this good for well over a decade.  The core design hasn&#x27;t (ever?) changed.<p>I started using Django on I think version 1.2 or 1.3 in 2011, back when it didn&#x27;t have database migrations and you had to use a library like South for it.  Even then, as an ORM&#x2F;query language it was apparently better than what other languages have now.</div><br/><div id="41414555" class="c"><input type="checkbox" id="c-41414555" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414485">parent</a><span>|</span><a href="#41414277">next</a><span>|</span><label class="collapse" for="c-41414555">[-]</label><label class="expand" for="c-41414555">[2 more]</label></div><br/><div class="children"><div class="content">The design of the ORM changed substantially once, early in Django&#x27;s history, when the &quot;magic removal branch&quot; landed. There are some notes on the new syntax that introduced here: <a href="https:&#x2F;&#x2F;code.djangoproject.com&#x2F;wiki&#x2F;RemovingTheMagic#Codechangesyoullneedtomake" rel="nofollow">https:&#x2F;&#x2F;code.djangoproject.com&#x2F;wiki&#x2F;RemovingTheMagic#Codecha...</a><p>That branch merged on May 1st 2006: <a href="https:&#x2F;&#x2F;www.djangoproject.com&#x2F;weblog&#x2F;2006&#x2F;may&#x2F;01&#x2F;magicremoval&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.djangoproject.com&#x2F;weblog&#x2F;2006&#x2F;may&#x2F;01&#x2F;magicremova...</a><p>I&#x27;ve long found Django&#x27;s commitment to not breaking too much at once inspiring. The release notes and upgrade guides are really solid.</div><br/><div id="41414723" class="c"><input type="checkbox" id="c-41414723" checked=""/><div class="controls bullet"><span class="by">vandahm</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414555">parent</a><span>|</span><a href="#41414277">next</a><span>|</span><label class="collapse" for="c-41414723">[-]</label><label class="expand" for="c-41414723">[1 more]</label></div><br/><div class="children"><div class="content">I used Django a lot from about 2007 to 2010 and, then, went for several years without using it at all. When I came back to it, I was delighted to find that everything still worked like it was supposed to, just better. Congrats on getting it right on the first try. That&#x27;s...not something that happens very often in software.</div><br/></div></div></div></div></div></div><div id="41414277" class="c"><input type="checkbox" id="c-41414277" checked=""/><div class="controls bullet"><span class="by">choilive</span><span>|</span><a href="#41414088">parent</a><span>|</span><a href="#41414485">prev</a><span>|</span><a href="#41414254">next</a><span>|</span><label class="collapse" for="c-41414277">[-]</label><label class="expand" for="c-41414277">[4 more]</label></div><br/><div class="children"><div class="content">Django&#x27;s ORM is acceptable - but I think Rails&#x2F;ActiveRecord is superior albeit certainly more opinionated. Most likely just my personal bias speaking because Rails was the first web &quot;framework&quot; I cut my teeth on.</div><br/><div id="41414553" class="c"><input type="checkbox" id="c-41414553" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414277">parent</a><span>|</span><a href="#41414821">next</a><span>|</span><label class="collapse" for="c-41414553">[-]</label><label class="expand" for="c-41414553">[1 more]</label></div><br/><div class="children"><div class="content">I think Django&#x27;s ORM is really great but only as long as that&#x27;s the first thing you have seen.<p>If you started from Rails and ActiveRecord, you&#x27;re probably not be very appreciative of Django&#x27;s ORM.</div><br/></div></div><div id="41414821" class="c"><input type="checkbox" id="c-41414821" checked=""/><div class="controls bullet"><span class="by">bitexploder</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414277">parent</a><span>|</span><a href="#41414553">prev</a><span>|</span><a href="#41414254">next</a><span>|</span><label class="collapse" for="c-41414821">[-]</label><label class="expand" for="c-41414821">[2 more]</label></div><br/><div class="children"><div class="content">SQLAlchemy is the best stand alone ORM I have found.</div><br/><div id="41415297" class="c"><input type="checkbox" id="c-41415297" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414821">parent</a><span>|</span><a href="#41414254">next</a><span>|</span><label class="collapse" for="c-41415297">[-]</label><label class="expand" for="c-41415297">[1 more]</label></div><br/><div class="children"><div class="content">sqlalchemy is easily one of the best ORMs ever made for any language. Hats off to zzzeek.<p>Currently working in typescript and writing SQL queries out by hand since I just don’t trust anything to do the right thing wrt units of work.</div><br/></div></div></div></div></div></div><div id="41414254" class="c"><input type="checkbox" id="c-41414254" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#41414088">parent</a><span>|</span><a href="#41414277">prev</a><span>|</span><a href="#41414816">next</a><span>|</span><label class="collapse" for="c-41414254">[-]</label><label class="expand" for="c-41414254">[5 more]</label></div><br/><div class="children"><div class="content">I agree. Django&#x27;s ORM is great because it handles the relationships well, where many ORMs barely do the object mapping part well.<p>I&#x27;m rewriting a large Django project in Java (quarkus + jooq), because it&#x27;s at the point where I need a type system now, but it still has a place in my heart.</div><br/><div id="41414490" class="c"><input type="checkbox" id="c-41414490" checked=""/><div class="controls bullet"><span class="by">BarryMilo</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414254">parent</a><span>|</span><a href="#41414816">next</a><span>|</span><label class="collapse" for="c-41414490">[-]</label><label class="expand" for="c-41414490">[4 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t Django models close enough to types?</div><br/><div id="41414546" class="c"><input type="checkbox" id="c-41414546" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414490">parent</a><span>|</span><a href="#41414816">next</a><span>|</span><label class="collapse" for="c-41414546">[-]</label><label class="expand" for="c-41414546">[3 more]</label></div><br/><div class="children"><div class="content">Nope. Python type hinting is far far from Java like types.<p>And yes, I guess OP has now a large system that needs types enforced by the system to reduce the friction in evolving the stack.</div><br/><div id="41414560" class="c"><input type="checkbox" id="c-41414560" checked=""/><div class="controls bullet"><span class="by">roze_sha</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414546">parent</a><span>|</span><a href="#41414816">next</a><span>|</span><label class="collapse" for="c-41414560">[-]</label><label class="expand" for="c-41414560">[2 more]</label></div><br/><div class="children"><div class="content">What about using pydantic?</div><br/><div id="41414677" class="c"><input type="checkbox" id="c-41414677" checked=""/><div class="controls bullet"><span class="by">mehdix</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414560">parent</a><span>|</span><a href="#41414816">next</a><span>|</span><label class="collapse" for="c-41414677">[-]</label><label class="expand" for="c-41414677">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, one python project I&#x27;m working on uses an obscure Framework, and ORM. I was contemplating to convert it to FastAPI+Pydantic, however the amount of effort needed was no different than rewriting the whole project.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41414816" class="c"><input type="checkbox" id="c-41414816" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#41414088">parent</a><span>|</span><a href="#41414254">prev</a><span>|</span><a href="#41414563">next</a><span>|</span><label class="collapse" for="c-41414816">[-]</label><label class="expand" for="c-41414816">[1 more]</label></div><br/><div class="children"><div class="content">In 15+ years I’ve only used two orms: Django ORM and SQLAlchemy. I’ve also skimmed docs for many others (some JS orms, etc), and those often look completely unusable.<p>SQLAlchemy is leagues above and beyond Django ORM. I can’t say I have nightmares from dealing with it, but it certainly was not pleasure. A bit too much magic here and there, not flexible enough and provokes too much bad practices. Re-defining save() methods to do a lot of work, anyone?<p>The best “orm” that I’ve ever used was not an ORM but a query builder — HoneySQL from Clojure. That one is fantastic. No ORM bullshit, no extra data loaded from DB, no accidental N+1 queries. Not reading docs on how to do a GROUP BY, everything’s just easy to write.<p>Frankly, we often use SQLAlchemy as just a query builder too. Makes life so much easier.</div><br/></div></div><div id="41414563" class="c"><input type="checkbox" id="c-41414563" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#41414088">parent</a><span>|</span><a href="#41414816">prev</a><span>|</span><a href="#41414257">next</a><span>|</span><label class="collapse" for="c-41414563">[-]</label><label class="expand" for="c-41414563">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  I thought they’d all be that good, but no.<p>I had the &quot;pleasure&quot; to use Doctrine once. Never again !</div><br/><div id="41414730" class="c"><input type="checkbox" id="c-41414730" checked=""/><div class="controls bullet"><span class="by">vandahm</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414563">parent</a><span>|</span><a href="#41414257">next</a><span>|</span><label class="collapse" for="c-41414730">[-]</label><label class="expand" for="c-41414730">[1 more]</label></div><br/><div class="children"><div class="content">I used Doctrine for a few years, and I remember thinking that it was about 50% awesome and 50% terrible. I wonder what I would think if I came back to it today.</div><br/></div></div></div></div><div id="41414257" class="c"><input type="checkbox" id="c-41414257" checked=""/><div class="controls bullet"><span class="by">Swizec</span><span>|</span><a href="#41414088">parent</a><span>|</span><a href="#41414563">prev</a><span>|</span><a href="#41414347">next</a><span>|</span><label class="collapse" for="c-41414257">[-]</label><label class="expand" for="c-41414257">[5 more]</label></div><br/><div class="children"><div class="content">For me Django and ActiveRecord stand out as 2 good examples of what an ORM should be like. Both feel like they make the simple stuff super easy, the complex stuff figure outable, and the super hard stuff trivially possible with raw SQL and a decent mapping from that back to regular code.<p>Although over the years my code trends more and more towards `.rawSql` or whatever equivalent exists. Even for the simple stuff. It’s just so much easier than first thinking up my query then bending over backwards three times to make it fit into the ORM’s pet syntax.<p>Plus raw sql is so much easier to copypasta between different tools when you’re debugging.<p>And before you say “but sql injection!” – that’s what prepared statements&#x2F;parametrized queries are for.</div><br/><div id="41414302" class="c"><input type="checkbox" id="c-41414302" checked=""/><div class="controls bullet"><span class="by">wsc981</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414257">parent</a><span>|</span><a href="#41414697">next</a><span>|</span><label class="collapse" for="c-41414302">[-]</label><label class="expand" for="c-41414302">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve started working on a .NET project that uses EntityFramework and due to some of the magic, I prefer just using raw SQL as well. I&#x27;ve used other ORM solutions in the past as well and I am not a fan ...<p>But the team chose EF due to it supposedly being easier to integrate with whatever database the customer might be using and that seems like valid reasoning.</div><br/><div id="41414736" class="c"><input type="checkbox" id="c-41414736" checked=""/><div class="controls bullet"><span class="by">djeiejejejej</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414302">parent</a><span>|</span><a href="#41414697">next</a><span>|</span><label class="collapse" for="c-41414736">[-]</label><label class="expand" for="c-41414736">[1 more]</label></div><br/><div class="children"><div class="content">Yes I agree. That’s a valid argument, but there are other ways as well like SQLKata and other query builders.<p>Depending on the complexity of the product I think writing standard SQL92 will get you far as well.<p>I don’t get how an ORM will handle Postgres’ CTEs and windowing functions. Those are pretty basic and extremely useful features to me, but those require dropping to raw SQL. Each vendor has those useful particularities that you immediately lose by going ORM.<p>So in practice you are already required to make your queries as bland as possible where GROUP BY and JOIN is about as complex as it will get. I’d say just do SQL92 work around the limitations - which is something you’ll have to do anyway, but now more directly - and all major vendors will work OOB.</div><br/></div></div></div></div><div id="41414697" class="c"><input type="checkbox" id="c-41414697" checked=""/><div class="controls bullet"><span class="by">djeiejejejej</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414257">parent</a><span>|</span><a href="#41414302">prev</a><span>|</span><a href="#41414347">next</a><span>|</span><label class="collapse" for="c-41414697">[-]</label><label class="expand" for="c-41414697">[2 more]</label></div><br/><div class="children"><div class="content">Same here, but IMO it is related to skill and experience.<p>Once you get sufficiently familiar with some paradigm the training wheels can come off.<p>“Raw” SQL is already an abstraction. Over time all the implicit magic will get on your nerves. Trying to shoehorn two completely different worlds into one abstraction is not worth it: you get to learn today’s untransferable funky ORM syntax and idiosyncrasies while losing sight of the actual skill that matters long term which is SQL itself.<p>I concede however that handling of SQL, the field names, the relations, is annoying. But it’s core to the problem you are probably solving (some form of CRUD). Plumbing is annoying but as a plumber I’d say get used to it instead of wishing to be dancer.<p>I notice this in other aspects of my work as well. When I switched away trom desktop environment to terminal I had the same feeling. It’s easier, less hassle, less wonky abstractions, more direct. Completely counter to what popular culture is telling me.</div><br/><div id="41414865" class="c"><input type="checkbox" id="c-41414865" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414697">parent</a><span>|</span><a href="#41414347">next</a><span>|</span><label class="collapse" for="c-41414865">[-]</label><label class="expand" for="c-41414865">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I concede however that handling of SQL, the field names, the relations, is annoying. But it’s core to the problem you are probably solving (some form of CRUD). Plumbing is annoying but as a plumber I’d say get used to it instead of wishing to be dancer.<p>It feels more like outsourcing said plumbing to someone that has done a lot of it in the past and will in most cases save you time, even if they won’t do everything the way you’d prefer yourself.<p>Throw in a bit of codegen and reading your current schema (if using schema first approach) and you’re in a pretty nice spot to be, except for the times when ORMs will get confused with non trivial joins and relationships, but typically then you have an escape hatch to have the query be in raw SQL while still mapping the outputs to whatever objects you need.<p>To be clear, I still think that mapping read only entities&#x2F;DTOs against specialized database views for non-trivial data selection makes sense a lot of time regardless of the stack (or even <i>some</i> in-database processing with stored procedures), but basic ORM mappings are useful a lot of time too.</div><br/></div></div></div></div></div></div><div id="41414347" class="c"><input type="checkbox" id="c-41414347" checked=""/><div class="controls bullet"><span class="by">malux85</span><span>|</span><a href="#41414088">parent</a><span>|</span><a href="#41414257">prev</a><span>|</span><a href="#41414205">next</a><span>|</span><label class="collapse" for="c-41414347">[-]</label><label class="expand" for="c-41414347">[2 more]</label></div><br/><div class="children"><div class="content">I love the django ORM and then the REST framework on top of that.<p>Define the object, hook it to a view, use our custom permission class, done.<p>GET, POST, PATCH, DELETE all urls, filtering, pagination, search, ordering, complex multi-org multi-user object permissions handled automatically. Need custom logic? Just overwrite  method.<p>It’s a productivity superpower, sure there’s a lot to learn but that’s the price you pay for the tools that make you hyper productive</div><br/><div id="41414831" class="c"><input type="checkbox" id="c-41414831" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#41414088">root</a><span>|</span><a href="#41414347">parent</a><span>|</span><a href="#41414205">next</a><span>|</span><label class="collapse" for="c-41414831">[-]</label><label class="expand" for="c-41414831">[1 more]</label></div><br/><div class="children"><div class="content">Ninja is even better than the REST framework. Practically no boilerplate.</div><br/></div></div></div></div><div id="41414205" class="c"><input type="checkbox" id="c-41414205" checked=""/><div class="controls bullet"><span class="by">1propionyl</span><span>|</span><a href="#41414088">parent</a><span>|</span><a href="#41414347">prev</a><span>|</span><a href="#41414815">next</a><span>|</span><label class="collapse" for="c-41414205">[-]</label><label class="expand" for="c-41414205">[1 more]</label></div><br/><div class="children"><div class="content">This is generally my experience as well. I don&#x27;t love using ORMs but at least Django&#x27;s is relatively painless and I can generally find the escape hatch I need.<p>The lack of support until very recently (and it&#x27;s still lacking) for views is the main knock.</div><br/></div></div></div></div><div id="41414815" class="c"><input type="checkbox" id="c-41414815" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#41414088">prev</a><span>|</span><label class="collapse" for="c-41414815">[-]</label><label class="expand" for="c-41414815">[2 more]</label></div><br/><div class="children"><div class="content">This is largely academic now. LLMs do a good job of writing highly complex queries with the django ORM.<p>All you need is the django toolbar so you can check their efficiency, then keep telling it to make them more efficient.</div><br/><div id="41415202" class="c"><input type="checkbox" id="c-41415202" checked=""/><div class="controls bullet"><span class="by">ruthmarx</span><span>|</span><a href="#41414815">parent</a><span>|</span><label class="collapse" for="c-41415202">[-]</label><label class="expand" for="c-41415202">[1 more]</label></div><br/><div class="children"><div class="content">LLMs are not at a point where we should be treating them as a solution to any software engineering issue, period.</div><br/></div></div></div></div></div></div></div></div></div></body></html>