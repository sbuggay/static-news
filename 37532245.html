<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694854877741" as="style"/><link rel="stylesheet" href="styles.css?v=1694854877741"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fauna.com/blog/relational-is-more-than-sql">Relational is more than SQL</a> <span class="domain">(<a href="https://fauna.com">fauna.com</a>)</span></div><div class="subtext"><span>tysont</span> | <span>20 comments</span></div><br/><div><div id="37533010" class="c"><input type="checkbox" id="c-37533010" checked=""/><div class="controls bullet"><span class="by">snthpy</span><span>|</span><a href="#37532536">next</a><span>|</span><label class="collapse" for="c-37533010">[-]</label><label class="expand" for="c-37533010">[2 more]</label></div><br/><div class="children"><div class="content">Disclaimer: I&#x27;m a core contributor to PRQL [1] and post about it a lot on HN. Apologies for jumping in on other people&#x27;s threads, but for people interested in the headline, PRQL might be of interest.<p>At PRQL[1] we believe that SQL is a combination of two things:<p>1. Relational Algebra, which is eternal because it&#x27;s just maths, and
2. A language designed in the 70s that looks like COBOL.<p>When people say that SQL will never die, they are usually thinking about Relational Algebra because SQL has been used interchangeably with that. With PRQL we agree that Relational Algebra is fundamental to thinking about data and we intend to keep that. However we&#x27;ve learned a lot about programming languages in the last 50 years and so PRQL is a revamp of SQL that brings the composability of functional languages and modern ergonomics to data transformations in order to improve the DX and UX of data scientists, data analysts and analytics engineers.<p>PRQL is simply a compiler that produces SQL so you can use it with whatever database you are currently using. It&#x27;s completely open source with zero commercial associations and is deeply committed to staying that way forever.<p>1: <a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;prql-lang.org&#x2F;</a></div><br/><div id="37533167" class="c"><input type="checkbox" id="c-37533167" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#37533010">parent</a><span>|</span><a href="#37532536">next</a><span>|</span><label class="collapse" for="c-37533167">[-]</label><label class="expand" for="c-37533167">[1 more]</label></div><br/><div class="children"><div class="content">That first PRQL code sample is wonderfully readable.</div><br/></div></div></div></div><div id="37532536" class="c"><input type="checkbox" id="c-37532536" checked=""/><div class="controls bullet"><span class="by">herodoturtle</span><span>|</span><a href="#37533010">prev</a><span>|</span><a href="#37532434">next</a><span>|</span><label class="collapse" for="c-37532536">[-]</label><label class="expand" for="c-37532536">[1 more]</label></div><br/><div class="children"><div class="content">This is a very interesting way to promote a product, credit to the author (who is an industry veteran it seems).<p>I had no idea what Fauna was. I just clicked the link here because the title caught my eye (I work with databases quite a bit).<p>The opening paragraph immediately grabbed my attention - &quot;My first deep dive into SQL was in 1987, just before I became the first technical person at Microsoft to work on SQL Server.&quot; - woah!<p>So I read this entire article, which is very well written and easy to read but mostly affirms what I already know.<p>And then I get to the final section where they promote Fauna - and so now I know about Fauna too.<p>Kudos to these folks, in my humble opinion, this is marketing done right.</div><br/></div></div><div id="37532434" class="c"><input type="checkbox" id="c-37532434" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#37532536">prev</a><span>|</span><a href="#37533023">next</a><span>|</span><label class="collapse" for="c-37532434">[-]</label><label class="expand" for="c-37532434">[8 more]</label></div><br/><div class="children"><div class="content">Nitpick, but relational does not mean joins, it means tables&#x2F;rows of tuples. A &quot;relational document database&quot; which is the slogan of Fauna it seems is a contradiction in terms.</div><br/><div id="37532630" class="c"><input type="checkbox" id="c-37532630" checked=""/><div class="controls bullet"><span class="by">contrast</span><span>|</span><a href="#37532434">parent</a><span>|</span><a href="#37533023">next</a><span>|</span><label class="collapse" for="c-37532630">[-]</label><label class="expand" for="c-37532630">[7 more]</label></div><br/><div class="children"><div class="content">That’s technically correct, and I think the author would say he’s aware of that definition.<p>The article as I read it is trying to make a broader point, that there are underlying mathematical principles that inspired Codd’s relational model.<p>I’ve never had cause to explore it, but my understanding is that there’s nothing in those principles that require tables&#x2F;rows of tuples.<p>One goal of the article seems to be to inspire a curiosity in knowledgeable readers: what happens if you build a document database that also supports the same mathematical principles that inspired the relational model?</div><br/><div id="37533040" class="c"><input type="checkbox" id="c-37533040" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37532434">root</a><span>|</span><a href="#37532630">parent</a><span>|</span><a href="#37532741">next</a><span>|</span><label class="collapse" for="c-37533040">[-]</label><label class="expand" for="c-37533040">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The article as I read it is trying to make a broader point, that there are underlying mathematical principles that inspired Codd’s relational model.<p>The relational model is a direct product of a set of mathematical principles Codd put together called relational algebra, which deals with sets of tuples called relations.<p>Nothing in the article addresses any of the mathematical underpinnings of the relational model. Its blowing smoke at an audience that it expects to know next to nothing about the topic.<p>&gt; One goal of the article seems to be to inspire a curiosity in knowledgeable readers: what happens if you build a document database that also supports the same mathematical principles that inspired the relational model<p>The features of RDBMSs that they seem to be suggesting FQL supports are ACID transactions. While that&#x27;s an important feature of RDBMSs, it isn’t the same thing as the mathematical principles addresses by the relational model, whether relational algebra or the more general set theory that inspires it. The article isn&#x27;t directed at knowledgable readers.</div><br/></div></div><div id="37532741" class="c"><input type="checkbox" id="c-37532741" checked=""/><div class="controls bullet"><span class="by">gregjor</span><span>|</span><a href="#37532434">root</a><span>|</span><a href="#37532630">parent</a><span>|</span><a href="#37533040">prev</a><span>|</span><a href="#37532889">next</a><span>|</span><label class="collapse" for="c-37532741">[-]</label><label class="expand" for="c-37532741">[3 more]</label></div><br/><div class="children"><div class="content">&gt; there’s nothing in [Codd’s] principles that require tables&#x2F;rows of tuples.<p>Have you read Codd’s Rules #1 and #2? Pretty clear on this point.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Codd%27s_12_rules" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Codd%27s_12_rules</a><p>Technically the relational model uses the term <i>relation</i> to refer to an unordered set of tuples, where every tuple has a key (one or more elements) to uniquely identify it, and every tuple has the same number of items, of the same type. Tables are relations. So are the results of a query, which can include joins.</div><br/><div id="37532931" class="c"><input type="checkbox" id="c-37532931" checked=""/><div class="controls bullet"><span class="by">ghusbands</span><span>|</span><a href="#37532434">root</a><span>|</span><a href="#37532741">parent</a><span>|</span><a href="#37532889">next</a><span>|</span><label class="collapse" for="c-37532931">[-]</label><label class="expand" for="c-37532931">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; there’s nothing in [Codd’s] principles that require tables&#x2F;rows of tuples.<p>You&#x27;re misquoting; is that intentional? The post you&#x27;re replying to says the principles that inspired&#x2F;predate Codd don&#x27;t require tables&#x2F;tuples. Thus, the details of Codd&#x27;s relational model are irrelevant.</div><br/><div id="37532943" class="c"><input type="checkbox" id="c-37532943" checked=""/><div class="controls bullet"><span class="by">bazoom42</span><span>|</span><a href="#37532434">root</a><span>|</span><a href="#37532931">parent</a><span>|</span><a href="#37532889">next</a><span>|</span><label class="collapse" for="c-37532943">[-]</label><label class="expand" for="c-37532943">[1 more]</label></div><br/><div class="children"><div class="content">What principles are you talking about then?</div><br/></div></div></div></div></div></div><div id="37532889" class="c"><input type="checkbox" id="c-37532889" checked=""/><div class="controls bullet"><span class="by">bazoom42</span><span>|</span><a href="#37532434">root</a><span>|</span><a href="#37532630">parent</a><span>|</span><a href="#37532741">prev</a><span>|</span><a href="#37533023">next</a><span>|</span><label class="collapse" for="c-37532889">[-]</label><label class="expand" for="c-37532889">[2 more]</label></div><br/><div class="children"><div class="content">A relation is by definition a set of tuples (informally called a table where the tuples are the rows).<p>Codds relational database model adds the further constraint that nested tables are not allowed (first normal form), instead representing relationships through foreign keys.<p>Codds motivation for disallowing nested tables is that it makes query languages much simpler. He develops relational algebra which is the foundation behind SQL, which is why SQL does not allow nested tables.<p>Document databases does not follow first normal form and allows nested structures, so they cannot be queried with relational algebra, since it doesnt have a way to “drill down” into nested structures.<p>It is unclear to me what “mathematical principles” remain if you remove the notion of relations from the relational model.</div><br/><div id="37533063" class="c"><input type="checkbox" id="c-37533063" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#37532434">root</a><span>|</span><a href="#37532889">parent</a><span>|</span><a href="#37533023">next</a><span>|</span><label class="collapse" for="c-37533063">[-]</label><label class="expand" for="c-37533063">[1 more]</label></div><br/><div class="children"><div class="content">Out of my depth here (no experience) but &quot;Codds relational database model adds the further constraint that nested tables are not allowed&quot; may be wrong. He allowed nested stuff, it&#x27;s just that SQL didn&#x27;t support it.<p>Can anyone elucidate? Please don&#x27;t shout that I&#x27;m wrong because there was <i>something</i> there in his first paper.</div><br/></div></div></div></div></div></div></div></div><div id="37533023" class="c"><input type="checkbox" id="c-37533023" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37532434">prev</a><span>|</span><a href="#37532977">next</a><span>|</span><label class="collapse" for="c-37533023">[-]</label><label class="expand" for="c-37533023">[2 more]</label></div><br/><div class="children"><div class="content">On strong schemas and flexibility:<p>1. You still have a schema in your code. With weak schemas it&#x27;s now just harder to know if every record in your database conforms to it.<p>2. An ORM is a great tool for prototyping. R.g. have SQLAlchemy objects in code, run a command to generate a database migration; run the migration, and you have all your data guaranteed to be compatible with your latest code, and you didn&#x27;t write any SQL.</div><br/><div id="37533136" class="c"><input type="checkbox" id="c-37533136" checked=""/><div class="controls bullet"><span class="by">m_mueller</span><span>|</span><a href="#37533023">parent</a><span>|</span><a href="#37532977">next</a><span>|</span><label class="collapse" for="c-37533136">[-]</label><label class="expand" for="c-37533136">[1 more]</label></div><br/><div class="children"><div class="content">If you program defensively you can save on certain common Schema updates in e.g. a document based data model (e.g. adding more fields). But strong schemas definitely make sense when you’re dealing with relational data from my experience. Earlier in my career I built a relational model on top of CouchDB (due to its strong replication capabilities, including on mobile devices), but it was definitely painful (and less performant) compared to building it in a relational DB.</div><br/></div></div></div></div><div id="37532977" class="c"><input type="checkbox" id="c-37532977" checked=""/><div class="controls bullet"><span class="by">ghusbands</span><span>|</span><a href="#37533023">prev</a><span>|</span><a href="#37532623">next</a><span>|</span><label class="collapse" for="c-37532977">[-]</label><label class="expand" for="c-37532977">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Most importantly, SQL databases made supporting highly consistent ACID transactions easy.<p>The default transaction isolation level for every major database is not ACID. Enabling the required serializability tends to make performance terrible, and so most don&#x27;t.</div><br/><div id="37533018" class="c"><input type="checkbox" id="c-37533018" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#37532977">parent</a><span>|</span><a href="#37532984">next</a><span>|</span><label class="collapse" for="c-37533018">[-]</label><label class="expand" for="c-37533018">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Enabling the required serializability...<p>is trivial, no?<p>&gt; ...tends to make performance terrible<p>I&#x27;ve heard this a lot but never seen any figures - anyone have any numbers&#x2F;experience?<p>(edit: and most apps I&#x27;ve worked with didn&#x27;t need serialisability, either because they were working with a snapshot of data or absolutely precise answers weren&#x27;t needed)</div><br/></div></div><div id="37532984" class="c"><input type="checkbox" id="c-37532984" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#37532977">parent</a><span>|</span><a href="#37533018">prev</a><span>|</span><a href="#37532623">next</a><span>|</span><label class="collapse" for="c-37532984">[-]</label><label class="expand" for="c-37532984">[2 more]</label></div><br/><div class="children"><div class="content">that&#x27;s presumably why the author said &quot;made supporting... easy&quot;, not &quot;is&quot;?</div><br/><div id="37533111" class="c"><input type="checkbox" id="c-37533111" checked=""/><div class="controls bullet"><span class="by">ghusbands</span><span>|</span><a href="#37532977">root</a><span>|</span><a href="#37532984">parent</a><span>|</span><a href="#37532623">next</a><span>|</span><label class="collapse" for="c-37533111">[-]</label><label class="expand" for="c-37533111">[1 more]</label></div><br/><div class="children"><div class="content">Most people believe that databases are ACID by default, so it&#x27;s worth bringing up when an article even subtly implies otherwise.</div><br/></div></div></div></div></div></div><div id="37532623" class="c"><input type="checkbox" id="c-37532623" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#37532977">prev</a><span>|</span><label class="collapse" for="c-37532623">[-]</label><label class="expand" for="c-37532623">[2 more]</label></div><br/><div class="children"><div class="content">Seems like a lot of what fauna does by storing documents isn’t really new, oracle, Postgres and others have provided this for a long time. I was really surprised by the performance of json queries [1], opens the doors to using Postgres as a client api cache, storing the payload in a table, and doing deserialization using (materialized) views.<p>Difference seems to be the approach to minimize number of calls from your application, get all require session data in one call, similar to what graphql is doing for api calls. They’re also using http as the protocol for database connectivity.<p>[1]: <a href="https:&#x2F;&#x2F;ako.github.io&#x2F;blog&#x2F;2023&#x2F;08&#x2F;25&#x2F;json-transformations.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;ako.github.io&#x2F;blog&#x2F;2023&#x2F;08&#x2F;25&#x2F;json-transformations.h...</a></div><br/><div id="37533122" class="c"><input type="checkbox" id="c-37533122" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37532623">parent</a><span>|</span><label class="collapse" for="c-37533122">[-]</label><label class="expand" for="c-37533122">[1 more]</label></div><br/><div class="children"><div class="content">Yes - the difference you mention seems to be the main difference.</div><br/></div></div></div></div></div></div></div></div></div></body></html>