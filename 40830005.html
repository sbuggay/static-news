<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719738059202" as="style"/><link rel="stylesheet" href="styles.css?v=1719738059202"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://memorycorruption.net/posts/rce-lua-factorio/">Bytecode Breakdown: Unraveling Factorio&#x27;s Lua Security Flaws</a> <span class="domain">(<a href="https://memorycorruption.net">memorycorruption.net</a>)</span></div><div class="subtext"><span>memcorruption</span> | <span>101 comments</span></div><br/><div><div id="40833342" class="c"><input type="checkbox" id="c-40833342" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40831708">next</a><span>|</span><label class="collapse" for="c-40833342">[-]</label><label class="expand" for="c-40833342">[13 more]</label></div><br/><div class="children"><div class="content">Unexpected!<p>Since lua interprets bytecode, it can check the arguments to the bytecode are meaningful. Point to memory lua allocated, things like that.<p>Turns out it doesn&#x27;t do that. Feed it bytecode with invalid arguments passed to the instructions and it executes it anyway. The rest of the compromise follows.<p>Further, instead of fixing their interpreter, the game plan is to statically analyse bytecode. Which turns out to only work in simple cases.<p>For a sandbox friendly interpreted language this is pretty disappointing. I wonder if they&#x27;d take patches to stop the interpreter trusting the input - presumably performance regression is the fear there, which seems dubious when luajit is the fast option anyway.</div><br/><div id="40833551" class="c"><input type="checkbox" id="c-40833551" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#40833342">parent</a><span>|</span><a href="#40833505">next</a><span>|</span><label class="collapse" for="c-40833551">[-]</label><label class="expand" for="c-40833551">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I wonder if they&#x27;d take patches to stop the interpreter trusting the input<p>The stance of the Lua developers AIUI is that processes that execute arbitrary Lua code should only accept source, and disable direct loading of byte code.<p>This seems reasonable to me, as it preserves the option of directly loading trusted byte code, while avoiding putting dynamic checks into the interpreter that would affect all users.</div><br/><div id="40834806" class="c"><input type="checkbox" id="c-40834806" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#40833342">root</a><span>|</span><a href="#40833551">parent</a><span>|</span><a href="#40833505">next</a><span>|</span><label class="collapse" for="c-40834806">[-]</label><label class="expand" for="c-40834806">[1 more]</label></div><br/><div class="children"><div class="content">Correct. From the Lua 5.2 manual [0]:<p>&quot;all functions that load code are potentially insecure when loading untrusted binary data. [...] When in doubt, use the mode argument of those functions to restrict them to loading textual chunks.&quot;<p>I thought this was widely known within the Lua community - I&#x27;m amazed that Factorio would support loading untrusted bytecode. Was that a decision the game&#x27;s developers actively made (for what reasons?) or were they simply unaware of the risks?<p>[0] <a href="https:&#x2F;&#x2F;www.lua.org&#x2F;manual&#x2F;5.2&#x2F;manual.html#8.2" rel="nofollow">https:&#x2F;&#x2F;www.lua.org&#x2F;manual&#x2F;5.2&#x2F;manual.html#8.2</a></div><br/></div></div></div></div><div id="40833505" class="c"><input type="checkbox" id="c-40833505" checked=""/><div class="controls bullet"><span class="by">AHTERIX5000</span><span>|</span><a href="#40833342">parent</a><span>|</span><a href="#40833551">prev</a><span>|</span><a href="#40834590">next</a><span>|</span><label class="collapse" for="c-40833505">[-]</label><label class="expand" for="c-40833505">[2 more]</label></div><br/><div class="children"><div class="content">Sandbox friendly?<p>It&#x27;s not exactly a simple task to make safe interpreter for bytecode as some other languages have shown. It&#x27;s a trade-off which also simplifies the reference implementation.<p>I wouldn&#x27;t trust most of these interpreters when it comes to third party code execution, I barely trust my browser even with all the R&amp;D money and attention web browsers receive.</div><br/><div id="40833763" class="c"><input type="checkbox" id="c-40833763" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40833342">root</a><span>|</span><a href="#40833505">parent</a><span>|</span><a href="#40834590">next</a><span>|</span><label class="collapse" for="c-40833763">[-]</label><label class="expand" for="c-40833763">[1 more]</label></div><br/><div class="children"><div class="content">Sandboxed in the sense that things like file i&#x2F;o or network access can be easily removed and selectively reintroduced, e.g. to give an interpreter which can trash it&#x27;s own heap but can&#x27;t do anything to the host.<p>Bounds checking on instruction opcodes can absolutely be implemented in an interpreter. I suppose it&#x27;s more complicated than just trusting the integer - but then the thing doesn&#x27;t fall over on malformed bytecode which seems like a feature.</div><br/></div></div></div></div><div id="40834590" class="c"><input type="checkbox" id="c-40834590" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#40833342">parent</a><span>|</span><a href="#40833505">prev</a><span>|</span><a href="#40834648">next</a><span>|</span><label class="collapse" for="c-40834590">[-]</label><label class="expand" for="c-40834590">[4 more]</label></div><br/><div class="children"><div class="content">Java, Wasm and BPF demonstrate that it is possible to have statically-verifiable bytecode for JIT-compiled languages. Lua’s problem is that the bytecode doesn’t provide the information necessary to fully verify its safety.</div><br/><div id="40834899" class="c"><input type="checkbox" id="c-40834899" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#40833342">root</a><span>|</span><a href="#40834590">parent</a><span>|</span><a href="#40834648">next</a><span>|</span><label class="collapse" for="c-40834899">[-]</label><label class="expand" for="c-40834899">[3 more]</label></div><br/><div class="children"><div class="content">All of those formats are designed to be translated to machine code when maximum performance is desired.  Whereas Lua byte code is designed and optimized to be interpreted directly.<p>One step in Lua&#x27;s evolution was to change from a stack machine to a register machine: <a href="https:&#x2F;&#x2F;www.lua.org&#x2F;doc&#x2F;jucs05.pdf" rel="nofollow">https:&#x2F;&#x2F;www.lua.org&#x2F;doc&#x2F;jucs05.pdf</a>  This made the interpreter faster, but also (I suspect) more difficult to verify.  I believe both Java and Wasm are stack machines (don&#x27;t know about BPF).</div><br/><div id="40835630" class="c"><input type="checkbox" id="c-40835630" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#40833342">root</a><span>|</span><a href="#40834899">parent</a><span>|</span><a href="#40834648">next</a><span>|</span><label class="collapse" for="c-40835630">[-]</label><label class="expand" for="c-40835630">[2 more]</label></div><br/><div class="children"><div class="content">Java was not. It was originally designed to be interpreted, and is still interpreted in many implementations (especially before any JIT kicks in).<p>In any case, those were just the examples I could think of OTOH. MSIL&#x2F;CIL is another good example; I’m sure there are many others.</div><br/><div id="40835704" class="c"><input type="checkbox" id="c-40835704" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40833342">root</a><span>|</span><a href="#40835630">parent</a><span>|</span><a href="#40834648">next</a><span>|</span><label class="collapse" for="c-40835704">[-]</label><label class="expand" for="c-40835704">[1 more]</label></div><br/><div class="children"><div class="content">Technically speaking, CIL is always compiled by CoreCLR (it has interpreter internally but it is never used and therefore has succumbed to bitrot), it is <i>sometimes</i> interpreted by Mono on certain platforms as a stand in for dynamically emitted code. A special case used to be with WASM target with Mono but supposedly that&#x27;s in the past.</div><br/></div></div></div></div></div></div></div></div><div id="40834648" class="c"><input type="checkbox" id="c-40834648" checked=""/><div class="controls bullet"><span class="by">tmaly</span><span>|</span><a href="#40833342">parent</a><span>|</span><a href="#40834590">prev</a><span>|</span><a href="#40834761">next</a><span>|</span><label class="collapse" for="c-40834648">[-]</label><label class="expand" for="c-40834648">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if this affects Roblox variant of Lua?</div><br/><div id="40834834" class="c"><input type="checkbox" id="c-40834834" checked=""/><div class="controls bullet"><span class="by">awkasljptafatfx</span><span>|</span><a href="#40833342">root</a><span>|</span><a href="#40834648">parent</a><span>|</span><a href="#40834761">next</a><span>|</span><label class="collapse" for="c-40834834">[-]</label><label class="expand" for="c-40834834">[2 more]</label></div><br/><div class="children"><div class="content">Luau (Roblox&#x27;s variant of Lua) seems to have disabled loading bytecode from Lua completely. Per <a href="https:&#x2F;&#x2F;luau-lang.org&#x2F;sandbox" rel="nofollow">https:&#x2F;&#x2F;luau-lang.org&#x2F;sandbox</a>:<p>&gt; To achieve memory safety, access to function bytecode has been removed. Bytecode is hard to validate and using untrusted bytecode may lead to exploits. Thus, loadstring doesn’t work with bytecode inputs, and string.dump&#x2F;load have been removed as they aren’t necessary anymore. When embedding Luau, bytecode should be encrypted&#x2F;signed to prevent MITM attacks as well, as the VM assumes that the bytecode was generated by the Luau compiler (which never produces invalid&#x2F;unsafe bytecode).</div><br/><div id="40835605" class="c"><input type="checkbox" id="c-40835605" checked=""/><div class="controls bullet"><span class="by">HaroldCindy</span><span>|</span><a href="#40833342">root</a><span>|</span><a href="#40834834">parent</a><span>|</span><a href="#40834761">next</a><span>|</span><label class="collapse" for="c-40835605">[-]</label><label class="expand" for="c-40835605">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; the VM assumes that the bytecode was generated by the Luau compiler (which never produces invalid&#x2F;unsafe bytecode)<p>Yep, to that end they also have a basic bytecode verifier (only used in debug mode &#x2F; when asserts are enabled) that validates the compiler only outputs valid bytecode, and I believe they continuously fuzz the compiler to make sure those asserts can&#x27;t be triggered. See <a href="https:&#x2F;&#x2F;github.com&#x2F;luau-lang&#x2F;luau&#x2F;blob&#x2F;0d2688844ab285af1ef52f15878b57911c3cf056&#x2F;Compiler&#x2F;src&#x2F;BytecodeBuilder.cpp#L1251">https:&#x2F;&#x2F;github.com&#x2F;luau-lang&#x2F;luau&#x2F;blob&#x2F;0d2688844ab285af1ef52...</a><p>It&#x27;s fairly robust (and Luau bytecode isn&#x27;t _that_ complex,) but they made the right decision disallowing direct bytecode execution.</div><br/></div></div></div></div></div></div><div id="40834761" class="c"><input type="checkbox" id="c-40834761" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40833342">parent</a><span>|</span><a href="#40834648">prev</a><span>|</span><a href="#40831708">next</a><span>|</span><label class="collapse" for="c-40834761">[-]</label><label class="expand" for="c-40834761">[1 more]</label></div><br/><div class="children"><div class="content">No, expected. Only execute bytecode that was actually generated by the correct compiler. Otherwise you get memory safety violations or sandbox escapes. (Or sandbox escapes via memory safety violations.)<p>Just as you don&#x27;t execute arbitrary machine code.<p>Luau has the same thing, and you don&#x27;t see Roblox suffering from sandbox escapes all the time, do you?</div><br/></div></div></div></div><div id="40831708" class="c"><input type="checkbox" id="c-40831708" checked=""/><div class="controls bullet"><span class="by">CapsAdmin</span><span>|</span><a href="#40833342">prev</a><span>|</span><a href="#40831204">next</a><span>|</span><label class="collapse" for="c-40831708">[-]</label><label class="expand" for="c-40831708">[9 more]</label></div><br/><div class="children"><div class="content">I wish this was more defined or documented somehow. You&#x27;re kind of left on your own to figure out whether a language is reasonably guaranteed to be safe or not.<p>Some example scenarios:<p>- Code is static and is executed directly by a user, the default case languages care typically care about. Including Lua.<p>- Code is dynamically fetched and executed through some update process, hopefully only through official channels. Here you can get away by making the process secure, but who knows.<p>- Code can be added by the user through plugins, this can be made easier through stores with the click of a button. You can review plugins, but this is hardly done. Here you need to consider if the code should be sandboxed or the user should be careful.<p>- A multiplayer game where a server can be extended with custom code via plugins, but not the clients. Here you need to consider that the users&#x2F;gamers who are hosting servers are eager to try many different plugins. The plugin community (gamers) can also be a lot more dangerous.<p>- A multiplayer game where the server can execute arbitrary code on clients, just like a browser. Here you need to be very careful about sandboxing, especially on clients as gamers will just join random servers without thinking about the security implications.<p>The last point being Factorio&#x27;s case. I&#x27;m not necessarily disagreeing that it&#x27;s the developers job to evaluate this, but sometimes it&#x27;s not obvious that for example the load function in Lua can run arbitrary bytecode which is unsafe.<p>To be honest, I wasn&#x27;t aware that Lua&#x27;s bytecode is unsafe, but I am aware that LuaJIT&#x27;s bytecode is unsafe. But as far as I know this fact is just stated randomly in the mailing list and github issues as an obvious fact.<p>There is another thing about servers being able to crash clients (just run some infinite loop on them), but this much harder and maybe pointless to avoid.</div><br/><div id="40832822" class="c"><input type="checkbox" id="c-40832822" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40831708">parent</a><span>|</span><a href="#40831805">next</a><span>|</span><label class="collapse" for="c-40832822">[-]</label><label class="expand" for="c-40832822">[2 more]</label></div><br/><div class="children"><div class="content">You should never assume any method of executing any attacker controlled code is safe, unless something explicitly calls that out and also has put Google-level amounts of effort into supporting that.</div><br/><div id="40834531" class="c"><input type="checkbox" id="c-40834531" checked=""/><div class="controls bullet"><span class="by">_factor</span><span>|</span><a href="#40831708">root</a><span>|</span><a href="#40832822">parent</a><span>|</span><a href="#40831805">next</a><span>|</span><label class="collapse" for="c-40834531">[-]</label><label class="expand" for="c-40834531">[1 more]</label></div><br/><div class="children"><div class="content">My interpreter only accepts print and addition to a predefined variable.  Let the attackers print and count all they want.<p>The problem isn’t the execution, it’s the scope of what it means to “execute”.</div><br/></div></div></div></div><div id="40831805" class="c"><input type="checkbox" id="c-40831805" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#40831708">parent</a><span>|</span><a href="#40832822">prev</a><span>|</span><a href="#40832392">next</a><span>|</span><label class="collapse" for="c-40831805">[-]</label><label class="expand" for="c-40831805">[5 more]</label></div><br/><div class="children"><div class="content">&gt; A multiplayer game where a server can be extended with custom code via plugins<p>A game called Mordhau (based on Unreal engine) had a built-in &quot;message of the day&quot; feature where server owners can put in a URL that loads an in-game browser when the player connects. No client side option existed to disable the browser and I believe the devs eventually disabled it completely but I&#x27;m not sure the status of it now.<p>Just shows how complex games &#x2F; game engines are getting where you have an embedded web browser for seemingly no good reason.</div><br/><div id="40833343" class="c"><input type="checkbox" id="c-40833343" checked=""/><div class="controls bullet"><span class="by">ooterness</span><span>|</span><a href="#40831708">root</a><span>|</span><a href="#40831805">parent</a><span>|</span><a href="#40835135">next</a><span>|</span><label class="collapse" for="c-40833343">[-]</label><label class="expand" for="c-40833343">[1 more]</label></div><br/><div class="children"><div class="content">The game &quot;Tabletop Simulator&quot; allows you to spawn various objects into a VR playspace. One of the objects is a tablet PC, which displays a little web browser on its virtual screen. It&#x27;s handy to look up rules or whatever without leaving VR.<p>The last time I tried this, the browser had a notification that it was out of date and needed updates.<p>Thinking about this broke my brain a little. I have no idea how to apply software updates to the virtual browser on the virtual tablet running in a virtual room simulated by my (hopefully real) PC.</div><br/></div></div><div id="40835135" class="c"><input type="checkbox" id="c-40835135" checked=""/><div class="controls bullet"><span class="by">CapsAdmin</span><span>|</span><a href="#40831708">root</a><span>|</span><a href="#40831805">parent</a><span>|</span><a href="#40833343">prev</a><span>|</span><a href="#40833231">next</a><span>|</span><label class="collapse" for="c-40835135">[-]</label><label class="expand" for="c-40835135">[1 more]</label></div><br/><div class="children"><div class="content">Garry&#x27;s mod uses Lua on server and clients. It also has the ability to create an embedded web browser on the client.<p>There have been many exploits throughout the years, including this particular exploit with bytecode, though in LuaJIT. Some were source engine related, some LuaJIT related, some web browser related (Awesomium) and some even steam overlay related.<p>I believe one funny thing about Awesomium was being able to read arbitrary files outside of the sandboxed virtual file system by using the file:&#x2F;&#x2F; uri scheme. I think some debug related commands in source engine would also allow you to get a list of files outside of the virtual file system.<p>At one point someone even managed to install actual malware on my computer and sent me screenshots of my desktop. I forgot what the exploit was though.</div><br/></div></div><div id="40833231" class="c"><input type="checkbox" id="c-40833231" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40831708">root</a><span>|</span><a href="#40831805">parent</a><span>|</span><a href="#40835135">prev</a><span>|</span><a href="#40832839">next</a><span>|</span><label class="collapse" for="c-40833231">[-]</label><label class="expand" for="c-40833231">[1 more]</label></div><br/><div class="children"><div class="content">Unreal Engine has something that can be called embedded web browser since the day one. The original Unreal Engine is this thing that has its own implementation of “something not entirely unlike JVM” and refers to various things by means of URLs.</div><br/></div></div><div id="40832839" class="c"><input type="checkbox" id="c-40832839" checked=""/><div class="controls bullet"><span class="by">zachrip</span><span>|</span><a href="#40831708">root</a><span>|</span><a href="#40831805">parent</a><span>|</span><a href="#40833231">prev</a><span>|</span><a href="#40832392">next</a><span>|</span><label class="collapse" for="c-40832839">[-]</label><label class="expand" for="c-40832839">[1 more]</label></div><br/><div class="children"><div class="content">A lot of games have web browsers embedded nowadays for ui</div><br/></div></div></div></div><div id="40832392" class="c"><input type="checkbox" id="c-40832392" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#40831708">parent</a><span>|</span><a href="#40831805">prev</a><span>|</span><a href="#40831204">next</a><span>|</span><label class="collapse" for="c-40832392">[-]</label><label class="expand" for="c-40832392">[1 more]</label></div><br/><div class="children"><div class="content">The first thing to look for is if the solution states clearly that it is a speculation-safe sandbox. I do think that not many will do that, but there are some. And go from there.</div><br/></div></div></div></div><div id="40831204" class="c"><input type="checkbox" id="c-40831204" checked=""/><div class="controls bullet"><span class="by">est31</span><span>|</span><a href="#40831708">prev</a><span>|</span><a href="#40831535">next</a><span>|</span><label class="collapse" for="c-40831204">[-]</label><label class="expand" for="c-40831204">[27 more]</label></div><br/><div class="children"><div class="content">In general, verifying programs is extremely hard, not just because of rice&#x27;s theorem but because it&#x27;s so easy to miss a spot, especially for non-trivial bytecode languages like lua&#x27;s. wasm has no concepts of for loops for example.<p>It&#x27;s strange that after upstream has given up on the problem as it was too hard, factorio devs have chosen to try to fix the verifier&#x2F;write their own (not sure which of the two they did).<p>Minetest&#x27;s loadstring function forbids bytecode entirely: <a href="https:&#x2F;&#x2F;github.com&#x2F;minetest&#x2F;minetest&#x2F;blob&#x2F;9a1501ae89ffe79c38dbd6756c9e7ed647dd7dc1&#x2F;src&#x2F;script&#x2F;cpp_api&#x2F;s_security.cpp#L431">https:&#x2F;&#x2F;github.com&#x2F;minetest&#x2F;minetest&#x2F;blob&#x2F;9a1501ae89ffe79c38...</a><p>I wonder why factorio mods need the ability to execute raw lua bytecode. If they don&#x27;t have it, there would be no need for a verifier.<p>It&#x27;s quite dangerous in the first place to execute lua code downloaded over the network. JS execution environments have gone through decades of cycles of discoveries of exploits and fixes. Lua gets those as well but on a smaller scale, and with less staffing to improve security. The main protection is I guess that there is fewer people running malicious game servers.</div><br/><div id="40831515" class="c"><input type="checkbox" id="c-40831515" checked=""/><div class="controls bullet"><span class="by">Therenas</span><span>|</span><a href="#40831204">parent</a><span>|</span><a href="#40831800">next</a><span>|</span><label class="collapse" for="c-40831515">[-]</label><label class="expand" for="c-40831515">[12 more]</label></div><br/><div class="children"><div class="content">Factorio disabled bytecode loading in response to this. Bytecode did allow for some cool stuff like writing mods in a preprocessor language that spits out Lua bytecode, but ultimately the security issues were more important to address.<p>Almost all of the debug library was made unavailable to mods as well, for similar security reasons.</div><br/><div id="40832493" class="c"><input type="checkbox" id="c-40832493" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831515">parent</a><span>|</span><a href="#40831533">next</a><span>|</span><label class="collapse" for="c-40832493">[-]</label><label class="expand" for="c-40832493">[2 more]</label></div><br/><div class="children"><div class="content">Loading raw bytecode is known to be unsafe, and iirc that is mentioned in lua_load&#x2F;luaL_load* documentation.<p>A preprocessor could spit out Lua code with the same effect and less complexity. Really interesting why and how these decision were made.</div><br/><div id="40833035" class="c"><input type="checkbox" id="c-40833035" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40832493">parent</a><span>|</span><a href="#40831533">next</a><span>|</span><label class="collapse" for="c-40833035">[-]</label><label class="expand" for="c-40833035">[1 more]</label></div><br/><div class="children"><div class="content">For what it’s worth, Metalua also generated PUC-Lua bytecode directly instead of source code, making it incompatible with LuaJIT (which might have been part of the reason why it died).</div><br/></div></div></div></div><div id="40831533" class="c"><input type="checkbox" id="c-40831533" checked=""/><div class="controls bullet"><span class="by">gjsman-1000</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831515">parent</a><span>|</span><a href="#40832493">prev</a><span>|</span><a href="#40831800">next</a><span>|</span><label class="collapse" for="c-40831533">[-]</label><label class="expand" for="c-40831533">[9 more]</label></div><br/><div class="children"><div class="content">Citation?<p>Factorio 1.1.101 (which the blog post says included the fix) does not list any changes regarding the disabling of bytecode or restricting the debug library. This would have been notable news, even without admitting the security risk. Factorio 1.1.107 does mention disabling the debug library, but it doesn’t seem this article had anything to do with that.</div><br/><div id="40831574" class="c"><input type="checkbox" id="c-40831574" checked=""/><div class="controls bullet"><span class="by">Therenas</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831533">parent</a><span>|</span><a href="#40831800">next</a><span>|</span><label class="collapse" for="c-40831574">[-]</label><label class="expand" for="c-40831574">[8 more]</label></div><br/><div class="children"><div class="content">I work on the game. The debug library was disabled for other security holes that were brought to our attention, so it wouldn‘t be related to this, but I thought it was interesting to mention.<p>I believe the change was not mentioned in the changelog as an attempt at &#x27;security through obscurity&#x27;, trying to avoid people getting any ideas before the update is wide-spread. Not sure that helps any, but still.</div><br/><div id="40831974" class="c"><input type="checkbox" id="c-40831974" checked=""/><div class="controls bullet"><span class="by">deely3</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831574">parent</a><span>|</span><a href="#40831800">next</a><span>|</span><label class="collapse" for="c-40831974">[-]</label><label class="expand" for="c-40831974">[7 more]</label></div><br/><div class="children"><div class="content">Sorry, but thats just a perfect example why &#x27;security through obscurity&#x27; is wrong. I have zero idea about security risks, but if fix does not mentioned anywhere, then for people that use previous version there no rush to upgrade.</div><br/><div id="40832275" class="c"><input type="checkbox" id="c-40832275" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831974">parent</a><span>|</span><a href="#40831995">next</a><span>|</span><label class="collapse" for="c-40832275">[-]</label><label class="expand" for="c-40832275">[4 more]</label></div><br/><div class="children"><div class="content">&gt; no rush to upgrade<p>I suspect the overwhelming majority of Factorio players are using Steam, which auto updates.</div><br/><div id="40833039" class="c"><input type="checkbox" id="c-40833039" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40832275">parent</a><span>|</span><a href="#40832656">next</a><span>|</span><label class="collapse" for="c-40833039">[-]</label><label class="expand" for="c-40833039">[2 more]</label></div><br/><div class="children"><div class="content">Due to the need for perfect synchronization all users need to be using the exact same version. Mods can also break between versions. It is therefore very common for public servers to stick on one version for extended periods of time. It is common for people to use the Steam &quot;betas&quot; functionality to pick an exact version or download an exact version from the Factorio website.<p>I would say that servers only tend to update when large features are released. So announcing a security vulnerability would likely push some servers to update.</div><br/><div id="40835004" class="c"><input type="checkbox" id="c-40835004" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40833039">parent</a><span>|</span><a href="#40832656">next</a><span>|</span><label class="collapse" for="c-40835004">[-]</label><label class="expand" for="c-40835004">[1 more]</label></div><br/><div class="children"><div class="content">Without metrics of some kind from Wube I guess we aren&#x27;t likely to know for sure, but I doubt very much it is common to run old versions of the game on Steam. I bet you that most people are simply running on the latest version at all times. That solves the MP issue, and plenty of mods don&#x27;t need to be updated for each game version.</div><br/></div></div></div></div><div id="40832656" class="c"><input type="checkbox" id="c-40832656" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40832275">parent</a><span>|</span><a href="#40833039">prev</a><span>|</span><a href="#40831995">next</a><span>|</span><label class="collapse" for="c-40832656">[-]</label><label class="expand" for="c-40832656">[1 more]</label></div><br/><div class="children"><div class="content">Factorio is special though, because it actively uses the beta version functionality in Steam to not only provide betas but also older stable versions. This allows the devs to move fast and break things.<p>I know I&#x27;ve held back my copy of Factorio due to some concern over changes in newer versions, preferring to letting the dust settle before upgrading to the latest stable version.</div><br/></div></div></div></div><div id="40831995" class="c"><input type="checkbox" id="c-40831995" checked=""/><div class="controls bullet"><span class="by">Therenas</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831974">parent</a><span>|</span><a href="#40832275">prev</a><span>|</span><a href="#40831800">next</a><span>|</span><label class="collapse" for="c-40831995">[-]</label><label class="expand" for="c-40831995">[2 more]</label></div><br/><div class="children"><div class="content">I don‘t disagree.</div><br/><div id="40832158" class="c"><input type="checkbox" id="c-40832158" checked=""/><div class="controls bullet"><span class="by">ethbr1</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831995">parent</a><span>|</span><a href="#40831800">next</a><span>|</span><label class="collapse" for="c-40832158">[-]</label><label class="expand" for="c-40832158">[1 more]</label></div><br/><div class="children"><div class="content">Arguments either way. Generic &quot;security vulnerabilities addressed&quot; in release notes is a nice balance.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40831800" class="c"><input type="checkbox" id="c-40831800" checked=""/><div class="controls bullet"><span class="by">JustAPerson</span><span>|</span><a href="#40831204">parent</a><span>|</span><a href="#40831515">prev</a><span>|</span><a href="#40831275">next</a><span>|</span><label class="collapse" for="c-40831800">[-]</label><label class="expand" for="c-40831800">[2 more]</label></div><br/><div class="children"><div class="content">Eventually every game developer learns the hard way that they must remove the bytecode ability from lua&#x27;s loadstring() function.<p>E.g. here&#x27;s a 12 year old blogpost on the topic from the ROBLOX developers: <a href="https:&#x2F;&#x2F;archive.is&#x2F;oXPyM" rel="nofollow">https:&#x2F;&#x2F;archive.is&#x2F;oXPyM</a><p>To be honest, it would probably be better off disabled by default. Its legitimate uses are pretty niche.</div><br/><div id="40832513" class="c"><input type="checkbox" id="c-40832513" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831800">parent</a><span>|</span><a href="#40831275">next</a><span>|</span><label class="collapse" for="c-40832513">[-]</label><label class="expand" for="c-40832513">[1 more]</label></div><br/><div class="children"><div class="content">Yep, its place is in luaconf.h really.</div><br/></div></div></div></div><div id="40831275" class="c"><input type="checkbox" id="c-40831275" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40831204">parent</a><span>|</span><a href="#40831800">prev</a><span>|</span><a href="#40832169">next</a><span>|</span><label class="collapse" for="c-40831275">[-]</label><label class="expand" for="c-40831275">[8 more]</label></div><br/><div class="children"><div class="content">Factorio has stuff like this:<p><a href="https:&#x2F;&#x2F;mods.factorio.com&#x2F;mod&#x2F;Moon_Logic" rel="nofollow">https:&#x2F;&#x2F;mods.factorio.com&#x2F;mod&#x2F;Moon_Logic</a><p>Besides, it&#x27;s quite limiting to create software that can&#x27;t just execute in a Turing complete environment.<p>Anyway, we really need interpreters that include a strong capability system.</div><br/><div id="40831363" class="c"><input type="checkbox" id="c-40831363" checked=""/><div class="controls bullet"><span class="by">dividuum</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831275">parent</a><span>|</span><a href="#40831339">next</a><span>|</span><label class="collapse" for="c-40831363">[-]</label><label class="expand" for="c-40831363">[1 more]</label></div><br/><div class="children"><div class="content">OP only refers to bytecode. There&#x27;s nothing wrong with executing Lua when provided to the VM via source code. The only reason to allow the VM to load bytecode directly is 1) a very minor improvement in loading time, as the interpreter then doesn&#x27;t have to parse Lua code into bytecode itself 2) allowing obfuscation of logic running within Factorio. Both seem rather irrelevant, so I&#x27;m not sure why they allow loading bytecode directly.</div><br/></div></div><div id="40831339" class="c"><input type="checkbox" id="c-40831339" checked=""/><div class="controls bullet"><span class="by">gjsman-1000</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831275">parent</a><span>|</span><a href="#40831363">prev</a><span>|</span><a href="#40832169">next</a><span>|</span><label class="collapse" for="c-40831339">[-]</label><label class="expand" for="c-40831339">[6 more]</label></div><br/><div class="children"><div class="content">“If I ran the business” (TM), I would just put it in Factorio settings as a toggle switch called “Reduced Security Mode - Allow Lua Bytecode.” By default, it’s turned off. People who really want those mods can turn it on, as long as they are informed (UAC prompt style) that they better trust the mod authors. I’d also add an API for mod authors to detect if bytecode access is enabled; so they can make their mods compatible with either environment.<p>Or maybe, down the road, Factorio could enable mods with greater privileges, as long as they are open source, and do an App Store-style review process with the community. Approved mods get not just bytecode, but perhaps even some of the typically forbidden modules like filesystem access. Unapproved mods using those enhanced privileges won’t run without a startup flag.</div><br/><div id="40831621" class="c"><input type="checkbox" id="c-40831621" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831339">parent</a><span>|</span><a href="#40832169">next</a><span>|</span><label class="collapse" for="c-40831621">[-]</label><label class="expand" for="c-40831621">[5 more]</label></div><br/><div class="children"><div class="content">&gt; By default, it’s turned off. People who really want those mods can turn it on<p>This works until a popular mod requires it (for legit reasons) then enabling the option becomes the de-facto standard for people who install mods.</div><br/><div id="40834958" class="c"><input type="checkbox" id="c-40834958" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831621">parent</a><span>|</span><a href="#40832005">next</a><span>|</span><label class="collapse" for="c-40834958">[-]</label><label class="expand" for="c-40834958">[1 more]</label></div><br/><div class="children"><div class="content">I see no problem. It&#x27;s those people&#x27;s choice to do so, and they accept the risk.</div><br/></div></div><div id="40832005" class="c"><input type="checkbox" id="c-40832005" checked=""/><div class="controls bullet"><span class="by">grogenaut</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40831621">parent</a><span>|</span><a href="#40834958">prev</a><span>|</span><a href="#40832169">next</a><span>|</span><label class="collapse" for="c-40832005">[-]</label><label class="expand" for="c-40832005">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible to make it so you enable it on a per mod basis, like app permissions</div><br/><div id="40832805" class="c"><input type="checkbox" id="c-40832805" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40832005">parent</a><span>|</span><a href="#40833311">next</a><span>|</span><label class="collapse" for="c-40832805">[-]</label><label class="expand" for="c-40832805">[1 more]</label></div><br/><div class="children"><div class="content">Because that&#x27;s never ever been a total usability disaster that just encourages people to enable every one because they don&#x27;t feel like fighting it. It&#x27;s also not effective, given how tightly tied mods are to the core API.</div><br/></div></div><div id="40833311" class="c"><input type="checkbox" id="c-40833311" checked=""/><div class="controls bullet"><span class="by">vsuperpower2020</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40832005">parent</a><span>|</span><a href="#40832805">prev</a><span>|</span><a href="#40832169">next</a><span>|</span><label class="collapse" for="c-40833311">[-]</label><label class="expand" for="c-40833311">[1 more]</label></div><br/><div class="children"><div class="content">When you&#x27;re talking about security, adding a bunch of config flags for users is never a good idea. Most users aren&#x27;t going to understand what it does, and like others mentioned, there&#x27;s too many reasons to turn it on.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40832169" class="c"><input type="checkbox" id="c-40832169" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40831204">parent</a><span>|</span><a href="#40831275">prev</a><span>|</span><a href="#40835256">next</a><span>|</span><label class="collapse" for="c-40832169">[-]</label><label class="expand" for="c-40832169">[2 more]</label></div><br/><div class="children"><div class="content">&gt; not just because of rice&#x27;s theorem<p>I don&#x27;t think Rice is relevant at all. I guess Rice is a useful first screen. Do you believe you can &quot;just&quot; Decide this correctly? If so, Henry Rice got his PhD half a century ago for proving you can&#x27;t do that, stop.<p>But assuming you&#x27;ve made your peace with accepting only a <i>subset</i> of the inputs that would actually meet your requirements, Rice is done. And you&#x27;re right - now instead of an impossible task you&#x27;ve just got an <i>extremely hard</i> task. This means when you fail (which you will) at least nobody will tell you it was impossible, if that helps?<p>Factorio should not have done this.</div><br/><div id="40833263" class="c"><input type="checkbox" id="c-40833263" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40831204">root</a><span>|</span><a href="#40832169">parent</a><span>|</span><a href="#40835256">next</a><span>|</span><label class="collapse" for="c-40833263">[-]</label><label class="expand" for="c-40833263">[1 more]</label></div><br/><div class="children"><div class="content">This idea of accepting some kind of subset is exactly what JVM does. There is a set of rules (IIRC 29 of them) that the JVM bytecode have to follow to be accepted, the one important rule is “stack entries should always be used as a same type”, the rest of the rules are there so that this can be statically checked.</div><br/></div></div></div></div><div id="40835256" class="c"><input type="checkbox" id="c-40835256" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#40831204">parent</a><span>|</span><a href="#40832169">prev</a><span>|</span><a href="#40833832">next</a><span>|</span><label class="collapse" for="c-40835256">[-]</label><label class="expand" for="c-40835256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In general, verifying programs is extremely hard, not just because of rice&#x27;s theorem but because it&#x27;s so easy to miss a spot, especially for non-trivial bytecode languages like lua&#x27;s.<p>Perhaps a dumb question then. Java has famously had a bytecode verifier for decades. Is it the case that:<p>a) bytecode verification is fundamentally easier in statically typed languages<p>or<p>b) it&#x27;s just as hard for Java, but Java has had decades to work on it and it&#x27;s still taken a long time to fix all the bugs&#x2F;security issues.</div><br/></div></div><div id="40833832" class="c"><input type="checkbox" id="c-40833832" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40831204">parent</a><span>|</span><a href="#40835256">prev</a><span>|</span><a href="#40831535">next</a><span>|</span><label class="collapse" for="c-40833832">[-]</label><label class="expand" for="c-40833832">[1 more]</label></div><br/><div class="children"><div class="content">&gt; rice&#x27;s theorem<p>That doesn&#x27;t apply here.  By the broad definition of &quot;syntax&quot; that Rice&#x27;s theorem takes, the things you want to verify on the bytecode are syntax.</div><br/></div></div></div></div><div id="40831535" class="c"><input type="checkbox" id="c-40831535" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#40831204">prev</a><span>|</span><a href="#40833209">next</a><span>|</span><label class="collapse" for="c-40831535">[-]</label><label class="expand" for="c-40831535">[7 more]</label></div><br/><div class="children"><div class="content">Factorio has a really good dev team behind it so I trust that they&#x27;re doing their best to fix these issues. Though, gamedev in general seems to be more of a creative endeavor which puts things like code practices and security on the back burner. I wonder how many zero day exploits are lurking in game clients &#x2F; servers.</div><br/><div id="40833062" class="c"><input type="checkbox" id="c-40833062" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#40831535">parent</a><span>|</span><a href="#40833322">next</a><span>|</span><label class="collapse" for="c-40833062">[-]</label><label class="expand" for="c-40833062">[1 more]</label></div><br/><div class="children"><div class="content">Yup. Intend to assume that any game with remote interaction is completely insecure. It is best to run Steam and all games in some sort of sandbox.<p>Flatpak is probably a helpful start. While containers aren&#x27;t a strong security boundary at least simple exploits won&#x27;t work.</div><br/></div></div><div id="40833322" class="c"><input type="checkbox" id="c-40833322" checked=""/><div class="controls bullet"><span class="by">vsuperpower2020</span><span>|</span><a href="#40831535">parent</a><span>|</span><a href="#40833062">prev</a><span>|</span><a href="#40832029">next</a><span>|</span><label class="collapse" for="c-40833322">[-]</label><label class="expand" for="c-40833322">[2 more]</label></div><br/><div class="children"><div class="content">Code practices? Factorio is one of the most well programmed, stable, and consistent piece of software I&#x27;ve ever seen. It&#x27;s almost a shame to see skilled people work in games because of how desperately other fields need people who are good at programming.</div><br/><div id="40833408" class="c"><input type="checkbox" id="c-40833408" checked=""/><div class="controls bullet"><span class="by">hypeatei</span><span>|</span><a href="#40831535">root</a><span>|</span><a href="#40833322">parent</a><span>|</span><a href="#40832029">next</a><span>|</span><label class="collapse" for="c-40833408">[-]</label><label class="expand" for="c-40833408">[1 more]</label></div><br/><div class="children"><div class="content">See my comment:
&gt; Factorio has a really good dev team<p>I wasn&#x27;t talking about the Factorio devs specifically but about the gamedev industry as a whole.</div><br/></div></div></div></div><div id="40832029" class="c"><input type="checkbox" id="c-40832029" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#40831535">parent</a><span>|</span><a href="#40833322">prev</a><span>|</span><a href="#40831571">next</a><span>|</span><label class="collapse" for="c-40832029">[-]</label><label class="expand" for="c-40832029">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, best to keep a separate computer for gaming for this reason. Definitely don’t put important documents or work stuff on it. It would be ideal to isolate it in a VM, but setting up a gaming VM can be a massive pain in the ass and exclude you from some games that use anticheat.</div><br/></div></div><div id="40831571" class="c"><input type="checkbox" id="c-40831571" checked=""/><div class="controls bullet"><span class="by">gjsman-1000</span><span>|</span><a href="#40831535">parent</a><span>|</span><a href="#40832029">prev</a><span>|</span><a href="#40833209">next</a><span>|</span><label class="collapse" for="c-40831571">[-]</label><label class="expand" for="c-40831571">[2 more]</label></div><br/><div class="children"><div class="content">Most likely, it’s not very good. Why do you think every console manufacturer, from Xbox to Sony to Nintendo, does not allow connecting to arbitrary server IP addresses or modding support?<p>It’s not merely a business decision (like some believe) to force people to use official Online services. Think about it: Restricting connecting to third-party server IPs means that any bugs in the network code, or in the rest of the game, even atrocious ones, will never be exploited. Restricting mods (even “safe” mods like Lua) further prevents exploits. This makes sense - buggy network code has tanked multiple consoles’s DRM historically.<p>And not just exploits - these consoles pride themselves on doing their review process before the code becomes available (despite oversights). Allowing executing of Lua, from a remote system, basically means a game could be reconfigured remotely after approval potentially from the developer themselves - not something any console manufacturer wants to permit without very close inspection.</div><br/><div id="40834327" class="c"><input type="checkbox" id="c-40834327" checked=""/><div class="controls bullet"><span class="by">tiagod</span><span>|</span><a href="#40831535">root</a><span>|</span><a href="#40831571">parent</a><span>|</span><a href="#40833209">next</a><span>|</span><label class="collapse" for="c-40834327">[-]</label><label class="expand" for="c-40834327">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t own any newer console, but I remember people abusing the P2P nature of PS3 Call of Duty MW2 to make ridiculous custom servers that you would randomly connect to. So at least on the Playstation 3, games would connect to arbitrary IPs. Maybe this has changed in the PS4 and PS5, probably for this reason.</div><br/></div></div></div></div></div></div><div id="40833209" class="c"><input type="checkbox" id="c-40833209" checked=""/><div class="controls bullet"><span class="by">bhk</span><span>|</span><a href="#40831535">prev</a><span>|</span><a href="#40831510">next</a><span>|</span><label class="collapse" for="c-40833209">[-]</label><label class="expand" for="c-40833209">[5 more]</label></div><br/><div class="children"><div class="content">So... this demonstrates an exploit that relies on a feature that is advertised as exploitable: loading byte code.  What am I missing?</div><br/><div id="40833415" class="c"><input type="checkbox" id="c-40833415" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#40833209">parent</a><span>|</span><a href="#40833350">next</a><span>|</span><label class="collapse" for="c-40833415">[-]</label><label class="expand" for="c-40833415">[2 more]</label></div><br/><div class="children"><div class="content">The interesting takeaway I got was how badly the Lua developers failed on their bytecode veryfier. Not some complex issues, but simple ones like of by one errors when modelling basic instructions like jmp or the issue that the Lua interpreter would try to interpret anything it got its hands on as instructions, even data sections the veryfier would not touch.</div><br/><div id="40833861" class="c"><input type="checkbox" id="c-40833861" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40833209">root</a><span>|</span><a href="#40833415">parent</a><span>|</span><a href="#40833350">next</a><span>|</span><label class="collapse" for="c-40833861">[-]</label><label class="expand" for="c-40833861">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The interesting takeaway I got was how badly the Lua developers failed on their bytecode veryfier.<p>What verifier?  The one they removed?<p>Or are you talking about the one the <i>Factorio</i> developers made, where flaws are a lot less surprising considering they have a lot less expertise with the internal machinery of Lua.</div><br/></div></div></div></div><div id="40833350" class="c"><input type="checkbox" id="c-40833350" checked=""/><div class="controls bullet"><span class="by">tsujamin</span><span>|</span><a href="#40833209">parent</a><span>|</span><a href="#40833415">prev</a><span>|</span><a href="#40833395">next</a><span>|</span><label class="collapse" for="c-40833350">[-]</label><label class="expand" for="c-40833350">[1 more]</label></div><br/><div class="children"><div class="content">That advertised features can still cause harm to end users, particularly those who don’t know what Lua or bytecode are?</div><br/></div></div><div id="40833395" class="c"><input type="checkbox" id="c-40833395" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#40833209">parent</a><span>|</span><a href="#40833350">prev</a><span>|</span><a href="#40831510">next</a><span>|</span><label class="collapse" for="c-40833395">[-]</label><label class="expand" for="c-40833395">[1 more]</label></div><br/><div class="children"><div class="content">It’s possible that the bytecode interpreter has a bug that lets one run arbitrary bytecode, even in environments where `loadstring` is disabled.</div><br/></div></div></div></div><div id="40831510" class="c"><input type="checkbox" id="c-40831510" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#40833209">prev</a><span>|</span><a href="#40832767">next</a><span>|</span><label class="collapse" for="c-40831510">[-]</label><label class="expand" for="c-40831510">[1 more]</label></div><br/><div class="children"><div class="content">IMO, Lua bytecode should never be usable anywhere outside of embedded systems that don&#x27;t have enough resources to run the Lua source code parser. Besides security vulnerabilities, the only other thing it seems to be useful for is closed-source programs.</div><br/></div></div><div id="40832767" class="c"><input type="checkbox" id="c-40832767" checked=""/><div class="controls bullet"><span class="by">davikr</span><span>|</span><a href="#40831510">prev</a><span>|</span><a href="#40832014">next</a><span>|</span><label class="collapse" for="c-40832767">[-]</label><label class="expand" for="c-40832767">[2 more]</label></div><br/><div class="children"><div class="content">Never enable in your Lua apps:<p>a. Bytecode<p>b. Debug, Io, Os libraries<p>...<p>Also, be very careful with sandboxing. It can be deceptively easy to break out of.<p>Everyone eventually learns this lesson, see: Roblox (removed bytecode almost a decade ago after, if I recall correctly, an exploit exfiltrated their server tokens), Company of Heroes (bytecode bug leading to RCE)<p>Luau should come with safe defaults, from what I&#x27;ve been told.</div><br/><div id="40832890" class="c"><input type="checkbox" id="c-40832890" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40832767">parent</a><span>|</span><a href="#40832014">next</a><span>|</span><label class="collapse" for="c-40832890">[-]</label><label class="expand" for="c-40832890">[1 more]</label></div><br/><div class="children"><div class="content">Yup. I&#x27;m the one who did the Roblox bytecode exploit that lead to it being disabled: the specific attack there was that getmetatable internally leaves the metatable value on the Lua value stack even if it ends up returning the __metatable locked message, which you could retrieve with a crafted bytecode chunk. I leveraged that into getting the metatable for the global environment, which was the entire Lua standard library, and crucially the <i>same</i> table across Roblox&#x27;s script permission levels. Roblox used &quot;context levels&quot; for seperating priviledge Lua scripts, which interacted with the server API endpoints, and normal game logic. By poisoning the priviledge context&#x27;s metatatable with my own functions I was able to capture the server endpoint URLs and accesskey, along with things like send arbitrary HTTP requests to their CDN from the server to steal any place file. This easily could have been arbitrary RCE on their servers instead: the crafted bytecode chunk attack for getting a r&#x2F;w primitive from for loops was published a little bit before this attack happened, IIRC, but there was a lot of less CTF style writeups about Lua internals and I was, like, 15 and an idiot.<p>In practice it&#x27;s really hard to sandbox arbitrary user controlled scripts. Even after this I found a half dozen other bugs in their Lua&lt;-&gt;C++ bindings that you could leverage into server code execution. V8 and other browser engines still having JIT bugs and DOM manipulation exploits every other week should terrify any developer who thinks &quot;oh I&#x27;ll let my users do a bit of scripting&quot;.</div><br/></div></div></div></div><div id="40832014" class="c"><input type="checkbox" id="c-40832014" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#40832767">prev</a><span>|</span><a href="#40831289">next</a><span>|</span><label class="collapse" for="c-40832014">[-]</label><label class="expand" for="c-40832014">[1 more]</label></div><br/><div class="children"><div class="content">We are seriously lucky such capable people are on the good side.</div><br/></div></div><div id="40833386" class="c"><input type="checkbox" id="c-40833386" checked=""/><div class="controls bullet"><span class="by">quenix</span><span>|</span><a href="#40831289">prev</a><span>|</span><a href="#40831971">next</a><span>|</span><label class="collapse" for="c-40833386">[-]</label><label class="expand" for="c-40833386">[6 more]</label></div><br/><div class="children"><div class="content">I’m confused about one thing.<p>It doesn’t follow to me, that since all clients are running their own simulation, Lua scripts must run on every client too.<p>If a client runs a Lua script, why can’t we just run it on their machine and propagate any game state changes (if the script adds an inserted, for example,) as if the player made those changes themselves?</div><br/><div id="40833500" class="c"><input type="checkbox" id="c-40833500" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#40833386">parent</a><span>|</span><a href="#40833402">next</a><span>|</span><label class="collapse" for="c-40833500">[-]</label><label class="expand" for="c-40833500">[2 more]</label></div><br/><div class="children"><div class="content">The mechanism Factorio uses is to sync user inputs, not game state changes (the reason isn’t explained, but I strongly suspect it’s because user inputs are less data; small inputs can cause big game state changes, but not vice versa).<p>If the user types a command, in order to preserve synchronization, the game must:<p>- Run the command on all other clients.<p>- OR it could sync changes made to the game for just commands; in other words, the other clients apply the changes caused by the command instead of running the command directly. But that would be an unreasonable amount of extra work just for a small feature and to make exploits harder.<p>- OR the server simply disallows clients from running Lua commands, which is the case for some servers.<p>I don’t get the second part though: why a map can store arbitrary Lua code that runs when the map loads.</div><br/><div id="40833649" class="c"><input type="checkbox" id="c-40833649" checked=""/><div class="controls bullet"><span class="by">BlueTemplar</span><span>|</span><a href="#40833386">root</a><span>|</span><a href="#40833500">parent</a><span>|</span><a href="#40833402">next</a><span>|</span><label class="collapse" for="c-40833649">[-]</label><label class="expand" for="c-40833649">[1 more]</label></div><br/><div class="children"><div class="content">Scenarios that don&#x27;t require a mod ?<p>(Some time ago, Factorio did not have a built-in mod synchronization system for multiplayer, with the result that the most popular servers did not run any mods, but rather used complicated scenarios instead.)</div><br/></div></div></div></div><div id="40833402" class="c"><input type="checkbox" id="c-40833402" checked=""/><div class="controls bullet"><span class="by">nmeofthestate</span><span>|</span><a href="#40833386">parent</a><span>|</span><a href="#40833500">prev</a><span>|</span><a href="#40833472">next</a><span>|</span><label class="collapse" for="c-40833402">[-]</label><label class="expand" for="c-40833402">[1 more]</label></div><br/><div class="children"><div class="content">If clients don&#x27;t run the same code they will desync the moment their state diverges. I haven&#x27;t played multiplayer factorio but I expect you can&#x27;t even join a server unless you&#x27;re running the same factorio version and mods as other players.</div><br/></div></div><div id="40833472" class="c"><input type="checkbox" id="c-40833472" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#40833386">parent</a><span>|</span><a href="#40833402">prev</a><span>|</span><a href="#40833899">next</a><span>|</span><label class="collapse" for="c-40833472">[-]</label><label class="expand" for="c-40833472">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If a client runs a Lua script, why can’t we just run it on their machine and propagate any game state changes (if the script adds an inserted, for example,) as if the player made those changes themselves?<p>The game already has to run Lua scripts as part of the simulation, potentially as part of in-game events which aren&#x27;t directly triggered by players. A player running a script from the console is handled by that same interpreter -- making it run in a completely different operating mode where any changes to game state are replicated would be much more complicated and prone to error.<p>Or, from the other direction: the game&#x27;s multiplayer model is all based around a replicated simulation where player inputs are fed into the simulation. Treating a player running a script as a special kind of event involving the text of that script is the simplest and most obviously correct way to implement that.</div><br/></div></div><div id="40833899" class="c"><input type="checkbox" id="c-40833899" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40833386">parent</a><span>|</span><a href="#40833472">prev</a><span>|</span><a href="#40831971">next</a><span>|</span><label class="collapse" for="c-40833899">[-]</label><label class="expand" for="c-40833899">[1 more]</label></div><br/><div class="children"><div class="content">Running the scripts outside the simulation and syncing their commands alongside user input would definitely work on a technical level.<p>But I think you&#x27;re massively underestimating how much these scripts can do.  Many mods would flood the network connections.  And there would also be an awkward delay for all script actions.</div><br/></div></div></div></div><div id="40831971" class="c"><input type="checkbox" id="c-40831971" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#40833386">prev</a><span>|</span><a href="#40835515">next</a><span>|</span><label class="collapse" for="c-40831971">[-]</label><label class="expand" for="c-40831971">[2 more]</label></div><br/><div class="children"><div class="content">Is it impractical to employ firecracker vm like separation to isolate untrusted code, severely reducing the impact of any bugs?<p>Browsers split their various components across multiple processes to provide isolation. VMs would provide even more isolation.</div><br/><div id="40832382" class="c"><input type="checkbox" id="c-40832382" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#40831971">parent</a><span>|</span><a href="#40835515">next</a><span>|</span><label class="collapse" for="c-40832382">[-]</label><label class="expand" for="c-40832382">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what they do. They add additional layers on top of the sandbox like jailing. You can jail your sandboxes, but it&#x27;s not so easy to make that a multi-platform solution for gaming. I think for games I would just stick to a fast interpreter and apply some generally appropriate measures to discourage timing attacks.</div><br/></div></div></div></div><div id="40835515" class="c"><input type="checkbox" id="c-40835515" checked=""/><div class="controls bullet"><span class="by">nmz</span><span>|</span><a href="#40831971">prev</a><span>|</span><a href="#40831517">next</a><span>|</span><label class="collapse" for="c-40835515">[-]</label><label class="expand" for="c-40835515">[1 more]</label></div><br/><div class="children"><div class="content">bytecode is also architecture dependent</div><br/></div></div><div id="40831517" class="c"><input type="checkbox" id="c-40831517" checked=""/><div class="controls bullet"><span class="by">BeefySwain</span><span>|</span><a href="#40835515">prev</a><span>|</span><a href="#40832457">next</a><span>|</span><label class="collapse" for="c-40831517">[-]</label><label class="expand" for="c-40831517">[2 more]</label></div><br/><div class="children"><div class="content">Unless I missed it (I admit I skimmed towards the end) The author does not discuss at all the actual remediation that was taken. I would love to hear more about that.</div><br/><div id="40833496" class="c"><input type="checkbox" id="c-40833496" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#40831517">parent</a><span>|</span><a href="#40832457">next</a><span>|</span><label class="collapse" for="c-40833496">[-]</label><label class="expand" for="c-40833496">[1 more]</label></div><br/><div class="children"><div class="content">The remediation was:<p>1.1.104: <a href="https:&#x2F;&#x2F;github.com&#x2F;Rseding91&#x2F;Factorio-Lua&#x2F;commit&#x2F;4d924b698084e8fb7b2631239466d98acd3b37de">https:&#x2F;&#x2F;github.com&#x2F;Rseding91&#x2F;Factorio-Lua&#x2F;commit&#x2F;4d924b69808...</a><p>and<p>1.1.107: <a href="https:&#x2F;&#x2F;github.com&#x2F;Rseding91&#x2F;Factorio-Lua&#x2F;commit&#x2F;ce12474c7fcee694bde1aa0f668dce488aca0806">https:&#x2F;&#x2F;github.com&#x2F;Rseding91&#x2F;Factorio-Lua&#x2F;commit&#x2F;ce12474c7fc...</a><p>The most relevant part was the change to luaB_load in 1.1.104 which simply disabled bytecode loading.</div><br/></div></div></div></div><div id="40832457" class="c"><input type="checkbox" id="c-40832457" checked=""/><div class="controls bullet"><span class="by">therobots927</span><span>|</span><a href="#40831517">prev</a><span>|</span><a href="#40832121">next</a><span>|</span><label class="collapse" for="c-40832457">[-]</label><label class="expand" for="c-40832457">[5 more]</label></div><br/><div class="children"><div class="content">I literally just downloaded a factorial demo to my work laptop. Is this something I need to be concerned about if I don’t play online?</div><br/><div id="40833261" class="c"><input type="checkbox" id="c-40833261" checked=""/><div class="controls bullet"><span class="by">vessenes</span><span>|</span><a href="#40832457">parent</a><span>|</span><a href="#40832495">next</a><span>|</span><label class="collapse" for="c-40833261">[-]</label><label class="expand" for="c-40833261">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but only because you might lose your job from playing too much factorio. :) the exploit was not a risk for vanilla unmodded single players, and has been patched in any event.</div><br/><div id="40833518" class="c"><input type="checkbox" id="c-40833518" checked=""/><div class="controls bullet"><span class="by">therobots927</span><span>|</span><a href="#40832457">root</a><span>|</span><a href="#40833261">parent</a><span>|</span><a href="#40832495">next</a><span>|</span><label class="collapse" for="c-40833518">[-]</label><label class="expand" for="c-40833518">[1 more]</label></div><br/><div class="children"><div class="content">Awesome! Yeah we’ll see I may not be able to start playing until I get moved to a boring &#x2F; less intensive project. I started playing and it felt identical to my day job which is why I wanted to try it but after a day of coding I just wasn’t up for it haha</div><br/></div></div></div></div><div id="40832495" class="c"><input type="checkbox" id="c-40832495" checked=""/><div class="controls bullet"><span class="by">IggleSniggle</span><span>|</span><a href="#40832457">parent</a><span>|</span><a href="#40833261">prev</a><span>|</span><a href="#40832121">next</a><span>|</span><label class="collapse" for="c-40832495">[-]</label><label class="expand" for="c-40832495">[2 more]</label></div><br/><div class="children"><div class="content">No.</div><br/><div id="40832584" class="c"><input type="checkbox" id="c-40832584" checked=""/><div class="controls bullet"><span class="by">therobots927</span><span>|</span><a href="#40832457">root</a><span>|</span><a href="#40832495">parent</a><span>|</span><a href="#40832121">next</a><span>|</span><label class="collapse" for="c-40832584">[-]</label><label class="expand" for="c-40832584">[1 more]</label></div><br/><div class="children"><div class="content">Thanks</div><br/></div></div></div></div></div></div><div id="40832121" class="c"><input type="checkbox" id="c-40832121" checked=""/><div class="controls bullet"><span class="by">bbor</span><span>|</span><a href="#40832457">prev</a><span>|</span><a href="#40831751">next</a><span>|</span><label class="collapse" for="c-40832121">[-]</label><label class="expand" for="c-40832121">[2 more]</label></div><br/><div class="children"><div class="content">As a non-security dev, I&#x27;ll drop the obligatory &quot;wow this is incredibly impressive!&quot; I can&#x27;t believe how clear and logically you&#x27;d have to think to track down these intricate failure cases. Definitely not my strong suit! I&#x27;m much more of an &quot;ideas guy&quot; ;)<p>Content-wise: Wow... We are totally, completely, utterly screwed once people start putting together ensembles of AI SWEs equipped with 10,000 blog posts like this one on finding weird memory exploits. Ultimately I think we&#x27;re gonna need a whole new paradigm for security, or at least some new element in the stack. It&#x27;s my potentially naive opinion that all the modern talk about &quot;trusted&quot; clients and DB roles and all that is trying to patch holes in swiss cheese; hopefully, we can find a new stack of LLM-maintained swiss cheese to add on instead!</div><br/><div id="40833828" class="c"><input type="checkbox" id="c-40833828" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40832121">parent</a><span>|</span><a href="#40831751">next</a><span>|</span><label class="collapse" for="c-40833828">[-]</label><label class="expand" for="c-40833828">[1 more]</label></div><br/><div class="children"><div class="content">People are doing it. The results have yet to be promising.</div><br/></div></div></div></div><div id="40831142" class="c"><input type="checkbox" id="c-40831142" checked=""/><div class="controls bullet"><span class="by">gjsman-1000</span><span>|</span><a href="#40833809">prev</a><span>|</span><label class="collapse" for="c-40831142">[-]</label><label class="expand" for="c-40831142">[14 more]</label></div><br/><div class="children"><div class="content">At this point, I have serious doubts whether bytecode and JIT systems, whether it be Lua in Factorio or JavaScript in Chrome, can ever be verifiably secure. I think we would all be better off if, like Apple’s Lockdown mode, we can disable anything JIT on a high stakes system.<p>I don’t blame Factorio though - this (anonymous?) researcher is 100x developer material.</div><br/><div id="40831211" class="c"><input type="checkbox" id="c-40831211" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40831142">parent</a><span>|</span><a href="#40832101">next</a><span>|</span><label class="collapse" for="c-40831211">[-]</label><label class="expand" for="c-40831211">[8 more]</label></div><br/><div class="children"><div class="content">How is JIT relevant here? Unless I missed something, the attack uses straight-up malicious byte code, it doesn&#x27;t exploit the JIT compiler.</div><br/><div id="40831252" class="c"><input type="checkbox" id="c-40831252" checked=""/><div class="controls bullet"><span class="by">gjsman-1000</span><span>|</span><a href="#40831142">root</a><span>|</span><a href="#40831211">parent</a><span>|</span><a href="#40832101">next</a><span>|</span><label class="collapse" for="c-40831252">[-]</label><label class="expand" for="c-40831252">[7 more]</label></div><br/><div class="children"><div class="content">JIT and Bytecode are two sides of the same coin, in my head. JIT also uses bytecode in some languages like Java.</div><br/><div id="40831814" class="c"><input type="checkbox" id="c-40831814" checked=""/><div class="controls bullet"><span class="by">nanidin</span><span>|</span><a href="#40831142">root</a><span>|</span><a href="#40831252">parent</a><span>|</span><a href="#40831936">next</a><span>|</span><label class="collapse" for="c-40831814">[-]</label><label class="expand" for="c-40831814">[3 more]</label></div><br/><div class="children"><div class="content">In this case someone generated malicious bytecode that the JIT compiler would not generate.<p>I would argue JIT is dangerous because it requires dynamic memory without the NX bit set, so if you manage to smash the stack (find an exploit) you can execute arbitrary code easily (leverage the exploit). That&#x27;s a different dangerous than running malicious bytecode.</div><br/><div id="40832874" class="c"><input type="checkbox" id="c-40832874" checked=""/><div class="controls bullet"><span class="by">axoltl</span><span>|</span><a href="#40831142">root</a><span>|</span><a href="#40831814">parent</a><span>|</span><a href="#40832451">next</a><span>|</span><label class="collapse" for="c-40832874">[-]</label><label class="expand" for="c-40832874">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t generally apply but Apple has a bunch of hardening in place that means you don&#x27;t just have an RWX mapping hanging around:<p><a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;browserenginekit&#x2F;protecting-code-compiled-just-in-time" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;browserenginekit&#x2F;p...</a><p>On top of that they&#x27;re working on (I haven&#x27;t checked in a bit) having the JIT compiler be entirely Out-Of-Process. I don&#x27;t think a lot has been written about that publicly but there&#x27;s a few breadcrumbs like <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;kernel&#x2F;oop_jit_conversion" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;kernel&#x2F;oop_jit_con...</a></div><br/></div></div><div id="40832451" class="c"><input type="checkbox" id="c-40832451" checked=""/><div class="controls bullet"><span class="by">colejohnson66</span><span>|</span><a href="#40831142">root</a><span>|</span><a href="#40831814">parent</a><span>|</span><a href="#40832874">prev</a><span>|</span><a href="#40831936">next</a><span>|</span><label class="collapse" for="c-40832451">[-]</label><label class="expand" for="c-40832451">[1 more]</label></div><br/><div class="children"><div class="content">JITs can still function with an NX bit; You just have to halt execution to modify it.</div><br/></div></div></div></div><div id="40831936" class="c"><input type="checkbox" id="c-40831936" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40831142">root</a><span>|</span><a href="#40831252">parent</a><span>|</span><a href="#40831814">prev</a><span>|</span><a href="#40831573">next</a><span>|</span><label class="collapse" for="c-40831936">[-]</label><label class="expand" for="c-40831936">[1 more]</label></div><br/><div class="children"><div class="content">All modern compilers use bytecode, in one form or the other.</div><br/></div></div><div id="40831573" class="c"><input type="checkbox" id="c-40831573" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#40831142">root</a><span>|</span><a href="#40831252">parent</a><span>|</span><a href="#40831936">prev</a><span>|</span><a href="#40831439">next</a><span>|</span><label class="collapse" for="c-40831573">[-]</label><label class="expand" for="c-40831573">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s much worse than that because of the complexity around JITs, behavior of hardware and speculative execution. Proper sandboxing is really hard, and I suspect that if people really want security they would disable JIT in general. Even simple ones like pcre2. Personally I have disabled Firefox&#x27;s JIT (I believe it&#x27;s called ion in the settings, but correct me if I misremember) for a few years now. I&#x27;ve never had any trouble with any websites so far. It&#x27;s not instant loading, but it&#x27;s close enough.<p>... but I don&#x27;t know if I would lump bytecode with JIT. Bytecodes don&#x27;t need or use RWX execute segments, for example. Lots of your favorite JITs do, for speed.</div><br/></div></div></div></div></div></div><div id="40832101" class="c"><input type="checkbox" id="c-40832101" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#40831142">parent</a><span>|</span><a href="#40831211">prev</a><span>|</span><a href="#40831522">next</a><span>|</span><label class="collapse" for="c-40832101">[-]</label><label class="expand" for="c-40832101">[1 more]</label></div><br/><div class="children"><div class="content">JIT has not been secure since Spectre and Meltdown.</div><br/></div></div><div id="40831522" class="c"><input type="checkbox" id="c-40831522" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#40831142">parent</a><span>|</span><a href="#40832101">prev</a><span>|</span><a href="#40831340">next</a><span>|</span><label class="collapse" for="c-40831522">[-]</label><label class="expand" for="c-40831522">[3 more]</label></div><br/><div class="children"><div class="content">The issue here isn’t things being “verifiably secure”. languages like js and lua run in a sandboxes environment where the only functions and operations that are permitted are those explicitly added by the host environment. Those sources languages are easily validated as correct <i>code</i>.<p>[edit: I realize I should clarify something “correct” and “verifiable” here do not mean “bug free”, it means ‘cannot interfere with or violate language or environment state, memory, or other invariants’]<p>The issue here is that the hosting environment is allowing the user&#x2F;attacker to provide the bytecode that is generated from the provably correct code. That byte code is not itself verifiable statically, and is not verified at runtime (and it might not even be possible to).<p>This is not to say that bytecode is not verifiable - Java, .NET, or even WASM (which is intentionally very low level) are verifiable bytecode environments. The issue is that a byte code must be _designed_ to be verifiable (and early Java bytecode was not due to JSR or similar iirc). Lua’s bytecode is designed for execution, and so allowing arbitrary bytecode execution is not too dissimilar from a JS engine allowing a website to provide direct access to their bytecode interpreter which would be similarly catastrophic.</div><br/><div id="40833338" class="c"><input type="checkbox" id="c-40833338" checked=""/><div class="controls bullet"><span class="by">dfox</span><span>|</span><a href="#40831142">root</a><span>|</span><a href="#40831522">parent</a><span>|</span><a href="#40834242">next</a><span>|</span><label class="collapse" for="c-40833338">[-]</label><label class="expand" for="c-40833338">[1 more]</label></div><br/><div class="children"><div class="content">The issue is not really about the verifiability of the bytecode but about the interpreter checking the invariants. JVM bytecode is intentionally designed to be verifiable so that the inner loop of the interpreter does not need to care about whether the operation is executed with correctly typed operands (which in the JVM case would be highly impractical and would essentially mean that you need twice the amount of memory). You can design a system where the bytecode is not verifiable, but instead the checks are done at runtime, CPython works that way.</div><br/></div></div><div id="40834242" class="c"><input type="checkbox" id="c-40834242" checked=""/><div class="controls bullet"><span class="by">worewood</span><span>|</span><a href="#40831142">root</a><span>|</span><a href="#40831522">parent</a><span>|</span><a href="#40833338">prev</a><span>|</span><a href="#40831340">next</a><span>|</span><label class="collapse" for="c-40834242">[-]</label><label class="expand" for="c-40834242">[1 more]</label></div><br/><div class="children"><div class="content">Yeah absolutely. This exploit is akin to V8 allowing websites to supply its own bytecode (not WASM -- talking about the internal bytecode here) to it instead of Javascript.</div><br/></div></div></div></div><div id="40831340" class="c"><input type="checkbox" id="c-40831340" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#40831142">parent</a><span>|</span><a href="#40831522">prev</a><span>|</span><label class="collapse" for="c-40831340">[-]</label><label class="expand" for="c-40831340">[1 more]</label></div><br/><div class="children"><div class="content">I would take a look at BPF.</div><br/></div></div></div></div></div></div></div></div></div></body></html>