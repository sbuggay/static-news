<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728032476197" as="style"/><link rel="stylesheet" href="styles.css?v=1728032476197"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ericnormand.me/article/the-heart-of-unix">The Heart of Unix (2018)</a> <span class="domain">(<a href="https://ericnormand.me">ericnormand.me</a>)</span></div><div class="subtext"><span>kugurerdem</span> | <span>59 comments</span></div><br/><div><div id="41737740" class="c"><input type="checkbox" id="c-41737740" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#41739163">next</a><span>|</span><label class="collapse" for="c-41737740">[-]</label><label class="expand" for="c-41737740">[3 more]</label></div><br/><div class="children"><div class="content">I generally agree with this article in that PROGRAMMABILITY is the core of Unix, and it is why I&#x27;ve been working on <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;</a> for many years<p>However I think the counterpoint is maybe a programming analog of Doctorow&#x27;s &quot;Civil War on General Purpose Computing&quot;<p>I believe the idea there was that we would all have iPads and iPhones, with content delivered to us, but we would not have the power to create our own content, or do arbitrary things with computers<p>I think some of that has come to pass, at least for some fairly large portions of the population<p>(though people are infinitely creative -- I found this story of people writing novels their phone with Google Docs, and selling them via WhatsApp, interesting and cool - <a href="https:&#x2F;&#x2F;theweek.com&#x2F;culture-life&#x2F;books&#x2F;the-rise-of-the-whatsapp-novelists" rel="nofollow">https:&#x2F;&#x2F;theweek.com&#x2F;culture-life&#x2F;books&#x2F;the-rise-of-the-whats...</a> )<p>---<p>The Unix&#x2F;shell version of that is that valuable and non-trivial logic&#x2F;knowledge will be hidden in cloud services, often behind a YAML interface.<p>And your job is now to LLM the YAML that approximates what you want to do<p>Not actually do any programming, which can lead to adjacent thoughts that the cloud&#x2F;YAML owners didn&#x27;t think of<p>In some cases there is no such YAML, or it&#x27;s been trained out of the LLM, so you can&#x27;t think that thought<p>---<p>There&#x27;s an economic sense to this, in some ways, but personally I don&#x27;t want to live in that world :)</div><br/><div id="41738095" class="c"><input type="checkbox" id="c-41738095" checked=""/><div class="controls bullet"><span class="by">syndicatedjelly</span><span>|</span><a href="#41737740">parent</a><span>|</span><a href="#41739163">next</a><span>|</span><label class="collapse" for="c-41738095">[-]</label><label class="expand" for="c-41738095">[2 more]</label></div><br/><div class="children"><div class="content">I see your concern, but don&#x27;t think it&#x27;s anything to be worried about. Is an electrician&#x27;s job at risk because homeowners can purchasing wiring and outlets from a big box store and tap a new outlet in their home? Are mechanics worried about people who do oil changes at home?<p>There will always be a demand for skilled labor, but the definition of &quot;skilled&quot; is going to continue changing over time. That&#x27;s a good sign, it means that the field is healthy and growing.</div><br/><div id="41738228" class="c"><input type="checkbox" id="c-41738228" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41737740">root</a><span>|</span><a href="#41738095">parent</a><span>|</span><a href="#41739163">next</a><span>|</span><label class="collapse" for="c-41738228">[-]</label><label class="expand" for="c-41738228">[1 more]</label></div><br/><div class="children"><div class="content">Usually in many countries, insurances won&#x27;t pay if something went bad by not being done by a professional electrician or mechanic.</div><br/></div></div></div></div></div></div><div id="41739163" class="c"><input type="checkbox" id="c-41739163" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#41737740">prev</a><span>|</span><a href="#41735548">next</a><span>|</span><label class="collapse" for="c-41739163">[-]</label><label class="expand" for="c-41739163">[1 more]</label></div><br/><div class="children"><div class="content">I have a slight bone to pick with the author&#x27;s statement that Unix is homoiconic – sure, I can tail and patch a file, but it doesn&#x27;t mean that I can seamlessly and quickly manipulate, generate, and execute the canonical representation of executable code in the same way that I can do with s-expressions, quote&#x2F;quasiquote and eval. I think the bar for meaningful homoiconicity is should at least be raised to include that.<p>If &quot;I can read my source just into the canonical datatype&quot; was the standard for an environment to be meaningfully homoiconic, you could easily argue that bare metal was homoiconic for the same reason. And in fact I&#x27;d argue that it would be easier to hand-assemble VAX instructions to write more opcodes in memory (because the VAX-11 had such an extensive and convenient instruction set, especially all of the three-operand bit swizzling and manipulation instructions) than to do C code generation with a base Unix environment.</div><br/></div></div><div id="41735548" class="c"><input type="checkbox" id="c-41735548" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#41739163">prev</a><span>|</span><a href="#41735047">next</a><span>|</span><label class="collapse" for="c-41735548">[-]</label><label class="expand" for="c-41735548">[24 more]</label></div><br/><div class="children"><div class="content">The biggest disadvantage of the shell is that, by exchanging data using text, you lose opportunities to check for errors in the output. If you call a function in a programming language and an erroneous output happens, you get a crash or exception. In a shell, you&#x27;ll get empty lines or, worse, incorrect lines, that will propagate to the rest of the script. This makes it impractical to write large scripts and debugging them gets more and more complicated. The shell works well for a few lines of script, any more than that and it becomes a frustrating experience.</div><br/><div id="41737486" class="c"><input type="checkbox" id="c-41737486" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#41735548">parent</a><span>|</span><a href="#41736522">next</a><span>|</span><label class="collapse" for="c-41737486">[-]</label><label class="expand" for="c-41737486">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The biggest disadvantage of the shell is that, by exchanging data using text, you lose opportunities to check for errors in the output.<p>That&#x27;s pretty bad, but isn&#x27;t the <i>complete lack of support for structured data</i> an even bigger one? After all, if you can&#x27;t even represent your data, then throwing errors is kind of moot.</div><br/><div id="41737635" class="c"><input type="checkbox" id="c-41737635" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737486">parent</a><span>|</span><a href="#41738372">next</a><span>|</span><label class="collapse" for="c-41737635">[-]</label><label class="expand" for="c-41737635">[3 more]</label></div><br/><div class="children"><div class="content">Oils&#x2F;YSH has structured data and JSON!  This was finished earlier this year<p><i>Garbage Collection Makes YSH Different</i> (than POSIX shell, awk, cmake, make, ...) - <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2024&#x2F;09&#x2F;gc.html" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2024&#x2F;09&#x2F;gc.html</a><p>You need GC for arbitrary recursive data structures, and traditionally Unix didn&#x27;t have those languages.<p>Lisp was the first GC language, and pre-dated Unix, and then Java made GC popular, and Java was not integrated with Unix (it wanted to be its own OS)<p>----<p>So now you can do<p><pre><code>    # create some JSON
    ysh-0.23.0$ echo &#x27;{&quot;foo&quot;:[1,2,3]}&#x27; &gt; x.json

    # read it into the variable x -- you will get a syntax error if it&#x27;s malformed
    ysh-0.23.0$ json read (&amp;x) &lt; x.json


    # pretty print the resulting data structure, = comes from Lua
    ysh-0.23.0$ = x
    (Dict)  {foo: [1, 2, 3]}

    # use it in some computation
    ysh-0.23.0$ var y = x.foo[1]
    ysh ysh-0.23.0$ = y
    (Int)   2</code></pre></div><br/><div id="41737717" class="c"><input type="checkbox" id="c-41737717" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737635">parent</a><span>|</span><a href="#41738372">next</a><span>|</span><label class="collapse" for="c-41737717">[-]</label><label class="expand" for="c-41737717">[2 more]</label></div><br/><div class="children"><div class="content">Structured shells are neat and I love them, but the Unix philosophy is <i>explicitly</i> built around plain text - the &quot;structured&quot; part of structured shells isn&#x27;t Unixy.</div><br/><div id="41737797" class="c"><input type="checkbox" id="c-41737797" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737717">parent</a><span>|</span><a href="#41738372">next</a><span>|</span><label class="collapse" for="c-41737797">[-]</label><label class="expand" for="c-41737797">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not either-or -- I&#x27;d think of it as LAYERED<p>- JSON denotes a data structure, but it is also text - you can use grep and sed on it, or jq<p>- TSV denotes a data structure [1], but it is also text - you can use grep on it, or xsv or recutils or ...<p>(on the other hand, protobuf or Apache arrow not text, and you can&#x27;t use grep on them directly.  But that doesn&#x27;t mean they&#x27;re bad or not useful, just not interoperable in a Unix style.  The way you use them with Unix is to &quot;project&quot; onto text)<p>etc.<p>That is the layered philosophy of Oils, as shown in this diagram - <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2022&#x2F;02&#x2F;diagrams.html#bytes-flat-files" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2022&#x2F;02&#x2F;diagrams.html#bytes-fl...</a><p>IMO this is significantly different and better than say PowerShell, which is all about objects inside a VM<p>what I call &quot;interior vs. exterior&quot;<p>processes and files&#x2F;JSON&#x2F;TSV are &quot;exterior&quot;, while cmdlets and objects inside a .NET VM are &quot;interior&quot;<p><i>Oils Is Exterior-First (Code, Text, and Structured Data)</i> - <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2023&#x2F;06&#x2F;ysh-design.html" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2023&#x2F;06&#x2F;ysh-design.html</a><p>---<p>[1] Oils fixes some flaws in the common text formats with &quot;J8 Notation&quot;, an optional and compatible upgrade.  Both JSON and TSV have some &quot;text-y&quot; quirks, like UTF-16 legacy and inablity to represent tabs<p>So J8 Notation cleans up those rough edges, and makes them more like &quot;real&quot; data structures with clean &#x2F; composable semantics</div><br/></div></div></div></div></div></div><div id="41738372" class="c"><input type="checkbox" id="c-41738372" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737486">parent</a><span>|</span><a href="#41737635">prev</a><span>|</span><a href="#41736522">next</a><span>|</span><label class="collapse" for="c-41738372">[-]</label><label class="expand" for="c-41738372">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if you can&#x27;t even represent your data<p>any data can be represented as text</div><br/></div></div></div></div><div id="41736522" class="c"><input type="checkbox" id="c-41736522" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41735548">parent</a><span>|</span><a href="#41737486">prev</a><span>|</span><a href="#41736139">next</a><span>|</span><label class="collapse" for="c-41736522">[-]</label><label class="expand" for="c-41736522">[6 more]</label></div><br/><div class="children"><div class="content">At the same time, the POSIX shell can be implemented in a tiny binary (dash compiles to 80k on i386).<p>Shells that implement advanced objects and error handling cannot sink this low, and thus the embedded realm is not accessible to them.</div><br/><div id="41738235" class="c"><input type="checkbox" id="c-41738235" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41736522">parent</a><span>|</span><a href="#41737133">next</a><span>|</span><label class="collapse" for="c-41738235">[-]</label><label class="expand" for="c-41738235">[2 more]</label></div><br/><div class="children"><div class="content">Sure they can, Smalltalk and Lisp environments didn&#x27;t had the luxury of 80k when they were invented.</div><br/><div id="41738343" class="c"><input type="checkbox" id="c-41738343" checked=""/><div class="controls bullet"><span class="by">amszmidt</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41738235">parent</a><span>|</span><a href="#41737133">next</a><span>|</span><label class="collapse" for="c-41738343">[-]</label><label class="expand" for="c-41738343">[1 more]</label></div><br/><div class="children"><div class="content">No, they had the luxury of having much more.</div><br/></div></div></div></div><div id="41737133" class="c"><input type="checkbox" id="c-41737133" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41736522">parent</a><span>|</span><a href="#41738235">prev</a><span>|</span><a href="#41736139">next</a><span>|</span><label class="collapse" for="c-41737133">[-]</label><label class="expand" for="c-41737133">[3 more]</label></div><br/><div class="children"><div class="content">that&#x27;s dramatically larger than <i>any</i> pdp-11 executable, including the original bourne shell, and also, for example, xlisp, which was an object-oriented lisp for cp&#x2F;m<p>advanced objects and error handling do not require tens of kilobytes of machine code. a lot of why the bourne shell is so error-prone is just design errors, many of them corrected in es and rc</div><br/><div id="41737619" class="c"><input type="checkbox" id="c-41737619" checked=""/><div class="controls bullet"><span class="by">ronjakoi</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737133">parent</a><span>|</span><a href="#41736139">next</a><span>|</span><label class="collapse" for="c-41737619">[-]</label><label class="expand" for="c-41737619">[2 more]</label></div><br/><div class="children"><div class="content">What are es and rc? Can you give some links?</div><br/><div id="41737705" class="c"><input type="checkbox" id="c-41737705" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737619">parent</a><span>|</span><a href="#41736139">next</a><span>|</span><label class="collapse" for="c-41737705">[-]</label><label class="expand" for="c-41737705">[1 more]</label></div><br/><div class="children"><div class="content">Search for &quot;rc shell&quot; and &quot;es shell&quot;<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rc_(Unix_shell)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rc_(Unix_shell)</a><p><a href="https:&#x2F;&#x2F;wryun.github.io&#x2F;es-shell&#x2F;" rel="nofollow">https:&#x2F;&#x2F;wryun.github.io&#x2F;es-shell&#x2F;</a><p>They are alternative shells, both from the 90&#x27;s I believe.  POSIX was good in some ways, but bad in that it froze a defective shell design<p>It has been acknowledged as defective for &gt;30 years<p><a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2019&#x2F;01&#x2F;18.html#slogans-to-explain-the-project" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2019&#x2F;01&#x2F;18.html#slogans-to-exp...</a><p>---<p>es shell is heavily influenced by Lisp.  And actually I just wrote a comment that said my project YSH has garbage collection, but the es shell paper has a nice section on garbage collection (which is required for Lisp-y data structures)<p>And I took some influence from it<p>Trivia: one of the authors of es shell, Paul Haahr, went on to be a key engineer in the creation of Google</div><br/></div></div></div></div></div></div></div></div><div id="41736139" class="c"><input type="checkbox" id="c-41736139" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41735548">parent</a><span>|</span><a href="#41736522">prev</a><span>|</span><a href="#41735814">next</a><span>|</span><label class="collapse" for="c-41736139">[-]</label><label class="expand" for="c-41736139">[1 more]</label></div><br/><div class="children"><div class="content">The &amp;&amp; and || operators let you branch on errors.</div><br/></div></div><div id="41735814" class="c"><input type="checkbox" id="c-41735814" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#41735548">parent</a><span>|</span><a href="#41736139">prev</a><span>|</span><a href="#41735921">next</a><span>|</span><label class="collapse" for="c-41735814">[-]</label><label class="expand" for="c-41735814">[3 more]</label></div><br/><div class="children"><div class="content">that&#x27;s why the rule #1 of robust shell scripts is &quot;set -e&quot;, exit on any error. This is not perfect, but helps with most of the errors.</div><br/><div id="41736002" class="c"><input type="checkbox" id="c-41736002" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41735814">parent</a><span>|</span><a href="#41735921">next</a><span>|</span><label class="collapse" for="c-41736002">[-]</label><label class="expand" for="c-41736002">[2 more]</label></div><br/><div class="children"><div class="content">set -euo pipefail, if you&#x27;re OK with the Bashism.</div><br/><div id="41736950" class="c"><input type="checkbox" id="c-41736950" checked=""/><div class="controls bullet"><span class="by">thristian</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41736002">parent</a><span>|</span><a href="#41735921">next</a><span>|</span><label class="collapse" for="c-41736950">[-]</label><label class="expand" for="c-41736950">[1 more]</label></div><br/><div class="children"><div class="content">Since POSIX 2024, `set -o pipefail` is no longer a bashism!</div><br/></div></div></div></div></div></div><div id="41735921" class="c"><input type="checkbox" id="c-41735921" checked=""/><div class="controls bullet"><span class="by">hggigg</span><span>|</span><a href="#41735548">parent</a><span>|</span><a href="#41735814">prev</a><span>|</span><a href="#41735047">next</a><span>|</span><label class="collapse" for="c-41735921">[-]</label><label class="expand" for="c-41735921">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s even worse than that. Most non-trivial, and some trivial scripts and one liners rely on naive parsing (regex&#x2F;cut etc) because that&#x27;s the only tool in the toolbox. This resulted in some horrific problems over the years.<p>I take a somewhat hard line that scripts and terminals are for executing sequential commands naively only. Call it &quot;glue&quot;. If you&#x27;re writing a program, use a higher level programming language and parse things properly.<p>This problem of course does tend to turn up in higher level languages but at least you <i>can</i> pull a proper parser in off the shelf there if you need to.<p>Notably if I see anyone parsing CSVs with cut again I&#x27;m going to die inside. Try unpicking a problem where someone put in the name field &quot;Smith, Bob&quot;...</div><br/><div id="41737094" class="c"><input type="checkbox" id="c-41737094" checked=""/><div class="controls bullet"><span class="by">Bluecobra</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41735921">parent</a><span>|</span><a href="#41737425">next</a><span>|</span><label class="collapse" for="c-41737094">[-]</label><label class="expand" for="c-41737094">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Notably if I see anyone parsing CSVs with cut again I&#x27;m going to die inside. Try unpicking a problem where someone put in the name field &quot;Smith, Bob&quot;...<p>How do you tackle this? Would you count the numbers of commas in each line then manually fix the lines that contain more fields?</div><br/><div id="41739305" class="c"><input type="checkbox" id="c-41739305" checked=""/><div class="controls bullet"><span class="by">hggigg</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737094">parent</a><span>|</span><a href="#41737828">next</a><span>|</span><label class="collapse" for="c-41739305">[-]</label><label class="expand" for="c-41739305">[1 more]</label></div><br/><div class="children"><div class="content">You parse them and reject CSVs that do not conform. There is absolutely no way to reason about a malformed CSV.</div><br/></div></div><div id="41737828" class="c"><input type="checkbox" id="c-41737828" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737094">parent</a><span>|</span><a href="#41739305">prev</a><span>|</span><a href="#41737380">next</a><span>|</span><label class="collapse" for="c-41737828">[-]</label><label class="expand" for="c-41737828">[1 more]</label></div><br/><div class="children"><div class="content">Yes, as in &quot;check the number of parsed fields for each line&quot; and don&#x27;t forget about empty fields. Throw an error and stop the program if the number of columns isn&#x27;t consistent. Which doesn&#x27;t mean that you can&#x27;t parse the whole file and output all errors at once (which is the preferred way, we don&#x27;t live in the 90s any more ;), just don&#x27;t process the wrong result. And with usable error messages, not just &quot;invalid line N&quot;.</div><br/></div></div><div id="41737380" class="c"><input type="checkbox" id="c-41737380" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737094">parent</a><span>|</span><a href="#41737828">prev</a><span>|</span><a href="#41737425">next</a><span>|</span><label class="collapse" for="c-41737380">[-]</label><label class="expand" for="c-41737380">[1 more]</label></div><br/><div class="children"><div class="content"><a href="http:&#x2F;&#x2F;www.catb.org&#x2F;~esr&#x2F;writings&#x2F;taoup&#x2F;html&#x2F;ch05s02.html" rel="nofollow">http:&#x2F;&#x2F;www.catb.org&#x2F;~esr&#x2F;writings&#x2F;taoup&#x2F;html&#x2F;ch05s02.html</a><p>paragraph titled DSV style. (Yeah esr, not a fan, whatever...)<p>Csv sucks no matter what, there is no one csv spec. Then even if you assume the file is &quot;MS Excel style csv&quot; you can&#x27;t validate it conforms. There&#x27;s a bunch of things the libraries do that cope with at least some of it that you will not replicate with cut or an awk one liner.</div><br/></div></div></div></div><div id="41737425" class="c"><input type="checkbox" id="c-41737425" checked=""/><div class="controls bullet"><span class="by">aadhavans</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41735921">parent</a><span>|</span><a href="#41737094">prev</a><span>|</span><a href="#41736754">next</a><span>|</span><label class="collapse" for="c-41737425">[-]</label><label class="expand" for="c-41737425">[2 more]</label></div><br/><div class="children"><div class="content">What if you had constraints on the CSV files? Suppose you knew that they don&#x27;t contain spaces, for example. In that case, I don&#x27;t see the problem with using UNIX tools.</div><br/><div id="41737461" class="c"><input type="checkbox" id="c-41737461" checked=""/><div class="controls bullet"><span class="by">throw10920</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41737425">parent</a><span>|</span><a href="#41736754">next</a><span>|</span><label class="collapse" for="c-41737461">[-]</label><label class="expand" for="c-41737461">[1 more]</label></div><br/><div class="children"><div class="content">Then you&#x27;re not actually processing the CSV format, you&#x27;re processing a subset of it. You&#x27;ll also likely bake that assumption into your system and forget about it, and then potentially violate it later.<p>Well-defined <i>structured</i> data formats, formal grammars, and parsers exist for a reason. Unix <i>explicitly</i> eschews that in favor of the fiction of &quot;plain text&quot;, which is not a format for structured data <i>by definition</i>.</div><br/></div></div></div></div><div id="41736754" class="c"><input type="checkbox" id="c-41736754" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41735548">root</a><span>|</span><a href="#41735921">parent</a><span>|</span><a href="#41737425">prev</a><span>|</span><a href="#41735047">next</a><span>|</span><label class="collapse" for="c-41736754">[-]</label><label class="expand" for="c-41736754">[1 more]</label></div><br/><div class="children"><div class="content">You might have enjoyed DCL under VMS.<p>It did not immediately succumb to envy of the Korn shell.</div><br/></div></div></div></div></div></div><div id="41735047" class="c"><input type="checkbox" id="c-41735047" checked=""/><div class="controls bullet"><span class="by">mmcgaha</span><span>|</span><a href="#41735548">prev</a><span>|</span><a href="#41737444">next</a><span>|</span><label class="collapse" for="c-41735047">[-]</label><label class="expand" for="c-41735047">[4 more]</label></div><br/><div class="children"><div class="content">I always tell people the best way to learn how to use linux is to read The Unix Programming Environment.</div><br/><div id="41735849" class="c"><input type="checkbox" id="c-41735849" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41735047">parent</a><span>|</span><a href="#41737444">next</a><span>|</span><label class="collapse" for="c-41735849">[-]</label><label class="expand" for="c-41735849">[3 more]</label></div><br/><div class="children"><div class="content">Perl superseded it for almost all of the chapters, except for the C ones. Altough for small programs, for sure it did.<p>Perl used to have an AWK to Perl converter because most of the language could be mapped 1:1 to Perl.<p>UPE would be fine under 9front save for sh (rc) and make (mk).</div><br/><div id="41736075" class="c"><input type="checkbox" id="c-41736075" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41735047">root</a><span>|</span><a href="#41735849">parent</a><span>|</span><a href="#41737444">next</a><span>|</span><label class="collapse" for="c-41736075">[-]</label><label class="expand" for="c-41736075">[2 more]</label></div><br/><div class="children"><div class="content">I liked awk and perl was even better where either more structured (I know, I know) constructs were comfy or I needed perl dbi (which was awesome, what do people use now?) but that was a while ago.  Sort of nuts that awk is much faster on really big columnar (csv etc) data, though.</div><br/><div id="41736906" class="c"><input type="checkbox" id="c-41736906" checked=""/><div class="controls bullet"><span class="by">cafard</span><span>|</span><a href="#41735047">root</a><span>|</span><a href="#41736075">parent</a><span>|</span><a href="#41737444">next</a><span>|</span><label class="collapse" for="c-41736906">[-]</label><label class="expand" for="c-41736906">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; what do people use now?<p>Well, sometimes Perl DBI. But the young seem to learn Python about the time they get their drivers&#x27; licenses, and some unfortunate among them will inherit my code, so these days I use more psycopg or cx_Oracle (the latter now superseded, yes).</div><br/></div></div></div></div></div></div></div></div><div id="41737444" class="c"><input type="checkbox" id="c-41737444" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#41735047">prev</a><span>|</span><a href="#41737395">next</a><span>|</span><label class="collapse" for="c-41737444">[-]</label><label class="expand" for="c-41737444">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I hope to see more &quot;sugar&quot; in languages to take advantage of calling out to other programs for help.<p>How about [1] and [2]?<p>My language has those because its first program was its own build script, which requires calling out to a C compiler. It had that before printing to stdout.<p>Turns out, that made it far more powerful than I imagined without a standard library. Calling out to separate programs is far better than a standard library.<p>[1]: <a href="https:&#x2F;&#x2F;git.yzena.com&#x2F;Yzena&#x2F;Yc&#x2F;src&#x2F;commit&#x2F;95904ef79701024857a7f7b7ffa1dc7df3e453ba&#x2F;tools&#x2F;format.yao#L127" rel="nofollow">https:&#x2F;&#x2F;git.yzena.com&#x2F;Yzena&#x2F;Yc&#x2F;src&#x2F;commit&#x2F;95904ef79701024857...</a><p>[2]: <a href="https:&#x2F;&#x2F;git.yzena.com&#x2F;Yzena&#x2F;Yc&#x2F;src&#x2F;commit&#x2F;95904ef79701024857a7f7b7ffa1dc7df3e453ba&#x2F;tools&#x2F;format.yao#L150-L152" rel="nofollow">https:&#x2F;&#x2F;git.yzena.com&#x2F;Yzena&#x2F;Yc&#x2F;src&#x2F;commit&#x2F;95904ef79701024857...</a></div><br/></div></div><div id="41737395" class="c"><input type="checkbox" id="c-41737395" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#41737444">prev</a><span>|</span><a href="#41736534">next</a><span>|</span><label class="collapse" for="c-41737395">[-]</label><label class="expand" for="c-41737395">[1 more]</label></div><br/><div class="children"><div class="content">Nice article.<p>The criticism of the file system as overly simple or archaic is often been made, ever since the 70s.  However the fact is that it IS use-able as a base for ACID capable software.  Numerous reality based evidence attests to that.<p>I remember in Rochkind&#x27;s book[0] there is a quote criticising Unix being inferior to IBM&#x27;s MVS because it didn&#x27;t have locking.  As Rochkind retorts, MVS didn&#x27;t either!  Not as a kernel feature, but via user space software, which is eminently do-able in Unix too.<p>[0] <a href="https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;advanced-unix-programming&#x2F;9780132466004&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;advanced-unix-programmi...</a></div><br/></div></div><div id="41736534" class="c"><input type="checkbox" id="c-41736534" checked=""/><div class="controls bullet"><span class="by">niobe</span><span>|</span><a href="#41737395">prev</a><span>|</span><a href="#41736136">next</a><span>|</span><label class="collapse" for="c-41736534">[-]</label><label class="expand" for="c-41736534">[1 more]</label></div><br/><div class="children"><div class="content">Great article. I was only just thinking this week, &quot;are there really still only 3 channels?&quot;.<p>But short of a massive overhaul and in spite of the shortcomings the current system still _works_ better than any other platform.<p>I would like to see unix stay relevant for the long-term however. It&#x27;s possible these shortcomings lead one day to a the trade-off against newer systems not being worth making, or being just incompatible.</div><br/></div></div><div id="41736136" class="c"><input type="checkbox" id="c-41736136" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#41736534">prev</a><span>|</span><a href="#41736559">next</a><span>|</span><label class="collapse" for="c-41736136">[-]</label><label class="expand" for="c-41736136">[1 more]</label></div><br/><div class="children"><div class="content">With image-capable terminals and funky enhanced cli utilities we are sort of slouching towards something like a CLIM listener or a notebook interface at the shell. What would something in that vein that was really, really nice look like?</div><br/></div></div><div id="41736559" class="c"><input type="checkbox" id="c-41736559" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41736136">prev</a><span>|</span><a href="#41735958">next</a><span>|</span><label class="collapse" for="c-41736559">[-]</label><label class="expand" for="c-41736559">[3 more]</label></div><br/><div class="children"><div class="content">&gt; We see that languages like Perl and Python have huge numbers of libraries for doing all sorts of tasks. Those libraries are only accessible through the programming language they were developed for. This is a missed opportunity for the languages to interoperate synergistically with the rest of the Unix ecosystem.<p>What would this interoperability look like, in practical terms?<p>For example, how would you invoke a program in language A from language B, other than the typical existing `system.exec(...)&#x27;.</div><br/><div id="41738381" class="c"><input type="checkbox" id="c-41738381" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41736559">parent</a><span>|</span><a href="#41736776">next</a><span>|</span><label class="collapse" for="c-41738381">[-]</label><label class="expand" for="c-41738381">[1 more]</label></div><br/><div class="children"><div class="content">The author is saying these libraries expose Perl&#x2F;Python&#x2F;etc functions, that can only be invoked by Perl&#x2F;Python&#x2F;etc code.<p>Whereas Unix functions (programs) can be invoked by any programming language.<p>---<p>The C ABI would be a second place, as many languages can interact with it.</div><br/></div></div><div id="41736776" class="c"><input type="checkbox" id="c-41736776" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#41736559">parent</a><span>|</span><a href="#41738381">prev</a><span>|</span><a href="#41735958">next</a><span>|</span><label class="collapse" for="c-41736776">[-]</label><label class="expand" for="c-41736776">[1 more]</label></div><br/><div class="children"><div class="content">Its nonsense. They interoperate just as well as any other programs in UNIX. You can pipe stdin to them, pipe their output to other programs, or invoke the shell or other programs. The fact that they have libraries that don&#x27;t require integration through text streams doesn&#x27;t take anything away from the text processing interfaces and programs. Shell scripts have their place, and UNIX is beautiful, but that doesn&#x27;t mean everything has to work this way.</div><br/></div></div></div></div><div id="41735958" class="c"><input type="checkbox" id="c-41735958" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#41736559">prev</a><span>|</span><a href="#41736981">next</a><span>|</span><label class="collapse" for="c-41735958">[-]</label><label class="expand" for="c-41735958">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m on board with this.<p>Unix is my favorite OS.<p>I like that it&#x27;s fundamental unit of work is the process, and that, as users, we have ready access to those. Processes are cheap and easy.<p>I can stack them together with a | character. I can shove them in the background with a &amp; (or ^Z and bg, or whatever). Cron is simple. at(1) and batch(1) are simple.<p>The early machines I worked on, processes were a preallocated thing on boot. They weren&#x27;t some disposable piece of work. You could do a lot with it, but it&#x27;s not the same.<p>Even when I was working on VMS, I &quot;never&quot; started new processes. Not like you do in Unix. Not ad hoc, &quot;just for a second&quot;. No, I just worked directly with what I had. I could not compose new workflows readily out of processes.<p>Processes give a lot of isolation and safety. If a process goes mad, it&#x27;s (usually) easily killed with little impact to the overall system. Thus its cheap and forgiving to mess up with processes.<p>inetd was a great idea. Tie stdin&#x2F;stdout to a socket. Any one and their brother Frank could write a service managed by inetd -- in anything. CGI-BIN is the same way. The http server does the routing, the process manages the rest. Can you imagine shared hosting without processes? I shudder at the thought.<p>Binary processes are cheap too, with shared code segments making easy forks, fast startup, low system impact. The interpreters, of course, wrecked that whole thing. And, arguably, the systems were &quot;fast enough&quot; to make that impact low.<p>But inetd, running binary processes? That is not a slow server. It can be faster (pre-forking, threads, dedicated daemons), but that combo is not necessarily slow. I think the sqlite folks basically do this with Fossil on their server.<p>Note, I&#x27;m not harping on &quot;one process, one thing&quot;, that&#x27;s different. Turns out when processes are cheap and nimble, then that concept kind of glitters at the bottom of the pan. But that&#x27;s policy, not capability.<p>But the Unix system is just crazy malleable and powerful. People talk about a post-holocaust system. How they want something like CP&#x2F;M cuz its simple. But, really? What a horrific system! Yes, a &quot;unix like system&quot; is an order of magnitude more complex than something like CP&#x2F;M. But its far more than an order of magnitude more capable. It&#x27;s worth the expense.<p>Even something weak, like Coherent on a 286. Yea, it had its limitations, but the fundamentals were there. At the end of the world, just give me a small kernel, sh, vi, cc, and ld -- I can write the rest of the userland -- poorly :).</div><br/></div></div><div id="41736981" class="c"><input type="checkbox" id="c-41736981" checked=""/><div class="controls bullet"><span class="by">golly_ned</span><span>|</span><a href="#41735958">prev</a><span>|</span><a href="#41738392">next</a><span>|</span><label class="collapse" for="c-41736981">[-]</label><label class="expand" for="c-41736981">[1 more]</label></div><br/><div class="children"><div class="content">What does this article add to the countless others espousing the Unix model for exactly the same thing?</div><br/></div></div><div id="41738392" class="c"><input type="checkbox" id="c-41738392" checked=""/><div class="controls bullet"><span class="by">mustache_kimono</span><span>|</span><a href="#41736981">prev</a><span>|</span><a href="#41738357">next</a><span>|</span><label class="collapse" for="c-41738392">[-]</label><label class="expand" for="c-41738392">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Compare that to Clojure, where you constantly define and redefine functions at the REPL.<p>It&#x27;s an interactive shell FFS, does it get more REPL than that?!<p>`set -x` is what you want brother.</div><br/></div></div><div id="41738357" class="c"><input type="checkbox" id="c-41738357" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41738392">prev</a><span>|</span><a href="#41734632">next</a><span>|</span><label class="collapse" for="c-41738357">[-]</label><label class="expand" for="c-41738357">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unix is homoiconic<p>Wild, very cool</div><br/></div></div><div id="41734632" class="c"><input type="checkbox" id="c-41734632" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41738357">prev</a><span>|</span><a href="#41737976">next</a><span>|</span><label class="collapse" for="c-41734632">[-]</label><label class="expand" for="c-41734632">[7 more]</label></div><br/><div class="children"><div class="content">Today Unix philisophy it&#x27;s better done at 9front than the Unix clones themselves.<p>&gt;Functional + universal data structure + homoiconic = power<p>It everything used TSV or tabular data, yes. But is not the case. With lisp you can always be sure.<p>&gt;I edit my entries in Emacs.<p>Emacs can do dired (ls+vidir), eshell, rsync maybe to s3 (emacs package+rclone), markdown to HTML (and more from ORG Mode) and tons more with Elisp. With ORG you can basically define your blog and with little of Elisp you could upload your blog upon finishing.<p>&gt;21st Century Terminal<p>Eshell, or Emacs itself.<p>&gt;. What if we take the idea of Unix programs as pure functions over streams of data a little further? What about higher-order functions? Or function transformations? Combinators?<p>Hello Elisp. On combinators, maybe that shell from Dave from 
CCA. MPSH? <a href="https:&#x2F;&#x2F;www.cca.org&#x2F;mpsh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cca.org&#x2F;mpsh&#x2F;</a></div><br/><div id="41735576" class="c"><input type="checkbox" id="c-41735576" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#41734632">parent</a><span>|</span><a href="#41737453">next</a><span>|</span><label class="collapse" for="c-41735576">[-]</label><label class="expand" for="c-41735576">[3 more]</label></div><br/><div class="children"><div class="content">Every time people praise Emacs like this, I wonder if I just don’t get it or they have an Emacs-shaped hammer and only see Emacs-shaped nails. Lots of braced nails, naturally.</div><br/><div id="41736540" class="c"><input type="checkbox" id="c-41736540" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#41734632">root</a><span>|</span><a href="#41735576">parent</a><span>|</span><a href="#41737072">next</a><span>|</span><label class="collapse" for="c-41736540">[-]</label><label class="expand" for="c-41736540">[1 more]</label></div><br/><div class="children"><div class="content">The nice thing about emacs is the customization. Unix utilities like ls, grep,… are opaque blob with switches. With Emacs, you have direct access to the functions and variables. Instead of praying for a switch or a configuration option, you just write or alter the code and integrate them together.<p>And while you have libraries and code access, elips is easier than the unix way (writing c&#x2F;go&#x2F;rust&#x2F;… programs or bash&#x2F;perl&#x2F;awk&#x2F;python&#x2F;… scripts). Except for few cases.</div><br/></div></div><div id="41737072" class="c"><input type="checkbox" id="c-41737072" checked=""/><div class="controls bullet"><span class="by">lotharcable</span><span>|</span><a href="#41734632">root</a><span>|</span><a href="#41735576">parent</a><span>|</span><a href="#41736540">prev</a><span>|</span><a href="#41737453">next</a><span>|</span><label class="collapse" for="c-41737072">[-]</label><label class="expand" for="c-41737072">[1 more]</label></div><br/><div class="children"><div class="content">Emacs is unique because it is self-editable.  That is you can edit and modify the program on the program realtime. There is a C-based core that can&#x27;t be updated on the fly, but by and large Emacs a self-mutable Lisp virtual machine that comes with a built-in editor and repl.<p>Depending on how you want to look at it it is possible to say that Emacs editor you use when you first install it is just the default application for the ELisp machine. This is why people talk about things like Org-Mode as if it is this separate thing.  It kinda really is. Sure it is included with Emacs nowadays, but it really is just another Elisp application. And, yes, it is a editor first and the machine is based around concepts like buffers, but it is still a full fledged programming environment.<p>Which also means that if you don&#x27;t like Emacs as a editor you can write your own. Which people have done. It makes a great Vi&#x2F;Vim editor with Evil that is far more compatible with Vim then most people imagine. I use &quot;Meow-mode&quot; which is another model editor that adopts some more modern approaches from things like  Helix and puts a lot of focus on improving the efficiency of Emacs keyboard macros.<p>So saying that Emacs users just have a &quot;Emacs-shaped hammer&quot; makes as much sense as saying that all Java authors have is a big Java hammer or that Linux users can only see problems as Linux nails, or whatever.<p>There is a downside to all of this, of course.<p>Emacs where-everything-is-changeable-and-accessible-all-the-time doesn&#x27;t lend itself to multi-threading, so if you have a lot of stuff going on in the &quot;background&quot; it can cause performance problems.  The newer &quot;native compilation&quot; that became standard in the past few years does helps a lot, but there is a still a single thread deep down.<p>Also if you want to get very productive in Emacs there is a learning curve.  If you are a sysadmin type that has been using Vi for decades then going to Emacs is going to be very painful.  The best bet for becoming a advanced user very quickly is to learn just enough Emacs to do basic editing and navigating info files... and then just put the effort into learning Elisp.  You don&#x27;t have to do this, lots of people use it for years without learning any real elisp, but it does limit you.  Of course thanks to things like Doom Emacs you don&#x27;t lose much compared to other editors&#x2F;IDEs.<p>Also things like Eshell and GNU Calc are criminally underrated and misunderstood. (hint: Eshell is not a terminal emulator and doesn&#x27;t use a external shell program, so don&#x27;t confuse it with things like ETerm)<p>And, hey, I can now have conversations with my editor with the help of ollama. So there is that.</div><br/></div></div></div></div><div id="41737453" class="c"><input type="checkbox" id="c-41737453" checked=""/><div class="controls bullet"><span class="by">amy-petrik-214</span><span>|</span><a href="#41734632">parent</a><span>|</span><a href="#41735576">prev</a><span>|</span><a href="#41735574">next</a><span>|</span><label class="collapse" for="c-41737453">[-]</label><label class="expand" for="c-41737453">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Functional + universal data structure + homoiconic = power<p>&gt;It everything used TSV or tabular data,  But is not the case. With lisp you can always be sure.<p>basic unix kit is built around line-separated lines which are field-separated and you even get to choose your own separators and not get locked into tab.  You can use this kitset, a common one, or other different kit.  But with this kitset, yes, everything is indeed a table<p>Re: emacs
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=urcL86UpqZc&amp;t=253s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=urcL86UpqZc&amp;t=253s</a></div><br/></div></div><div id="41735574" class="c"><input type="checkbox" id="c-41735574" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#41734632">parent</a><span>|</span><a href="#41737453">prev</a><span>|</span><a href="#41737976">next</a><span>|</span><label class="collapse" for="c-41735574">[-]</label><label class="expand" for="c-41735574">[2 more]</label></div><br/><div class="children"><div class="content">Elisp is dependent on Emacs. It is useful to have a language that you can run without loading Emacs.</div><br/><div id="41736653" class="c"><input type="checkbox" id="c-41736653" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41734632">root</a><span>|</span><a href="#41735574">parent</a><span>|</span><a href="#41737976">next</a><span>|</span><label class="collapse" for="c-41736653">[-]</label><label class="expand" for="c-41736653">[1 more]</label></div><br/><div class="children"><div class="content">Guile supports Elisp, albeit it&#x27;s far slower. Also you can run<p><pre><code>      emacs -q --script &quot;foo.el&quot;
</code></pre>
foo.el being<p><pre><code>   (&#x2F; 2.0 3.0)
   (princ &quot;Hello&quot;)
   (terpri)</code></pre></div><br/></div></div></div></div></div></div><div id="41737976" class="c"><input type="checkbox" id="c-41737976" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#41734632">prev</a><span>|</span><a href="#41734816">next</a><span>|</span><label class="collapse" for="c-41737976">[-]</label><label class="expand" for="c-41737976">[2 more]</label></div><br/><div class="children"><div class="content">Being a programmable environment is one of the good benefits of UNIX, and piping programs together is also a good benefit of UNIX.<p>&quot;Write programs that do one thing and do it well&quot; and &quot;Write programs to work together&quot; are good ideas, too (unfortunately many programs don&#x27;t).<p>I think that using a text stream for everything is not the best idea though. In many cases binary formats will do better. I think XML and JSON are not that good either.<p>I think &quot;cache your compiler output to disk so you wouldn&#x27;t have to do a costly compile step each time you ran a program&quot; is a good idea, although this should not be required; REPL and other stuff they mention there is also very helpful.<p>They say the file system is also old. My idea is a transactional hypertext file system. It doesn&#x27;t have metadata (or even file names), but a file can contain multiple numbered forks and you can store extra data in there.<p>(Transactional file system is something that I think is useful and that UNIX doesn&#x27;t do.)<p>They are also right about the terminal is old, although some of the newer things that some people had tried to do have different sets of problems.<p>They also say another unfortunate thing is layering, and I agree that this layering is excessive.<p>Interoperating without needing FFI is also helpful (and see below what I mention about typed initial messages, too).<p>About the stuff listed in &quot;Text streams, evolved&quot;, my idea of the operating system design, involves the &quot;Common Data Format&quot; (which is a binary format, somewhat like ASN.1 BER but different), and most data, including the command shell and most files, would use it; this also allows for common operations.<p>I agree with &quot;a program which displays all of the thumbnails of the files listed on stdin would be much more useful to me than a mouse-oriented file browser&quot;, and I do not have a GUI file browser anyways. I do use command-line programs for most things, even though I have X Windows to run some GUI programs and to be able to have multiple xterms at once (I often have many xterms at once). However, it could be improved as I describe above, too.<p>They mention the shell. I agree that it could be greatly improved, and I think that it would go with the other improvements above. My operating system design effectively requires &quot;programs as pure functions over streams of data&quot; (although it is functions over &quot;capabilities&quot;, and not necessarily &quot;streams of data&quot;) due to the way that the capability-based security is working, and the way the linking and capability passing is working also allows working like higher-order functions and transformations and all of that stuff. Even, my idea also involves message passing (all I&#x2F;O is done by passing messages between capabilities), too.<p>I had also considered programs that require types. One of the forks (like I mentioned above) of a executable file can specify the expected type of the initial message, and the command shell can use this to effectively make them like functions that have types.<p>Something they don&#x27;t mention is security. That can also be improved; the capability-based security that I mention above, if you have proxy capabilities too, will improve it. There is also the possibility that users can use the command shell and write other programs to make up your own proxy capabilities, and this allows programs to be used to do things that they were not necessarily designed to do, in addition to improving security. Instead of merely a user account, it might e.g. allow to write to only one file, or allow connecting to only one remote computer (without the program knowing which one it is, and perhaps even with data compression that the application program is unaware of), etc.<p>I still think that, even if you have powerful computers, you should still program it efficiently anyways.<p>The new one won&#x27;t be UNIX; it will be something else.</div><br/><div id="41738485" class="c"><input type="checkbox" id="c-41738485" checked=""/><div class="controls bullet"><span class="by">Tor3</span><span>|</span><a href="#41737976">parent</a><span>|</span><a href="#41734816">next</a><span>|</span><label class="collapse" for="c-41738485">[-]</label><label class="expand" for="c-41738485">[1 more]</label></div><br/><div class="children"><div class="content">Using text streams between piped-together processes is not a requirement though. I&#x27;m using binary streams for some of the stuff I do, as I write simulators for some hardware (and other things) which gets processed by something else through a pipe or two (and may end up being parsed into text at or near the final point).</div><br/></div></div></div></div><div id="41734816" class="c"><input type="checkbox" id="c-41734816" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41737976">prev</a><span>|</span><a href="#41738054">next</a><span>|</span><label class="collapse" for="c-41734816">[-]</label><label class="expand" for="c-41734816">[1 more]</label></div><br/><div class="children"><div class="content">On shells for Unix, this can be really useful to cut script regex
matching in half:<p><a href="https:&#x2F;&#x2F;www.cca.org&#x2F;mpsh&#x2F;docs-08.html" rel="nofollow">https:&#x2F;&#x2F;www.cca.org&#x2F;mpsh&#x2F;docs-08.html</a></div><br/></div></div><div id="41735189" class="c"><input type="checkbox" id="c-41735189" checked=""/><div class="controls bullet"><span class="by">gregw2</span><span>|</span><a href="#41738054">prev</a><span>|</span><label class="collapse" for="c-41735189">[-]</label><label class="expand" for="c-41735189">[4 more]</label></div><br/><div class="children"><div class="content">The author of the article seems unaware of awk or jq or perl one-liners for handling JSON or other forms of data from UNIX command line.</div><br/><div id="41735447" class="c"><input type="checkbox" id="c-41735447" checked=""/><div class="controls bullet"><span class="by">taejavu</span><span>|</span><a href="#41735189">parent</a><span>|</span><a href="#41735857">next</a><span>|</span><label class="collapse" for="c-41735447">[-]</label><label class="expand" for="c-41735447">[1 more]</label></div><br/><div class="children"><div class="content">The contents of the article indicate you&#x27;re mistaken:<p>&gt; You really can use the best tool for the job. I&#x27;ve got Bash scripts, awk scripts, Python scripts, some Perl scripts. What I program in at the moment depends on my mood and practical considerations.</div><br/></div></div><div id="41735857" class="c"><input type="checkbox" id="c-41735857" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41735189">parent</a><span>|</span><a href="#41735447">prev</a><span>|</span><label class="collapse" for="c-41735857">[-]</label><label class="expand" for="c-41735857">[2 more]</label></div><br/><div class="children"><div class="content">You often have to do dances with JSON, XML, TSV... converters before parsing the actual data.<p>If you use something like Emacs, you just handle s-exps.</div><br/><div id="41736843" class="c"><input type="checkbox" id="c-41736843" checked=""/><div class="controls bullet"><span class="by">cutler</span><span>|</span><a href="#41735189">root</a><span>|</span><a href="#41735857">parent</a><span>|</span><label class="collapse" for="c-41736843">[-]</label><label class="expand" for="c-41736843">[1 more]</label></div><br/><div class="children"><div class="content">What about jq and family?</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>