<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685437257244" as="style"/><link rel="stylesheet" href="styles.css?v=1685437257244"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://austinhenley.com/blog/superoptimizer.html">My first superoptimizer</a> <span class="domain">(<a href="https://austinhenley.com">austinhenley.com</a>)</span></div><div class="subtext"><span>azhenley</span> | <span>49 comments</span></div><br/><div><div id="36120049" class="c"><input type="checkbox" id="c-36120049" checked=""/><div class="controls bullet"><span class="by">SideQuark</span><span>|</span><a href="#36118440">next</a><span>|</span><label class="collapse" for="c-36120049">[-]</label><label class="expand" for="c-36120049">[2 more]</label></div><br/><div class="children"><div class="content">Better than brute force is using a model of your instruction set (x86 start here [1]), then using something like Z3 [] to find solutions. Here&#x27;s a paper doing the same [2]. With these approaches you can get vastly bigger pieces of code generated than brute force, and with significantly less hand heuristic tuning effort (which likely still loses out to current solvers).<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;zwegner&#x2F;x86-sat">https:&#x2F;&#x2F;github.com&#x2F;zwegner&#x2F;x86-sat</a><p>[2] <a href="https:&#x2F;&#x2F;people.cs.umass.edu&#x2F;~aabhinav&#x2F;Publications&#x2F;Unbounded-Superoptimization-Onward17.pdf" rel="nofollow">https:&#x2F;&#x2F;people.cs.umass.edu&#x2F;~aabhinav&#x2F;Publications&#x2F;Unbounded...</a></div><br/><div id="36121921" class="c"><input type="checkbox" id="c-36121921" checked=""/><div class="controls bullet"><span class="by">malft</span><span>|</span><a href="#36120049">parent</a><span>|</span><a href="#36118440">next</a><span>|</span><label class="collapse" for="c-36121921">[-]</label><label class="expand" for="c-36121921">[1 more]</label></div><br/><div class="children"><div class="content">If you are familiar with that paper, I&#x27;m a little confused by the results section. If I&#x27;m reading p01 from figure 7 correctly, the &quot;before&quot; is x&amp;(x-1) and the &quot;after&quot; is a single instruction x&amp;(x&lt;&lt;1). What am I doing wrong?<p>(The other two wins listed are &quot;recognize the Hacker&#x27;s Delight trick and replace it with the straight-forward implementation a human would write&quot;, which I like.)</div><br/></div></div></div></div><div id="36118440" class="c"><input type="checkbox" id="c-36118440" checked=""/><div class="controls bullet"><span class="by">mungoman2</span><span>|</span><a href="#36120049">prev</a><span>|</span><a href="#36118784">next</a><span>|</span><label class="collapse" for="c-36118440">[-]</label><label class="expand" for="c-36118440">[2 more]</label></div><br/><div class="children"><div class="content">Happy to see this! Superoptimizers are one of my all time favorite topics.<p>My favorite trick when cutting down the search space of possible programs is to generate DAGs directly instead of an instruction sequence. This way, it&#x27;s easier to write rules that avoid nonsensical programs and to some extent avoid generating multiple equivalent programs.<p>For example to avoid programs that overwrite calculations you make sure that each node in the generated DAG has something that depends on it.<p>In a suitable environment the DAG can then be executed directly without lowering to a sequence of instructions.</div><br/><div id="36118632" class="c"><input type="checkbox" id="c-36118632" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#36118440">parent</a><span>|</span><a href="#36118784">next</a><span>|</span><label class="collapse" for="c-36118632">[-]</label><label class="expand" for="c-36118632">[1 more]</label></div><br/><div class="children"><div class="content">This sounds a little bit like representing boolean functions as binary decision diagrams -- although for a superoptimizer presumably each node in the DAG would correspond to an instruction from the target instruction set, which might do something rather complicated, not just a primitive logical operation between a few bits.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Binary_decision_diagram" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Binary_decision_diagram</a><p>(i first read about BDDs in Knuth&#x27;s, &quot;The Art of Computer Programming&quot;, Volume 4, Fascicle 1, then spent an enjoyable few weeks going down a rabbit hole of building a boolean function to decide if an input 2d grid of bits was a maze or not, then uniformly sampling mazes from it...)</div><br/></div></div></div></div><div id="36118784" class="c"><input type="checkbox" id="c-36118784" checked=""/><div class="controls bullet"><span class="by">petercooper</span><span>|</span><a href="#36118440">prev</a><span>|</span><a href="#36118984">next</a><span>|</span><label class="collapse" for="c-36118784">[-]</label><label class="expand" for="c-36118784">[5 more]</label></div><br/><div class="children"><div class="content">The 1987 paper about superoptimizers is well worth the read, BTW. It&#x27;s quite short. Even the first example on its own (writing the sign function without any conditionals) is a mind-bender but becomes straightforward once you see the trick used: <a href="https:&#x2F;&#x2F;courses.cs.washington.edu&#x2F;courses&#x2F;cse501&#x2F;15sp&#x2F;papers&#x2F;massalin.pdf" rel="nofollow">https:&#x2F;&#x2F;courses.cs.washington.edu&#x2F;courses&#x2F;cse501&#x2F;15sp&#x2F;papers...</a></div><br/><div id="36119158" class="c"><input type="checkbox" id="c-36119158" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#36118784">parent</a><span>|</span><a href="#36118984">next</a><span>|</span><label class="collapse" for="c-36119158">[-]</label><label class="expand" for="c-36119158">[4 more]</label></div><br/><div class="children"><div class="content">The cool thing about that paper is compiler implementers immediately added those optimizations to their code generators.</div><br/><div id="36120305" class="c"><input type="checkbox" id="c-36120305" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#36118784">root</a><span>|</span><a href="#36119158">parent</a><span>|</span><a href="#36118984">next</a><span>|</span><label class="collapse" for="c-36120305">[-]</label><label class="expand" for="c-36120305">[3 more]</label></div><br/><div class="children"><div class="content">By &#x27;those optimisations&#x27; I assume you mean the specific rewrites, not superoptimisation?  There has been some interesting recent work in rewrite inference, e.g. ruler.  (I recall one such project did a survey and found that many—possibly a majority—of the rewrites it had generated automatically were not present in the hand-written corpuses of gcc and clang.  I&#x27;m not sure if there was subsequent work to supplement gcc and clang; this was a few years ago now; I think they were looking at gcc 7.)</div><br/><div id="36120895" class="c"><input type="checkbox" id="c-36120895" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#36118784">root</a><span>|</span><a href="#36120305">parent</a><span>|</span><a href="#36118984">next</a><span>|</span><label class="collapse" for="c-36120895">[-]</label><label class="expand" for="c-36120895">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I assume you mean the specific rewrites<p>Of course. The superoptimizer is too slow to use in the compiler itself.</div><br/><div id="36121695" class="c"><input type="checkbox" id="c-36121695" checked=""/><div class="controls bullet"><span class="by">colinb</span><span>|</span><a href="#36118784">root</a><span>|</span><a href="#36120895">parent</a><span>|</span><a href="#36118984">next</a><span>|</span><label class="collapse" for="c-36121695">[-]</label><label class="expand" for="c-36121695">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10463312" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10463312</a> talks about some in real time uses</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36118984" class="c"><input type="checkbox" id="c-36118984" checked=""/><div class="controls bullet"><span class="by">manasij7479</span><span>|</span><a href="#36118784">prev</a><span>|</span><a href="#36118634">next</a><span>|</span><label class="collapse" for="c-36118984">[-]</label><label class="expand" for="c-36118984">[1 more]</label></div><br/><div class="children"><div class="content">The pruning part can do a lot of heavy lifting to make it a practical tool.<p>Related: I work on Souper (<a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;souper">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;souper</a>).<p>Feel free to reach out if anyone has questions!</div><br/></div></div><div id="36118634" class="c"><input type="checkbox" id="c-36118634" checked=""/><div class="controls bullet"><span class="by">ipnon</span><span>|</span><a href="#36118984">prev</a><span>|</span><a href="#36118751">next</a><span>|</span><label class="collapse" for="c-36118634">[-]</label><label class="expand" for="c-36118634">[3 more]</label></div><br/><div class="children"><div class="content">Jetbrains was hiring mathematicians working on homotopy type theory to do something similar if I recall correctly. The idea is that HTT can be used to generate equivalent programs to that which is in your buffer and do something like superoptimization. Maybe I am hallucinating.</div><br/><div id="36118823" class="c"><input type="checkbox" id="c-36118823" checked=""/><div class="controls bullet"><span class="by">lambdaxymox</span><span>|</span><a href="#36118634">parent</a><span>|</span><a href="#36118751">next</a><span>|</span><label class="collapse" for="c-36118823">[-]</label><label class="expand" for="c-36118823">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about superoptimization, but JetBrains does have a HoTT-based language and proof assistant called Arend for doing mathematics in.</div><br/><div id="36119436" class="c"><input type="checkbox" id="c-36119436" checked=""/><div class="controls bullet"><span class="by">bmc7505</span><span>|</span><a href="#36118634">root</a><span>|</span><a href="#36118823">parent</a><span>|</span><a href="#36118751">next</a><span>|</span><label class="collapse" for="c-36119436">[-]</label><label class="expand" for="c-36119436">[1 more]</label></div><br/><div class="children"><div class="content">Is superoptimization related to supercompilation, or are these unrelated compiler optimization techniques? From what I have read, it seems like Turchin [1] et al. are trying to prove equality using some sort of algebraic rewriting system (i.e., the &quot;intensional&quot; approach), whereas superoptimization uses an extensional technique to first try proving disequality by testing on a small set of inputs, then applies formal verification to the remaining candidates.<p>Massalin (1987) [2] calls the first phase &quot;probabilistic execution&quot; and claims that nearly all of the functions which pass the PE test also pass the more rigorous Boolean verification test. Can you give any insight into the benefits of TT over more &quot;automated&quot; optimizations? I am curious if MLTT&#x2F;HoTT is more suitable for certain compiler optimizations or offers additional expressive power for proving equivalence, or is the benefit mostly ergonomics?<p>[1]: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;5956.5957" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;5956.5957</a><p>[2]: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;36177.36194" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;36177.36194</a></div><br/></div></div></div></div></div></div><div id="36118751" class="c"><input type="checkbox" id="c-36118751" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36118634">prev</a><span>|</span><a href="#36118523">next</a><span>|</span><label class="collapse" for="c-36118751">[-]</label><label class="expand" for="c-36118751">[5 more]</label></div><br/><div class="children"><div class="content">If anyone&#x27;s interested in non-toy usage, there&#x27;s the souper project as well <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;souper">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;souper</a><p>It&#x27;s a shame it&#x27;s a bit hard to actually build these days. Its target is people working on compilers, not end users. But there are some odd cases where I&#x27;d really like to use it myself, like trying to get speedup in llama.cpp.</div><br/><div id="36118939" class="c"><input type="checkbox" id="c-36118939" checked=""/><div class="controls bullet"><span class="by">fooker</span><span>|</span><a href="#36118751">parent</a><span>|</span><a href="#36118523">next</a><span>|</span><label class="collapse" for="c-36118939">[-]</label><label class="expand" for="c-36118939">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting idea.<p>Are llama.cpp (and similar targets) made into standalone C++ source files without dependencies doing the heavy lifting?</div><br/><div id="36119299" class="c"><input type="checkbox" id="c-36119299" checked=""/><div class="controls bullet"><span class="by">HanClinto</span><span>|</span><a href="#36118751">root</a><span>|</span><a href="#36118939">parent</a><span>|</span><a href="#36119515">next</a><span>|</span><label class="collapse" for="c-36119299">[-]</label><label class="expand" for="c-36119299">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s the idea of the project.<p>One can now compile against cuBLAS and other GPU libraries to help take some of the load, but the core of the project is indeed to run on the CPU and do all of the work without dependencies.</div><br/></div></div><div id="36119515" class="c"><input type="checkbox" id="c-36119515" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#36118751">root</a><span>|</span><a href="#36118939">parent</a><span>|</span><a href="#36119299">prev</a><span>|</span><a href="#36118523">next</a><span>|</span><label class="collapse" for="c-36119515">[-]</label><label class="expand" for="c-36119515">[2 more]</label></div><br/><div class="children"><div class="content">Is llama performance not basically bound by the memory hierarchy?</div><br/><div id="36120157" class="c"><input type="checkbox" id="c-36120157" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#36118751">root</a><span>|</span><a href="#36119515">parent</a><span>|</span><a href="#36118523">next</a><span>|</span><label class="collapse" for="c-36120157">[-]</label><label class="expand" for="c-36120157">[1 more]</label></div><br/><div class="children"><div class="content">Bound by: yes. Currently restricted by: possibly not. For example the performance difference between clang 11 and 15 compiled llama.cpp is ~10% (I tested a while ago, can&#x27;t remember the exact number)</div><br/></div></div></div></div></div></div></div></div><div id="36118523" class="c"><input type="checkbox" id="c-36118523" checked=""/><div class="controls bullet"><span class="by">divan</span><span>|</span><a href="#36118751">prev</a><span>|</span><a href="#36118659">next</a><span>|</span><label class="collapse" for="c-36118523">[-]</label><label class="expand" for="c-36118523">[1 more]</label></div><br/><div class="children"><div class="content">How about &quot;cognitive superoptimizer&quot; – find the optimal version of the code for human comprehension?<p>First try - get every permutation, feed to some stable code-oriented LLM, ask to explain code and measure number of words.</div><br/></div></div><div id="36118659" class="c"><input type="checkbox" id="c-36118659" checked=""/><div class="controls bullet"><span class="by">EliasWatson</span><span>|</span><a href="#36118523">prev</a><span>|</span><a href="#36118385">next</a><span>|</span><label class="collapse" for="c-36118659">[-]</label><label class="expand" for="c-36118659">[4 more]</label></div><br/><div class="children"><div class="content">It would be interesting to modify this for optimizing BrainF programs.
It has a very simple instruction set and there are lots of example programs available.<p>To avoid generating useless things like &quot;++--&quot;, you could have the optimizer generate instructions that are translated to BrainF operations.
So instead of &quot;&gt;&gt;&gt;--&quot;, the optimizer would generate &quot;Move +3; Add -2&quot;.</div><br/><div id="36118897" class="c"><input type="checkbox" id="c-36118897" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#36118659">parent</a><span>|</span><a href="#36118385">next</a><span>|</span><label class="collapse" for="c-36118897">[-]</label><label class="expand" for="c-36118897">[3 more]</label></div><br/><div class="children"><div class="content">there might not be that many opportunities to optimize brainfuck programs as the instruction set of the brainfuck virtual machine is so simple. arithmetic is unary, and staying within the brainfuck virtual machine doesn&#x27;t provide a way to do any better than unary arithmetic.<p>on another hand, there are many opportunities for optimization when compiling brainfuck to an actual real world instruction set<p>e.g. suppose in your program you want to load the integer 36 into the current cell<p>a naive way to do this is to increment 36 times, e.g. `++++++++++++++++++++++++++++++++++++`.<p>if you can&#x27;t guarantee that the initial value of the current cell is zero, then you could zero it first: `[-]++++++++++++++++++++++++++++++++++++`<p>if we&#x27;re optimizing for code size, not instruction count, we could express this as a more complex, compact program: `[-]&gt;[-]++++++[-&lt;++++++&gt;]&lt;`  -- assuming it is OK to use the cell one to the right of the pointer as working storage.  this will run slower than the less compact naive program as it executes more instructions.<p>if compiling to some reasonable instruction set, there&#x27;s likely a single non-BF instruction that lets you load the constant 36 into a register.<p>extra credit: implementing the optimising brainfuck-to-something compiler in brainfuck itself</div><br/><div id="36121684" class="c"><input type="checkbox" id="c-36121684" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#36118659">root</a><span>|</span><a href="#36118897">parent</a><span>|</span><a href="#36120286">next</a><span>|</span><label class="collapse" for="c-36121684">[-]</label><label class="expand" for="c-36121684">[1 more]</label></div><br/><div class="children"><div class="content">&gt; arithmetic is unary, and staying within the brainfuck virtual machine doesn&#x27;t provide a way to do any better than unary arithmetic.<p>It won’t be efficient (but who cares about that in a true Turing machine?), but you can do binary&#x2F;octal&#x2F;decimal&#x2F;whatever, using a series of cells each containing a number in the right range.<p>As an optimization, you can postpone any carries until you want to compare or print such numbers. Addition would ‘just’ loop over the cells in the numbers to be added, adding cells pairwise. For example, binary 11001 + 10101 would yield 21102.</div><br/></div></div><div id="36120286" class="c"><input type="checkbox" id="c-36120286" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#36118659">root</a><span>|</span><a href="#36118897">parent</a><span>|</span><a href="#36121684">prev</a><span>|</span><a href="#36118385">next</a><span>|</span><label class="collapse" for="c-36120286">[-]</label><label class="expand" for="c-36120286">[1 more]</label></div><br/><div class="children"><div class="content">Just as an exercise, you could use brainfuck with genetic algorithms and evolve the program that you want, then try to play with the fitness function to squeeze down whatever you don&#x27;t want (code size, instruction set, etc...).<p>Then you could try to superoptimize yourself a solution and compare how close the evolved program was to the superoptimized program.<p>Could also be interesting with other esoteric languages like befunge or malbolge.</div><br/></div></div></div></div></div></div><div id="36118385" class="c"><input type="checkbox" id="c-36118385" checked=""/><div class="controls bullet"><span class="by">twoodfin</span><span>|</span><a href="#36118659">prev</a><span>|</span><a href="#36118989">next</a><span>|</span><label class="collapse" for="c-36118385">[-]</label><label class="expand" for="c-36118385">[4 more]</label></div><br/><div class="children"><div class="content">I’m curious: Has there been any research on optimization in the opposite direction? Start with the most naively implemented correct function—a giant switch&#x2F;nested if covering all possible inputs—and transform it piecewise in a correctness-preserving manner?</div><br/><div id="36118947" class="c"><input type="checkbox" id="c-36118947" checked=""/><div class="controls bullet"><span class="by">retrac</span><span>|</span><a href="#36118385">parent</a><span>|</span><a href="#36118893">next</a><span>|</span><label class="collapse" for="c-36118947">[-]</label><label class="expand" for="c-36118947">[1 more]</label></div><br/><div class="children"><div class="content">A similar problem comes up in digital design.  Behaviour is often specified in terms of exhaustive truth tables, perhaps tables that were generated automatically, from a hardware description language.  While such a table can be directly translated into a circuit, doing so in a naive fashion is potentially extremely non-optimal.  Optimizing it is a hard problem.  Everything has been tried, from exhaustive search (suitable only for small numbers of terms), to rule-based fuzzy backtracking searches, to in recent years, deep learning.  But at least when I was in school a couple decades ago, the best known algorithm was still a person playing with the terms on graph paper, rearranging them until patterns emerged: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Karnaugh_map" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Karnaugh_map</a><p>As I understand it, there are recent advances in SAT solvers giving practical algorithms for much larger numbers of terms, but I&#x27;m much behind the state of the art at this point.</div><br/></div></div><div id="36118893" class="c"><input type="checkbox" id="c-36118893" checked=""/><div class="controls bullet"><span class="by">boothby</span><span>|</span><a href="#36118385">parent</a><span>|</span><a href="#36118947">prev</a><span>|</span><a href="#36118433">next</a><span>|</span><label class="collapse" for="c-36118893">[-]</label><label class="expand" for="c-36118893">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done this.  In my experience it ends up stuck in local minima from which there are no obvious correctness-preserving improvements.  Add Monte Carlo to escape valleys and this mode of exploration is still too timid to find anything close to optimal.<p>When you find a truly optimal solution, you end up with the least satisfying proof of correctness: &quot;Here&#x27;s this this inscrutable formula; I verified that it produces the right output for all possible inputs.&quot;</div><br/></div></div><div id="36118433" class="c"><input type="checkbox" id="c-36118433" checked=""/><div class="controls bullet"><span class="by">UncleMeat</span><span>|</span><a href="#36118385">parent</a><span>|</span><a href="#36118893">prev</a><span>|</span><a href="#36118989">next</a><span>|</span><label class="collapse" for="c-36118433">[-]</label><label class="expand" for="c-36118433">[1 more]</label></div><br/><div class="children"><div class="content">Mostly yes. There is a lot of research on taking arbitrary programs and distilling constraints and invariants out of them or doing various forms of function simplification.</div><br/></div></div></div></div><div id="36118989" class="c"><input type="checkbox" id="c-36118989" checked=""/><div class="controls bullet"><span class="by">whiterock</span><span>|</span><a href="#36118385">prev</a><span>|</span><a href="#36118752">next</a><span>|</span><label class="collapse" for="c-36118989">[-]</label><label class="expand" for="c-36118989">[2 more]</label></div><br/><div class="children"><div class="content">This reminds of an undergrad paper I once wrote in which I showed that binary functions in n variables need asymptotically not more (and seldom less) than 2^n&#x2F;n boolean gates.</div><br/><div id="36120880" class="c"><input type="checkbox" id="c-36120880" checked=""/><div class="controls bullet"><span class="by">throw345d605c</span><span>|</span><a href="#36118989">parent</a><span>|</span><a href="#36118752">next</a><span>|</span><label class="collapse" for="c-36120880">[-]</label><label class="expand" for="c-36120880">[1 more]</label></div><br/><div class="children"><div class="content">Is this published anywhere?</div><br/></div></div></div></div><div id="36118752" class="c"><input type="checkbox" id="c-36118752" checked=""/><div class="controls bullet"><span class="by">harerazer</span><span>|</span><a href="#36118989">prev</a><span>|</span><a href="#36118394">next</a><span>|</span><label class="collapse" for="c-36118752">[-]</label><label class="expand" for="c-36118752">[2 more]</label></div><br/><div class="children"><div class="content">This is essentially calculating the Kolmogorov complexity of whatever the final state of memory wrt to the constrained assembly (and giving the associated program). Since the any program in the constrained assembly always halts, this is possible a la brute force.<p>It also doesn&#x27;t seem particularly interesting because it doesn&#x27;t allow the programs to get input. Obviously that makes things much more difficult wrt to proving program equivalence.</div><br/><div id="36119101" class="c"><input type="checkbox" id="c-36119101" checked=""/><div class="controls bullet"><span class="by">manasij7479</span><span>|</span><a href="#36118752">parent</a><span>|</span><a href="#36118394">next</a><span>|</span><label class="collapse" for="c-36119101">[-]</label><label class="expand" for="c-36119101">[1 more]</label></div><br/><div class="children"><div class="content">Input&#x27;s and other side effects are not too tricky to handle.<p>In most cases, you just slice the program to isolate pure computation, and just optimize that.<p>Most traditional compiler optimizations stick to that as well, the exceptions to this rule are carefully engineered.</div><br/></div></div></div></div><div id="36118394" class="c"><input type="checkbox" id="c-36118394" checked=""/><div class="controls bullet"><span class="by">gxt</span><span>|</span><a href="#36118752">prev</a><span>|</span><a href="#36118400">next</a><span>|</span><label class="collapse" for="c-36118394">[-]</label><label class="expand" for="c-36118394">[1 more]</label></div><br/><div class="children"><div class="content">There are surely ways to further constraint the set of programs to test, ie anything that output something not in the expected outcome should probably be an early return. I&#x27;d love for more work to be poured into this concept. There might be low hanging fruits and who knows an LLVM pass somewhere not to far in the distant future.</div><br/></div></div><div id="36118400" class="c"><input type="checkbox" id="c-36118400" checked=""/><div class="controls bullet"><span class="by">jakewins</span><span>|</span><a href="#36118394">prev</a><span>|</span><a href="#36118503">next</a><span>|</span><label class="collapse" for="c-36118400">[-]</label><label class="expand" for="c-36118400">[3 more]</label></div><br/><div class="children"><div class="content">I think you would enjoy applying dynamic programming to this problem!<p>I have a simple example, starting from a “generate all possible combinations” python function, here: <a href="https:&#x2F;&#x2F;tech.davis-hansson.com&#x2F;p&#x2F;price-wars.html" rel="nofollow">https:&#x2F;&#x2F;tech.davis-hansson.com&#x2F;p&#x2F;price-wars.html</a></div><br/><div id="36119140" class="c"><input type="checkbox" id="c-36119140" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#36118400">parent</a><span>|</span><a href="#36118974">next</a><span>|</span><label class="collapse" for="c-36119140">[-]</label><label class="expand" for="c-36119140">[1 more]</label></div><br/><div class="children"><div class="content">Or the Dijkstra&#x27;s algorithm, which is a form of dynamic programming.<p>To solve the superoptimization problem, imagine every possible memory state as a node in a graph, and each instruction as an edge between two states, the superoptimized program is the shortest path between the starting state and the end state.<p>You can even use A* which is very similar to Dijkstra&#x27;s algorithm, but with a sense of direction, materialized by a heuristic function that estimates how close we are to the goal. Here, a simple heuristic could be the number of memory locations that are different to the goal divided by two, that because each instruction changes at most two memory locations.<p>Of course, dynamic programming is a space-time trade-off, so memory consumption is something to consider.</div><br/></div></div><div id="36118974" class="c"><input type="checkbox" id="c-36118974" checked=""/><div class="controls bullet"><span class="by">jmholla</span><span>|</span><a href="#36118400">parent</a><span>|</span><a href="#36119140">prev</a><span>|</span><a href="#36118503">next</a><span>|</span><label class="collapse" for="c-36118974">[-]</label><label class="expand" for="c-36118974">[1 more]</label></div><br/><div class="children"><div class="content">Why did you use the term dynamic programming programming when referring to the memorization part? The term of art, dynamic programming, is at play here but refers to the initial design of breaking up the problem into recursive sub-problems.</div><br/></div></div></div></div><div id="36118503" class="c"><input type="checkbox" id="c-36118503" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#36118400">prev</a><span>|</span><a href="#36118410">next</a><span>|</span><label class="collapse" for="c-36118503">[-]</label><label class="expand" for="c-36118503">[1 more]</label></div><br/><div class="children"><div class="content">Seems like the superoptimizer search graph would be a very good subject for machine learning algorithms? Are where any good AI superoptimizers out there?</div><br/></div></div><div id="36118410" class="c"><input type="checkbox" id="c-36118410" checked=""/><div class="controls bullet"><span class="by">Xeoncross</span><span>|</span><a href="#36118503">prev</a><span>|</span><a href="#36119380">next</a><span>|</span><label class="collapse" for="c-36118410">[-]</label><label class="expand" for="c-36118410">[1 more]</label></div><br/><div class="children"><div class="content">Have superoptimizers been run against math formulas? Seems like the quickest way to find holes in modern encryption.</div><br/></div></div><div id="36119380" class="c"><input type="checkbox" id="c-36119380" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#36118410">prev</a><span>|</span><a href="#36119210">next</a><span>|</span><label class="collapse" for="c-36119380">[-]</label><label class="expand" for="c-36119380">[1 more]</label></div><br/><div class="children"><div class="content">I thought was impossible somehow?
Something something Barry&#x27;s Paradox...?</div><br/></div></div><div id="36119210" class="c"><input type="checkbox" id="c-36119210" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#36119380">prev</a><span>|</span><a href="#36118961">next</a><span>|</span><label class="collapse" for="c-36119210">[-]</label><label class="expand" for="c-36119210">[1 more]</label></div><br/><div class="children"><div class="content">There is (long abandoned tho) a GNU superoptimiser that supports multiple hardware architectures including HP PA-RISC, Motorola 68k and 88k, Intel i960 amongst others – <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;superopt&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;superopt&#x2F;</a><p>It is based on the exhaustive search with backtracking, kind of what Prolog is best for, and given a function that takes an input vector of integers, it attempts to find the most optimal instruction sequence that produces an output integer.</div><br/></div></div><div id="36118372" class="c"><input type="checkbox" id="c-36118372" checked=""/><div class="controls bullet"><span class="by">c7DJTLrn</span><span>|</span><a href="#36118961">prev</a><span>|</span><label class="collapse" for="c-36118372">[-]</label><label class="expand" for="c-36118372">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found GPT to be pretty good at cleaning up code. I&#x27;ve pasted in isolated blocks of code, asked it to tidy it up, and it often has nice suggestions.<p>There&#x27;s a feature coming to Copilot where you can select code in-editor and prompt on it directly.</div><br/><div id="36118415" class="c"><input type="checkbox" id="c-36118415" checked=""/><div class="controls bullet"><span class="by">UncleMeat</span><span>|</span><a href="#36118372">parent</a><span>|</span><label class="collapse" for="c-36118415">[-]</label><label class="expand" for="c-36118415">[7 more]</label></div><br/><div class="children"><div class="content">Superoptimization has absolutely nothing to do with what GPT is doing. It doesn&#x27;t happen in source and produces actually optimal code sequences (against some cost model) rather than doing some refactoring or tidying.</div><br/><div id="36118513" class="c"><input type="checkbox" id="c-36118513" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#36118372">root</a><span>|</span><a href="#36118415">parent</a><span>|</span><label class="collapse" for="c-36118513">[-]</label><label class="expand" for="c-36118513">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;d hate to suggest that the comment about cleaning up code with GPT was written by GPT and posted without that crucial editing step.  But the number of people who are using that tool instead of their wetware is certainly growing.</div><br/><div id="36118963" class="c"><input type="checkbox" id="c-36118963" checked=""/><div class="controls bullet"><span class="by">c7DJTLrn</span><span>|</span><a href="#36118372">root</a><span>|</span><a href="#36118513">parent</a><span>|</span><label class="collapse" for="c-36118963">[-]</label><label class="expand" for="c-36118963">[5 more]</label></div><br/><div class="children"><div class="content">GPT&#x27;s knowledge isn&#x27;t up to date enough to know about the feature I mentioned. No, it wasn&#x27;t written by GPT. It wasn&#x27;t clear to me from the post that superoptimisation pertains to optimisation of machine code only.</div><br/><div id="36121525" class="c"><input type="checkbox" id="c-36121525" checked=""/><div class="controls bullet"><span class="by">sbierwagen</span><span>|</span><a href="#36118372">root</a><span>|</span><a href="#36118963">parent</a><span>|</span><a href="#36119272">next</a><span>|</span><label class="collapse" for="c-36121525">[-]</label><label class="expand" for="c-36121525">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Good evening, GPT. Can you tell me what superoptimization is, in relation to computer programming?<p>ChatGPT:
Good evening! Superoptimization, in the context of computer programming, refers to the process of finding the optimal or most efficient implementation of a piece of code for a given task or problem. It involves automatically searching through all possible combinations of instructions and their arrangements to produce the most efficient code in terms of speed, memory usage, or other specific criteria.<p>Superoptimization is typically performed by specialized tools or algorithms known as superoptimizers. These tools analyze the code and exhaustively explore the space of all possible code sequences, considering both the individual instructions and their order. The goal is to find the shortest or fastest sequence of instructions that achieves the desired output or behavior.<p>Superoptimization is a computationally expensive process since it involves searching a vast solution space. Due to the exponential nature of the problem, it is often only feasible for small code snippets or performance-critical sections of code. Additionally, superoptimization may not always be practical or necessary because modern compilers and optimization techniques can often generate highly efficient code automatically.<p>Superoptimization techniques have been primarily used in areas such as compiler design, code generation, and optimizing low-level code for specific architectures. They can be beneficial in situations where manual optimization is not feasible or when there is a need for extreme performance optimizations in constrained environments.</div><br/></div></div><div id="36119272" class="c"><input type="checkbox" id="c-36119272" checked=""/><div class="controls bullet"><span class="by">UncleMeat</span><span>|</span><a href="#36118372">root</a><span>|</span><a href="#36118963">parent</a><span>|</span><a href="#36121525">prev</a><span>|</span><a href="#36119045">next</a><span>|</span><label class="collapse" for="c-36119272">[-]</label><label class="expand" for="c-36119272">[2 more]</label></div><br/><div class="children"><div class="content">&gt; GPT&#x27;s knowledge isn&#x27;t up to date enough to know about the feature I mentioned.<p>Superoptimization has been around for well over a decade.</div><br/><div id="36121654" class="c"><input type="checkbox" id="c-36121654" checked=""/><div class="controls bullet"><span class="by">KingMob</span><span>|</span><a href="#36118372">root</a><span>|</span><a href="#36119272">parent</a><span>|</span><a href="#36119045">next</a><span>|</span><label class="collapse" for="c-36121654">[-]</label><label class="expand" for="c-36121654">[1 more]</label></div><br/><div class="children"><div class="content">Decades, even. The term was coined by a 1987 paper.</div><br/></div></div></div></div><div id="36119045" class="c"><input type="checkbox" id="c-36119045" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#36118372">root</a><span>|</span><a href="#36118963">parent</a><span>|</span><a href="#36119272">prev</a><span>|</span><label class="collapse" for="c-36119045">[-]</label><label class="expand" for="c-36119045">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t pertain to the optimization of machine code only, but the distinguishing feature between optimization and superoptimization is that superoptimization produces an absolute shortest possible program given an instruction set.  GPT doesn&#x27;t do that.  Copilot won&#x27;t do that.  Whatever cleanup feature you&#x27;re describing is a non-sequitur here.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>