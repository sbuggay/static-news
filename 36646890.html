<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688893260983" as="style"/><link rel="stylesheet" href="styles.css?v=1688893260983"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://castle-engine.io/why_pascal">Why use Pascal?</a> <span class="domain">(<a href="https://castle-engine.io">castle-engine.io</a>)</span></div><div class="subtext"><span>mariuz</span> | <span>210 comments</span></div><br/><div><div id="36647915" class="c"><input type="checkbox" id="c-36647915" checked=""/><div class="controls bullet"><span class="by">squarefoot</span><span>|</span><a href="#36648967">next</a><span>|</span><label class="collapse" for="c-36647915">[-]</label><label class="expand" for="c-36647915">[3 more]</label></div><br/><div class="children"><div class="content">Many people using Delphi back in the day will probably already know Lazarus, which is essentially an Open Source recreation which runs and compiles <i>natively</i> pretty much everywhere, Raspberry PI and similar ARM boards included.
Installing libraries however can be tedious, therefore FpcUp and later FpcUpDeluxe were created to automate the task of installing the IDE along with other modules and some quite interesting addons.<p><a href="https:&#x2F;&#x2F;wiki.freepascal.org&#x2F;fpcupdeluxe" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.freepascal.org&#x2F;fpcupdeluxe</a><p>Here&#x27;s a quick&amp;dirty instrument panel widgets demo I just put together using some free widgets available with FpcUpDeluxe.<p><a href="https:&#x2F;&#x2F;ibb.co&#x2F;9bchx7T" rel="nofollow noreferrer">https:&#x2F;&#x2F;ibb.co&#x2F;9bchx7T</a><p>FpcUpDeluxe does work also under Alpine Linux (get the musl version on the releases page), which opens possibilities for adding instrumentation panels to very small systems. All code is compiled native on various platforms, and runs fast: no interpreters, no web browsers etc.</div><br/><div id="36652370" class="c"><input type="checkbox" id="c-36652370" checked=""/><div class="controls bullet"><span class="by">brnt</span><span>|</span><a href="#36647915">parent</a><span>|</span><a href="#36648967">next</a><span>|</span><label class="collapse" for="c-36652370">[-]</label><label class="expand" for="c-36652370">[2 more]</label></div><br/><div class="children"><div class="content">&gt; free widgets<p>Are you saying there are paid widgets? I use Qt5, which comes with more widgets than I know what to do with. Are the ones that come with Lazarus limited?<p>Last time I tried Lazarus (and Delphi), Unicode was difficult. Everything seemed to assume ASCII.</div><br/><div id="36652647" class="c"><input type="checkbox" id="c-36652647" checked=""/><div class="controls bullet"><span class="by">chadcmulligan</span><span>|</span><a href="#36647915">root</a><span>|</span><a href="#36652370">parent</a><span>|</span><a href="#36648967">next</a><span>|</span><label class="collapse" for="c-36652647">[-]</label><label class="expand" for="c-36652647">[1 more]</label></div><br/><div class="children"><div class="content">Unicode was fixed in 2007 (or thereabouts). I think thats a problem with Delphi (and Lazarus) everyone compares it to when they used Delphi (in 1999) it didn&#x27;t do this cool thing that languages in 2023 do, however modern day Delphi does a lot more stuff. It&#x27;s worth a revisit, I use it with the skia graphics engine to create multi platform apps very easily.</div><br/></div></div></div></div></div></div><div id="36648967" class="c"><input type="checkbox" id="c-36648967" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#36647915">prev</a><span>|</span><a href="#36647579">next</a><span>|</span><label class="collapse" for="c-36648967">[-]</label><label class="expand" for="c-36648967">[21 more]</label></div><br/><div class="children"><div class="content">I used to use Delphi&#x2F;Pascal as my main language.  In the last decade or two I have been on a bit of a journey looking for a language that feels right to me.  I used Haxe for quite a while but I felt Haxe fell into the trap of &#x27;There&#x27;s a Macro for that&#x27; (Macros can do anything, but ultimately enough macros make everyone programming in their own macro augmented language).    JavaScript developed decent improvements (but could still use more) and I do a lot of stuff there now.<p>A year or three ago I was writing some 8-bit AVR code and I gave FreePascal another go.  I found it extremely enjoyable.  I got to use the newer features and it felt like a truly modern language.  Part of what made it so enjoyable was that because I was coding for a tiny space I was not using most of the standard library and just building custom specific code as I went.  This meant I did not have the layers of backwards compatible namespace clutter that FreePascal has accumulated over many years (TList, TFPList, TFPGList, TFPGObjectList etc.  My main pain point was that the compiler did not allow constant floating point expressions on a target without an FPU(or emulation).  Since these could be done at compile time it would have been nice.<p>Having worked in other spaces, I do now find the inability to define variables mid function to be restrictive, being able to have sub-function scoping is nice too. Begin End vs { }  doesn&#x27;t really bother me.   I think I now prefer case sensitive languages and would rather not have letter prefixes on types.  I think this is more due to the advancements in editors than anything.  Syntax highlighting and active linting can remove text clutter by moving information into separate domains.<p>I would probably be quite enthusiastic for a descendant language of FreePascal that had a clean slate approach.  A new standard library that used the newest features as first class citizens.   Maybe when I retire I&#x27;ll have a go at it.</div><br/><div id="36649019" class="c"><input type="checkbox" id="c-36649019" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648967">parent</a><span>|</span><a href="#36647579">next</a><span>|</span><label class="collapse" for="c-36649019">[-]</label><label class="expand" for="c-36649019">[20 more]</label></div><br/><div class="children"><div class="content">&gt; Begin End vs { } doesn&#x27;t really bother me.<p>but they don&#x27;t really mean the same thing - {} defines a local scope, begin...end doesn&#x27;t.</div><br/><div id="36649779" class="c"><input type="checkbox" id="c-36649779" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36649019">parent</a><span>|</span><a href="#36649170">next</a><span>|</span><label class="collapse" for="c-36649779">[-]</label><label class="expand" for="c-36649779">[9 more]</label></div><br/><div class="children"><div class="content">They are both used to define blocks. Eg Begin … End in for loops <a href="https:&#x2F;&#x2F;wiki.freepascal.org&#x2F;For" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.freepascal.org&#x2F;For</a><p>From what I recall, Pascal doesn’t support variables scoped within a specific block. But then neither do some languages with C-style curly braces too.<p>So {} and Begin…End are pretty much the same thing.<p>BASIC (and Visual Basic especially) often get a lot of criticism for their syntax but the End Thing style block terminator was very clear.<p>It’s a pity that the only popular alternative to C-style braces is Python because I do think ALGOL-style syntax has a lot more going for it than people give it credit.</div><br/><div id="36652310" class="c"><input type="checkbox" id="c-36652310" checked=""/><div class="controls bullet"><span class="by">noobermin</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36649779">parent</a><span>|</span><a href="#36650336">next</a><span>|</span><label class="collapse" for="c-36652310">[-]</label><label class="expand" for="c-36652310">[2 more]</label></div><br/><div class="children"><div class="content">The most C-style language is C  and it does have variables scoped to a block, I believe. The same for C++.</div><br/><div id="36652661" class="c"><input type="checkbox" id="c-36652661" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36652310">parent</a><span>|</span><a href="#36650336">next</a><span>|</span><label class="collapse" for="c-36652661">[-]</label><label class="expand" for="c-36652661">[1 more]</label></div><br/><div class="children"><div class="content">I was using “C-style” with respect to {} syntax for compound statements rather than language specification because the GP is discussing language grammar.</div><br/></div></div></div></div><div id="36650336" class="c"><input type="checkbox" id="c-36650336" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36649779">parent</a><span>|</span><a href="#36652310">prev</a><span>|</span><a href="#36649170">next</a><span>|</span><label class="collapse" for="c-36650336">[-]</label><label class="expand" for="c-36650336">[6 more]</label></div><br/><div class="children"><div class="content">i do not think you understand the concept of scope.</div><br/><div id="36652091" class="c"><input type="checkbox" id="c-36652091" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36650336">parent</a><span>|</span><a href="#36651045">next</a><span>|</span><label class="collapse" for="c-36652091">[-]</label><label class="expand" for="c-36652091">[2 more]</label></div><br/><div class="children"><div class="content">I’ve written a few compilers in my time so I have some idea about scoping rules ;)<p>As I and other have already said, it depends on the specific language. Some languages scope local variables at the function level (irrespective of {} or Begin End), and other languages scope local variables inside the containing {} or Begin and End block.<p>In that regard {} and Begin End serve identical purposes of defining a local execution block and then it’s up to the language or dialect, or sometimes even the compiler authors, to decide upon the rules of variable scoping.<p>What you’re doing here is conflating syntax grammar with deeper rules about a languages compiler or specification.<p>To come back to your original point, Delphi does support variable scoping inside Begin End blocks. I don’t know if FreePascal also does but older dialects of Pascal didn’t because of the original intent of Pascal being a single pass compiler. Equally, not all languages that have C-like curly braces support variable scoping in the way you’re trying to describe. JavaScript originally didn’t and had to create a whole new keyword to add it (a little like what Delphi did, funny enough). My own shell scripting language very intentionally doesn’t support scoping despite having curly braces.<p>As for inlining other contexts like functions, classes, etc, it has been a while since I’ve written any Pascal so I can’t recall the nesting rules here. But like with our discussion about variables, it’s more a question of whether the specification and&#x2F;or compiler has support rather than a quirk of the Begin End grammar that forbids it — just as is the case with {} too.</div><br/><div id="36652849" class="c"><input type="checkbox" id="c-36652849" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36652091">parent</a><span>|</span><a href="#36651045">next</a><span>|</span><label class="collapse" for="c-36652849">[-]</label><label class="expand" for="c-36652849">[1 more]</label></div><br/><div class="children"><div class="content">this post is specifically about pascal - my comment about {} vs begin...end was intended for that context. pascal has no way of defining variables within a local scope - it was added to delphi as a kludge much later. i admit i should have said something like &quot;... {} in C and C++&quot;.</div><br/></div></div></div></div><div id="36651045" class="c"><input type="checkbox" id="c-36651045" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36650336">parent</a><span>|</span><a href="#36652091">prev</a><span>|</span><a href="#36650835">next</a><span>|</span><label class="collapse" for="c-36651045">[-]</label><label class="expand" for="c-36651045">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps you&#x27;re being a little short here? Explaining what you mean would go a long way to fostering good will.</div><br/><div id="36652014" class="c"><input type="checkbox" id="c-36652014" checked=""/><div class="controls bullet"><span class="by">countrymile</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36651045">parent</a><span>|</span><a href="#36650835">next</a><span>|</span><label class="collapse" for="c-36652014">[-]</label><label class="expand" for="c-36652014">[1 more]</label></div><br/><div class="children"><div class="content">More of these replies on HN please!</div><br/></div></div></div></div><div id="36650835" class="c"><input type="checkbox" id="c-36650835" checked=""/><div class="controls bullet"><span class="by">ipcress_file</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36650336">parent</a><span>|</span><a href="#36651045">prev</a><span>|</span><a href="#36649170">next</a><span>|</span><label class="collapse" for="c-36650835">[-]</label><label class="expand" for="c-36650835">[1 more]</label></div><br/><div class="children"><div class="content">Would you explain it? I&#x27;m self taught, have programmed in Python, C, and am looking at Pascal, and I don&#x27;t understand the difference.</div><br/></div></div></div></div></div></div><div id="36649299" class="c"><input type="checkbox" id="c-36649299" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36649019">parent</a><span>|</span><a href="#36649170">prev</a><span>|</span><a href="#36651029">next</a><span>|</span><label class="collapse" for="c-36649299">[-]</label><label class="expand" for="c-36649299">[7 more]</label></div><br/><div class="children"><div class="content">Depends a lot on the language does not it?</div><br/><div id="36649332" class="c"><input type="checkbox" id="c-36649332" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36649299">parent</a><span>|</span><a href="#36651029">next</a><span>|</span><label class="collapse" for="c-36649332">[-]</label><label class="expand" for="c-36649332">[6 more]</label></div><br/><div class="children"><div class="content">we are talking about pascal</div><br/><div id="36650395" class="c"><input type="checkbox" id="c-36650395" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36649332">parent</a><span>|</span><a href="#36650013">next</a><span>|</span><label class="collapse" for="c-36650395">[-]</label><label class="expand" for="c-36650395">[2 more]</label></div><br/><div class="children"><div class="content">you are probably talking about C++ vs pascal. But you should be talking C.</div><br/><div id="36650416" class="c"><input type="checkbox" id="c-36650416" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36650395">parent</a><span>|</span><a href="#36650013">next</a><span>|</span><label class="collapse" for="c-36650416">[-]</label><label class="expand" for="c-36650416">[1 more]</label></div><br/><div class="children"><div class="content">no, c and c++ have basically similar rules for the scope of variables, with the regard to braces</div><br/></div></div></div></div><div id="36650013" class="c"><input type="checkbox" id="c-36650013" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36649332">parent</a><span>|</span><a href="#36650395">prev</a><span>|</span><a href="#36651029">next</a><span>|</span><label class="collapse" for="c-36650013">[-]</label><label class="expand" for="c-36650013">[3 more]</label></div><br/><div class="children"><div class="content">About pas Al in comparison to languages using {} for blocks, where some have block scoping and some don&#x27;t.</div><br/><div id="36650369" class="c"><input type="checkbox" id="c-36650369" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36650013">parent</a><span>|</span><a href="#36651029">next</a><span>|</span><label class="collapse" for="c-36650369">[-]</label><label class="expand" for="c-36650369">[2 more]</label></div><br/><div class="children"><div class="content">no idea what you are talking about here - what is &quot;pas Al&quot; - post an example of what you mean.</div><br/><div id="36651253" class="c"><input type="checkbox" id="c-36651253" checked=""/><div class="controls bullet"><span class="by">saladdressing</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36650369">parent</a><span>|</span><a href="#36651029">next</a><span>|</span><label class="collapse" for="c-36651253">[-]</label><label class="expand" for="c-36651253">[1 more]</label></div><br/><div class="children"><div class="content">Pascal. It’s a typo.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36651029" class="c"><input type="checkbox" id="c-36651029" checked=""/><div class="controls bullet"><span class="by">clouddrover</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36649019">parent</a><span>|</span><a href="#36649299">prev</a><span>|</span><a href="#36647579">next</a><span>|</span><label class="collapse" for="c-36651029">[-]</label><label class="expand" for="c-36651029">[2 more]</label></div><br/><div class="children"><div class="content">They do: <a href="https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Alexandria&#x2F;en&#x2F;Inline_Variable_Declaration" rel="nofollow noreferrer">https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Alexandria&#x2F;en&#x2F;Inli...</a></div><br/><div id="36651230" class="c"><input type="checkbox" id="c-36651230" checked=""/><div class="controls bullet"><span class="by">beached_whale</span><span>|</span><a href="#36648967">root</a><span>|</span><a href="#36651029">parent</a><span>|</span><a href="#36647579">next</a><span>|</span><label class="collapse" for="c-36651230">[-]</label><label class="expand" for="c-36651230">[1 more]</label></div><br/><div class="children"><div class="content">without that, one can use a repeat until loop to simulate I think</div><br/></div></div></div></div></div></div></div></div><div id="36647579" class="c"><input type="checkbox" id="c-36647579" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648967">prev</a><span>|</span><a href="#36647233">next</a><span>|</span><label class="collapse" for="c-36647579">[-]</label><label class="expand" for="c-36647579">[8 more]</label></div><br/><div class="children"><div class="content">I used Delph professionaly for several years in the 90s, and liked it, but really got tired with Borland (and subsequent owners) mis-managing the product and the language, as did Anders Hejlsberg, who left Borland for Microsoft, where he created C# - IMHO a much better language &amp; architecture to invest your time in.</div><br/><div id="36650561" class="c"><input type="checkbox" id="c-36650561" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#36647579">parent</a><span>|</span><a href="#36647233">next</a><span>|</span><label class="collapse" for="c-36650561">[-]</label><label class="expand" for="c-36650561">[7 more]</label></div><br/><div class="children"><div class="content">Reliably deploying C# desktop app is total nightmare in comparison to single exe generated by Delphi&#x27;s &#x2F; Lazarus.</div><br/><div id="36651205" class="c"><input type="checkbox" id="c-36651205" checked=""/><div class="controls bullet"><span class="by">mycall</span><span>|</span><a href="#36647579">root</a><span>|</span><a href="#36650561">parent</a><span>|</span><a href="#36651054">next</a><span>|</span><label class="collapse" for="c-36651205">[-]</label><label class="expand" for="c-36651205">[2 more]</label></div><br/><div class="children"><div class="content">C# can generate single executables now.</div><br/><div id="36652777" class="c"><input type="checkbox" id="c-36652777" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36647579">root</a><span>|</span><a href="#36651205">parent</a><span>|</span><a href="#36651054">next</a><span>|</span><label class="collapse" for="c-36652777">[-]</label><label class="expand" for="c-36652777">[1 more]</label></div><br/><div class="children"><div class="content">Kind of.<p>Depends if we are speaking about Xamarin&#x2F;Mono AOT, .NET Native, Native AOT or IL2CPP.<p>Each of those ones has plus and minus, none of them allow to pick a random .NET application and just compile it straight into native code.</div><br/></div></div></div></div><div id="36651054" class="c"><input type="checkbox" id="c-36651054" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36647579">root</a><span>|</span><a href="#36650561">parent</a><span>|</span><a href="#36651205">prev</a><span>|</span><a href="#36647233">next</a><span>|</span><label class="collapse" for="c-36651054">[-]</label><label class="expand" for="c-36651054">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found .Net deployments to be rock solid and easy. What problems do you hit?</div><br/><div id="36651562" class="c"><input type="checkbox" id="c-36651562" checked=""/><div class="controls bullet"><span class="by">wsc981</span><span>|</span><a href="#36647579">root</a><span>|</span><a href="#36651054">parent</a><span>|</span><a href="#36647233">next</a><span>|</span><label class="collapse" for="c-36651562">[-]</label><label class="expand" for="c-36651562">[3 more]</label></div><br/><div class="children"><div class="content">A couple of months ago I started working at a company that (mainly) develops C# libraries.<p>The pipeline to deploy is complicated. Using a tool like ILMerge to combine DLLs into a single DLL (to prevent DLL hell issues). Using Babel to obfuscate the code base. Using nuspecs to create a Nuget package from the DLLs and various metadata. Signing the DLLs with some certificate. Then, if native stuff is included, also ensure the Nuget package can be deployed on all supported architectures. Probably some more stuff.<p>Setting up a pipeline in Azure devops for a product I am working on, for the company, is already taking me a week and will probably take another couple of days to complete. But at least it’s a one-time task.</div><br/><div id="36652062" class="c"><input type="checkbox" id="c-36652062" checked=""/><div class="controls bullet"><span class="by">zx14</span><span>|</span><a href="#36647579">root</a><span>|</span><a href="#36651562">parent</a><span>|</span><a href="#36647233">next</a><span>|</span><label class="collapse" for="c-36652062">[-]</label><label class="expand" for="c-36652062">[2 more]</label></div><br/><div class="children"><div class="content">Well, a lot of those requirements are highly bespoke to your task and to your team.<p>My C# pipelines and C# apps are far easier to package and deploy than my Python apps for example. And, as you said, the pipeline is normally a one time cost.</div><br/><div id="36652210" class="c"><input type="checkbox" id="c-36652210" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36647579">root</a><span>|</span><a href="#36652062">parent</a><span>|</span><a href="#36647233">next</a><span>|</span><label class="collapse" for="c-36652210">[-]</label><label class="expand" for="c-36652210">[1 more]</label></div><br/><div class="children"><div class="content">Comparing to Python is not exactly fair. I don&#x27;t think there are any languages that have a worse deployment experience.<p>How does it compare to Go or Rust?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36647233" class="c"><input type="checkbox" id="c-36647233" checked=""/><div class="controls bullet"><span class="by">stevekemp</span><span>|</span><a href="#36647579">prev</a><span>|</span><a href="#36647662">next</a><span>|</span><label class="collapse" for="c-36647233">[-]</label><label class="expand" for="c-36647233">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;m finding myself using Pascal for fun these days due to resource constraints.<p>The old release of Borland&#x27;s Turbo Pascal, version 3.00A, runs under CP&#x2F;M and provides an editor, compiler, and libraries all under 64k.<p>It&#x27;s fast enough to use interactively, and produces code that is good-enough to implement low-level utilities, simple games, and other random hacks.<p>I&#x27;ve not used Pascal on anything larger, or more modern, but I have to say that my recent experience has been rewarding enough that I wouldn&#x27;t rule it out!</div><br/><div id="36647282" class="c"><input type="checkbox" id="c-36647282" checked=""/><div class="controls bullet"><span class="by">netule</span><span>|</span><a href="#36647233">parent</a><span>|</span><a href="#36647560">next</a><span>|</span><label class="collapse" for="c-36647282">[-]</label><label class="expand" for="c-36647282">[3 more]</label></div><br/><div class="children"><div class="content">Turbo Pascal and later Delphi were the first time when a programming language really spoke to me. Eventually, I went the C and C++ route, but I’ve always had a desire to return to more expressive languages.<p>I had no idea that there was still a modern Pascal implementation, so I may just have to get reacquainted with my first love.</div><br/><div id="36647778" class="c"><input type="checkbox" id="c-36647778" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#36647233">root</a><span>|</span><a href="#36647282">parent</a><span>|</span><a href="#36647560">next</a><span>|</span><label class="collapse" for="c-36647778">[-]</label><label class="expand" for="c-36647778">[2 more]</label></div><br/><div class="children"><div class="content">I’ve also a had an early acquaintance with Borland TP 7.0 at the time C99 was already around, and Pascal felt rather clumsy in comparison. The strong typing, the lack of a preprocessor, the verbosity in data declarations, the small set of available libraries just made my early programming self consider C superior.</div><br/><div id="36648341" class="c"><input type="checkbox" id="c-36648341" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#36647233">root</a><span>|</span><a href="#36647778">parent</a><span>|</span><a href="#36647560">next</a><span>|</span><label class="collapse" for="c-36648341">[-]</label><label class="expand" for="c-36648341">[1 more]</label></div><br/><div class="children"><div class="content">Nowadays you look at pascal and see go without braces.</div><br/></div></div></div></div></div></div><div id="36647560" class="c"><input type="checkbox" id="c-36647560" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36647233">parent</a><span>|</span><a href="#36647282">prev</a><span>|</span><a href="#36649035">next</a><span>|</span><label class="collapse" for="c-36647560">[-]</label><label class="expand" for="c-36647560">[5 more]</label></div><br/><div class="children"><div class="content">Check out Free Pascal (FP) if you haven&#x27;t already. It supports many platforms.<p>You can check on their site if it supports CP&#x2F;M if you need that. 
I would not be surprised if it did.<p>The TUI IDE is very similar to Turbo Pascal, and lightning fast. The language has a lot more (advanced) features than Turbo Pascal, but you don&#x27;t have to use them if you don&#x27;t want to.<p>The generated binaries were also very small, similar to C, when I did a quick test of it on Windows, some time ago. Under 50 or 60 KB for a simple hello world program.</div><br/><div id="36652622" class="c"><input type="checkbox" id="c-36652622" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36647233">root</a><span>|</span><a href="#36647560">parent</a><span>|</span><a href="#36647634">next</a><span>|</span><label class="collapse" for="c-36652622">[-]</label><label class="expand" for="c-36652622">[1 more]</label></div><br/><div class="children"><div class="content">&#x27;under 60 kb&#x27; for a cp&#x2F;m machine is like &#x27;under 60 gb&#x27; for the laptop you&#x27;re probably using</div><br/></div></div><div id="36647634" class="c"><input type="checkbox" id="c-36647634" checked=""/><div class="controls bullet"><span class="by">stevekemp</span><span>|</span><a href="#36647233">root</a><span>|</span><a href="#36647560">parent</a><span>|</span><a href="#36652622">prev</a><span>|</span><a href="#36649035">next</a><span>|</span><label class="collapse" for="c-36647634">[-]</label><label class="expand" for="c-36647634">[3 more]</label></div><br/><div class="children"><div class="content">Sadly it seems not to be available for such systems.<p>Though for reference compiling my sample &quot;Hello World&quot; script on TP gives me a &quot;hello.com&quot; file which is 8320 bytes.  64k is as much memory as I have on the machine, so if it were 50-60k I&#x27;d be worried there would be no space left for anything else!</div><br/><div id="36648332" class="c"><input type="checkbox" id="c-36648332" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36647233">root</a><span>|</span><a href="#36647634">parent</a><span>|</span><a href="#36647812">next</a><span>|</span><label class="collapse" for="c-36648332">[-]</label><label class="expand" for="c-36648332">[1 more]</label></div><br/><div class="children"><div class="content">Free Pascal has support for Z80 which <i>might</i> work with some CP&#x2F;M systems (AFAIK Z80 is backwards compatible with 8080 and some CP&#x2F;M systems used Z80). You need to compile the compiler from source but it apparently can target the ZX Spectrum, so with some modification it might be able to target CP&#x2F;M too.</div><br/></div></div><div id="36647812" class="c"><input type="checkbox" id="c-36647812" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36647233">root</a><span>|</span><a href="#36647634">parent</a><span>|</span><a href="#36648332">prev</a><span>|</span><a href="#36649035">next</a><span>|</span><label class="collapse" for="c-36647812">[-]</label><label class="expand" for="c-36647812">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah, I realised that just after hitting submit. Had worked on almost as low powered machines a while, much earlier, as a hobby. Sorry for leading you down the wrong track.<p>It looks like the broad cross-platform capabilities of FP are mainly for modern machines and platforms, even if low powered like the RPi.</div><br/></div></div></div></div></div></div><div id="36649035" class="c"><input type="checkbox" id="c-36649035" checked=""/><div class="controls bullet"><span class="by">brightsize</span><span>|</span><a href="#36647233">parent</a><span>|</span><a href="#36647560">prev</a><span>|</span><a href="#36647662">next</a><span>|</span><label class="collapse" for="c-36649035">[-]</label><label class="expand" for="c-36649035">[2 more]</label></div><br/><div class="children"><div class="content">Oh Pascal!, oh the nostalgia. I saved up the princely sum of $80-$100 back in TRS-80 Model III days to buy the Pascal 80 package, the New Classics version, which was basically a proto-IDE, and a pretty sweet one at the time. <a href="http:&#x2F;&#x2F;www.trs-80.org&#x2F;pascal-80&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.trs-80.org&#x2F;pascal-80&#x2F;</a>
I recall it being a huge step up from the M-III BASIC dev environment and the games and utilities I wrote ran well enough in the 48K of RAM that was available. I wonder what became of the Pascal-80 codebase? Not that it would be any better than the modern tools available for retro hardware, probably far worse. Oh yeah, &quot;Oh Pascal!&quot; was the book from which I learned the language, and I doubt there were many other options, as this predated Pascal&#x27;s commercial use by quite a few years.</div><br/><div id="36650988" class="c"><input type="checkbox" id="c-36650988" checked=""/><div class="controls bullet"><span class="by">alwillis</span><span>|</span><a href="#36647233">root</a><span>|</span><a href="#36649035">parent</a><span>|</span><a href="#36647662">next</a><span>|</span><label class="collapse" for="c-36650988">[-]</label><label class="expand" for="c-36650988">[1 more]</label></div><br/><div class="children"><div class="content">Anyone can check out <i>Oh! Pascal!</i> [1] just like a library book.<p>Even now, it&#x27;s one of the best introductory programming books for any programming language.<p>[1]: <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ohpascal0000coop&#x2F;mode&#x2F;2up" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ohpascal0000coop&#x2F;mode&#x2F;2up</a></div><br/></div></div></div></div></div></div><div id="36647662" class="c"><input type="checkbox" id="c-36647662" checked=""/><div class="controls bullet"><span class="by">tangus</span><span>|</span><a href="#36647233">prev</a><span>|</span><a href="#36648791">next</a><span>|</span><label class="collapse" for="c-36647662">[-]</label><label class="expand" for="c-36647662">[36 more]</label></div><br/><div class="children"><div class="content">I disagree with some of their reasons.<p>Modern: Object Pascal isn&#x27;t a modern language. It was modern in 1998, maybe, but it hasn&#x27;t evolved much since then. Latest big change was the addition of generics, behind almost any other language.<p>Fast: FPC doesn&#x27;t generate particularly fast code, and the nature of OP objects doesn&#x27;t help with locality. It&#x27;s faster than scripting languages, but generally slower than AOT compiled languages, even those with GC.<p>On the other hand, the ecosystem is great. There are lots of good libraries and tools (the most remarkable one being Lazarus, the Delphi clone). In my experience, people working with FPC or Delphi don&#x27;t care much about modernizing the language or things like that, the just get things done (TM). I don&#x27;t see the language being attractive to new coders though, so I don&#x27;t know what its future will be...</div><br/><div id="36652186" class="c"><input type="checkbox" id="c-36652186" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#36647662">parent</a><span>|</span><a href="#36648263">next</a><span>|</span><label class="collapse" for="c-36652186">[-]</label><label class="expand" for="c-36652186">[1 more]</label></div><br/><div class="children"><div class="content">I also think the modern part is exaggerated here. Object Pascal was had cutting edge features and developer experience in the 1990s, but I think it&#x27;s hard to see it this way nowadays.<p>There are two big features that one expects in a &quot;modern&quot; language that are missing in object pascal:<p>1. Some sort of automatic memory management that prevents memory leaks and dangling pointers. Modern languages usually have GC, automatic reference counting (like Swift or Python) or some form of static analysis (like the Rust borrow checker) - Zig is probably the only outlier here, but it does have better memory safety tooling (like defer). Object Pascal really feels like going back to C++ as it was during the 1990s and early 2000s, before smart pointers and later move semantics caught on. If I remember correctly, COM interfaces, but they carry the COM baggage and nobody is using interfaces for everything.<p>2. A package manager that is isolated (not impacted by the global environment), supports specifying dependency version in a configuration file and supports repeatable builds with lockfiles. fppkg doesn&#x27;t seem to go that far.<p>There are other features that you could argue for I guess, like type inference, simplified expression syntax, asynchronous I&#x2F;O and more, but they would be more controversial.<p>I don&#x27;t think I can honestly call Object Pascal a modern language, and it&#x27;s sad, since I still have a warm place in my heart for Pascal.</div><br/></div></div><div id="36648263" class="c"><input type="checkbox" id="c-36648263" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36647662">parent</a><span>|</span><a href="#36652186">prev</a><span>|</span><a href="#36648241">next</a><span>|</span><label class="collapse" for="c-36648263">[-]</label><label class="expand" for="c-36648263">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Latest big change was the addition of generics, behind almost any other language.<p>FPC added generics 17 years ago, that is far from recent. Also i&#x27;d say that anonymous functions and function references (closures) are better candidates for &quot;big change that was added recently&quot;.<p>&gt; FPC doesn&#x27;t generate particularly fast code, and the nature of OP objects doesn&#x27;t help with locality. It&#x27;s faster than scripting languages, but generally slower than AOT compiled languages, even those with GC.<p>In practice the performance is fine and you can actually optimize the code as much as you need for any hotspots you find - it can be a bit more of a PITA if you use the &quot;high level&quot; classes compared to C++ but it isn&#x27;t impossible.<p>Though if you <i>really</i> want performance out of the box with minimal effort from your side, there is a new LLVM backend. You need to compile the compiler from source to enable it as the entire runtime library, FCL, etc need to be built with the LLVM backend, but that takes only a couple of minutes. On the other hand the compiler becomes much slower (and IMO the difference in performance isn&#x27;t worth it).</div><br/></div></div><div id="36648241" class="c"><input type="checkbox" id="c-36648241" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36647662">parent</a><span>|</span><a href="#36648263">prev</a><span>|</span><a href="#36652791">next</a><span>|</span><label class="collapse" for="c-36648241">[-]</label><label class="expand" for="c-36648241">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Fast: FPC doesn&#x27;t generate particularly fast code, and the nature of OP objects doesn&#x27;t help with locality. It&#x27;s faster than scripting languages, but generally slower than AOT compiled languages, even those with GC.<p>You&#x27;re selling it short.<p>Firstly, as the other poster downthread pointed out, it benchmarked as fast as C++ in the past.<p>Secondly, it&#x27;s main use is local gui apps, and there&#x27;s nothing I&#x27;ve seen, including C# gui apps and have gui apps, that even comes close to how snappy it is.<p>So I am curious what benchmark you used to determine that it&#x27;s about 50 times slower than it actually is.</div><br/><div id="36648516" class="c"><input type="checkbox" id="c-36648516" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648241">parent</a><span>|</span><a href="#36652791">next</a><span>|</span><label class="collapse" for="c-36648516">[-]</label><label class="expand" for="c-36648516">[8 more]</label></div><br/><div class="children"><div class="content">&gt; <i>it benchmarked as fast as C++ in the past</i><p>Does this mean it&#x27;s no longer as fast as C++ today? Do you have specific benchmark results?</div><br/><div id="36652798" class="c"><input type="checkbox" id="c-36652798" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648516">parent</a><span>|</span><a href="#36648574">next</a><span>|</span><label class="collapse" for="c-36652798">[-]</label><label class="expand" for="c-36652798">[1 more]</label></div><br/><div class="children"><div class="content">Delphi and C++ Builder share the same compiler backed.<p>Nowadays it is based on LLVM.</div><br/></div></div><div id="36648574" class="c"><input type="checkbox" id="c-36648574" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648516">parent</a><span>|</span><a href="#36652798">prev</a><span>|</span><a href="#36652791">next</a><span>|</span><label class="collapse" for="c-36648574">[-]</label><label class="expand" for="c-36648574">[6 more]</label></div><br/><div class="children"><div class="content">You can find some in Debian benchmark game. In general FPC generated code is around 1.5 to 2 times slower the fastest entry (often C++). Note though that this is with FPC&#x27;s own code generator and there is a new LLVM backend in the development version (FPC&#x27;s own code generator is the default and will always be, the LLVM backend is for those who really want it and is <i>much</i> slower).<p>I&#x27;d expect synthetic benchmarks like those in the Debian benchmark game to be closer to C++&#x27;s performance with the LLVM backend.</div><br/><div id="36648863" class="c"><input type="checkbox" id="c-36648863" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648574">parent</a><span>|</span><a href="#36652791">next</a><span>|</span><label class="collapse" for="c-36648863">[-]</label><label class="expand" for="c-36648863">[5 more]</label></div><br/><div class="children"><div class="content">When I had a look at the CLBG results last time the code generated by FreePascal was even about three to four times slower than C&#x2F;C++; but the benchmark rules are not particularly well suited for fair comparison (some code is obviously written with inside knowledge of the particular compiler&#x2F;version and not what you usually see for the given language, and the Pascal code likely includes range and overflow checks which make it slower compared to a language without these, etc.). The LLVM backend is not officially supported by FP and doesn&#x27;t support all platforms as far as I know; and unfortunately micro benchmarks are usually not representative for the daily overall performance of an application; the Are-we-fast-yet benchmark suite would be better in this regard.<p>Anyway, I would be interested in why FP benchmarked as fast as C++ in the past, but no longer today.</div><br/><div id="36648926" class="c"><input type="checkbox" id="c-36648926" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648863">parent</a><span>|</span><a href="#36652791">next</a><span>|</span><label class="collapse" for="c-36648926">[-]</label><label class="expand" for="c-36648926">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The LLVM backend is not officially supported by FP<p>It used to be a separate project but these days is part of the main development branch. Though indeed the OS and CPU support is very limited.<p>Also i agree about the micro benchmark comparison, they tend to exaggerate differences. FWIW in my own programs i never found Free Pascal&#x27;s code generator to be inadequate.<p>I do not remember the exact difference but last year i did compile my 3D game engine with the LLVM backend and the difference was small enough for me to decide that i don&#x27;t want to bother with the <i>much</i> slower compile times.</div><br/><div id="36648985" class="c"><input type="checkbox" id="c-36648985" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648926">parent</a><span>|</span><a href="#36652791">next</a><span>|</span><label class="collapse" for="c-36648985">[-]</label><label class="expand" for="c-36648985">[3 more]</label></div><br/><div class="children"><div class="content">I read other comments of people claiming the code generated by the LLVM backend was less than factor 1.5 faster than the one generated by the original backend, which is not worth the effort (and the humongous overhead and additional dependencies) from my point of view; but I&#x27;m still trying to find information about the specific optimizations done in the current FP compiler.</div><br/><div id="36649172" class="c"><input type="checkbox" id="c-36649172" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648985">parent</a><span>|</span><a href="#36652791">next</a><span>|</span><label class="collapse" for="c-36649172">[-]</label><label class="expand" for="c-36649172">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m still trying to find information about the specific optimizations done in the current FP compiler.<p>AFAIK there isn&#x27;t any explicit documentation but the &quot;toptimizerswitch&quot; and &quot;twpoptimizerswitch&quot; (the latter is for whole program optimizations) types in the compiler define the available optimizations in globtype.pas and have the following values:<p><pre><code>    cs_opt_level1,cs_opt_level2,cs_opt_level3,cs_opt_level4,
    cs_opt_regvar,cs_opt_uncertain,cs_opt_size,cs_opt_stackframe,
    cs_opt_peephole,cs_opt_loopunroll,cs_opt_tailrecursion,cs_opt_nodecse,
    cs_opt_nodedfa,cs_opt_loopstrength,cs_opt_scheduler,cs_opt_autoinline,
    cs_useebp,cs_userbp,cs_opt_reorder_fields,cs_opt_fastmath,
    cs_opt_dead_values,cs_opt_remove_empty_proc,cs_opt_constant_propagate,
    cs_opt_dead_store_eliminate,cs_opt_forcenostackframe,
    cs_opt_use_load_modify_store,cs_opt_unused_para,cs_opt_consts,
    cs_opt_forloop

    cs_wpo_devirtualize_calls,cs_wpo_optimize_vmts,cs_wpo_symbol_liveness
</code></pre>
level1&#x2F;2&#x2F;3&#x2F;4 are basically collections for some of the above and are enabled for -On where n is 1 to 4. You can enable optimizations explicitly with the -OoXXX (for per-module optimizations) and -OwXXX (for whole program optimizations). The -io and -iw parameters can be used to obtain the available names for these.<p>I think the names are more or less self-explanatory, at least for the most part (not sure what &quot;uncertain&quot; does... which i think is appropriate :-P).<p>Some brief documentation (though <i>very</i> brief) is available in the programmer&#x27;s guide:<p><a href="https:&#x2F;&#x2F;www.freepascal.org&#x2F;docs-html&#x2F;current&#x2F;prog&#x2F;progch11.html#x235-24900011" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.freepascal.org&#x2F;docs-html&#x2F;current&#x2F;prog&#x2F;progch11.h...</a></div><br/><div id="36649221" class="c"><input type="checkbox" id="c-36649221" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36649172">parent</a><span>|</span><a href="#36652791">next</a><span>|</span><label class="collapse" for="c-36649221">[-]</label><label class="expand" for="c-36649221">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the hints. I was already concerned that I would have to analyze the source code directly myself, and so I started to build tools for this purpose (<a href="https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;FreePascal">https:&#x2F;&#x2F;github.com&#x2F;rochus-keller&#x2F;FreePascal</a>).<p>I read somewhere that there are issues with higher optimization levels. Can you confirm that?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36652791" class="c"><input type="checkbox" id="c-36652791" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36647662">parent</a><span>|</span><a href="#36648241">prev</a><span>|</span><a href="#36648049">next</a><span>|</span><label class="collapse" for="c-36652791">[-]</label><label class="expand" for="c-36652791">[1 more]</label></div><br/><div class="children"><div class="content">The Object Pascal as originally created by Apple, not.<p>The Object Pascal adopted by Borland, and evolved into Delphi, is on par with plenty of C++ capabilities, given the Delphi&#x2F;C++ Builder symbiotic relationship.</div><br/></div></div><div id="36648049" class="c"><input type="checkbox" id="c-36648049" checked=""/><div class="controls bullet"><span class="by">yeputons</span><span>|</span><a href="#36647662">parent</a><span>|</span><a href="#36652791">prev</a><span>|</span><a href="#36647776">next</a><span>|</span><label class="collapse" for="c-36648049">[-]</label><label class="expand" for="c-36648049">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s faster than scripting languages, but generally slower than AOT compiled languages, even those with GC.<p>Not sure about FPC, but Delphi 7 was on par with C++ ten years ago in competitive programming, that is about 2-3 times faster than Java. By competitive programming I mean very short (1-3 seconds per execution max, so any JIT is at disadvantage), CPU-bound single-threaded heavily algorithmic computation on mostly default compiler&#x2F;runtime settings with no external libraries or ability to tweak. The common knowledge was: you either use C++&#x2F;Pascal, or use Java and occasionally rewrite your 200-300 line solution to C++ if you get &quot;time limit exceeded&quot; error, and it passes with flying colors.</div><br/><div id="36648377" class="c"><input type="checkbox" id="c-36648377" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648049">parent</a><span>|</span><a href="#36647776">next</a><span>|</span><label class="collapse" for="c-36648377">[-]</label><label class="expand" for="c-36648377">[1 more]</label></div><br/><div class="children"><div class="content">reasons why Delphi was&#x2F;is a strong option for CP:<p>1. Fast compilation enables edit-compile-run workflow. Fast iteration enables solving CP problems faster.<p>2. Native dynamic arrays, native String type<p>3. Easy to learn language for middle&#x2F;high schoolers.<p>4. Usefulness for outside CP, for example I created GUI programs in Delphi for clients and earned $$$ while in 8th grade, right after I was done with competition season.</div><br/></div></div></div></div><div id="36647776" class="c"><input type="checkbox" id="c-36647776" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36647662">parent</a><span>|</span><a href="#36648049">prev</a><span>|</span><a href="#36647701">next</a><span>|</span><label class="collapse" for="c-36647776">[-]</label><label class="expand" for="c-36647776">[14 more]</label></div><br/><div class="children"><div class="content">the greatest difference btw Pascal and C++ is developer experience.<p>Pascal uses a single-pass LL(1) compiler, which allows you to compile in milliseconds. Pascal enables REPL-like experience where you can Edit-&gt;Compile-&gt;Run in less than a second.<p>C&#x2F;C++ with macros and slower compilation times is worse developer experience, at least it was the reason for me to learn Pascal instead of C and Delphi instead of C++</div><br/><div id="36647895" class="c"><input type="checkbox" id="c-36647895" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36647776">parent</a><span>|</span><a href="#36648536">next</a><span>|</span><label class="collapse" for="c-36647895">[-]</label><label class="expand" for="c-36647895">[8 more]</label></div><br/><div class="children"><div class="content">Just to add more context: Niklaus Wirth&#x27;s foresight was to design Pascal&#x27;s syntax to allow a single-pass compile. But it took more than 15 years until we <i>actually had</i> a blazingly fast single-pass compiler and that is totally Anders Hejlsberg&#x27;s merit.</div><br/><div id="36648885" class="c"><input type="checkbox" id="c-36648885" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36647895">parent</a><span>|</span><a href="#36649756">next</a><span>|</span><label class="collapse" for="c-36648885">[-]</label><label class="expand" for="c-36648885">[6 more]</label></div><br/><div class="children"><div class="content">Every so often a thread pops up about Turbo Pascal and I&#x27;m astonished as to how nice an IDE you could fit onto a 64K CP&#x2F;M system. (See also comments above&#x2F;below.)</div><br/><div id="36649022" class="c"><input type="checkbox" id="c-36649022" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648885">parent</a><span>|</span><a href="#36649756">next</a><span>|</span><label class="collapse" for="c-36649022">[-]</label><label class="expand" for="c-36649022">[5 more]</label></div><br/><div class="children"><div class="content">Oh, it was very very nice. I still miss it today sometimes. Here are a few highlights:<p>- Pressing F1 gave you reliably context sensitive help and the help content was really well put together.<p>- The debugger was great and was basically what we now  know from Eclipse or IntelliJ and completely not like gdb. It had the same keyboard shortcuts for stepping as IntelliJ still has today.<p>- Computers in the 90s really did not support more than one display, but there was a weird trick that allowed you to connect one color and one monochrome monitor. Turbo Pascal fully supported that and could display the app on the color display while you saw the debugger on the monochrome one. This was before Windows and GUIs, everything was fullscreen. Without that there was no way to see debugger and app at the same time.<p>- The editor was so good that I preferred it over a word processor even for writing prose.</div><br/><div id="36649186" class="c"><input type="checkbox" id="c-36649186" checked=""/><div class="controls bullet"><span class="by">Andrew_nenakhov</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36649022">parent</a><span>|</span><a href="#36649376">next</a><span>|</span><label class="collapse" for="c-36649186">[-]</label><label class="expand" for="c-36649186">[1 more]</label></div><br/><div class="children"><div class="content">The best thing about built-in help was that it not only contained documentation of a function, but usually a short example code. That was extremely helpful and I relied on it a lot.</div><br/></div></div><div id="36649376" class="c"><input type="checkbox" id="c-36649376" checked=""/><div class="controls bullet"><span class="by">virgulino</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36649022">parent</a><span>|</span><a href="#36649186">prev</a><span>|</span><a href="#36649789">next</a><span>|</span><label class="collapse" for="c-36649376">[-]</label><label class="expand" for="c-36649376">[2 more]</label></div><br/><div class="children"><div class="content">Back in the days of Turbo Pascal 5.5 I had a secondary monitor, a monochrome orange phosphor, connected to an EGA card, I think. The main screen was VGA. Two monitors provided a huge productivity gain, with common and cheap hardware, and it was super cool. Turbo Pascal was the only software I used that could display on the second monitor. Sometimes I miss seeing everything in orange.</div><br/><div id="36649520" class="c"><input type="checkbox" id="c-36649520" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36649376">parent</a><span>|</span><a href="#36649789">next</a><span>|</span><label class="collapse" for="c-36649520">[-]</label><label class="expand" for="c-36649520">[1 more]</label></div><br/><div class="children"><div class="content">I had a VGA and a Hercules card and  it&#x27;s probably hard to relay how super cool that was at a time and in an environment where computers alone were pure magic to most people. Then there were these kids, like us, that could not only use these magic programs but could control and manipulate them from a second screen:-)</div><br/></div></div></div></div><div id="36649789" class="c"><input type="checkbox" id="c-36649789" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36649022">parent</a><span>|</span><a href="#36649376">prev</a><span>|</span><a href="#36649756">next</a><span>|</span><label class="collapse" for="c-36649789">[-]</label><label class="expand" for="c-36649789">[1 more]</label></div><br/><div class="children"><div class="content">TP IDE was indeed magical. Except for one pain point, from an emacs user POV, no extensibility. You can&#x27;t tweak the ergonomics so you&#x27;re stuck with what the devs put in. It was 99% perfect but that broke me out of it.</div><br/></div></div></div></div></div></div><div id="36649756" class="c"><input type="checkbox" id="c-36649756" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36647895">parent</a><span>|</span><a href="#36648885">prev</a><span>|</span><a href="#36648536">next</a><span>|</span><label class="collapse" for="c-36649756">[-]</label><label class="expand" for="c-36649756">[1 more]</label></div><br/><div class="children"><div class="content">My memory is fuzzy, but even before Hejlsberg magic, Wirth parser was a light and fast (but maybe unreadable) hand coded piece of code.</div><br/></div></div></div></div><div id="36648536" class="c"><input type="checkbox" id="c-36648536" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36647776">parent</a><span>|</span><a href="#36647895">prev</a><span>|</span><a href="#36647701">next</a><span>|</span><label class="collapse" for="c-36648536">[-]</label><label class="expand" for="c-36648536">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Pascal uses a single-pass LL(1)</i><p>No longer the case with the Pascal version used by the game engine.</div><br/><div id="36648964" class="c"><input type="checkbox" id="c-36648964" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648536">parent</a><span>|</span><a href="#36647701">next</a><span>|</span><label class="collapse" for="c-36648964">[-]</label><label class="expand" for="c-36648964">[4 more]</label></div><br/><div class="children"><div class="content">which Pascal compiler is it - Embarcadero or FPC?</div><br/><div id="36649034" class="c"><input type="checkbox" id="c-36649034" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648964">parent</a><span>|</span><a href="#36647701">next</a><span>|</span><label class="collapse" for="c-36649034">[-]</label><label class="expand" for="c-36649034">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the language itself; I currently build a parser for FP 3.2.2 and I need more look-ahead than LL(1) in different parts of the syntax. And it has features which require more than one pass.</div><br/><div id="36651310" class="c"><input type="checkbox" id="c-36651310" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36649034">parent</a><span>|</span><a href="#36647701">next</a><span>|</span><label class="collapse" for="c-36651310">[-]</label><label class="expand" for="c-36651310">[2 more]</label></div><br/><div class="children"><div class="content">One thing this thread seems to forget, Pascal sources do not include literal kilometers of headers compared to C++, and there’s no code in Interface sections either. Every C++ translation unit explodes into a full set of libs at preprocessing phase. One pass or LL(1) is just a cool bonus compared to that.</div><br/><div id="36652534" class="c"><input type="checkbox" id="c-36652534" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36651310">parent</a><span>|</span><a href="#36647701">next</a><span>|</span><label class="collapse" for="c-36652534">[-]</label><label class="expand" for="c-36652534">[1 more]</label></div><br/><div class="children"><div class="content">Delphi and FreePascal have compiler directives and include files quite similar to C, and it&#x27;s commonly used e.g. in the FP source tree, albeit to a lesser extent than in a typical C&#x2F;C++ project.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36647701" class="c"><input type="checkbox" id="c-36647701" checked=""/><div class="controls bullet"><span class="by">Svip</span><span>|</span><a href="#36647662">parent</a><span>|</span><a href="#36647776">prev</a><span>|</span><a href="#36647748">next</a><span>|</span><label class="collapse" for="c-36647701">[-]</label><label class="expand" for="c-36647701">[5 more]</label></div><br/><div class="children"><div class="content">&gt; On the other hand, the ecosystem is great.<p>Hard disagree.  I worked with Pascal for about 10 years, and the lack of modern libraries was a source of frequent frustration, meaning we often had to develop the solutions ourselves, or abandon an idea entirely.</div><br/><div id="36648097" class="c"><input type="checkbox" id="c-36648097" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36647701">parent</a><span>|</span><a href="#36648155">next</a><span>|</span><label class="collapse" for="c-36648097">[-]</label><label class="expand" for="c-36648097">[1 more]</label></div><br/><div class="children"><div class="content">In regards to Delphi there were plenty of them, sold by companies specialised in component libraries.<p>Naturally one had to be willing to pay for them.</div><br/></div></div><div id="36648155" class="c"><input type="checkbox" id="c-36648155" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36647701">parent</a><span>|</span><a href="#36648097">prev</a><span>|</span><a href="#36648660">next</a><span>|</span><label class="collapse" for="c-36648155">[-]</label><label class="expand" for="c-36648155">[2 more]</label></div><br/><div class="children"><div class="content">Yep. Unless it&#x27;s part of a legacy project, or I&#x27;m developing something as a fun experiment, I have no interest in languages that lack modern, robust, stable, up-to-date libraries.</div><br/><div id="36648904" class="c"><input type="checkbox" id="c-36648904" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36648155">parent</a><span>|</span><a href="#36648660">next</a><span>|</span><label class="collapse" for="c-36648904">[-]</label><label class="expand" for="c-36648904">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have no interest in languages that lack modern, robust, stable, up-to-date libraries.<p>I guess JavaScript is out then. ;-)</div><br/></div></div></div></div><div id="36648660" class="c"><input type="checkbox" id="c-36648660" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36647662">root</a><span>|</span><a href="#36647701">parent</a><span>|</span><a href="#36648155">prev</a><span>|</span><a href="#36647748">next</a><span>|</span><label class="collapse" for="c-36648660">[-]</label><label class="expand" for="c-36648660">[1 more]</label></div><br/><div class="children"><div class="content">May we please have a few examples of what&#x27;s missing?</div><br/></div></div></div></div><div id="36647748" class="c"><input type="checkbox" id="c-36647748" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36647662">parent</a><span>|</span><a href="#36647701">prev</a><span>|</span><a href="#36648505">next</a><span>|</span><label class="collapse" for="c-36647748">[-]</label><label class="expand" for="c-36647748">[1 more]</label></div><br/><div class="children"><div class="content">FPC (if my experience with Lazarus is anything to go by) doesn&#x27;t even compile quickly - certainly not compared to the Delphi compiler.</div><br/></div></div><div id="36648505" class="c"><input type="checkbox" id="c-36648505" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36647662">parent</a><span>|</span><a href="#36647748">prev</a><span>|</span><a href="#36648791">next</a><span>|</span><label class="collapse" for="c-36648505">[-]</label><label class="expand" for="c-36648505">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>but generally slower than AOT compiled languages, even those with GC.</i><p>Is this an assessment by experience or do you have specific performance data, e.g. comparing a set of benchmarks with C++? What&#x27;s the difference if checks (range, overflow, etc.) are disabled?</div><br/></div></div></div></div><div id="36648791" class="c"><input type="checkbox" id="c-36648791" checked=""/><div class="controls bullet"><span class="by">sacnoradhq</span><span>|</span><a href="#36647662">prev</a><span>|</span><a href="#36648062">next</a><span>|</span><label class="collapse" for="c-36648791">[-]</label><label class="expand" for="c-36648791">[6 more]</label></div><br/><div class="children"><div class="content">Often overlooked, the Ada embedded ecosystem has advantages of maturity in static analysis, debugging, and target support.</div><br/><div id="36648938" class="c"><input type="checkbox" id="c-36648938" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#36648791">parent</a><span>|</span><a href="#36649081">next</a><span>|</span><label class="collapse" for="c-36648938">[-]</label><label class="expand" for="c-36648938">[1 more]</label></div><br/><div class="children"><div class="content">I always thought that Ada was underrated. Personally I appreciate features like memory safety, a standard concurrency model, support for unit&#x2F;measurement types, and ahead-of-time compilation.<p>Ada&#x27;s Pascal-like syntax seems verbose to me but isn&#x27;t hard to read. And VHDL is based on Ada syntax, perhaps making it easier for people who are working in both languages.<p>Swift seems to check some of those boxes (and adds many other convenient features including closures, automatic reference counting, type inference, etc.) I don&#x27;t know about measurement types, but it seems they should be doable. There doesn&#x27;t seem to be a Swift-like HDL yet though.</div><br/></div></div><div id="36649081" class="c"><input type="checkbox" id="c-36649081" checked=""/><div class="controls bullet"><span class="by">bobajeff</span><span>|</span><a href="#36648791">parent</a><span>|</span><a href="#36648938">prev</a><span>|</span><a href="#36649821">next</a><span>|</span><label class="collapse" for="c-36649081">[-]</label><label class="expand" for="c-36649081">[2 more]</label></div><br/><div class="children"><div class="content">Does Ada support Android and iOS targets yet? Last I checked there didn&#x27;t seem to be any obvious way to build for NDK.</div><br/><div id="36649388" class="c"><input type="checkbox" id="c-36649388" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36648791">root</a><span>|</span><a href="#36649081">parent</a><span>|</span><a href="#36649821">next</a><span>|</span><label class="collapse" for="c-36649388">[-]</label><label class="expand" for="c-36649388">[1 more]</label></div><br/><div class="children"><div class="content">iOS yes: <a href="https:&#x2F;&#x2F;docs.adacore.com&#x2F;gnat_ugx-docs&#x2F;html&#x2F;gnat_ugx&#x2F;gnat_ugx&#x2F;ios_topics.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.adacore.com&#x2F;gnat_ugx-docs&#x2F;html&#x2F;gnat_ugx&#x2F;gnat_ug...</a><p>Never used it though.</div><br/></div></div></div></div><div id="36649821" class="c"><input type="checkbox" id="c-36649821" checked=""/><div class="controls bullet"><span class="by">sigzero</span><span>|</span><a href="#36648791">parent</a><span>|</span><a href="#36649081">prev</a><span>|</span><a href="#36648062">next</a><span>|</span><label class="collapse" for="c-36649821">[-]</label><label class="expand" for="c-36649821">[2 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t the friendliest to get started on macos.</div><br/><div id="36649858" class="c"><input type="checkbox" id="c-36649858" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36648791">root</a><span>|</span><a href="#36649821">parent</a><span>|</span><a href="#36648062">next</a><span>|</span><label class="collapse" for="c-36649858">[-]</label><label class="expand" for="c-36649858">[1 more]</label></div><br/><div class="children"><div class="content">Alire mostly resolves that. It can manage the compilers you have installed. Much better than the situation a few years back.<p><a href="https:&#x2F;&#x2F;alire.ada.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;alire.ada.dev&#x2F;</a></div><br/></div></div></div></div></div></div><div id="36648062" class="c"><input type="checkbox" id="c-36648062" checked=""/><div class="controls bullet"><span class="by">bradley13</span><span>|</span><a href="#36648791">prev</a><span>|</span><a href="#36649118">next</a><span>|</span><label class="collapse" for="c-36648062">[-]</label><label class="expand" for="c-36648062">[13 more]</label></div><br/><div class="children"><div class="content">Why? Old languages must remain around for legacy support. However, it&#x27;s hard to see the point of shoe-horning all those modern features into an old language.<p>I write a lot of Java, and really, almost everything since Java 8 should not have been added. Lambdas, for example, are a kludge in Java.<p>Want modern features? Use a modern language. If you want to stay in the Java ecosystem, for example, you could use Kotlin.<p>I&#x27;m talking about Java only because I haven&#x27;t seen Pascal for literally decades. I last programmed Pascal in the 1980s. Adding that laundry list of features to Pascal is just silly.</div><br/><div id="36648390" class="c"><input type="checkbox" id="c-36648390" checked=""/><div class="controls bullet"><span class="by">renewedrebecca</span><span>|</span><a href="#36648062">parent</a><span>|</span><a href="#36648389">next</a><span>|</span><label class="collapse" for="c-36648390">[-]</label><label class="expand" for="c-36648390">[3 more]</label></div><br/><div class="children"><div class="content"><i>lambdas</i> are a kludge?  Really?  You prefer creating one-method anonymous classes instead?</div><br/><div id="36648547" class="c"><input type="checkbox" id="c-36648547" checked=""/><div class="controls bullet"><span class="by">kagevf</span><span>|</span><a href="#36648062">root</a><span>|</span><a href="#36648390">parent</a><span>|</span><a href="#36648389">next</a><span>|</span><label class="collapse" for="c-36648547">[-]</label><label class="expand" for="c-36648547">[2 more]</label></div><br/><div class="children"><div class="content">I think they meant in terms of how the feature was implemented, not the feature itself.</div><br/><div id="36650352" class="c"><input type="checkbox" id="c-36650352" checked=""/><div class="controls bullet"><span class="by">renewedrebecca</span><span>|</span><a href="#36648062">root</a><span>|</span><a href="#36648547">parent</a><span>|</span><a href="#36648389">next</a><span>|</span><label class="collapse" for="c-36650352">[-]</label><label class="expand" for="c-36650352">[1 more]</label></div><br/><div class="children"><div class="content">Ok, yeah, that&#x27;s true.</div><br/></div></div></div></div></div></div><div id="36648389" class="c"><input type="checkbox" id="c-36648389" checked=""/><div class="controls bullet"><span class="by">maleldil</span><span>|</span><a href="#36648062">parent</a><span>|</span><a href="#36648390">prev</a><span>|</span><a href="#36648100">next</a><span>|</span><label class="collapse" for="c-36648389">[-]</label><label class="expand" for="c-36648389">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Use a modern language. If you want to stay in the Java ecosystem, for example, you could use Kotlin.<p>That&#x27;s easier in Java given how easy it is to interop between languages (see also Clojure). What if I&#x27;m using C++? There&#x27;s no easy upgrade path to anything else.<p>There&#x27;s still value to &quot;shoe-horning all those modern features&quot;. I might not start a project with C++ today, instead choosing a modern language (e.g. Rust) instead. But there are millions of lines of C++ already written that would be improved by modern features (see how C++11 changed the landscape).</div><br/><div id="36652217" class="c"><input type="checkbox" id="c-36652217" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#36648062">root</a><span>|</span><a href="#36648389">parent</a><span>|</span><a href="#36648100">next</a><span>|</span><label class="collapse" for="c-36652217">[-]</label><label class="expand" for="c-36652217">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I might not start a project with C++ today, instead choosing a modern language (e.g. Rust) instead.<p>This would depend on what your constraints and needs are. Rust isn&#x27;t a &quot;modernized C++&quot;, it&#x27;s a language&#x2F;ecosystem with a different set of strengths and weaknesses. You may very well prefer C++ over Rust today.</div><br/></div></div></div></div><div id="36648100" class="c"><input type="checkbox" id="c-36648100" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#36648062">parent</a><span>|</span><a href="#36648389">prev</a><span>|</span><a href="#36648321">next</a><span>|</span><label class="collapse" for="c-36648100">[-]</label><label class="expand" for="c-36648100">[1 more]</label></div><br/><div class="children"><div class="content">Then we have to switch PLs much more often. Seems reasonable to me to add&#x2F;integrate new features that have proven to add a benefit to delay this process.</div><br/></div></div><div id="36648321" class="c"><input type="checkbox" id="c-36648321" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#36648062">parent</a><span>|</span><a href="#36648100">prev</a><span>|</span><a href="#36648104">next</a><span>|</span><label class="collapse" for="c-36648321">[-]</label><label class="expand" for="c-36648321">[3 more]</label></div><br/><div class="children"><div class="content">Java until recently had less going for it than Delphi 15 years ago except the insanely large ecosystem - which trumps everything else, admittedly.<p>Java the language was misguided in its decision to use libraries instead of language features leading to impressive amounts of boilerplate. Yes, you can do everything you can do in Python, Lisp or Haskell. But, you can also do that in brainf*ck, by definition, so the actual complexity of Java solutions is actually higher than a more featured language, because you end up reimplementing all those language features anyway in a slightly broken way or pull in tons of dependencies that do that for you, in either case with added API surface to learn.</div><br/><div id="36648481" class="c"><input type="checkbox" id="c-36648481" checked=""/><div class="controls bullet"><span class="by">deely3</span><span>|</span><a href="#36648062">root</a><span>|</span><a href="#36648321">parent</a><span>|</span><a href="#36648104">next</a><span>|</span><label class="collapse" for="c-36648481">[-]</label><label class="expand" for="c-36648481">[2 more]</label></div><br/><div class="children"><div class="content">&gt; because you end up reimplementing all those language features anyway in a slightly broken way or pull in tons of dependencies that do that for you, in either case with added API surface to learn.<p>I suppose this statement is true for absolutely all programming languages?<p>You have to use libraries in all languages, all libraries is somehow broken because of using unique way to implement functionality, by using any library you have to learn unique API, etc. etc.</div><br/><div id="36648986" class="c"><input type="checkbox" id="c-36648986" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#36648062">root</a><span>|</span><a href="#36648481">parent</a><span>|</span><a href="#36648104">next</a><span>|</span><label class="collapse" for="c-36648986">[-]</label><label class="expand" for="c-36648986">[1 more]</label></div><br/><div class="children"><div class="content">Yes.<p>Except sometimes you don’t have to use libraries because the language just does the right thing out of the box, e.g. go with channels, selects and goroutines. This is what Python’s ‘there should be only one way to do it’ is really about.</div><br/></div></div></div></div></div></div><div id="36648104" class="c"><input type="checkbox" id="c-36648104" checked=""/><div class="controls bullet"><span class="by">thriftwy</span><span>|</span><a href="#36648062">parent</a><span>|</span><a href="#36648321">prev</a><span>|</span><a href="#36649118">next</a><span>|</span><label class="collapse" for="c-36648104">[-]</label><label class="expand" for="c-36648104">[3 more]</label></div><br/><div class="children"><div class="content">Only in the last few years we have a competing JVM language.<p>Scala was a dead end. Clojure was a fad. Rhino&#x2F;JS was very limited in its ambition.<p>Java improvements allowed JVM to stay relevant and fend off DotNet, which is a good thing considering Microsoft&#x27;s history.</div><br/><div id="36650330" class="c"><input type="checkbox" id="c-36650330" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#36648062">root</a><span>|</span><a href="#36648104">parent</a><span>|</span><a href="#36649118">next</a><span>|</span><label class="collapse" for="c-36650330">[-]</label><label class="expand" for="c-36650330">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Scala was a dead end.<p>I&#x27;m sure all the companies, like Microsoft, Twitter, Disney, and basically every bank out there, will be very surprised to hear this.</div><br/><div id="36652811" class="c"><input type="checkbox" id="c-36652811" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36648062">root</a><span>|</span><a href="#36650330">parent</a><span>|</span><a href="#36649118">next</a><span>|</span><label class="collapse" for="c-36652811">[-]</label><label class="expand" for="c-36652811">[1 more]</label></div><br/><div class="children"><div class="content">Where does Microsoft use Scala?<p>Or every bank out there?</div><br/></div></div></div></div></div></div></div></div><div id="36649118" class="c"><input type="checkbox" id="c-36649118" checked=""/><div class="controls bullet"><span class="by">didip</span><span>|</span><a href="#36648062">prev</a><span>|</span><a href="#36651405">next</a><span>|</span><label class="collapse" for="c-36649118">[-]</label><label class="expand" for="c-36649118">[5 more]</label></div><br/><div class="children"><div class="content">Pascal is actually good and perfomant. It was the second language I picked up in high school after Basic.<p>I don’t understand why as an industry we had to regress to Python, Ruby, Java, &amp; Javascript in late 90s &amp; early 2000.</div><br/><div id="36649394" class="c"><input type="checkbox" id="c-36649394" checked=""/><div class="controls bullet"><span class="by">dansalvato</span><span>|</span><a href="#36649118">parent</a><span>|</span><a href="#36651405">next</a><span>|</span><label class="collapse" for="c-36649394">[-]</label><label class="expand" for="c-36649394">[4 more]</label></div><br/><div class="children"><div class="content">I saw a talk that touched on this recently: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Tml94je2edk">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Tml94je2edk</a><p>He explains that dynamically-typed languages like Python, Ruby, and JS became popular in the 90s because they offered a fast feedback loop for website building, and they didn&#x27;t need an IDE or compilers, which were slow (and often not free). It ended up not being worth trading your development time for the performance increase when all your users were connecting via 56k modem anyway.<p>The talk makes a lot of other cool points about how development has changed in the past decade or two, and why the trend is moving back to static typing.</div><br/><div id="36649458" class="c"><input type="checkbox" id="c-36649458" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36649118">root</a><span>|</span><a href="#36649394">parent</a><span>|</span><a href="#36651405">next</a><span>|</span><label class="collapse" for="c-36649458">[-]</label><label class="expand" for="c-36649458">[3 more]</label></div><br/><div class="children"><div class="content">Do not forget Pearl.</div><br/><div id="36649963" class="c"><input type="checkbox" id="c-36649963" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36649118">root</a><span>|</span><a href="#36649458">parent</a><span>|</span><a href="#36651020">next</a><span>|</span><label class="collapse" for="c-36649963">[-]</label><label class="expand" for="c-36649963">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is a gem of a language.<p>Now, I wonder who its mother is?</div><br/></div></div><div id="36651020" class="c"><input type="checkbox" id="c-36651020" checked=""/><div class="controls bullet"><span class="by">unixhero</span><span>|</span><a href="#36649118">root</a><span>|</span><a href="#36649458">parent</a><span>|</span><a href="#36649963">prev</a><span>|</span><a href="#36651405">next</a><span>|</span><label class="collapse" for="c-36651020">[-]</label><label class="expand" for="c-36651020">[1 more]</label></div><br/><div class="children"><div class="content">Perl or Rakudo?</div><br/></div></div></div></div></div></div></div></div><div id="36651405" class="c"><input type="checkbox" id="c-36651405" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#36649118">prev</a><span>|</span><a href="#36647953">next</a><span>|</span><label class="collapse" for="c-36651405">[-]</label><label class="expand" for="c-36651405">[4 more]</label></div><br/><div class="children"><div class="content">Pascal isn&#x27;t too bad; actually I think that it has some advantages over some more modern programming languages. It isn&#x27;t perfect though and does have disadvantages too. I sometimes use for Pascal and BASIC for DOS programming; Pascal does look OK for that, at least (and C seems not as good for DOS programming (at least in real mode), even though it is sometimes done). However, for programming in Linux, I generally prefer C (although I also use PostScript; I think that both C and PostScript have some advantages compared with some more modern programming languages). Pascal can be used for other programs too; even TeX is written in Pascal.</div><br/><div id="36651514" class="c"><input type="checkbox" id="c-36651514" checked=""/><div class="controls bullet"><span class="by">haolez</span><span>|</span><a href="#36651405">parent</a><span>|</span><a href="#36647953">next</a><span>|</span><label class="collapse" for="c-36651514">[-]</label><label class="expand" for="c-36651514">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s your use of Postscript? I find fascinating when people use it for anything other than print related stuff</div><br/><div id="36652658" class="c"><input type="checkbox" id="c-36652658" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36651405">root</a><span>|</span><a href="#36651514">parent</a><span>|</span><a href="#36651788">next</a><span>|</span><label class="collapse" for="c-36652658">[-]</label><label class="expand" for="c-36652658">[1 more]</label></div><br/><div class="children"><div class="content">you may appreciate <a href="http:&#x2F;&#x2F;postscriptcode.com&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;postscriptcode.com&#x2F;</a> by nathan laredo<p>i wrote a parametric 2-d cad system in postscript: <a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;laserboot&#x2F;cut-3&#x2F;README.md.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;laserboot&#x2F;cut-3&#x2F;README.md.ht...</a><p>it&#x27;s a very flexible dynamic language, much like lisp, and a little less like python, but with much better performance than python</div><br/></div></div><div id="36651788" class="c"><input type="checkbox" id="c-36651788" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#36651405">root</a><span>|</span><a href="#36651514">parent</a><span>|</span><a href="#36652658">prev</a><span>|</span><a href="#36647953">next</a><span>|</span><label class="collapse" for="c-36651788">[-]</label><label class="expand" for="c-36651788">[1 more]</label></div><br/><div class="children"><div class="content">I think that it is not such a bad programming language. I have used it for both graphical and nongraphical stuff. For example:<p>- A library to read&#x2F;write the ZZT file format. I had then also used it to make a program which will draw a graphical map (I also defined a &quot;PCEncoding&quot; vector, although some characters seems to not work somehow). I had also done other things with it that are not graphical, including constructing ZZT world file automatically or making batch modifications to existing world files.<p>- A library to parse a UHS hint file. Later, a program could also be written to allow it to be printed out, perhaps even using invisible ink or scratch-off layer if you have a suitable printer. It could also be used for interactive mode without printing.<p>- I wrote a program to convert the levels from a DOS game into the Free Hero Mesh level import format, in PostScript. (A similar thing can be done to convert levels from other games, I suppose.)<p>- I wanted to measure the computer&#x27;s temperature and load over time, so I wrote a program in C to write the measurements to a file (just simple binary data with fixed length records) and then wrote PostScript program which will plot it on a graph and make a PNG file.<p>- I also implemented getopt and JSON and multicodec in PostScript. I don&#x27;t use JSON much, although I do use the getopt implementation sometimes.<p>- I wanted to write a Pokemon battle simulator in C. I had used PostScript to manage some of the configuration-related stuff that is used before the program is compiled. As a side-effect, it can also make the type matchup charts in PNG as well (in addition to producing the files in the format used by the battle simulator I wanted to write), so now I have those as a reference even when playing a different game.<p>- I also implemented Infocom&#x27;s Z-machine in PostScript, although that is mostly just to see if I can. It implements both interactive mode (without the printer, using standard I&#x2F;O), and the transcript (with the printer).<p>Nevertheless, there are some things I would improve in PostScript. For example, add a &quot;unread&quot; operator (similar to ungetc in C), a built-in procedure called &quot;#!&quot; which just skips the rest of the line from the source file (the following slash is a new token in PostScript (which will be skipped by this procedure) so this will work), optional auto-allocation for stuff such as &quot;readline&quot;, making warning&#x2F;diagnostic&#x2F;error messages on stderr instead of stdout (although &quot;print&quot;, &quot;=&quot;, &quot;==&quot; would still write to stdout; you can use &quot;write==&quot; etc to write to other files, but being able to do this with &quot;pstack&quot; would also be useful), and some other stuff. (Some of the stuff in Ghostscript is good, such as the ARGUMENTS array; that is probably the feature of Ghostscript which I use most often. %pipe% is also useful.)</div><br/></div></div></div></div></div></div><div id="36647953" class="c"><input type="checkbox" id="c-36647953" checked=""/><div class="controls bullet"><span class="by">khaledh</span><span>|</span><a href="#36651405">prev</a><span>|</span><a href="#36648038">next</a><span>|</span><label class="collapse" for="c-36647953">[-]</label><label class="expand" for="c-36647953">[1 more]</label></div><br/><div class="children"><div class="content">My first project as a freshman in university was an elevator simulator (with text graphics) in Pascal. I enjoyed the language, there&#x27;s something elegant about it when compared to C-like languages. This is the reason I&#x27;m enjoying Nim nowadays, which afaik is inspired by Wirthian languages (Pascal, Modula 3, Oberon, Delphi), in addition to Ada and Python.</div><br/></div></div><div id="36648038" class="c"><input type="checkbox" id="c-36648038" checked=""/><div class="controls bullet"><span class="by">jmorenoamor</span><span>|</span><a href="#36647953">prev</a><span>|</span><a href="#36652475">next</a><span>|</span><label class="collapse" for="c-36648038">[-]</label><label class="expand" for="c-36648038">[6 more]</label></div><br/><div class="children"><div class="content">My first languaje after BASIC was Modula2, which looks a lot like Pascal. I studied OOP, algorithms and data structures with Pascal in college, so it&#x27;s a languaje for which I have great memeories.<p>Nice to see it&#x27;s still around.</div><br/><div id="36648609" class="c"><input type="checkbox" id="c-36648609" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36648038">parent</a><span>|</span><a href="#36652475">next</a><span>|</span><label class="collapse" for="c-36648609">[-]</label><label class="expand" for="c-36648609">[5 more]</label></div><br/><div class="children"><div class="content">Modula-2 is a much better language than original Pascal, but if you want OO features Oberon-2 is the corresponding Wirth language.</div><br/><div id="36648770" class="c"><input type="checkbox" id="c-36648770" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36648038">root</a><span>|</span><a href="#36648609">parent</a><span>|</span><a href="#36652475">next</a><span>|</span><label class="collapse" for="c-36648770">[-]</label><label class="expand" for="c-36648770">[4 more]</label></div><br/><div class="children"><div class="content">Both made it into modernity as large swaths of Golang. Modula-2 even had coroutines.</div><br/><div id="36648922" class="c"><input type="checkbox" id="c-36648922" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36648038">root</a><span>|</span><a href="#36648770">parent</a><span>|</span><a href="#36652475">next</a><span>|</span><label class="collapse" for="c-36648922">[-]</label><label class="expand" for="c-36648922">[3 more]</label></div><br/><div class="children"><div class="content">Go has surprisingly little in common with Oberon or Modula (mostly the receiver syntax of Oberon-2 bound procedures). The coroutines were not a language feature of Modula, but a library feature; also the Oakwood guidelines of Oberon (not by the original authors) include a coroutine API, but I&#x27;m not sure whether there was a working implementation.</div><br/><div id="36652676" class="c"><input type="checkbox" id="c-36652676" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36648038">root</a><span>|</span><a href="#36648922">parent</a><span>|</span><a href="#36652475">next</a><span>|</span><label class="collapse" for="c-36652676">[-]</label><label class="expand" for="c-36652676">[2 more]</label></div><br/><div class="children"><div class="content">golang is basically newsqueak</div><br/><div id="36652818" class="c"><input type="checkbox" id="c-36652818" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36648038">root</a><span>|</span><a href="#36652676">parent</a><span>|</span><a href="#36652475">next</a><span>|</span><label class="collapse" for="c-36652818">[-]</label><label class="expand" for="c-36652818">[1 more]</label></div><br/><div class="children"><div class="content">Go is basically Limbo + Oberon-2</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36652475" class="c"><input type="checkbox" id="c-36652475" checked=""/><div class="controls bullet"><span class="by">timwaagh</span><span>|</span><a href="#36648038">prev</a><span>|</span><a href="#36648489">next</a><span>|</span><label class="collapse" for="c-36652475">[-]</label><label class="expand" for="c-36652475">[1 more]</label></div><br/><div class="children"><div class="content">What I don&#x27;t really like about Pascal is it&#x27;s pretty verbose. It was originally for educational purposes so everything is very explicit.</div><br/></div></div><div id="36648489" class="c"><input type="checkbox" id="c-36648489" checked=""/><div class="controls bullet"><span class="by">maleldil</span><span>|</span><a href="#36652475">prev</a><span>|</span><a href="#36647660">next</a><span>|</span><label class="collapse" for="c-36648489">[-]</label><label class="expand" for="c-36648489">[9 more]</label></div><br/><div class="children"><div class="content">Does Pascal still require all variables to be declared at the top? I did a quick search and that seems like the case, but I want confirmation from someone that knows the language.<p>If so, that&#x27;s a immediate &quot;no&quot; for me. We know by now that keeping variable declarations close to their usage is a big boost in readability, and at times even in performance (you only declare variables you actually use).<p>I know Pascal has evolved a lot over time. If this is indeed still a requirement, it&#x27;s hard to understand why, and a barrier to those used to scoping in &quot;modern&quot; languages (even C99 has this).</div><br/><div id="36648528" class="c"><input type="checkbox" id="c-36648528" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36648489">parent</a><span>|</span><a href="#36652038">next</a><span>|</span><label class="collapse" for="c-36648528">[-]</label><label class="expand" for="c-36648528">[3 more]</label></div><br/><div class="children"><div class="content">Delphi allows inline variable declaration but Free Pascal does not (the developers explicitly decided against implementing it).<p>Note that in Pascal (FPC, Delphi, whatever) you can have nested functions so this isn&#x27;t that much of a limitation as it sounds. For example if i have a procedure that is very long i often end up splitting it in multiple nested procedures and each one has its own variable section.<p>Also from a more practical perspective Lazarus (the most common FPC IDE) has a shortcut key to automatically insert variable declarations so you don&#x27;t have to move up and down in code even if you have a large function body. I&#x27;d expect Delphi to have something similar.</div><br/><div id="36648615" class="c"><input type="checkbox" id="c-36648615" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648489">root</a><span>|</span><a href="#36648528">parent</a><span>|</span><a href="#36652038">next</a><span>|</span><label class="collapse" for="c-36648615">[-]</label><label class="expand" for="c-36648615">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Delphi allows inline variable declaration<p>it may do so now, but for the longest time it didn&#x27;t, which made it compare poorly with C++ and even with C, which allows definitions in a scope. in fact the OP concept of scope is a bit crap - basically the whole function,</div><br/><div id="36652826" class="c"><input type="checkbox" id="c-36652826" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36648489">root</a><span>|</span><a href="#36648615">parent</a><span>|</span><a href="#36652038">next</a><span>|</span><label class="collapse" for="c-36652826">[-]</label><label class="expand" for="c-36652826">[1 more]</label></div><br/><div class="children"><div class="content">Your concept of Object Pascal scope is also outdated, in relation to Delphi.</div><br/></div></div></div></div></div></div><div id="36652038" class="c"><input type="checkbox" id="c-36652038" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36648489">parent</a><span>|</span><a href="#36648528">prev</a><span>|</span><a href="#36648624">next</a><span>|</span><label class="collapse" for="c-36652038">[-]</label><label class="expand" for="c-36652038">[2 more]</label></div><br/><div class="children"><div class="content">One of my primary languages is C89 and don&#x27;t find it an impediment. It&#x27;s been over 2 decades since I last touched Pascal so I&#x27;m not sure how it works there, but in C you can always open a new inner scope with { and declare more variables there.<p><i>and at times even in performance (you only declare variables you actually use).</i><p>All but the stupidest compiler (which usually means no optimisation at all, not even precomputing constants) will not be affected by completely extraneous variables.</div><br/><div id="36652366" class="c"><input type="checkbox" id="c-36652366" checked=""/><div class="controls bullet"><span class="by">mike_hock</span><span>|</span><a href="#36648489">root</a><span>|</span><a href="#36652038">parent</a><span>|</span><a href="#36648624">next</a><span>|</span><label class="collapse" for="c-36652366">[-]</label><label class="expand" for="c-36652366">[1 more]</label></div><br/><div class="children"><div class="content">&gt; All but the stupidest compiler (which usually means no optimisation at all, not even precomputing constants) will not be affected by completely extraneous variables.<p>The statement is certainly false in this general form, even with full link-time optimizations. If the type has a constructor with side effects external to the program (e.g. it makes syscalls), the compiler cannot remove the variable.</div><br/></div></div></div></div><div id="36648624" class="c"><input type="checkbox" id="c-36648624" checked=""/><div class="controls bullet"><span class="by">gaze</span><span>|</span><a href="#36648489">parent</a><span>|</span><a href="#36652038">prev</a><span>|</span><a href="#36650604">next</a><span>|</span><label class="collapse" for="c-36648624">[-]</label><label class="expand" for="c-36648624">[2 more]</label></div><br/><div class="children"><div class="content">Seems a bit shallow. JavaScript equals is an abomination, which to me seems like a larger issue, and people use it just fine.</div><br/><div id="36648867" class="c"><input type="checkbox" id="c-36648867" checked=""/><div class="controls bullet"><span class="by">maleldil</span><span>|</span><a href="#36648489">root</a><span>|</span><a href="#36648624">parent</a><span>|</span><a href="#36650604">next</a><span>|</span><label class="collapse" for="c-36648867">[-]</label><label class="expand" for="c-36648867">[1 more]</label></div><br/><div class="children"><div class="content">I agree that triple equals is an abomination. It&#x27;s one of the many things ensuring I use JavaScript as little as possible.</div><br/></div></div></div></div><div id="36650604" class="c"><input type="checkbox" id="c-36650604" checked=""/><div class="controls bullet"><span class="by">drpixie</span><span>|</span><a href="#36648489">parent</a><span>|</span><a href="#36648624">prev</a><span>|</span><a href="#36647660">next</a><span>|</span><label class="collapse" for="c-36650604">[-]</label><label class="expand" for="c-36650604">[1 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s the worst thing you can find about Pascal (and it&#x27;s just a style issue) then Pascal must be the best thing ever :)</div><br/></div></div></div></div><div id="36647660" class="c"><input type="checkbox" id="c-36647660" checked=""/><div class="controls bullet"><span class="by">eimrine</span><span>|</span><a href="#36648489">prev</a><span>|</span><a href="#36648619">next</a><span>|</span><label class="collapse" for="c-36647660">[-]</label><label class="expand" for="c-36647660">[1 more]</label></div><br/><div class="children"><div class="content">I have found a beautiful beginner book &quot;High-Level Languages and Their Compilers&quot; by Des Watson and I want to run all that examples which are given mostly on Pascal.</div><br/></div></div><div id="36648619" class="c"><input type="checkbox" id="c-36648619" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36647660">prev</a><span>|</span><a href="#36648103">next</a><span>|</span><label class="collapse" for="c-36648619">[-]</label><label class="expand" for="c-36648619">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Why use Pascal?<p>Because you like Niklaus Wirth&#x27;s languages, and only those ... but only up to Pascal.<p>You don&#x27;t think that the improvements in his subsequent Pascal-like languages are Wirth a damn.<p>You believe that Wirth went soft in the 1970&#x27;s and 1980&#x27;s, and sold out Pascal.<p>If that is you, you probably write code in Pascal, implement Pascal, write about Pascal ...<p>(Everyone else should probably skip Pascal and take a look at Modula-2 and Oberon.)</div><br/><div id="36648946" class="c"><input type="checkbox" id="c-36648946" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36648619">parent</a><span>|</span><a href="#36648103">next</a><span>|</span><label class="collapse" for="c-36648946">[-]</label><label class="expand" for="c-36648946">[4 more]</label></div><br/><div class="children"><div class="content">&gt; (Everyone else should probably skip Pascal and take a look at Modula-2 and Oberon.)<p>I did check out Oberon-07 because of its minimalism but i really couldn&#x27;t get over the SHOUTY keywords :-P.<p>(Wirth used uppercase for Pascal&#x27;s keywords too but unlike Oberon, Pascal is not case sensitive - my pet theory is that Oberon is case sensitive as a reaction to Pascal programmers not using shouty capitalization :-P)</div><br/><div id="36652158" class="c"><input type="checkbox" id="c-36652158" checked=""/><div class="controls bullet"><span class="by">augustk</span><span>|</span><a href="#36648619">root</a><span>|</span><a href="#36648946">parent</a><span>|</span><a href="#36649549">next</a><span>|</span><label class="collapse" for="c-36652158">[-]</label><label class="expand" for="c-36652158">[1 more]</label></div><br/><div class="children"><div class="content">I think the main reason for keywords being uppercased in Oberon (which is case sensitive) is to free up the space for user-defined identifiers. As long as the programmer sticks to lowercase and mixed case identifiers, new keywords and predefined procedures can be introduced in the language without invalidating old programs.</div><br/></div></div><div id="36649549" class="c"><input type="checkbox" id="c-36649549" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36648619">root</a><span>|</span><a href="#36648946">parent</a><span>|</span><a href="#36652158">prev</a><span>|</span><a href="#36651878">next</a><span>|</span><label class="collapse" for="c-36649549">[-]</label><label class="expand" for="c-36649549">[1 more]</label></div><br/><div class="children"><div class="content">Yes, forcing uppercase keywords is rather unfortunate; have a look at <a href="https:&#x2F;&#x2F;oberon-lang.github.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;oberon-lang.github.io&#x2F;</a></div><br/></div></div><div id="36651878" class="c"><input type="checkbox" id="c-36651878" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36648619">root</a><span>|</span><a href="#36648946">parent</a><span>|</span><a href="#36649549">prev</a><span>|</span><a href="#36648103">next</a><span>|</span><label class="collapse" for="c-36651878">[-]</label><label class="expand" for="c-36651878">[1 more]</label></div><br/><div class="children"><div class="content">For a &quot;Loberon&quot; dialect!</div><br/></div></div></div></div></div></div><div id="36648103" class="c"><input type="checkbox" id="c-36648103" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#36648619">prev</a><span>|</span><a href="#36648195">next</a><span>|</span><label class="collapse" for="c-36648103">[-]</label><label class="expand" for="c-36648103">[1 more]</label></div><br/><div class="children"><div class="content">For the first couple of items on the list, Austral might be a language worth considering:<p><a href="https:&#x2F;&#x2F;austral-lang.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;austral-lang.org</a><p>It&#x27;s new so it obviously doesn&#x27;t have the community of libraries to use, but it does have a very friendly and accessible Pascal-like syntax, while also having a state of the art linear type system.</div><br/></div></div><div id="36648195" class="c"><input type="checkbox" id="c-36648195" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36648103">prev</a><span>|</span><a href="#36649227">next</a><span>|</span><label class="collapse" for="c-36648195">[-]</label><label class="expand" for="c-36648195">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using Free Pascal for my 3D game engine (recent-ish screenshot[0]). For me there is really two main simple reasons:<p>1. Lazarus. A game engine is -waaay- more than just a 3D engine with the tools being a very important aspect. Lazarus and LCL provide a rich and well featured WYSIWYG RAD IDE and framework for making desktop applications. As a bonus Lazarus as an IDE (even ignoring the LCL framework) is very fast.<p>2. The language is decent and i know it. This is important because i&#x27;m not interested in learning a new language or framework or whatever while also making the engine, i want to focus on one thing. Also i have a lot of code written over the years to cherry pick (i started the project in 2020 but some of the code goes back to 2007-2008). And finally it has a strong aversion to breaking existing code - there is a culture of preserving backwards compatibility.<p>Free Pascal is far from perfect though and TBH i&#x27;m annoyed by some of its constraints - some of them being quite pointless too IMO. For example the language has three ways to create compound types: records, objects and classes. They are <i>almost</i> all identical, except each one of them has limitations that isn&#x27;t found in others, e.g.:<p>1. Records. They are like C structs. With &quot;advanced records&quot; language submode (enabled more functionality in a backwards compatibility preserving manner) they can also have methods, properties and &quot;management operators&quot; allowing the compiler to insert calls when things enter or exit the scope (so you can e.g. implement smart pointers, RAII or whatever). However they do not have any form of inheritance or virtual functions. They are value types and as such can be put in the stack, heap and their can be part of another compound type.<p>2. Objects. They are basically records with inheritance and virtual functions, though they cannot have management operators or some other record-only functionality like a variant section (allowing, e.g. functionality similar to C unions). They are also value types and can be put in stack, heap and&#x2F;or be part of another compound type.<p>3. Classes. They are objects with extra functionality, have extra the bells and whistles like dynamic&#x2F;message-based methods, a published section that expose properties and attributes via RTTI, etc. However they are reference types - they can only be allocated on the heap[1] and as such cannot be put in the stack and cannot be part of another type (only references can be stored).<p>The thing is none of the above limitations have a technical reason - especially those between objects and records. In fact in the compiler source code all compound types are implemented with mostly the same code with some specialization checks here and there, it isn&#x27;t like each of the above gets its own separate code path.<p>But this is far from the only limitation. Another is that there is no way to expose a readonly view of an instance - something like C&#x2F;C++&#x27;s &quot;const&quot; - so you can&#x27;t -e.g.- have a mutable collection as a private field in a class that is exposed as an immutable one directly, so the compiler knows it can generate code for directly accessing the underlying field but not allowing any modifications to it. The weirder - and misleading - aspect is that the language <i>does</i> have some ways of specifying readonly views in some cases - specifically function parameters can use &quot;const&quot; or &quot;constref&quot; (the latter ensures a value is passed by reference, the former lets the compiler decide) which disallows the value to be modified. However if an object is passed like that you can still make method calls that mutate it even though you cannot assign it to another value, which kinda makes the whole thing feel only skin deep.<p>On the topic of arbitrary limitations and types, there is also a weird limitation on properties: you can have property getters (and setters, but what i&#x27;ll describe makes sense only for getters) be either fields or functions. For the former the compiler will generate code that&#x27;d be equivalent to accessing the field directly, for the latter it&#x27;d be a function call. When you define a property you also declare its type - but if you use a field as a getter it must much the type <i>exactly</i>, on the other hand you can have a function that returns a field as another type. This means that you cannot work around the &quot;lack of const&quot; limitation for collections by making a base class collection that only provides a readonly view and a subclass that allows mutation and then expose the mutable instance as its immutable parent class while letting the compiler generate code that access the field directly - you <i>have</i> to go through a function call and not only the compiler is <i>very</i> stupid at eliminating unnecessary calls, this also changes the RTTI data if you want this to be handled for -e.g.- serialization or via a GUI property editor.<p>Also when it comes to RTTI which it is still better than what you&#x27;d get via -e.g.- C++ (i.e. nothing), it has limitations like only allowing primitive types (so if you have a class for a 3D object and you want to expose its position to be edited via a property editor that uses RTTI to figure out what to edit or to have automatic serialization and deserialization you cannot expose a &quot;Position&quot; property of a &quot;Vector3D&quot; type directly with the RTTI specifying what that &quot;Vector3D&quot; means and instead you have to specify separate &quot;PositionX&quot;, &quot;PositionY&quot; and &quot;PositionZ&quot; properties of &quot;Single&quot; type (which is a primitive type for 32bit floats). You can still have a &quot;Position&quot; property of a &quot;Vector3D&quot; outside of RTTI and you can still use a private field of &quot;Vector3D&quot; to store the position and then use getters and setters beneath the scenes to access the individual vector fields for the &quot;PositionX&#x2F;Y&#x2F;Z&quot; properties.<p>All of the above have the end results of using tons of -often inefficient- boilerplate to work around language limitations that in 99% of the cases have no reason to exist in the first place (aside from nobody implementing them - which would be fine, it is a free project, but the thing is the above are things the FPC developers refused to acknowledge as problems - in fact i personally tried to submit a patch that implemented the property case).<p>As an example, in my 3D game engine i have a &quot;dynamic array&quot; generic (an incredibly common container you&#x27;d find in game engines) that i want to be able to allocate on the stack, heap or part of another object, i want it to separate allocation from number of elements (the language itself has dynamic arrays but they always allocate the same number of elements as the array has which means when you insert items you do a lot of allocations and deallocations - that not only fragments the heap but the FPC memory manager isn&#x27;t that fast in the first place) and of course being able to automatically finalize (i.e. destroy) any managed objects (e.g. a dynamic array of strings with string being copy-on-write &quot;smart&quot; objects defined by the language itself).<p>In order to get the &quot;allocate on stack or part of object&quot; i couldn&#x27;t use classes, only objects or records. Because i wanted to expose it directly but without allowing mutation, i really could only use objects since records to not support inheritance. However objects do not support management operators so i&#x27;d have to explicitly initialize and finalize the objects. So the workaround there was to store the data in a separate type that is a record with management operators and specify a single field in the (immutable &#x2F; readonly &#x2F; base) object of that separate type so that when the object goes out of scope or is finalized itself, its contents are also finalized (remember that i mentioned how this is an arbitrary limitation? The compiler already knows this can happen and handles this, otherwise this workaround wouldn&#x27;t work!). And also because i cannot have the mutable field accessed directly as its immutable&#x2F;readonly base type, wherever i use it and i want to expose it i have to use a method getter which returns a <i>pointer</i> to the underlying field (but as the immutable type) - this is needed because otherwise the getter would return a copy of it (remember these are value types).<p>[0] <a href="https:&#x2F;&#x2F;i.imgur.com&#x2F;zzIH4dl.png" rel="nofollow noreferrer">https:&#x2F;&#x2F;i.imgur.com&#x2F;zzIH4dl.png</a><p>[1] (there are workarounds like using a proxy array with in-place initialization but they are very bug prone so i ignore them as they are not practical)</div><br/><div id="36648197" class="c"><input type="checkbox" id="c-36648197" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36648195">parent</a><span>|</span><a href="#36648649">next</a><span>|</span><label class="collapse" for="c-36648197">[-]</label><label class="expand" for="c-36648197">[1 more]</label></div><br/><div class="children"><div class="content">(continued)<p>These are some of the annoyances with Free Pascal as the language, but there are others like how a unit (think module in other languages) has an &quot;initialization&quot; and &quot;finalization&quot; section that is executed on startup and shutdown respectively. This is good and useful thing, however the problem is that the initialization also has implicit code that zeroes out any global memory in that unit. This means that if a unit A&#x27;s initialization code runs a function from unit B that accesses some global in unit B but the initialization code in unit B isn&#x27;t called yet, any modification made by unit A calling that method would be lost ending up with weird bugs. The order the initialization code runs depends on the order the units are used in a program but if there are circular dependencies this order can be whatever the compiler encounters first. The workaround for this is to make sure the <i>program</i> (not any unit) that you compile has in its &quot;uses&quot; section the units that you don&#x27;t want them to modify and make sure they do not have any dependencies themselves.<p>Found that the hard way because in my units the initialization section contains RTTI registration calls that were later clobbered by the RTTI registry unit somehow getting initialized after some units that registered some types - this ended up with some assets not being loaded in the engine because the registry couldn&#x27;t find the type of some serialized objects (because these types happened to be registered before the registry&#x27;s own initialization code zeroed out its globals and erased any registered types).<p>The obvious fix would be for the global zeroing out to happen before any initialization section code is executed (and that only in systems which actually need it), but for whatever reason FPC doesn&#x27;t do that.<p>On the positive side the compiler is relatively fast - it takes about a couple of seconds to build the full engine + editor on my (now 5 year old) PC. And while there are issues like i mentioned above, the positives (which include the fast IDE, rich framework - and also i had a much easier time when trying to contributing to Lazarus - fast compiler... and the fact i already have a lot of FP code and know the language) outweigh the negatives.<p>It isn&#x27;t like there are many alternatives anyway, especially when it comes to something like Lazarus (of which the only potential alternative i can think of - which i haven&#x27;t explored much - is Qt Creator but i find Lazarus both the better IDE and LCL easier to work with than Qt, not to mention how FPC is <i>waaaaay</i> faster than G++ or Clang++).</div><br/></div></div><div id="36648649" class="c"><input type="checkbox" id="c-36648649" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36648195">parent</a><span>|</span><a href="#36648197">prev</a><span>|</span><a href="#36649209">next</a><span>|</span><label class="collapse" for="c-36648649">[-]</label><label class="expand" for="c-36648649">[2 more]</label></div><br/><div class="children"><div class="content">What about performance, e.g. compared with C++?</div><br/><div id="36648785" class="c"><input type="checkbox" id="c-36648785" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#36648195">root</a><span>|</span><a href="#36648649">parent</a><span>|</span><a href="#36649209">next</a><span>|</span><label class="collapse" for="c-36648785">[-]</label><label class="expand" for="c-36648785">[1 more]</label></div><br/><div class="children"><div class="content">I never really had a problem with it, at least so far.<p>Actually a few years ago i wrote a 3D game for DOS using Free Pascal[0] (here is a review from a YouTuber[1]) and the performance was decent, though i did write the rasterizer inner loop in assembly (not that great assembly TBH but still slightly better than what FPC generated).<p>I did optimize it over time and expectedly, the biggest gains weren&#x27;t from microptimizations but from changing how rendering works (e.g. i got a boost by adding a PVS and then another by replacing the PVS with portals since the PVS wasn&#x27;t that great :-P and then yet another when i added mesh occlusion culling using data from the previous frame).<p>About the engine i linked at in my post, i also did a few optimizations but again they weren&#x27;t microoptimizations but just algorithmic changes. I did write a profiler[2][3] a couple of years ago that helped (the video shows it in practice with the engine) but it uses some Windows-specific functionality and i&#x27;ve switched to Linux since then. Perf works fine under Linux with FPC, but FPWProf (my profiler) has some useful functionality and i&#x27;d like to port it to Linux at some point.<p>[0] <a href="https:&#x2F;&#x2F;bad-sector.itch.io&#x2F;post-apocalyptic-petra" rel="nofollow noreferrer">https:&#x2F;&#x2F;bad-sector.itch.io&#x2F;post-apocalyptic-petra</a><p>[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Lo7VlrYiTeE">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Lo7VlrYiTeE</a><p>[2] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yF0wmN9J8Ts">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yF0wmN9J8Ts</a><p>[3] <a href="http:&#x2F;&#x2F;runtimeterror.com&#x2F;tools&#x2F;fpwprof&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;runtimeterror.com&#x2F;tools&#x2F;fpwprof&#x2F;</a></div><br/></div></div></div></div><div id="36649209" class="c"><input type="checkbox" id="c-36649209" checked=""/><div class="controls bullet"><span class="by">dannymi</span><span>|</span><a href="#36648195">parent</a><span>|</span><a href="#36648649">prev</a><span>|</span><a href="#36649227">next</a><span>|</span><label class="collapse" for="c-36649209">[-]</label><label class="expand" for="c-36649209">[1 more]</label></div><br/><div class="children"><div class="content">Your level editor looks awesome :)</div><br/></div></div></div></div><div id="36649227" class="c"><input type="checkbox" id="c-36649227" checked=""/><div class="controls bullet"><span class="by">dolmen</span><span>|</span><a href="#36648195">prev</a><span>|</span><a href="#36650291">next</a><span>|</span><label class="collapse" for="c-36649227">[-]</label><label class="expand" for="c-36649227">[2 more]</label></div><br/><div class="children"><div class="content">I see Go as a direct competitor to Pascal, in particular for all the points mentioned in the article.<p>But Go has a modern runtime (with garbage collection), a modern ecosystem (with major libraries such as HTTP and TLS in stdlib) and an active community.</div><br/><div id="36649420" class="c"><input type="checkbox" id="c-36649420" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36649227">parent</a><span>|</span><a href="#36650291">next</a><span>|</span><label class="collapse" for="c-36649420">[-]</label><label class="expand" for="c-36649420">[1 more]</label></div><br/><div class="children"><div class="content">I do not. Co-routine thinking is more complex than imperative coding regarding the teaching aspects.<p>Java and more concrete C# are the one who took Pascal and Delphi originally out of the game for day to day programming. And Go is already so much more popular than Pascal for real life work, that competition is a really the wrong word.</div><br/></div></div></div></div><div id="36650291" class="c"><input type="checkbox" id="c-36650291" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#36649227">prev</a><span>|</span><a href="#36648711">next</a><span>|</span><label class="collapse" for="c-36650291">[-]</label><label class="expand" for="c-36650291">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t use it.<p>...but I&#x27;m kinda glad Delphi was my first language. I feel it primed my thinking along helpful lines - typed &amp; pretty rigidly structured.<p>Spent a lot of time in python since which always felt a little..fuzzy for lack of better word. Recent took up Rust and had a bit of a &quot;oh this feels familiar&quot; moment. Clean and unforgiving.</div><br/></div></div><div id="36648711" class="c"><input type="checkbox" id="c-36648711" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#36650291">prev</a><span>|</span><a href="#36650396">next</a><span>|</span><label class="collapse" for="c-36648711">[-]</label><label class="expand" for="c-36648711">[1 more]</label></div><br/><div class="children"><div class="content">Pascal was one of my first languages and I love it for that, but I can’t imagine going back to it. It never had a modern ecosystem and the OOP stuff was super janky</div><br/></div></div><div id="36650396" class="c"><input type="checkbox" id="c-36650396" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36648711">prev</a><span>|</span><a href="#36649222">next</a><span>|</span><label class="collapse" for="c-36650396">[-]</label><label class="expand" for="c-36650396">[3 more]</label></div><br/><div class="children"><div class="content">Related, and of interest, IMO:<p>Delphi – why won&#x27;t it die? (2013)<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7613543">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=7613543</a></div><br/><div id="36652797" class="c"><input type="checkbox" id="c-36652797" checked=""/><div class="controls bullet"><span class="by">Tozen</span><span>|</span><a href="#36650396">parent</a><span>|</span><a href="#36649222">next</a><span>|</span><label class="collapse" for="c-36652797">[-]</label><label class="expand" for="c-36652797">[2 more]</label></div><br/><div class="children"><div class="content">The funny thing about that, is here we are in 2023.  Lots of its competitors and haters are likely still asking, &quot;Why won&#x27;t it die?&quot;<p>TIOBE index has Delphi&#x2F;Object Pascal ranked at #11.  That&#x27;s ahead of &quot;top players&quot; like Go, Rust, and Swift.</div><br/><div id="36652833" class="c"><input type="checkbox" id="c-36652833" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36650396">root</a><span>|</span><a href="#36652797">parent</a><span>|</span><a href="#36649222">next</a><span>|</span><label class="collapse" for="c-36652833">[-]</label><label class="expand" for="c-36652833">[1 more]</label></div><br/><div class="children"><div class="content">In Germany we keep having a Delphi &#x2F; C++ Builder developers conference, and maybe due to their relation to Anders, it is not surprising to see related articles on the .NET Developers Magazine.</div><br/></div></div></div></div></div></div><div id="36649222" class="c"><input type="checkbox" id="c-36649222" checked=""/><div class="controls bullet"><span class="by">applesan</span><span>|</span><a href="#36650396">prev</a><span>|</span><a href="#36648267">next</a><span>|</span><label class="collapse" for="c-36649222">[-]</label><label class="expand" for="c-36649222">[2 more]</label></div><br/><div class="children"><div class="content">Pascal and Logo Turtle are programming languages I learned at school, but never used them outside of it. I hated them back then. I don&#x27;t know if this was teacher or language fault, but these IT lessons couldn&#x27;t be more boring and confusing.</div><br/><div id="36649365" class="c"><input type="checkbox" id="c-36649365" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36649222">parent</a><span>|</span><a href="#36648267">next</a><span>|</span><label class="collapse" for="c-36649365">[-]</label><label class="expand" for="c-36649365">[1 more]</label></div><br/><div class="children"><div class="content">Teacher and kids not being focused. I learnt using Pascal and it was perfect.</div><br/></div></div></div></div><div id="36648267" class="c"><input type="checkbox" id="c-36648267" checked=""/><div class="controls bullet"><span class="by">slavapestov</span><span>|</span><a href="#36649222">prev</a><span>|</span><a href="#36648748">next</a><span>|</span><label class="collapse" for="c-36648267">[-]</label><label class="expand" for="c-36648267">[3 more]</label></div><br/><div class="children"><div class="content">We need to bring back Oberon. Fast compile times, automatic memory management, live environment.</div><br/><div id="36652838" class="c"><input type="checkbox" id="c-36652838" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36648267">parent</a><span>|</span><a href="#36648641">next</a><span>|</span><label class="collapse" for="c-36652838">[-]</label><label class="expand" for="c-36652838">[1 more]</label></div><br/><div class="children"><div class="content">It was great for its time, nowadays we would be better off having a similar experience based on Go, C#, D,...</div><br/></div></div><div id="36648641" class="c"><input type="checkbox" id="c-36648641" checked=""/><div class="controls bullet"><span class="by">Rochus</span><span>|</span><a href="#36648267">parent</a><span>|</span><a href="#36652838">prev</a><span>|</span><a href="#36648748">next</a><span>|</span><label class="collapse" for="c-36648641">[-]</label><label class="expand" for="c-36648641">[1 more]</label></div><br/><div class="children"><div class="content">Oberon is even older than Delphi; a more modern version is Oberon+: <a href="https:&#x2F;&#x2F;oberon-lang.github.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;oberon-lang.github.io&#x2F;</a></div><br/></div></div></div></div><div id="36648748" class="c"><input type="checkbox" id="c-36648748" checked=""/><div class="controls bullet"><span class="by">oh_my_goodness</span><span>|</span><a href="#36648267">prev</a><span>|</span><a href="#36648466">next</a><span>|</span><label class="collapse" for="c-36648748">[-]</label><label class="expand" for="c-36648748">[1 more]</label></div><br/><div class="children"><div class="content">In the future, if you ever create a teaching language, <i>please</i> point out clearly to the students that it&#x27;s a teaching language.</div><br/></div></div><div id="36648466" class="c"><input type="checkbox" id="c-36648466" checked=""/><div class="controls bullet"><span class="by">brd</span><span>|</span><a href="#36648748">prev</a><span>|</span><a href="#36648678">next</a><span>|</span><label class="collapse" for="c-36648466">[-]</label><label class="expand" for="c-36648466">[4 more]</label></div><br/><div class="children"><div class="content">I won&#x27;t even bother clicking this click bait title. I learned Pascal as a sophomore in high school and by my senior year I knew I&#x27;d never touch it again. At the time it was a great introductory language but there&#x27;s very little reason anyone should even be thinking about Pascal these days.<p>Fun fact:  I still have my old pascal files on floppy disks in a box somewhere with a not so thin layer of dust on them.</div><br/><div id="36649494" class="c"><input type="checkbox" id="c-36649494" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36648466">parent</a><span>|</span><a href="#36649190">next</a><span>|</span><label class="collapse" for="c-36649494">[-]</label><label class="expand" for="c-36649494">[2 more]</label></div><br/><div class="children"><div class="content">I still think it is brutal we let our industry rookies learn complicated programming concepts in complicated languages like Java, python, js or god forbid anything functional.<p>I still think it is a huge mistake be Microsoft to let Basic rot away and that our industry should focus teaching on something like Pascal which does not stand in your way</div><br/><div id="36652853" class="c"><input type="checkbox" id="c-36652853" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36648466">root</a><span>|</span><a href="#36649494">parent</a><span>|</span><a href="#36649190">next</a><span>|</span><label class="collapse" for="c-36652853">[-]</label><label class="expand" for="c-36652853">[1 more]</label></div><br/><div class="children"><div class="content">Visual Basic 6 remains unmatched in how to deal with COM.<p>It is incredible given how much WinDev doubles down on COM, that they keep failing on producing any kind of tooling that is as productive as the VB 6 experiece used to be.</div><br/></div></div></div></div><div id="36649190" class="c"><input type="checkbox" id="c-36649190" checked=""/><div class="controls bullet"><span class="by">dolmen</span><span>|</span><a href="#36648466">parent</a><span>|</span><a href="#36649494">prev</a><span>|</span><a href="#36648678">next</a><span>|</span><label class="collapse" for="c-36649190">[-]</label><label class="expand" for="c-36649190">[1 more]</label></div><br/><div class="children"><div class="content">Same here. Including the fun fact.</div><br/></div></div></div></div><div id="36648678" class="c"><input type="checkbox" id="c-36648678" checked=""/><div class="controls bullet"><span class="by">riidom</span><span>|</span><a href="#36648466">prev</a><span>|</span><a href="#36648356">next</a><span>|</span><label class="collapse" for="c-36648678">[-]</label><label class="expand" for="c-36648678">[1 more]</label></div><br/><div class="children"><div class="content">Question for Castle Engine users:<p>How is the file size when exporting to web, for an near-empty project?</div><br/></div></div><div id="36648356" class="c"><input type="checkbox" id="c-36648356" checked=""/><div class="controls bullet"><span class="by">whatyesaid</span><span>|</span><a href="#36648678">prev</a><span>|</span><a href="#36650339">next</a><span>|</span><label class="collapse" for="c-36648356">[-]</label><label class="expand" for="c-36648356">[51 more]</label></div><br/><div class="children"><div class="content">Unless you want a C++ with a different syntax and less features then there&#x27;s no reason to learn Pascal in 2023.<p>And the syntax is much worse, you can&#x27;t even declare variables in the middle of a function it has to go before the function. This slows you down from real work (art code comes later). It also makes worse code as declaring near the usage point makes code more clear.</div><br/><div id="36652633" class="c"><input type="checkbox" id="c-36652633" checked=""/><div class="controls bullet"><span class="by">Tozen</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36648764">next</a><span>|</span><label class="collapse" for="c-36652633">[-]</label><label class="expand" for="c-36652633">[1 more]</label></div><br/><div class="children"><div class="content">Seems like you haven&#x27;t been using the Object Pascal dialects of Delphi or PascalABC, which let you declare variables everywhere.  In the case of Delphi, Embarcadero has been making it as easy as possible to switch between their Delphi and C++Builder products lines.<p>For Free Pascal, the developers and many users voted against that, because it appears the opinion was it leads to sloppy code and unnecessary errors.  The other point, is that Object Pascal has for a very long time allowed nested functions, so it wasn&#x27;t arguably that much of an issue for those on that side.  It seems more like C&#x2F;C++ users wanted to force their habits on Pascal, which Embarcadero sold out to, for a few extra dollars.  PascalABC, copied what Delphi was doing, who they use as a quasi-standard.</div><br/></div></div><div id="36648764" class="c"><input type="checkbox" id="c-36648764" checked=""/><div class="controls bullet"><span class="by">brokenkebaby</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36652633">prev</a><span>|</span><a href="#36648707">next</a><span>|</span><label class="collapse" for="c-36648764">[-]</label><label class="expand" for="c-36648764">[1 more]</label></div><br/><div class="children"><div class="content">Just a few days ago I found a bug in someone&#x27;s code where a variable was introduced twice with slightly different name, like &quot;var jobno&quot;, and then &quot;var jobn&quot;. Made me think that Pascal&#x27;s approach to keep vars declarations at one place is not a bad thing. As for slowing down - probably yes, but I doubt that speedtyping is really a big virtue for a software developer. Also, in a decent IDE it should be possible to make binding&#x2F;macro to insert declaration after the current function header without jumping away from the current position (though I don&#x27;t know what Pascal devs use nowadays for IDE)</div><br/></div></div><div id="36648707" class="c"><input type="checkbox" id="c-36648707" checked=""/><div class="controls bullet"><span class="by">janoc</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36648764">prev</a><span>|</span><a href="#36648407">next</a><span>|</span><label class="collapse" for="c-36648707">[-]</label><label class="expand" for="c-36648707">[9 more]</label></div><br/><div class="children"><div class="content">That&#x27;s completely missing the point.<p>While Pascal can be used for serious work, it is first and foremost a teaching language friendly to beginners meant for introducing people (who back in the day) likely started with something like BASIC to concepts of structured and objects oriented programming. The syntax is easy to learn, fairly clean and the language has very fast compilation (C++ really can&#x27;t compete here). Which is important when teaching - permits rapid iteration.<p>Concerning archaic&#x2F;rigid syntax - there are some good reasons why the syntax is like it is. E.g. the concept of declaring a variable in the middle of a block didn&#x27;t exist in Pascal for a reason - you had to actually allocate memory before you used it, the compiler didn&#x27;t hide this from you. That&#x27;s why variables are declared at the start of the block.<p>When Pascal has been designed it was running on various 8bit and 16bit machines and was originally compiled into bytecode (p-code), so optimizations like statement reordering common today (which permits to declare the variables in the middle of blocks) didn&#x27;t exist&#x2F;weren&#x27;t possible&#x2F;common.<p>These days you have a ton of abstractions between you and the &quot;metal&quot; running your code, Pascal is a language designed for much simpler time and hardware.</div><br/><div id="36648981" class="c"><input type="checkbox" id="c-36648981" checked=""/><div class="controls bullet"><span class="by">Al-Khwarizmi</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648707">parent</a><span>|</span><a href="#36648814">next</a><span>|</span><label class="collapse" for="c-36648981">[-]</label><label class="expand" for="c-36648981">[3 more]</label></div><br/><div class="children"><div class="content">I was teaching programming with Pascal until three years ago, and I think the pedagogical argument might have made sense in the past, but not in 2023 (or 10 years ago for that matter).<p>The syntax is rigid in all the wrong places. For example, not being able to declare variables anywhere doesn&#x27;t really help students, this isn&#x27;t something that typically leads them to errors.<p>What <i>does</i> lead to lots of errors? Dereferencing uninitialized pointers or going out of bounds in arrays, for example. And the language and compiler won&#x27;t help you one bit there. Same opaque segmentation faults as with C, same unpredictable behavior as with C, but with worse tooling for debugging.<p>Compilation time is not an issue in 2023 - well, maybe it is if you compare with C++, but C++ is about the worst non-joke language I can think of for learning (and it was my first language!). C, Java, Python, etc. are fast enough.<p>Pascal had its time but I don&#x27;t think there is much reason to use it now, outside of pure curiosity or wanting to try a historical language.</div><br/><div id="36649087" class="c"><input type="checkbox" id="c-36649087" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648981">parent</a><span>|</span><a href="#36651208">next</a><span>|</span><label class="collapse" for="c-36649087">[-]</label><label class="expand" for="c-36649087">[1 more]</label></div><br/><div class="children"><div class="content">&gt;For example, not being able to declare variables anywhere doesn&#x27;t really help students, this<p>Disagree. Creating variables in the middle is the reason why beginners create spaghetti code and mix up control flow. This is the reason for dangling pointers, memory leaks, and de-referencing pointers in wrong places.<p>If student needs to declare variable in the middle of method, this is a good sign to split the method or rethink control flow.<p>What really I learned from Pascal is managing clean control flow, and <i>var</i> section in the beginning forces you to think in advance what you are going to need in this particular method vs what needs to be done in a separate function.</div><br/></div></div><div id="36651208" class="c"><input type="checkbox" id="c-36651208" checked=""/><div class="controls bullet"><span class="by">anta40</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648981">parent</a><span>|</span><a href="#36649087">prev</a><span>|</span><a href="#36648814">next</a><span>|</span><label class="collapse" for="c-36651208">[-]</label><label class="expand" for="c-36651208">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Pascal had its time but I don&#x27;t think there is much reason to use it now, outside of pure curiosity or wanting to try a historical language.<p>I use Pascal only for side job&#x2F;hobby, not for daily work. Lazarus+FPC is still my #1 choice for desktop app (is this still a &quot;thing&quot; in 2023?). No Electron, no JVM etc etc.<p>For writing web&#x2F;server&#x2F;backend stuffs, kinda hard to argue with Go.</div><br/></div></div></div></div><div id="36648814" class="c"><input type="checkbox" id="c-36648814" checked=""/><div class="controls bullet"><span class="by">OnlyMortal</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648707">parent</a><span>|</span><a href="#36648981">prev</a><span>|</span><a href="#36649353">next</a><span>|</span><label class="collapse" for="c-36648814">[-]</label><label class="expand" for="c-36648814">[1 more]</label></div><br/><div class="children"><div class="content">Much of the original Mac was Pascal based with 68k for performance pinch points.<p>Of note it was faster to compile than C with MPW Shell.</div><br/></div></div><div id="36649353" class="c"><input type="checkbox" id="c-36649353" checked=""/><div class="controls bullet"><span class="by">oaiey</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648707">parent</a><span>|</span><a href="#36648814">prev</a><span>|</span><a href="#36648913">next</a><span>|</span><label class="collapse" for="c-36649353">[-]</label><label class="expand" for="c-36649353">[1 more]</label></div><br/><div class="children"><div class="content">Many years ago I learned programming that way. Pascal then C, Assembler and VB Script. I completely agree with the argument that it is a great teaching language. Our teachers even explained this to us. JS, C, C#, Python and Java syntax is just crazy for real newbies. Curly braces basically do not exist in normal life and scare people. And Go and the functional group of languages are just not understandable with their concepts. Imperative programming is much easier to understand.<p>Pascal is in a sweet spot.</div><br/></div></div><div id="36648913" class="c"><input type="checkbox" id="c-36648913" checked=""/><div class="controls bullet"><span class="by">sigg3</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648707">parent</a><span>|</span><a href="#36649353">prev</a><span>|</span><a href="#36649393">next</a><span>|</span><label class="collapse" for="c-36648913">[-]</label><label class="expand" for="c-36648913">[2 more]</label></div><br/><div class="children"><div class="content">I seem to recall Golang being inspired by it too, but I could be misremembering.</div><br/><div id="36650273" class="c"><input type="checkbox" id="c-36650273" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648913">parent</a><span>|</span><a href="#36649393">next</a><span>|</span><label class="collapse" for="c-36650273">[-]</label><label class="expand" for="c-36650273">[1 more]</label></div><br/><div class="children"><div class="content">I believe you&#x27;re right. iirc, that&#x27;s where the := notation comes from</div><br/></div></div></div></div><div id="36649393" class="c"><input type="checkbox" id="c-36649393" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648707">parent</a><span>|</span><a href="#36648913">prev</a><span>|</span><a href="#36648407">next</a><span>|</span><label class="collapse" for="c-36649393">[-]</label><label class="expand" for="c-36649393">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>While Pascal can be used for serious work, it is first and foremost a teaching language friendly to beginners</i><p>But that&#x27;s not what the linked article argues as a reason to use (Object) Pascal.<p>&gt; <i>The syntax is easy to learn, fairly clean and the language has very fast compilation (C++ really can&#x27;t compete here).  Which is important when teaching - permits rapid iteration.</i><p>1. There are other languages than C++ you know...<p>2. For language-teaching purposes, basically _any_ language compiles essentially instantaneously on modern hardware (including  C++).</div><br/></div></div></div></div><div id="36648407" class="c"><input type="checkbox" id="c-36648407" checked=""/><div class="controls bullet"><span class="by">whobre</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36648707">prev</a><span>|</span><a href="#36648582">next</a><span>|</span><label class="collapse" for="c-36648407">[-]</label><label class="expand" for="c-36648407">[25 more]</label></div><br/><div class="children"><div class="content">Can’t speak about Object Pascal, but the old Pascal was objectively better than C. You can like or dislike the differences in syntax, but Pascal’s type system was pretty solid which can’t be said about C</div><br/><div id="36648769" class="c"><input type="checkbox" id="c-36648769" checked=""/><div class="controls bullet"><span class="by">pmelendez</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648407">parent</a><span>|</span><a href="#36648424">next</a><span>|</span><label class="collapse" for="c-36648769">[-]</label><label class="expand" for="c-36648769">[16 more]</label></div><br/><div class="children"><div class="content">&gt; but Pascal’s type system was pretty solid<p>To be honest, this is a matter of styles, coming from a dynamic type background I don’t appreciate strongly typed systems as an advantage.</div><br/><div id="36648827" class="c"><input type="checkbox" id="c-36648827" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648769">parent</a><span>|</span><a href="#36648424">next</a><span>|</span><label class="collapse" for="c-36648827">[-]</label><label class="expand" for="c-36648827">[15 more]</label></div><br/><div class="children"><div class="content">Strongly typed is orthogonal to dynamic and static typing. Python and Common Lisp are both &quot;strongly&quot; typed and dynamically typed. There&#x27;s no reason to shun strong typing if you also like dynamic typing.</div><br/><div id="36648999" class="c"><input type="checkbox" id="c-36648999" checked=""/><div class="controls bullet"><span class="by">pmelendez</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648827">parent</a><span>|</span><a href="#36649151">next</a><span>|</span><label class="collapse" for="c-36648999">[-]</label><label class="expand" for="c-36648999">[5 more]</label></div><br/><div class="children"><div class="content">I would be curious to see references that claims that dynamic and static typing are orthogonal with strongly typed systems, as “strongly type” is rather ambiguous and the only reason I used the term was because that was how Pascal was promoted back in the day (or at least how was taught to me)<p>From Wikipedia: In 1974, Liskov and S. Zilles defined a strongly-typed language as one in which &quot;whenever an object is passed from a calling function to a called function, its type must be compatible with the type declared in the called function.&quot;<p>Note that the definition refers to type declaration, both being optional in Python and Common Lisp, so I wouldn’t use either as an example of strongly type languages.</div><br/><div id="36649325" class="c"><input type="checkbox" id="c-36649325" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648999">parent</a><span>|</span><a href="#36649070">next</a><span>|</span><label class="collapse" for="c-36649325">[-]</label><label class="expand" for="c-36649325">[1 more]</label></div><br/><div class="children"><div class="content">&quot;whenever an object is passed&quot; clearly refers to run-time. An object is not being passed when we are compiling the function call.<p>&quot;declared in the function&quot; clearly means that the function has an internal type check.<p>An interface declaration (Modula-2 interface file, C header file with prototypes) is not &quot;in the function&quot;; it&#x27;s compile-time meta-data about a function.<p>A function call between separately compiled translation units has no idea what is <i>in</i> a function.</div><br/></div></div><div id="36649070" class="c"><input type="checkbox" id="c-36649070" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648999">parent</a><span>|</span><a href="#36649325">prev</a><span>|</span><a href="#36649238">next</a><span>|</span><label class="collapse" for="c-36649070">[-]</label><label class="expand" for="c-36649070">[1 more]</label></div><br/><div class="children"><div class="content">You already found the wikipedia page, try reading it. See where it puts a lot of dynamically typed languages under the category of &quot;strongly typed&quot;. You&#x27;ve decided it&#x27;s a good enough source apparently.<p>But really, I used &quot;strongly&quot; in quotes deliberately. It&#x27;s a terrible phrase since it means nothing in practice because it can mean too many things (as that same page notes) that often are at odds with each other.<p>&gt; Note that the definition refers to type declaration, both being optional in Python and Common Lisp, so I wouldn’t use either as an example of strongly type languages.<p>Even this definition would potentially exclude SML and OCaml where types are inferred, not declared. So according to you those two languages are weakly typed? I think a lot of people would be surprised to learn that.</div><br/></div></div><div id="36649177" class="c"><input type="checkbox" id="c-36649177" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648999">parent</a><span>|</span><a href="#36649238">prev</a><span>|</span><a href="#36649151">next</a><span>|</span><label class="collapse" for="c-36649177">[-]</label><label class="expand" for="c-36649177">[1 more]</label></div><br/><div class="children"><div class="content">Dynamic and static merely point to the fact that type analysis is either done at runtime or at compilation time.<p>It is an unrelated concept to which type rules will be applied by the software at runtime or compilation time.</div><br/></div></div></div></div><div id="36649151" class="c"><input type="checkbox" id="c-36649151" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648827">parent</a><span>|</span><a href="#36648999">prev</a><span>|</span><a href="#36648424">next</a><span>|</span><label class="collapse" for="c-36649151">[-]</label><label class="expand" for="c-36649151">[9 more]</label></div><br/><div class="children"><div class="content">how can Python be strongly typed if it doesn&#x27;t enforce types for declared arguments?<p>What is the value of this supposedly &quot;strongly typed&quot; Python&#x27;s type system?<p>class Object:<p><pre><code>    pass
</code></pre>
def f(arg:int):<p><pre><code>    print(&quot;type of arg = &quot;, str(type(arg)))
</code></pre>
f(1)<p>f(666.0)<p>f(&quot;kek&quot;)<p>f(Object())<p>type of arg =  &lt;class &#x27;int&#x27;&gt;<p>type of arg =  &lt;class &#x27;float&#x27;&gt;<p>type of arg =  &lt;class &#x27;str&#x27;&gt;<p>type of arg =  &lt;class &#x27;__main__.Object&#x27;&gt;<p>and not a single error&#x2F;warning thrown</div><br/><div id="36649191" class="c"><input type="checkbox" id="c-36649191" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36649151">parent</a><span>|</span><a href="#36648424">next</a><span>|</span><label class="collapse" for="c-36649191">[-]</label><label class="expand" for="c-36649191">[8 more]</label></div><br/><div class="children"><div class="content">How is OCaml strongly typed if it doesn&#x27;t have declared types?!?!? (EDIT: In case it&#x27;s not obvious, I&#x27;m being sarcastic, I&#x27;m pretty sure some people in this discussion won&#x27;t get that though.)<p><pre><code>  let f x = x + 1;; (* What&#x27;s the type?!?!? *)
</code></pre>
Turns out that &quot;strong typing&quot; is a shitty phrase that people should stop using because it means too many conflicting things, and, consequently, means nothing. Static and dynamic typing have well-defined meanings, stick with those terms instead of ones that mean nothing.<p>But for a demonstration (compare to Perl) try this in your Python REPL:<p><pre><code>  &gt;&gt;&gt; 1 + &quot;1&quot;
</code></pre>
Does it work? Probably not unless you futzed with the language implementation. In Perl it does, though. So to the extent that &quot;strong typing&quot; means anything, Perl is &quot;weakly typed&quot;, Python is &quot;strongly typed&quot;, and both are dynamically typed. It&#x27;s an orthogonal characteristic of the type system and language from when type checking occurs.<p>----------<p>EDIT: BTW, formatting code blocks on HN is really easy. Prefix each line of code with two space characters.<p><pre><code>  __Replace those _&#x27;s with spaces
</code></pre>
The result is much cleaner than your comment:<p><pre><code>  def foo(x):
    return x + x
</code></pre>
No extra newlines needed, more compact, easier for most people to read.</div><br/><div id="36649300" class="c"><input type="checkbox" id="c-36649300" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36649191">parent</a><span>|</span><a href="#36648424">next</a><span>|</span><label class="collapse" for="c-36649300">[-]</label><label class="expand" for="c-36649300">[7 more]</label></div><br/><div class="children"><div class="content">people on HN often claim that Python is &quot;strongly typed&quot; while PHP is loosely-typed, but I don&#x27;t see the difference honestly. both are pretty loose.<p>re:
  1 + &quot;1&quot;<p>I didn&#x27;t get your point really. My reply was to counter claim that Python is supposedly &quot;strongly typed&quot; and I don&#x27;t understand how this strong typing helps developers. I know that languages can infer types, which is tangential subject.  I dont know why you brought this up</div><br/><div id="36649406" class="c"><input type="checkbox" id="c-36649406" checked=""/><div class="controls bullet"><span class="by">dsemi</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36649300">parent</a><span>|</span><a href="#36649379">next</a><span>|</span><label class="collapse" for="c-36649406">[-]</label><label class="expand" for="c-36649406">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t see the difference honestly. both are pretty loose.<p>There&#x27;s a clear difference, in PHP 1 + &quot;1&quot; is 2, in Python it&#x27;s a TypeError, (and as a bonus, in Javascript 1 + &quot;1&quot; is &quot;11&quot;).<p>The definition of &quot;strongly typed&quot; being used is related to type coercion, not type inference. In PHP the string is being coerced to an integer, but Python requires you to explicitly say 1 + int(&quot;1&quot;) if you want to add the numbers together. This can be helpful to developers because it requires you to make a decision about what behavior you actually want rather than assuming you want to add two numbers or concatenate strings when you may have wanted the opposite.</div><br/><div id="36649456" class="c"><input type="checkbox" id="c-36649456" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36649406">parent</a><span>|</span><a href="#36649379">next</a><span>|</span><label class="collapse" for="c-36649456">[-]</label><label class="expand" for="c-36649456">[1 more]</label></div><br/><div class="children"><div class="content">String concatenation is probably the most reasonable result aside from a type error given how + is used in JS for concatenation elsewhere, but JS actually gets funny.<p><pre><code>  &quot;1&quot;*2 &#x2F;&#x2F; =&gt; 2 (not &quot;2&quot;)
  &quot;1&quot;*2+3 &#x2F;&#x2F; =&gt; 5
  &quot;1&quot; - 2 &#x2F;&#x2F; =&gt; -1
  &quot;9&quot;&#x2F;3 &#x2F;&#x2F; =&gt; 3
  &quot;9&quot; + 3 &#x2F;&#x2F; =&gt; &quot;93&quot;
</code></pre>
So some mathematical operators will convert string parameters to a number, but not +.</div><br/></div></div></div></div><div id="36649379" class="c"><input type="checkbox" id="c-36649379" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36649300">parent</a><span>|</span><a href="#36649406">prev</a><span>|</span><a href="#36648424">next</a><span>|</span><label class="collapse" for="c-36649379">[-]</label><label class="expand" for="c-36649379">[4 more]</label></div><br/><div class="children"><div class="content">Try that line in both Python and Perl and see how they behave, you&#x27;ll see that one (Python) respects types (the most useful notion of &quot;strong typing&quot; is no or limited automatic type coercion and &quot;weak typing&quot; as an excessive permissibility around mixing of types in operations) and the other (Perl) does not.<p>I pointed out the OCaml example because both you and your sibling poster brought up type <i>declarations</i> as somehow mattering with respect to &quot;strong typing&quot;. OCaml doesn&#x27;t require type declarations, so I guess it&#x27;s weakly typed according to both of you. Which is a surprising result.</div><br/><div id="36649404" class="c"><input type="checkbox" id="c-36649404" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36649379">parent</a><span>|</span><a href="#36648424">next</a><span>|</span><label class="collapse" for="c-36649404">[-]</label><label class="expand" for="c-36649404">[3 more]</label></div><br/><div class="children"><div class="content">I never do 1+”1” in my code, so this example is not useful to me.<p>I do however annotate types and expect Python to respect type annotations which is not the case. Then I dont understand what is point of annotating types if they are not respected?<p>If your argument that Python doesn’t convert from one type to another - well, it doesn’t need to do that if doesn’t care about types in the first place and lets you pass any junk into any method (and this is #1 thing that type system is supposed to prevent)<p>Is it only for documentation so that people reading code could understand what types to pass?</div><br/><div id="36649440" class="c"><input type="checkbox" id="c-36649440" checked=""/><div class="controls bullet"><span class="by">dsemi</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36649404">parent</a><span>|</span><a href="#36649575">next</a><span>|</span><label class="collapse" for="c-36649440">[-]</label><label class="expand" for="c-36649440">[1 more]</label></div><br/><div class="children"><div class="content">Python type annotations were added to be used by an external type checker, so no they are not enforced by the interpreter itself.<p>This was an explicit decision: <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0484&#x2F;#non-goals" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0484&#x2F;#non-goals</a></div><br/></div></div><div id="36649575" class="c"><input type="checkbox" id="c-36649575" checked=""/><div class="controls bullet"><span class="by">TheCleric</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36649404">parent</a><span>|</span><a href="#36649440">prev</a><span>|</span><a href="#36648424">next</a><span>|</span><label class="collapse" for="c-36649575">[-]</label><label class="expand" for="c-36649575">[1 more]</label></div><br/><div class="children"><div class="content">Python type hinting is not useful at runtime (in fact it&#x27;s flat out ignored). It is useful at &quot;linting&quot; time when run through mypy.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36648424" class="c"><input type="checkbox" id="c-36648424" checked=""/><div class="controls bullet"><span class="by">bigbillheck</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648407">parent</a><span>|</span><a href="#36648769">prev</a><span>|</span><a href="#36650565">next</a><span>|</span><label class="collapse" for="c-36648424">[-]</label><label class="expand" for="c-36648424">[7 more]</label></div><br/><div class="children"><div class="content">The way I remember the pascal type system is arrays of different lengths were different types.</div><br/><div id="36648553" class="c"><input type="checkbox" id="c-36648553" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648424">parent</a><span>|</span><a href="#36648537">next</a><span>|</span><label class="collapse" for="c-36648553">[-]</label><label class="expand" for="c-36648553">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s more to it than that. You could (from early Pascal days) and can have arrays where the array index range is a previously defined subrange of integers, or maybe even of an enumerated type.<p>Then you have sets as a built-in type, which is big.<p>Some more.</div><br/></div></div><div id="36648537" class="c"><input type="checkbox" id="c-36648537" checked=""/><div class="controls bullet"><span class="by">filmor</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648424">parent</a><span>|</span><a href="#36648553">prev</a><span>|</span><a href="#36648654">next</a><span>|</span><label class="collapse" for="c-36648537">[-]</label><label class="expand" for="c-36648537">[4 more]</label></div><br/><div class="children"><div class="content">They are pretty much everywhere when statically allocated.</div><br/><div id="36649042" class="c"><input type="checkbox" id="c-36649042" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648537">parent</a><span>|</span><a href="#36648654">next</a><span>|</span><label class="collapse" for="c-36649042">[-]</label><label class="expand" for="c-36649042">[3 more]</label></div><br/><div class="children"><div class="content">well, not in c.</div><br/><div id="36650359" class="c"><input type="checkbox" id="c-36650359" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36649042">parent</a><span>|</span><a href="#36648654">next</a><span>|</span><label class="collapse" for="c-36650359">[-]</label><label class="expand" for="c-36650359">[2 more]</label></div><br/><div class="children"><div class="content">I believe they are in C, but arrays degrade to pointers when you look at them wrong, and _those_ don&#x27;t have length as part of their type.<p>At least I&#x27;m seeing: `array type &#x27;int[3]&#x27;` in messages when I tried to do something wrong with it quick to get an error message (using llvm), maybe that&#x27;s a compiler specific thing.</div><br/><div id="36650402" class="c"><input type="checkbox" id="c-36650402" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36650359">parent</a><span>|</span><a href="#36648654">next</a><span>|</span><label class="collapse" for="c-36650402">[-]</label><label class="expand" for="c-36650402">[1 more]</label></div><br/><div class="children"><div class="content">&gt; when you look at them wrong<p>no, almost whenever you look at them. it is very hard to carry around the size of an array in C.<p>&gt; At least I&#x27;m seeing: `array type &#x27;int[3]&#x27;` in messages when I tried to do something wrong with it quick to get an error message (using llvm), maybe that&#x27;s a compiler specific thing.<p>post some code that illustrates what you are talking about</div><br/></div></div></div></div></div></div></div></div><div id="36648654" class="c"><input type="checkbox" id="c-36648654" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648424">parent</a><span>|</span><a href="#36648537">prev</a><span>|</span><a href="#36650565">next</a><span>|</span><label class="collapse" for="c-36648654">[-]</label><label class="expand" for="c-36648654">[1 more]</label></div><br/><div class="children"><div class="content">In the <i>original</i> Pascal, that was true.  The standard (and, I think, Jensen &amp; Wirth) were that way.  And it was a fatal flaw.<p>I had a program that I took over that did a numerical simulation on a 2D grid with user-specified size.  The original author simulated that 2D grid with a 1D doubly-linked list.  As you might expect, this was both slow and error-prone.  But he did it because there was no possible type that you could give to a user-sized array.  There was literally no way to talk about such a thing.<p>We eventually &quot;fixed&quot; it by allocating the largest 2D array possible within our memory limitations, and using only the user-specified part of it.<p>Most &quot;real&quot; Pascals (Turbo Pascal, but others that were intended to be used in the real world, not just in the classroom) developed some way to give a type to a variable-length array (and also to do a C-ish cast).  Unfortunately they all did it in different ways, so there was no code portability between compilers if your code needed such things.<p>So, yeah, &quot;objectively better than C&quot; is quite a stretch, even just in the type system.</div><br/></div></div></div></div><div id="36650565" class="c"><input type="checkbox" id="c-36650565" checked=""/><div class="controls bullet"><span class="by">drpixie</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648407">parent</a><span>|</span><a href="#36648424">prev</a><span>|</span><a href="#36648582">next</a><span>|</span><label class="collapse" for="c-36650565">[-]</label><label class="expand" for="c-36650565">[1 more]</label></div><br/><div class="children"><div class="content">Strong agree. I used the old Turbo Pascal for many years. It was quite routine to produce substantial programs where the compiler (and type system) had caught ALL the bugs.<p><i>Meaning:</i> you used sensible types (and had sensible libraries) and once the obvious compile-time errors were fixed, there would be zero bugs found in testing or in live!<p>I like the flexibility of python, but I know that every substantial program has untested pathways that will fail when they come to be exercised :(</div><br/></div></div></div></div><div id="36648582" class="c"><input type="checkbox" id="c-36648582" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36648407">prev</a><span>|</span><a href="#36649045">next</a><span>|</span><label class="collapse" for="c-36648582">[-]</label><label class="expand" for="c-36648582">[1 more]</label></div><br/><div class="children"><div class="content">Delphi&#x2F;Lazarus seems like a fairly productive environment.<p>Also if I recall correctly some Pascal compilers (similarly to Ada) could actually generate somewhat memory safe code with array bounds checking, which is something that C&#x2F;C++ usually lacks.</div><br/></div></div><div id="36649045" class="c"><input type="checkbox" id="c-36649045" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36648582">prev</a><span>|</span><a href="#36648556">next</a><span>|</span><label class="collapse" for="c-36649045">[-]</label><label class="expand" for="c-36649045">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Unless you want a C++ with a different syntax and less features then there&#x27;s no reason to learn Pascal in 2023.<p>For me, personally, there there is a <i>good</i> reason to learn Pascal in 2023; the quick and almost painless ability to produce fast GUI applications.<p>The alternatives are not nearly as polished or as nice.</div><br/></div></div><div id="36648556" class="c"><input type="checkbox" id="c-36648556" checked=""/><div class="controls bullet"><span class="by">nopepon</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36649045">prev</a><span>|</span><a href="#36648989">next</a><span>|</span><label class="collapse" for="c-36648556">[-]</label><label class="expand" for="c-36648556">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been playing around with Lazarus the last couple of weeks, and I can say there is at least one reason to learn pascal in 2023: it&#x27;s fun!</div><br/></div></div><div id="36648989" class="c"><input type="checkbox" id="c-36648989" checked=""/><div class="controls bullet"><span class="by">chinabot</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36648556">prev</a><span>|</span><a href="#36649319">next</a><span>|</span><label class="collapse" for="c-36648989">[-]</label><label class="expand" for="c-36648989">[1 more]</label></div><br/><div class="children"><div class="content">recently did a conversion of a Delphi program to Java with some C++ and this is a strange argument to use. pressing F9 at any point in Delphi and having your program run a second later is incredible, that plus catching the vast majority of errors compile time certainly does not slow you down.<p>Speed wise on this last conversion project with the same first level optimizations GCC is a good 50% faster, the Java parts feel about the same or a bit slower though, Disclaimer I never go to extreme optimization settings on compilers, was bitten several years back and happy to not go cutting edge.<p>Also Pascal is much less toxic community for noobs I got to the point about ten years back I would rather not ask the question on-line for GCC due to the fact I would be branded stupid for not knowing some obscure linker setting or such like.<p>end of my career now, happy Pascal was part of it, especially in the early Turbo Pascal DOS days, I doubt I would have carried on at the time if I was forced to use C (I later did and it wasnt that bad but I had to scratch my head at the time how people thought it better)</div><br/></div></div><div id="36649319" class="c"><input type="checkbox" id="c-36649319" checked=""/><div class="controls bullet"><span class="by">delphi4711</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36648989">prev</a><span>|</span><a href="#36648626">next</a><span>|</span><label class="collapse" for="c-36649319">[-]</label><label class="expand" for="c-36649319">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can&#x27;t even declare variables in the middle of a function<p>You can since Delphi 10.3.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;History_of_Delphi_(software)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;History_of_Delphi_(software)</a></div><br/></div></div><div id="36648626" class="c"><input type="checkbox" id="c-36648626" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36649319">prev</a><span>|</span><a href="#36650500">next</a><span>|</span><label class="collapse" for="c-36648626">[-]</label><label class="expand" for="c-36648626">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can&#x27;t even declare variables in the middle of a function<p>losing time with &quot;static declaration follows non static&quot; in C programs doesn&#x27;t help either.</div><br/></div></div><div id="36650500" class="c"><input type="checkbox" id="c-36650500" checked=""/><div class="controls bullet"><span class="by">clouddrover</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36648626">prev</a><span>|</span><a href="#36650620">next</a><span>|</span><label class="collapse" for="c-36650500">[-]</label><label class="expand" for="c-36650500">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>you can&#x27;t even declare variables in the middle of a function</i><p>Yes you can:<p><a href="https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Alexandria&#x2F;en&#x2F;Inline_Variable_Declaration" rel="nofollow noreferrer">https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Alexandria&#x2F;en&#x2F;Inli...</a></div><br/></div></div><div id="36650620" class="c"><input type="checkbox" id="c-36650620" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36650500">prev</a><span>|</span><a href="#36648629">next</a><span>|</span><label class="collapse" for="c-36650620">[-]</label><label class="expand" for="c-36650620">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;And the syntax is much worse, you can&#x27;t even declare variables in the middle of a function it has to go before the function.&quot;<p>I wish people would bother to check the facts before posting. It&#x27;s been available for quite a while along with many more modern features.</div><br/></div></div><div id="36648629" class="c"><input type="checkbox" id="c-36648629" checked=""/><div class="controls bullet"><span class="by">unnouinceput</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36650620">prev</a><span>|</span><a href="#36648797">next</a><span>|</span><label class="collapse" for="c-36648629">[-]</label><label class="expand" for="c-36648629">[5 more]</label></div><br/><div class="children"><div class="content">I never understood why is declaring variables in the middle of the code a &quot;pro&quot; for some. In my experience that&#x27;s a &quot;con&quot; especially because of maintainability. Same way you do a comment before declaring a function to explain its purpose, you do a comment for each variable to declare its goal within said function. That&#x27;s proper maintainability for a project.<p>Also Delphi, for past 2 years, has this &quot;middle&quot; variable declaration style, and I hate it, never used it. So your comment missed the mark. If you want to advocate &quot;don&#x27;t learn Pascal in 2023&quot; please do more research and come up with better argument.</div><br/><div id="36648750" class="c"><input type="checkbox" id="c-36648750" checked=""/><div class="controls bullet"><span class="by">tnecniv</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648629">parent</a><span>|</span><a href="#36649020">next</a><span>|</span><label class="collapse" for="c-36648750">[-]</label><label class="expand" for="c-36648750">[1 more]</label></div><br/><div class="children"><div class="content">Like dynamic typing and other things, declaring things in the middle of your code block seemed like a great idea to young me, but as I’ve gotten older, things like organizing variable definitions, strict use of types (or the kind of sucky type hints in Python), and other kinds of self-documenting declarations have become much more appealing to me. It might save “real work” from happening if you measure by lines of code, but you pay that price later when debugging or reading code you haven’t touched in a long time.</div><br/></div></div><div id="36649020" class="c"><input type="checkbox" id="c-36649020" checked=""/><div class="controls bullet"><span class="by">Al-Khwarizmi</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648629">parent</a><span>|</span><a href="#36648750">prev</a><span>|</span><a href="#36649074">next</a><span>|</span><label class="collapse" for="c-36649020">[-]</label><label class="expand" for="c-36649020">[1 more]</label></div><br/><div class="children"><div class="content">A clear example of why it is a pro is the index of a for loop. Why would it be more maintainable to declare all for loop indexes at the beginning of a function? They are basically bound variables that are only meaningful within their loop, and they are usually not even worth commenting.</div><br/></div></div><div id="36649074" class="c"><input type="checkbox" id="c-36649074" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648629">parent</a><span>|</span><a href="#36649020">prev</a><span>|</span><a href="#36652429">next</a><span>|</span><label class="collapse" for="c-36649074">[-]</label><label class="expand" for="c-36649074">[1 more]</label></div><br/><div class="children"><div class="content">defining all variables as near to their point of use as possible is a pretty obviously good thing, for readability if nothing else.</div><br/></div></div><div id="36652429" class="c"><input type="checkbox" id="c-36652429" checked=""/><div class="controls bullet"><span class="by">clouddrover</span><span>|</span><a href="#36648356">root</a><span>|</span><a href="#36648629">parent</a><span>|</span><a href="#36649074">prev</a><span>|</span><a href="#36648797">next</a><span>|</span><label class="collapse" for="c-36652429">[-]</label><label class="expand" for="c-36652429">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I hate it, never used it</i><p>You should at least use it in for loops. It&#x27;s a useful improvement, and especially handy in combination with type inference. For example:<p><pre><code>  for var i := 1 to 10 do
    Inc (Total, i);
</code></pre>
i is declared inline, it&#x27;s only in scope inside the for loop, and the type is inferred from the bounds of the loop. You could of course use &quot;for var i : Integer := 1 to 10 do&quot; if you wanted to be explicit about the type.<p>Documentation: <a href="https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Alexandria&#x2F;en&#x2F;Inline_Variable_Declaration" rel="nofollow noreferrer">https:&#x2F;&#x2F;docwiki.embarcadero.com&#x2F;RADStudio&#x2F;Alexandria&#x2F;en&#x2F;Inli...</a></div><br/></div></div></div></div><div id="36648797" class="c"><input type="checkbox" id="c-36648797" checked=""/><div class="controls bullet"><span class="by">gmiller123456</span><span>|</span><a href="#36648356">parent</a><span>|</span><a href="#36648629">prev</a><span>|</span><a href="#36650339">next</a><span>|</span><label class="collapse" for="c-36648797">[-]</label><label class="expand" for="c-36648797">[1 more]</label></div><br/><div class="children"><div class="content">C used to be that way too, but Pascal stopped evolving when it fell out of popularity.</div><br/></div></div></div></div><div id="36650339" class="c"><input type="checkbox" id="c-36650339" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#36648356">prev</a><span>|</span><a href="#36649360">next</a><span>|</span><label class="collapse" for="c-36650339">[-]</label><label class="expand" for="c-36650339">[1 more]</label></div><br/><div class="children"><div class="content">Seeing devexpress components in Lazarus would be a dream come true.</div><br/></div></div><div id="36649360" class="c"><input type="checkbox" id="c-36649360" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#36650339">prev</a><span>|</span><a href="#36648215">next</a><span>|</span><label class="collapse" for="c-36649360">[-]</label><label class="expand" for="c-36649360">[2 more]</label></div><br/><div class="children"><div class="content">&gt; modern, readable, fast, type-safe, cross-platform programming language<p>Let&#x27;s assume this is all true (although I wouldn&#x27;t say it&#x27;s particularly modern, and I don&#x27;t know about some of the rest). And let&#x27;s forget that some of these adjectives are relative or subjective.<p>Even under that assumption - there are other programming languages which meet these criteria. Why would we prefer Object Pascal over them? Especially when it has existed for many years and not gotten a lot of traction?</div><br/><div id="36649405" class="c"><input type="checkbox" id="c-36649405" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#36649360">parent</a><span>|</span><a href="#36648215">next</a><span>|</span><label class="collapse" for="c-36649405">[-]</label><label class="expand" for="c-36649405">[1 more]</label></div><br/><div class="children"><div class="content">&quot;For those who like this sort of thing, it is the sort of thing they like.&quot; - attributed to a number of people.<p>There are other languages which meet these criteria.  But if Pascal fits the way your brain works, then it does.  So use it.<p>And if it doesn&#x27;t fit the way your brain works, then don&#x27;t.<p>People are different.  It doesn&#x27;t hurt to have different tools.</div><br/></div></div></div></div><div id="36648215" class="c"><input type="checkbox" id="c-36648215" checked=""/><div class="controls bullet"><span class="by">snailtrail</span><span>|</span><a href="#36649360">prev</a><span>|</span><label class="collapse" for="c-36648215">[-]</label><label class="expand" for="c-36648215">[1 more]</label></div><br/><div class="children"><div class="content">&lt;&#x2F;main&gt;</div><br/></div></div></div></div></div></div></div></body></html>