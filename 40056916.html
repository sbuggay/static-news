<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713344471025" as="style"/><link rel="stylesheet" href="styles.css?v=1713344471025"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://buttondown.email/hillelwayne/archive/what-makes-concurrency-so-hard/">What makes concurrency so hard?</a> <span class="domain">(<a href="https://buttondown.email">buttondown.email</a>)</span></div><div class="subtext"><span>BerislavLopac</span> | <span>13 comments</span></div><br/><div><div id="40061814" class="c"><input type="checkbox" id="c-40061814" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#40060034">next</a><span>|</span><label class="collapse" for="c-40061814">[-]</label><label class="expand" for="c-40061814">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We do concurrent reasoning every time we drive a car!<p>&gt; More generally, some studies find that if you frame concurrent systems in human terms (&quot;meatspace modeling&quot;), people get quite good at finding the race conditions.
&gt; So while concurrency might be difficult to reason about, I don&#x27;t think it&#x27;s because of a fault in our brains.<p>Indeed, when you drive a car you get rich input, unlike with concurrency where neither the design nor, even more importantly, execution, is presented to you in anything similarly comprehensible</div><br/></div></div><div id="40060034" class="c"><input type="checkbox" id="c-40060034" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40061814">prev</a><span>|</span><a href="#40056952">next</a><span>|</span><label class="collapse" for="c-40060034">[-]</label><label class="expand" for="c-40060034">[2 more]</label></div><br/><div class="children"><div class="content">In the past, programmers opted for concurrency because creating a thread was the only way to get a continuation&#x2F;closure type entity, where you could nicely do everything in one tidy scope. So even the thread was preemptive, and thus particularly threatening, it was nicer to write the program.<p>Also, if you multiplex events onto a single thread, though you get some better guarantees about execution order than you do under preemptive threads, it is still chaotic.  Events arrive in any order. Multiple state machines update their state in any order, and hit their important states in any order.<p>Data being chopped into frames arbitrarily scrambles things. The past million time the program read four bytes from the network socket, it got the entire 32 bit integer in one operation. Today, it didn&#x27;t notice that the read only returned 3 bytes.<p>Threads are exciting, especially to young programmers. Look, all you have to do is write little programs that do simple things in a loop, taking some messages here and replying there. Put them together, and the complex behavior of the application will somehow just emerge, as if by magic. And you don&#x27;t even have to document it anywhere; just document the simple things that the individual threads are doing!</div><br/></div></div><div id="40056952" class="c"><input type="checkbox" id="c-40056952" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40060034">prev</a><span>|</span><a href="#40060149">next</a><span>|</span><label class="collapse" for="c-40056952">[-]</label><label class="expand" for="c-40056952">[1 more]</label></div><br/><div class="children"><div class="content">&gt; All means of making concurrency &#x27;easier&#x27; are concerned first and foremost with managing the state space.<p>&gt; Data mutations create new steps, which immutable data structures avoid by definition.<p>This is why I&#x27;ll already reach for immutability-first, and only mutate in special cases.</div><br/></div></div><div id="40060149" class="c"><input type="checkbox" id="c-40060149" checked=""/><div class="controls bullet"><span class="by">jklowden</span><span>|</span><a href="#40056952">prev</a><span>|</span><a href="#40061007">next</a><span>|</span><label class="collapse" for="c-40060149">[-]</label><label class="expand" for="c-40060149">[4 more]</label></div><br/><div class="children"><div class="content">Three words: Communicating Sequential Processes.</div><br/><div id="40061034" class="c"><input type="checkbox" id="c-40061034" checked=""/><div class="controls bullet"><span class="by">hbogert</span><span>|</span><a href="#40060149">parent</a><span>|</span><a href="#40061472">next</a><span>|</span><label class="collapse" for="c-40061034">[-]</label><label class="expand" for="c-40061034">[2 more]</label></div><br/><div class="children"><div class="content">Like in Go? I still think it&#x27;s difficult there. Is it made easy? Sure. But it&#x27;s not simple</div><br/><div id="40061216" class="c"><input type="checkbox" id="c-40061216" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#40060149">root</a><span>|</span><a href="#40061034">parent</a><span>|</span><a href="#40061472">next</a><span>|</span><label class="collapse" for="c-40061216">[-]</label><label class="expand" for="c-40061216">[1 more]</label></div><br/><div class="children"><div class="content">In part because Go isn&#x27;t true CSP, it&#x27;s just inspired by it.  It&#x27;s very easy to accidentally share data between threads even when exclusively using channels to communicate.  Couple this with the cases where it is better to use shared state with mutexes and you get can bit by them being easy to screw up or forget.</div><br/></div></div></div></div><div id="40061472" class="c"><input type="checkbox" id="c-40061472" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40060149">parent</a><span>|</span><a href="#40061034">prev</a><span>|</span><a href="#40061007">next</a><span>|</span><label class="collapse" for="c-40061472">[-]</label><label class="expand" for="c-40061472">[1 more]</label></div><br/><div class="children"><div class="content">It doesn’t make it easy. You can still have dead&#x2F;live locks.</div><br/></div></div></div></div><div id="40061007" class="c"><input type="checkbox" id="c-40061007" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40060149">prev</a><span>|</span><a href="#40060240">next</a><span>|</span><label class="collapse" for="c-40061007">[-]</label><label class="expand" for="c-40061007">[3 more]</label></div><br/><div class="children"><div class="content">Concurrency is not so hard if you have the right tools &#x2F; primitives:<p>- Monads with do-notation<p>- Atoms<p>- Immutable data structures</div><br/><div id="40061063" class="c"><input type="checkbox" id="c-40061063" checked=""/><div class="controls bullet"><span class="by">BenoitP</span><span>|</span><a href="#40061007">parent</a><span>|</span><a href="#40060240">next</a><span>|</span><label class="collapse" for="c-40061063">[-]</label><label class="expand" for="c-40061063">[2 more]</label></div><br/><div class="children"><div class="content">According to the framework the author uses, how would you describe these in terms of state space management (apart from immutability, which the author dealt with)?</div><br/><div id="40061971" class="c"><input type="checkbox" id="c-40061971" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40061007">root</a><span>|</span><a href="#40061063">parent</a><span>|</span><a href="#40060240">next</a><span>|</span><label class="collapse" for="c-40061971">[-]</label><label class="expand" for="c-40061971">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Monads with do-notation<p>Phrased like this, it sounds like &#x27;the monad abstraction&#x27; and &#x27;good syntax for monads&#x27; are what helps, which is slightly off the mark.<p>But <i>particular</i> monads do help:<p>- The Par monad gives you deterministic parallelism for computations.<p>- The flipside of marking mutable&#x2F;non-determistic functions as IO (another monad), is that the functions <i>not</i> marked as such are deterministic, non-interfering etc., so interleaving them differently will not grow the state-space.<p>- The STM monad gives you transactions, which give you safe, shared mutability without running into the following issue from the article:<p>&gt; I can use programming constructs like mutexes and barriers to &quot;prune&quot; the state space and give me the behaviors I want, but given how big the state space can be, I have to do a lot of pruning to get the right behaviors. I can make mistakes in implementation, &quot;misshape&quot; the space (like by adding a deadlock), or not notice a buggy state I need to remove. Threads are very error prone.<p>I&#x27;m not sure what &#x27;Atoms&#x27; refer to, unless it&#x27;s running code in an atomic block in STM.<p>That said, having a good monadic syntax <i>is still great</i>, even if the syntax can&#x27;t solve semantic concurrency issues.  I believe that CompletableFutures were a good way to model async code in Java (and Rx&#x2F;observables etc, to some extent).  But they got resistance from Java programmers who didn&#x27;t want to flatMap everything all the time.  They had semantic issues too (can&#x27;t cancel?!? what?!).  But I think it&#x27;s largely their syntax that made programmers miss the Thread model of writing straight-line imperative code.</div><br/></div></div></div></div></div></div><div id="40060240" class="c"><input type="checkbox" id="c-40060240" checked=""/><div class="controls bullet"><span class="by">datavirtue</span><span>|</span><a href="#40061007">prev</a><span>|</span><label class="collapse" for="c-40060240">[-]</label><label class="expand" for="c-40060240">[1 more]</label></div><br/><div class="children"><div class="content">Emergence.</div><br/></div></div></div></div></div></div></div></body></html>