<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713258059254" as="style"/><link rel="stylesheet" href="styles.css?v=1713258059254"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jazco.dev/2024/04/15/in-memory-graphs/">How much memory does a graph take?</a> <span class="domain">(<a href="https://jazco.dev">jazco.dev</a>)</span></div><div class="subtext"><span>goranmoomin</span> | <span>12 comments</span></div><br/><div><div id="40048011" class="c"><input type="checkbox" id="c-40048011" checked=""/><div class="controls bullet"><span class="by">lmeyerov</span><span>|</span><a href="#40049643">next</a><span>|</span><label class="collapse" for="c-40048011">[-]</label><label class="expand" for="c-40048011">[2 more]</label></div><br/><div class="children"><div class="content">Extra fun: We find most enterprise&#x2F;gov graph analytics work only requires 1-2 attributes to go along with the graph index, and those attributes often are already numeric (time, $, ...) or can be dictionary-encoded as discussed here (categorical, ID, ...). The result is that even &#x27;tough&#x27; billion scale graphs are fine on 1 gpu.<p>Ex: Most of our users are happy to do 100K-100M edges quickly on a single node, imagine a quick parquet read, so goes surprisingly far. For $0.5&#x2F;hr, you can get 16GB of GPU RAM on aws, stuff in 100M+ edges comfortably, and have room to compute all sorts of things. With a more typical one, 1B is easy.<p>Early, but that&#x27;s been the basic thinking into our new GFQL system: slice into the columns you want, and then do all the in-GPU traversals you want. In our V1, we keep things dataframe-native, including the in-GPU data representation, and we are now working on adding the first extensions to support on-the-fly switching to more graph-native indexing as needed.<p>Ex: <a href="https:&#x2F;&#x2F;github.com&#x2F;graphistry&#x2F;pygraphistry&#x2F;blob&#x2F;master&#x2F;demos&#x2F;gfql&#x2F;benchmark_hops_cpu_gpu.ipynb">https:&#x2F;&#x2F;github.com&#x2F;graphistry&#x2F;pygraphistry&#x2F;blob&#x2F;master&#x2F;demos...</a></div><br/><div id="40049591" class="c"><input type="checkbox" id="c-40049591" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40048011">parent</a><span>|</span><a href="#40049643">next</a><span>|</span><label class="collapse" for="c-40049591">[-]</label><label class="expand" for="c-40049591">[1 more]</label></div><br/><div class="children"><div class="content">Hence the typical observation that a lot of Big Data jobs actually run comfortably on a developer laptop.</div><br/></div></div></div></div><div id="40049643" class="c"><input type="checkbox" id="c-40049643" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40048011">prev</a><span>|</span><a href="#40049360">next</a><span>|</span><label class="collapse" for="c-40049643">[-]</label><label class="expand" for="c-40049643">[1 more]</label></div><br/><div class="children"><div class="content">Depending on the relative sizes of the sets and the number of times the intersections are computed, it might be more efficient to store the sets as ordered lists and do a linear merge pass to compute the intersection.</div><br/></div></div><div id="40049360" class="c"><input type="checkbox" id="c-40049360" checked=""/><div class="controls bullet"><span class="by">kohlerm</span><span>|</span><a href="#40049643">prev</a><span>|</span><a href="#40049064">next</a><span>|</span><label class="collapse" for="c-40049360">[-]</label><label class="expand" for="c-40049360">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;eclipse.dev&#x2F;mat&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eclipse.dev&#x2F;mat&#x2F;</a> can handle very large graphs of objects using a similar approach. It also does implement some kind of paging, such that you do not have to load the complete graph into memory when running some of the graph algorithms.</div><br/></div></div><div id="40049064" class="c"><input type="checkbox" id="c-40049064" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#40049360">prev</a><span>|</span><a href="#40047535">next</a><span>|</span><label class="collapse" for="c-40049064">[-]</label><label class="expand" for="c-40049064">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>the feature ... that shows you how many of your friends also follow this user.</i><p>Propaganda in the 1920s targeted social clique by social clique, but as far as I know (cards having been invented for a few decades) it was largely a manual wetware-driven process. With our progress over the last century, we can now target &quot;all your friends are saying&quot; campaigns completely automatically.</div><br/></div></div><div id="40047535" class="c"><input type="checkbox" id="c-40047535" checked=""/><div class="controls bullet"><span class="by">fl0ki</span><span>|</span><a href="#40049064">prev</a><span>|</span><a href="#40045281">next</a><span>|</span><label class="collapse" for="c-40047535">[-]</label><label class="expand" for="c-40047535">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been doing this for years in projects internal to my employers. It&#x27;s nice to see it catching on, because it&#x27;ll be easier to explain to people if I can point to a blog post saying the same thing.<p>Other tips worth trying:<p>* You&#x27;ll do even better by optimizing your ID type. Even if it has to be a string, it can at least be a string with SSO, or a long-lived string reference, or an interned string.<p>* Try the ahash crate instead of the default cryptogically secure hash function in Rust.<p>* Consider HashSet&lt;ByRef&lt;Arc&lt;T&gt;&gt;&gt; instead of having to take keys to a different map to resolve the actual object.</div><br/><div id="40048275" class="c"><input type="checkbox" id="c-40048275" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40047535">parent</a><span>|</span><a href="#40045281">next</a><span>|</span><label class="collapse" for="c-40048275">[-]</label><label class="expand" for="c-40048275">[1 more]</label></div><br/><div class="children"><div class="content">* You can use a Vector-like for the `uid_to_did` direction (be sure it doesn&#x27;t copy on resize, and you may also want to prevent invalidation, so a 2-level vector is often a reasonable choice). Depending on design decisions the elements might want to be `Option&lt;String&gt;` instead of just `String`.<p>* You can get away with uint32 indexes. The interned indexes should local so this shouldn&#x27;t be a problem even if you think you&#x27;ll have more than 4 billion global users. (note: all social media combined only has that currently)<p>* For interned strings specifically it&#x27;s embarrassingly simple to use a bump allocator for the string data itself.</div><br/></div></div></div></div><div id="40045281" class="c"><input type="checkbox" id="c-40045281" checked=""/><div class="controls bullet"><span class="by">victorbjorklund</span><span>|</span><a href="#40047535">prev</a><span>|</span><a href="#40048086">next</a><span>|</span><label class="collapse" for="c-40045281">[-]</label><label class="expand" for="c-40045281">[3 more]</label></div><br/><div class="children"><div class="content">Really nice writeup. Suprised it was so efficient.</div><br/><div id="40047039" class="c"><input type="checkbox" id="c-40047039" checked=""/><div class="controls bullet"><span class="by">philipkglass</span><span>|</span><a href="#40045281">parent</a><span>|</span><a href="#40048086">next</a><span>|</span><label class="collapse" for="c-40047039">[-]</label><label class="expand" for="c-40047039">[2 more]</label></div><br/><div class="children"><div class="content">It concludes &quot;There’s further optimization left to be made by locking individual HashSets instead of the entire follows or following set, but we can leave that for a later day.&quot;<p>The other optimization that I would try is replacing those u64 keys with u32. There are only a few million accounts at present so there&#x27;s a <i>lot</i> of growth room before 32 bits become inadequate. RAM is cheap, but making values smaller allows you to fit more of them into CPU cache, which often gives worthwhile speedups.</div><br/><div id="40049314" class="c"><input type="checkbox" id="c-40049314" checked=""/><div class="controls bullet"><span class="by">unrealhoang</span><span>|</span><a href="#40045281">root</a><span>|</span><a href="#40047039">parent</a><span>|</span><a href="#40048086">next</a><span>|</span><label class="collapse" for="c-40049314">[-]</label><label class="expand" for="c-40049314">[1 more]</label></div><br/><div class="children"><div class="content">After convert the keys to u32, they can use more specialized data structure like croaring to get an order of magnitude faster.</div><br/></div></div></div></div></div></div><div id="40048086" class="c"><input type="checkbox" id="c-40048086" checked=""/><div class="controls bullet"><span class="by">adultSwim</span><span>|</span><a href="#40045281">prev</a><span>|</span><label class="collapse" for="c-40048086">[-]</label><label class="expand" for="c-40048086">[1 more]</label></div><br/><div class="children"><div class="content">The online graph algorithm in the post reminded me of Frank McSherry&#x27;s Differential Dataflow.</div><br/></div></div></div></div></div></div></div></body></html>