<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729846877298" as="style"/><link rel="stylesheet" href="styles.css?v=1729846877298"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/E-xyza/zigler">Zigler: Zig NIFs in Elixir</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>ksec</span> | <span>62 comments</span></div><br/><div><div id="41943475" class="c"><input type="checkbox" id="c-41943475" checked=""/><div class="controls bullet"><span class="by">Dowwie</span><span>|</span><a href="#41938301">next</a><span>|</span><label class="collapse" for="c-41943475">[-]</label><label class="expand" for="c-41943475">[1 more]</label></div><br/><div class="children"><div class="content">Understand NIF risks: they can crash your entire Elixir Application, beyond their immediate supervision tree, because they operate in the same memory space as the BEAM itself.<p>NIF responsibly. :)</div><br/></div></div><div id="41938301" class="c"><input type="checkbox" id="c-41938301" checked=""/><div class="controls bullet"><span class="by">ihumanable</span><span>|</span><a href="#41943475">prev</a><span>|</span><a href="#41939215">next</a><span>|</span><label class="collapse" for="c-41938301">[-]</label><label class="expand" for="c-41938301">[34 more]</label></div><br/><div class="children"><div class="content">For anyone mystified about what a NIF is that doesn&#x27;t want to go read the docs.<p>The BEAM VM (which is the thing that runs erlang &#x2F; elixir &#x2F; gleam &#x2F; etc) has 3 flavors of functions.<p>- BIFs - Built-in functions, these are written in C and ship with the VM<p>- NIFs - Natively implemented functions, these are written in any language that can speak the NIF ABI that BEAM exposes and allows you to provide a function that looks like a built-in function but that you build yourself.<p>- User - User functions are written in the language that&#x27;s running on BEAM, so if you write a function in erlang or elixir, that&#x27;s a user function.<p>NIFs allow you to drop down into a lower level language and extend the VM.  Originally most NIFs were written in C, but now a lot more languages have built out nice facilities for writing NIFs.  Rust has Rustler and Zig now has Zigler, although people have been writing zig nifs for a while without zigler and I&#x27;m sure people wrote rust nifs without rustler.</div><br/><div id="41938375" class="c"><input type="checkbox" id="c-41938375" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41938301">parent</a><span>|</span><a href="#41942358">next</a><span>|</span><label class="collapse" for="c-41938375">[-]</label><label class="expand" for="c-41938375">[22 more]</label></div><br/><div class="children"><div class="content">It’s important to note that while Erlang has protections against user code crashing an Erlang process and recovering, a faulty NIF can take down the entire virtual machine.</div><br/><div id="41939013" class="c"><input type="checkbox" id="c-41939013" checked=""/><div class="controls bullet"><span class="by">kristoff_it</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41938375">parent</a><span>|</span><a href="#41938422">next</a><span>|</span><label class="collapse" for="c-41939013">[-]</label><label class="expand" for="c-41939013">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a series of things that a NIF must do to be a good citizen. Not crashing is a big one, but also not starving the VM by never yielding (in case the NIF is long-running) is important, plus a few secondary things like using the BEAM allocator so that tooling that monitors memory consumption can see resources consumed by the NIF.<p>The creator of Zigler has a talk from ElixirConf 2021 on how he made Zig NIFs behave nicely:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=lDfjdGva3NE" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=lDfjdGva3NE</a></div><br/></div></div><div id="41938422" class="c"><input type="checkbox" id="c-41938422" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41938375">parent</a><span>|</span><a href="#41939013">prev</a><span>|</span><a href="#41939165">next</a><span>|</span><label class="collapse" for="c-41938422">[-]</label><label class="expand" for="c-41938422">[19 more]</label></div><br/><div class="children"><div class="content">Hence why Rustler is of so much interest since it provides more protections against this happening.<p>Discord is a big Erlang + Rustler user.</div><br/><div id="41940150" class="c"><input type="checkbox" id="c-41940150" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41938422">parent</a><span>|</span><a href="#41939147">next</a><span>|</span><label class="collapse" for="c-41940150">[-]</label><label class="expand" for="c-41940150">[4 more]</label></div><br/><div class="children"><div class="content">What kind of protections as opposed to Zigler?</div><br/><div id="41942658" class="c"><input type="checkbox" id="c-41942658" checked=""/><div class="controls bullet"><span class="by">el_oni</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41940150">parent</a><span>|</span><a href="#41940267">next</a><span>|</span><label class="collapse" for="c-41942658">[-]</label><label class="expand" for="c-41942658">[1 more]</label></div><br/><div class="children"><div class="content">Rustler catches panics before they crash the VM and raises them on the elixir side as an exception. So your process might crash but the vm wont</div><br/></div></div><div id="41940267" class="c"><input type="checkbox" id="c-41940267" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41940150">parent</a><span>|</span><a href="#41942658">prev</a><span>|</span><a href="#41939147">next</a><span>|</span><label class="collapse" for="c-41940267">[-]</label><label class="expand" for="c-41940267">[2 more]</label></div><br/><div class="children"><div class="content">Rust comes with memory safety.<p>It&#x27;s one less potential cause that might bring down the entire Erlang VM.</div><br/><div id="41940462" class="c"><input type="checkbox" id="c-41940462" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41940267">parent</a><span>|</span><a href="#41939147">next</a><span>|</span><label class="collapse" for="c-41940462">[-]</label><label class="expand" for="c-41940462">[1 more]</label></div><br/><div class="children"><div class="content">SIGSEGV is a pretty common failure mode alright.</div><br/></div></div></div></div></div></div><div id="41939147" class="c"><input type="checkbox" id="c-41939147" checked=""/><div class="controls bullet"><span class="by">depr</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41938422">parent</a><span>|</span><a href="#41940150">prev</a><span>|</span><a href="#41939154">next</a><span>|</span><label class="collapse" for="c-41939147">[-]</label><label class="expand" for="c-41939147">[10 more]</label></div><br/><div class="children"><div class="content">Are they really? Their projects don&#x27;t look so active</div><br/><div id="41939317" class="c"><input type="checkbox" id="c-41939317" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41939147">parent</a><span>|</span><a href="#41939968">next</a><span>|</span><label class="collapse" for="c-41939317">[-]</label><label class="expand" for="c-41939317">[8 more]</label></div><br/><div class="children"><div class="content">It’s pretty common in the Elixir ecosystem for these types of libraries to not change very much.  Elixir itself doesn’t change too much so these libraries stay solid without needing frequent updates.  It doesn’t mean people aren’t using them.  Some libraries even put disclaimers that they are actively maintained even if they haven’t seen an update in a long time. It’s something that takes some getting used to for some people (including myself at one point).</div><br/><div id="41940424" class="c"><input type="checkbox" id="c-41940424" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41939317">parent</a><span>|</span><a href="#41940191">next</a><span>|</span><label class="collapse" for="c-41940424">[-]</label><label class="expand" for="c-41940424">[5 more]</label></div><br/><div class="children"><div class="content">&gt; It’s pretty common in the Elixir ecosystem for these types of libraries to not change very much.<p>This is kind of fascinating and seems worthy of more detailed study.  I&#x27;m sure almost anything looks stable compared to javascript&#x2F;python ecosystems, but would be interesting to see how other ecosystems with venerable old web-frameworks or solid old compression libraries compare.  But on further reflection.. language metrics like &quot;popularity&quot; are also in danger of just quantifying the churn that it takes to keep working stuff working.  You can&#x27;t even measure strictly new projects and hope that helps, because new projects may be a reaction to perceived need to replace other stuff that&#x27;s annoyingly unstable over periods of 5-10 years, etc.<p>Some churn is introduced by trying to keep up with a changing language, standard lib, or other dependencies, but some is just adding features forever or endlessly refactoring aesthetics under different management.  Makes me wish for a project badge to indicate a commitment like finished-except-for-bugfixes.</div><br/><div id="41941391" class="c"><input type="checkbox" id="c-41941391" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41940424">parent</a><span>|</span><a href="#41940491">next</a><span>|</span><label class="collapse" for="c-41941391">[-]</label><label class="expand" for="c-41941391">[1 more]</label></div><br/><div class="children"><div class="content">Erlang (and friends) are built with a goal of stability. Operational stability is part of that, but it also comes into play with code and architectural stability.<p>Maybe it&#x27;s the functionalness, maybe it&#x27;s the problem domains, but a lot of the modules have clear boundaries and end up with pretty small modules where the libraries end up having a clear scope and a small code base that moves towards being obviously correct and good for most and then doesn&#x27;t have much changes after that. It might not work for everyone, but most modules don&#x27;t end up with lots of options to support all the possible use cases.<p>The underlying bits of OTP don&#x27;t tend to churn too much either, so old code usually continues to work, unless you managed to have a dependency on something that had a big change. I recall dealing with some changes in timekeeping and random sources, but otherwise I don&#x27;t remember having to change my Erlang code for OTP updates.<p>It helps that the OTP team is supporting several major versions (annual releases) simultaneously, so if there&#x27;s a lot of unneccessary change, that makes their job harder as well as everyone else&#x27;s.</div><br/></div></div><div id="41940491" class="c"><input type="checkbox" id="c-41940491" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41940424">parent</a><span>|</span><a href="#41941391">prev</a><span>|</span><a href="#41943332">next</a><span>|</span><label class="collapse" for="c-41940491">[-]</label><label class="expand" for="c-41940491">[2 more]</label></div><br/><div class="children"><div class="content">Elixir itself is &quot;feature complete&quot; as of 2019 (5-years now).<p><a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2019&#x2F;06&#x2F;24&#x2F;elixir-v1-9-0-released&#x2F;" rel="nofollow">https:&#x2F;&#x2F;elixir-lang.org&#x2F;blog&#x2F;2019&#x2F;06&#x2F;24&#x2F;elixir-v1-9-0-releas...</a><p>It does get the occasional updates, but it&#x27;s mainly related to developer tooling than language enhancements.</div><br/><div id="41941194" class="c"><input type="checkbox" id="c-41941194" checked=""/><div class="controls bullet"><span class="by">hmmokidk</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41940491">parent</a><span>|</span><a href="#41943332">next</a><span>|</span><label class="collapse" for="c-41941194">[-]</label><label class="expand" for="c-41941194">[1 more]</label></div><br/><div class="children"><div class="content">with the maybe exception of the type system</div><br/></div></div></div></div><div id="41943332" class="c"><input type="checkbox" id="c-41943332" checked=""/><div class="controls bullet"><span class="by">the_duke</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41940424">parent</a><span>|</span><a href="#41940491">prev</a><span>|</span><a href="#41940191">next</a><span>|</span><label class="collapse" for="c-41943332">[-]</label><label class="expand" for="c-41943332">[1 more]</label></div><br/><div class="children"><div class="content">Same in Java.<p>You can find libraries that haven&#x27;t been updated in 10 years and yet are still the best solution.</div><br/></div></div></div></div><div id="41940191" class="c"><input type="checkbox" id="c-41940191" checked=""/><div class="controls bullet"><span class="by">sbuttgereit</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41939317">parent</a><span>|</span><a href="#41940424">prev</a><span>|</span><a href="#41939705">next</a><span>|</span><label class="collapse" for="c-41940191">[-]</label><label class="expand" for="c-41940191">[1 more]</label></div><br/><div class="children"><div class="content">Yep.  This is one reason I choose Elixir for a project.  For a variety of use cases, long term stability is a big plus.</div><br/></div></div><div id="41939705" class="c"><input type="checkbox" id="c-41939705" checked=""/><div class="controls bullet"><span class="by">andy_ppp</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41939317">parent</a><span>|</span><a href="#41940191">prev</a><span>|</span><a href="#41939968">next</a><span>|</span><label class="collapse" for="c-41939705">[-]</label><label class="expand" for="c-41939705">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I was trying to explain this to another developer that packages end up being “finished” eventually and seem to continue to work exceptionally well without updates for a really long time.<p>Something about immutability and the structure of Elixir leads to surprisingly few bugs.</div><br/></div></div></div></div><div id="41939968" class="c"><input type="checkbox" id="c-41939968" checked=""/><div class="controls bullet"><span class="by">ihumanable</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41939147">parent</a><span>|</span><a href="#41939317">prev</a><span>|</span><a href="#41939154">next</a><span>|</span><label class="collapse" for="c-41939968">[-]</label><label class="expand" for="c-41939968">[1 more]</label></div><br/><div class="children"><div class="content">I wrote sorted_set_nif, the lack of activity isn’t a lack of care about the library but more just a reflection that the library is done.<p>With data structures that have some definite behavior unless someone finds a defect there isn’t going to be much activity.</div><br/></div></div></div></div><div id="41938636" class="c"><input type="checkbox" id="c-41938636" checked=""/><div class="controls bullet"><span class="by">drawnwren</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41938422">parent</a><span>|</span><a href="#41939154">prev</a><span>|</span><a href="#41939165">next</a><span>|</span><label class="collapse" for="c-41938636">[-]</label><label class="expand" for="c-41938636">[3 more]</label></div><br/><div class="children"><div class="content">Is any of this code open source? As an outsider, I&#x27;m kind of at a loss for why anyone wants this or what you kids are doing over there and how offended I should be by it.</div><br/><div id="41938715" class="c"><input type="checkbox" id="c-41938715" checked=""/><div class="controls bullet"><span class="by">jhgg</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41938636">parent</a><span>|</span><a href="#41938874">next</a><span>|</span><label class="collapse" for="c-41938715">[-]</label><label class="expand" for="c-41938715">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;discord&#x2F;sorted_set_nif">https:&#x2F;&#x2F;github.com&#x2F;discord&#x2F;sorted_set_nif</a></div><br/></div></div><div id="41938874" class="c"><input type="checkbox" id="c-41938874" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41938636">parent</a><span>|</span><a href="#41938715">prev</a><span>|</span><a href="#41939165">next</a><span>|</span><label class="collapse" for="c-41938874">[-]</label><label class="expand" for="c-41938874">[1 more]</label></div><br/><div class="children"><div class="content">Do you mean Rustler?<p>Yes, it&#x27;s Apache 2.0<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rusterlium&#x2F;rustler">https:&#x2F;&#x2F;github.com&#x2F;rusterlium&#x2F;rustler</a></div><br/></div></div></div></div></div></div><div id="41939165" class="c"><input type="checkbox" id="c-41939165" checked=""/><div class="controls bullet"><span class="by">jlkjfuwnjalfw</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41938375">parent</a><span>|</span><a href="#41938422">prev</a><span>|</span><a href="#41942358">next</a><span>|</span><label class="collapse" for="c-41939165">[-]</label><label class="expand" for="c-41939165">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t be like me and do a 20ms page fault in a NIF</div><br/></div></div></div></div><div id="41942358" class="c"><input type="checkbox" id="c-41942358" checked=""/><div class="controls bullet"><span class="by">cooljacob204</span><span>|</span><a href="#41938301">parent</a><span>|</span><a href="#41938375">prev</a><span>|</span><a href="#41939014">next</a><span>|</span><label class="collapse" for="c-41942358">[-]</label><label class="expand" for="c-41942358">[3 more]</label></div><br/><div class="children"><div class="content">Do nifs have the equal process time stuff that regular elixir processes have? Where the BEAM will move the scheduler into another process if it&#x27;s taking too long?<p>Forgive me if I&#x27;m mixing up my terminology it&#x27;s been a bit since I have poked at Elixir.</div><br/><div id="41942486" class="c"><input type="checkbox" id="c-41942486" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41942358">parent</a><span>|</span><a href="#41942442">next</a><span>|</span><label class="collapse" for="c-41942486">[-]</label><label class="expand" for="c-41942486">[1 more]</label></div><br/><div class="children"><div class="content">You can write nifs that way but it seems like a pain in the ass<p><a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;apps&#x2F;erts&#x2F;erl_nif#enif_schedule_nif" rel="nofollow">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;apps&#x2F;erts&#x2F;erl_nif#enif_schedule_n...</a><p>After all, many of the BIFs have been replaced internally by NIFs<p>And there&#x27;s this, which would scare me:<p><a href="https:&#x2F;&#x2F;erlang.org&#x2F;documentation&#x2F;doc-15.0-rc3&#x2F;erts-15.0&#x2F;doc&#x2F;html&#x2F;automaticyieldingofccode.html#introduction" rel="nofollow">https:&#x2F;&#x2F;erlang.org&#x2F;documentation&#x2F;doc-15.0-rc3&#x2F;erts-15.0&#x2F;doc&#x2F;...</a></div><br/></div></div><div id="41942442" class="c"><input type="checkbox" id="c-41942442" checked=""/><div class="controls bullet"><span class="by">rubyn00bie</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41942358">parent</a><span>|</span><a href="#41942486">prev</a><span>|</span><a href="#41939014">next</a><span>|</span><label class="collapse" for="c-41942442">[-]</label><label class="expand" for="c-41942442">[1 more]</label></div><br/><div class="children"><div class="content">Nope, at least not by default or like one would expect from pure Erlang (when it comes to preempting). Been a while since I dug into this admittedly but I write Elixir daily for work (and have for about ten years now). They don’t do the record keeping necessary for the BEAM to interrupt. You need to make sure the “dirty scheduler” is enabled or you can end up blocking other processes on the same scheduler.<p>Here’s a link I found talking about using the dirty scheduler with Rust(ler): <a href="https:&#x2F;&#x2F;bgmarx.com&#x2F;2018&#x2F;08&#x2F;15&#x2F;using-dirty-schedulers-with-rustler&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bgmarx.com&#x2F;2018&#x2F;08&#x2F;15&#x2F;using-dirty-schedulers-with-ru...</a></div><br/></div></div></div></div><div id="41939014" class="c"><input type="checkbox" id="c-41939014" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#41938301">parent</a><span>|</span><a href="#41942358">prev</a><span>|</span><a href="#41939215">next</a><span>|</span><label class="collapse" for="c-41939014">[-]</label><label class="expand" for="c-41939014">[8 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also important to point out ports, because as you mention, NIFs are a way to integrate external code. But as someone else points out, NIFs can crash the entire BEAM VM. Ports are a safer way to integrate external code because they are just another BEAM process that talks to an external program. If that program crashes, then the port process crashes just like any other BEAM process but it won&#x27;t crash the entire BEAM VM.</div><br/><div id="41939313" class="c"><input type="checkbox" id="c-41939313" checked=""/><div class="controls bullet"><span class="by">gioazzi</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41939014">parent</a><span>|</span><a href="#41940527">next</a><span>|</span><label class="collapse" for="c-41939313">[-]</label><label class="expand" for="c-41939313">[3 more]</label></div><br/><div class="children"><div class="content">And then there are port drivers which are the worst of both worlds! Can crash the BEAM and need much more ceremony than NIF to set up  but they’re pretty nice to do in Zig[1] as well<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;borgoat&#x2F;er_zig_driver">https:&#x2F;&#x2F;github.com&#x2F;borgoat&#x2F;er_zig_driver</a></div><br/><div id="41939434" class="c"><input type="checkbox" id="c-41939434" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41939313">parent</a><span>|</span><a href="#41940527">next</a><span>|</span><label class="collapse" for="c-41939434">[-]</label><label class="expand" for="c-41939434">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true. Haha!<p>There&#x27;s another option and that&#x27;s setting up an Erlang node in the other language. The Erlang term format is relatively straightforward. But I&#x27;m honestly not sure of the benefit of a node versus just using a port.</div><br/><div id="41939807" class="c"><input type="checkbox" id="c-41939807" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41939434">parent</a><span>|</span><a href="#41940527">next</a><span>|</span><label class="collapse" for="c-41939807">[-]</label><label class="expand" for="c-41939807">[1 more]</label></div><br/><div class="children"><div class="content">Node:<p>- can &quot;easily&quot; send beam terms back and forth<p>- if you want it to be os-supervised separately (systemd, kubernetes, e.g.)<p>- pain in the ass<p>Port:<p>- easy<p>- usually the only choice if you&#x27;re not the software author<p>- really only communicates via stdio bytestreams<p>- risk of zombies if... Iirc the stdout is not closed properly?<p>- kind of crazy how it works, Erlang VM spawns a separate process as a middleman</div><br/></div></div></div></div></div></div><div id="41940527" class="c"><input type="checkbox" id="c-41940527" checked=""/><div class="controls bullet"><span class="by">abrookewood</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41939014">parent</a><span>|</span><a href="#41939313">prev</a><span>|</span><a href="#41939215">next</a><span>|</span><label class="collapse" for="c-41940527">[-]</label><label class="expand" for="c-41940527">[4 more]</label></div><br/><div class="children"><div class="content">Why would anyone use a NIF instead of a Port then?</div><br/><div id="41941311" class="c"><input type="checkbox" id="c-41941311" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41940527">parent</a><span>|</span><a href="#41940652">next</a><span>|</span><label class="collapse" for="c-41941311">[-]</label><label class="expand" for="c-41941311">[1 more]</label></div><br/><div class="children"><div class="content">NIFs are great for things that really feel like a relatively quick function call.<p>If you&#x27;ve got some mathematical&#x2F;crypto function, chances are you don&#x27;t want that to go through a command queue to an external port, because that&#x27;s too much overhead. If it&#x27;s a many round crypto function like bcrypt or something, you do need to be a bit careful doing it as a NIF because of runtime. But you wouldn&#x27;t want to put a sha256 through an external program and have to pass all that data to it, etc.<p>Something that you might actually want queueing for and is likely to have potential for memory unsafety like say transcoding with ffmpeg, would be a good fit as an external Port rather than a NIF or a linked in Port driver.</div><br/></div></div><div id="41940652" class="c"><input type="checkbox" id="c-41940652" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#41938301">root</a><span>|</span><a href="#41940527">parent</a><span>|</span><a href="#41941311">prev</a><span>|</span><a href="#41941445">next</a><span>|</span><label class="collapse" for="c-41940652">[-]</label><label class="expand" for="c-41940652">[1 more]</label></div><br/><div class="children"><div class="content">IPC&#x2F;shared memory overhead?</div><br/></div></div></div></div></div></div></div></div><div id="41939215" class="c"><input type="checkbox" id="c-41939215" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#41938301">prev</a><span>|</span><a href="#41938052">next</a><span>|</span><label class="collapse" for="c-41939215">[-]</label><label class="expand" for="c-41939215">[2 more]</label></div><br/><div class="children"><div class="content">Zig is also used in an excellent way by burrito[0]. I&#x27;ve also used zig for compiling NIFs written in C&#x2F;C++&#x2F;Objective-C, since `zig cc` makes cross-compiling much nicer.<p>I wish zig got more use and attention in the Erlang ecosystem, but rustler seems more popular.</div><br/><div id="41940382" class="c"><input type="checkbox" id="c-41940382" checked=""/><div class="controls bullet"><span class="by">kansi</span><span>|</span><a href="#41939215">parent</a><span>|</span><a href="#41938052">next</a><span>|</span><label class="collapse" for="c-41940382">[-]</label><label class="expand" for="c-41940382">[1 more]</label></div><br/><div class="children"><div class="content">[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;burrito-elixir&#x2F;burrito">https:&#x2F;&#x2F;github.com&#x2F;burrito-elixir&#x2F;burrito</a></div><br/></div></div></div></div><div id="41938052" class="c"><input type="checkbox" id="c-41938052" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#41939215">prev</a><span>|</span><a href="#41938752">next</a><span>|</span><label class="collapse" for="c-41938052">[-]</label><label class="expand" for="c-41938052">[1 more]</label></div><br/><div class="children"><div class="content">Completely lacking a description that made it clear, but basically, from what I can tell, this lets you embed Zig code inside Elixir code</div><br/></div></div><div id="41938752" class="c"><input type="checkbox" id="c-41938752" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#41938052">prev</a><span>|</span><a href="#41938224">next</a><span>|</span><label class="collapse" for="c-41938752">[-]</label><label class="expand" for="c-41938752">[7 more]</label></div><br/><div class="children"><div class="content">Does anyone actually enjoy using these systems that encourage you to embed programming-language X code in programming-language Y heredocs?<p>I always find actually <i>doing</i> that — and then maintaining the results over time — to be quite painful: you don&#x27;t get syntax highlighting inside the string; you can no longer search your worktree reliably using extension-based filtering; etc.<p>I personally find the workflow much more sane if&#x2F;when you just have a separate file (e.g. `foo.zig`) for the guest-language code, and then your host-language code references it.</div><br/><div id="41938919" class="c"><input type="checkbox" id="c-41938919" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41938752">parent</a><span>|</span><a href="#41942317">next</a><span>|</span><label class="collapse" for="c-41938919">[-]</label><label class="expand" for="c-41938919">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done some assembly in C, and for big functions, yeah, I want it in its own file, but smaller things often make sense to embed. I&#x27;m not sure if I&#x27;d like my nif code embedded into my erl files (assuming this works for Erlang as well), but it could conceivably make the nasty bit of boilerplate around ERL_NIF_INIT in the NIF (which I have to do in C anyway) and exit(nif_library_not_loaded) in the erl go away, which would be nice.<p>It&#x27;s certainly possible to get syntax highlighting on the embedded code, but you&#x27;ll need to work with your syntax highlighter; it certainly helps if you&#x27;re not the only person using it.<p>But then again, I worked without syntax highlighting for years, so I&#x27;m happy when it works, but when it doesn&#x27;t, I&#x27;m ok with that too.</div><br/></div></div><div id="41942317" class="c"><input type="checkbox" id="c-41942317" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41938752">parent</a><span>|</span><a href="#41938919">prev</a><span>|</span><a href="#41939155">next</a><span>|</span><label class="collapse" for="c-41942317">[-]</label><label class="expand" for="c-41942317">[1 more]</label></div><br/><div class="children"><div class="content">I’m not too familiar with Elixir, but I definitely prefer building libraries in Zig and then consuming them in Python, TS, whatever over embedding them inside another language directly.<p>That being said, you can get IDE language support for embedded code if you use eMacs or vim (and probably other editors as well). As I mentioned I still vastly prefer separating it personally, especially if you don’t necessarily expect your Python or Typescript programmers to be knowledgeable about Zig (or C).</div><br/></div></div><div id="41939155" class="c"><input type="checkbox" id="c-41939155" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#41938752">parent</a><span>|</span><a href="#41942317">prev</a><span>|</span><a href="#41942484">next</a><span>|</span><label class="collapse" for="c-41939155">[-]</label><label class="expand" for="c-41939155">[2 more]</label></div><br/><div class="children"><div class="content">Syntax highlighting here can work correctly, actually.<p>Also, I&#x27;m not sure why it&#x27;s not better documented in Zigler, but you can also write the code in a separate file just fine.</div><br/><div id="41941208" class="c"><input type="checkbox" id="c-41941208" checked=""/><div class="controls bullet"><span class="by">h0l0cube</span><span>|</span><a href="#41938752">root</a><span>|</span><a href="#41939155">parent</a><span>|</span><a href="#41942484">next</a><span>|</span><label class="collapse" for="c-41941208">[-]</label><label class="expand" for="c-41941208">[1 more]</label></div><br/><div class="children"><div class="content">Links for anyone curious.<p>&gt; Syntax highlighting here can work correctly, actually.<p>Highlighting shown here in the 2021 ElixirConf talk posted elsewhere in the comments:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;lDfjdGva3NE?t=2064" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;lDfjdGva3NE?t=2064</a><p>&gt; I&#x27;m not sure why it&#x27;s not better documented in Zigler<p>Here&#x27;s the docs for it (though buried in the &#x27;advanced&#x27; section)<p><a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;zigler&#x2F;Zig.html#module-importing-external-files" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;zigler&#x2F;Zig.html#module-importing-external...</a></div><br/></div></div></div></div><div id="41942484" class="c"><input type="checkbox" id="c-41942484" checked=""/><div class="controls bullet"><span class="by">travisgriggs</span><span>|</span><a href="#41938752">parent</a><span>|</span><a href="#41939155">prev</a><span>|</span><a href="#41938911">next</a><span>|</span><label class="collapse" for="c-41942484">[-]</label><label class="expand" for="c-41942484">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does anyone actually enjoy using these systems that encourage you to embed programming-language X code in programming-language Y heredocs?<p>Isn’t that essentially any web application?</div><br/></div></div><div id="41938911" class="c"><input type="checkbox" id="c-41938911" checked=""/><div class="controls bullet"><span class="by">systems</span><span>|</span><a href="#41938752">parent</a><span>|</span><a href="#41942484">prev</a><span>|</span><a href="#41938224">next</a><span>|</span><label class="collapse" for="c-41938911">[-]</label><label class="expand" for="c-41938911">[1 more]</label></div><br/><div class="children"><div class="content">I initially agree<p>But, if all you do is write elixir wrappers around the zig function, to completely hide the foreign language functions, keeping both the wrapper and implementation in the same file, even if two different languages doesn&#x27;t seem horrible, but again, keeping them in two file doesn&#x27;t seem like a huge difference too<p>I think its really a matter of taste, both options viable</div><br/></div></div></div></div><div id="41938224" class="c"><input type="checkbox" id="c-41938224" checked=""/><div class="controls bullet"><span class="by">kuon</span><span>|</span><a href="#41938752">prev</a><span>|</span><a href="#41940340">next</a><span>|</span><label class="collapse" for="c-41938224">[-]</label><label class="expand" for="c-41938224">[5 more]</label></div><br/><div class="children"><div class="content">I use zig a lot in elixir nif, for things like audio and video processing, it works great. But I do not use zigler as I prefer the code to live in their own codebases. But zigler is really nice and it provides an easy way to do computational heavy tasks in elixir.</div><br/><div id="41939746" class="c"><input type="checkbox" id="c-41939746" checked=""/><div class="controls bullet"><span class="by">kansi</span><span>|</span><a href="#41938224">parent</a><span>|</span><a href="#41940340">next</a><span>|</span><label class="collapse" for="c-41939746">[-]</label><label class="expand" for="c-41939746">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I use zig a lot in elixir nif, for things like audio and video processing<p>Sounds interesting, is it open source? I am interested in seeing how the code layout looks like when mixing Zig and Elixir</div><br/><div id="41940146" class="c"><input type="checkbox" id="c-41940146" checked=""/><div class="controls bullet"><span class="by">kuon</span><span>|</span><a href="#41938224">root</a><span>|</span><a href="#41939746">parent</a><span>|</span><a href="#41940340">next</a><span>|</span><label class="collapse" for="c-41940146">[-]</label><label class="expand" for="c-41940146">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have open source code base to share but here it how it looks like:<p><pre><code>        &#x2F;&#x2F; the_nif.zig

        fn init_imp(
            env: ?*erl.ErlNifEnv,
            argc: c_int,
            argv: [*c]const erl.ERL_NIF_TERM,
        ) !erl.ERL_NIF_TERM {
            if (argc != 0) {
                return error.BadArg;
            }

            return try helpers.make(&quot;Hello world&quot;);
        }

        export fn media_tools_init(
            env: ?*erl.ErlNifEnv,
            argc: c_int,
            argv: [*c]const erl.ERL_NIF_TERM,
        ) erl.ERL_NIF_TERM {
            return init_imp(env, argc, argv) catch |err|
                return helpers.make_error(env, err);
        }


        var funcs = [_]erl.ErlNifFunc{ erl.ErlNifFunc{
            .name = &quot;init&quot;,
            .arity = 1,
            .fptr = media_tools_init,
            .flags = erl.ERL_NIF_DIRTY_JOB_CPU_BOUND, 
        } };

        var entry = erl.ErlNifEntry{
            .major = erl.ERL_NIF_MAJOR_VERSION,
            .minor = erl.ERL_NIF_MINOR_VERSION,
            .name = &quot;Elixir.MediaTools.Stream&quot;,
            .num_of_funcs = funcs.len,
            .funcs = &amp;funcs,
            .load = load,
            .reload = null,
            .upgrade = null,
            .unload = null,
            .vm_variant = &quot;beam.vanilla&quot;,
            .options = 0,
            .sizeof_ErlNifResourceTypeInit = @sizeOf(erl.ErlNifResourceTypeInit),
            .min_erts = &quot;erts-10.4&quot;,
        };

        export fn nif_init() *erl.ErlNifEntry {
            return &amp;entry;
        }

        # the_exlixir_file.ex

        assert &quot;Hello world&quot; == MediaTools.Stream.init()

</code></pre>
The &quot;helpers&quot; library is used to convert types to and from erlang, I plan on open sourcing it but it is not ready now. In the above example, the code is explicit but &quot;entry&quot; can be created with an helper comptime function. erl is simply the erl_nif.h header converted by zig translate-c.<p>I wrote a piece back in 2022, but things evolved a lot since then: <a href="https:&#x2F;&#x2F;www.kuon.ch&#x2F;post&#x2F;2022-11-26-zig-nif&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.kuon.ch&#x2F;post&#x2F;2022-11-26-zig-nif&#x2F;</a></div><br/><div id="41942785" class="c"><input type="checkbox" id="c-41942785" checked=""/><div class="controls bullet"><span class="by">filmor</span><span>|</span><a href="#41938224">root</a><span>|</span><a href="#41940146">parent</a><span>|</span><a href="#41940327">next</a><span>|</span><label class="collapse" for="c-41942785">[-]</label><label class="expand" for="c-41942785">[1 more]</label></div><br/><div class="children"><div class="content">This won&#x27;t work on Windows as the BEAM uses a slightly different NIF initialisation method there.</div><br/></div></div><div id="41940327" class="c"><input type="checkbox" id="c-41940327" checked=""/><div class="controls bullet"><span class="by">kansi</span><span>|</span><a href="#41938224">root</a><span>|</span><a href="#41940146">parent</a><span>|</span><a href="#41942785">prev</a><span>|</span><a href="#41940340">next</a><span>|</span><label class="collapse" for="c-41940327">[-]</label><label class="expand" for="c-41940327">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing the post, it was intriguing. The detailed comments mentioned in `main.zig` and `build.zig` towards the end helped a lot.</div><br/></div></div></div></div></div></div></div></div><div id="41940340" class="c"><input type="checkbox" id="c-41940340" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41938224">prev</a><span>|</span><a href="#41938223">next</a><span>|</span><label class="collapse" for="c-41940340">[-]</label><label class="expand" for="c-41940340">[2 more]</label></div><br/><div class="children"><div class="content">(Yo dawg, we put a niche language into a niche language so that...)<p>I wonder if the Zig code can be <i>not</i> written inline, as an option. With anything larger than a few lines, I&#x27;d want syntax highlighting, LSP support, navigation, etc. It&#x27;s easier to achieve with one language per file.</div><br/><div id="41940986" class="c"><input type="checkbox" id="c-41940986" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#41940340">parent</a><span>|</span><a href="#41938223">next</a><span>|</span><label class="collapse" for="c-41940986">[-]</label><label class="expand" for="c-41940986">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you can put Zig code in a separate file.</div><br/></div></div></div></div><div id="41938223" class="c"><input type="checkbox" id="c-41938223" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#41940340">prev</a><span>|</span><a href="#41938192">next</a><span>|</span><label class="collapse" for="c-41938223">[-]</label><label class="expand" for="c-41938223">[3 more]</label></div><br/><div class="children"><div class="content">Great! But, what is a nifs, please?  :&#x27;D</div><br/><div id="41938235" class="c"><input type="checkbox" id="c-41938235" checked=""/><div class="controls bullet"><span class="by">jameskilton</span><span>|</span><a href="#41938223">parent</a><span>|</span><a href="#41940993">next</a><span>|</span><label class="collapse" for="c-41938235">[-]</label><label class="expand" for="c-41938235">[1 more]</label></div><br/><div class="children"><div class="content">Natively Implemented Functions<p><a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;system&#x2F;nif.html" rel="nofollow">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;system&#x2F;nif.html</a></div><br/></div></div><div id="41940993" class="c"><input type="checkbox" id="c-41940993" checked=""/><div class="controls bullet"><span class="by">sangnoir</span><span>|</span><a href="#41938223">parent</a><span>|</span><a href="#41938235">prev</a><span>|</span><a href="#41938192">next</a><span>|</span><label class="collapse" for="c-41940993">[-]</label><label class="expand" for="c-41940993">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s Elixir&#x27;s[1] equivalent of a Foreign Function Interface.<p>1. More accurately, NIFs sre BEAM&#x27;s take on FFI functions, and Elixir is a BEAM language.</div><br/></div></div></div></div><div id="41938192" class="c"><input type="checkbox" id="c-41938192" checked=""/><div class="controls bullet"><span class="by">G4BB3R</span><span>|</span><a href="#41938223">prev</a><span>|</span><label class="collapse" for="c-41938192">[-]</label><label class="expand" for="c-41938192">[6 more]</label></div><br/><div class="children"><div class="content">Are sigils (~) restricted to one char?
To me seems ~Zig would be more clear and short enough.</div><br/><div id="41938312" class="c"><input type="checkbox" id="c-41938312" checked=""/><div class="controls bullet"><span class="by">Miner49er</span><span>|</span><a href="#41938192">parent</a><span>|</span><label class="collapse" for="c-41938312">[-]</label><label class="expand" for="c-41938312">[5 more]</label></div><br/><div class="children"><div class="content">Erlang sigils are not, they can be any length, limited to characters allowed in atoms.<p>Elixir sigils also allow multiple characters in the name, but chars after the first must be upper case, according to the docs.<p>So for Elixir, it would have to be something like ~zIG</div><br/><div id="41938447" class="c"><input type="checkbox" id="c-41938447" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41938192">root</a><span>|</span><a href="#41938312">parent</a><span>|</span><a href="#41942839">next</a><span>|</span><label class="collapse" for="c-41938447">[-]</label><label class="expand" for="c-41938447">[2 more]</label></div><br/><div class="children"><div class="content">According to the docs, must be all upper case:<p>&gt; Custom sigils may be either a single lowercase character, or an uppercase character followed by more uppercase characters and digits.<p><a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;sigils.html" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;sigils.html</a></div><br/><div id="41938495" class="c"><input type="checkbox" id="c-41938495" checked=""/><div class="controls bullet"><span class="by">Miner49er</span><span>|</span><a href="#41938192">root</a><span>|</span><a href="#41938447">parent</a><span>|</span><a href="#41942839">next</a><span>|</span><label class="collapse" for="c-41938495">[-]</label><label class="expand" for="c-41938495">[1 more]</label></div><br/><div class="children"><div class="content">Ah yeah, you&#x27;re right.</div><br/></div></div></div></div><div id="41942839" class="c"><input type="checkbox" id="c-41942839" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41938192">root</a><span>|</span><a href="#41938312">parent</a><span>|</span><a href="#41938447">prev</a><span>|</span><label class="collapse" for="c-41942839">[-]</label><label class="expand" for="c-41942839">[2 more]</label></div><br/><div class="children"><div class="content">Wait, erlang has sigils?</div><br/><div id="41943110" class="c"><input type="checkbox" id="c-41943110" checked=""/><div class="controls bullet"><span class="by">com</span><span>|</span><a href="#41938192">root</a><span>|</span><a href="#41942839">parent</a><span>|</span><label class="collapse" for="c-41943110">[-]</label><label class="expand" for="c-41943110">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, there’s a bit of a developer experience push going on in erlang world, which is great!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>