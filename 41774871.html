<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728464455038" as="style"/><link rel="stylesheet" href="styles.css?v=1728464455038"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://devblogs.microsoft.com/oldnewthing/20241007-00/?p=110345">A popular but wrong way to convert a string to uppercase or lowercase</a> <span class="domain">(<a href="https://devblogs.microsoft.com">devblogs.microsoft.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>190 comments</span></div><br/><div><div id="41780014" class="c"><input type="checkbox" id="c-41780014" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#41775180">next</a><span>|</span><label class="collapse" for="c-41780014">[-]</label><label class="expand" for="c-41780014">[28 more]</label></div><br/><div class="children"><div class="content">In gamedev there is simple rule: don&#x27;t try to do any of that.<p>If it is text game needs to show to user then every version of the text that is needed is a translated text. Programmer will never know if context or locale will need word order changes or anything complicated. Just trust the translation team.<p>If text is coming from user - then change design until its not needed to &#x27;convert&#x27;. There are major issues just to show user back what he entered! Because the font for editing and displayed text could be different. Not even mentioning RTL and other issues.<p>Once ppl learn about localization the questions like why a programming language does not do this &#x27;simple text operation&#x27; are just a newcomer detector. :)</div><br/><div id="41780568" class="c"><input type="checkbox" id="c-41780568" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#41780014">parent</a><span>|</span><a href="#41784676">next</a><span>|</span><label class="collapse" for="c-41780568">[-]</label><label class="expand" for="c-41780568">[17 more]</label></div><br/><div class="children"><div class="content">&gt;Once ppl learn about localization the questions like why a programming language does not do this &#x27;simple text operation&#x27; are just a newcomer detector. :)<p>I think you are purposefully misinterpreting the question. They&#x27;re not asking about converting the case of any Unicode string with locale sensitivity, they&#x27;re asking about converting the case of ASCII characters.<p>What if your game needs to talk to a server and do some string manipulation in between requests? Are you really going to architect everything so that the client doesn&#x27;t need to handle any of that ever?</div><br/><div id="41782449" class="c"><input type="checkbox" id="c-41782449" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41780568">parent</a><span>|</span><a href="#41781113">next</a><span>|</span><label class="collapse" for="c-41782449">[-]</label><label class="expand" for="c-41782449">[1 more]</label></div><br/><div class="children"><div class="content">&gt;What if your game needs to talk to a server and do some string manipulation in between requests? Are you really going to architect everything so that the client doesn&#x27;t need to handle any of that ever?<p>Of course! Your string manipulation with user entered attributes like display names or chat messages are 1 millimeter away from old good sql &#x27;Bobby; drop table students&#x27;. Never ever do that if you can avoid it. Every time someone &#x27;just concatenates&#x27; two strings like to add ie &#x27;symbol that represents input button&#x27; programmer makes bad bug that will be both annoying and wrong. Games should use substitution patterns guided by translation team. Because there is no ASCII culture in like around 15 typically supported by big publishers.<p>There are exceptions like platform provided services to filter ban words in chat. And even there you don&#x27;t have to do &#x27;things with ASCII characters&#x27;. Yeah, players will input unsupported symbols everywhere they can and you need to have good replacement characters for those and fix support for popular emojis regularly. That is expected by communities now.</div><br/></div></div><div id="41781113" class="c"><input type="checkbox" id="c-41781113" checked=""/><div class="controls bullet"><span class="by">squeaky-clean</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41780568">parent</a><span>|</span><a href="#41782449">prev</a><span>|</span><a href="#41785479">next</a><span>|</span><label class="collapse" for="c-41781113">[-]</label><label class="expand" for="c-41781113">[7 more]</label></div><br/><div class="children"><div class="content">&gt; They&#x27;re not asking about converting the case of any Unicode string with locale sensitivity, they&#x27;re asking about converting the case of ASCII characters.<p>I&#x27;m confused now. The article specifically mentions issues with UTF-16 and UTF-32 unicode characters outside the basic multilingual plane (BMP).</div><br/><div id="41781244" class="c"><input type="checkbox" id="c-41781244" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41781113">parent</a><span>|</span><a href="#41785479">next</a><span>|</span><label class="collapse" for="c-41781244">[-]</label><label class="expand" for="c-41781244">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m referring to the people who call case conversion in general &quot;a simple text operation&quot;. Say you have an std::string and you want to make it lower case. If you assume it contains just ASCII that&#x27;s a simpler operation than if you assume it contains UTF-8, but C++ doesn&#x27;t provide a single function that does either of them. A person can rightly complain that the former is a basic functionality that the language should include; personally, I would agree. And you could say &quot;wow, doesn&#x27;t this person realize that case conversion in Unicode is actually complicated? They must be really inexperienced.&quot; It could be that the other person really doesn&#x27;t know about Unicode, or it could mean that you and them are thinking about entirely different problems and you&#x27;re being judgemental a bit too eagerly.</div><br/><div id="41781440" class="c"><input type="checkbox" id="c-41781440" checked=""/><div class="controls bullet"><span class="by">squeaky-clean</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41781244">parent</a><span>|</span><a href="#41785479">next</a><span>|</span><label class="collapse" for="c-41781440">[-]</label><label class="expand" for="c-41781440">[5 more]</label></div><br/><div class="children"><div class="content">For ascii in C++ isn&#x27;t there std::tolower &#x2F; std::toupper? If you&#x27;re not dealing with unsigned char types there isn&#x27;t a simple case conversion function, but that&#x27;s for a good reason as the article lays out.</div><br/><div id="41781662" class="c"><input type="checkbox" id="c-41781662" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41781440">parent</a><span>|</span><a href="#41785479">next</a><span>|</span><label class="collapse" for="c-41781662">[-]</label><label class="expand" for="c-41781662">[4 more]</label></div><br/><div class="children"><div class="content">Those functions take and return single characters. What&#x27;s missing is functions that operate on strings. You can use them in combination with std::transform(), but as the article points out, even if you&#x27;re just dealing with ASCII you can easily do it wrong. I&#x27;ve been using C++ for over 20 years and I didn&#x27;t know tolower() and toupper() were non-addressable. There&#x27;s really no excuse for the library not having simple case conversion functions that operate on strings in-place.</div><br/><div id="41783304" class="c"><input type="checkbox" id="c-41783304" checked=""/><div class="controls bullet"><span class="by">squeaky-clean</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41781662">parent</a><span>|</span><a href="#41782846">next</a><span>|</span><label class="collapse" for="c-41783304">[-]</label><label class="expand" for="c-41783304">[2 more]</label></div><br/><div class="children"><div class="content">std::transform() seems like overkill when you can just iterate over the string and modify it in place. And in my opinion, tranform is way less readable than seeing a loop over some array with a single operation inside.<p>The article talks about wstrings for good reason. If you&#x27;re converting narrow strings, you don&#x27;t need to be this fancy. Just loop over the string and edit it in place.<p>If you are operating on wide strings, there is no suitable single solution, partly because wstring is a terrible type. It&#x27;s different widths on different platforms, and no string encoding format uses a generalized wsring, they have mandatory min&#x2F;max character byte widths. So a wstring tells you nothing about the actual encoded string contents semantic representation.<p>The C++ stdlib could include a fully unicode aware string type set, and surrounding library. But personally I think C++ isn&#x27;t the kind of language to provide an opinionated stdlib module for such a complex task. And there&#x27;s no way to implement such a module without being very opinionated about something.</div><br/><div id="41783616" class="c"><input type="checkbox" id="c-41783616" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41783304">parent</a><span>|</span><a href="#41782846">next</a><span>|</span><label class="collapse" for="c-41783616">[-]</label><label class="expand" for="c-41783616">[1 more]</label></div><br/><div class="children"><div class="content">I know I can simply iterate. The point is that it&#x27;s a function that should be included, not that it&#x27;s impossible without it. It&#x27;s one of the most common string operations.</div><br/></div></div></div></div><div id="41782846" class="c"><input type="checkbox" id="c-41782846" checked=""/><div class="controls bullet"><span class="by">theelous3</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41781662">parent</a><span>|</span><a href="#41783304">prev</a><span>|</span><a href="#41785479">next</a><span>|</span><label class="collapse" for="c-41782846">[-]</label><label class="expand" for="c-41782846">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s really no excuse for the library not having simple case conversion functions that operate on strings in-place.<p>Could not agree more. Any time I touch a C I want to scoop my brain out of my ear. So many simple unbelievably common operations have fifty &quot;best&quot; ways to do them, when they should have one happy path 99% of usecases require baked in. Nobody should ever have to seriously consider something as ridiculous as &quot;is tolower addressable?&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41785479" class="c"><input type="checkbox" id="c-41785479" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41780568">parent</a><span>|</span><a href="#41781113">prev</a><span>|</span><a href="#41783402">next</a><span>|</span><label class="collapse" for="c-41785479">[-]</label><label class="expand" for="c-41785479">[1 more]</label></div><br/><div class="children"><div class="content">Nobody is thinking about converting the case of ASCII characters. To be thinking that, they are explicitly excluding most of the world&#x27;s cultures from entering common names correctly. Restricting thought to ASCII is a lack of thought, not an active thought.</div><br/></div></div><div id="41783402" class="c"><input type="checkbox" id="c-41783402" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41780568">parent</a><span>|</span><a href="#41785479">prev</a><span>|</span><a href="#41784676">next</a><span>|</span><label class="collapse" for="c-41783402">[-]</label><label class="expand" for="c-41783402">[7 more]</label></div><br/><div class="children"><div class="content">&gt; What if your game needs to talk to a server and do some string manipulation in between requests?<p>What conceivable reason would there be to ever need to do that? If the server takes commands in upper case, then have them in upper case from the start. If the server takes commands in lower case, have them in lower case from the start. If the server specifies that you need to invert the case of its response to use in the next request, find a server developed by someone not crazy.</div><br/><div id="41783502" class="c"><input type="checkbox" id="c-41783502" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41783402">parent</a><span>|</span><a href="#41784524">next</a><span>|</span><label class="collapse" for="c-41783502">[-]</label><label class="expand" for="c-41783502">[3 more]</label></div><br/><div class="children"><div class="content">Case conversion is not the only string manipulation that&#x27;s locale sensitive.</div><br/><div id="41783630" class="c"><input type="checkbox" id="c-41783630" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41783502">parent</a><span>|</span><a href="#41784524">next</a><span>|</span><label class="collapse" for="c-41783630">[-]</label><label class="expand" for="c-41783630">[2 more]</label></div><br/><div class="children"><div class="content">No reasonable server API should require locale sensitive string manipulation.</div><br/><div id="41784533" class="c"><input type="checkbox" id="c-41784533" checked=""/><div class="controls bullet"><span class="by">NBJack</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41783630">parent</a><span>|</span><a href="#41784524">next</a><span>|</span><label class="collapse" for="c-41784533">[-]</label><label class="expand" for="c-41784533">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, I think you misspelled &quot;true&quot; and &quot;Scotsman&quot; in that sentence.<p>Examples and reasoning for your assertion?</div><br/></div></div></div></div></div></div><div id="41784524" class="c"><input type="checkbox" id="c-41784524" checked=""/><div class="controls bullet"><span class="by">NBJack</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41783402">parent</a><span>|</span><a href="#41783502">prev</a><span>|</span><a href="#41784676">next</a><span>|</span><label class="collapse" for="c-41784524">[-]</label><label class="expand" for="c-41784524">[3 more]</label></div><br/><div class="children"><div class="content">Word censoring? Ease of use? Console commands (i.e. from Quake to minecraft)?</div><br/><div id="41784604" class="c"><input type="checkbox" id="c-41784604" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41784524">parent</a><span>|</span><a href="#41785163">next</a><span>|</span><label class="collapse" for="c-41784604">[-]</label><label class="expand" for="c-41784604">[1 more]</label></div><br/><div class="children"><div class="content">Those sound exactly like the newcomer detectors GP was referring to. What you want is a case-insensitive string comparison, and outside ASCII that&#x27;s not equivalent to just turning both strings to lowercase and checking equality (or doing a substring search or whatever the task requires)</div><br/></div></div><div id="41785163" class="c"><input type="checkbox" id="c-41785163" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41784524">parent</a><span>|</span><a href="#41784604">prev</a><span>|</span><a href="#41784676">next</a><span>|</span><label class="collapse" for="c-41785163">[-]</label><label class="expand" for="c-41785163">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Word censoring?<p>Should only ever be needed for text from the user, and in that case, as GP said, find a way to examine it as-is, don&#x27;t &quot;convert&quot;.<p>&gt; Ease of use?<p>What ease of use? When has futzing around with case ever made anything easier?<p>&gt; Console commands (i.e. from Quake to minecraft)?<p>Why would those necessitate changing case?</div><br/></div></div></div></div></div></div></div></div><div id="41784676" class="c"><input type="checkbox" id="c-41784676" checked=""/><div class="controls bullet"><span class="by">cheema33</span><span>|</span><a href="#41780014">parent</a><span>|</span><a href="#41780568">prev</a><span>|</span><a href="#41780508">next</a><span>|</span><label class="collapse" for="c-41784676">[-]</label><label class="expand" for="c-41784676">[4 more]</label></div><br/><div class="children"><div class="content">&gt; In gamedev there is simple rule: don&#x27;t try to do any of that.<p>I am not in gamedev, but I frequently have to develop middleware that takes in user entered data and formats it in a way that will import into a 3rd party system without errors.  And that sometimes means changing the case on strings.<p>In my experience as a developer, this is very very common requirement.<p>Luckily I am not forced to use a low level language for any of my work.  In C# I can simply do this:  &quot;hello world&quot;.ToUpper();</div><br/><div id="41785429" class="c"><input type="checkbox" id="c-41785429" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41784676">parent</a><span>|</span><a href="#41785474">next</a><span>|</span><label class="collapse" for="c-41785429">[-]</label><label class="expand" for="c-41785429">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re putting data into a third-party system, you <i>might</i> want `ToUpperInvariant`, not `ToUpper`. (Just checking that you know the difference, because most people don&#x27;t!)</div><br/></div></div><div id="41785474" class="c"><input type="checkbox" id="c-41785474" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41784676">parent</a><span>|</span><a href="#41785429">prev</a><span>|</span><a href="#41785566">next</a><span>|</span><label class="collapse" for="c-41785474">[-]</label><label class="expand" for="c-41785474">[1 more]</label></div><br/><div class="children"><div class="content">Note that the correct way to do that in C# would be to pass an instance of CultureInfo.</div><br/></div></div><div id="41785566" class="c"><input type="checkbox" id="c-41785566" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41784676">parent</a><span>|</span><a href="#41785474">prev</a><span>|</span><a href="#41780508">next</a><span>|</span><label class="collapse" for="c-41785566">[-]</label><label class="expand" for="c-41785566">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that such third-party requirements are usually <i>wrong</i>.<p>Two decades ago some developer probably went &quot;Yeah, obviously all names start with capital letters!&quot;, not realizing that there are in fact plenty of names which start with a lowercase letter. So they added an input validation test which checks for capitals, which meant everyone feeding that system had to format their data. A whole ecosystem grew around the format of the output of that system, and now you&#x27;re suddenly rewriting the system and you run into weird and plain wrong capitalization requirements for no technical reason whatsoever.<p>Alternatively, the same but start with punch cards which predate ASCII and don&#x27;t distinguish between uppercase and lowercase letters.<p>&gt; In C# I can simply do this: &quot;hello world&quot;.ToUpper()<p>... which does not work.<p>Take a look at the German word &quot;straße&quot; (street), for example. Until <i>very</i> recently the &quot;ß&quot; character did not have an uppercase variant, so a ToUpper would convert it to &quot;STRASSE&quot;. This is a lossy operation, as the reverse isn&#x27;t true: the lowercase variant of &quot;KONGRESSSTRASSE&quot; (congress street) is <i>not</i> &quot;kongreßstraße&quot; - it&#x27;s supposed to be &quot;Kongressstraße&quot;.<p>It can get even worse: the phrase &quot;in Maßen&quot; (in moderate amounts) naively has the uppercase variant &quot;IN MASSEN&quot; - but that means &quot;in huge amounts&quot;! In that case it is probably better to stick to &quot;IN MASZEN&quot;.<p>And then there&#x27;s Turkish, where the uppercase variant of the letter &quot;i&quot; is of course &quot;İ&quot; rather than &quot;I&quot; - note the dot.<p>So no, you cannot &quot;simply&quot; use ToUpper() &#x2F; ToLower(). They might work well enough of basic ASCII for languages like English, but they have a habit of making a mess out of everything else. You&#x27;re <i>supposed</i> to use CultureInfo.TextInfo.ToUpperCase() and explicitly specify what locale the text is in so that it can use the right converter. Which is of course essentially impossible in general-purpose text fields.<p>In practice that means your options are a) giving up on the concept of uppercase&#x2F;lowercase conversion and just passing it as-is, or b) accepting that you are inevitably going to be silently corrupting your data.</div><br/></div></div></div></div><div id="41780508" class="c"><input type="checkbox" id="c-41780508" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#41780014">parent</a><span>|</span><a href="#41784676">prev</a><span>|</span><a href="#41781970">next</a><span>|</span><label class="collapse" for="c-41780508">[-]</label><label class="expand" for="c-41780508">[2 more]</label></div><br/><div class="children"><div class="content">&gt;If text is coming from user - then change design until its not needed to &#x27;convert&#x27;<p>In games, you can possibly get away with this. Most other people need to worry about things like string collation (locale-aware sorting) for user-supplied text.</div><br/><div id="41784004" class="c"><input type="checkbox" id="c-41784004" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41780508">parent</a><span>|</span><a href="#41781970">next</a><span>|</span><label class="collapse" for="c-41784004">[-]</label><label class="expand" for="c-41784004">[1 more]</label></div><br/><div class="children"><div class="content">TBF, if you are caring about string collation, you&#x27;re already at the entrance of the rabbit hole and probably should go down to the deep end anyway.<p>I&#x27;d assume SleepyMyroslav doesn&#x27;t apply to devs willing to spend weeks at time to handle all the complexity in full.</div><br/></div></div></div></div><div id="41781970" class="c"><input type="checkbox" id="c-41781970" checked=""/><div class="controls bullet"><span class="by">beeboobaa3</span><span>|</span><a href="#41780014">parent</a><span>|</span><a href="#41780508">prev</a><span>|</span><a href="#41781961">next</a><span>|</span><label class="collapse" for="c-41781970">[-]</label><label class="expand" for="c-41781970">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There are major issues just to show user back what he entered! Because the font for editing and displayed text could be different. Not even mentioning RTL and other issues.<p>Your web browser is doing it right now as you are reading this comment.</div><br/><div id="41782605" class="c"><input type="checkbox" id="c-41782605" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41781970">parent</a><span>|</span><a href="#41781961">next</a><span>|</span><label class="collapse" for="c-41782605">[-]</label><label class="expand" for="c-41782605">[2 more]</label></div><br/><div class="children"><div class="content">And web development is not game development? And chances are that games don&#x27;t ship chromium with them?</div><br/><div id="41783463" class="c"><input type="checkbox" id="c-41783463" checked=""/><div class="controls bullet"><span class="by">moron4hire</span><span>|</span><a href="#41780014">root</a><span>|</span><a href="#41782605">parent</a><span>|</span><a href="#41781961">next</a><span>|</span><label class="collapse" for="c-41783463">[-]</label><label class="expand" for="c-41783463">[1 more]</label></div><br/><div class="children"><div class="content">Actually...<p><pre><code>  https:&#x2F;&#x2F;github.com&#x2F;baikety&#x2F;uWebKit
  https:&#x2F;&#x2F;zenfulcrum.com&#x2F;browser&#x2F;docs&#x2F;Readme.html
  https:&#x2F;&#x2F;github.com&#x2F;roydejong&#x2F;chromium-unity-server
</code></pre>
There are a lot more, I just got bored at 3.<p>And it&#x27;s not just Unity. <i>Several</i> exist for Unreal as well.<p>Why? Specifically because 2D layout and text rendering suck so much in game engines. What&#x27;s ~50MB matter when you&#x27;re shipping several GB of game assets?</div><br/></div></div></div></div></div></div></div></div><div id="41775180" class="c"><input type="checkbox" id="c-41775180" checked=""/><div class="controls bullet"><span class="by">blenderob</span><span>|</span><a href="#41780014">prev</a><span>|</span><a href="#41785458">next</a><span>|</span><label class="collapse" for="c-41775180">[-]</label><label class="expand" for="c-41775180">[57 more]</label></div><br/><div class="children"><div class="content">It is issues like this due to which I gave up on C++. There are so many ways to do something and every way is freaking wrong!<p>An acceptable solution is given at the end of the article:<p>&gt; If you use the International Components for Unicode (ICU) library, you can use u_strToUpper and u_strToLower.<p>Makes you wonder why this isn&#x27;t part of the C++ standard library itself. Every revision of the C++ standard brings with itself more syntax and more complexity in the language. But as a user of C++ I don&#x27;t need more syntax and more complexity in the language. But I do need more standard library functions that solves these ordinary real-world programming problems.</div><br/><div id="41775308" class="c"><input type="checkbox" id="c-41775308" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#41775180">parent</a><span>|</span><a href="#41775300">next</a><span>|</span><label class="collapse" for="c-41775308">[-]</label><label class="expand" for="c-41775308">[39 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s a C++ problem. You just can&#x27;t transform anything developed in &quot;ancient&quot; times to unicode aware in a single swoop.<p>On the other hand, libicu is 37MB by itself, so it&#x27;s not something someone can write in a weekend and ship.<p>Any tool which is old enough will have a thousand ways to do something. This is the inevitability of software and programming languages. In the domain of C++, which has a size mammoth now, everyone expects this huge pony to learn new tricks, but everybody has a different idea of the &quot;new tricks&quot;, so more features are added on top of its already impressive and very long list of features and capabilities.<p>You want libICU built-in? There must be other folks who want that too. So you may need to find them and work with them to make your dream a reality.<p>So, C++ is doing fine. It&#x27;s not that they omitted Unicode during the design phase. Unicode has arrived later, and it has to be integrated by other means. This is what libraries for.</div><br/><div id="41780414" class="c"><input type="checkbox" id="c-41780414" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775308">parent</a><span>|</span><a href="#41775367">next</a><span>|</span><label class="collapse" for="c-41780414">[-]</label><label class="expand" for="c-41780414">[1 more]</label></div><br/><div class="children"><div class="content">&gt;You just can&#x27;t transform anything developed in &quot;ancient&quot; times to unicode aware in a single swoop.<p>Even for Python it took well over a decade, and people <i>still</i> complain about the fact that they don&#x27;t get to treat byte-sequences transparently as text any more - as if they <i>want</i> to wrestle with the `basestring` supertype, getting `UnicodeDecodeError` from an encoding operation or vice-versa, trying to guess the encoding of someone else&#x27;s data instead of expecting it to be decoded on the other side....<p>But in C++ (and in C), you have the additional problem that the 8-bit integer type was <i>named for</i> the concept of a character of text, even though it clearly cannot actually represent any such thing. (Not to mention the whole bit about `char` being a separate type from both `signed char` and `unsigned char`, without defined signedness.)</div><br/></div></div><div id="41775367" class="c"><input type="checkbox" id="c-41775367" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775308">parent</a><span>|</span><a href="#41780414">prev</a><span>|</span><a href="#41780451">next</a><span>|</span><label class="collapse" for="c-41775367">[-]</label><label class="expand" for="c-41775367">[19 more]</label></div><br/><div class="children"><div class="content">Being developed in, <i>and having to stay compatible with</i>, ancient times is a real problem of C++.<p>The now-invalid assumptions couldn&#x27;t have been avoided 50 years ago. Fixing them now in C++ is difficult or impossible, but still, the end result is a ton of brokenness baked into C++.<p>Languages developed in the 21st century typically have some at least half-decent Unicode support built-in. Unicode is big and complex, but there&#x27;s a lot that a language can do to at least not silently destroy the encoding.</div><br/><div id="41775666" class="c"><input type="checkbox" id="c-41775666" checked=""/><div class="controls bullet"><span class="by">cm2187</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775367">parent</a><span>|</span><a href="#41780451">next</a><span>|</span><label class="collapse" for="c-41775666">[-]</label><label class="expand" for="c-41775666">[18 more]</label></div><br/><div class="children"><div class="content">That explains why there are two functions, one for ascii and one for unicode. That doesn&#x27;t explain why the unicode functions are hard to use (per the article).</div><br/><div id="41775925" class="c"><input type="checkbox" id="c-41775925" checked=""/><div class="controls bullet"><span class="by">BoringTimesGang</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775666">parent</a><span>|</span><a href="#41780451">next</a><span>|</span><label class="collapse" for="c-41775925">[-]</label><label class="expand" for="c-41775925">[17 more]</label></div><br/><div class="children"><div class="content">Because human language is hard to boil down to a simple computing model and the problem is underdefined, based on naive assumptions.<p>Or perhaps I should say naïve.</div><br/><div id="41780129" class="c"><input type="checkbox" id="c-41780129" checked=""/><div class="controls bullet"><span class="by">cm2187</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775925">parent</a><span>|</span><a href="#41782489">next</a><span>|</span><label class="collapse" for="c-41780129">[-]</label><label class="expand" for="c-41780129">[14 more]</label></div><br/><div class="children"><div class="content">Well pretty much every other more recent language solved that problem.</div><br/><div id="41780263" class="c"><input type="checkbox" id="c-41780263" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780129">parent</a><span>|</span><a href="#41782489">next</a><span>|</span><label class="collapse" for="c-41780263">[-]</label><label class="expand" for="c-41780263">[13 more]</label></div><br/><div class="children"><div class="content">Almost no programming language, perhaps other than Swift, solved that problem. Just use the article&#x27;s examples as test cases. It&#x27;s just as wrong as the C++ version in the article, except it&#x27;s wrong with nicer syntax.</div><br/><div id="41780453" class="c"><input type="checkbox" id="c-41780453" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780263">parent</a><span>|</span><a href="#41782226">next</a><span>|</span><label class="collapse" for="c-41780453">[-]</label><label class="expand" for="c-41780453">[11 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s strings have uppercase, lowercase and case-folding methods that don&#x27;t choke on this. They don&#x27;t use UTF-16 internally (they <i>can</i> use UCS-2 for strings whose code points will fit in that range; while a string might store code points from the surrogate-pair range, they&#x27;re never interpreted as surrogate pairs, but instead as an error encoding so that e.g. invalid UTF-8 can be round-tripped) so they&#x27;re never worried about surrogate pairs, and it knows a few things about localized text casing:<p><pre><code>    &gt;&gt;&gt; &#x27;ß&#x27;.upper()
    &#x27;SS&#x27;
    &gt;&gt;&gt; &#x27;ß&#x27;.lower()
    &#x27;ß&#x27;
    &gt;&gt;&gt; &#x27;ß&#x27;.casefold()
    &#x27;ss&#x27;
</code></pre>
There are a lot of really complicated tasks for Unicode strings. String casing isn&#x27;t really one of them.<p>(No, Python can&#x27;t turn &#x27;SS&#x27; back into &#x27;ß&#x27;. But doing that requires metadata about language that a string simply doesn&#x27;t represent.)</div><br/><div id="41785596" class="c"><input type="checkbox" id="c-41785596" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780453">parent</a><span>|</span><a href="#41780647">next</a><span>|</span><label class="collapse" for="c-41785596">[-]</label><label class="expand" for="c-41785596">[1 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s wrong. The uppercase for &quot;in Maßen&quot; (&quot;in moderate amounts&quot;) is <i>not</i> &quot;IN MASSEN&quot; (&quot;in Massen&quot;, meaning &quot;in massive amounts&quot;).</div><br/></div></div><div id="41780647" class="c"><input type="checkbox" id="c-41780647" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780453">parent</a><span>|</span><a href="#41785596">prev</a><span>|</span><a href="#41780786">next</a><span>|</span><label class="collapse" for="c-41780647">[-]</label><label class="expand" for="c-41780647">[3 more]</label></div><br/><div class="children"><div class="content">Still breaks on, for example, Turkish i vs İ. It&#x27;s impossible to do correctly without language information.<p>&gt; (No, Python can&#x27;t turn &#x27;SS&#x27; back into &#x27;ß&#x27;. But doing that requires metadata about language that a string simply doesn&#x27;t represent.)<p>Yes that&#x27;s my point. Because in typical languages strings don&#x27;t store language metadata, this is impossible to do correctly in general.</div><br/><div id="41780685" class="c"><input type="checkbox" id="c-41780685" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780647">parent</a><span>|</span><a href="#41780786">next</a><span>|</span><label class="collapse" for="c-41780685">[-]</label><label class="expand" for="c-41780685">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not seeing anything in the Swift documentation about strings carrying language metadata, either, though?</div><br/><div id="41780805" class="c"><input type="checkbox" id="c-41780805" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780685">parent</a><span>|</span><a href="#41780786">next</a><span>|</span><label class="collapse" for="c-41780805">[-]</label><label class="expand" for="c-41780805">[1 more]</label></div><br/><div class="children"><div class="content">This lowercase function takes a locale argument <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;foundation&#x2F;nsstring&#x2F;1417298-lowercased" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;foundation&#x2F;nsstrin...</a><p>It looks like an old NSString method that&#x27;s available in both Obj-C and Swift.<p>The casefold function is even older than that. <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;foundation&#x2F;nsstring&#x2F;1413779-folding" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;foundation&#x2F;nsstrin...</a> Its documentation specifically includes a discussion of the Turkish İ&#x2F;I issue.</div><br/></div></div></div></div></div></div><div id="41780786" class="c"><input type="checkbox" id="c-41780786" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780453">parent</a><span>|</span><a href="#41780647">prev</a><span>|</span><a href="#41782226">next</a><span>|</span><label class="collapse" for="c-41780786">[-]</label><label class="expand" for="c-41780786">[6 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s wrong. The upper case for ß is ẞ.</div><br/><div id="41781531" class="c"><input type="checkbox" id="c-41781531" checked=""/><div class="controls bullet"><span class="by">cm2187</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780786">parent</a><span>|</span><a href="#41785090">next</a><span>|</span><label class="collapse" for="c-41781531">[-]</label><label class="expand" for="c-41781531">[1 more]</label></div><br/><div class="children"><div class="content">C#&#x27;s &quot;ToUpper&quot; takes an optional CultureInfo argument if you want to play around with how to treat different languages. Again, solved problem decades ago.</div><br/></div></div><div id="41785090" class="c"><input type="checkbox" id="c-41785090" checked=""/><div class="controls bullet"><span class="by">Towaway69</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780786">parent</a><span>|</span><a href="#41781531">prev</a><span>|</span><a href="#41781403">next</a><span>|</span><label class="collapse" for="c-41785090">[-]</label><label class="expand" for="c-41785090">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t uppercase for ß just ß - i.e. it&#x27;s its own uppercase character?</div><br/></div></div><div id="41781403" class="c"><input type="checkbox" id="c-41781403" checked=""/><div class="controls bullet"><span class="by">IncreasePosts</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780786">parent</a><span>|</span><a href="#41785090">prev</a><span>|</span><a href="#41782226">next</a><span>|</span><label class="collapse" for="c-41781403">[-]</label><label class="expand" for="c-41781403">[3 more]</label></div><br/><div class="children"><div class="content">That was only adopted in Germany like 7 years ago!</div><br/><div id="41781860" class="c"><input type="checkbox" id="c-41781860" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41781403">parent</a><span>|</span><a href="#41782226">next</a><span>|</span><label class="collapse" for="c-41781860">[-]</label><label class="expand" for="c-41781860">[2 more]</label></div><br/><div class="children"><div class="content">Well languages and conventions change. The € sign was added not that long ago and it was somewhat painful. The Chinese language uses a single character to refer to chemical elements so when IUPAC names new elements they will invent new characters. Etc.</div><br/><div id="41783486" class="c"><input type="checkbox" id="c-41783486" checked=""/><div class="controls bullet"><span class="by">extraduder_ire</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41781860">parent</a><span>|</span><a href="#41782226">next</a><span>|</span><label class="collapse" for="c-41783486">[-]</label><label class="expand" for="c-41783486">[1 more]</label></div><br/><div class="children"><div class="content">Does unicode have space set aside for those new symbols to slot into? I know it&#x27;s very rare, but it could get messy.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41782226" class="c"><input type="checkbox" id="c-41782226" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780263">parent</a><span>|</span><a href="#41780453">prev</a><span>|</span><a href="#41782489">next</a><span>|</span><label class="collapse" for="c-41782226">[-]</label><label class="expand" for="c-41782226">[1 more]</label></div><br/><div class="children"><div class="content">Rust will cheerfully:<p><pre><code>    assert_eq!(&quot;ὀδυσσεύς&quot;, &quot;ὈΔΥΣΣΕΎΣ&quot;.to_lowercase());
</code></pre>
[Notice that this is in fact entirely impossible with the naive strategy since Greek cares about position of symbols]<p>Some of the latter examples aren&#x27;t cases where a programming language or library should just &quot;do the right thing&quot; but cases of ambiguity where you need locale information to decide what&#x27;s appropriate, which isn&#x27;t &quot;just as wrong as the C++ version&quot; it&#x27;s a whole other problem. It isn&#x27;t <i>wrong</i> to capitalise A-acute as a capital A-acute, it&#x27;s just <i>not always appropriate</i> depending on the locale.</div><br/></div></div></div></div></div></div><div id="41782489" class="c"><input type="checkbox" id="c-41782489" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775925">parent</a><span>|</span><a href="#41780129">prev</a><span>|</span><a href="#41780451">next</a><span>|</span><label class="collapse" for="c-41782489">[-]</label><label class="expand" for="c-41782489">[2 more]</label></div><br/><div class="children"><div class="content">So what?<p>That doesn’t prevent adding a new function that converts an entire string to upper or lowercase in a Unicode aware way.<p>What would be wrong with adding new correct functions to the standard library to make this easy? There are already namespaces in C++ so you don’t even have to worry about collisions.<p>That’s the problem I see. It’s fine if you have a history of stuff that’s not that great in hindsight. But what’s wrong with having a better standard library going forward?<p>It’s not like this is an esoteric thing.</div><br/><div id="41783259" class="c"><input type="checkbox" id="c-41783259" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41782489">parent</a><span>|</span><a href="#41780451">next</a><span>|</span><label class="collapse" for="c-41783259">[-]</label><label class="expand" for="c-41783259">[1 more]</label></div><br/><div class="children"><div class="content">The reason that wasn&#x27;t done is because Unicode is not really in older C++ standards. I think it may have been added to C++23 but I am not familiar with that. There are many partial solutions in older C++ but if you want to do it well then you need to get a library for it from somewhere, or else (possibly) wait for a new standard.<p>Unicode and character encodings are pretty esoteric. So are fonts. The stuff is technically everywhere and fundamental, but there are many encodings, technical details, etc. And most programmers only care about one language, or else only use UTF-8 with the most basic chars (the ones that agree with ASCII). That isn&#x27;t terrible. You only need what you actually need. Most programs don&#x27;t strictly have to be built for multiple random languages, and there is kind of a standard methodology to learn before you can do that.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41780451" class="c"><input type="checkbox" id="c-41780451" checked=""/><div class="controls bullet"><span class="by">ectospheno</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775308">parent</a><span>|</span><a href="#41775367">prev</a><span>|</span><a href="#41775424">next</a><span>|</span><label class="collapse" for="c-41780451">[-]</label><label class="expand" for="c-41780451">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Any tool which is old enough will have a thousand ways to do something.<p>Only because of the strange desire of programmers to never stop. Not every program is a never ending story. Most are short stories their authors bludgeon into a novel.<p>Programming languages bloat into stupidity for the same reason. Nothing is ever removed. Programmers need editors.</div><br/><div id="41780611" class="c"><input type="checkbox" id="c-41780611" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780451">parent</a><span>|</span><a href="#41775424">next</a><span>|</span><label class="collapse" for="c-41780611">[-]</label><label class="expand" for="c-41780611">[3 more]</label></div><br/><div class="children"><div class="content">So how do you design a language that accommodates both the people who need a codebase to be stable for decades and the people who want the bleeding edge all the time, backwards compatibility be damned?</div><br/><div id="41780639" class="c"><input type="checkbox" id="c-41780639" checked=""/><div class="controls bullet"><span class="by">the_gorilla</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780611">parent</a><span>|</span><a href="#41775424">next</a><span>|</span><label class="collapse" for="c-41780639">[-]</label><label class="expand" for="c-41780639">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t. Any language that tries to do both turns into an unusable abomination like C++. Good languages are stable and the bleeding edge is just the &quot;new thing&quot; and not necessarily better than the old thing.</div><br/><div id="41780673" class="c"><input type="checkbox" id="c-41780673" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41780639">parent</a><span>|</span><a href="#41775424">next</a><span>|</span><label class="collapse" for="c-41780673">[-]</label><label class="expand" for="c-41780673">[1 more]</label></div><br/><div class="children"><div class="content">C++ <i>doesn&#x27;t</i> try to do that. It aims to remain as backwards compatible as possible, which is what the GP is complaining about.</div><br/></div></div></div></div></div></div></div></div><div id="41775424" class="c"><input type="checkbox" id="c-41775424" checked=""/><div class="controls bullet"><span class="by">relaxing</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775308">parent</a><span>|</span><a href="#41780451">prev</a><span>|</span><a href="#41780355">next</a><span>|</span><label class="collapse" for="c-41775424">[-]</label><label class="expand" for="c-41775424">[13 more]</label></div><br/><div class="children"><div class="content">It’s been 30 years. Unicode predates C++98. Java saw the writing on the wall. There’s no excuse.</div><br/><div id="41775464" class="c"><input type="checkbox" id="c-41775464" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775424">parent</a><span>|</span><a href="#41781165">next</a><span>|</span><label class="collapse" for="c-41775464">[-]</label><label class="expand" for="c-41775464">[10 more]</label></div><br/><div class="children"><div class="content">&gt; There’s no excuse.<p>I politely disagree. None of the programming languages which started integrating Unicode was targeting from bare metal to GUI, incl. embedded and OS development at the same time.<p>C++ has a great target area when compared to other programming languages. There are widely used libraries which compile correctly on PDP-11s, even if they are updated constantly.<p>You can&#x27;t just say &quot;I&#x27;ll be just making everything Unicode aware, backwards compatibility be damned, eh&quot;.</div><br/><div id="41775488" class="c"><input type="checkbox" id="c-41775488" checked=""/><div class="controls bullet"><span class="by">blenderob</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775464">parent</a><span>|</span><a href="#41781165">next</a><span>|</span><label class="collapse" for="c-41775488">[-]</label><label class="expand" for="c-41775488">[9 more]</label></div><br/><div class="children"><div class="content">But we don&#x27;t have to make everything Unicode aware. Backward compatibility is indeed very important in C++. Like you rightly said, it still has to work for PDP-11 without breaking anything.<p>But the C++ overlords could always add a new type that is Unicode-aware. Converting one Unicode string to another is a purely in-memory, in-CPU operation. It does not need any I&#x2F;O and it does not need any interaction with peripherals. So one can dream that such a type along with its conversion routines could be added to an updated standard library without breaking existing code that compiles correctly on PDP-11s.</div><br/><div id="41775577" class="c"><input type="checkbox" id="c-41775577" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775488">parent</a><span>|</span><a href="#41781165">next</a><span>|</span><label class="collapse" for="c-41775577">[-]</label><label class="expand" for="c-41775577">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Converting one Unicode string to another is a purely in-memory, in-CPU operation.<p>...but it&#x27;s a complex operation. This is what libICU is mostly for. You can&#x27;t just look-up a single table and convert a string to another like you work on ASCII table or any other simple encoding.<p>Germans have their ß to S (or capital ß depending on the year), Turkish has ı&#x2F;I and i&#x2F;İ pairs, and tons of other languages have other rules.<p>Esp, this I&#x2F;ı and İ&#x2F;i pairs break tons of applications in very unexpected ways. I don&#x27;t remember how many bugs I reported, and how many workarounds I have implemented in my systems.<p>Adding a type is nice, but the surrounding machinery is so big, it brings tons of work with itself. Unicode is such a complicated system, that I read that even you need two UTF-16 characters (4 bytes in total) to encode a single character. This is insane (as in complexity, I guess they have their reasons).</div><br/><div id="41777433" class="c"><input type="checkbox" id="c-41777433" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775577">parent</a><span>|</span><a href="#41775788">next</a><span>|</span><label class="collapse" for="c-41777433">[-]</label><label class="expand" for="c-41777433">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Unicode is such a complicated system, that I read that even you need two UTF-16 characters (4 bytes in total) to encode a single character. This is insane (as in complexity, I guess they have their reasons).<p>Because there are more than 65,535 characters. That&#x27;s just writing systems, not Unicode&#x27;s fault. Most of the unnecessary complexity of Unicode is legacy compatibility: UTF-16 &amp; UTF-32 are bad ideas that increase complexity, but they predate UTF-8 which actually works decently well so they get kept around for backwards compatibility. Likewise with the need for multiple normalization forms.</div><br/><div id="41783144" class="c"><input type="checkbox" id="c-41783144" checked=""/><div class="controls bullet"><span class="by">numpad0</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41777433">parent</a><span>|</span><a href="#41777526">next</a><span>|</span><label class="collapse" for="c-41783144">[-]</label><label class="expand" for="c-41783144">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s because Unicode don&#x27;t allow for language switching.<p>It takes up to eight bytes per character in Unicode if you want to support both Chinese and Japanese in a single font using IVS(and I don&#x27;t think there&#x27;s any font that actually supports this).<p>AFAICS(As far as I can search), Simplified(PRC) and Traditional(Taiwan) Chinese encoding are respectively called GB2312 and Big5, and they&#x27;re both two byte encodings with good practical coverage. Same applies for Japanese Shift_JIS. If e.g. :flag_cc: were allowed to be used as start-of-language marker, one could theoretically cut that back down to two bytes per character without losing much and actually improving language supports.</div><br/></div></div><div id="41777526" class="c"><input type="checkbox" id="c-41777526" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41777433">parent</a><span>|</span><a href="#41783144">prev</a><span>|</span><a href="#41775788">next</a><span>|</span><label class="collapse" for="c-41777526">[-]</label><label class="expand" for="c-41777526">[2 more]</label></div><br/><div class="children"><div class="content">I mean, I already know some Unicode internals and linguistics (since I developed a language-specific compression algorithm back in the day), but I have never seen a single character requiring four bytes (and I know Emoji chaining for skin color, etc.).<p>So, seeing this just moved the complexity of Unicode one notch up in my head, and I respect the guys who designed and made it work. It was not whining or complaining of any sort. :)</div><br/><div id="41780662" class="c"><input type="checkbox" id="c-41780662" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41777526">parent</a><span>|</span><a href="#41775788">next</a><span>|</span><label class="collapse" for="c-41780662">[-]</label><label class="expand" for="c-41780662">[1 more]</label></div><br/><div class="children"><div class="content">Cuneiform codepoints are 17 bits long. If you&#x27;re using UTF-16 you&#x27;ll need two code units to represent a character.</div><br/></div></div></div></div></div></div><div id="41775645" class="c"><input type="checkbox" id="c-41775645" checked=""/><div class="controls bullet"><span class="by">blenderob</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775577">parent</a><span>|</span><a href="#41775788">prev</a><span>|</span><a href="#41781165">next</a><span>|</span><label class="collapse" for="c-41775645">[-]</label><label class="expand" for="c-41775645">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the reply! Really appreciate the time you have taken to write down a thoughtful reply.</div><br/><div id="41775790" class="c"><input type="checkbox" id="c-41775790" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775645">parent</a><span>|</span><a href="#41781165">next</a><span>|</span><label class="collapse" for="c-41775790">[-]</label><label class="expand" for="c-41775790">[1 more]</label></div><br/><div class="children"><div class="content">No problems! If you want a slightly longer write-up, here&#x27;s a classic I constantly share with people:<p><a href="https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;whats-wrong-with-turkey&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;whats-wrong-with-turkey&#x2F;</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41781165" class="c"><input type="checkbox" id="c-41781165" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775424">parent</a><span>|</span><a href="#41775464">prev</a><span>|</span><a href="#41783278">next</a><span>|</span><label class="collapse" for="c-41781165">[-]</label><label class="expand" for="c-41781165">[1 more]</label></div><br/><div class="children"><div class="content">Java ended up picking UCS-2 and getting screwed.</div><br/></div></div><div id="41783278" class="c"><input type="checkbox" id="c-41783278" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775424">parent</a><span>|</span><a href="#41781165">prev</a><span>|</span><a href="#41780355">next</a><span>|</span><label class="collapse" for="c-41783278">[-]</label><label class="expand" for="c-41783278">[1 more]</label></div><br/><div class="children"><div class="content">Java was built from scratch as a heavy language with a whole portability layer that C++ does not have. Also, libraries have been around to do this stuff in C++ but maybe some people saw it better to not <i>require</i> C++ to support Unicode, presumably.</div><br/></div></div></div></div><div id="41780355" class="c"><input type="checkbox" id="c-41780355" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775308">parent</a><span>|</span><a href="#41775424">prev</a><span>|</span><a href="#41775300">next</a><span>|</span><label class="collapse" for="c-41780355">[-]</label><label class="expand" for="c-41780355">[1 more]</label></div><br/><div class="children"><div class="content">&gt; libicu is 37MB by itself, so it&#x27;s not something someone can write in a weekend and ship.<p>Isn&#x27;t that mostly just from tables derived from the Unicode standard?</div><br/></div></div></div></div><div id="41775300" class="c"><input type="checkbox" id="c-41775300" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41775180">parent</a><span>|</span><a href="#41775308">prev</a><span>|</span><a href="#41775576">next</a><span>|</span><label class="collapse" for="c-41775300">[-]</label><label class="expand" for="c-41775300">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There are so many ways to do something and every way is freaking wrong!<p>That&#x27;s life! The perfect way does not exist. The best you can do is be aware of the tradeoffs, and languages like C++ absolutely throw them in your face at every single opportunity. It&#x27;s fatiguing, and writing in javascript or python allows us to uphold the facade that everything is okay and that we don&#x27;t have to worry about a thing.</div><br/><div id="41775426" class="c"><input type="checkbox" id="c-41775426" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775300">parent</a><span>|</span><a href="#41775405">next</a><span>|</span><label class="collapse" for="c-41775426">[-]</label><label class="expand" for="c-41775426">[1 more]</label></div><br/><div class="children"><div class="content">JS and Python are still old enough to have been created when Unicode was in its infancy, so they have their own share of problems from using UCS-2 (such as indexing strings by what is now a UTF-16 code unit, rather than by a codepoint or a grapheme cluster).<p>Swift has been developed in the modern times, and it&#x27;s able to tackle Unicode properly, e.g. makes distinction between codepoints and grapheme clusters, and steers users away from random-access indexing and having a single (incorrect) notion of a string length.</div><br/></div></div></div></div><div id="41775576" class="c"><input type="checkbox" id="c-41775576" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41775180">parent</a><span>|</span><a href="#41775300">prev</a><span>|</span><a href="#41777516">next</a><span>|</span><label class="collapse" for="c-41775576">[-]</label><label class="expand" for="c-41775576">[1 more]</label></div><br/><div class="children"><div class="content">Well, the only time you can do str lower where unicode locale awareness will be a problem is when you do it on the user input, like names.<p>How about you just dont? If it&#x27;s a constant in your code, you probably use ASCII anyway or can do a static mapping. If it&#x27;s user user input -- just don&#x27;t str lower &#x2F; str upper it.</div><br/></div></div><div id="41777516" class="c"><input type="checkbox" id="c-41777516" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41775180">parent</a><span>|</span><a href="#41775576">prev</a><span>|</span><a href="#41784748">next</a><span>|</span><label class="collapse" for="c-41777516">[-]</label><label class="expand" for="c-41777516">[2 more]</label></div><br/><div class="children"><div class="content">Because it is a fight to put anything on a ISO managed language, and only the strongest persevere long enough to make it happen.<p>Regardless of what ISO language we are talking about.</div><br/><div id="41781200" class="c"><input type="checkbox" id="c-41781200" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41777516">parent</a><span>|</span><a href="#41784748">next</a><span>|</span><label class="collapse" for="c-41781200">[-]</label><label class="expand" for="c-41781200">[1 more]</label></div><br/><div class="children"><div class="content">Yes, significantly smaller libraries had an hard time getting onto the standard. Getting the equivalent of ICU would be almost impossible. And good luck keeping it up to date.</div><br/></div></div></div></div><div id="41784748" class="c"><input type="checkbox" id="c-41784748" checked=""/><div class="controls bullet"><span class="by">dennis_jeeves2</span><span>|</span><a href="#41775180">parent</a><span>|</span><a href="#41777516">prev</a><span>|</span><a href="#41785496">next</a><span>|</span><label class="collapse" for="c-41784748">[-]</label><label class="expand" for="c-41784748">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There are so many ways to do something and every way is freaking wrong!<p>Stroustrup, laugheth!</div><br/></div></div><div id="41785496" class="c"><input type="checkbox" id="c-41785496" checked=""/><div class="controls bullet"><span class="by">hoseja</span><span>|</span><a href="#41775180">parent</a><span>|</span><a href="#41784748">prev</a><span>|</span><a href="#41775297">next</a><span>|</span><label class="collapse" for="c-41785496">[-]</label><label class="expand" for="c-41785496">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Makes you wonder why this isn&#x27;t part of the C++ standard library itself.<p>Because then every change in Unicode would need to be standardized in C++ as well. Yup. Can&#x27;t have Unicode due to committee friction.</div><br/></div></div><div id="41775297" class="c"><input type="checkbox" id="c-41775297" checked=""/><div class="controls bullet"><span class="by">BoringTimesGang</span><span>|</span><a href="#41775180">parent</a><span>|</span><a href="#41785496">prev</a><span>|</span><a href="#41782824">next</a><span>|</span><label class="collapse" for="c-41775297">[-]</label><label class="expand" for="c-41775297">[3 more]</label></div><br/><div class="children"><div class="content">&gt;It is issues like this due to which I gave up on C++. There are so many ways to do something and every way is freaking wrong!<p>These are mostly unicode or linguistics problems.</div><br/><div id="41775359" class="c"><input type="checkbox" id="c-41775359" checked=""/><div class="controls bullet"><span class="by">tralarpa</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775297">parent</a><span>|</span><a href="#41782824">next</a><span>|</span><label class="collapse" for="c-41775359">[-]</label><label class="expand" for="c-41775359">[2 more]</label></div><br/><div class="children"><div class="content">The fact that the standard library works against you doesn&#x27;t help (to_lower takes an int, but only kind of works (sometimes) correctly on unsigned char, and wchar_t is implicitly promoted to int).</div><br/><div id="41775401" class="c"><input type="checkbox" id="c-41775401" checked=""/><div class="controls bullet"><span class="by">BoringTimesGang</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41775359">parent</a><span>|</span><a href="#41782824">next</a><span>|</span><label class="collapse" for="c-41775401">[-]</label><label class="expand" for="c-41775401">[1 more]</label></div><br/><div class="children"><div class="content">to_lower is in the std namespace but is actually just part of the C89 standard, meaning it predates both UTF8 and UTF16. Is the alternative that it should be made unusable, and more existing code broken? A modern user has to include one of the c-prefix headers to use it, already hinting to them that &#x27;here be dragons&#x27;.<p>But there are always dragons. It&#x27;s strings. The mere assumption that they can be transformed int-by-int, irrespective of encoding, is wrong. As is the assumption that a sensible transformation to lower case without error handling <i>exists</i>.</div><br/></div></div></div></div></div></div><div id="41782824" class="c"><input type="checkbox" id="c-41782824" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#41775180">parent</a><span>|</span><a href="#41775297">prev</a><span>|</span><a href="#41775406">next</a><span>|</span><label class="collapse" for="c-41782824">[-]</label><label class="expand" for="c-41782824">[5 more]</label></div><br/><div class="children"><div class="content">Me too, how is case conversion perfectly done in modern languages such as Zig [1], Rust, or Swift?<p>[1] Ended up looking at <a href="https:&#x2F;&#x2F;github.com&#x2F;JakubSzark&#x2F;zig-string">https:&#x2F;&#x2F;github.com&#x2F;JakubSzark&#x2F;zig-string</a></div><br/><div id="41783225" class="c"><input type="checkbox" id="c-41783225" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41782824">parent</a><span>|</span><a href="#41775406">next</a><span>|</span><label class="collapse" for="c-41783225">[-]</label><label class="expand" for="c-41783225">[4 more]</label></div><br/><div class="children"><div class="content">In Rust, the APIs are clear if they&#x27;re ASCII only or unicode aware.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;primitive.str.html#method.to_lowercase" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;primitive.str.html#meth...</a><p>&gt; ‘Lowercase’ is defined according to the terms of the Unicode Derived Core Property Lowercase.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;primitive.str.html#method.to_ascii_lowercase" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;primitive.str.html#meth...</a><p>&gt; ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’, but non-ASCII letters are unchanged.<p>Now, &quot;perfectly&quot; is very strong. For example, the Turkish i problem. That is not solved. But 99% of Unicode stuff is handled correctly by default.</div><br/><div id="41783870" class="c"><input type="checkbox" id="c-41783870" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41783225">parent</a><span>|</span><a href="#41775406">next</a><span>|</span><label class="collapse" for="c-41783870">[-]</label><label class="expand" for="c-41783870">[3 more]</label></div><br/><div class="children"><div class="content">&gt; 99% of Unicode stuff<p>Does that include context-dependent conversion rules like o&#x27;reilly -&gt; O&#x27;Reilly?</div><br/><div id="41784679" class="c"><input type="checkbox" id="c-41784679" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41783870">parent</a><span>|</span><a href="#41775406">next</a><span>|</span><label class="collapse" for="c-41784679">[-]</label><label class="expand" for="c-41784679">[2 more]</label></div><br/><div class="children"><div class="content">that is neither up-casing nor-downcasing, but (de)capitalization, which is a significantly more complex task (which ultimately requires up- or down-casing, but a whole lot more before then).</div><br/><div id="41784756" class="c"><input type="checkbox" id="c-41784756" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#41775180">root</a><span>|</span><a href="#41784679">parent</a><span>|</span><a href="#41775406">next</a><span>|</span><label class="collapse" for="c-41784756">[-]</label><label class="expand" for="c-41784756">[1 more]</label></div><br/><div class="children"><div class="content">So it doesn&#x27;t. If Unicode doesn&#x27;t cover non-trivial forms of case-folding, <i>99% of Unicode</i> doesn&#x27;t mean anything.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41785458" class="c"><input type="checkbox" id="c-41785458" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41775180">prev</a><span>|</span><a href="#41785281">next</a><span>|</span><label class="collapse" for="c-41785458">[-]</label><label class="expand" for="c-41785458">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  From the article: &quot;I find it quaint that Unicode character names are ALL IN CAPITAL LETTERS, in case you need to put them in a Baudot telegram or something.&quot;<p>I had to do that. When we had our steampunk telegraph office at steampunk conventions [1], people could text in a message via SMS, it would be printed on a Model 14 or 15 Teletype, put in an envelope, and hand-delivered. People would use emoji in messages, and the device could only print Baudot, or International Telegraphic Alphabet #2, which is upper case only with some symbols.<p>Emoji translation would cause the machine to hammer out<p><pre><code>    (RED-HEART)
</code></pre>
or whatever emoji description was needed.<p>Used the emoji list at [2], an older version.<p>[1] <a href="https:&#x2F;&#x2F;vimeo.com&#x2F;124065314" rel="nofollow">https:&#x2F;&#x2F;vimeo.com&#x2F;124065314</a><p>[2] <a href="http:&#x2F;&#x2F;unicode.org&#x2F;emoji&#x2F;charts-beta&#x2F;full-emoji-list.html" rel="nofollow">http:&#x2F;&#x2F;unicode.org&#x2F;emoji&#x2F;charts-beta&#x2F;full-emoji-list.html</a></div><br/></div></div><div id="41785281" class="c"><input type="checkbox" id="c-41785281" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#41785458">prev</a><span>|</span><a href="#41775245">next</a><span>|</span><label class="collapse" for="c-41785281">[-]</label><label class="expand" for="c-41785281">[1 more]</label></div><br/><div class="children"><div class="content">Handle text in two ways: either it&#x27;s controlled by you and you can do simple, efficient, and naive processing, or it&#x27;s not (it&#x27;s translated resources, or user input) and you can&#x27;t.<p>For the former case, you don&#x27;t need any complex logic. A very typical example would be: i&#x27;m serializing a field or constructing a url so I want the variable name &quot;Someproperty&quot; as a lower case string. The lowercase transform is completely naive. I know exactly what the range of possible characters are and they aren&#x27;t going to be Turkish or emoji, not least because I have asserted they won&#x27;t be. And THIS is what the regular programming functions for upper&#x2F;lower case are for. They are important, and they are most often <i>correct</i>. Because for all the other cases (i18n, user input, ...) you probably don&#x27;t want to do toUpper&#x2F;toLower at all to begin with!<p>Example, if you present a message to the user from resources so your code is translate(&quot;USER_DIALOG_QUESTION_ABOUT_FISH&quot;) which you want to lookup knowing it will be in sentence case, and present as uppercase, what will you do? Here you likely can&#x27;t, and shouldn&#x27;t, do toUpper(translate(resourceKey)). Just use two resources if you want to correctly transform text. The toUpper function isn&#x27;t made for this.<p>Trying to use a complex i18n-ready toUpper&#x2F;toLower only helps part of the way. It <i>still</i> might not understand whether two S are contracted or whether something is a proper Noun and must stay capitalized. So it adds complexity and <i>still</i> isn&#x27;t correct. Just use two resources!</div><br/></div></div><div id="41775245" class="c"><input type="checkbox" id="c-41775245" checked=""/><div class="controls bullet"><span class="by">appointment</span><span>|</span><a href="#41785281">prev</a><span>|</span><a href="#41775153">next</a><span>|</span><label class="collapse" for="c-41775245">[-]</label><label class="expand" for="c-41775245">[11 more]</label></div><br/><div class="children"><div class="content">The key takeaway here is that you can&#x27;t correctly process a string if you don&#x27;t what language it&#x27;s in. That includes variants of the same language with different rules, eg en-US and en-UK or es-MX and es-ES.<p>If you are handling multilingual text the locale is mandatory metadata.</div><br/><div id="41775381" class="c"><input type="checkbox" id="c-41775381" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41775245">parent</a><span>|</span><a href="#41783759">next</a><span>|</span><label class="collapse" for="c-41775381">[-]</label><label class="expand" for="c-41775381">[9 more]</label></div><br/><div class="children"><div class="content">Different parts of a string can be in different languages too[1].<p>The lowercase of &quot;DON&#x27;T FUSS ABOUT FUSSBALL&quot; is &quot;don&#x27;t fuss about fußball&quot;. Unless you&#x27;re in Switzerland.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Code-switching" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Code-switching</a></div><br/><div id="41775416" class="c"><input type="checkbox" id="c-41775416" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#41775245">root</a><span>|</span><a href="#41775381">parent</a><span>|</span><a href="#41778000">next</a><span>|</span><label class="collapse" for="c-41775416">[-]</label><label class="expand" for="c-41775416">[1 more]</label></div><br/><div class="children"><div class="content">Probably &quot;don&#x27;t fuss about Fußball&quot; for the same reasons, right?</div><br/></div></div><div id="41778000" class="c"><input type="checkbox" id="c-41778000" checked=""/><div class="controls bullet"><span class="by">thiht</span><span>|</span><a href="#41775245">root</a><span>|</span><a href="#41775381">parent</a><span>|</span><a href="#41775416">prev</a><span>|</span><a href="#41783759">next</a><span>|</span><label class="collapse" for="c-41778000">[-]</label><label class="expand" for="c-41778000">[7 more]</label></div><br/><div class="children"><div class="content">I thought the German language deprecated the use of ß years ago, no? I learned German for a year and that&#x27;s what the teacher told us, but maybe it&#x27;s not the whole story</div><br/><div id="41779174" class="c"><input type="checkbox" id="c-41779174" checked=""/><div class="controls bullet"><span class="by">47282847</span><span>|</span><a href="#41775245">root</a><span>|</span><a href="#41778000">parent</a><span>|</span><a href="#41782707">next</a><span>|</span><label class="collapse" for="c-41779174">[-]</label><label class="expand" for="c-41779174">[5 more]</label></div><br/><div class="children"><div class="content">Incorrect. ẞ is still a thing.</div><br/><div id="41782043" class="c"><input type="checkbox" id="c-41782043" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#41775245">root</a><span>|</span><a href="#41779174">parent</a><span>|</span><a href="#41780493">next</a><span>|</span><label class="collapse" for="c-41782043">[-]</label><label class="expand" for="c-41782043">[1 more]</label></div><br/><div class="children"><div class="content">Germans run Uber Long Term Support dialects</div><br/></div></div><div id="41780493" class="c"><input type="checkbox" id="c-41780493" checked=""/><div class="controls bullet"><span class="by">CamperBob2</span><span>|</span><a href="#41775245">root</a><span>|</span><a href="#41779174">parent</a><span>|</span><a href="#41782043">prev</a><span>|</span><a href="#41782707">next</a><span>|</span><label class="collapse" for="c-41780493">[-]</label><label class="expand" for="c-41780493">[3 more]</label></div><br/><div class="children"><div class="content">Going by what you and the grandparent wrote, it&#x27;s not just a thing, but two <i>different</i> things: ẞ ß<p>It is probably time for an Esperanto advocate to show up and set us all straight.</div><br/><div id="41782143" class="c"><input type="checkbox" id="c-41782143" checked=""/><div class="controls bullet"><span class="by">selenography</span><span>|</span><a href="#41775245">root</a><span>|</span><a href="#41780493">parent</a><span>|</span><a href="#41781864">next</a><span>|</span><label class="collapse" for="c-41782143">[-]</label><label class="expand" for="c-41782143">[1 more]</label></div><br/><div class="children"><div class="content">&gt; set us all straight.<p>Se fareblus oni, jam farintus oni. (It definitely won&#x27;t happen on an echo-change day like today, either. ;))<p>Contra my comrade&#x27;s comment, Esperanto orthography is firmly European, and so retains European-style casing distinctions; every sound thus still has two letters -- or at least two codepoints.<p>(There aren&#x27;t any eszettesque bigraphs, but that&#x27;s not saying much.)</div><br/></div></div><div id="41781864" class="c"><input type="checkbox" id="c-41781864" checked=""/><div class="controls bullet"><span class="by">D-Coder</span><span>|</span><a href="#41775245">root</a><span>|</span><a href="#41780493">parent</a><span>|</span><a href="#41782143">prev</a><span>|</span><a href="#41782707">next</a><span>|</span><label class="collapse" for="c-41781864">[-]</label><label class="expand" for="c-41781864">[1 more]</label></div><br/><div class="children"><div class="content">Pri kio vi parolas? En Esperanto, unu letero egalas unu sonon.<p>What are you talking about? In Esperanto, one letter equals one sound.</div><br/></div></div></div></div></div></div><div id="41782707" class="c"><input type="checkbox" id="c-41782707" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#41775245">root</a><span>|</span><a href="#41778000">parent</a><span>|</span><a href="#41779174">prev</a><span>|</span><a href="#41783759">next</a><span>|</span><label class="collapse" for="c-41782707">[-]</label><label class="expand" for="c-41782707">[1 more]</label></div><br/><div class="children"><div class="content">The Swiss have dropped ß, but it&#x27;s still a thing in Germany or Austria.</div><br/></div></div></div></div></div></div><div id="41783759" class="c"><input type="checkbox" id="c-41783759" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41775245">parent</a><span>|</span><a href="#41775381">prev</a><span>|</span><a href="#41775153">next</a><span>|</span><label class="collapse" for="c-41783759">[-]</label><label class="expand" for="c-41783759">[1 more]</label></div><br/><div class="children"><div class="content">Not quite.<p>islower is actually supposed to account for the user&#x27;s &quot;locale&quot;, which includes their language.<p>The key takeway is that lowercasing a string needs to be done on the <i>whole</i> string, not individual characters, even if std::string had a way to iterate over codepoints instead of bytes (or code units, in the case of wstring).<p>And there isn&#x27;t a standard way to do that, you either meed to use a platform specific API, like the windows function mentioned, or use a library like ICU.</div><br/></div></div></div></div><div id="41775153" class="c"><input type="checkbox" id="c-41775153" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41775245">prev</a><span>|</span><a href="#41775513">next</a><span>|</span><label class="collapse" for="c-41775153">[-]</label><label class="expand" for="c-41775153">[49 more]</label></div><br/><div class="children"><div class="content">As always, Raymond is right. (And as usually, I could guess it&#x27;s him before even clicking the link.)<p>That said, 99% time when doing upper- or lowercase operation you&#x27;re interested just in the 7-bit ASCII range of characters.<p>For the remaining 1%, there&#x27;s ICU library. Just like Raymond Chen mentioned.</div><br/><div id="41781750" class="c"><input type="checkbox" id="c-41781750" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#41775153">parent</a><span>|</span><a href="#41775511">next</a><span>|</span><label class="collapse" for="c-41781750">[-]</label><label class="expand" for="c-41781750">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>That said, 99% time when doing upper- or lowercase operation you&#x27;re interested just in the 7-bit ASCII range of characters.</i><p>I think it&#x27;s more the exact opposite.<p>The only times I&#x27;m dealing with 7-bit ASCII is for internal identifiers like variable names or API endpoints. Which is a lot of the time, but I can&#x27;t ever think of when I&#x27;ve needed my code to change their case. It might literally be never.<p>On the other hand, needing to switch between upper, lower, and title case happens all the time, always with people&#x27;s names and article titles and product names and whatnot. Which are <i>never</i> in ASCII because this isn&#x27;t 1990.</div><br/><div id="41784147" class="c"><input type="checkbox" id="c-41784147" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41781750">parent</a><span>|</span><a href="#41782618">next</a><span>|</span><label class="collapse" for="c-41784147">[-]</label><label class="expand" for="c-41784147">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Which are never in ASCII because this isn&#x27;t 1990.<p>This is a very silly statement. I&#x27;m willing to believe that you have lots of cases where those things are outside the ASCII range. Perhaps even most of the cases, depending on where you live. But I do not believe for one second that it never happens.</div><br/><div id="41784166" class="c"><input type="checkbox" id="c-41784166" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41784147">parent</a><span>|</span><a href="#41782618">next</a><span>|</span><label class="collapse" for="c-41784166">[-]</label><label class="expand" for="c-41784166">[1 more]</label></div><br/><div class="children"><div class="content">Never stored in ASCII, never limited to ASCII. They&#x27;re UTF-8, usually.<p>If somebody&#x27;s name happens to fit into ASCII that&#x27;s irrelevant because it&#x27;s not guaranteed, so you can never blindly do an ASCII case conversion.<p>For text data meant for users, I literally cannot remember the last time I used a string in ASCII format as opposed to UTF-8 (or UTF-16 in JS). It&#x27;s certainly over a decade ago.<p>So yes, when I say never, I literally mean never. Nothing &quot;very silly&quot; about it, sorry.<p>(Again, excepting identifiers, where case conversion is not generally applicable.)</div><br/></div></div></div></div><div id="41782618" class="c"><input type="checkbox" id="c-41782618" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41781750">parent</a><span>|</span><a href="#41784147">prev</a><span>|</span><a href="#41775511">next</a><span>|</span><label class="collapse" for="c-41782618">[-]</label><label class="expand" for="c-41782618">[1 more]</label></div><br/><div class="children"><div class="content">And you could argue that if the internal identifiers need to be capitalized or lower-cased, you&#x27;ve already lost.<p>On an enterprise app these little string manipulations are a drop in the bucket. In a game they might not be. Sort that stuff out at compile time, or commit time.</div><br/></div></div></div></div><div id="41775511" class="c"><input type="checkbox" id="c-41775511" checked=""/><div class="controls bullet"><span class="by">sebstefan</span><span>|</span><a href="#41775153">parent</a><span>|</span><a href="#41781750">prev</a><span>|</span><a href="#41784697">next</a><span>|</span><label class="collapse" for="c-41775511">[-]</label><label class="expand" for="c-41775511">[11 more]</label></div><br/><div class="children"><div class="content">Yes please, keep making software that mangles my actual last name at every step of the way. 99% of the world loves it when you only care about the USA.</div><br/><div id="41775607" class="c"><input type="checkbox" id="c-41775607" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775511">parent</a><span>|</span><a href="#41782911">next</a><span>|</span><label class="collapse" for="c-41775607">[-]</label><label class="expand" for="c-41775607">[7 more]</label></div><br/><div class="children"><div class="content">If it needs to uppercase names it probably interfaces with something forsaken like Sabre&#x2F;Amadeus that only understands ASCII anyway.<p>The real problem is accepting non-ASCII input from user where you later assume it&#x27;s ASCII-only and safe to bitfuck around.</div><br/><div id="41776002" class="c"><input type="checkbox" id="c-41776002" checked=""/><div class="controls bullet"><span class="by">sebstefan</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775607">parent</a><span>|</span><a href="#41776465">next</a><span>|</span><label class="collapse" for="c-41776002">[-]</label><label class="expand" for="c-41776002">[5 more]</label></div><br/><div class="children"><div class="content">From experience anything banking adjacent will usually fuck it up as well<p>For some reason they have a hard-on for putting last names in capital letters and they still have systems in place that use ASCII</div><br/><div id="41777384" class="c"><input type="checkbox" id="c-41777384" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41776002">parent</a><span>|</span><a href="#41776465">next</a><span>|</span><label class="collapse" for="c-41777384">[-]</label><label class="expand" for="c-41777384">[4 more]</label></div><br/><div class="children"><div class="content">If it uses ASCII anyway, what&#x27;s the problem then? Don&#x27;t accept non-ASCII user input.</div><br/><div id="41777484" class="c"><input type="checkbox" id="c-41777484" checked=""/><div class="controls bullet"><span class="by">sebstefan</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41777384">parent</a><span>|</span><a href="#41776465">next</a><span>|</span><label class="collapse" for="c-41777484">[-]</label><label class="expand" for="c-41777484">[3 more]</label></div><br/><div class="children"><div class="content">First off: And exclude 70% of the world?<p>Usually they&#x27;ll accept it, but some parts of the backend are still running code from the 60&#x27;s.<p>So you get your name rendered properly on the web interface,  and most core features, but one day you&#x27;re wandering off from the beaten path, by, like, requesting some insurance contract, and you&#x27;ll see your name at the top with some characters mangled, depending on what your name&#x27;s like. Mine is just accented latin characters so it usually drops the accents ; not sure how it would work if your name was in an entirely different alphabet</div><br/><div id="41781414" class="c"><input type="checkbox" id="c-41781414" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41777484">parent</a><span>|</span><a href="#41776465">next</a><span>|</span><label class="collapse" for="c-41781414">[-]</label><label class="expand" for="c-41781414">[2 more]</label></div><br/><div class="children"><div class="content">&gt;First off: And exclude 70% of the world?<p>Guess what, I&#x27;m part of this 70% and I also work in a bank and I know exactly how.<p>Not a single letter in my name (any of them) can be represented with ASCII. When it is represented in UTF-8, most of the people who have to see it can&#x27;t read it anyway.<p>So my identity document issued by the country which doesn&#x27;t use Latin alphabet includes ASCII-representation of my name in addition to canonical form in Ukrainian Cyrillic. That ASCII-rendering is happily accepted by all kinds of systems that only speak ASCII.<p>People still can&#x27;t pronounce it and it got misspelled like <i>yesterday</i> when dictated over the phone.<p>Now regarding the accents, it&#x27;s illegal to not support them per GDPR (as per case law, discussed here few years ago).</div><br/><div id="41783224" class="c"><input type="checkbox" id="c-41783224" checked=""/><div class="controls bullet"><span class="by">numpad0</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41781414">parent</a><span>|</span><a href="#41776465">next</a><span>|</span><label class="collapse" for="c-41783224">[-]</label><label class="expand" for="c-41783224">[1 more]</label></div><br/><div class="children"><div class="content">Why can&#x27;t these people understand that that 70% of the world consider ASCII to be &quot;the computer language&quot;, not English, and UTF-8 to be &quot;whatever soup that only works inside files and forms and can&#x27;t be program manipulated&quot;?<p>Maybe it needs to be communicated more often, like way more often, until it sticks.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41776465" class="c"><input type="checkbox" id="c-41776465" checked=""/><div class="controls bullet"><span class="by">InfamousRece</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775607">parent</a><span>|</span><a href="#41776002">prev</a><span>|</span><a href="#41782911">next</a><span>|</span><label class="collapse" for="c-41776465">[-]</label><label class="expand" for="c-41776465">[1 more]</label></div><br/><div class="children"><div class="content">Some systems are still using EBCDIC.</div><br/></div></div></div></div><div id="41782911" class="c"><input type="checkbox" id="c-41782911" checked=""/><div class="controls bullet"><span class="by">MajimasEyepatch</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775511">parent</a><span>|</span><a href="#41775607">prev</a><span>|</span><a href="#41784697">next</a><span>|</span><label class="collapse" for="c-41782911">[-]</label><label class="expand" for="c-41782911">[3 more]</label></div><br/><div class="children"><div class="content">It’s totally reasonable to assume your users are in the US if your business only sells to people in the US. I work in the health insurance sector; there’s absolutely no chance my company ever sells these products internationally. We can’t even sell them in every state.</div><br/><div id="41783011" class="c"><input type="checkbox" id="c-41783011" checked=""/><div class="controls bullet"><span class="by">davidcbc</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41782911">parent</a><span>|</span><a href="#41784697">next</a><span>|</span><label class="collapse" for="c-41783011">[-]</label><label class="expand" for="c-41783011">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not reasonable to assume that users in the US have names that only use 7-bit ASCII</div><br/><div id="41784154" class="c"><input type="checkbox" id="c-41784154" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41783011">parent</a><span>|</span><a href="#41784697">next</a><span>|</span><label class="collapse" for="c-41784154">[-]</label><label class="expand" for="c-41784154">[1 more]</label></div><br/><div class="children"><div class="content">It actually is. That covers the vast, vast majority of people in the US.</div><br/></div></div></div></div></div></div></div></div><div id="41784697" class="c"><input type="checkbox" id="c-41784697" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41775153">parent</a><span>|</span><a href="#41775511">prev</a><span>|</span><a href="#41775216">next</a><span>|</span><label class="collapse" for="c-41784697">[-]</label><label class="expand" for="c-41784697">[2 more]</label></div><br/><div class="children"><div class="content">He may be right, but approximately 75% of the problems he describes are all Microsoft-ecosystem specific.<p>In Unix-land we don&#x27;t use wchar_t or UTF-16, and his article is a good demonstrations of why not.</div><br/><div id="41785502" class="c"><input type="checkbox" id="c-41785502" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41784697">parent</a><span>|</span><a href="#41775216">next</a><span>|</span><label class="collapse" for="c-41785502">[-]</label><label class="expand" for="c-41785502">[1 more]</label></div><br/><div class="children"><div class="content">UNIX land is even worse in international languages support.<p>As in, there isn&#x27;t even something on POSIX at the level other operaring systems support for localisation.<p>Yes there is some locale stuff, however not enough for all stuff, hence why every modern programming language happens to have this as part of their standard library.</div><br/></div></div></div></div><div id="41775216" class="c"><input type="checkbox" id="c-41775216" checked=""/><div class="controls bullet"><span class="by">fhars</span><span>|</span><a href="#41775153">parent</a><span>|</span><a href="#41784697">prev</a><span>|</span><a href="#41784886">next</a><span>|</span><label class="collapse" for="c-41775216">[-]</label><label class="expand" for="c-41775216">[30 more]</label></div><br/><div class="children"><div class="content">No, when you are doing string manipulation, you are almost never interestet in just the seven bit ASCII range, as there is almost no language that can be written using just that.</div><br/><div id="41775255" class="c"><input type="checkbox" id="c-41775255" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775216">parent</a><span>|</span><a href="#41775253">next</a><span>|</span><label class="collapse" for="c-41775255">[-]</label><label class="expand" for="c-41775255">[18 more]</label></div><br/><div class="children"><div class="content">&gt; as there is almost no language that can be written using just that.<p>99% of use cases I&#x27;ve seen have nothing to do with human language.<p>1% human language case that is needs to be handled properly using a proper Unicode library.<p>Your mileage (percentages) may vary depending on your job.</div><br/><div id="41775546" class="c"><input type="checkbox" id="c-41775546" checked=""/><div class="controls bullet"><span class="by">kergonath</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775255">parent</a><span>|</span><a href="#41775310">next</a><span>|</span><label class="collapse" for="c-41775546">[-]</label><label class="expand" for="c-41775546">[7 more]</label></div><br/><div class="children"><div class="content">Right. That’s why I still get mail with my name mangled and my street name barely recognisable. Because I’m in the 1%. Too bad for me…<p>In all seriousness, though, in the real world ASCII works only for a subset of a handful of languages. The vast majority of the population does not read or write any English in their day to day lives. As far as end users are concerned, you should probably swap your percentages.<p>ASCII is mostly fine within your programs like the parser you mention in your other comment. But even then, it’s better if a Chinese user name does not break your reporting or logging systems or your parser, so it’s still a good idea to take Unicode seriously. Otherwise, anything that comes from a user or gets out of the program needs to behave.</div><br/><div id="41783435" class="c"><input type="checkbox" id="c-41783435" checked=""/><div class="controls bullet"><span class="by">Factory</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775546">parent</a><span>|</span><a href="#41783312">next</a><span>|</span><label class="collapse" for="c-41783435">[-]</label><label class="expand" for="c-41783435">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The vast majority of the population does not read or write any English in their day to day lives.&quot;
This is doubtful: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_languages_by_total_number_of_speakers" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;List_of_languages_by_total_num...</a>
While English speakers are not a majority, it is the most popular language. 
And one should also note that given English is the lingua franca of programming, I&#x27;d suspect that English as a second language is actually a majority for programmers.
So any code that deals solely with programmers as users can easily just use standard ASCII as default, and never see any problems.</div><br/></div></div><div id="41783312" class="c"><input type="checkbox" id="c-41783312" checked=""/><div class="controls bullet"><span class="by">numpad0</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775546">parent</a><span>|</span><a href="#41783435">prev</a><span>|</span><a href="#41775600">next</a><span>|</span><label class="collapse" for="c-41783312">[-]</label><label class="expand" for="c-41783312">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That’s why I still get mail with my name mangled<p>Which is why you always type out addresses in ASCII representations in any foreign transactions even if it&#x27;s not going to match your identity documents, unless the other party specifically demands it in UTF-8 and insists that they can handle it.<p>&gt; it’s better if a Chinese user name does not break your reporting or logging systems<p>You should not be just casually dumping Chinese usernames into logs without warnings, in fact, you should not be using Chinese characters for usernames at all. Lots of Chinese online services exclusively use numeric IDs and e-mails for login IDs. &quot;Usernames in natural human language&quot; is a valid concept only in ASCII cultural sphere.</div><br/></div></div><div id="41775600" class="c"><input type="checkbox" id="c-41775600" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775546">parent</a><span>|</span><a href="#41783312">prev</a><span>|</span><a href="#41775623">next</a><span>|</span><label class="collapse" for="c-41775600">[-]</label><label class="expand" for="c-41775600">[2 more]</label></div><br/><div class="children"><div class="content">I said use a Unicode library if input data is actual human language. Which names and addresses are.<p>99% case being ASCII data generated by other software of unknown provenance. (Or sometimes by humans, but it&#x27;s still data for machines, not for humans.)</div><br/><div id="41776927" class="c"><input type="checkbox" id="c-41776927" checked=""/><div class="controls bullet"><span class="by">kergonath</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775600">parent</a><span>|</span><a href="#41775623">next</a><span>|</span><label class="collapse" for="c-41776927">[-]</label><label class="expand" for="c-41776927">[1 more]</label></div><br/><div class="children"><div class="content">I am really not sure about this 99%. A lot of programs deal with quite a lot of user-provided data, which you don’t control.</div><br/></div></div></div></div><div id="41775623" class="c"><input type="checkbox" id="c-41775623" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775546">parent</a><span>|</span><a href="#41775600">prev</a><span>|</span><a href="#41775310">next</a><span>|</span><label class="collapse" for="c-41775623">[-]</label><label class="expand" for="c-41775623">[2 more]</label></div><br/><div class="children"><div class="content">Who and why still tries to lowercase&#x2F;uppercase names? Please tell them to stop.</div><br/><div id="41776932" class="c"><input type="checkbox" id="c-41776932" checked=""/><div class="controls bullet"><span class="by">kergonath</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775623">parent</a><span>|</span><a href="#41775310">next</a><span>|</span><label class="collapse" for="c-41776932">[-]</label><label class="expand" for="c-41776932">[1 more]</label></div><br/><div class="children"><div class="content">Hell if I know. I don’t know what kind of abomination e-commerce websites run on their backend, I just see the consequences.</div><br/></div></div></div></div></div></div><div id="41775310" class="c"><input type="checkbox" id="c-41775310" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775255">parent</a><span>|</span><a href="#41775546">prev</a><span>|</span><a href="#41775771">next</a><span>|</span><label class="collapse" for="c-41775310">[-]</label><label class="expand" for="c-41775310">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny how software developers live in bubbles so much. Whether you deal with human language a lot or almost not at all depends entirely on your specific domain. Anyone working on user interfaces of any kind must accommodate for proper encoding, for example; that includes pretty much every line-of-business app out there, which is <i>a lot of code</i>.</div><br/></div></div><div id="41775771" class="c"><input type="checkbox" id="c-41775771" checked=""/><div class="controls bullet"><span class="by">elpocko</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775255">parent</a><span>|</span><a href="#41775310">prev</a><span>|</span><a href="#41775402">next</a><span>|</span><label class="collapse" for="c-41775771">[-]</label><label class="expand" for="c-41775771">[1 more]</label></div><br/><div class="children"><div class="content">Every search feature everywhere has to be case-insensitive or it&#x27;s unusable. Search seems like a pretty ubiquitous feature in a lot of software, and has to work regardless of locale&#x2F;encoding.</div><br/></div></div><div id="41775402" class="c"><input type="checkbox" id="c-41775402" checked=""/><div class="controls bullet"><span class="by">inexcf</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775255">parent</a><span>|</span><a href="#41775771">prev</a><span>|</span><a href="#41775253">next</a><span>|</span><label class="collapse" for="c-41775402">[-]</label><label class="expand" for="c-41775402">[8 more]</label></div><br/><div class="children"><div class="content">Why do you need upper- or lowercase conversion in cases that have nothing to do with human language?</div><br/><div id="41775451" class="c"><input type="checkbox" id="c-41775451" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775402">parent</a><span>|</span><a href="#41775253">next</a><span>|</span><label class="collapse" for="c-41775451">[-]</label><label class="expand" for="c-41775451">[7 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s an example. Hypothetically say you want to build an HTML parser.<p>You might encounter tags like &lt;html&gt;, &lt;HTML&gt;, &lt;Html&gt;, etc., but you want to perform a hash table lookup.<p>So first you&#x27;re going to normalize to either lower- or uppercase.</div><br/><div id="41780449" class="c"><input type="checkbox" id="c-41780449" checked=""/><div class="controls bullet"><span class="by">ARandumGuy</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775451">parent</a><span>|</span><a href="#41776614">next</a><span>|</span><label class="collapse" for="c-41780449">[-]</label><label class="expand" for="c-41780449">[1 more]</label></div><br/><div class="children"><div class="content">Converting string case is almost never something you want to do for text that&#x27;s displayed to the end user, but there are many situations where you need to do it internally. Generally when the spec is case insensitive, but you still need to verify or organize things using string comparison.</div><br/></div></div><div id="41776614" class="c"><input type="checkbox" id="c-41776614" checked=""/><div class="controls bullet"><span class="by">inexcf</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775451">parent</a><span>|</span><a href="#41780449">prev</a><span>|</span><a href="#41775642">next</a><span>|</span><label class="collapse" for="c-41776614">[-]</label><label class="expand" for="c-41776614">[4 more]</label></div><br/><div class="children"><div class="content">Ah, i see, we disagree on what is &quot;human language&quot;. An abbreviation like HTML and it&#x27;s different capitalisations to me sound a lot like a feature of human language.</div><br/><div id="41780264" class="c"><input type="checkbox" id="c-41780264" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41776614">parent</a><span>|</span><a href="#41775642">next</a><span>|</span><label class="collapse" for="c-41780264">[-]</label><label class="expand" for="c-41780264">[3 more]</label></div><br/><div class="children"><div class="content">Is this a serious argument?  Humans don&#x27;t directly use HTML to communicate with each other.  It&#x27;s a document markup language rendered by user agents, developed against a specification.</div><br/><div id="41781806" class="c"><input type="checkbox" id="c-41781806" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41780264">parent</a><span>|</span><a href="#41775642">next</a><span>|</span><label class="collapse" for="c-41781806">[-]</label><label class="expand" for="c-41781806">[2 more]</label></div><br/><div class="children"><div class="content">Markup languages and SGML in particular absolutely are designed for digital text communication by humans and to be written using plain text editors; it&#x27;s kindof the entire point of avoiding binary data constructs.<p>And to GP, SGML&#x2F;HTML actually has a facility to define uppercasing rules beyond ASCII, namely the LCNMSTRT, UCNMSTRT, LCNMCHAR, UCNMCHAR options in the SYNTAX NAMING section in the SGML declaration introduced in the &quot;Extended Naming Rules&quot; revision of ISO 8879 (SGML std, cf. <a href="https:&#x2F;&#x2F;sgmljs.net&#x2F;docs&#x2F;sgmlrefman.html" rel="nofollow">https:&#x2F;&#x2F;sgmljs.net&#x2F;docs&#x2F;sgmlrefman.html</a>). Like basically everything else on this level, these rules are still used by HTML 5 to this date, and in particular, that while elements names can contain arbitrary characters, only those in the IRV (ASCII) get case-folded for canonization.</div><br/><div id="41783073" class="c"><input type="checkbox" id="c-41783073" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41781806">parent</a><span>|</span><a href="#41775642">next</a><span>|</span><label class="collapse" for="c-41783073">[-]</label><label class="expand" for="c-41783073">[1 more]</label></div><br/><div class="children"><div class="content">HTML is a text-based medium.  But that doesn&#x27;t make it a human language.  Some human languages are not text-based.  And some text is not a human language.<p>ANSI C was designed to be written by humans using a plain text editor.  That doesn&#x27;t make it a human language.</div><br/></div></div></div></div></div></div></div></div><div id="41775642" class="c"><input type="checkbox" id="c-41775642" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775451">parent</a><span>|</span><a href="#41776614">prev</a><span>|</span><a href="#41775253">next</a><span>|</span><label class="collapse" for="c-41775642">[-]</label><label class="expand" for="c-41775642">[1 more]</label></div><br/><div class="children"><div class="content">But but, I want to have a custom web component and register it under my own name, which can only be properly written in Ukrainian Cyrillic. How dare you not let me have it.</div><br/></div></div></div></div></div></div></div></div><div id="41775253" class="c"><input type="checkbox" id="c-41775253" checked=""/><div class="controls bullet"><span class="by">daemin</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775216">parent</a><span>|</span><a href="#41775255">prev</a><span>|</span><a href="#41784886">next</a><span>|</span><label class="collapse" for="c-41775253">[-]</label><label class="expand" for="c-41775253">[11 more]</label></div><br/><div class="children"><div class="content">I would argue that for most programs when you&#x27;re doing string manipulation you&#x27;re doing it for internal programming reasons - logs, error messages, etc. In that case you are in nearly full control of the strings and therefore can declare that you&#x27;re only working with ASCII.<p>The other normal cases of string usage are file paths and user interface, and the needed operations can be done with simple string functions, and even in UTF8 encoding the characters you care about are in the ASCII range.
With file paths the manipulations that you&#x27;re most often doing is path based so you only care about &#x27;&#x2F;&#x27;, &#x27;\&#x27;, &#x27;:&#x27;, and &#x27;.&#x27; ASCII characters.
With user interface elements you&#x27;re likely to be using them as just static data and only substituting values into placeholders when necessary.</div><br/><div id="41775318" class="c"><input type="checkbox" id="c-41775318" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775253">parent</a><span>|</span><a href="#41775329">next</a><span>|</span><label class="collapse" for="c-41775318">[-]</label><label class="expand" for="c-41775318">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I would argue that for most programs when you&#x27;re doing string manipulation you&#x27;re doing it for internal programming reasons - logs, error messages, etc. In that case you are in nearly full control of the strings and therefore can declare that you&#x27;re only working with ASCII.<p>Why would you argue that? In my experience it&#x27;s about formatting things that are addressed to the user, where the hardest and most annoying localization problems matter a lot. That includes sorting the last name &quot;van den Berg&quot; just after &quot;Bakker&quot;, stylizing it as &quot;Berg, van den&quot;, and making sure this capitalization is correct and not &quot;Van Den Berg&quot;. There is no built in standard library function in any language that does any of that. It&#x27;s so much larger than ascii and even larger than unicode.<p>Another user said that the main takeaway is that you can&#x27;t process strings until you know their language (locale), and that is exactly correct.</div><br/><div id="41775604" class="c"><input type="checkbox" id="c-41775604" checked=""/><div class="controls bullet"><span class="by">daemin</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775318">parent</a><span>|</span><a href="#41775329">next</a><span>|</span><label class="collapse" for="c-41775604">[-]</label><label class="expand" for="c-41775604">[2 more]</label></div><br/><div class="children"><div class="content">I would maintain that your program has more string manipulation for error messages and logging than for generating localised formatted names.<p>Further I do say that if you&#x27;re creating text for presenting to the user then the most common operation would be replacement of some field in pre-defined text.<p>In your case I would design it so that the correctly capitalised first name, surname, and variations of those for sorting would be generated at the data entry point (manually or automatically) and then just used when needed in user facing text generation. Therefore the only string operation needed would be replacement of placeholders like the fmt and standard library provide. This uses more memory and storage but these are cheaper now.</div><br/><div id="41776054" class="c"><input type="checkbox" id="c-41776054" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775604">parent</a><span>|</span><a href="#41775329">next</a><span>|</span><label class="collapse" for="c-41776054">[-]</label><label class="expand" for="c-41776054">[1 more]</label></div><br/><div class="children"><div class="content">I agree, but the logging formatters don&#x27;t really do much beyond trivially pasting in placeholders.<p>And as for data entry... Maybe in an ideal world. In the current world, marred by importing previously mangled datasets, a common solution in the few companies I&#x27;ve worked at is to just not do anything, which leaves ugly edges, yet is &quot;good enough&quot;.</div><br/></div></div></div></div></div></div><div id="41775329" class="c"><input type="checkbox" id="c-41775329" checked=""/><div class="controls bullet"><span class="by">heisenzombie</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775253">parent</a><span>|</span><a href="#41775318">prev</a><span>|</span><a href="#41775323">next</a><span>|</span><label class="collapse" for="c-41775329">[-]</label><label class="expand" for="c-41775329">[6 more]</label></div><br/><div class="children"><div class="content">File paths? I think filesystem paths are generally “bags of bytes” that the OS might interpret as UTF-16 (Windows) or UTF-8 (macOS, Linux).<p>For example: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Program_Files#Localization" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Program_Files#Localization</a></div><br/><div id="41775338" class="c"><input type="checkbox" id="c-41775338" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775329">parent</a><span>|</span><a href="#41775323">next</a><span>|</span><label class="collapse" for="c-41775338">[-]</label><label class="expand" for="c-41775338">[5 more]</label></div><br/><div class="children"><div class="content">File paths are scary. The last I checked (which is admittedly a while ago), Windows didn&#x27;t for example care about correct UTF-16 surrogate pairs at all, it&#x27;d happily accept invalid UTF-16 strings.<p>So use standard string processing libraries on path names at your own peril.<p>It&#x27;s a good idea to consider file paths as a bag of bytes.</div><br/><div id="41775508" class="c"><input type="checkbox" id="c-41775508" checked=""/><div class="controls bullet"><span class="by">netsharc</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775338">parent</a><span>|</span><a href="#41775452">next</a><span>|</span><label class="collapse" for="c-41775508">[-]</label><label class="expand" for="c-41775508">[1 more]</label></div><br/><div class="children"><div class="content">IIRC, the FAT filesystem (before Windows 95) allowed lowercase letters, but there&#x27;s a layer in the filesystem driver that converted everything to uppercase, e.g. if you did the command &quot;more readme.txt&quot;, the more command would ask the filesystem for &quot;readme.txt&quot; and it would search for &quot;README.TXT&quot; in the file allocation table.<p>I think I once hex-edited the FA-table to change a filename to have a lowercase name (or maybe it was disk corruption), trying to delete that file didn&#x27;t work because it would be trying to delete &quot;FOO&quot;, and couldn&#x27;t find it because the file was named &quot;FOo&quot;.</div><br/></div></div><div id="41775452" class="c"><input type="checkbox" id="c-41775452" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775338">parent</a><span>|</span><a href="#41775508">prev</a><span>|</span><a href="#41783375">next</a><span>|</span><label class="collapse" for="c-41775452">[-]</label><label class="expand" for="c-41775452">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a good idea to consider file paths as a bag of bytes<p>(Nitpick: <i>sequence</i> of bytes)<p>Also very limiting. If you do that, you can’t, for example, show a file name to the user as a string or easily use a shell to process data in your file system (do you type “&#x2F;bin” or “\x2F\x62\x69\x6E”?)<p>Unix, from the start, claimed file names where byte sequences, yet assumed many of those to encode ascii.<p>That’s part of why Plan 9 made the choice <i>“names may contain any printable character (that is, any character outside hexadecimal 00-1F and 80-9F)”</i> (<a href="https:&#x2F;&#x2F;9fans.github.io&#x2F;plan9port&#x2F;man&#x2F;man9&#x2F;intro.html" rel="nofollow">https:&#x2F;&#x2F;9fans.github.io&#x2F;plan9port&#x2F;man&#x2F;man9&#x2F;intro.html</a>)</div><br/></div></div><div id="41783375" class="c"><input type="checkbox" id="c-41783375" checked=""/><div class="controls bullet"><span class="by">numpad0</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775338">parent</a><span>|</span><a href="#41775452">prev</a><span>|</span><a href="#41775466">next</a><span>|</span><label class="collapse" for="c-41783375">[-]</label><label class="expand" for="c-41783375">[1 more]</label></div><br/><div class="children"><div class="content">Just using UTF-8 for username at all is problematic. That has been a major PSA item for Windows users in my language literally since 90s and still is. Microsoft switched home folder names from Microsoft Account username to shortened user email for that reason.</div><br/></div></div><div id="41775466" class="c"><input type="checkbox" id="c-41775466" checked=""/><div class="controls bullet"><span class="by">daemin</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775338">parent</a><span>|</span><a href="#41783375">prev</a><span>|</span><a href="#41775323">next</a><span>|</span><label class="collapse" for="c-41775466">[-]</label><label class="expand" for="c-41775466">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I mean, you treat filesystem paths as bags of bytes separated by known ASCII characters, as the only path manipulation that you generally need to do is to append a path, remove a path, change extension, things that only care about those ASCII characters. You only modify the path strings at those known characters and leave everything in between as is (with some exceptions using OS API specific functions as needed).</div><br/></div></div></div></div></div></div><div id="41775323" class="c"><input type="checkbox" id="c-41775323" checked=""/><div class="controls bullet"><span class="by">BoringTimesGang</span><span>|</span><a href="#41775153">root</a><span>|</span><a href="#41775253">parent</a><span>|</span><a href="#41775329">prev</a><span>|</span><a href="#41784886">next</a><span>|</span><label class="collapse" for="c-41775323">[-]</label><label class="expand" for="c-41775323">[1 more]</label></div><br/><div class="children"><div class="content">Now double all of that effort, so you can get it to work with Windows&#x27; UTF-16 wstrings.</div><br/></div></div></div></div></div></div><div id="41784886" class="c"><input type="checkbox" id="c-41784886" checked=""/><div class="controls bullet"><span class="by">yas_hmaheshwari</span><span>|</span><a href="#41775153">parent</a><span>|</span><a href="#41775216">prev</a><span>|</span><a href="#41775513">next</a><span>|</span><label class="collapse" for="c-41784886">[-]</label><label class="expand" for="c-41784886">[1 more]</label></div><br/><div class="children"><div class="content">Wow, I came here to write exactly that, and its heartening to see that I am not crazy<p>Just reading the title, with microsoft.com in bracket, I knew two things:
1. It would be written by Raymond Chen
2. That article is going to be awesome</div><br/></div></div></div></div><div id="41775513" class="c"><input type="checkbox" id="c-41775513" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41775153">prev</a><span>|</span><a href="#41775332">next</a><span>|</span><label class="collapse" for="c-41775513">[-]</label><label class="expand" for="c-41775513">[1 more]</label></div><br/><div class="children"><div class="content">Thought this was going to be about and-not-ing bytes with 0x20. Wrong for most inputs but sure as hell faster than anything else.</div><br/></div></div><div id="41775332" class="c"><input type="checkbox" id="c-41775332" checked=""/><div class="controls bullet"><span class="by">cyxxon</span><span>|</span><a href="#41775513">prev</a><span>|</span><a href="#41784627">next</a><span>|</span><label class="collapse" for="c-41775332">[-]</label><label class="expand" for="c-41775332">[7 more]</label></div><br/><div class="children"><div class="content">Small nitpick: the example &quot;LATIN SMALL LETTER SHARP S (“ß” U+00DF) uppercases to the two-character sequence “SS”:³ Straße ⇒ STRASSE&quot; is slightly wrong, it seems to me, as we now do actually have a uppercase version of that, so it should uppercase to &quot;Latin Capital Letter Sharp S&quot; (U+1E9E).
The double-S thing is still widely used, though.</div><br/><div id="41775411" class="c"><input type="checkbox" id="c-41775411" checked=""/><div class="controls bullet"><span class="by">mkayokay</span><span>|</span><a href="#41775332">parent</a><span>|</span><a href="#41777547">next</a><span>|</span><label class="collapse" for="c-41775411">[-]</label><label class="expand" for="c-41775411">[3 more]</label></div><br/><div class="children"><div class="content">Duden mentions this: &quot;Bei Verwendung von Großbuchstaben steht traditionellerweise SS für ß. In manchen Schriften gibt es aber auch einen entsprechenden Großbuchstaben; seine Verwendung ist fakultativ ‹§ 25 E3›.&quot;<p>But isn&#x27;t it also dependent on the available glyphs in the font used? So f.e. it needs to be ensured that U+1E9E exists?</div><br/><div id="41784844" class="c"><input type="checkbox" id="c-41784844" checked=""/><div class="controls bullet"><span class="by">NoInkling</span><span>|</span><a href="#41775332">root</a><span>|</span><a href="#41775411">parent</a><span>|</span><a href="#41782720">next</a><span>|</span><label class="collapse" for="c-41784844">[-]</label><label class="expand" for="c-41784844">[1 more]</label></div><br/><div class="children"><div class="content">According to Wikipedia:<p>&gt; &quot;Since 2024 the capital ⟨ẞ⟩ is preferred over ⟨SS⟩.&quot;<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;%C3%9F" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;%C3%9F</a><p>Check reference #5 and compare it to the older wording in reference #12.</div><br/></div></div><div id="41782720" class="c"><input type="checkbox" id="c-41782720" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#41775332">root</a><span>|</span><a href="#41775411">parent</a><span>|</span><a href="#41784844">prev</a><span>|</span><a href="#41777547">next</a><span>|</span><label class="collapse" for="c-41782720">[-]</label><label class="expand" for="c-41782720">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there exists any code that makes uppercasing decisions based on the selected font. Besides, if it doesn&#x27;t exist in the current font, there&#x27;s probably a fallback font.</div><br/></div></div></div></div><div id="41777547" class="c"><input type="checkbox" id="c-41777547" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41775332">parent</a><span>|</span><a href="#41775411">prev</a><span>|</span><a href="#41775675">next</a><span>|</span><label class="collapse" for="c-41777547">[-]</label><label class="expand" for="c-41777547">[1 more]</label></div><br/><div class="children"><div class="content">Lowering case is even better, because a Swiss user would expect the two-character sequence “SS“ to be converted into “ss“ and not “ß“.<p>And thus we add country specific locale to the party.</div><br/></div></div><div id="41775675" class="c"><input type="checkbox" id="c-41775675" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#41775332">parent</a><span>|</span><a href="#41777547">prev</a><span>|</span><a href="#41781048">next</a><span>|</span><label class="collapse" for="c-41775675">[-]</label><label class="expand" for="c-41775675">[1 more]</label></div><br/><div class="children"><div class="content">But what if you need to uppercase the historical record in a vital records registry from 1950ies, but and OCRed last week? Now you need to not just be locale-aware, but you locale should be versioned.</div><br/></div></div><div id="41781048" class="c"><input type="checkbox" id="c-41781048" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#41775332">parent</a><span>|</span><a href="#41775675">prev</a><span>|</span><a href="#41784627">next</a><span>|</span><label class="collapse" for="c-41781048">[-]</label><label class="expand" for="c-41781048">[1 more]</label></div><br/><div class="children"><div class="content">The footnote #3 in the article (called as part of your quote) covers the different ways to uppercase ß with more detail.</div><br/></div></div></div></div><div id="41784627" class="c"><input type="checkbox" id="c-41784627" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#41775332">prev</a><span>|</span><a href="#41784009">next</a><span>|</span><label class="collapse" for="c-41784627">[-]</label><label class="expand" for="c-41784627">[1 more]</label></div><br/><div class="children"><div class="content">First, you should consider if you even need case folding; for many uses it will be unnecessary, anyways.<p>Furthermore, the proper way to do case folding will depend on such things as the character set, the language, the specific context of the text being converted (e.g. in some cases specific letters are required, such as abbreviations of the names of SI units), etc. And then, it is not necessarily only &quot;uppercase&quot; and &quot;lowercase&quot;, anyways.<p>There might even be different ways to do by the same language, with possibly disagreements about usage (e.g. the German Eszett did not have an official capital form until 2017, although apparently some type designers did it anyways (and it was in Unicode before then, despite that)).<p>If the character set is Unicode, then there is not actually the correct way to do it, despite what the Unicode Conspiracy insists otherwise.<p>Also, for some uses the way that it will need to be done, there will be a specific way that it is required (due to the way that a file format or a protocol or whatever is working), so in such a case if the character set is something other than ASCII then you cannot just assume that it will always work in the same way.<p>You also cannot necessarily depend on the locale for such a thing, since it might depend on the data, as well.<p>These things can be as bad as they are, but Unicode just makes these things worse than that. If a program requires a specific case folding and then it will not work because it is the wrong version of Unicode and it is possible to be a security issue and&#x2F;or other problems.<p>(Another problem, which applies even if you do not use case folding, is that some people think that all text is or should be Unicode and that one character set is suitable for everything. Actually, one character set cannot be suitable for everything, regardless of what character set it is. Even if it was (which it isn&#x27;t), it wouldn&#x27;t be Unicode.)</div><br/></div></div><div id="41785536" class="c"><input type="checkbox" id="c-41785536" checked=""/><div class="controls bullet"><span class="by">guerrilla</span><span>|</span><a href="#41784009">prev</a><span>|</span><a href="#41775447">next</a><span>|</span><label class="collapse" for="c-41785536">[-]</label><label class="expand" for="c-41785536">[1 more]</label></div><br/><div class="children"><div class="content">C is hard. It seems like C++ just made things way harder. I don&#x27;t regret skipping it. Why not just go right to Java, C#, JS, Haskell, etc. and do what you need in C.</div><br/></div></div><div id="41775447" class="c"><input type="checkbox" id="c-41775447" checked=""/><div class="controls bullet"><span class="by">serbuvlad</span><span>|</span><a href="#41785536">prev</a><span>|</span><a href="#41781042">next</a><span>|</span><label class="collapse" for="c-41775447">[-]</label><label class="expand" for="c-41775447">[4 more]</label></div><br/><div class="children"><div class="content">The real insights here are that strings in C++ suck and UTF-16 is extremely unintuitive.</div><br/><div id="41779693" class="c"><input type="checkbox" id="c-41779693" checked=""/><div class="controls bullet"><span class="by">criddell</span><span>|</span><a href="#41775447">parent</a><span>|</span><a href="#41781042">next</a><span>|</span><label class="collapse" for="c-41779693">[-]</label><label class="expand" for="c-41779693">[3 more]</label></div><br/><div class="children"><div class="content">Strings in C++ standard library do suck (and C++ is my favorite language).<p>As for UTF-16, well, I don&#x27;t know that UTF-8 is a whole lot more intuitive:<p>&gt; And for UTF-8 data, you have the same issues discussed before: Multibyte characters will not be converted properly, and it breaks for case mappings that alter string lengths.</div><br/><div id="41780271" class="c"><input type="checkbox" id="c-41780271" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41775447">root</a><span>|</span><a href="#41779693">parent</a><span>|</span><a href="#41781042">next</a><span>|</span><label class="collapse" for="c-41780271">[-]</label><label class="expand" for="c-41780271">[2 more]</label></div><br/><div class="children"><div class="content">UTF-16 has all the complexity of UTF-8 <i>plus</i> surrogate pairs.</div><br/><div id="41780610" class="c"><input type="checkbox" id="c-41780610" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#41775447">root</a><span>|</span><a href="#41780271">parent</a><span>|</span><a href="#41781042">next</a><span>|</span><label class="collapse" for="c-41780610">[-]</label><label class="expand" for="c-41780610">[1 more]</label></div><br/><div class="children"><div class="content">Surrogate pairs aren&#x27;t more complex than UTF-8&#x27;s scheme for determining the number of bytes used to represent a code point. (Arguably the logic is slightly simpler.) But the important point is that UTF-16 <i>pretends to</i> be a constant-length encoding while actually having the surrogate-pair loophole - that&#x27;s because it&#x27;s a hack on top of UCS-2 (which originally worked well enough for Microsoft to get married to; but then the BMP turned out not to be enough code points). UTF-8 is clearly designed from scratch to be a multi-byte encoding (and, while the standard now makes the corresponding sequences illegal, the scheme was designed to be able to support much higher code points - up to 2^42 if we extend the logic all the way; hypothetical 6-byte sequences starting with values FC or FD would neatly map up to 2^31).</div><br/></div></div></div></div></div></div></div></div><div id="41781042" class="c"><input type="checkbox" id="c-41781042" checked=""/><div class="controls bullet"><span class="by">flareback</span><span>|</span><a href="#41775447">prev</a><span>|</span><a href="#41782643">next</a><span>|</span><label class="collapse" for="c-41781042">[-]</label><label class="expand" for="c-41781042">[7 more]</label></div><br/><div class="children"><div class="content">He gave 4 examples of how it&#x27;s done incorrectly, but zero actual examples of doing it correctly.</div><br/><div id="41785652" class="c"><input type="checkbox" id="c-41785652" checked=""/><div class="controls bullet"><span class="by">crote</span><span>|</span><a href="#41781042">parent</a><span>|</span><a href="#41781605">next</a><span>|</span><label class="collapse" for="c-41785652">[-]</label><label class="expand" for="c-41785652">[1 more]</label></div><br/><div class="children"><div class="content">The correct thing to do is to <i>not do it at all</i>. If text is 3rd-party supplied, treat it like an opaque byte sequence. Alternatively, pay a well-trained human to do it by hand.<p>All other options are going to result in edge cases where you&#x27;re not handling it properly. It&#x27;s like trying to programmatically split a full name into a first name and a last name: language doesn&#x27;t work like that.</div><br/></div></div><div id="41781605" class="c"><input type="checkbox" id="c-41781605" checked=""/><div class="controls bullet"><span class="by">TheGeminon</span><span>|</span><a href="#41781042">parent</a><span>|</span><a href="#41785652">prev</a><span>|</span><a href="#41781324">next</a><span>|</span><label class="collapse" for="c-41781605">[-]</label><label class="expand" for="c-41781605">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Okay, so those are the problems. What’s the solution?<p>&gt; If you need to perform a case mapping on a string, you can use LCMap­String­Ex with LCMAP_LOWERCASE or LCMAP_UPPERCASE, possibly with other flags like LCMAP_LINGUISTIC_CASING. If you use the International Components for Unicode (ICU) library, you can use u_strToUpper and u_strToLower.</div><br/></div></div><div id="41781324" class="c"><input type="checkbox" id="c-41781324" checked=""/><div class="controls bullet"><span class="by">commandlinefan</span><span>|</span><a href="#41781042">parent</a><span>|</span><a href="#41781605">prev</a><span>|</span><a href="#41782643">next</a><span>|</span><label class="collapse" for="c-41781324">[-]</label><label class="expand" for="c-41781324">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    for (int i = 0; i &lt; strlen(s); i++) {
        s[i] ^= 0x20;
    }</code></pre></div><br/><div id="41781633" class="c"><input type="checkbox" id="c-41781633" checked=""/><div class="controls bullet"><span class="by">calibas</span><span>|</span><a href="#41781042">root</a><span>|</span><a href="#41781324">parent</a><span>|</span><a href="#41781439">next</a><span>|</span><label class="collapse" for="c-41781633">[-]</label><label class="expand" for="c-41781633">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for this universal approach. I can now toggle capitalization on&#x2F;off for any character, instead of just being limited to alphabetic ones!<p>Jokes aside, I was kinda hoping for a good answer that doesn&#x27;t rely on a Windows API or an external library, but I&#x27;m not sure there is one. It&#x27;s a rather complex problem when you account for more than just ASCII and the English language.</div><br/><div id="41782051" class="c"><input type="checkbox" id="c-41782051" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#41781042">root</a><span>|</span><a href="#41781633">parent</a><span>|</span><a href="#41781439">next</a><span>|</span><label class="collapse" for="c-41782051">[-]</label><label class="expand" for="c-41782051">[1 more]</label></div><br/><div class="children"><div class="content">Next up, check out our vector addition implementation of Hello+World. Spoiler alert, the result is Zalgo</div><br/></div></div></div></div><div id="41781439" class="c"><input type="checkbox" id="c-41781439" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41781042">root</a><span>|</span><a href="#41781324">parent</a><span>|</span><a href="#41781633">prev</a><span>|</span><a href="#41782643">next</a><span>|</span><label class="collapse" for="c-41781439">[-]</label><label class="expand" for="c-41781439">[1 more]</label></div><br/><div class="children"><div class="content">Surely you meant:<p><pre><code>  s[i] &amp;= ~0x20;
</code></pre>
We&#x27;re talking about converting to upper case after all! As an added benefit, every space character (0x20) is now a NUL byte!</div><br/></div></div></div></div></div></div><div id="41782643" class="c"><input type="checkbox" id="c-41782643" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41781042">prev</a><span>|</span><a href="#41781052">next</a><span>|</span><label class="collapse" for="c-41782643">[-]</label><label class="expand" for="c-41782643">[1 more]</label></div><br/><div class="children"><div class="content">C++, where every line of code is a book waiting to be written.</div><br/></div></div><div id="41776740" class="c"><input type="checkbox" id="c-41776740" checked=""/><div class="controls bullet"><span class="by">high_na_euv</span><span>|</span><a href="#41781052">prev</a><span>|</span><a href="#41780564">next</a><span>|</span><label class="collapse" for="c-41776740">[-]</label><label class="expand" for="c-41776740">[4 more]</label></div><br/><div class="children"><div class="content">In cpp basic things are hard</div><br/><div id="41781330" class="c"><input type="checkbox" id="c-41781330" checked=""/><div class="controls bullet"><span class="by">johnnyjeans</span><span>|</span><a href="#41776740">parent</a><span>|</span><a href="#41777376">next</a><span>|</span><label class="collapse" for="c-41781330">[-]</label><label class="expand" for="c-41781330">[2 more]</label></div><br/><div class="children"><div class="content">nothing about working with locales, or text in general, is basic. we were decades into working with digital computers before we moved past switchboards and LEDs. don&#x27;t take for granted just how high of a perch upon the shoulders of giants you have. that&#x27;s exactly how the mistakes in the blog post get made.</div><br/><div id="41785705" class="c"><input type="checkbox" id="c-41785705" checked=""/><div class="controls bullet"><span class="by">high_na_euv</span><span>|</span><a href="#41776740">root</a><span>|</span><a href="#41781330">parent</a><span>|</span><a href="#41777376">next</a><span>|</span><label class="collapse" for="c-41785705">[-]</label><label class="expand" for="c-41785705">[1 more]</label></div><br/><div class="children"><div class="content">Ive worked in various languages like C#, C and CPP and I know where Ive been fighting what kinds of problems.<p>People always had some fancy reasoning about why things that should just work are not, but then a few years pass and things are improved.<p>C++ is getting closer and closer to langs like C# in terms of making it harder to shot yourself, but still there is a huge room for improvement</div><br/></div></div></div></div><div id="41777376" class="c"><input type="checkbox" id="c-41777376" checked=""/><div class="controls bullet"><span class="by">onemoresoop</span><span>|</span><a href="#41776740">parent</a><span>|</span><a href="#41781330">prev</a><span>|</span><a href="#41780564">next</a><span>|</span><label class="collapse" for="c-41777376">[-]</label><label class="expand" for="c-41777376">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s subjective but I find C++ extremely ugly.</div><br/></div></div></div></div><div id="41780564" class="c"><input type="checkbox" id="c-41780564" checked=""/><div class="controls bullet"><span class="by">HPsquared</span><span>|</span><a href="#41776740">prev</a><span>|</span><a href="#41781447">next</a><span>|</span><label class="collapse" for="c-41780564">[-]</label><label class="expand" for="c-41780564">[3 more]</label></div><br/><div class="children"><div class="content">I thought this was going to be about adding or subtracting 32. Old school.</div><br/><div id="41784019" class="c"><input type="checkbox" id="c-41784019" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#41780564">parent</a><span>|</span><a href="#41781447">next</a><span>|</span><label class="collapse" for="c-41784019">[-]</label><label class="expand" for="c-41784019">[2 more]</label></div><br/><div class="children"><div class="content">I do hope you mean bitwise &quot;addition&quot; and &quot;subtraction&quot; -- (c =&gt; c&amp;0xdf) or (c =&gt; c|0x20)</div><br/><div id="41785303" class="c"><input type="checkbox" id="c-41785303" checked=""/><div class="controls bullet"><span class="by">HPsquared</span><span>|</span><a href="#41780564">root</a><span>|</span><a href="#41784019">parent</a><span>|</span><a href="#41781447">next</a><span>|</span><label class="collapse" for="c-41785303">[-]</label><label class="expand" for="c-41785303">[1 more]</label></div><br/><div class="children"><div class="content">Tbh I come at this as a plebeian Excel user</div><br/></div></div></div></div></div></div><div id="41782405" class="c"><input type="checkbox" id="c-41782405" checked=""/><div class="controls bullet"><span class="by">himinlomax</span><span>|</span><a href="#41781447">prev</a><span>|</span><a href="#41781783">next</a><span>|</span><label class="collapse" for="c-41782405">[-]</label><label class="expand" for="c-41782405">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And in certain forms of the French language, capitalizing an accented character causes the accent to be dropped: à Paris ⇒ A PARIS.<p>That&#x27;s incorrect, using diacritics on capital letters is always the preferred form, it&#x27;s just that dropping them is acceptable as it was often done for technical reasons.</div><br/></div></div><div id="41781783" class="c"><input type="checkbox" id="c-41781783" checked=""/><div class="controls bullet"><span class="by">PoignardAzur</span><span>|</span><a href="#41782405">prev</a><span>|</span><a href="#41780618">next</a><span>|</span><label class="collapse" for="c-41781783">[-]</label><label class="expand" for="c-41781783">[2 more]</label></div><br/><div class="children"><div class="content">So I&#x27;m going to be that guy and say it:<p>Man, I&#x27;m happy we don&#x27;t need to deal with this crap in Rust, and we can just use String::to_lowercase. Not having to worry about things makes coding fun.</div><br/><div id="41783337" class="c"><input type="checkbox" id="c-41783337" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#41781783">parent</a><span>|</span><a href="#41780618">next</a><span>|</span><label class="collapse" for="c-41783337">[-]</label><label class="expand" for="c-41783337">[1 more]</label></div><br/><div class="children"><div class="content">While certainly much better, you still need to be aware that doing case conversion absent any locale information will never be perfect. If you want proper locale-aware conversion you can use the icu crate (<a href="https:&#x2F;&#x2F;docs.rs&#x2F;icu&#x2F;latest&#x2F;icu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;icu&#x2F;latest&#x2F;icu&#x2F;</a>).</div><br/></div></div></div></div><div id="41780618" class="c"><input type="checkbox" id="c-41780618" checked=""/><div class="controls bullet"><span class="by">the_gorilla</span><span>|</span><a href="#41781783">prev</a><span>|</span><a href="#41775287">next</a><span>|</span><label class="collapse" for="c-41780618">[-]</label><label class="expand" for="c-41780618">[2 more]</label></div><br/><div class="children"><div class="content">Why are some functions addressable in C++ and others not? Seems like a pointless design oversight.</div><br/><div id="41782073" class="c"><input type="checkbox" id="c-41782073" checked=""/><div class="controls bullet"><span class="by">bialpio</span><span>|</span><a href="#41780618">parent</a><span>|</span><a href="#41775287">next</a><span>|</span><label class="collapse" for="c-41782073">[-]</label><label class="expand" for="c-41782073">[1 more]</label></div><br/><div class="children"><div class="content">Footnote in the article provides the following explanation: 
&quot;The standard imposes this limitation because the implementation may need to add default function parameters, template default parameters, or overloads in order to accomplish the various requirements of the standard.&quot;</div><br/></div></div></div></div><div id="41775287" class="c"><input type="checkbox" id="c-41775287" checked=""/><div class="controls bullet"><span class="by">ahartmetz</span><span>|</span><a href="#41780618">prev</a><span>|</span><label class="collapse" for="c-41775287">[-]</label><label class="expand" for="c-41775287">[5 more]</label></div><br/><div class="children"><div class="content">...and that is why you use QString if you are using the Qt framework. QString is a string class that actually does what you want when used in the obvious way. It probably helps that it was mostly created by people with &quot;ASCII+&quot; native languages. Or with customers that expect not exceedingly dumb behavior. The methods are called QString::toUpper() and QString::toLower() and take only the implicit &quot;this&quot; argument, unlike Win32 LCMapStringEx() which takes 5-8 arguments...</div><br/><div id="41775789" class="c"><input type="checkbox" id="c-41775789" checked=""/><div class="controls bullet"><span class="by">cannam</span><span>|</span><a href="#41775287">parent</a><span>|</span><a href="#41775312">next</a><span>|</span><label class="collapse" for="c-41775789">[-]</label><label class="expand" for="c-41775789">[2 more]</label></div><br/><div class="children"><div class="content">QString::toUpper&#x2F;toLower are <i>not</i> locale-aware (<a href="https:&#x2F;&#x2F;doc.qt.io&#x2F;qt-6&#x2F;qstring.html#toLower" rel="nofollow">https:&#x2F;&#x2F;doc.qt.io&#x2F;qt-6&#x2F;qstring.html#toLower</a>)<p>Qt does have a locale-aware equivalent (QLocale::toUpper&#x2F;toLower) which calls out to ICU if available. Otherwise it falls back to the QString functions, so you have to be confident about how your build is configured. Whether it works or not has very little to do with the design of QString.</div><br/><div id="41776325" class="c"><input type="checkbox" id="c-41776325" checked=""/><div class="controls bullet"><span class="by">ahartmetz</span><span>|</span><a href="#41775287">root</a><span>|</span><a href="#41775789">parent</a><span>|</span><a href="#41775312">next</a><span>|</span><label class="collapse" for="c-41776325">[-]</label><label class="expand" for="c-41776325">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see a problem with that. You can have it done locale-aware or not and &quot;not&quot; seems like a sane default. QString will uppercase &#x27;ü&#x27; to &#x27;Ü&#x27; just fine without locale-awareness whereas std::string doesn&#x27;t handle non-ASCII according to the article. The cases where locale matters are probably very rare and the result will probably be reasonable anyway.</div><br/></div></div></div></div><div id="41775312" class="c"><input type="checkbox" id="c-41775312" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41775287">parent</a><span>|</span><a href="#41775789">prev</a><span>|</span><a href="#41781232">next</a><span>|</span><label class="collapse" for="c-41775312">[-]</label><label class="expand" for="c-41775312">[1 more]</label></div><br/><div class="children"><div class="content">You just want a banana, but you also get the gorilla. And the jungle.</div><br/></div></div><div id="41781232" class="c"><input type="checkbox" id="c-41781232" checked=""/><div class="controls bullet"><span class="by">aetherspawn</span><span>|</span><a href="#41775287">parent</a><span>|</span><a href="#41775312">prev</a><span>|</span><label class="collapse" for="c-41781232">[-]</label><label class="expand" for="c-41781232">[1 more]</label></div><br/><div class="children"><div class="content">I will admit I don’t love the Qt licensing model, but most things in Qt just work as they are supposed to, and on every platform too.</div><br/></div></div></div></div></div></div></div></div></div></body></html>