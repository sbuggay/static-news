<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724144466050" as="style"/><link rel="stylesheet" href="styles.css?v=1724144466050"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.builder.io/blog/good-vs-bad-refactoring">Good Refactoring vs. Bad Refactoring</a> <span class="domain">(<a href="https://www.builder.io">www.builder.io</a>)</span></div><div class="subtext"><span>steve8708</span> | <span>42 comments</span></div><br/><div><div id="41297150" class="c"><input type="checkbox" id="c-41297150" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#41298038">next</a><span>|</span><label class="collapse" for="c-41297150">[-]</label><label class="expand" for="c-41297150">[3 more]</label></div><br/><div class="children"><div class="content">That OO refactor isn’t actual OO. The tell tale sign is that it is named by what it does rather than what it is (verb vs noun) and the -or ending in the name [0]. It’s just a function masquerading as a class.<p>The better refactor to introduce OO concepts would have been to introduce an isAdult function on the user class and maybe a formatted function. This + the functional refactor probably would have made for the best code.<p><pre><code>    return users.filter(u =&gt; u.isAdult())
      .map(u =&gt; format(u)); &#x2F;&#x2F; maybe u.formatted()

</code></pre>
[0] <a href="https:&#x2F;&#x2F;www.yegor256.com&#x2F;2015&#x2F;03&#x2F;09&#x2F;objects-end-with-er.html" rel="nofollow">https:&#x2F;&#x2F;www.yegor256.com&#x2F;2015&#x2F;03&#x2F;09&#x2F;objects-end-with-er.html</a></div><br/><div id="41298009" class="c"><input type="checkbox" id="c-41298009" checked=""/><div class="controls bullet"><span class="by">dominicrose</span><span>|</span><a href="#41297150">parent</a><span>|</span><a href="#41298038">next</a><span>|</span><label class="collapse" for="c-41298009">[-]</label><label class="expand" for="c-41298009">[2 more]</label></div><br/><div class="children"><div class="content">What about a pure function that can take anything that has an age as input? Well obviously that wouldn&#x27;t work for a cat but it&#x27;s just an example. It requires typescript and I&#x27;m not sure how to name the file it would go in, but I think it&#x27;s interesting to consider this duck-typing style.<p><pre><code>    function isAdult({age}: {age: int}) {
        return age &gt;= 18
    }
</code></pre>
ps: I replaced const by function because I don&#x27;t like the IDE saying I can&#x27;t use something before it is defined. It&#x27;s not a bug it&#x27;s an early feature of javascript to be able to use a function before it is defined. Code is just easier to read when putting the caller above the callee.</div><br/><div id="41298109" class="c"><input type="checkbox" id="c-41298109" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#41297150">root</a><span>|</span><a href="#41298009">parent</a><span>|</span><a href="#41298038">next</a><span>|</span><label class="collapse" for="c-41298109">[-]</label><label class="expand" for="c-41298109">[1 more]</label></div><br/><div class="children"><div class="content">That wouldn’t be object oriented. In OO you tend to want to ask an object about itself, Yegor talks a bit about this in his book Elegant Objects.<p>What you are proposing is just functions or data-oriented programming; which is fine if that’s your thing, but I’d be weary because of the reasons you outline above. Can a book be an adult? What about a tv show? Or recipe from the 9th century? isAdult really only applies to users and really belongs on that object.</div><br/></div></div></div></div></div></div><div id="41298038" class="c"><input type="checkbox" id="c-41298038" checked=""/><div class="controls bullet"><span class="by">mariopt</span><span>|</span><a href="#41297150">prev</a><span>|</span><a href="#41297828">next</a><span>|</span><label class="collapse" for="c-41298038">[-]</label><label class="expand" for="c-41298038">[3 more]</label></div><br/><div class="children"><div class="content">Words can not express my hate for this kind of articles.<p>Imagine working on a legacy codebase where the PM holds the dogma of refactoring being a bad thing and expecting you to do it wrong, even micro managing your PRs.<p>Most often than not, I do see projects suffering and coders actually resigning due to a lack of internal discussing about best practices, having space&#x2F;time to test potential solutions, having Lead devs who resemble dictators quite well.<p>Let me guess, some PM wrote this article and they just want you to push the product asap by applying pressure and not allowing you ever to refactor. This is just a casual day in software development. I&#x27;m not surprised anymore when most web apps have silly bugs for years because it&#x27;s gonna be a Jira ticket and a big discussion about..... one evil thing called refactor.<p>Several years ago I rewrote a full SaaS in about 3 months, it took another team 12 months with 5 devs. Guess which version made the investors happy, mine.<p>Bad refactoring is just a product of poor engineering culture.</div><br/><div id="41298160" class="c"><input type="checkbox" id="c-41298160" checked=""/><div class="controls bullet"><span class="by">remus</span><span>|</span><a href="#41298038">parent</a><span>|</span><a href="#41298137">next</a><span>|</span><label class="collapse" for="c-41298160">[-]</label><label class="expand" for="c-41298160">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Imagine working on a legacy codebase where the PM holds the dogma of refactoring being a bad thing and expecting you to do it wrong, even micro managing your PRs.<p>I don&#x27;t think the article said that anywhere? It was just a list of some common things that can go wrong when refactoring, along with some examples.</div><br/></div></div><div id="41298137" class="c"><input type="checkbox" id="c-41298137" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#41298038">parent</a><span>|</span><a href="#41298160">prev</a><span>|</span><a href="#41297828">next</a><span>|</span><label class="collapse" for="c-41298137">[-]</label><label class="expand" for="c-41298137">[1 more]</label></div><br/><div class="children"><div class="content">more people just means more time spent trying to coordinate and in the limit, you spend all the time talking and none coding.</div><br/></div></div></div></div><div id="41297828" class="c"><input type="checkbox" id="c-41297828" checked=""/><div class="controls bullet"><span class="by">jv_be</span><span>|</span><a href="#41298038">prev</a><span>|</span><a href="#41296727">next</a><span>|</span><label class="collapse" for="c-41297828">[-]</label><label class="expand" for="c-41297828">[1 more]</label></div><br/><div class="children"><div class="content">A good refactor does not change behaviour, I would like the author to start with that point.
Take many more much smaller steps while doing so.
Not touching a piece of code in the first 6 to 9 months is something I don’t really agree with. Breaking complex methods up by extracting variables and methods can really help learning the code, whilst not breaking it.
If you are worried about consistency, just pair up of practice ensemble programming instead of asynchronous code reviews. Leaving a new dev alone with the code and give them feedback about the things they did wrong after they went through everything is just not a great way to treat people in your team.</div><br/></div></div><div id="41296727" class="c"><input type="checkbox" id="c-41296727" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#41297828">prev</a><span>|</span><a href="#41296172">next</a><span>|</span><label class="collapse" for="c-41296727">[-]</label><label class="expand" for="c-41296727">[5 more]</label></div><br/><div class="children"><div class="content">Good refactoring respects the idioms of the language and the culture of the organisation. Change to new methodology is thoughtful and probably slow, except when a revolution happens but then, its still respectful to the new culture.<p>Bad refactoring is elitist, &quot;you won&#x27;t understand this&quot; commented and the owner walks with nobody left behind who understands it.<p>That the examples deprecated FP and preferred an idiom natural to Java(script) only speaks to the principle. I can imagine a quant-shop in a bank re-factoring to pure Haskell, out of somthing else, and being entirely happy that its FP respecting.<p>So the surface &quot;FP patterns are bad&quot; is a bit light-on. The point was, nobody else in that specific group could really be expected to maintain them unless they were part of the culture.<p>&quot;If you unroll loops a la duff&#x27;s device, you should explain why you&#x27;re doing it&quot; would be another example.</div><br/><div id="41297148" class="c"><input type="checkbox" id="c-41297148" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#41296727">parent</a><span>|</span><a href="#41296172">next</a><span>|</span><label class="collapse" for="c-41297148">[-]</label><label class="expand" for="c-41297148">[4 more]</label></div><br/><div class="children"><div class="content">The dig against FP is weird since the &quot;good refactor&quot; also uses FP, just a built in one in JS. Which I agree is better, but mostly by being built in and idiomatic, it&#x27;s still exactly as functional.</div><br/><div id="41297286" class="c"><input type="checkbox" id="c-41297286" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#41296727">root</a><span>|</span><a href="#41297148">parent</a><span>|</span><a href="#41297766">next</a><span>|</span><label class="collapse" for="c-41297286">[-]</label><label class="expand" for="c-41297286">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I don&#x27;t like this style of FP coding&quot; ok: if you run the group and own the codebase you can enforce that. So good refactoring is style guide enforcement.<p>I think I over-read his dislike of FP. really the complaint is &quot;why did you introduce a new dependency&quot; which I am totally fine with, as a complaint. Thats not cool.<p>Many of his examples kind-of bury the lede. If he had tried to write an abstract up front, I think &quot;dont code FP&quot; wouldn&#x27;t have been in it. &quot;use the methods in the language like .filter and .map&quot; might be.</div><br/></div></div><div id="41297766" class="c"><input type="checkbox" id="c-41297766" checked=""/><div class="controls bullet"><span class="by">carlmr</span><span>|</span><a href="#41296727">root</a><span>|</span><a href="#41297148">parent</a><span>|</span><a href="#41297286">prev</a><span>|</span><a href="#41297445">next</a><span>|</span><label class="collapse" for="c-41297766">[-]</label><label class="expand" for="c-41297766">[1 more]</label></div><br/><div class="children"><div class="content">On point. Even then mentioning it used filter and map. But the bad refactor also uses filter and map. It&#x27;s the exact same change of programming paradigm.<p>Given the text, I would have expected some minor refactor with range-based for loops (are these a thing? My JS is rusty). Where you get the advantage of map (no off-by-one indexing errors) without changing the programming paradigm.</div><br/></div></div><div id="41297445" class="c"><input type="checkbox" id="c-41297445" checked=""/><div class="controls bullet"><span class="by">watwut</span><span>|</span><a href="#41296727">root</a><span>|</span><a href="#41297148">parent</a><span>|</span><a href="#41297766">prev</a><span>|</span><a href="#41296172">next</a><span>|</span><label class="collapse" for="c-41297445">[-]</label><label class="expand" for="c-41297445">[1 more]</label></div><br/><div class="children"><div class="content">I think that was the point - the library added nothing, the same thing could be done with pure javascript.</div><br/></div></div></div></div></div></div><div id="41296172" class="c"><input type="checkbox" id="c-41296172" checked=""/><div class="controls bullet"><span class="by">michaelteter</span><span>|</span><a href="#41296727">prev</a><span>|</span><a href="#41298114">next</a><span>|</span><label class="collapse" for="c-41296172">[-]</label><label class="expand" for="c-41296172">[23 more]</label></div><br/><div class="children"><div class="content">The first example complained about the refactor appealing to functional thinkers (implying that it would be difficult to grok by the existing devs), but then the “improved” version is virtually the same save for the (unnecessary?) use of Ramda in the first.<p>And while many devs are resistant to try functional ways, this first example reads so much better than the original code that I find it impossible to believe that some prefer the imperative loop&#x2F;conditional nesting approach.</div><br/><div id="41296548" class="c"><input type="checkbox" id="c-41296548" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41296172">parent</a><span>|</span><a href="#41297504">next</a><span>|</span><label class="collapse" for="c-41296548">[-]</label><label class="expand" for="c-41296548">[5 more]</label></div><br/><div class="children"><div class="content">(Raises hand.) I prefer the for loop. Pushing items to an array is idiomatic Javascript for creating an array. An if statement is an idiomatic way to do it conditionally. It&#x27;s also easier to debug.<p>The map and filter methods are nice too, but they&#x27;re for one-liners.</div><br/><div id="41296760" class="c"><input type="checkbox" id="c-41296760" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41296548">parent</a><span>|</span><a href="#41297089">next</a><span>|</span><label class="collapse" for="c-41296760">[-]</label><label class="expand" for="c-41296760">[3 more]</label></div><br/><div class="children"><div class="content">Writing assembly was the idiomatic way of programming before Fortran and human-readable languages came.<p>Writing with goto was the idiomatic way before Algol and structural programming came.<p>Having only a handful of scalar types was the idiomatic way until structural data types came (and later objects).<p>Writing programs as fragments of text that get glued together somehow at build time was the idiomatic way until module systems came. (C and partly C++ continue to live in 1970s though.)<p>Callback hell was the idiomatic way to do async until Futures &#x2F; Promises and appropriate language support came.<p>Sometimes it&#x27;s time to move on. Writing idiomatic ES5 may feel fun for some, but it may not be the best way to reach high productivity and correctness of the result.</div><br/><div id="41297213" class="c"><input type="checkbox" id="c-41297213" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41296760">parent</a><span>|</span><a href="#41297089">next</a><span>|</span><label class="collapse" for="c-41297213">[-]</label><label class="expand" for="c-41297213">[2 more]</label></div><br/><div class="children"><div class="content">Making analogies like this doesn&#x27;t prove anything, they&#x27;re just suggestive. All I&#x27;m getting out of this is that you think for loops are old-fashioned.</div><br/><div id="41298133" class="c"><input type="checkbox" id="c-41298133" checked=""/><div class="controls bullet"><span class="by">Jean-Papoulos</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41297213">parent</a><span>|</span><a href="#41297089">next</a><span>|</span><label class="collapse" for="c-41298133">[-]</label><label class="expand" for="c-41298133">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because they are. Functional code is more readable. And if you look back, basically all advances in programming languages have been about &quot;making stuff more readable&quot;. Thus, for loops (for this usage) are &quot;old&quot;.</div><br/></div></div></div></div></div></div><div id="41297089" class="c"><input type="checkbox" id="c-41297089" checked=""/><div class="controls bullet"><span class="by">bobthepanda</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41296548">parent</a><span>|</span><a href="#41296760">prev</a><span>|</span><a href="#41297504">next</a><span>|</span><label class="collapse" for="c-41297089">[-]</label><label class="expand" for="c-41297089">[1 more]</label></div><br/><div class="children"><div class="content">I will say in 2024 i feel like for&#x2F;of or forEach would at least let you avoid the boilerplate of an index.</div><br/></div></div></div></div><div id="41297504" class="c"><input type="checkbox" id="c-41297504" checked=""/><div class="controls bullet"><span class="by">jamil7</span><span>|</span><a href="#41296172">parent</a><span>|</span><a href="#41296548">prev</a><span>|</span><a href="#41296513">next</a><span>|</span><label class="collapse" for="c-41297504">[-]</label><label class="expand" for="c-41297504">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve haven&#x27;t written JS in a long time – are engines like V8 smart enough to roll the filter and map into a single loop? Otherwise wouldn&#x27;t a reduce be more efficient there?</div><br/><div id="41297863" class="c"><input type="checkbox" id="c-41297863" checked=""/><div class="controls bullet"><span class="by">nevon</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41297504">parent</a><span>|</span><a href="#41296513">next</a><span>|</span><label class="collapse" for="c-41297863">[-]</label><label class="expand" for="c-41297863">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a matter of being smart enough. Since JavaScript is interpreted, the optimization happens at runtime. If the code is executed once and the number of items in the array is small, then it will take more time for the compiler to optimize the code than to naively execute it. Most code falls into this category.<p>As for whether or not it&#x27;s possible at all to combine a map and filter into a single loop I guess depends on whether the first operation can have side effects that affect the second operation or the collection that is being iterated over. I don&#x27;t know the answer, but I would be surprised if there wasn&#x27;t some hard to detect corner case that prohibits this kind of optimization.</div><br/></div></div></div></div><div id="41296513" class="c"><input type="checkbox" id="c-41296513" checked=""/><div class="controls bullet"><span class="by">p2501</span><span>|</span><a href="#41296172">parent</a><span>|</span><a href="#41297504">prev</a><span>|</span><a href="#41296555">next</a><span>|</span><label class="collapse" for="c-41296513">[-]</label><label class="expand" for="c-41296513">[13 more]</label></div><br/><div class="children"><div class="content">Aesthetic aside, I am under the impression that people start programming, by and large, with imperative for&#x2F;if style =&gt; so the imperative style is readable by more people. Even for more experienced programmers, reading imperative probably cost less energy, since it is more internalised?<p>Futhermore, in JS, the functionnal style is less performant (nearly twice on my machine, i assume because it do less useless memory allocations)<p>So, same functionnality, readable by more people, more performant? The imperative example seems like the better code.</div><br/><div id="41297136" class="c"><input type="checkbox" id="c-41297136" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41296513">parent</a><span>|</span><a href="#41296587">next</a><span>|</span><label class="collapse" for="c-41297136">[-]</label><label class="expand" for="c-41297136">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Even for more experienced programmers, reading imperative probably cost less energy, since it is more internalised?<p>I disagree. For-cycles are usually more difficult to reason about, because they&#x27;re more general and powerful. If I see &quot;for (...&quot;, I only know that the subsequent code will iterate, but the actual meaning has to be inferred from the content.<p>Meanwhile, a .map() or .filter() already give me hints - the lambda will transform the values (map), will filter values (filter), these hints make it easier to understand the logic because you already understand what the lambda is meant to do.<p>Other benefits stem from idiomatic usage of these constructs. It&#x27;s normal to mix different things into one for-cycle - e.g. filtering, transformation, adding to the resulting collection are all in the same block of code. In the functional approach, different &quot;stages&quot; of the processing are isolated into smaller chunks which are easier to reason about.<p>Another thing is that immutable data structures are quite natural with functional programming and they are a major simplification when thinking about the program state. A given variable has only one immutable state (in the current execution) as opposed to being changed 1000 times over the course of the for-loop.</div><br/></div></div><div id="41296587" class="c"><input type="checkbox" id="c-41296587" checked=""/><div class="controls bullet"><span class="by">joshka</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41296513">parent</a><span>|</span><a href="#41297136">prev</a><span>|</span><a href="#41296985">next</a><span>|</span><label class="collapse" for="c-41296587">[-]</label><label class="expand" for="c-41296587">[1 more]</label></div><br/><div class="children"><div class="content">I, a Datapoint of 1, find the functional style to generally express the ideas of what&#x27;s happening to be significantly easier to grok. Particularly if intermediate variables and conversion constructors are introduced rather than relying on full chains. E.g.:<p><pre><code>    function processUsers(users: User[]): FormattedUser[] {
      let adults = users.filter(user =&gt; user.age &gt;= 18);
      return adults.map(user =&gt; FormattedUser.new_adult(user));
    }
</code></pre>
On the performance tip, what scale are we talking? Is it relevant to the target system? Obviously the example is synthetic, so we can&#x27;t know that, but does it seem like this would have a runtime performance that is meaningful in some sort of reasonable use case?</div><br/></div></div><div id="41296985" class="c"><input type="checkbox" id="c-41296985" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41296513">parent</a><span>|</span><a href="#41296587">prev</a><span>|</span><a href="#41296555">next</a><span>|</span><label class="collapse" for="c-41296985">[-]</label><label class="expand" for="c-41296985">[10 more]</label></div><br/><div class="children"><div class="content">&gt; I am under the impression that people start programming, by and large, with imperative for&#x2F;if style =&gt; so the imperative style is readable by more people.<p>IMO, this is a simple consequence of technology moving faster than society. There are still instructors out there who learned to program in an environment where the go-to options for imperative programming were C and FORTRAN; the go-to options for other paradigms (if you&#x27;d even heard of other paradigms) were things like Lisp, Haskell and Smalltalk; and CPU speeds were measured in MHz on machines that you had to share with other people. Of course you&#x27;re going to get more experience with imperative programming; and familiarity breeds comprehension.<p>But really, I believe strongly that the functional style - properly factored - is far more intuitive. The mechanics of initializing some output collection to a default state (and, perhaps, the realization that zero isn&#x27;t a special case), keeping track of a position in an input collection, and repeatedly appending to an output, are just not that interesting. Sure, coming up with those steps could be a useful problem-solving exercise for brand-new programmers. But there are countless other options - and IMX, problem-solving is fiendishly hard to teach anyway. What ends up happening all the time is that you <i>think</i> you&#x27;ve taught a skill, but really the student has memorized a pattern and will slavishly attempt to apply it as much as possible going forward.<p>&gt; Futhermore, in JS, the functionnal style is less performant (nearly twice on my machine, i assume because it do less useless memory allocations)<p>Sure. Meanwhile in Python:<p><pre><code>    $ python -m timeit &quot;x = []&quot; &quot;for i in &#x27;example sequence&#x27;:&quot; &quot;  x.append(i)&quot;
    500000 loops, best of 5: 796 nsec per loop
    $ python -m timeit &quot;x = [i for i in &#x27;example sequence&#x27;]&quot;
    500000 loops, best of 5: 529 nsec per loop
</code></pre>
... But, of course:<p><pre><code>    $ python -m timeit &quot;x = list(&#x27;example sequence&#x27;)&quot;
    2000000 loops, best of 5: 198 nsec per loop
</code></pre>
Horses for courses.</div><br/><div id="41297123" class="c"><input type="checkbox" id="c-41297123" checked=""/><div class="controls bullet"><span class="by">vasco</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41296985">parent</a><span>|</span><a href="#41296555">next</a><span>|</span><label class="collapse" for="c-41297123">[-]</label><label class="expand" for="c-41297123">[9 more]</label></div><br/><div class="children"><div class="content">People think imperatively though. If I think of visiting my friend, grabbing gas on the way back, the way I&#x27;ll visualize the steps is not functional.</div><br/><div id="41298028" class="c"><input type="checkbox" id="c-41298028" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41297123">parent</a><span>|</span><a href="#41298057">next</a><span>|</span><label class="collapse" for="c-41298028">[-]</label><label class="expand" for="c-41298028">[1 more]</label></div><br/><div class="children"><div class="content">I disagree. People are sometimes just forced to think imperatively when dealing with computers, but I usually think declarative when I design my programs.<p>Say if I want to filter a sequence of users and omit users below the age of 18, I&#x27;ll construct my predicate (a &quot;what&quot;), and want to apply that predicate to create a new sequence of user (another &quot;what&quot;).<p>I really don&#x27;t want to tell a computer how to process a list every single time. I don&#x27;t care about creating an index first and checking the length of my list in order to keep track that I process each user in my list sequentially, and don&#x27;t forget that important &quot;i++&quot;. All I want at that moment is to think in streams, and this stream processing can happen in parallel just as well for all I care.<p>But I also do think Python, Haskell etc. are the most expressive here with list comprehensions. It can&#x27;t get more concise than this IMHO:<p><pre><code>  users_adult = [
    user
    for user in users
    if user.age &gt;= 18
  ]</code></pre></div><br/></div></div><div id="41298057" class="c"><input type="checkbox" id="c-41298057" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41297123">parent</a><span>|</span><a href="#41298028">prev</a><span>|</span><a href="#41297212">next</a><span>|</span><label class="collapse" for="c-41298057">[-]</label><label class="expand" for="c-41298057">[2 more]</label></div><br/><div class="children"><div class="content">While I think of things in a defined order, I also think in sets. If I grab a bunch of peanuts, I don&#x27;t visualize grabbing every single peanut one by one, I visualize getting a bunch at the same time.</div><br/><div id="41298079" class="c"><input type="checkbox" id="c-41298079" checked=""/><div class="controls bullet"><span class="by">vasco</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41298057">parent</a><span>|</span><a href="#41297212">next</a><span>|</span><label class="collapse" for="c-41298079">[-]</label><label class="expand" for="c-41298079">[1 more]</label></div><br/><div class="children"><div class="content">If you grab a bunch of peanuts you&#x27;re probably thinking in &quot;hand fulls&quot;, but the fact that the world and actions we take are fractal in the way we can analyze them doesn&#x27;t prove one or the other.</div><br/></div></div></div></div><div id="41297212" class="c"><input type="checkbox" id="c-41297212" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41297123">parent</a><span>|</span><a href="#41298057">prev</a><span>|</span><a href="#41296555">next</a><span>|</span><label class="collapse" for="c-41297212">[-]</label><label class="expand" for="c-41297212">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s quite debatable.<p>In this case, you first declare the end-goal - visit a friend and have full gas tank, with the actual steps to achieve them being much less important and often left to be defined at a later point (e.g. which particular gas station, which particular pump etc.). This corresponds more to functional thinking.<p>An imperative thinking would correspond more to &quot;I will sit in the car, start the engine, ride on highway, stop at address X, converse with Y, leave 2 hours later, stop at gas station X&quot; - in this case the imperative steps are the dominant pattern while the actual intent (visit a friend) is only implicit.</div><br/><div id="41297304" class="c"><input type="checkbox" id="c-41297304" checked=""/><div class="controls bullet"><span class="by">vasco</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41297212">parent</a><span>|</span><a href="#41296555">next</a><span>|</span><label class="collapse" for="c-41297304">[-]</label><label class="expand" for="c-41297304">[4 more]</label></div><br/><div class="children"><div class="content">Your second part is how I think and how I think most people think. That&#x27;s exactly what I meant.</div><br/><div id="41297487" class="c"><input type="checkbox" id="c-41297487" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41297304">parent</a><span>|</span><a href="#41297521">next</a><span>|</span><label class="collapse" for="c-41297487">[-]</label><label class="expand" for="c-41297487">[2 more]</label></div><br/><div class="children"><div class="content">So when you arrange the visit with your friend two weeks in advance, you first think about sitting in the car, driving out of the garage, getting on the highway, turning on the radio, parking the car, ringing the bell and this other myriad of actions, and the actual talking with the friend is just one of the actions, with no prominence over the others?<p>I certainly don&#x27;t think like that. My main goal is to visit a friend. The transportation is subordinate, it&#x27;s only a mean to the goal, an implementation detail which I don&#x27;t care about much. I might even take a train instead of driving the car, or even ride a bike, if I feel like it and the weather is nice on the day of the visit.<p>Now reflecting on this, I think such focus on the process (as opposed to focus on the goal), exact imperative order, not being able to alter the plan even if the change is meaningless in relation to the goal, is a sign of autism. But I don&#x27;t believe most people think like that.</div><br/><div id="41297988" class="c"><input type="checkbox" id="c-41297988" checked=""/><div class="controls bullet"><span class="by">vasco</span><span>|</span><a href="#41296172">root</a><span>|</span><a href="#41297487">parent</a><span>|</span><a href="#41297521">next</a><span>|</span><label class="collapse" for="c-41297988">[-]</label><label class="expand" for="c-41297988">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re the one that added all those conditions about exactness, about needing to replay every step (even this is a problem because steps are fractal), or not being able to change the plan. I can think imperatively and still do those :)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41296555" class="c"><input type="checkbox" id="c-41296555" checked=""/><div class="controls bullet"><span class="by">diatone</span><span>|</span><a href="#41296172">parent</a><span>|</span><a href="#41296513">prev</a><span>|</span><a href="#41296249">next</a><span>|</span><label class="collapse" for="c-41296555">[-]</label><label class="expand" for="c-41296555">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find it impossible to believe that some prefer the imperative loop&#x2F;conditional nesting approach.<p>Yeah, there’s your problem. This is in fact possible!</div><br/></div></div><div id="41296249" class="c"><input type="checkbox" id="c-41296249" checked=""/><div class="controls bullet"><span class="by">happytoexplain</span><span>|</span><a href="#41296172">parent</a><span>|</span><a href="#41296555">prev</a><span>|</span><a href="#41298114">next</a><span>|</span><label class="collapse" for="c-41296249">[-]</label><label class="expand" for="c-41296249">[1 more]</label></div><br/><div class="children"><div class="content">Are you saying you find it hard to believe that some prefer the first &quot;Before&quot; example over the first &quot;Bad refactor&quot; example?</div><br/></div></div></div></div><div id="41298114" class="c"><input type="checkbox" id="c-41298114" checked=""/><div class="controls bullet"><span class="by">Jean-Papoulos</span><span>|</span><a href="#41296172">prev</a><span>|</span><a href="#41297974">next</a><span>|</span><label class="collapse" for="c-41298114">[-]</label><label class="expand" for="c-41298114">[1 more]</label></div><br/><div class="children"><div class="content">I feel this article is honestly disingenuous. One of the &quot;common pitfalls of refactoring&quot; mentioned is &quot;Not understanding the code before refactoring&quot;. Well yeah ? The same would apply to doing anything with the code. The following one is &quot;Understand the business context&quot; (note that the author has already departed from the pattern of listing &quot;common pitfalls&quot; to just write whatever he feels like. Or he just published his first draft).<p>Not a very qualitative article.</div><br/></div></div><div id="41297974" class="c"><input type="checkbox" id="c-41297974" checked=""/><div class="controls bullet"><span class="by">azangru</span><span>|</span><a href="#41298114">prev</a><span>|</span><a href="#41297313">next</a><span>|</span><label class="collapse" for="c-41297974">[-]</label><label class="expand" for="c-41297974">[2 more]</label></div><br/><div class="children"><div class="content">The first example of a good refactor is a meh refactor at best, and possibly a bad refactor. Array methods such as map or filter are not &quot;more conventional&quot; in javascript; they are &quot;as conventional&quot; as for-loops, and arguably less &quot;conventional&quot;, given how for-loops have been around since the introduction of the language. They are also inevitably more expensive than for-loops (every cycle creates an anonymous function; a map followed by a filter means another iteration of the array). The original example was fine; there was no need to &quot;refactor&quot; it.</div><br/><div id="41298089" class="c"><input type="checkbox" id="c-41298089" checked=""/><div class="controls bullet"><span class="by">knallfrosch</span><span>|</span><a href="#41297974">parent</a><span>|</span><a href="#41297313">next</a><span>|</span><label class="collapse" for="c-41298089">[-]</label><label class="expand" for="c-41298089">[1 more]</label></div><br/><div class="children"><div class="content">Disagree on this. filter and map are much more readable and especially extensible than result-arrays. Plus it eliminates out-of-bonds indexing.<p>See the variable name. It&#x27;s forced to be &#x27;result&#x27; so that it&#x27;s consistent with the result-array style. Therefore it lacks a descriptive name.<p>For the functional methods, you can easily assign the filter(age &gt; 18) result to an intermediate variable like adultUsers to make the code even more descriptive. Useful when you have more steps. With the result-array approach, you&#x27;d have to repeat the looping code or bury the description deep in the loop itself and so you usually avoid that.</div><br/></div></div></div></div><div id="41297313" class="c"><input type="checkbox" id="c-41297313" checked=""/><div class="controls bullet"><span class="by">piotrkaminski</span><span>|</span><a href="#41297974">prev</a><span>|</span><a href="#41296850">next</a><span>|</span><label class="collapse" for="c-41297313">[-]</label><label class="expand" for="c-41297313">[1 more]</label></div><br/><div class="children"><div class="content">What I get out of this is that even for teams that prioritize trust and velocity and eschew the use of pre-commit code reviews, there&#x27;s a strong argument to be made for putting all new hires on an approval-required list for the first few months!</div><br/></div></div><div id="41296850" class="c"><input type="checkbox" id="c-41296850" checked=""/><div class="controls bullet"><span class="by">nailer</span><span>|</span><a href="#41297313">prev</a><span>|</span><label class="collapse" for="c-41296850">[-]</label><label class="expand" for="c-41296850">[2 more]</label></div><br/><div class="children"><div class="content">Oh god the ‘object oriented’ refactor. I wish everyone who had OO thrust upon them in the early 2000s received some explicit communication that what they were taught is essentially a hoax and bears no resemblance to Alan Kay’s original intention</div><br/><div id="41297759" class="c"><input type="checkbox" id="c-41297759" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#41296850">parent</a><span>|</span><label class="collapse" for="c-41297759">[-]</label><label class="expand" for="c-41297759">[1 more]</label></div><br/><div class="children"><div class="content">Some of that is on Alan Kay because it took him twenty years to realize people couldn&#x27;t read his mind on the proper definition of &quot;object oriented.&quot;</div><br/></div></div></div></div></div></div></div></div></div></body></html>