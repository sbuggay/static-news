<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688806856383" as="style"/><link rel="stylesheet" href="styles.css?v=1688806856383"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fastapi.tiangolo.com/release-notes/">FastAPI 0.100.0 release notes</a> <span class="domain">(<a href="https://fastapi.tiangolo.com">fastapi.tiangolo.com</a>)</span></div><div class="subtext"><span>constantinum</span> | <span>76 comments</span></div><br/><div><div id="36642633" class="c"><input type="checkbox" id="c-36642633" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36638482">next</a><span>|</span><label class="collapse" for="c-36642633">[-]</label><label class="expand" for="c-36642633">[1 more]</label></div><br/><div class="children"><div class="content">Over 14 years or so I’ve developed with flask, bottle, Falcon, FastAPI, Django, Sanic and Starlette.<p>My preferred back end web server is now nodejs with typescript and plain old Postgres SQL queries, no ORM. Caddy web server with auth sub requests.</div><br/></div></div><div id="36638482" class="c"><input type="checkbox" id="c-36638482" checked=""/><div class="controls bullet"><span class="by">TheRealPomax</span><span>|</span><a href="#36642633">prev</a><span>|</span><a href="#36640556">next</a><span>|</span><label class="collapse" for="c-36638482">[-]</label><label class="expand" for="c-36638482">[25 more]</label></div><br/><div class="children"><div class="content">&gt; FastAPI is already being used in production in many applications and systems. And the test coverage is kept at 100%. But its development is still moving quickly. New features are added frequently, bugs are fixed regularly, and the code is still continuously improving. That&#x27;s why the current versions are still 0.x.x, this reflects that each version could potentially have breaking changes.[1]<p>What kind of weird reasoning is this? This should be why you use actual semver, and you use the major version to indicate backward compatibility breaking changes, minor versions for new features, and patch versions for bug fixes that don&#x27;t actually actually change the public API surface.<p>If you don&#x27;t want to use semver, just don&#x27;t use semver.<p>[1] <a href="https:&#x2F;&#x2F;fastapi.tiangolo.com&#x2F;deployment&#x2F;versions&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;fastapi.tiangolo.com&#x2F;deployment&#x2F;versions&#x2F;</a></div><br/><div id="36638536" class="c"><input type="checkbox" id="c-36638536" checked=""/><div class="controls bullet"><span class="by">senko</span><span>|</span><a href="#36638482">parent</a><span>|</span><a href="#36639310">next</a><span>|</span><label class="collapse" for="c-36638536">[-]</label><label class="expand" for="c-36638536">[6 more]</label></div><br/><div class="children"><div class="content">This <i>is</i> semver:<p>&gt; Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The public API SHOULD NOT be considered stable.<p>(from <a href="https:&#x2F;&#x2F;semver.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;semver.org&#x2F;</a>)</div><br/><div id="36638748" class="c"><input type="checkbox" id="c-36638748" checked=""/><div class="controls bullet"><span class="by">foob</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36638536">parent</a><span>|</span><a href="#36641499">next</a><span>|</span><label class="collapse" for="c-36638748">[-]</label><label class="expand" for="c-36638748">[2 more]</label></div><br/><div class="children"><div class="content">Sure, depending on how you interpret <i>initial development</i>. FastAPI has 60k stars on GitHub, has been extremely popular for at least four years, and is widely used in production by a lot of people. It&#x27;s the maintainers&#x27; decision what their goals are for a v1 release, but I was personally surprised to learn that it hasn&#x27;t had one yet. I can see why one might argue that they&#x27;re not following the spirit of semver at this point.</div><br/><div id="36639384" class="c"><input type="checkbox" id="c-36639384" checked=""/><div class="controls bullet"><span class="by">capableweb</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36638748">parent</a><span>|</span><a href="#36641499">next</a><span>|</span><label class="collapse" for="c-36639384">[-]</label><label class="expand" for="c-36639384">[1 more]</label></div><br/><div class="children"><div class="content">As long as the developers&#x2F;maintainers feel like &quot;Anything MAY change at any time&quot; and &quot;The public API SHOULD NOT be considered stable&quot; is true, both the &quot;spirit&quot; and specification (if we may call it so) say it should be on 0.x.z</div><br/></div></div></div></div><div id="36641499" class="c"><input type="checkbox" id="c-36641499" checked=""/><div class="controls bullet"><span class="by">TheRealPomax</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36638536">parent</a><span>|</span><a href="#36638748">prev</a><span>|</span><a href="#36641885">next</a><span>|</span><label class="collapse" for="c-36641499">[-]</label><label class="expand" for="c-36641499">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, doesn&#x27;t stroke well with &quot;FastAPI is already being used in production in many applications and systems. And the test coverage is kept at 100%. But its development is still moving quickly.&quot; now does it?<p>It doesn&#x27;t matter how quickly you move, you can apply real semver numbering just fine. Five years and a 0 dot one hundred is obeying the letter of the law while being utterly ridiculous.</div><br/></div></div><div id="36641885" class="c"><input type="checkbox" id="c-36641885" checked=""/><div class="controls bullet"><span class="by">Zababa</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36638536">parent</a><span>|</span><a href="#36641499">prev</a><span>|</span><a href="#36641091">next</a><span>|</span><label class="collapse" for="c-36641885">[-]</label><label class="expand" for="c-36641885">[1 more]</label></div><br/><div class="children"><div class="content">From the same link:<p>&gt; How do I know when to release 1.0.0?<p>&gt; If your software is being used in production, it should probably already be 1.0.0. If you have a stable API on which users have come to depend, you should be 1.0.0. If you’re worrying a lot about backward compatibility, you should probably already be 1.0.0.</div><br/></div></div><div id="36641091" class="c"><input type="checkbox" id="c-36641091" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36638536">parent</a><span>|</span><a href="#36641885">prev</a><span>|</span><a href="#36639310">next</a><span>|</span><label class="collapse" for="c-36641091">[-]</label><label class="expand" for="c-36641091">[1 more]</label></div><br/><div class="children"><div class="content">The point is that it shows the maintainers have a severe lack of judgement</div><br/></div></div></div></div><div id="36639310" class="c"><input type="checkbox" id="c-36639310" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#36638482">parent</a><span>|</span><a href="#36638536">prev</a><span>|</span><a href="#36638497">next</a><span>|</span><label class="collapse" for="c-36639310">[-]</label><label class="expand" for="c-36639310">[4 more]</label></div><br/><div class="children"><div class="content">FastAPI doesn&#x27;t use Semver; it uses ZeroVer: <a href="https:&#x2F;&#x2F;0ver.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;0ver.org&#x2F;</a></div><br/><div id="36641471" class="c"><input type="checkbox" id="c-36641471" checked=""/><div class="controls bullet"><span class="by">TheRealPomax</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36639310">parent</a><span>|</span><a href="#36638497">next</a><span>|</span><label class="collapse" for="c-36641471">[-]</label><label class="expand" for="c-36641471">[3 more]</label></div><br/><div class="children"><div class="content">No, they don&#x27;t. They literally link out to semver.org</div><br/><div id="36641485" class="c"><input type="checkbox" id="c-36641485" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36641471">parent</a><span>|</span><a href="#36642251">next</a><span>|</span><label class="collapse" for="c-36641485">[-]</label><label class="expand" for="c-36641485">[1 more]</label></div><br/><div class="children"><div class="content">Zerover is satire.</div><br/></div></div><div id="36642251" class="c"><input type="checkbox" id="c-36642251" checked=""/><div class="controls bullet"><span class="by">_Algernon_</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36641471">parent</a><span>|</span><a href="#36641485">prev</a><span>|</span><a href="#36638497">next</a><span>|</span><label class="collapse" for="c-36642251">[-]</label><label class="expand" for="c-36642251">[1 more]</label></div><br/><div class="children"><div class="content">The joke<p>.<p>.<p>.<p>Your head</div><br/></div></div></div></div></div></div><div id="36638497" class="c"><input type="checkbox" id="c-36638497" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36638482">parent</a><span>|</span><a href="#36639310">prev</a><span>|</span><a href="#36640262">next</a><span>|</span><label class="collapse" for="c-36638497">[-]</label><label class="expand" for="c-36638497">[2 more]</label></div><br/><div class="children"><div class="content">Semver specifically allows you to use 0.x for this purpose: <a href="https:&#x2F;&#x2F;semver.org&#x2F;#spec-item-4" rel="nofollow noreferrer">https:&#x2F;&#x2F;semver.org&#x2F;#spec-item-4</a><p>&gt; Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The public API SHOULD NOT be considered stable.<p>That said, I&#x27;d argue that this <i>is</i> a little silly. Maybe a better design is to use something I am calling &quot;zero-calver&quot;: 0.YYYY.MM.DD. Then use semantic versioning once stability is reached.</div><br/><div id="36640315" class="c"><input type="checkbox" id="c-36640315" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36638497">parent</a><span>|</span><a href="#36640262">next</a><span>|</span><label class="collapse" for="c-36640315">[-]</label><label class="expand" for="c-36640315">[1 more]</label></div><br/><div class="children"><div class="content">Just use semver from the moment it is usable by a third party.<p>Then maybe it goes up to 41.x.x until stability is reached. So what? It&#x27;s not less professional than keeping 0.x.x forever.</div><br/></div></div></div></div><div id="36640262" class="c"><input type="checkbox" id="c-36640262" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#36638482">parent</a><span>|</span><a href="#36638497">prev</a><span>|</span><a href="#36642329">next</a><span>|</span><label class="collapse" for="c-36640262">[-]</label><label class="expand" for="c-36640262">[2 more]</label></div><br/><div class="children"><div class="content">Because it seems like devs believe that 1.0.0 means &quot;the API is perfect, it won&#x27;t break ever again&quot;.<p>Somehow they feel like having a version 15.2.3 looks unprofessional (because the API got broken 14 times), but 0.100.0 is perfectly fine.<p>I just don&#x27;t get it.</div><br/><div id="36641479" class="c"><input type="checkbox" id="c-36641479" checked=""/><div class="controls bullet"><span class="by">aliasxneo</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36640262">parent</a><span>|</span><a href="#36642329">next</a><span>|</span><label class="collapse" for="c-36641479">[-]</label><label class="expand" for="c-36641479">[1 more]</label></div><br/><div class="children"><div class="content">Just had this conversation the other day. It&#x27;s become so unusual to see high major versions that it&#x27;s basically become taboo.</div><br/></div></div></div></div><div id="36642329" class="c"><input type="checkbox" id="c-36642329" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#36638482">parent</a><span>|</span><a href="#36640262">prev</a><span>|</span><a href="#36639137">next</a><span>|</span><label class="collapse" for="c-36642329">[-]</label><label class="expand" for="c-36642329">[1 more]</label></div><br/><div class="children"><div class="content">Using semver doesn&#x27;t magically make it okay to make breaking changes constantly. It&#x27;s still a pain for anyone using your library.<p>Semver explicitly encourages you to use major version 0 during early development for this exact reason, it&#x27;s up to the maintainers to decide when they can be more stable.</div><br/></div></div><div id="36639137" class="c"><input type="checkbox" id="c-36639137" checked=""/><div class="controls bullet"><span class="by">foolswisdom</span><span>|</span><a href="#36638482">parent</a><span>|</span><a href="#36642329">prev</a><span>|</span><a href="#36640261">next</a><span>|</span><label class="collapse" for="c-36639137">[-]</label><label class="expand" for="c-36639137">[3 more]</label></div><br/><div class="children"><div class="content">FWIW other frameworks (namely, flask) took a similar approach of not moving to 1.0 for a while.</div><br/><div id="36640300" class="c"><input type="checkbox" id="c-36640300" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36639137">parent</a><span>|</span><a href="#36640261">next</a><span>|</span><label class="collapse" for="c-36640300">[-]</label><label class="expand" for="c-36640300">[2 more]</label></div><br/><div class="children"><div class="content">Which sucks, to be honest. Just accept that your major can go up to 23.8.3, and it does not make it less professional than 0.231.0. Actually it&#x27;s better because it said which releases broke backward compatibility and which ones did not.</div><br/><div id="36641639" class="c"><input type="checkbox" id="c-36641639" checked=""/><div class="controls bullet"><span class="by">norgie</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36640300">parent</a><span>|</span><a href="#36640261">next</a><span>|</span><label class="collapse" for="c-36641639">[-]</label><label class="expand" for="c-36641639">[1 more]</label></div><br/><div class="children"><div class="content">Seriously, this 0ver nonsense makes it so much harder to deal with upgrading packages. Who cares you bump the major version frequently</div><br/></div></div></div></div></div></div><div id="36640261" class="c"><input type="checkbox" id="c-36640261" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36638482">parent</a><span>|</span><a href="#36639137">prev</a><span>|</span><a href="#36638756">next</a><span>|</span><label class="collapse" for="c-36640261">[-]</label><label class="expand" for="c-36640261">[3 more]</label></div><br/><div class="children"><div class="content">This <i>is using semver</i> in the exact way it’s intended but with predictably silly outcomes. For several years now I’ve been of the opinion that this particular aspect of semver is … very bad actually.<p>For personal projects I skip any zero major prefixes. In their place, I use alpha&#x2F;beta suffixes and version Major&#x2F;minor&#x2F;patch from an initial 1.0 alpha. Hasn’t caused any problems for me.</div><br/><div id="36640280" class="c"><input type="checkbox" id="c-36640280" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36640261">parent</a><span>|</span><a href="#36638756">next</a><span>|</span><label class="collapse" for="c-36640280">[-]</label><label class="expand" for="c-36640280">[2 more]</label></div><br/><div class="children"><div class="content">And to clarify the approach, the equivalent version would be 1.0.0-alpha.100.0. Clear in its meaning, clear in versioning resolution, ambiguous only in its maturity but that’s what the project is trying to do.<p>Edit: or probably it’s 1.0.0-beta.100.0. That’s still much clearer</div><br/><div id="36641480" class="c"><input type="checkbox" id="c-36641480" checked=""/><div class="controls bullet"><span class="by">TheRealPomax</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36640280">parent</a><span>|</span><a href="#36638756">next</a><span>|</span><label class="collapse" for="c-36641480">[-]</label><label class="expand" for="c-36641480">[1 more]</label></div><br/><div class="children"><div class="content">Not if they&#x27;ve dropped support for several versions of Python over the years, no. More like v5.10.12<p>This software is absolutely not in alpha anymore, it&#x27;s used in production and the project even acknowledges this explicitly.</div><br/></div></div></div></div></div></div><div id="36640192" class="c"><input type="checkbox" id="c-36640192" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36638482">parent</a><span>|</span><a href="#36638756">prev</a><span>|</span><a href="#36640556">next</a><span>|</span><label class="collapse" for="c-36640192">[-]</label><label class="expand" for="c-36640192">[2 more]</label></div><br/><div class="children"><div class="content">I prefer straight integer version numbers.<p>It&#x27;s a tendency of developers to make things complex.</div><br/><div id="36640284" class="c"><input type="checkbox" id="c-36640284" checked=""/><div class="controls bullet"><span class="by">palata</span><span>|</span><a href="#36638482">root</a><span>|</span><a href="#36640192">parent</a><span>|</span><a href="#36640556">next</a><span>|</span><label class="collapse" for="c-36640284">[-]</label><label class="expand" for="c-36640284">[1 more]</label></div><br/><div class="children"><div class="content">Actually, semver would make sense if people used it correctly.<p>Changing the major means that it breaks backward compatibility. Changing the minor means that it has new features. Changing the patch means that it had bugfixes.<p>That&#x27;s useful for libraries. Of course it&#x27;s a bit less useful for executables. I just increase the major for executables, but if I need to backport a feature or a fix (to somebody who still uses an older version), then I use the minor&#x2F;patch.</div><br/></div></div></div></div></div></div><div id="36640556" class="c"><input type="checkbox" id="c-36640556" checked=""/><div class="controls bullet"><span class="by">v3ss0n</span><span>|</span><a href="#36638482">prev</a><span>|</span><a href="#36638163">next</a><span>|</span><label class="collapse" for="c-36640556">[-]</label><label class="expand" for="c-36640556">[7 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;litestar.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;litestar.dev</a> is also reaching 2.0 .it is a lot faster than FastAPI yet much better maintained. Has DTO, event and channels, Repository, Service DDD style framework built-in. No promotional commits. 
I had written the reason of moving away from FastApi here and intro to Litestar 2.0.<p><a href="https:&#x2F;&#x2F;dev.to&#x2F;v3ss0n&#x2F;litestar-20-beta-speed-of-light-power-of-stars-1j62" rel="nofollow noreferrer">https:&#x2F;&#x2F;dev.to&#x2F;v3ss0n&#x2F;litestar-20-beta-speed-of-light-power-...</a></div><br/><div id="36640780" class="c"><input type="checkbox" id="c-36640780" checked=""/><div class="controls bullet"><span class="by">lyu07282</span><span>|</span><a href="#36640556">parent</a><span>|</span><a href="#36641067">next</a><span>|</span><label class="collapse" for="c-36640780">[-]</label><label class="expand" for="c-36640780">[2 more]</label></div><br/><div class="children"><div class="content">I think you raised some valid concerns there, I see 18 open issues in the fastapi repo, what&#x27;s going on there? Are they just moving everything into a discussion? A bit concerning</div><br/><div id="36641306" class="c"><input type="checkbox" id="c-36641306" checked=""/><div class="controls bullet"><span class="by">v3ss0n</span><span>|</span><a href="#36640556">root</a><span>|</span><a href="#36640780">parent</a><span>|</span><a href="#36641067">next</a><span>|</span><label class="collapse" for="c-36641306">[-]</label><label class="expand" for="c-36641306">[1 more]</label></div><br/><div class="children"><div class="content">There are thousands of issues which about 30% of them are actual bugs, including some of them are those we found on production and reported, the maintainer wrote a script that convert all to discussion and never looked back, so we never look back too.</div><br/></div></div></div></div><div id="36641067" class="c"><input type="checkbox" id="c-36641067" checked=""/><div class="controls bullet"><span class="by">holler</span><span>|</span><a href="#36640556">parent</a><span>|</span><a href="#36640780">prev</a><span>|</span><a href="#36640752">next</a><span>|</span><label class="collapse" for="c-36641067">[-]</label><label class="expand" for="c-36641067">[2 more]</label></div><br/><div class="children"><div class="content">How does it compare to Starlette? (lib FastAPI uses under the hood) I&#x27;ve used vanilla Starlette for recent projects and it&#x27;s been great.</div><br/><div id="36641298" class="c"><input type="checkbox" id="c-36641298" checked=""/><div class="controls bullet"><span class="by">v3ss0n</span><span>|</span><a href="#36640556">root</a><span>|</span><a href="#36641067">parent</a><span>|</span><a href="#36640752">next</a><span>|</span><label class="collapse" for="c-36641298">[-]</label><label class="expand" for="c-36641298">[1 more]</label></div><br/><div class="children"><div class="content">It was based on starlette first but all functionalities are rewritten ending up in better code quality.  <a href="https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;litestar-org&#x2F;discussions&#x2F;612">https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;litestar-org&#x2F;discussions&#x2F;612</a><p>Starlette can be considered pure server framework in the lines of CherryPy, wezurg in wsgi&#x2F;sync world.<p>Litestar is a lot more battery included with built-in integration to Sqalchemy, many other ORMs as plugin. Built-in security and authentication middleware.<p>Join our discord, we have good community there too .</div><br/></div></div></div></div><div id="36640752" class="c"><input type="checkbox" id="c-36640752" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36640556">parent</a><span>|</span><a href="#36641067">prev</a><span>|</span><a href="#36638163">next</a><span>|</span><label class="collapse" for="c-36640752">[-]</label><label class="expand" for="c-36640752">[2 more]</label></div><br/><div class="children"><div class="content">Nice, thanks. I wonder how performance compares to django-ninja.</div><br/><div id="36641314" class="c"><input type="checkbox" id="c-36641314" checked=""/><div class="controls bullet"><span class="by">v3ss0n</span><span>|</span><a href="#36640556">root</a><span>|</span><a href="#36640752">parent</a><span>|</span><a href="#36638163">next</a><span>|</span><label class="collapse" for="c-36641314">[-]</label><label class="expand" for="c-36641314">[1 more]</label></div><br/><div class="children"><div class="content">We haven&#x27;t test Django ninja in term of performance.
But from our experience of Django 4.2 async , Django isn&#x27;t truly asynchronous yet. Since ecosystem is not asynchronous I am not sure how asynchronous API would benefit from that when the extension aren&#x27;t.</div><br/></div></div></div></div></div></div><div id="36638163" class="c"><input type="checkbox" id="c-36638163" checked=""/><div class="controls bullet"><span class="by">krat0sprakhar</span><span>|</span><a href="#36640556">prev</a><span>|</span><a href="#36642036">next</a><span>|</span><label class="collapse" for="c-36638163">[-]</label><label class="expand" for="c-36638163">[16 more]</label></div><br/><div class="children"><div class="content">&gt; In some cases, for pure data validation and processing, you can get performance improvements of 20x or more. This means 2,000% or more.<p>Amazing! Excited to try it out.<p>Slightly OT: But what are some use-cases where you&#x27;d still use Flask over FastAPI? I really like FastAPI&#x27;s devEx and don&#x27;t see myself going back to Flask anytime soon. Curious to hear what others think.</div><br/><div id="36638583" class="c"><input type="checkbox" id="c-36638583" checked=""/><div class="controls bullet"><span class="by">gsa</span><span>|</span><a href="#36638163">parent</a><span>|</span><a href="#36639943">next</a><span>|</span><label class="collapse" for="c-36638583">[-]</label><label class="expand" for="c-36638583">[3 more]</label></div><br/><div class="children"><div class="content">Flask has been around much longer than FastAPI and, as a result, is a much more mature framework. Some examples:<p>- There&#x27;s a memory leak with a particular combination of packages FastAPI [0]<p>- Before Pydantic v2, you would validate your data on input (when it&#x27;s stored in the db) and then every single time on retrieval. There is no way to skip validation, for example, when you are generating a response on data that was already validated when it was persisted to the db. [1]<p>- FastAPI has documentation only in the form of tutorials. There is no API documentation and if something is not clear looking through the source code is the only option<p>- You need ORJSON for maximum serialisation performance (perhaps this has changed with Pydantic v2) [2]<p>- Using FastAPI with uvicorn doesn&#x27;t respect log format settings [3]<p>I don&#x27;t mean to imply that FastAPI is a bad framework. The Flask ecosystem has had over a decade to mature. FastAPI and the ecosystem will get there but it _needs_ time.<p>- [0] <a href="https:&#x2F;&#x2F;github.com&#x2F;tiangolo&#x2F;fastapi&#x2F;discussions&#x2F;9082">https:&#x2F;&#x2F;github.com&#x2F;tiangolo&#x2F;fastapi&#x2F;discussions&#x2F;9082</a><p>- [1] <a href="https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;pydantic&#x2F;issues&#x2F;1212">https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;pydantic&#x2F;issues&#x2F;1212</a><p>- [2] <a href="https:&#x2F;&#x2F;fastapi.tiangolo.com&#x2F;advanced&#x2F;custom-response&#x2F;#use-orjsonresponse" rel="nofollow noreferrer">https:&#x2F;&#x2F;fastapi.tiangolo.com&#x2F;advanced&#x2F;custom-response&#x2F;#use-o...</a><p>- [3] <a href="https:&#x2F;&#x2F;github.com&#x2F;encode&#x2F;uvicorn&#x2F;issues&#x2F;527">https:&#x2F;&#x2F;github.com&#x2F;encode&#x2F;uvicorn&#x2F;issues&#x2F;527</a></div><br/><div id="36642150" class="c"><input type="checkbox" id="c-36642150" checked=""/><div class="controls bullet"><span class="by">arun-mani-j</span><span>|</span><a href="#36638163">root</a><span>|</span><a href="#36638583">parent</a><span>|</span><a href="#36638774">next</a><span>|</span><label class="collapse" for="c-36642150">[-]</label><label class="expand" for="c-36642150">[1 more]</label></div><br/><div class="children"><div class="content">Exactly my issue too. Why there is no API documentation for FastAPI? It is very difficult to know what is available and what is not beyond the tutorial style docs.<p>(I love FastAPI and use it for all my projects, this one little thing troubles me sometimes)</div><br/></div></div><div id="36638774" class="c"><input type="checkbox" id="c-36638774" checked=""/><div class="controls bullet"><span class="by">minimaxir</span><span>|</span><a href="#36638163">root</a><span>|</span><a href="#36638583">parent</a><span>|</span><a href="#36642150">prev</a><span>|</span><a href="#36639943">next</a><span>|</span><label class="collapse" for="c-36638774">[-]</label><label class="expand" for="c-36638774">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - You need ORJSON for maximum serialisation performance (perhaps this has changed with Pydantic v2) [2]<p>The common orjson trick no longer works in v2 and will throw warnings, but it appears it&#x27;s no longer necessary since the JSON formatting leverages the native seralizer which happens in Rust-land.</div><br/></div></div></div></div><div id="36639943" class="c"><input type="checkbox" id="c-36639943" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#36638163">parent</a><span>|</span><a href="#36638583">prev</a><span>|</span><a href="#36638295">next</a><span>|</span><label class="collapse" for="c-36639943">[-]</label><label class="expand" for="c-36639943">[2 more]</label></div><br/><div class="children"><div class="content">Well the performance increase is so huge because pydantic1 is really really slow. And for using rust, I&#x27;d have expected more tbh…<p>I&#x27;ve been benchmarking pydantic v2 against typedload (which I write) and despite the rust, it still manages to be slower than pure python in some benchmarks.<p>The ones on the website are still about comparing to v1 because v2 was not out yet at the time of the last release.<p>pydantic&#x27;s author will refuse to benchmark any library that is faster (<a href="https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;pydantic&#x2F;pull&#x2F;3264">https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;pydantic&#x2F;pull&#x2F;3264</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;pydantic&#x2F;pull&#x2F;1525">https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;pydantic&#x2F;pull&#x2F;1525</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;pydantic&#x2F;pull&#x2F;1810">https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;pydantic&#x2F;pull&#x2F;1810</a>) and keep boasting about amazing performances.<p>On pypy, v2 beta was really really really slow.</div><br/><div id="36640126" class="c"><input type="checkbox" id="c-36640126" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#36638163">root</a><span>|</span><a href="#36639943">parent</a><span>|</span><a href="#36638295">next</a><span>|</span><label class="collapse" for="c-36640126">[-]</label><label class="expand" for="c-36640126">[1 more]</label></div><br/><div class="children"><div class="content">Well that is a bad look. I am sure the highlighted performance metrics have had a lingering impact on library decisions.</div><br/></div></div></div></div><div id="36638295" class="c"><input type="checkbox" id="c-36638295" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#36638163">parent</a><span>|</span><a href="#36639943">prev</a><span>|</span><a href="#36638527">next</a><span>|</span><label class="collapse" for="c-36638295">[-]</label><label class="expand" for="c-36638295">[2 more]</label></div><br/><div class="children"><div class="content">Is it still a bus factor of one? I veer to the side of boring technology and FastAPI is still too in flux for me. I do not ever want to be the vanguard discovering novel problems with my framework.</div><br/><div id="36638394" class="c"><input type="checkbox" id="c-36638394" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36638163">root</a><span>|</span><a href="#36638295">parent</a><span>|</span><a href="#36638527">next</a><span>|</span><label class="collapse" for="c-36638394">[-]</label><label class="expand" for="c-36638394">[1 more]</label></div><br/><div class="children"><div class="content">Definitely this. Flask is old and well-tested, with a solid feature set and little need to change how it works.<p>Also you&#x27;d use Flask for basically anything that isn&#x27;t an &quot;API&quot;, but where you still want something lighter-weight than Django. I believe other traditional Python web frameworks like Pyramid fall into the same category.<p>The &quot;Fast&quot; in FastAPI refers to the speed of getting a working prototype running, specifically for an API that accepts and emits JSON and implements an OpenAPI schema. If that&#x27;s not your use case, then you might not need or want FastAPI.</div><br/></div></div></div></div><div id="36638527" class="c"><input type="checkbox" id="c-36638527" checked=""/><div class="controls bullet"><span class="by">WhatsName</span><span>|</span><a href="#36638163">parent</a><span>|</span><a href="#36638295">prev</a><span>|</span><a href="#36638514">next</a><span>|</span><label class="collapse" for="c-36638527">[-]</label><label class="expand" for="c-36638527">[1 more]</label></div><br/><div class="children"><div class="content">Coming from django primarily, but written some flask code. I would say the ecosystem. As of my last try, adding authentication (via cookies) to a fastapi project was somewhat cumbersome.<p>Usually as the projects grow, and I start reinventing the wheel, I come to regret not going for a &quot;full&quot; framework.</div><br/></div></div><div id="36638514" class="c"><input type="checkbox" id="c-36638514" checked=""/><div class="controls bullet"><span class="by">aardshark</span><span>|</span><a href="#36638163">parent</a><span>|</span><a href="#36638527">prev</a><span>|</span><a href="#36642439">next</a><span>|</span><label class="collapse" for="c-36638514">[-]</label><label class="expand" for="c-36638514">[6 more]</label></div><br/><div class="children"><div class="content">Not to be excessively negative, but this really means very little without more context. Maybe it was very slow before, or it&#x27;s a particulary unused scenario. I&#x27;m always skeptical when people write such praises of their own software without giving a comparison point.</div><br/><div id="36639512" class="c"><input type="checkbox" id="c-36639512" checked=""/><div class="controls bullet"><span class="by">jammycrisp</span><span>|</span><a href="#36638163">root</a><span>|</span><a href="#36638514">parent</a><span>|</span><a href="#36638707">next</a><span>|</span><label class="collapse" for="c-36639512">[-]</label><label class="expand" for="c-36639512">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe it was very slow before<p>That is at least partly the case. I maintain msgspec[1], another Python JSON validation library. Pydantic V1 was ~100x slower at encoding&#x2F;decoding&#x2F;validating JSON than msgspec, which was more a testament to Pydantic&#x27;s performance issues than msgspec&#x27;s speed. Pydantic V2 is definitely faster than V1, but it&#x27;s still ~10x slower than msgspec, and up to 2x slower than other pure-python implementations like mashumaro.<p>Recent benchmark here: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;jcrist&#x2F;d62f450594164d284fbea957fd48b743" rel="nofollow noreferrer">https:&#x2F;&#x2F;gist.github.com&#x2F;jcrist&#x2F;d62f450594164d284fbea957fd48b...</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;jcrist&#x2F;msgspec">https:&#x2F;&#x2F;github.com&#x2F;jcrist&#x2F;msgspec</a></div><br/><div id="36640012" class="c"><input type="checkbox" id="c-36640012" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#36638163">root</a><span>|</span><a href="#36639512">parent</a><span>|</span><a href="#36638707">next</a><span>|</span><label class="collapse" for="c-36640012">[-]</label><label class="expand" for="c-36640012">[1 more]</label></div><br/><div class="children"><div class="content">Eeey hello :D<p>Eeh come on, I think it&#x27;s a bit unfair to compare, because msgspec doesn&#x27;t support regular python union types… which are the number 1 source of slowness… at least in my real world use case of the thing. I&#x27;ve got hundreds of classes with abundant nesting and unions.<p>In pydantic v2 they did the same thing i&#x27;ve been doing in typedload for a few versions already: check the field annotated with a Literal and directly pick the correct type, rather than do try and error. So now the speed for unions has become better.<p>Even so, for being binary vs pure python, I&#x27;d have expected much more.</div><br/></div></div></div></div><div id="36638707" class="c"><input type="checkbox" id="c-36638707" checked=""/><div class="controls bullet"><span class="by">agent281</span><span>|</span><a href="#36638163">root</a><span>|</span><a href="#36638514">parent</a><span>|</span><a href="#36639512">prev</a><span>|</span><a href="#36639976">next</a><span>|</span><label class="collapse" for="c-36638707">[-]</label><label class="expand" for="c-36638707">[2 more]</label></div><br/><div class="children"><div class="content">Pydantic was a pure python library and was rewritten in Rust recently. To be fair, I have seen some critiques of this rewrite. Specifically saying that the validation model could have been much faster in Python and switching languages papers over the deficiencies. I&#x27;m not in a good place to judge if this is true or not.</div><br/><div id="36640021" class="c"><input type="checkbox" id="c-36640021" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#36638163">root</a><span>|</span><a href="#36638707">parent</a><span>|</span><a href="#36639976">next</a><span>|</span><label class="collapse" for="c-36640021">[-]</label><label class="expand" for="c-36640021">[1 more]</label></div><br/><div class="children"><div class="content">I wrote so in other comments… I was surprised to see that for the benchmarks of my library (typedload), it now manages to win a few… but not all of them.</div><br/></div></div></div></div><div id="36639976" class="c"><input type="checkbox" id="c-36639976" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#36638163">root</a><span>|</span><a href="#36638514">parent</a><span>|</span><a href="#36638707">prev</a><span>|</span><a href="#36642439">next</a><span>|</span><label class="collapse" for="c-36639976">[-]</label><label class="expand" for="c-36639976">[1 more]</label></div><br/><div class="children"><div class="content">Yes it was incredibly slow and inefficient.<p>I maintain typedload (a similar project, that I started before pydantic&#x27;s first release) and pydantic 2 somehow still manages to be slower than a pure python library that got no funding to improve performances.</div><br/></div></div></div></div><div id="36642439" class="c"><input type="checkbox" id="c-36642439" checked=""/><div class="controls bullet"><span class="by">ddorian43</span><span>|</span><a href="#36638163">parent</a><span>|</span><a href="#36638514">prev</a><span>|</span><a href="#36642036">next</a><span>|</span><label class="collapse" for="c-36642439">[-]</label><label class="expand" for="c-36642439">[1 more]</label></div><br/><div class="children"><div class="content">You can use gevent and no need to replicate every library under the sun for async io.</div><br/></div></div></div></div><div id="36642036" class="c"><input type="checkbox" id="c-36642036" checked=""/><div class="controls bullet"><span class="by">miiiiiike</span><span>|</span><a href="#36638163">prev</a><span>|</span><a href="#36642411">next</a><span>|</span><label class="collapse" for="c-36642036">[-]</label><label class="expand" for="c-36642036">[1 more]</label></div><br/><div class="children"><div class="content">I wish Django would take async more seriously. This comment gives a pretty good overview of the current situation (some points are more valid than others): <a href="https:&#x2F;&#x2F;github.com&#x2F;encode&#x2F;django-rest-framework&#x2F;discussions&#x2F;7774#discussioncomment-6361530">https:&#x2F;&#x2F;github.com&#x2F;encode&#x2F;django-rest-framework&#x2F;discussions&#x2F;...</a><p>The Python ecosystem is strange. Where other dev communities will embrace new ways of doing things faster than most people can keep up — the Python community needs to be pulled kicking and screaming into the light once ever decade or so. Python 2 to 3, ~10 years.<p>async&#x2F;await has been in Python since 2015, it feels like it&#x27;s going to be another 5 years before we see people taking async seriously in the big packages. Same problem we had during the 2&#x2F;3 transition. No library support, no developer support.</div><br/></div></div><div id="36642411" class="c"><input type="checkbox" id="c-36642411" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#36642036">prev</a><span>|</span><a href="#36638611">next</a><span>|</span><label class="collapse" for="c-36642411">[-]</label><label class="expand" for="c-36642411">[2 more]</label></div><br/><div class="children"><div class="content">This project has 433 pull requests.<p>It used to have literally thousands of open issues. Where did they go? Fixed?<p>It also had a project owner who refused to form a team of people responsible for the project. How did that pan out?</div><br/><div id="36642580" class="c"><input type="checkbox" id="c-36642580" checked=""/><div class="controls bullet"><span class="by">greazy</span><span>|</span><a href="#36642411">parent</a><span>|</span><a href="#36638611">next</a><span>|</span><label class="collapse" for="c-36642580">[-]</label><label class="expand" for="c-36642580">[1 more]</label></div><br/><div class="children"><div class="content">Not long ago the lead author converted all issues to discussions. I think most of the issues were actually questions.</div><br/></div></div></div></div><div id="36638611" class="c"><input type="checkbox" id="c-36638611" checked=""/><div class="controls bullet"><span class="by">aliljet</span><span>|</span><a href="#36642411">prev</a><span>|</span><a href="#36639176">next</a><span>|</span><label class="collapse" for="c-36638611">[-]</label><label class="expand" for="c-36638611">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really curious about why you would want to use FastAPI over Django Rest Framework. Are there signficant advantages to FastAPI?</div><br/><div id="36640242" class="c"><input type="checkbox" id="c-36640242" checked=""/><div class="controls bullet"><span class="by">pedrovhb</span><span>|</span><a href="#36638611">parent</a><span>|</span><a href="#36638643">next</a><span>|</span><label class="collapse" for="c-36640242">[-]</label><label class="expand" for="c-36640242">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re totally different in terms of the scope of the project they&#x27;re meant to be used for.<p>FastAPI is much closer to Flask in that it&#x27;s trivial to throw up  a single file with a couple of routes, and you can use something like SQLite yourself for persistence to disk, or install a couple of libraries for authentication or such (not sure if that&#x27;s built in by now).<p>Django, on the other hand, requires a multi-step process to even start a project and creates a dozen of files, most of which are boilerplate, before you can even see a &quot;hello world&quot; route.<p>But in exchange, you get not just a program which deals with routing and templates and status codes, but much more - a world-class ORM which integrates pretty much transparently with multiple data stores like Postgres or SQLite, an amazing dashboard out of the box which is really handy for sharing with non-techies, a very mature ecosystem, and perhaps most importantly, the &quot;one right way to do things&quot;, which makes it a lot more effective for collaboration between a bunch of engineers. It&#x27;s of course not infallible, has a learning curve, and comes with a good few footguns that get the uninitiated, but the upside is a real upside. Migrations alone might justify it - for all the grief of merge conflicts between migrations right before a code freeze, I can&#x27;t imagine how much worse it would be to <i>not</i> have them.<p>So I wouldn&#x27;t say there&#x27;s significant advantages to using either - they&#x27;re different tools for different use cases. If you want to get something up quick that isn&#x27;t too complex, FastAPI is great for that. If you know you&#x27;re eventually going to rewrite Django but worse, you may as well use the real thing.</div><br/></div></div><div id="36638643" class="c"><input type="checkbox" id="c-36638643" checked=""/><div class="controls bullet"><span class="by">djaychela</span><span>|</span><a href="#36638611">parent</a><span>|</span><a href="#36640242">prev</a><span>|</span><a href="#36640774">next</a><span>|</span><label class="collapse" for="c-36638643">[-]</label><label class="expand" for="c-36638643">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve just made a first project in fastAPI, and it was trivially simple compared to my previous adventures in DRF. Plus asyc from the get go, which was also pleasant. I had a task as part of this that takes 10 seconds to run, and there&#x27;s a built in way to allow it to run in the background.<p>And the documentation is excellent.</div><br/><div id="36639613" class="c"><input type="checkbox" id="c-36639613" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#36638611">root</a><span>|</span><a href="#36638643">parent</a><span>|</span><a href="#36640774">next</a><span>|</span><label class="collapse" for="c-36639613">[-]</label><label class="expand" for="c-36639613">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve just made a first project in fastAPI, and it was trivially simple…<p>My experience has been, as Seth Godin says, “the long-cut is the most direct route to get to where you seek to go”<p>Every time I started with Django, I hated the feeling of sitting in boilerplate hell early on.<p>Every time I started with FastAPI&#x2F;Flask, I get something working quickly, then hit a wall of recreating everything that comes with Django.<p>The only solution I’ve found is: embrace boilerplate [1], automate the boilerplate.<p>[1] Django, or whatever batteries included framework you like (Rails, Laravel, Phoenix, etc)</div><br/><div id="36639749" class="c"><input type="checkbox" id="c-36639749" checked=""/><div class="controls bullet"><span class="by">etimberg</span><span>|</span><a href="#36638611">root</a><span>|</span><a href="#36639613">parent</a><span>|</span><a href="#36640774">next</a><span>|</span><label class="collapse" for="c-36639749">[-]</label><label class="expand" for="c-36639749">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, at a past job I had to build out a way to run launchdarkly in FastAPI and it was very unpleasant. Launchdarkly only ships a sync python client so we ended up having to run it in another process to avoid blocking all requests</div><br/></div></div></div></div></div></div><div id="36640774" class="c"><input type="checkbox" id="c-36640774" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#36638611">parent</a><span>|</span><a href="#36638643">prev</a><span>|</span><a href="#36639176">next</a><span>|</span><label class="collapse" for="c-36640774">[-]</label><label class="expand" for="c-36640774">[1 more]</label></div><br/><div class="children"><div class="content">I found DRF to be great at generating fairly simple APIs very quickly. But complicated stuff gets... more complicated, due to inheritance and magic. I love me some DRF, govscent uses it: <a href="https:&#x2F;&#x2F;govscent.org&#x2F;api&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;govscent.org&#x2F;api&#x2F;</a><p>All from a few lines of code.<p>But I&#x27;ve mostly switched to django-ninja which is more type safe and faster.</div><br/></div></div></div></div><div id="36639176" class="c"><input type="checkbox" id="c-36639176" checked=""/><div class="controls bullet"><span class="by">nikcub</span><span>|</span><a href="#36638611">prev</a><span>|</span><a href="#36636066">next</a><span>|</span><label class="collapse" for="c-36639176">[-]</label><label class="expand" for="c-36639176">[3 more]</label></div><br/><div class="children"><div class="content">The rustification of Python libraries and tooling continues and it has been brilliant. In the past 6 months I have personally switched projected to ruff[0], polars and now - as of this morning[1] - pydantic 2 and FastAPI 0.100<p>[0] has replaced pylint, flake8, pyupgrade, isort, mccabe and pydocstyle<p>[1] bump-pydantic worked well, after porting settings to pydantic_settings.</div><br/><div id="36639374" class="c"><input type="checkbox" id="c-36639374" checked=""/><div class="controls bullet"><span class="by">Kydlaw</span><span>|</span><a href="#36639176">parent</a><span>|</span><a href="#36640336">next</a><span>|</span><label class="collapse" for="c-36639374">[-]</label><label class="expand" for="c-36639374">[1 more]</label></div><br/><div class="children"><div class="content">You might want to check Pylyzer then (<a href="https:&#x2F;&#x2F;github.com&#x2F;mtshiba&#x2F;pylyzer">https:&#x2F;&#x2F;github.com&#x2F;mtshiba&#x2F;pylyzer</a>).<p>I&#x27;m not involved at all. It is still very very early in development. But as it is in the same vein, I thought I&#x27;d mentioned it here.</div><br/></div></div><div id="36640336" class="c"><input type="checkbox" id="c-36640336" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#36639176">parent</a><span>|</span><a href="#36639374">prev</a><span>|</span><a href="#36636066">next</a><span>|</span><label class="collapse" for="c-36640336">[-]</label><label class="expand" for="c-36640336">[1 more]</label></div><br/><div class="children"><div class="content">At the cost of bigger downloads, not working with other python implementations, and in the case of pydantic, the performance gains aren&#x27;t that impressive compared to pure python libraries.</div><br/></div></div></div></div><div id="36636066" class="c"><input type="checkbox" id="c-36636066" checked=""/><div class="controls bullet"><span class="by">svaha1728</span><span>|</span><a href="#36639176">prev</a><span>|</span><a href="#36642042">next</a><span>|</span><label class="collapse" for="c-36636066">[-]</label><label class="expand" for="c-36636066">[11 more]</label></div><br/><div class="children"><div class="content">Did not take long at all to see Pydantic version 2 support. Nice!</div><br/><div id="36638438" class="c"><input type="checkbox" id="c-36638438" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36636066">parent</a><span>|</span><a href="#36642042">next</a><span>|</span><label class="collapse" for="c-36638438">[-]</label><label class="expand" for="c-36638438">[10 more]</label></div><br/><div class="children"><div class="content">I still can&#x27;t stand Pydantic&#x27;s API and its approach to non-documentation. I respect the tremendous amount of hard work that goes into it, but fundamentally I don&#x27;t like the developer experience and I don&#x27;t think I&#x27;ll ever feel otherwise. I use it because my coworkers like it and I&#x27;ve learned its advanced features because I had to in order to get things done, not because I like it.<p>I would love to see a FastAPI alternative still using Starlette internally, but using Attrs + Marshmallow + Cattrs + Apispec instead of Pydantic. It would be a little less &quot;fast&quot; to write a working prototype, but I&#x27;d feel much more comfortable working with those APIs, as well as much more comfortable that my dependencies are well-supported and stable.<p>The problem of course is not that gluing those things together is hard. The problem is that now someone has put untold hundreds of person-hours into FastAPI, and replicating that level of care, polish, bugfixes, feature requests, etc. is difficult without putting in those hundreds of person-hours yourself.</div><br/><div id="36639254" class="c"><input type="checkbox" id="c-36639254" checked=""/><div class="controls bullet"><span class="by">willhoyle</span><span>|</span><a href="#36636066">root</a><span>|</span><a href="#36638438">parent</a><span>|</span><a href="#36640235">next</a><span>|</span><label class="collapse" for="c-36639254">[-]</label><label class="expand" for="c-36639254">[7 more]</label></div><br/><div class="children"><div class="content">I too have made similar observations regarding pydantic and FastAPI.<p>I was evaluating various Python async http frameworks and landed on a similar stack:<p>- attrs&#x2F;cattrs for models
- starlette+uvicorn for HTTP&#x2F;websocket
- validation I’m still on the fence about. I’ll see how far I get with the built in validators offered by attrs. I use voluptuous at work and generally like the DX but it’s in maintenance mode.<p>This is purely personally preference, I’m sure devs using fastapi+pydantic are more productive in the long run. It almost feels like I’m hand rolling my own fastapi implementation but at the same time I don’t want to be too locked in to frameworks like that.<p>Ive been burnt by magic frameworks that do too much behind the scenes and there’s something nice about fully understanding what’s going on when you hand stitch libraries yourself.</div><br/><div id="36639585" class="c"><input type="checkbox" id="c-36639585" checked=""/><div class="controls bullet"><span class="by">jammycrisp</span><span>|</span><a href="#36636066">root</a><span>|</span><a href="#36639254">parent</a><span>|</span><a href="#36639851">next</a><span>|</span><label class="collapse" for="c-36639585">[-]</label><label class="expand" for="c-36639585">[2 more]</label></div><br/><div class="children"><div class="content">If you like cattrs, you _might_ be interested in trying out my msgspec library [1].<p>It works out-of-the-box with attrs objects (as well as its own faster `Struct` types), while being ~10-15x faster than cattrs for encoding&#x2F;decoding&#x2F;validating JSON. The hope is it&#x27;s easy to integrate msgspec with other tools (like attrs!) rather than forcing the user to rewrite code to fit the new validation&#x2F;serialization framework. It may not fit every use case, but if msgspec works for you it should be generally an order-of-magnitude faster than other Python options.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;jcrist&#x2F;msgspec">https:&#x2F;&#x2F;github.com&#x2F;jcrist&#x2F;msgspec</a><p>&lt;&#x2F;blatant-evangelism&gt;</div><br/><div id="36640689" class="c"><input type="checkbox" id="c-36640689" checked=""/><div class="controls bullet"><span class="by">willhoyle</span><span>|</span><a href="#36636066">root</a><span>|</span><a href="#36639585">parent</a><span>|</span><a href="#36639851">next</a><span>|</span><label class="collapse" for="c-36640689">[-]</label><label class="expand" for="c-36640689">[1 more]</label></div><br/><div class="children"><div class="content">This looks like exactly what I&#x27;ve been looking for. I just want strong typing, json &lt;-&gt; struct and validation. Seems like it ticks all the boxes + speed benefits which is always nice. I especially find it useful that I can use messagepack for internal service chatter but still support json for external stuff and dump astuple to sqlite.</div><br/></div></div></div></div><div id="36639851" class="c"><input type="checkbox" id="c-36639851" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#36636066">root</a><span>|</span><a href="#36639254">parent</a><span>|</span><a href="#36639585">prev</a><span>|</span><a href="#36640235">next</a><span>|</span><label class="collapse" for="c-36639851">[-]</label><label class="expand" for="c-36639851">[4 more]</label></div><br/><div class="children"><div class="content">Depending on how far in you are, starlite&#x2F;litestar has good documentation and offers another &quot;batteries included&quot; framework. Performance wise it&#x27;s about the same and the stack is about the same. Fastapi suffers from the &quot;one solo dev in Nebraska&quot; paradigm (check out open prs and old tickets). For me the main draw of litestar is the batteries + better docs + more active development with multiple developers vs most other python web frameworks.</div><br/><div id="36640128" class="c"><input type="checkbox" id="c-36640128" checked=""/><div class="controls bullet"><span class="by">jammycrisp</span><span>|</span><a href="#36636066">root</a><span>|</span><a href="#36639851">parent</a><span>|</span><a href="#36640137">next</a><span>|</span><label class="collapse" for="c-36640128">[-]</label><label class="expand" for="c-36640128">[1 more]</label></div><br/><div class="children"><div class="content">+1 for litestar[1]. The higher bus-factor is nice, and I like that they&#x27;re working to embrace a wider set of technologies than just pydantic. The framework currently lets you model objects using msgspec[2] (they actually use msgspec for all serialization), pydantic, or attrs[3], and the upcoming release adds some new mechanisms for handling additional types. I really appreciate the flexibility in modeling APIs; not everything fits well into a pydantic shaped box.<p>[1]: <a href="https:&#x2F;&#x2F;litestar.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;litestar.dev&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;jcrist&#x2F;msgspec">https:&#x2F;&#x2F;github.com&#x2F;jcrist&#x2F;msgspec</a><p>[3]: <a href="https:&#x2F;&#x2F;www.attrs.org&#x2F;en&#x2F;stable&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.attrs.org&#x2F;en&#x2F;stable&#x2F;</a></div><br/></div></div><div id="36640137" class="c"><input type="checkbox" id="c-36640137" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36636066">root</a><span>|</span><a href="#36639851">parent</a><span>|</span><a href="#36640128">prev</a><span>|</span><a href="#36640235">next</a><span>|</span><label class="collapse" for="c-36640137">[-]</label><label class="expand" for="c-36640137">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t heard of Starlite or Litestar before. Is one a fork of the other? Their documentation intro text is identical:<p>&gt; {Litestar|Starlite} is a powerful, flexible, highly performant, and opinionated ASGI framework, offering first class typing support and a full Pydantic integration.
&gt; 
&gt; The {Litestar|Starlite} framework supports Plugins, ships with dependency injection, security primitives, OpenAPI schema generation, MessagePack, middlewares, and much more.</div><br/><div id="36640228" class="c"><input type="checkbox" id="c-36640228" checked=""/><div class="controls bullet"><span class="by">jammycrisp</span><span>|</span><a href="#36636066">root</a><span>|</span><a href="#36640137">parent</a><span>|</span><a href="#36640235">next</a><span>|</span><label class="collapse" for="c-36640228">[-]</label><label class="expand" for="c-36640228">[1 more]</label></div><br/><div class="children"><div class="content">starlite was the original name, it was recently renamed to litestar due to comments about how easily confused &quot;starlette&quot; and &quot;starlite&quot; are.</div><br/></div></div></div></div></div></div></div></div><div id="36640235" class="c"><input type="checkbox" id="c-36640235" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#36636066">root</a><span>|</span><a href="#36638438">parent</a><span>|</span><a href="#36639254">prev</a><span>|</span><a href="#36642042">next</a><span>|</span><label class="collapse" for="c-36640235">[-]</label><label class="expand" for="c-36640235">[2 more]</label></div><br/><div class="children"><div class="content">Could you simplify your point? I was an ardent marshmallow user and when I finally switched to pydantic, it felt like I finally sat down in my life after standing forever. The documentation sounds good enough to me, but importantly the interface pydantic provides to define your json schema is the most elegant interface I’ve seen in any language and miles better than the mess marshmallow provided.<p>For many of us especially in the SaaS side, speed of these operations is a distant third priority compared to ease of writing and understanding the code, and ensuring reliable less buggy code. The actual compute happens on a cluster with spark or snowflake anyway.</div><br/><div id="36641254" class="c"><input type="checkbox" id="c-36641254" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36636066">root</a><span>|</span><a href="#36640235">parent</a><span>|</span><a href="#36642042">next</a><span>|</span><label class="collapse" for="c-36641254">[-]</label><label class="expand" for="c-36641254">[1 more]</label></div><br/><div class="children"><div class="content">There is no reference doc. The docs cover a lot of material in a small amount of space, buying important pieces of information and mixing up a large number of topics under unintuitive headlines. Reading the source code is occasionally necessary just to figure out how it all works.<p>The API is a little weird, particularly around defining validators. The parameter name-matching is an &quot;interesting&quot; design choice. Accessing &quot;values&quot; as a dict[str,Any] is messy if you care about static typing, although I can understand why they did it.<p>Furthermore, the behavior of validators and the exact sequence in which they run is not defined by the docs. It&#x27;s not that hard to figure out, but it also might change at any time because there&#x27;s no user contract. Attrs is significantly nicer in just about all respects here, <i>especially</i> their attention to detail in their extensive user guide and reference docs.<p>Speaking of user contract, there&#x27;s no clear separation between private and public. Without a reference doc it all looks like fair game, but without a reference doc it also might all change at any moment. Either you stick to the examples, or you&#x27;re off doing a guess-and-check dance and hoping something doesn&#x27;t break.<p>Even with the Mypy plugin, I often have to write `if TYPE_CHECKING` all over any nontrivial Pydantic class consuming data from external sources. Variable annotations in Pydantic are fundamentally <i>not</i> PEP 484 type hints. That&#x27;s fine, but it&#x27;s confusing that they&#x27;re <i>almost</i> the same, and, as above, it&#x27;s almost entirely up to you to figure out how it all works, either by trial and error or by digging around in the issue tracker and StackOverflow.<p>Ease of writing and reliability is precisely my big area of annoyance and concern. Speed of (de)serialization is comparatively unimportant (although I don&#x27;t like the huge amount of overhead involved and I avoid using it in hot code paths).<p>I also don&#x27;t like <i>using</i> Pydantic-defined classes very much, because the actual init method signature is just *args, **kwargs, which doesn&#x27;t work well with any tooling. It feels like being back in the Tornado &amp; PyMongo dark ages where everything is dynamic or dynamically-generated and classes are just glorified hash tables.<p>I agree that the JSONSchema integration is outstanding. BaseSettings is also a tremendous productivity improvement, I love that I can define a class and immediately get a proper app-wide config reading from both env vars and a dotenv file. I also like the default error messages that tell you exactly which field failed validation. I also like the validator system (once I figured out how it worked), respecting the order in which I define the validators as well as supporting validators that run before or after the default set of validators (pre=True and pre=False respectively). I was probably being a little too negative before, but my annoyance level with the developer-facing API and documentation remains high, and I will gladly jump to an Attrs-based alternative as soon as one exists.*</div><br/></div></div></div></div></div></div></div></div><div id="36642042" class="c"><input type="checkbox" id="c-36642042" checked=""/><div class="controls bullet"><span class="by">monlockandkey</span><span>|</span><a href="#36636066">prev</a><span>|</span><a href="#36638872">next</a><span>|</span><label class="collapse" for="c-36642042">[-]</label><label class="expand" for="c-36642042">[1 more]</label></div><br/><div class="children"><div class="content">My only frustration with fastapi is the lack of API documentation.<p>Usually docs just have API specified, this project goes the other end of the spectrum and has examples for everything.<p>Whilst that is nice, APIs  are undocumented and it is a bit harder to grok the project without the available functions and methods in a list</div><br/></div></div><div id="36638872" class="c"><input type="checkbox" id="c-36638872" checked=""/><div class="controls bullet"><span class="by">The_Hoff</span><span>|</span><a href="#36642042">prev</a><span>|</span><a href="#36639936">next</a><span>|</span><label class="collapse" for="c-36638872">[-]</label><label class="expand" for="c-36638872">[1 more]</label></div><br/><div class="children"><div class="content">FastAPI is a joy to use. Tried using `bump-pydantic` and it worked flawlessly. Thankful for the work by this team.</div><br/></div></div></div></div></div></div></div></body></html>