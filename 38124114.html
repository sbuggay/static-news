<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699002059995" as="style"/><link rel="stylesheet" href="styles.css?v=1699002059995"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/BurntSushi/rsc-regexp">Translations of Russ Cox&#x27;s Thompson NFA C Program to Rust</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>asicsp</span> | <span>7 comments</span></div><br/><div><div id="38125257" class="c"><input type="checkbox" id="c-38125257" checked=""/><div class="controls bullet"><span class="by">porridgeraisin</span><span>|</span><label class="collapse" for="c-38125257">[-]</label><label class="expand" for="c-38125257">[6 more]</label></div><br/><div class="children"><div class="content">Ripgrep also uses Thompson nfas</div><br/><div id="38125503" class="c"><input type="checkbox" id="c-38125503" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#38125257">parent</a><span>|</span><a href="#38125934">next</a><span>|</span><label class="collapse" for="c-38125503">[-]</label><label class="expand" for="c-38125503">[3 more]</label></div><br/><div class="children"><div class="content">A fun experience 12 years ago was implementing Thompson NFA from the original 1960s paper into C# to improve a NLP lab&#x27;s regex processing speed. Speed up was crazy, like 1200 times versus the custom bespoke matching method they had been using until then.<p>I had this awakening of raw primal power, like: <i>I can take this ancient thing, in this obscure long forgotten paper, and use to cast new power and speed.</i><p>I realized not all good things are shiny and new! Some can be dusty and old.<p>Experts may dispute my characterization of the Thompson NFA paper as obscure and forgotten but this was in 2011 and how it seemed to me. You must remember that to an expert, something otherwise obscure will not be! Also, seemed that way when I learned that not every regex implementation used this clearly superior method.<p>Also, I realized and appreciated what an absolute genius Thompson was. Reading his paper was like clarity: you could feel his clarity and power. It&#x27;s masterful. To appreciate his clear presentation and absolute command of the concepts that were contained in this dusty ancient document (well I mean the PDF looked that way, ha!), was just awesome. It was cool! :)</div><br/><div id="38126044" class="c"><input type="checkbox" id="c-38126044" checked=""/><div class="controls bullet"><span class="by">uticus</span><span>|</span><a href="#38125257">root</a><span>|</span><a href="#38125503">parent</a><span>|</span><a href="#38125970">next</a><span>|</span><label class="collapse" for="c-38126044">[-]</label><label class="expand" for="c-38126044">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty cool, C# performance chasing can be fun or maddening. Thompson NFA was obviously a good choice based on the speedup. But after reading this article I&#x27;m wondering if it was the best choice for all-out performance:<p>&gt; The rust-regex program is quite a bit faster, but primarily because it uses a different technique for this particular regex (a lazy DFA).<p>[edit] Point being, different techniques work better for different use cases. To deal with <i>this</i> aspect of performance chasing I wonder, since multi-core is more prevalent now (than in 1968), if it would be the ultimate in performance to fire off a few different techniques simultaneously on different cores and let the first one take it. That would bypass the need for analysis before choosing a technique.</div><br/></div></div><div id="38125970" class="c"><input type="checkbox" id="c-38125970" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38125257">root</a><span>|</span><a href="#38125503">parent</a><span>|</span><a href="#38126044">prev</a><span>|</span><a href="#38125934">next</a><span>|</span><label class="collapse" for="c-38125970">[-]</label><label class="expand" for="c-38125970">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s remarkable how much our ancestors achieved. I can only wonder what other treasures are hidden away in the literature. Does anyone have a collection?</div><br/></div></div></div></div><div id="38125934" class="c"><input type="checkbox" id="c-38125934" checked=""/><div class="controls bullet"><span class="by">mcbain</span><span>|</span><a href="#38125257">parent</a><span>|</span><a href="#38125503">prev</a><span>|</span><a href="#38125930">next</a><span>|</span><label class="collapse" for="c-38125934">[-]</label><label class="expand" for="c-38125934">[1 more]</label></div><br/><div class="children"><div class="content">Which is also the OP&#x27;s (BurntSushi) work.</div><br/></div></div></div></div></div></div></div></div></div></body></html>