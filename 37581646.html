<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695286863102" as="style"/><link rel="stylesheet" href="styles.css?v=1695286863102"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.macarthur.me/posts/more-aggressive-cache-headers">Cache headers could probably be more aggressive</a> <span class="domain">(<a href="https://www.macarthur.me">www.macarthur.me</a>)</span></div><div class="subtext"><span>skilled</span> | <span>20 comments</span></div><br/><div><div id="37594656" class="c"><input type="checkbox" id="c-37594656" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#37594814">next</a><span>|</span><label class="collapse" for="c-37594656">[-]</label><label class="expand" for="c-37594656">[3 more]</label></div><br/><div class="children"><div class="content">Caching is largely a <i>means</i> to reach a goal of reduced bandwidth but even more so network latency. Almost everything else is fast and cheap, and network latency can largely be simplified to number of round trips, similar to the N+1 problem for database queries. Reducing number of round trips is a better proxy for performance (although global CDNs can make some round trips faster than others).<p>I don’t know what serving stacks kids use these days but judging from my web developer tools, it appears to be a hodgepodge of dynamically loaded crap and microservices (which adds also TLS handshakes to the mix) that of course fetch things in the least efficient ways possible. Caching (a) won’t even work for many of these cases and (b) wouldn’t help much even when it does work.<p>I’d love to see a post about round trips exclusively and how to reduce it in the bloated stacks of today. I hope it’s not as bad as I think.</div><br/><div id="37594718" class="c"><input type="checkbox" id="c-37594718" checked=""/><div class="controls bullet"><span class="by">hannob</span><span>|</span><a href="#37594656">parent</a><span>|</span><a href="#37594814">next</a><span>|</span><label class="collapse" for="c-37594718">[-]</label><label class="expand" for="c-37594718">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s how to reduce roundtrips:<p>* Support TLS 1.3 + HTTP&#x2F;2 or HTTP&#x2F;3.<p>* Reduce the number of different hosts that you connect to. The optimal number is 1.<p>That&#x27;s it.</div><br/><div id="37594802" class="c"><input type="checkbox" id="c-37594802" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#37594656">root</a><span>|</span><a href="#37594718">parent</a><span>|</span><a href="#37594814">next</a><span>|</span><label class="collapse" for="c-37594802">[-]</label><label class="expand" for="c-37594802">[1 more]</label></div><br/><div class="children"><div class="content">Additionally, use early hints to push resources to the client before your server responds with the rendered page.</div><br/></div></div></div></div></div></div><div id="37594814" class="c"><input type="checkbox" id="c-37594814" checked=""/><div class="controls bullet"><span class="by">munro</span><span>|</span><a href="#37594656">prev</a><span>|</span><a href="#37593932">next</a><span>|</span><label class="collapse" for="c-37594814">[-]</label><label class="expand" for="c-37594814">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really like these content marketing posts, that subtly hide referrals, in this case to: <a href="https:&#x2F;&#x2F;www.picperf.dev&#x2F;?ref=alex-macarthur" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.picperf.dev&#x2F;?ref=alex-macarthur</a><p>I also don&#x27;t want to jump to conclusions, maybe the author really does like PicPerf (and just so happened to include a referral tag lol), but I think most people here are very sensitive to content marketing.<p>I&#x27;m trying to apply for a visa, and it&#x27;s almost impossible to find official government documents or 1st hand experiences buried underneath all the shitty content marketing from law firms.</div><br/></div></div><div id="37593932" class="c"><input type="checkbox" id="c-37593932" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#37594814">prev</a><span>|</span><a href="#37594804">next</a><span>|</span><label class="collapse" for="c-37593932">[-]</label><label class="expand" for="c-37593932">[10 more]</label></div><br/><div class="children"><div class="content">Fingerprinting with content-based hashing in the filename works, but it’s not ideal. You’ve got to make it work for basically every static asset regardless of how it is generated.<p>Generally speaking, I’ve found it’s better to remove this from the build logic and treat it as an infra &#x2F; deployment issue. Dump all of your static assets into your object store using the Git hash of the current version as a prefix. So if you are deploying foo.js, then you might serve it as <a href="https:&#x2F;&#x2F;static.example.com&#x2F;&lt;git" rel="nofollow noreferrer">https:&#x2F;&#x2F;static.example.com&#x2F;&lt;git</a> hash&gt;&#x2F;foo.js.<p>This means that you can set all of your assets as permanently cacheable and still have your cache invalidated for everything every time you deploy something new. And it doesn’t matter what you use to build your assets; your build pipeline doesn’t need to know anything about this, it can just generate assets normally.</div><br/><div id="37594021" class="c"><input type="checkbox" id="c-37594021" checked=""/><div class="controls bullet"><span class="by">comradesmith</span><span>|</span><a href="#37593932">parent</a><span>|</span><a href="#37594188">next</a><span>|</span><label class="collapse" for="c-37594021">[-]</label><label class="expand" for="c-37594021">[2 more]</label></div><br/><div class="children"><div class="content">That means that after a deployment all my users will find themselves refetching everything on the next page load regardless of if it has changed.</div><br/></div></div><div id="37594188" class="c"><input type="checkbox" id="c-37594188" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#37593932">parent</a><span>|</span><a href="#37594021">prev</a><span>|</span><a href="#37593966">next</a><span>|</span><label class="collapse" for="c-37594188">[-]</label><label class="expand" for="c-37594188">[3 more]</label></div><br/><div class="children"><div class="content">If you’re using Webpack you can emit chunks by their content hash, which means the file names don’t change even when your commit changes.<p>This way, a new deployment of your application doesn’t cause new assets to be served to users, and maintains the speed of your website.</div><br/><div id="37594396" class="c"><input type="checkbox" id="c-37594396" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#37593932">root</a><span>|</span><a href="#37594188">parent</a><span>|</span><a href="#37593966">next</a><span>|</span><label class="collapse" for="c-37594396">[-]</label><label class="expand" for="c-37594396">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you’re using Webpack you can emit chunks by their content hash<p>You’re talking about this in terms of chunks of JavaScript, but static asset caching is something you should be doing for all static assets, not just JavaScript. Whenever I’ve seen somebody use Webpack content hashing for this, they’ve done it for JavaScript and CSS and forgot about basically every other type of file. And also, now you are tied to only referencing those assets via JavaScript because you have to get the URLs from Webpack, whereas with a URL prefix you can just use relative URLs which work in other contexts as well.</div><br/><div id="37594627" class="c"><input type="checkbox" id="c-37594627" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#37593932">root</a><span>|</span><a href="#37594396">parent</a><span>|</span><a href="#37593966">next</a><span>|</span><label class="collapse" for="c-37594627">[-]</label><label class="expand" for="c-37594627">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, for this I like to append the deployment time to the asset paths from within my application; however in the case of static websites it can be a problem.</div><br/></div></div></div></div></div></div><div id="37593966" class="c"><input type="checkbox" id="c-37593966" checked=""/><div class="controls bullet"><span class="by">jstummbillig</span><span>|</span><a href="#37593932">parent</a><span>|</span><a href="#37594188">prev</a><span>|</span><a href="#37594804">next</a><span>|</span><label class="collapse" for="c-37593966">[-]</label><label class="expand" for="c-37593966">[4 more]</label></div><br/><div class="children"><div class="content">Sounds interesting. How do you handle that? How do you select the correct&#x2F;latest ref of each asset to send to the user? It feels like you would have to do the same amount of work that you would have to do with fingerprinting.</div><br/><div id="37594418" class="c"><input type="checkbox" id="c-37594418" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#37593932">root</a><span>|</span><a href="#37593966">parent</a><span>|</span><a href="#37594804">next</a><span>|</span><label class="collapse" for="c-37594418">[-]</label><label class="expand" for="c-37594418">[3 more]</label></div><br/><div class="children"><div class="content">With fingerprinting, each asset has a URL you need to ultimately get from your bundler individually. With a URL prefix, your assets retain their original filenames. In some contexts you’ll need to know the prefix, but it’s the same for every asset. And in other contexts you can just use relative URLs and not think about it at all.</div><br/><div id="37594660" class="c"><input type="checkbox" id="c-37594660" checked=""/><div class="controls bullet"><span class="by">jstummbillig</span><span>|</span><a href="#37593932">root</a><span>|</span><a href="#37594418">parent</a><span>|</span><a href="#37594804">next</a><span>|</span><label class="collapse" for="c-37594660">[-]</label><label class="expand" for="c-37594660">[2 more]</label></div><br/><div class="children"><div class="content">You would need the correct git hash, no? Instead of &#x2F;rndotherhash_filename.ext you are looking for &#x2F;rndgithash&#x2F;filename.ext<p>I fail to understand how resolving that is simpler.</div><br/><div id="37594971" class="c"><input type="checkbox" id="c-37594971" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#37593932">root</a><span>|</span><a href="#37594660">parent</a><span>|</span><a href="#37594804">next</a><span>|</span><label class="collapse" for="c-37594971">[-]</label><label class="expand" for="c-37594971">[1 more]</label></div><br/><div class="children"><div class="content">Support you have the following assets:<p><pre><code>  - &#x2F;js&#x2F;foo.js
  - &#x2F;css&#x2F;bar.css
  - &#x2F;img&#x2F;baz.png
</code></pre>
With a content-based hash, end up with something like the following:<p><pre><code>  - &#x2F;js&#x2F;foo.abc123.js
  - &#x2F;css&#x2F;bar.def456.css
  - &#x2F;img&#x2F;baz.ghi789.png
</code></pre>
This means that for each and every asset you have, you need to keep track of their unique filename for that deployment and you need to be able to access that whenever you want to refer to the asset. In practice that means most people rely on their bundler to rewrite every place they refer to those assets, which can make it awkward if they need to refer to them from non-JavaScript contexts. Also in practice, people often seem to ignore anything other than JavaScript or CSS, meaning you get stale assets if they aren’t JavaScript or CSS.<p>With a Git hash prefix, you would have something like:<p><pre><code>  - &#x2F;abcdef&#x2F;js&#x2F;foo.js
  - &#x2F;abcdef&#x2F;css&#x2F;bar.css
  - &#x2F;abcdef&#x2F;img&#x2F;baz.png
</code></pre>
This means you only have one single reference to manage, which you can keep track of without relying on your JavaScript bundler. It also means that in a lot of contexts you don’t need the reference at all, for instance in your stylesheets you can just refer to url(..&#x2F;img&#x2F;baz.png) and there’s no rewriting necessary to get the right behaviour.<p>Your build process and your infrastructure caching are two separate concerns; it’s easier if they aren’t tightly coupled.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37594804" class="c"><input type="checkbox" id="c-37594804" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37593932">prev</a><span>|</span><a href="#37594833">next</a><span>|</span><label class="collapse" for="c-37594804">[-]</label><label class="expand" for="c-37594804">[1 more]</label></div><br/><div class="children"><div class="content">An alternative is to think of the browser as a distributed managed cache.<p>Browsers have a cache API that can be used directly or in service&#x2F;webworkers.<p>A managed cache comes with significant upsides, such as complete control, but costs design&#x2F;developer time and comes with a risk:<p>Caching done wrong can lead to bugs that are very hard to reason about and fix. Especially when service workers are involved.</div><br/></div></div><div id="37594833" class="c"><input type="checkbox" id="c-37594833" checked=""/><div class="controls bullet"><span class="by">e_y_</span><span>|</span><a href="#37594804">prev</a><span>|</span><a href="#37594502">next</a><span>|</span><label class="collapse" for="c-37594833">[-]</label><label class="expand" for="c-37594833">[1 more]</label></div><br/><div class="children"><div class="content">I generally prefer to make the regex rule look for the hash signature, e g. `&#x2F;\.[0-9a-f]{6}\.&#x2F;` rather than solely by file extension. That way if there&#x27;s any files that didn&#x27;t get fingerprinted it won&#x27;t cache it indefinitely.</div><br/></div></div><div id="37594502" class="c"><input type="checkbox" id="c-37594502" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#37594833">prev</a><span>|</span><a href="#37594136">next</a><span>|</span><label class="collapse" for="c-37594502">[-]</label><label class="expand" for="c-37594502">[1 more]</label></div><br/><div class="children"><div class="content">This is the literally the first thing you should check for on a new codebase, particularly because modern build tooling recognizes the need and makes it easy. When you have a.js depending on b.js depending on c.js and on and on, the latency on each network request (just to get the 304) <i>really</i> adds up and can drastically affect perceived speed. Indeed, if most of your users are on speedy connections, the difference between a 500 byte 304 response and a 50 kb re-download is pretty much immaterial compared to the latency of making the request in the first place.</div><br/></div></div><div id="37594136" class="c"><input type="checkbox" id="c-37594136" checked=""/><div class="controls bullet"><span class="by">thomasfromcdnjs</span><span>|</span><a href="#37594502">prev</a><span>|</span><label class="collapse" for="c-37594136">[-]</label><label class="expand" for="c-37594136">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always had a great a time using Fastly (varnish) for caching.<p>You can cache a lot more than you think if you mastermind your strategy.<p>A diagram of fastly&#x2F;varnish state -&gt; <a href="https:&#x2F;&#x2F;www.integralist.co.uk&#x2F;images&#x2F;fastly-request-flow.png" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.integralist.co.uk&#x2F;images&#x2F;fastly-request-flow.png</a></div><br/><div id="37594958" class="c"><input type="checkbox" id="c-37594958" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#37594136">parent</a><span>|</span><label class="collapse" for="c-37594958">[-]</label><label class="expand" for="c-37594958">[1 more]</label></div><br/><div class="children"><div class="content">I was spec-ing out Varnish for a project recently and was really impressed with what it could do. The stale-while-revalidate approach (immediately serve data past the `ttl` for a `grace` period while asynchronously refreshing it) keeps data flowing. It can `keep` data past the `grace` period and serve that when the origin goes down or use that in conditional requests (If-Modified-Since) to the origin to prevent fetching unchanged content. Coalescing requests mitigates thundering herds that reach stale caches. VCL scripting makes the whole thing very configurable. I think Varnish needs better marketing, but I suppose Fastly does that now.<p>[1] <a href="https:&#x2F;&#x2F;www.varnish-software.com&#x2F;developers&#x2F;tutorials&#x2F;http-caching-basics&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.varnish-software.com&#x2F;developers&#x2F;tutorials&#x2F;http-c...</a><p>[2] <a href="https:&#x2F;&#x2F;info.varnish-software.com&#x2F;blog&#x2F;request-coalescing-and-other-reasons-to-use-varnish-as-an-origin-shield" rel="nofollow noreferrer">https:&#x2F;&#x2F;info.varnish-software.com&#x2F;blog&#x2F;request-coalescing-an...</a><p>[3] <a href="https:&#x2F;&#x2F;docs.varnish-software.com&#x2F;tutorials&#x2F;object-lifetime&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.varnish-software.com&#x2F;tutorials&#x2F;object-lifetime&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;www.varnish-software.com&#x2F;developers&#x2F;tutorials&#x2F;varnish-builtin-vcl&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.varnish-software.com&#x2F;developers&#x2F;tutorials&#x2F;varnis...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>