<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699261260895" as="style"/><link rel="stylesheet" href="styles.css?v=1699261260895"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/joeycumines/ts-chan">Show HN: Ts-Chan – Go-Like Concurrency Primitives for TypeScript/JavaScript</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>joeycumines</span> | <span>25 comments</span></div><br/><div><div id="38158109" class="c"><input type="checkbox" id="c-38158109" checked=""/><div class="controls bullet"><span class="by">eplawless</span><span>|</span><a href="#38159858">next</a><span>|</span><label class="collapse" for="c-38158109">[-]</label><label class="expand" for="c-38158109">[10 more]</label></div><br/><div class="children"><div class="content">It might be worthwhile to expand a bit in the docs on  the problems you see with JS concurrency (why you think it sucks, maybe some examples) and then show how ts-chan fixes those problems.</div><br/><div id="38159743" class="c"><input type="checkbox" id="c-38159743" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#38158109">parent</a><span>|</span><a href="#38158910">next</a><span>|</span><label class="collapse" for="c-38159743">[-]</label><label class="expand" for="c-38159743">[6 more]</label></div><br/><div class="children"><div class="content">Agreed. I don’t know go. So I still don’t understand what this is trying to solve</div><br/><div id="38159856" class="c"><input type="checkbox" id="c-38159856" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38158109">root</a><span>|</span><a href="#38159743">parent</a><span>|</span><a href="#38158910">next</a><span>|</span><label class="collapse" for="c-38159856">[-]</label><label class="expand" for="c-38159856">[5 more]</label></div><br/><div class="children"><div class="content">I think y&#x27;all have very fair points, for the record.<p>Unfortunately it is a lot easier to write documentation for an audience that shares the same context &#x2F; background &#x2F; experience. The README was written with an audience in mind consisting primarily of those familiar with Go (or more convoluted &quot;communicating sequential processes&quot; implementations), who were frustrated that things that are very easy in Go, are so much harder in JS. It&#x27;s not something I considered deeply, but I was imagining that it was unlikely that someone would be searching for &quot;channels in JS&quot; without a base level of understanding.<p>I work&#x2F;have worked with some pretty talented people, but (in the past) I&#x27;ve found it difficult to convey the value of the sorts of patterns that `ts-chan` is intended to enable, to those without first-hand experience with such patterns.<p>Documentation is hard :P</div><br/><div id="38159886" class="c"><input type="checkbox" id="c-38159886" checked=""/><div class="controls bullet"><span class="by">yunohn</span><span>|</span><a href="#38158109">root</a><span>|</span><a href="#38159856">parent</a><span>|</span><a href="#38158910">next</a><span>|</span><label class="collapse" for="c-38159886">[-]</label><label class="expand" for="c-38159886">[4 more]</label></div><br/><div class="children"><div class="content">I’m pretty sure you could articulate how exactly this “better” pattern works versus the default “bad” one. Right now the readme is a pile of illegible jargon to me as a non-go person.</div><br/><div id="38159936" class="c"><input type="checkbox" id="c-38159936" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38158109">root</a><span>|</span><a href="#38159886">parent</a><span>|</span><a href="#38158910">next</a><span>|</span><label class="collapse" for="c-38159936">[-]</label><label class="expand" for="c-38159936">[3 more]</label></div><br/><div class="children"><div class="content">Sure, I intend to give it a shot.<p>I will say though, I personally get the impression that attempts at &quot;concurrency&quot; in JavaScript (in production code) are quite rare, which I attribute to how difficult it is.<p>That is to say, I don&#x27;t know if there really _is_ a &quot;default pattern&quot;.</div><br/><div id="38160007" class="c"><input type="checkbox" id="c-38160007" checked=""/><div class="controls bullet"><span class="by">yunohn</span><span>|</span><a href="#38158109">root</a><span>|</span><a href="#38159936">parent</a><span>|</span><a href="#38158910">next</a><span>|</span><label class="collapse" for="c-38160007">[-]</label><label class="expand" for="c-38160007">[2 more]</label></div><br/><div class="children"><div class="content">I think it would be useful to generally explain what these primitives do and how they interact with each other. A lot of JS&#x2F;TS users haven’t used golang, but would appreciate a better solution if they understand it (me included).<p>Regarding the default vs better, a comparative example with a real concurrent task coded with&#x2F;out your library would be my preferred way to understand it clearly.</div><br/><div id="38160133" class="c"><input type="checkbox" id="c-38160133" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38158109">root</a><span>|</span><a href="#38160007">parent</a><span>|</span><a href="#38158910">next</a><span>|</span><label class="collapse" for="c-38160133">[-]</label><label class="expand" for="c-38160133">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll definitely keep that in mind, thanks :)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38158910" class="c"><input type="checkbox" id="c-38158910" checked=""/><div class="controls bullet"><span class="by">artisin</span><span>|</span><a href="#38158109">parent</a><span>|</span><a href="#38159743">prev</a><span>|</span><a href="#38158304">next</a><span>|</span><label class="collapse" for="c-38158910">[-]</label><label class="expand" for="c-38158910">[2 more]</label></div><br/><div class="children"><div class="content">I somewhat disagree with this take, as I felt the intro and &quot;The microtask queue: a footgun&quot; [1] section in the README does an adequate job of laying out the &#x27;why&#x27; and the problems with JS&#x27;s concurrency model. However, it does presume some understanding of Go&#x27;s channels, so a more explicit example contrasting ts-chan with native JS concurrency could better clarify its benefits for those less familiar. Granted, there is an &#x2F;example directory, but the benchmarking complexity  muddles the readability. Regardless, upon a quick run-through, it looks to be an A-grade library that seems promising for practical use, plus well-referenced, composed, and quite thorough.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;joeycumines&#x2F;ts-chan#the-microtask-queue-a-footgun">https:&#x2F;&#x2F;github.com&#x2F;joeycumines&#x2F;ts-chan#the-microtask-queue-a...</a></div><br/><div id="38159222" class="c"><input type="checkbox" id="c-38159222" checked=""/><div class="controls bullet"><span class="by">rpbiwer2</span><span>|</span><a href="#38158109">root</a><span>|</span><a href="#38158910">parent</a><span>|</span><a href="#38158304">next</a><span>|</span><label class="collapse" for="c-38159222">[-]</label><label class="expand" for="c-38159222">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m dumb but that section didn&#x27;t explain the problem to me in the slightest.</div><br/></div></div></div></div><div id="38158304" class="c"><input type="checkbox" id="c-38158304" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38158109">parent</a><span>|</span><a href="#38158910">prev</a><span>|</span><a href="#38159858">next</a><span>|</span><label class="collapse" for="c-38158304">[-]</label><label class="expand" for="c-38158304">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good idea, thanks :)<p>Honestly, I&#x27;ve been struggling to come up with examples that aren&#x27;t extremely contrived, but are still self-contained enough to easily demonstrate. It might actually be easier to just document patterns, though.</div><br/></div></div></div></div><div id="38159858" class="c"><input type="checkbox" id="c-38159858" checked=""/><div class="controls bullet"><span class="by">eddtries</span><span>|</span><a href="#38158109">prev</a><span>|</span><a href="#38159885">next</a><span>|</span><label class="collapse" for="c-38159858">[-]</label><label class="expand" for="c-38159858">[2 more]</label></div><br/><div class="children"><div class="content">The thing that made me <i>love</i> Golang was the Time channel, where you can have a channel execute a function every X milliseconds, without having to worry about blocking threads with time.sleep() etc. It made a lot of stuff I wanted to write so much easier I basically went all in on Go and haven&#x27;t regretted it.</div><br/><div id="38159944" class="c"><input type="checkbox" id="c-38159944" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38159858">parent</a><span>|</span><a href="#38159885">next</a><span>|</span><label class="collapse" for="c-38159944">[-]</label><label class="expand" for="c-38159944">[1 more]</label></div><br/><div class="children"><div class="content">That one is actually pretty easy in JavaScript - in the past I&#x27;ve implemented the same sort of behavior using async generators.<p>(I also like Go&#x27;s time.Ticker behavior quite a lot)</div><br/></div></div></div></div><div id="38159885" class="c"><input type="checkbox" id="c-38159885" checked=""/><div class="controls bullet"><span class="by">mattlondon</span><span>|</span><a href="#38159858">prev</a><span>|</span><a href="#38158784">next</a><span>|</span><label class="collapse" for="c-38159885">[-]</label><label class="expand" for="c-38159885">[2 more]</label></div><br/><div class="children"><div class="content">It might be nice to implement go&#x27;s defer here too (e.g. for closing the channel) to keep some of the DX.<p>I guess a JavaScript defer could just be enqueueMicrotask and an anonymous arrow function?</div><br/><div id="38159962" class="c"><input type="checkbox" id="c-38159962" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38159885">parent</a><span>|</span><a href="#38158784">next</a><span>|</span><label class="collapse" for="c-38159962">[-]</label><label class="expand" for="c-38159962">[1 more]</label></div><br/><div class="children"><div class="content">If you want it to run on exiting the function in reverse order, something like Python&#x27;s context managers would probably be necessary.<p>I&#x27;ve dabbled in that too, though I don&#x27;t actually use it for anything, currently: <a href="https:&#x2F;&#x2F;github.com&#x2F;Mcsavvy&#x2F;contextlib&#x2F;pull&#x2F;1">https:&#x2F;&#x2F;github.com&#x2F;Mcsavvy&#x2F;contextlib&#x2F;pull&#x2F;1</a></div><br/></div></div></div></div><div id="38158784" class="c"><input type="checkbox" id="c-38158784" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#38159885">prev</a><span>|</span><a href="#38158490">next</a><span>|</span><label class="collapse" for="c-38158784">[-]</label><label class="expand" for="c-38158784">[3 more]</label></div><br/><div class="children"><div class="content">Any comparison with the web-standard channel messaging API? <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Channel_Messaging_API" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Channel_Mes...</a></div><br/><div id="38159016" class="c"><input type="checkbox" id="c-38159016" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38158784">parent</a><span>|</span><a href="#38158490">next</a><span>|</span><label class="collapse" for="c-38159016">[-]</label><label class="expand" for="c-38159016">[2 more]</label></div><br/><div class="children"><div class="content">I actually considered including one in the README, but there were (are) lots of other topics to consider.<p>The tl;dr is that there is some cross over, but the use cases and patterns they support are largely different. Message channels are two-way, channels are one way. (I believe) message channels are 1-1, while `ts-chan`&#x27;s channels are n-n, though each send corresponds to a single receive.<p>The primary use case I aim to address is coordination between independent, asynchronous operations (concurrency in JavaScript). Having an analogue to Go&#x27;s &quot;select statement&quot; is fairly key to that, and I am not quite sure how to articulate the value it provides, but it does not overlap with message channels.<p>Example using a single channel: `ts-chan` may be used to implement a set of workers, which accept requests from n sources (e.g. incoming http requests in a web server), then perform some operation, as a mechanism to bound the concurrency of that operation. Personally, I find it much easier to model it as:<p>1. Start the desired number of workers<p>2. Wire up workers to await incoming requests then process them, in a loop<p>3. Send requests to said workers<p>Rather than (for example) tracking the number of running operations, starting a new worker only if possible, after enqueuing the operation, then having the workers need to operate like &quot;check for any work, increment number of operations, perform operation, check for any work (loop), otherwise decrement number of operations&quot;.<p>The `ts-chan` pattern (which is, really, just a Go pattern) also makes it much easier when the requirements are more complex, e.g. if the requester needs to wait for a response, and might timeout before the operation is even started - in which case the operation should be cancelled.<p>I should probably include demonstrative examples for all that, heh.</div><br/><div id="38159429" class="c"><input type="checkbox" id="c-38159429" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#38158784">root</a><span>|</span><a href="#38159016">parent</a><span>|</span><a href="#38158490">next</a><span>|</span><label class="collapse" for="c-38159429">[-]</label><label class="expand" for="c-38159429">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I should probably include demonstrative examples for all that, heh.<p>Documentation is a lot of work!<p>Thanks for the detailed reply, that makes a lot of sense.</div><br/></div></div></div></div></div></div><div id="38158490" class="c"><input type="checkbox" id="c-38158490" checked=""/><div class="controls bullet"><span class="by">graup</span><span>|</span><a href="#38158784">prev</a><span>|</span><a href="#38159038">next</a><span>|</span><label class="collapse" for="c-38158490">[-]</label><label class="expand" for="c-38158490">[3 more]</label></div><br/><div class="children"><div class="content">I really like Go channels, and I was looking for something like this in JS.<p>One of the earlier implementations is this one, albeit not maintained anymore: <a href="https:&#x2F;&#x2F;github.com&#x2F;NodeGuy&#x2F;channel">https:&#x2F;&#x2F;github.com&#x2F;NodeGuy&#x2F;channel</a>
I think I prefer its more concise API, e.g. for select (<a href="https:&#x2F;&#x2F;github.com&#x2F;NodeGuy&#x2F;channel&#x2F;blob&#x2F;main&#x2F;API.md#examples">https:&#x2F;&#x2F;github.com&#x2F;NodeGuy&#x2F;channel&#x2F;blob&#x2F;main&#x2F;API.md#examples</a>). ts-chan&#x27;s API looks a bit too verbose to my taste.<p>Here&#x27;s an example from ts-chan:<p><pre><code>  import {recv, Chan, Select} from &#x27;ts-chan&#x27;;

  const ch1 = new Chan&lt;number&gt;();
  const ch2 = new Chan&lt;string&gt;();

  void sendsToCh1ThenEventuallyClosesIt();
  void sendsToCh2();

  const select = new Select([recv(ch1), recv(ch2)]);
  for (let running = true; running;) {
    const i = await select.wait();
    switch (i) {
    case 0: {
      const v = select.recv(select.cases[i]);
      if (v.done) {
        running = false;
        break;
      }
      console.log(`rounded value: ${Math.round(v.value)}`);
      break;
    }
    case 1: {
      const v = select.recv(select.cases[i]);
      if (v.done) {
        throw new Error(&#x27;ch2 unexpectedly closed&#x27;);
      }
      console.log(`uppercase string value: ${v.value.toUpperCase()}`);
      break;
    }
    default:
      throw new Error(&#x27;unreachable&#x27;);
    }
  }

</code></pre>
I would consider rewriting the API to something like this:<p><pre><code>  import { receive, Channel, select } from &#x27;ts-chan&#x27;;

  const ch1 = new Channel&lt;number&gt;();
  const ch2 = new Channel&lt;string&gt;();

  void sendsToCh1ThenEventuallyClosesIt();
  void sendsToCh2();

  for (let running = true; running;) {
   switch(await select([receive(ch1), receive(ch2)])) {
      case ch1: {
        if (ch1.done) {
          running = false;
          break;
        }
        console.log(`rounded value: ${Math.round(ch1.value)}`);
      }
      case ch2: {
        if (ch1.done) {
          throw new Error(&#x27;ch2 unexpectedly closed&#x27;);
        }
        console.log(`uppercase string value: ${ch2.value.toUpperCase()}`);
        break;
      }
    }
  }</code></pre></div><br/><div id="38158814" class="c"><input type="checkbox" id="c-38158814" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38158490">parent</a><span>|</span><a href="#38159038">next</a><span>|</span><label class="collapse" for="c-38158814">[-]</label><label class="expand" for="c-38158814">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been considering adding a `select` function, but I was concerned with the overhead of recreating the select case each time, and wanted to reserve it for a time once I&#x27;ve mulled over my options (I&#x27;m aiming to avoid making breaking changes, even though it&#x27;s pre-v1).<p>With receives, there&#x27;s a value attached, and that presents some difficulties regarding typing (for TypeScript).<p>You have given me an idea, however: I _might_ be able to wrangle together a mechanism that avoids making it a two-step deal (get the index, then resolve the type). It&#x27;d probably support only a subset of the functionality, though.<p>It&#x27;s on my list to add a simple example to the README using the `Chan` class. Communicating with a single channel (with or without abort support) is very simple, and I&#x27;m happy with the API for that.</div><br/><div id="38160021" class="c"><input type="checkbox" id="c-38160021" checked=""/><div class="controls bullet"><span class="by">yunohn</span><span>|</span><a href="#38158490">root</a><span>|</span><a href="#38158814">parent</a><span>|</span><a href="#38159038">next</a><span>|</span><label class="collapse" for="c-38160021">[-]</label><label class="expand" for="c-38160021">[1 more]</label></div><br/><div class="children"><div class="content">In addition to my other comment, I agree with the parent here. I appreciate the attempt to mirror  golang’s naming, but it would be vastly more readable if you used Channel instead of Chan, etc.</div><br/></div></div></div></div></div></div><div id="38159038" class="c"><input type="checkbox" id="c-38159038" checked=""/><div class="controls bullet"><span class="by">pineapple_guy</span><span>|</span><a href="#38158490">prev</a><span>|</span><a href="#38158455">next</a><span>|</span><label class="collapse" for="c-38159038">[-]</label><label class="expand" for="c-38159038">[2 more]</label></div><br/><div class="children"><div class="content">Regarding the first example in the readme; where is the result variable declared?</div><br/><div id="38159090" class="c"><input type="checkbox" id="c-38159090" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38159038">parent</a><span>|</span><a href="#38158455">next</a><span>|</span><label class="collapse" for="c-38159090">[-]</label><label class="expand" for="c-38159090">[1 more]</label></div><br/><div class="children"><div class="content">Ah, that example is demonstrating an internal mechanism used to ensure the high-level asynchronous API calls take at least one tick of the event loop to complete.<p>There is no `result` variable - I was just attempting to convey that &quot;some async stuff happens, then it waits if we can&#x27;t verify that it&#x27;s not the same tick as when the call started&quot;. The &quot;async stuff&quot;, in the actual implementation, is sending or receiving.</div><br/></div></div></div></div><div id="38158455" class="c"><input type="checkbox" id="c-38158455" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#38159038">prev</a><span>|</span><label class="collapse" for="c-38158455">[-]</label><label class="expand" for="c-38158455">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s based on the JavaScript Promise type. Where is the concurrency?<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Promise" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>Asynchronous is not the same as concurrent.</div><br/><div id="38158753" class="c"><input type="checkbox" id="c-38158753" checked=""/><div class="controls bullet"><span class="by">joeycumines</span><span>|</span><a href="#38158455">parent</a><span>|</span><label class="collapse" for="c-38158753">[-]</label><label class="expand" for="c-38158753">[1 more]</label></div><br/><div class="children"><div class="content">The concurrency comes from providing mechanisms to communicate between independent, asynchronous chains of operations.<p>Here is an example, that I based on an example from within the Go spec: <a href="https:&#x2F;&#x2F;github.com&#x2F;joeycumines&#x2F;ts-chan&#x2F;blob&#x2F;main&#x2F;examples&#x2F;concurrent-prime-sieve&#x2F;index.js">https:&#x2F;&#x2F;github.com&#x2F;joeycumines&#x2F;ts-chan&#x2F;blob&#x2F;main&#x2F;examples&#x2F;co...</a><p>Here is the same example in Go: <a href="https:&#x2F;&#x2F;github.com&#x2F;joeycumines&#x2F;ts-chan&#x2F;blob&#x2F;main&#x2F;examples&#x2F;concurrent-prime-sieve&#x2F;main.go">https:&#x2F;&#x2F;github.com&#x2F;joeycumines&#x2F;ts-chan&#x2F;blob&#x2F;main&#x2F;examples&#x2F;co...</a><p>The JS example is, obviously, much slower, and is fairly contrived - I wouldn&#x27;t expect anyone to actually want to do that, specifically. The JS one is more complicated primarily because I used it in a benchmark, so needed a mechanism to stop the concurrent, asynchronous chains of operations, once it reached the target number of primes.<p>I hope that explains it for you.</div><br/></div></div></div></div></div></div></div></div></div></body></html>