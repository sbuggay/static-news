<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712048452241" as="style"/><link rel="stylesheet" href="styles.css?v=1712048452241"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.trl.sn/blog/what-is-a-json-number/">What even is a JSON number?</a> <span class="domain">(<a href="https://blog.trl.sn">blog.trl.sn</a>)</span></div><div class="subtext"><span>bterlson</span> | <span>110 comments</span></div><br/><div><div id="39899762" class="c"><input type="checkbox" id="c-39899762" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39900236">next</a><span>|</span><label class="collapse" for="c-39899762">[-]</label><label class="expand" for="c-39899762">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll add that for Haskell, the library everyone uses for JSON parses numbers into Scientific types with almost unlimited size and precision. I say almost unlimited because they use a decimal coefficient-and-exponent representation where the exponent is a 64-bit integer.<p>The documentation is quite paranoid that if you are dealing with untrusted inputs, you could parse two JSON numbers from the untrusted source fine and then performing an addition on them could cause your memory to fill up. Exciting new DoS vector.<p>Of course in practice people end up parsing them into custom types with 64-bit integers, so this is only a problem if you are manipulating JSON directly which is very rare in Haskell.</div><br/><div id="39900871" class="c"><input type="checkbox" id="c-39900871" checked=""/><div class="controls bullet"><span class="by">akubera</span><span>|</span><a href="#39899762">parent</a><span>|</span><a href="#39902083">next</a><span>|</span><label class="collapse" for="c-39900871">[-]</label><label class="expand" for="c-39900871">[10 more]</label></div><br/><div class="children"><div class="content">I was attempting to solve this very problem in the Rust BigDecimal crate this weekend. Is it better to just let it crash with an out of memory error, or have a compile-time constant limit (I was thinking ~8 billion digits) and panic if any operation would exceed that limit with a more specific error-message (does that mean it&#x27;s no longer arbitrary-precision?). Or keep some kind of overflow-state&#x2F;nan, but then the complexity is shifted into checking for NaNs, which I&#x27;ve been trying to avoid.<p>Sounds like Haskell made the right call: put warnings in the docs and steer the user in the right direction. Keeps implementation simple and users in control.<p>To the point of the article, serde_json support is improving in the next version of BigDecimal, so you&#x27;ll be able to decorate your BigDecimal fields and it&#x27;ll parse numeric fields from the JSON source, rather than json -&gt; f64 -&gt; BigDecimal.<p><pre><code>    #[derive(Serialize, Deserialize)]
    pub struct MyStruct {
      #[serde(with = &quot;bigdecimal::serde::json_num&quot;)]
      value: BigDecimal,
    }
</code></pre>
Whether or not this is a good idea is debatable[^], but it&#x27;s certainly something people have been asking for.<p>[^] Is every part of your system, or your users&#x27; systems, going to parse with full precision?</div><br/><div id="39903285" class="c"><input type="checkbox" id="c-39903285" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39900871">parent</a><span>|</span><a href="#39900980">next</a><span>|</span><label class="collapse" for="c-39903285">[-]</label><label class="expand" for="c-39903285">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there is any &quot;sensible limit&quot; which is big enough for everyone&#x27;s needs, but low enough you won&#x27;t blow out memory.<p>An 8 billion digit number is 2.5G? (Did I do my maths right?) All I need to do is shove 1,000 of those in a JSON array, and I&#x27;ll cause an out-of-memory anyway.<p>On the other hand, any limit low enough that I can&#x27;t blow up memory by making an array of 100K or so is going to be too low for some people (including me, I often make numbers of low-million numbers of digits).<p>Providing some method of putting a limit on seems sensible, but maybe just make a LimitedBigDecimal type, so then through the whole program there is a limit on how much memory BigDecimals can take up? (I haven&#x27;t looked at the library in detail, sorry).</div><br/></div></div><div id="39900980" class="c"><input type="checkbox" id="c-39900980" checked=""/><div class="controls bullet"><span class="by">AaronFriel</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39900871">parent</a><span>|</span><a href="#39903285">prev</a><span>|</span><a href="#39901266">next</a><span>|</span><label class="collapse" for="c-39900980">[-]</label><label class="expand" for="c-39900980">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d strongly recommend against this default - it&#x27;s a major blocker for using the Haskell library with web APIs as it transforms JSON RPC into into readily available denial of service attacks.<p>8 billion digits (~100 bits?) is far more than should be used.<p>Would it possible to use const generics to expose a `BigDecimal&lt;N&gt;` or `BigDecimal&lt;MinExp, MaxExp, Precision&gt;` type with bounded precision for serde, and disallow this unsafe `BigDecimal` entirely?<p>If not, I expect BigDecimal will be flagged in a CVE in the near future for causing a denial of service.</div><br/><div id="39902532" class="c"><input type="checkbox" id="c-39902532" checked=""/><div class="controls bullet"><span class="by">akubera</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39900980">parent</a><span>|</span><a href="#39901266">next</a><span>|</span><label class="collapse" for="c-39902532">[-]</label><label class="expand" for="c-39902532">[1 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s the use-case for the rust_decimal crate, which is a 96-bit floating number (~28 decimal digits) which is safer and faster than the bigdecimal crate (which at its heart is a Vec&lt;u64&gt;, unbounded, and geared more for things like calculating sqrt(2) to 10000 places, that kind of thing). Still, people are using it for serialization, and I try to oblige.<p>Having user-set generic limits would be cool, and something I considered when const generics came out, but there&#x27;s a lot more work to do on the basics, and I&#x27;m worried about making the interface too complicated. (And I don&#x27;t want to reimplement everything.) D<p>I also would like a customizable parser struct, with things like localization, allowing grouping-delimiters and such (1_000_000 or 1&#x27;000&#x27;000 or 10,00,000). That could also return some kind of OutOfRange parsing error to disallow &quot;suspicious&quot; values, out of range. I&#x27;m not sure how that to make that generic with the serde parser, but I may some safe limits to the auto serialization code.<p>Especially with JSON, I&#x27;d expect there&#x27;s only two kinds of numbers: normal &quot;human&quot; numbers, and exploit attempts.</div><br/></div></div></div></div><div id="39901266" class="c"><input type="checkbox" id="c-39901266" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39900871">parent</a><span>|</span><a href="#39900980">prev</a><span>|</span><a href="#39901454">next</a><span>|</span><label class="collapse" for="c-39901266">[-]</label><label class="expand" for="c-39901266">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s best if your parser fails.<p>Serde has an interface that allows failing. That one should fail. There is also another that panics, and AFAIK it will automatically panic on any parser that fails.<p>Do not try to handle huge values, do not pretend your parser is total, and do not pretend it&#x27;s a correct value.<p>If you want to create an specialized parser that handles huge numbers, that&#x27;s great. But any general one must fail on them.</div><br/><div id="39902300" class="c"><input type="checkbox" id="c-39902300" checked=""/><div class="controls bullet"><span class="by">akubera</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39901266">parent</a><span>|</span><a href="#39901454">next</a><span>|</span><label class="collapse" for="c-39902300">[-]</label><label class="expand" for="c-39902300">[3 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t about parsing so much as letting the users do &quot;dangerous&quot; math operations. The obvious one is diving by zero, but when the library offers arbitrary precision, addition becomes dangerous with regard to allocating all the digits between a small and large value<p><pre><code>  1e10 + 1e-10 = 10000000000.0000000001
  1e10000000000000000000 + 1e-10000000000000000000 = ...
</code></pre>
It&#x27;s tough to know where to draw the lines between &quot;safety&quot;, &quot;speed&quot;, and &quot;functionality&quot; for the user.<p>[EDIT]: Oh I see, fix the parser to disallow such large numbers from entering the system in the first place, then you don&#x27;t have to worry about adding them together. Yeah that could be a good first step towards safety. Though, I don&#x27;t know how to parametrize the serde call.</div><br/><div id="39902472" class="c"><input type="checkbox" id="c-39902472" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39902300">parent</a><span>|</span><a href="#39901454">next</a><span>|</span><label class="collapse" for="c-39902472">[-]</label><label class="expand" for="c-39902472">[2 more]</label></div><br/><div class="children"><div class="content">If you are using a library with this kind of number representation, computing any rational number with a repeating decimal representation will use up all your memory. 1&#x2F;3=0.33333… It will keep allocating memory to store infinite copies of the digit 3. (In practice it stores it using binary representation but you get the idea.)</div><br/><div id="39902587" class="c"><input type="checkbox" id="c-39902587" checked=""/><div class="controls bullet"><span class="by">akubera</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39902472">parent</a><span>|</span><a href="#39901454">next</a><span>|</span><label class="collapse" for="c-39902587">[-]</label><label class="expand" for="c-39902587">[1 more]</label></div><br/><div class="children"><div class="content">For the Rust crate, there is already an arbitrary limit (defaults to 100 digits) for &quot;unbounded operations&quot; like square_root, inverting, division. That&#x27;s a compile time constant. And there&#x27;s a Context object for runtime-configuration you can set with a precision (stop after `prec` digits).<p>But for addition, the idea is to give the complete number if you do `a + b`, otherwise you could use the context to keep the numbers within your `ctx.add(a, b)`. But after the discussions here, maybe this is too unsafe... and it should use the default precision (or a slightly larger one) in the name of safety? With a compile time flag to disable it? hmm...</div><br/></div></div></div></div></div></div></div></div><div id="39901454" class="c"><input type="checkbox" id="c-39901454" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39900871">parent</a><span>|</span><a href="#39901266">prev</a><span>|</span><a href="#39902083">next</a><span>|</span><label class="collapse" for="c-39901454">[-]</label><label class="expand" for="c-39901454">[2 more]</label></div><br/><div class="children"><div class="content">I think Haskell&#x27;s warning-in-the-doc approach is not strong enough. I&#x27;d be in favor of distinguishing small and huge values using the type system. Have a Rust enum that contains either a small-ish number (the absolute value being 10^100 or less, but the threshold should be configurable preferably as a type parameter) or a huge number. Then the user will be required to handle it. Most of the time the user does not want huge numbers, so they will fail the parse explicitly when they do a match and find it.</div><br/><div id="39902602" class="c"><input type="checkbox" id="c-39902602" checked=""/><div class="controls bullet"><span class="by">akubera</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39901454">parent</a><span>|</span><a href="#39902083">next</a><span>|</span><label class="collapse" for="c-39902602">[-]</label><label class="expand" for="c-39902602">[1 more]</label></div><br/><div class="children"><div class="content">That seems to be the sentiment here. I&#x27;ll take it into consideration. Thanks.</div><br/></div></div></div></div></div></div><div id="39902083" class="c"><input type="checkbox" id="c-39902083" checked=""/><div class="controls bullet"><span class="by">adolph</span><span>|</span><a href="#39899762">parent</a><span>|</span><a href="#39900871">prev</a><span>|</span><a href="#39900236">next</a><span>|</span><label class="collapse" for="c-39902083">[-]</label><label class="expand" for="c-39902083">[2 more]</label></div><br/><div class="children"><div class="content">How does it handle exponent notation?<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36027871">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36027871</a></div><br/><div id="39902226" class="c"><input type="checkbox" id="c-39902226" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39899762">root</a><span>|</span><a href="#39902083">parent</a><span>|</span><a href="#39900236">next</a><span>|</span><label class="collapse" for="c-39902226">[-]</label><label class="expand" for="c-39902226">[1 more]</label></div><br/><div class="children"><div class="content">It just handles it natively. The internal representation <i>is</i> coefficient and exponent. Parsing `1e100` results in storing 1 and 100 separately.  That&#x27;s why parsing huge JSON numbers is not a problem. The problem comes when you do arithmetic on it, which is when it needs to convert the number into the libgmp representation.</div><br/></div></div></div></div></div></div><div id="39900236" class="c"><input type="checkbox" id="c-39900236" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39899762">prev</a><span>|</span><a href="#39901950">next</a><span>|</span><label class="collapse" for="c-39900236">[-]</label><label class="expand" for="c-39900236">[22 more]</label></div><br/><div class="children"><div class="content">One of the first Ajax projects I worked on was multi tenant, and someone decided to solve the industrial espionage problem by using random 64 bit identifiers for all records in the system. You have about a .1% chance of generating an ID that gets truncated in JavaScript, which is just enough that you might make it past MVP before anyone figures out it’s broken, and that’s exactly what happened to us.<p>So we had to go through all the code adding quotes to all the ID fields. That was a giant pain in my ass.</div><br/><div id="39901716" class="c"><input type="checkbox" id="c-39901716" checked=""/><div class="controls bullet"><span class="by">Recursing</span><span>|</span><a href="#39900236">parent</a><span>|</span><a href="#39900452">next</a><span>|</span><label class="collapse" for="c-39901716">[-]</label><label class="expand" for="c-39901716">[4 more]</label></div><br/><div class="children"><div class="content">&gt; You have about a .1% chance of generating an ID that gets truncated in JavaScript<p>I don&#x27;t follow. 1-(Number.MAX_SAFE_INTEGER &#x2F; 2*63) ~ 99.9%, so don&#x27;t you have a &gt;99% chance of generating an ID that gets truncated in js?</div><br/><div id="39901929" class="c"><input type="checkbox" id="c-39901929" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901716">parent</a><span>|</span><a href="#39900452">next</a><span>|</span><label class="collapse" for="c-39901929">[-]</label><label class="expand" for="c-39901929">[3 more]</label></div><br/><div class="children"><div class="content">IEEE 754 can represent integers larger than MAX_SAFE_INTEGER, just not all of them:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Double-precision_floating-point_format#Precision_limitations_on_integer_values" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Double-precision_floating-poin...</a><p>That&#x27;s still going to be a greater than 0.1% chance of hitting a non-representable value though.</div><br/><div id="39902009" class="c"><input type="checkbox" id="c-39902009" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901929">parent</a><span>|</span><a href="#39900452">next</a><span>|</span><label class="collapse" for="c-39902009">[-]</label><label class="expand" for="c-39902009">[2 more]</label></div><br/><div class="children"><div class="content">It’s been a long long time. I may be remembering the ratio wrong, or we might have been clipping the range a bit.</div><br/><div id="39903091" class="c"><input type="checkbox" id="c-39903091" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39902009">parent</a><span>|</span><a href="#39900452">next</a><span>|</span><label class="collapse" for="c-39903091">[-]</label><label class="expand" for="c-39903091">[1 more]</label></div><br/><div class="children"><div class="content">&gt; or we might have been clipping the range a bit<p>Well it&#x27;s a pretty abrupt change.  53 bits work fine, at 54 bits a quarter of numbers get truncated, at 55 it&#x27;s half.</div><br/></div></div></div></div></div></div></div></div><div id="39900452" class="c"><input type="checkbox" id="c-39900452" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#39900236">parent</a><span>|</span><a href="#39901716">prev</a><span>|</span><a href="#39900803">next</a><span>|</span><label class="collapse" for="c-39900452">[-]</label><label class="expand" for="c-39900452">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been burned by a similar issue too. Lesson here is never to use numbers for things you are not planning to do math on. Ids should always be strings.</div><br/><div id="39902204" class="c"><input type="checkbox" id="c-39902204" checked=""/><div class="controls bullet"><span class="by">justinpombrio</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39900452">parent</a><span>|</span><a href="#39901327">next</a><span>|</span><label class="collapse" for="c-39902204">[-]</label><label class="expand" for="c-39902204">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the lesson only that ids shouldn&#x27;t be <i>floats</i>? If they were integers everything would be fine, but JS numbers aren&#x27;t integers, even if they look like them sometimes.</div><br/><div id="39903281" class="c"><input type="checkbox" id="c-39903281" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39902204">parent</a><span>|</span><a href="#39901327">next</a><span>|</span><label class="collapse" for="c-39903281">[-]</label><label class="expand" for="c-39903281">[1 more]</label></div><br/><div class="children"><div class="content">Nah, the lesson is broader than that, cause numbers as IDs have a whole bunch of problems and this is just one of them. Eg Twitter has incrementing number IDs and back when they had this whole ecosystem of 3rd party twitter apps (that they have since ruined), half the apps failed when the IDs became too large to fit into a 32-bit int.<p>If it looks like a number, and it quacks like a number, sooner or later people are going to treat it like a number.</div><br/></div></div></div></div><div id="39901327" class="c"><input type="checkbox" id="c-39901327" checked=""/><div class="controls bullet"><span class="by">greggyb</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39900452">parent</a><span>|</span><a href="#39902204">prev</a><span>|</span><a href="#39900575">next</a><span>|</span><label class="collapse" for="c-39901327">[-]</label><label class="expand" for="c-39901327">[10 more]</label></div><br/><div class="children"><div class="content">Until you want faster joins, in which case, comparisons of integers tend to be much faster on hardware I am aware of than string comparisons.</div><br/><div id="39903288" class="c"><input type="checkbox" id="c-39903288" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901327">parent</a><span>|</span><a href="#39901369">next</a><span>|</span><label class="collapse" for="c-39903288">[-]</label><label class="expand" for="c-39903288">[1 more]</label></div><br/><div class="children"><div class="content">UUIDs are great for this. It’s really just a random 128-bit integer, which makes comparisons about as fast as variable-length integers on modern hardware. And they decode to strings which means no application code or API end-user code is going to assume it’s a number.</div><br/></div></div><div id="39901369" class="c"><input type="checkbox" id="c-39901369" checked=""/><div class="controls bullet"><span class="by">cduzz</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901327">parent</a><span>|</span><a href="#39903288">prev</a><span>|</span><a href="#39901364">next</a><span>|</span><label class="collapse" for="c-39901369">[-]</label><label class="expand" for="c-39901369">[3 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t care.<p>A numeric identity is an identity and so is a string.<p>If you want to math it, it is a number, otherwise... string.<p>&quot;Will you ever want the 95th percentile PID?  Then it is not a number.  Move on.&quot;</div><br/><div id="39901633" class="c"><input type="checkbox" id="c-39901633" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901369">parent</a><span>|</span><a href="#39901364">next</a><span>|</span><label class="collapse" for="c-39901633">[-]</label><label class="expand" for="c-39901633">[2 more]</label></div><br/><div class="children"><div class="content">Double precision floats can&#x27;t represent every 64-bit integer. If you want to math it, what kind of number will you accept?</div><br/><div id="39902098" class="c"><input type="checkbox" id="c-39902098" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901633">parent</a><span>|</span><a href="#39901364">next</a><span>|</span><label class="collapse" for="c-39902098">[-]</label><label class="expand" for="c-39902098">[1 more]</label></div><br/><div class="children"><div class="content">They are saying not to use numbers <i>unless</i> you need to do math with th thing.<p>If you need to do math with the thing, use an appropriate type of number, of course.</div><br/></div></div></div></div></div></div><div id="39901364" class="c"><input type="checkbox" id="c-39901364" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901327">parent</a><span>|</span><a href="#39901369">prev</a><span>|</span><a href="#39900575">next</a><span>|</span><label class="collapse" for="c-39901364">[-]</label><label class="expand" for="c-39901364">[5 more]</label></div><br/><div class="children"><div class="content">We&#x27;re talking about deserialising JSONs in the application server here, nobody stops you from treating ids as numbers on the database side of things.<p>But also, this sounds like a premature optimisation. Most applications will never reach a level where their performance is actually impacted by string comparison, and when you reach that stage, you&#x27;re likely have already thrown out a lot of other common sense stuff like db normalisation to get there, and we shouldn&#x27;t judge &quot;regular people&quot; advice because it doesn&#x27;t usually apply to you anyway.<p>Out of curiosity, have you ever seen an application that was meaningfully impacted by this? How gigantic was it?<p>----<p>Scratch that. I&#x27;ve actually thought about it some more, and now I&#x27;m not 100% sure it&#x27;s premature, I have to investigate further to be sure. Question still stands though.</div><br/><div id="39901715" class="c"><input type="checkbox" id="c-39901715" checked=""/><div class="controls bullet"><span class="by">greggyb</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901364">parent</a><span>|</span><a href="#39903109">next</a><span>|</span><label class="collapse" for="c-39901715">[-]</label><label class="expand" for="c-39901715">[1 more]</label></div><br/><div class="children"><div class="content">I work primarily in data analytics. It tends to become noticeable in my experience as soon as you&#x27;re at a few million records[0] on at least one side of a relationship. Especially as we see more columnar databases in analytics, the row count accounts for more than total data size for this sort of thing.<p>Due to the type of aggregate queries that typify analytics workloads, almost everything turns into a scan, whether it be of the a table, field, or index. Strings occupy more space on disk, or in RAM, so scanning a whole column or table simply takes longer, because you have to shovel more bytes through the CPU. This doesn&#x27;t even take into account the relative CPU time to actually do the comparisons.<p>I&#x27;ve never personally worked with a system that has string keys shorter than 10 [1][2] characters. At that point, regardless of how you pack characters into a register, you&#x27;re occupying more bits with two strings of character data than you would with two 64-bit integers[3]. This shows through in join time.<p>[0]: Even modestly sized companies tend to have at least a few tables that get into the millions of records.<p>[1]: I&#x27;ve heard of systems with shorter string keys<p>[2]: Most systems with string keys I&#x27;ve encountered have more than 10 characters.<p>[3]: The vast majority of systems I&#x27;ve seen since the mid-2010s use 64-bit integers for keys for analytics. 32-bit integers seemed to phase out for new systems I&#x27;ve seen since ~2015, but were more common prior to that.</div><br/></div></div><div id="39903109" class="c"><input type="checkbox" id="c-39903109" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901364">parent</a><span>|</span><a href="#39901715">prev</a><span>|</span><a href="#39903483">next</a><span>|</span><label class="collapse" for="c-39903109">[-]</label><label class="expand" for="c-39903109">[1 more]</label></div><br/><div class="children"><div class="content">&gt; when you reach that stage, you&#x27;re likely have already thrown out a lot of other common sense stuff like db normalisation to get there<p>Don&#x27;t <i>most</i> databases set a length limit on ID strings?<p>If you&#x27;re setting a length limit, and it&#x27;s made out of digits with no leading zeroes, then you might as well store it as a number.  Is there a downside?</div><br/></div></div><div id="39903483" class="c"><input type="checkbox" id="c-39903483" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901364">parent</a><span>|</span><a href="#39903109">prev</a><span>|</span><a href="#39902034">next</a><span>|</span><label class="collapse" for="c-39903483">[-]</label><label class="expand" for="c-39903483">[1 more]</label></div><br/><div class="children"><div class="content">People use integer data types for primary keys in databases all the time. There is nothing wrong with it.</div><br/></div></div><div id="39902034" class="c"><input type="checkbox" id="c-39902034" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39901364">parent</a><span>|</span><a href="#39903483">prev</a><span>|</span><a href="#39900575">next</a><span>|</span><label class="collapse" for="c-39902034">[-]</label><label class="expand" for="c-39902034">[1 more]</label></div><br/><div class="children"><div class="content">Mostly a deal of defaults on our stack. Tweaked a couple of things in a few places to stop the bleeding. Then had to fix all of the tests.</div><br/></div></div></div></div></div></div></div></div><div id="39900803" class="c"><input type="checkbox" id="c-39900803" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#39900236">parent</a><span>|</span><a href="#39900452">prev</a><span>|</span><a href="#39901950">next</a><span>|</span><label class="collapse" for="c-39900803">[-]</label><label class="expand" for="c-39900803">[3 more]</label></div><br/><div class="children"><div class="content">Why would the value get truncated?</div><br/><div id="39901146" class="c"><input type="checkbox" id="c-39901146" checked=""/><div class="controls bullet"><span class="by">hatthew</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39900803">parent</a><span>|</span><a href="#39900893">next</a><span>|</span><label class="collapse" for="c-39901146">[-]</label><label class="expand" for="c-39901146">[1 more]</label></div><br/><div class="children"><div class="content">FTA: JavaScript&#x27;s built-in JSON implementation is limited to the range and precision of a double.<p>Obviously, not all int64 values are representable in float64 (double).</div><br/></div></div><div id="39900893" class="c"><input type="checkbox" id="c-39900893" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#39900236">root</a><span>|</span><a href="#39900803">parent</a><span>|</span><a href="#39901146">prev</a><span>|</span><a href="#39901950">next</a><span>|</span><label class="collapse" for="c-39900893">[-]</label><label class="expand" for="c-39900893">[1 more]</label></div><br/><div class="children"><div class="content">not all numbers are representable as the particular type of floating point number that js uses<p>nice pics here: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Floating-point_arithmetic" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Floating-point_arithmetic</a></div><br/></div></div></div></div></div></div><div id="39901950" class="c"><input type="checkbox" id="c-39901950" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#39900236">prev</a><span>|</span><a href="#39903562">next</a><span>|</span><label class="collapse" for="c-39901950">[-]</label><label class="expand" for="c-39901950">[5 more]</label></div><br/><div class="children"><div class="content">Long story short: don&#x27;t use JSON numbers to represent money or monetary rates. Always use decimals encoded as string. It&#x27;s surprising how many APIs fall short of this basic bar.</div><br/><div id="39903434" class="c"><input type="checkbox" id="c-39903434" checked=""/><div class="controls bullet"><span class="by">incorrecthorse</span><span>|</span><a href="#39901950">parent</a><span>|</span><a href="#39903240">next</a><span>|</span><label class="collapse" for="c-39903434">[-]</label><label class="expand" for="c-39903434">[3 more]</label></div><br/><div class="children"><div class="content">No. Use integers to store the smallest money decimal, and store the currency name alongside.</div><br/><div id="39903556" class="c"><input type="checkbox" id="c-39903556" checked=""/><div class="controls bullet"><span class="by">sjducb</span><span>|</span><a href="#39901950">root</a><span>|</span><a href="#39903434">parent</a><span>|</span><a href="#39903240">next</a><span>|</span><label class="collapse" for="c-39903556">[-]</label><label class="expand" for="c-39903556">[2 more]</label></div><br/><div class="children"><div class="content">What happens if you’re sure that four decimal places is the smallest, then suddenly a partner system starts sending you 6 decimal places?</div><br/><div id="39903613" class="c"><input type="checkbox" id="c-39903613" checked=""/><div class="controls bullet"><span class="by">Macha</span><span>|</span><a href="#39901950">root</a><span>|</span><a href="#39903556">parent</a><span>|</span><a href="#39903240">next</a><span>|</span><label class="collapse" for="c-39903613">[-]</label><label class="expand" for="c-39903613">[1 more]</label></div><br/><div class="children"><div class="content">Precision should be part of the spec for integrations. With the integer multiple of minimal unit, that makes it clear in the API what it is.<p>e.g. it doesn&#x27;t make sense to support billing in sub-currency unit amounts just by allowing it in your API definition, as you&#x27;re going to need to batch that until you get a billable amount which is larger than the fee for issuing a bill. Even for something like $100,000.1234, the bank doesn&#x27;t let you do a transfer for 0.34c.<p>For cases where sub-currency unit billing is a thing, it should be agreed what the minimal unit is (e.g. advertising has largely standardised on millicents)</div><br/></div></div></div></div></div></div><div id="39903240" class="c"><input type="checkbox" id="c-39903240" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39901950">parent</a><span>|</span><a href="#39903434">prev</a><span>|</span><a href="#39903562">next</a><span>|</span><label class="collapse" for="c-39903240">[-]</label><label class="expand" for="c-39903240">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the language. On the JVM you are fine. With Javascript, doing math on big numbers is probably going to end in tears unless you know what you are doing. Either way, have some tests for this and make sure your code is doing what you expect.<p>Encoding numbers as string because you are using a language and parser that can&#x27;t deal with numbers properly (even 64 bit doubles), is a bit of a hack. Basically the rest of the world giving up because Javascript can&#x27;t get its shit together is not a great plan.</div><br/></div></div></div></div><div id="39903562" class="c"><input type="checkbox" id="c-39903562" checked=""/><div class="controls bullet"><span class="by">datagreed</span><span>|</span><a href="#39901950">prev</a><span>|</span><a href="#39899206">next</a><span>|</span><label class="collapse" for="c-39903562">[-]</label><label class="expand" for="c-39903562">[1 more]</label></div><br/><div class="children"><div class="content">That font &gt;.&lt;</div><br/></div></div><div id="39899206" class="c"><input type="checkbox" id="c-39899206" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#39903562">prev</a><span>|</span><a href="#39898859">next</a><span>|</span><label class="collapse" for="c-39899206">[-]</label><label class="expand" for="c-39899206">[16 more]</label></div><br/><div class="children"><div class="content">I tend to end up encoding everything as an integer (multiply by 1000, 10000 etc) and then turn it back into a float&#x2F;decimal on decode. For instance if I am building a system dealing with dollar amounts I will store cent amounts everywhere, communicate cent amounts over the wire, etc. then treat it as a presentation concern to render it as a dollar amount.</div><br/><div id="39903594" class="c"><input type="checkbox" id="c-39903594" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#39899206">parent</a><span>|</span><a href="#39899391">next</a><span>|</span><label class="collapse" for="c-39903594">[-]</label><label class="expand" for="c-39903594">[2 more]</label></div><br/><div class="children"><div class="content">For money, that&#x27;s a sane setup.<p>But do note, that in currency, there are multiple, actively used currencies that have zero, three, five (rare) or even eight (BTC) decimals. That some decimals cannot be divided by all numbers (e.g. only 0.5)<p>Point being: floats are dangerously naive for currency. But integers are naive too. You&#x27;ll most probably want a &quot;currency&quot; or &quot;money&quot; type. Some Value Object, or even Domain Model.<p>XML offered all this, but in JSON there&#x27;s little to convey this, other than some nested &quot;object&quot; with at least the decimal amt (as int), and the ISO4217 currency. And maybe -depending on how HATEOAS you wanna be- a formatting string to be used in locales, a rule on divisibility and&#x2F;or how many decimal places your int or decimal might be.<p>(FWIW, I built backbends for financial systems and apps. It gets worse than this if you do math on the currencies. Some legislatioins or bookkeeping rules state that calculation uses more or less decimals. E.g. that ($10&#x2F;3)*3 == $10 vs == $9.99. or that $0.03&#x2F;2 == 0.1 + 0.2, e.g. when splitting a bill. This stuff is complex, but real domain logic)</div><br/><div id="39903610" class="c"><input type="checkbox" id="c-39903610" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#39899206">root</a><span>|</span><a href="#39903594">parent</a><span>|</span><a href="#39899391">next</a><span>|</span><label class="collapse" for="c-39903610">[-]</label><label class="expand" for="c-39903610">[1 more]</label></div><br/><div class="children"><div class="content">When I say dangerously naive, I mean in a way that people can go to jail¹ for &quot;loosing&quot; or &quot;inventing&quot; cents. Which your software will do if you use floats.<p>¹IANAL. But this was told when legal people looked at our architecture.</div><br/></div></div></div></div><div id="39899391" class="c"><input type="checkbox" id="c-39899391" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#39899206">parent</a><span>|</span><a href="#39903594">prev</a><span>|</span><a href="#39899562">next</a><span>|</span><label class="collapse" for="c-39899391">[-]</label><label class="expand" for="c-39899391">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth bearing in mind when you do that that the largest integer that is &quot;generally safe&quot; in JSON is 2^53-1, so if you scale by a factor of 10000 you&#x27;re taking 13-14 more bits off that maximum. That leaves you about 2^40, or about a trillion, before you may start losing precision or seeing systems disagree about the decoded values. Whether that&#x27;s a problem depends on your domain.</div><br/></div></div><div id="39899562" class="c"><input type="checkbox" id="c-39899562" checked=""/><div class="controls bullet"><span class="by">nedt</span><span>|</span><a href="#39899206">parent</a><span>|</span><a href="#39899391">prev</a><span>|</span><a href="#39900254">next</a><span>|</span><label class="collapse" for="c-39899562">[-]</label><label class="expand" for="c-39899562">[2 more]</label></div><br/><div class="children"><div class="content">So basically you use fixpoint numbers. Especially for currency that’s a very good idea anyway, because of rounding errors, even more so in IEEE 754</div><br/><div id="39899635" class="c"><input type="checkbox" id="c-39899635" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#39899206">root</a><span>|</span><a href="#39899562">parent</a><span>|</span><a href="#39900254">next</a><span>|</span><label class="collapse" for="c-39899635">[-]</label><label class="expand" for="c-39899635">[1 more]</label></div><br/><div class="children"><div class="content">Pedantically, IEEE 754 defines decimal floating point formats (like decimal128) which are appropriate for representing currency. Representing currency in non-integer values in any of the binary floating point formats is indeed a recipe for disaster though.</div><br/></div></div></div></div><div id="39900254" class="c"><input type="checkbox" id="c-39900254" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#39899206">parent</a><span>|</span><a href="#39899562">prev</a><span>|</span><a href="#39899320">next</a><span>|</span><label class="collapse" for="c-39900254">[-]</label><label class="expand" for="c-39900254">[3 more]</label></div><br/><div class="children"><div class="content">The problem with that (which I have seen in practice) is that you are essentially hard coding the maximum precision you will accept for every client that needs to interpret your JSON.<p>For example, you say you store monetary amounts as cents. What if you needed to store US gas prices, which are normally priced in amounts ending in 9&#x2F;10ths of a cent? If you want to keep your values as integers you need to change your precision, which will likely mess up a lot of your code.</div><br/><div id="39901664" class="c"><input type="checkbox" id="c-39901664" checked=""/><div class="controls bullet"><span class="by">felixfbecker</span><span>|</span><a href="#39899206">root</a><span>|</span><a href="#39900254">parent</a><span>|</span><a href="#39901002">next</a><span>|</span><label class="collapse" for="c-39901664">[-]</label><label class="expand" for="c-39901664">[1 more]</label></div><br/><div class="children"><div class="content">and different currencies have different default precisions. So if you&#x27;re dealing with multiple currencies, now you need both client and server to have a map of all currency precisions for formatting purposes that they agree on.<p>What&#x27;s worse is that these things can also change over time and there is sometimes disagreement over what the canonical value is.<p>E.g. ISO 4217 (used by Safari, Firefox and NodeJS) will say that the Indonesian Rupiah (IDR) uses 2 decimal digits, while Unicode CLDR (used by Chrome) will say that they use 0 decimal digits. The former is the more &quot;legalistic&quot; definition, while the latter matches how people use the currency in reality.<p>This is not a real issue if you transfer amounts as decimal strings and then pass those to the Intl API for formatting (the formatting will just be different but still <i>correct</i>), but it&#x27;s catastrophic if you use scaled-up integers (all amounts will be off by magnitudes).<p>For this reason I would always store currency amounts in an appropriate DECIMAL type in the DB and send currency amounts as strings over the wire.</div><br/></div></div><div id="39901002" class="c"><input type="checkbox" id="c-39901002" checked=""/><div class="controls bullet"><span class="by">NateEag</span><span>|</span><a href="#39899206">root</a><span>|</span><a href="#39900254">parent</a><span>|</span><a href="#39901664">prev</a><span>|</span><a href="#39899320">next</a><span>|</span><label class="collapse" for="c-39901002">[-]</label><label class="expand" for="c-39901002">[1 more]</label></div><br/><div class="children"><div class="content">This is a good point.<p>It&#x27;s not widely known, but US gasoline prices are actually in a defined currency unit, the mill (<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Mill_(currency)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Mill_(currency)</a>).<p>For most purposes, using mills as the base unit would be sufficient resolution.</div><br/></div></div></div></div><div id="39899320" class="c"><input type="checkbox" id="c-39899320" checked=""/><div class="controls bullet"><span class="by">Supermancho</span><span>|</span><a href="#39899206">parent</a><span>|</span><a href="#39900254">prev</a><span>|</span><a href="#39900162">next</a><span>|</span><label class="collapse" for="c-39899320">[-]</label><label class="expand" for="c-39899320">[1 more]</label></div><br/><div class="children"><div class="content">I have tried to encode all non-trivial numbers as strings. If it&#x27;s too big (or small), or if it&#x27;s a float, I&#x27;ll have to change my JSON schema. Bake the need to decode numbers into the transforms for consistency.</div><br/></div></div><div id="39900162" class="c"><input type="checkbox" id="c-39900162" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#39899206">parent</a><span>|</span><a href="#39899320">prev</a><span>|</span><a href="#39899314">next</a><span>|</span><label class="collapse" for="c-39900162">[-]</label><label class="expand" for="c-39900162">[4 more]</label></div><br/><div class="children"><div class="content">Makes sense for dollars, but for anything like graphics or physics I&#x27;d consider a power of two like 1,024 as the fixed-point factor instead.<p>My intuition tells me that &quot;x * 1000 &#x2F; 1000 == x&quot; might not be true for all numbers if you&#x27;re using floats.</div><br/><div id="39900768" class="c"><input type="checkbox" id="c-39900768" checked=""/><div class="controls bullet"><span class="by">beryilma</span><span>|</span><a href="#39899206">root</a><span>|</span><a href="#39900162">parent</a><span>|</span><a href="#39899314">next</a><span>|</span><label class="collapse" for="c-39900768">[-]</label><label class="expand" for="c-39900768">[3 more]</label></div><br/><div class="children"><div class="content">A sure sign of an inexperienced programmer in numerical computing is when they check for equality to zero of a floating-point number as<p>if (x == 0) ...<p>instead of something like<p>if (abs(x) &lt; eps) ...<p>where eps is a suitably defined small number.</div><br/><div id="39903413" class="c"><input type="checkbox" id="c-39903413" checked=""/><div class="controls bullet"><span class="by">esrauch</span><span>|</span><a href="#39899206">root</a><span>|</span><a href="#39900768">parent</a><span>|</span><a href="#39902182">next</a><span>|</span><label class="collapse" for="c-39903413">[-]</label><label class="expand" for="c-39903413">[1 more]</label></div><br/><div class="children"><div class="content">I think funny enough a sure sign of an inexperienced programmer in bigco application programming is the other way around, that they wrongly learn a metal model of &quot;floating point is approximate, never ever do ==&quot; in school.</div><br/></div></div><div id="39902182" class="c"><input type="checkbox" id="c-39902182" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39899206">root</a><span>|</span><a href="#39900768">parent</a><span>|</span><a href="#39903413">prev</a><span>|</span><a href="#39899314">next</a><span>|</span><label class="collapse" for="c-39902182">[-]</label><label class="expand" for="c-39902182">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes it is fine. For example, reference BLAS will check if the input scalars in DGEMM are exactly zero, for<p><pre><code>    C &lt;- alpha*AB + beta*C 
</code></pre>
If beta is exactly 0, you don’t have to read C, just write to it.<p>The key here is that beta is likely to be an exact value that is entered as a constant, and detecting it allows for a worthwhile optimization.</div><br/></div></div></div></div></div></div><div id="39899314" class="c"><input type="checkbox" id="c-39899314" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#39899206">parent</a><span>|</span><a href="#39900162">prev</a><span>|</span><a href="#39900042">next</a><span>|</span><label class="collapse" for="c-39899314">[-]</label><label class="expand" for="c-39899314">[1 more]</label></div><br/><div class="children"><div class="content">This is great as long as you always make clear which value is pre post encoding. I remember one of my first production bugs was giving users 100 times the credit they actually bought. Oops.</div><br/></div></div><div id="39900042" class="c"><input type="checkbox" id="c-39900042" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#39899206">parent</a><span>|</span><a href="#39899314">prev</a><span>|</span><a href="#39898859">next</a><span>|</span><label class="collapse" for="c-39900042">[-]</label><label class="expand" for="c-39900042">[1 more]</label></div><br/><div class="children"><div class="content">I often store it as smaller than cents, because anything with division or a basket of summed parts with taxes can start to get funky if you round down (and some places have laws about that.)</div><br/></div></div></div></div><div id="39898859" class="c"><input type="checkbox" id="c-39898859" checked=""/><div class="controls bullet"><span class="by">EdSchouten</span><span>|</span><a href="#39899206">prev</a><span>|</span><a href="#39900378">next</a><span>|</span><label class="collapse" for="c-39898859">[-]</label><label class="expand" for="c-39898859">[6 more]</label></div><br/><div class="children"><div class="content">I think the description for Go is inaccurate&#x2F;incomplete. You can call this function to instruct the decoder to leave numbers in unparsed string form:<p><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;encoding&#x2F;json#Decoder.UseNumber" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;encoding&#x2F;json#Decoder.UseNumber</a><p>That allows you to capture&#x2F;forward numbers without any loss of precision.</div><br/><div id="39898955" class="c"><input type="checkbox" id="c-39898955" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#39898859">parent</a><span>|</span><a href="#39900378">next</a><span>|</span><label class="collapse" for="c-39898955">[-]</label><label class="expand" for="c-39898955">[5 more]</label></div><br/><div class="children"><div class="content">I have added this note, thanks! In the blog I am mostly trying to show the behavior you get using the (maybe defacto) stdlib with its default configuration, but this is useful data to call out.</div><br/><div id="39900825" class="c"><input type="checkbox" id="c-39900825" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#39898859">root</a><span>|</span><a href="#39898955">parent</a><span>|</span><a href="#39900378">next</a><span>|</span><label class="collapse" for="c-39900825">[-]</label><label class="expand" for="c-39900825">[4 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re going to extend Go the courtesy of customizing the parser, oughtn&#x27;t you do the same for Python (and all the languages)?<p>To wit, Python&#x27;s json module has `parse_float` and `parse_int` hooks:<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;json.html#encoders-and-decoders" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;json.html#encoders-and-dec...</a><p>Example:<p><pre><code>  &gt;&gt;&gt; json.loads(&#x27;{&quot;int&quot;:12345,&quot;float&quot;:123.45}&#x27;, parse_int=str, parse_float=str)
  {&#x27;int&#x27;: &#x27;12345&#x27;, &#x27;float&#x27;: &#x27;123.45&#x27;}
</code></pre>
FWIW, when I&#x27;ve cared about interop and controlled the schema, I&#x27;ve specified JSON strings for numbers, along with the range, precision, and representation. This is no worse (nor better) than using RFC 3339 for dates.</div><br/><div id="39900915" class="c"><input type="checkbox" id="c-39900915" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#39898859">root</a><span>|</span><a href="#39900825">parent</a><span>|</span><a href="#39900378">next</a><span>|</span><label class="collapse" for="c-39900915">[-]</label><label class="expand" for="c-39900915">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just a JS guy trying to understand the world around me and documenting what I find, not trying to be discourteous (or even courteous). I&#x27;ll add the note about Python, thanks for calling it out. FWIW JS does not have a similar capability so I can&#x27;t add a note there.</div><br/><div id="39902929" class="c"><input type="checkbox" id="c-39902929" checked=""/><div class="controls bullet"><span class="by">jbboehr</span><span>|</span><a href="#39898859">root</a><span>|</span><a href="#39900915">parent</a><span>|</span><a href="#39900981">next</a><span>|</span><label class="collapse" for="c-39902929">[-]</label><label class="expand" for="c-39902929">[1 more]</label></div><br/><div class="children"><div class="content">&gt; FWIW JS does not have a similar capability so I can&#x27;t add a note there<p>This example on MDN seems to indicate that you can, am I misunderstanding it?<p><pre><code>  const bigJSON = &#x27;{&quot;gross_gdp&quot;: 12345678901234567890}&#x27;;
  const bigObj = JSON.parse(bigJSON, (key, value, context) =&gt; {
    if (key === &quot;gross_gdp&quot;) {
      &#x2F;&#x2F; Ignore the value because it has already lost precision
      return BigInt(context.source);
    }
    return value;
  });
</code></pre>
[0]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;JSON&#x2F;parse" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a></div><br/></div></div><div id="39900981" class="c"><input type="checkbox" id="c-39900981" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#39898859">root</a><span>|</span><a href="#39900915">parent</a><span>|</span><a href="#39902929">prev</a><span>|</span><a href="#39900378">next</a><span>|</span><label class="collapse" for="c-39900981">[-]</label><label class="expand" for="c-39900981">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough! Thank you for the writeup.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39900378" class="c"><input type="checkbox" id="c-39900378" checked=""/><div class="controls bullet"><span class="by">bevekspldnw</span><span>|</span><a href="#39898859">prev</a><span>|</span><a href="#39900865">next</a><span>|</span><label class="collapse" for="c-39900378">[-]</label><label class="expand" for="c-39900378">[1 more]</label></div><br/><div class="children"><div class="content">Try to get a DECIMAL value out of a Postgres database into a JSON API response and you’ll learn all this and more in the most painful way possible!</div><br/></div></div><div id="39900865" class="c"><input type="checkbox" id="c-39900865" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#39900378">prev</a><span>|</span><a href="#39899815">next</a><span>|</span><label class="collapse" for="c-39900865">[-]</label><label class="expand" for="c-39900865">[1 more]</label></div><br/><div class="children"><div class="content">Other values one could test for:<p>- <i>“+1”</i> (not a valid number, according to ECMA-404 and RFC-8259)<p>- <i>“+0”</i> (also not a valid number, but trickier than <i>“+1”</i> because IEEE floats have <i>“+0”</i> and <i>“-0”</i>)<p>- <i>“070”</i> (not a valid number, but may get parsed as octal 56)<p>- <i>“1.”</i> (not a valid number in json)<p>- <i>“.1”</i> (not a valid number in json)<p>- <i>“0E-0”</i> (a valid number in json)<p>There probably are others.</div><br/></div></div><div id="39899815" class="c"><input type="checkbox" id="c-39899815" checked=""/><div class="controls bullet"><span class="by">egwor</span><span>|</span><a href="#39900865">prev</a><span>|</span><a href="#39903522">next</a><span>|</span><label class="collapse" for="c-39899815">[-]</label><label class="expand" for="c-39899815">[4 more]</label></div><br/><div class="children"><div class="content">I think the thing folk miss is when there’s an error like divide by zero, or the calculation would return NaN. I feel like this is the main gap&#x2F;concern with using JSON and it seems to be rarely discussed.</div><br/><div id="39900364" class="c"><input type="checkbox" id="c-39900364" checked=""/><div class="controls bullet"><span class="by">olejorgenb</span><span>|</span><a href="#39899815">parent</a><span>|</span><a href="#39903522">next</a><span>|</span><label class="collapse" for="c-39900364">[-]</label><label class="expand" for="c-39900364">[3 more]</label></div><br/><div class="children"><div class="content">Agreed, this can be a pain. Python by default serialize and de-serialize the `NaN` literal, making you pay some cleanup cost once you need to interopt with other systems. (same for `Inf`)<p>Say what you want about NaN, but IEEE 754 is the facto way of dealing with floating points in computers and even if NaNs and Infs are a bit &quot;fringe&quot; it&#x27;s unfortunate that the most popular serialization format can not represent these.</div><br/><div id="39902058" class="c"><input type="checkbox" id="c-39902058" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#39899815">root</a><span>|</span><a href="#39900364">parent</a><span>|</span><a href="#39903522">next</a><span>|</span><label class="collapse" for="c-39902058">[-]</label><label class="expand" for="c-39902058">[2 more]</label></div><br/><div class="children"><div class="content">There are so many things that are poorly thought out or underspecified in JSON, it&#x27;s amazing that it got so widely adopted for interop. No wonder that it became a perpetual source of serialization bugs.</div><br/><div id="39903340" class="c"><input type="checkbox" id="c-39903340" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39899815">root</a><span>|</span><a href="#39902058">parent</a><span>|</span><a href="#39903522">next</a><span>|</span><label class="collapse" for="c-39903340">[-]</label><label class="expand" for="c-39903340">[1 more]</label></div><br/><div class="children"><div class="content">Especially annoying given that they could have been easily adopted. Infinity could&#x27;ve been encoded as `1&#x2F;0` (among most other possibilities). NaN could&#x27;ve been encoded as `0&#x2F;0` (again, among most other possibilities). JSON doesn&#x27;t allow all possible JavaScript literals anyway, so these encodings might have been worked if they were somehow standardized.</div><br/></div></div></div></div></div></div></div></div><div id="39903522" class="c"><input type="checkbox" id="c-39903522" checked=""/><div class="controls bullet"><span class="by">billpg</span><span>|</span><a href="#39899815">prev</a><span>|</span><a href="#39900007">next</a><span>|</span><label class="collapse" for="c-39903522">[-]</label><label class="expand" for="c-39903522">[1 more]</label></div><br/><div class="children"><div class="content">&quot;ID numbers start from 2^53 and are allocated sequentially including odd numbers that are not compatible with &quot;double&quot; types. Please ensure you are reading this value as a 64-bit integer.&quot;</div><br/></div></div><div id="39900007" class="c"><input type="checkbox" id="c-39900007" checked=""/><div class="controls bullet"><span class="by">nigeltao</span><span>|</span><a href="#39903522">prev</a><span>|</span><a href="#39900844">next</a><span>|</span><label class="collapse" for="c-39900007">[-]</label><label class="expand" for="c-39900007">[5 more]</label></div><br/><div class="children"><div class="content">When I wrote my jsonptr tool a few years ago, I noticed that some JSON libraries (in both C++ and Rust) don&#x27;t even do &quot;parse a string of decimal digits as a float64&quot; properly. I don&#x27;t mean that in the &quot;0.3 isn&#x27;t exactly representable; have 0.30000000000000004 instead&quot; sense.<p>I mean that rapidjson (C++) parsed the string &quot;0.99999999999999999&quot; as the number 1.0000000000000003. Apart from just looking weird, it&#x27;s a different float64 bit-pattern: 0x3FF0000000000000 vs 0x3FF0000000000001.<p>Similarly, serde-json (Rust) parsed &quot;122.416294033786585&quot; as 122.4162940337866. This isn&#x27;t as obvious a difference, but the bit-patterns differ by one: 0x405E9AA48FBB2888 vs 0x405E9AA48FBB2889. Serde-json does have an &quot;float_roundtrip&quot; feature flag, but it&#x27;s opt-in, not enabled by default.<p>For details, look for &quot;rapidjson issue #1773&quot; and &quot;serde_json issue #707&quot; at <a href="https:&#x2F;&#x2F;nigeltao.github.io&#x2F;blog&#x2F;2020&#x2F;jsonptr.html" rel="nofollow">https:&#x2F;&#x2F;nigeltao.github.io&#x2F;blog&#x2F;2020&#x2F;jsonptr.html</a></div><br/><div id="39901255" class="c"><input type="checkbox" id="c-39901255" checked=""/><div class="controls bullet"><span class="by">lofenfew</span><span>|</span><a href="#39900007">parent</a><span>|</span><a href="#39900275">next</a><span>|</span><label class="collapse" for="c-39901255">[-]</label><label class="expand" for="c-39901255">[3 more]</label></div><br/><div class="children"><div class="content">this requires multiple precision to do properly and isn&#x27;t useful most of the time. its odd to describe this as &quot;not properly&quot;. you might say &quot;with exact rounding&quot;, but that makes it clearer that this isn&#x27;t that useful a feature, especially since we usually expect floats to be inexact in the first place.</div><br/><div id="39902078" class="c"><input type="checkbox" id="c-39902078" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#39900007">root</a><span>|</span><a href="#39901255">parent</a><span>|</span><a href="#39903150">next</a><span>|</span><label class="collapse" for="c-39902078">[-]</label><label class="expand" for="c-39902078">[1 more]</label></div><br/><div class="children"><div class="content">With JSON, there&#x27;s essentially no such thing as &quot;properly&quot; when it comes to parsing numbers, since the spec doesn&#x27;t limit the ability of the implementation to constrain width and precision. It only says that float64 is <i>common</i> and therefore &quot;good interoperability can be achieved by implementations that expect no more precision or range than these provide&quot;, but note the complete absence of any guarantees in that wording.<p>The only sane thing with JSON is to avoid numbers altogether and just use decimal-encoded strings. This forces the person parsing it on the other end to at least look up the actual limits defined by your schema.</div><br/></div></div><div id="39903150" class="c"><input type="checkbox" id="c-39903150" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39900007">root</a><span>|</span><a href="#39901255">parent</a><span>|</span><a href="#39902078">prev</a><span>|</span><a href="#39900275">next</a><span>|</span><label class="collapse" for="c-39903150">[-]</label><label class="expand" for="c-39903150">[1 more]</label></div><br/><div class="children"><div class="content">Rounding by more than an ULP is pretty bad.  I don&#x27;t think it&#x27;s odd at all to describe rapidjson&#x27;s behavior as improper.<p>At least 122.416294033786585 is <i>between</i> ...888 and ...889, though it&#x27;s much closer to the former.</div><br/></div></div></div></div><div id="39900275" class="c"><input type="checkbox" id="c-39900275" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#39900007">parent</a><span>|</span><a href="#39901255">prev</a><span>|</span><a href="#39900844">next</a><span>|</span><label class="collapse" for="c-39900275">[-]</label><label class="expand" for="c-39900275">[1 more]</label></div><br/><div class="children"><div class="content">Oh wow. So serde_json doesn&#x27;t roundtrip floats by default, it uses some imprecise faster algorithm <a href="https:&#x2F;&#x2F;github.com&#x2F;serde-rs&#x2F;json&#x2F;issues&#x2F;707">https:&#x2F;&#x2F;github.com&#x2F;serde-rs&#x2F;json&#x2F;issues&#x2F;707</a><p>Good thing there&#x27;s msgpack I guess.</div><br/></div></div></div></div><div id="39900844" class="c"><input type="checkbox" id="c-39900844" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#39900007">prev</a><span>|</span><a href="#39900066">next</a><span>|</span><label class="collapse" for="c-39900844">[-]</label><label class="expand" for="c-39900844">[1 more]</label></div><br/><div class="children"><div class="content">My opinion is that a safe approach is to use either 52-bit integer number or 64-bit floating number to keep JavaScript compatibility. JavaScript is too important and at the same time, the errors are too terrific (JS will silently round to the nearest 52-bit integer number which could lead to various exploits) to skip on that. If you need anything else, just use strings.</div><br/></div></div><div id="39900066" class="c"><input type="checkbox" id="c-39900066" checked=""/><div class="controls bullet"><span class="by">ctrw</span><span>|</span><a href="#39900844">prev</a><span>|</span><a href="#39899210">next</a><span>|</span><label class="collapse" for="c-39900066">[-]</label><label class="expand" for="c-39900066">[1 more]</label></div><br/><div class="children"><div class="content">I still get a laugh of ecma 404. The first time I looked it up I refreshed the page a large number of times before I realized it wasn&#x27;t an error.</div><br/></div></div><div id="39899210" class="c"><input type="checkbox" id="c-39899210" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#39900066">prev</a><span>|</span><a href="#39898836">next</a><span>|</span><label class="collapse" for="c-39899210">[-]</label><label class="expand" for="c-39899210">[17 more]</label></div><br/><div class="children"><div class="content">It&#x27;s weird that any parser that loses digits is tolerated. A parser that forces strings into uppercase US-ASCII never would be.</div><br/><div id="39902113" class="c"><input type="checkbox" id="c-39902113" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#39899210">parent</a><span>|</span><a href="#39899276">next</a><span>|</span><label class="collapse" for="c-39902113">[-]</label><label class="expand" for="c-39902113">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s tolerated because the JSON spec explicitly allows it:<p><pre><code>   This specification allows implementations to set limits on the range
   and precision of numbers accepted.  Since software that implements
   IEEE 754 binary64 (double precision) numbers [IEEE754] is generally
   available and widely used, good interoperability can be achieved by
   implementations that expect no more precision or range than these
   provide, in the sense that implementations will approximate JSON
   numbers within the expected precision.  A JSON number such as 1E400
   or 3.141592653589793238462643383279 may indicate potential
   interoperability problems, since it suggests that the software that
   created it expects receiving software to have greater capabilities
   for numeric magnitude and precision than is widely available.

   Note that when such software is used, numbers that are integers and
   are in the range [-(2**53)+1, (2**53)-1] are interoperable in the
   sense that implementations will agree exactly on their numeric
   values.
</code></pre>
And yes, this is completely insane for a format that supposed to be specifically for serialization and interop. Needless to say, the industry has enthusiastically adopted it to the point where it became the standard.<p>I miss XML these days. Sure, it was verbose and had a bunch of different and probably excessive numeric types defined for XML Schema... but at least they were <i>well-defined</i> (<a href="https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xmlschema-2&#x2F;#built-in-datatypes" rel="nofollow">https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xmlschema-2&#x2F;#built-in-datatypes</a>). And, on the other hand, without a schema, all you had were strings. Either way, no mismatched expectations.</div><br/></div></div><div id="39899276" class="c"><input type="checkbox" id="c-39899276" checked=""/><div class="controls bullet"><span class="by">msm_</span><span>|</span><a href="#39899210">parent</a><span>|</span><a href="#39902113">prev</a><span>|</span><a href="#39899375">next</a><span>|</span><label class="collapse" for="c-39899276">[-]</label><label class="expand" for="c-39899276">[14 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true for every floating point number in every programming language you have ever used, though.<p><pre><code>    $ python3
    Python 3.10.13 (main, Aug 24 2023, 12:59:26) [GCC 12.2.0] on linux
    Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
    &gt;&gt;&gt; 100000.000000000017
    100000.00000000001</code></pre></div><br/><div id="39899439" class="c"><input type="checkbox" id="c-39899439" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899276">parent</a><span>|</span><a href="#39899564">next</a><span>|</span><label class="collapse" for="c-39899439">[-]</label><label class="expand" for="c-39899439">[5 more]</label></div><br/><div class="children"><div class="content">This is why Decimal exists:<p><pre><code>  Python 3.8.10 (default, Nov 22 2023, 10:22:35) 
  [GCC 9.4.0] on linux
  Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
  &gt;&gt;&gt; from decimal import Decimal
  &gt;&gt;&gt; Decimal(&#x27;100000.000000000017&#x27;)
  Decimal(&#x27;100000.000000000017&#x27;)
</code></pre>
For example:<p><pre><code>  &gt;&gt;&gt; import json
  &gt;&gt;&gt; json.loads(&#x27;{&quot;a&quot;: 100000.000000000017}&#x27;)
  {&#x27;a&#x27;: 100000.00000000001}
  &gt;&gt;&gt; json.loads(&#x27;{&quot;a&quot;: 100000.000000000017}&#x27;, parse_float=Decimal)
  {&#x27;a&#x27;: Decimal(&#x27;100000.000000000017&#x27;)}</code></pre></div><br/><div id="39902610" class="c"><input type="checkbox" id="c-39902610" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899439">parent</a><span>|</span><a href="#39899669">next</a><span>|</span><label class="collapse" for="c-39902610">[-]</label><label class="expand" for="c-39902610">[1 more]</label></div><br/><div class="children"><div class="content">Decimal is not arbitrary precision, though. It has many of the same issues, you&#x27;ll just see them in different places.<p><pre><code>  &gt;&gt;&gt; Decimal(&#x27;100000.00000000000000000000017&#x27;) + Decimal(&#x27;1&#x27;)
  Decimal(&#x27;100001.0000000000000000000002&#x27;)</code></pre></div><br/></div></div><div id="39899669" class="c"><input type="checkbox" id="c-39899669" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899439">parent</a><span>|</span><a href="#39902610">prev</a><span>|</span><a href="#39899623">next</a><span>|</span><label class="collapse" for="c-39899669">[-]</label><label class="expand" for="c-39899669">[1 more]</label></div><br/><div class="children"><div class="content">And not every programming language offers a Decimal type and on most of those, there’s usually a performance penalty associated with it not to mention issues of interoperability and developer knowledge of its existence. For financial calculations, usually using integers with an implicit decimal offset (e.g., US currency amounts being expressed in cents rather than dollars), while other contexts will often determine that the inherent inaccuracy of IEEE floating types is a non-issue. The biggest potential problem lies in treating values that act kind of like numbers and look like numbers as numbers, e.g., Dewey Decimal classification numbers or the topic in a Library of Congress classification.¹<p>⸻<p>1. This is a bit on my mind lately as I discovered that LibraryThing’s sort by LoC classification seems to be broken so I exported my library (discovering that they export as ISO8859-1 with no option for UTF-8) and wrote a custom sorter for LOC classification codes for use in finally arranging the books on my shelves after my move last year.</div><br/></div></div><div id="39899623" class="c"><input type="checkbox" id="c-39899623" checked=""/><div class="controls bullet"><span class="by">cerved</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899439">parent</a><span>|</span><a href="#39899669">prev</a><span>|</span><a href="#39899564">next</a><span>|</span><label class="collapse" for="c-39899623">[-]</label><label class="expand" for="c-39899623">[2 more]</label></div><br/><div class="children"><div class="content">but serializing&#x2F;deserializing decimal using the json module is futile</div><br/><div id="39901939" class="c"><input type="checkbox" id="c-39901939" checked=""/><div class="controls bullet"><span class="by">yawaramin</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899623">parent</a><span>|</span><a href="#39899564">next</a><span>|</span><label class="collapse" for="c-39901939">[-]</label><label class="expand" for="c-39901939">[1 more]</label></div><br/><div class="children"><div class="content">Why is it futile? It can be serialized&#x2F;deserialized perfectly through its string representation.</div><br/></div></div></div></div></div></div><div id="39899564" class="c"><input type="checkbox" id="c-39899564" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899276">parent</a><span>|</span><a href="#39899439">prev</a><span>|</span><a href="#39899375">next</a><span>|</span><label class="collapse" for="c-39899564">[-]</label><label class="expand" for="c-39899564">[8 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s true for every floating point number in every programming language you have ever used, though.<p>Alright, if &quot;you&quot; have only ever used python.  In C, for example, we have hexadecimal floating point literals that represent all floats and doubles exactly (including infinities and nans that make the json parser fail miserably).</div><br/><div id="39899683" class="c"><input type="checkbox" id="c-39899683" checked=""/><div class="controls bullet"><span class="by">legobmw99</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899564">parent</a><span>|</span><a href="#39899784">next</a><span>|</span><label class="collapse" for="c-39899683">[-]</label><label class="expand" for="c-39899683">[1 more]</label></div><br/><div class="children"><div class="content">If you use the same syntax as OP, C’s parser will also round that literal. The existence of a hex literal for floats is something orthogonal</div><br/></div></div><div id="39899784" class="c"><input type="checkbox" id="c-39899784" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899564">parent</a><span>|</span><a href="#39899683">prev</a><span>|</span><a href="#39899991">next</a><span>|</span><label class="collapse" for="c-39899784">[-]</label><label class="expand" for="c-39899784">[5 more]</label></div><br/><div class="children"><div class="content">&gt; we have hexadecimal floating point literals that represent all floats and doubles exactly<p>How do you do that?<p>A couple of resources I found but which I’m not sure if are about exactly what you speak of<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;65480947&#x2F;is-ieee-754-representation-used-in-c&#x2F;65481061" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;65480947&#x2F;is-ieee-754-rep...</a><p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Hex-Floats.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Hex-Floats.html</a><p>Furthermore, what exactly do you mean by “all floats and doubles exactly”?</div><br/><div id="39899936" class="c"><input type="checkbox" id="c-39899936" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899784">parent</a><span>|</span><a href="#39899991">next</a><span>|</span><label class="collapse" for="c-39899936">[-]</label><label class="expand" for="c-39899936">[4 more]</label></div><br/><div class="children"><div class="content">Yes, I was talking about what is described in your resources.  You can do this:<p><pre><code>    &#x2F;&#x2F; define a floating-point literal in hex and print it in decimal
    float x = 0x1p-8;          &#x2F;&#x2F; x = 1.0&#x2F;256
    printf(&quot;x = %g\n&quot;, x);     &#x2F;&#x2F; prints 0.00390625
    
    &#x2F;&#x2F; define a floating point literal in decimal and print it in various ways
    float y = 0.3;             &#x2F;&#x2F; non-representable, rounded to closest float
    printf(&quot;y = %g\n&quot;, y);     &#x2F;&#x2F; 0.3 (the %g format does some heuristics)
    printf(&quot;y = %.10f\n&quot;, y);  &#x2F;&#x2F; 0.3000000119
    printf(&quot;y = %.20f\n&quot;, y);  &#x2F;&#x2F; 0.30000001192092895508
    printf(&quot;y = %a\n&quot;, f);     &#x2F;&#x2F; 0x1.333334p-2</code></pre></div><br/><div id="39900008" class="c"><input type="checkbox" id="c-39900008" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39899936">parent</a><span>|</span><a href="#39899991">next</a><span>|</span><label class="collapse" for="c-39900008">[-]</label><label class="expand" for="c-39900008">[3 more]</label></div><br/><div class="children"><div class="content">So for example if you make a variable that has the value parent commenter used<p>100000.000000000017<p>And then you print it.<p>Does it preserve the exact value?</div><br/><div id="39900104" class="c"><input type="checkbox" id="c-39900104" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39900008">parent</a><span>|</span><a href="#39899991">next</a><span>|</span><label class="collapse" for="c-39900104">[-]</label><label class="expand" for="c-39900104">[2 more]</label></div><br/><div class="children"><div class="content">Your question is ambiguous for two different reasons.   First, this value is not representable as a floating-point number, so there&#x27;s no way that you can even store it in a float.  Second, once you have a float variable, you can print it in many different ways.  So, the answer to your question is, irremediably, &quot;it depends what you mean by <i>exact value</i>&quot;.<p>If you print your variable with the %a format, then YES, the exact value is preserved and there is no loss of information.  The problem is that the literal that you wrote cannot be represented exactly.  But this is hardly a fault of the floats.  Ints have exactly the same problem:<p><pre><code>    int x = 2.5;   &#x2F;&#x2F; x gets the value 2
    int y = 7&#x2F;3;   &#x2F;&#x2F; same thing</code></pre></div><br/><div id="39900140" class="c"><input type="checkbox" id="c-39900140" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#39899210">root</a><span>|</span><a href="#39900104">parent</a><span>|</span><a href="#39899991">next</a><span>|</span><label class="collapse" for="c-39900140">[-]</label><label class="expand" for="c-39900140">[1 more]</label></div><br/><div class="children"><div class="content">So in other words, is it fair to say that this situation is not much different from what you get with Python?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39899375" class="c"><input type="checkbox" id="c-39899375" checked=""/><div class="controls bullet"><span class="by">tpm</span><span>|</span><a href="#39899210">parent</a><span>|</span><a href="#39899276">prev</a><span>|</span><a href="#39898836">next</a><span>|</span><label class="collapse" for="c-39899375">[-]</label><label class="expand" for="c-39899375">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;0.30000000000000004.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;0.30000000000000004.com&#x2F;</a><p>Although it would be good to move in the direction of using a BigDecimal equivalent by default when ingesting unknown data.</div><br/></div></div></div></div><div id="39898836" class="c"><input type="checkbox" id="c-39898836" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39899210">prev</a><span>|</span><a href="#39899179">next</a><span>|</span><label class="collapse" for="c-39898836">[-]</label><label class="expand" for="c-39898836">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I-JSON messages SHOULD NOT include numbers that express greater magnitude or precision than an IEEE 754 double precision number provides<p>I&#x27;m confused by this.<p>What is the precision of 0.1, relative to IEEE 754?<p>If I read it correctly, that statement is saying:<p><pre><code>  json_number_precision(json_number) &lt;= ieee_754_precision
</code></pre>
^ How do I calculate these values?</div><br/><div id="39899046" class="c"><input type="checkbox" id="c-39899046" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#39898836">parent</a><span>|</span><a href="#39899096">next</a><span>|</span><label class="collapse" for="c-39899046">[-]</label><label class="expand" for="c-39899046">[1 more]</label></div><br/><div class="children"><div class="content">I think the spec just means, assume IEEE 754. In the case of 0.1, which cannot be represented exactly, software should assume that `0.1` will be represented as `0.100000000000000005551115123126`. Depending on `0.1` being parsed as the exact value `0.1` is not widely interoperable.</div><br/></div></div><div id="39899096" class="c"><input type="checkbox" id="c-39899096" checked=""/><div class="controls bullet"><span class="by">ebolyen</span><span>|</span><a href="#39898836">parent</a><span>|</span><a href="#39899046">prev</a><span>|</span><a href="#39901874">next</a><span>|</span><label class="collapse" for="c-39899096">[-]</label><label class="expand" for="c-39899096">[1 more]</label></div><br/><div class="children"><div class="content">Relatedly, what about integers like 9007199254740995. Is that a legal integer since it rounds to 9007199254740996?<p>It does seem unclear what it means to exceed precision (given rounding is such an expected part of the way we use these numbers). Magnitude feels easier as at least you definitely run out of bits in the exponent.</div><br/></div></div><div id="39901874" class="c"><input type="checkbox" id="c-39901874" checked=""/><div class="controls bullet"><span class="by">hugh-avherald</span><span>|</span><a href="#39898836">parent</a><span>|</span><a href="#39899096">prev</a><span>|</span><a href="#39899179">next</a><span>|</span><label class="collapse" for="c-39901874">[-]</label><label class="expand" for="c-39901874">[1 more]</label></div><br/><div class="children"><div class="content">I think the spec is saying that it is <i>the message</i> that should not express greater magnitude or precision, not &#x27;the number&#x27;.<p>So including the string &quot;0.1&quot; in a message is fine because v = 0.1 implies 0.05 &lt; v &lt; 0.15, but including 0.100000000000000000000000000000000000 would not be.</div><br/></div></div></div></div><div id="39899179" class="c"><input type="checkbox" id="c-39899179" checked=""/><div class="controls bullet"><span class="by">frizlab</span><span>|</span><a href="#39898836">prev</a><span>|</span><a href="#39899018">next</a><span>|</span><label class="collapse" for="c-39899179">[-]</label><label class="expand" for="c-39899179">[3 more]</label></div><br/><div class="children"><div class="content">It’s missing Swift tests, but otherwise it’s a great post.</div><br/><div id="39899560" class="c"><input type="checkbox" id="c-39899560" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#39899179">parent</a><span>|</span><a href="#39899018">next</a><span>|</span><label class="collapse" for="c-39899560">[-]</label><label class="expand" for="c-39899560">[2 more]</label></div><br/><div class="children"><div class="content">If you would like to contribute Swift tests, I would be happy to take it! You can send a PR into this document, updating the data tables and adding a code sample at the end: <a href="https:&#x2F;&#x2F;github.com&#x2F;bterlson&#x2F;blog&#x2F;blob&#x2F;main&#x2F;content&#x2F;blog&#x2F;what-is-a-json-number.md">https:&#x2F;&#x2F;github.com&#x2F;bterlson&#x2F;blog&#x2F;blob&#x2F;main&#x2F;content&#x2F;blog&#x2F;what...</a>. No need to test openapi-tools swift codegen unless you really want to!</div><br/><div id="39900219" class="c"><input type="checkbox" id="c-39900219" checked=""/><div class="controls bullet"><span class="by">frizlab</span><span>|</span><a href="#39899179">root</a><span>|</span><a href="#39899560">parent</a><span>|</span><a href="#39899018">next</a><span>|</span><label class="collapse" for="c-39900219">[-]</label><label class="expand" for="c-39900219">[1 more]</label></div><br/><div class="children"><div class="content">I’m having a lot on my plate currently, but I’m adding this to my TODO list!</div><br/></div></div></div></div></div></div><div id="39899018" class="c"><input type="checkbox" id="c-39899018" checked=""/><div class="controls bullet"><span class="by">timvdalen</span><span>|</span><a href="#39899179">prev</a><span>|</span><a href="#39899043">next</a><span>|</span><label class="collapse" for="c-39899018">[-]</label><label class="expand" for="c-39899018">[2 more]</label></div><br/><div class="children"><div class="content">A little off topic, but fun to see that someone else has adopted that magical CSS theme! (<a href="https:&#x2F;&#x2F;css.winterveil.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;css.winterveil.net&#x2F;</a>)</div><br/></div></div><div id="39899043" class="c"><input type="checkbox" id="c-39899043" checked=""/><div class="controls bullet"><span class="by">ape4</span><span>|</span><a href="#39899018">prev</a><span>|</span><label class="collapse" for="c-39899043">[-]</label><label class="expand" for="c-39899043">[6 more]</label></div><br/><div class="children"><div class="content">Since JSON is so widely used it should be modified to support more types - Mongo DB&#x27;s Extended JSON supports all the BSON (Binary) types:<p><pre><code>    Array
    Binary
    Date
    Decimal128
    Document
    Double
    Int32
    Int64
    MaxKey
    MinKey
    ObjectId
    Regular Expression
    Timestamp
</code></pre>
<a href="https:&#x2F;&#x2F;www.mongodb.com&#x2F;docs&#x2F;manual&#x2F;reference&#x2F;mongodb-extended-json&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.mongodb.com&#x2F;docs&#x2F;manual&#x2F;reference&#x2F;mongodb-extend...</a></div><br/><div id="39899089" class="c"><input type="checkbox" id="c-39899089" checked=""/><div class="controls bullet"><span class="by">bterlson</span><span>|</span><a href="#39899043">parent</a><span>|</span><a href="#39900931">next</a><span>|</span><label class="collapse" for="c-39899089">[-]</label><label class="expand" for="c-39899089">[1 more]</label></div><br/><div class="children"><div class="content">JS is likely to get a hook to be able to handle serialization&#x2F;deserialization of such values without swapping out the entire implementation[1]. Native support for these types, without additional code or configuration, would likely break the Internet badly, so is unlikely to happen unfortunately.<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-json-parse-with-source">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-json-parse-with-source</a></div><br/></div></div><div id="39900931" class="c"><input type="checkbox" id="c-39900931" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#39899043">parent</a><span>|</span><a href="#39899089">prev</a><span>|</span><a href="#39899225">next</a><span>|</span><label class="collapse" for="c-39900931">[-]</label><label class="expand" for="c-39900931">[1 more]</label></div><br/><div class="children"><div class="content">JSON is not the place to be so fussy about number widths, and things like MaxKey and 24-hex-value ObjectId would be ridiculous.</div><br/></div></div><div id="39899225" class="c"><input type="checkbox" id="c-39899225" checked=""/><div class="controls bullet"><span class="by">apantel</span><span>|</span><a href="#39899043">parent</a><span>|</span><a href="#39900931">prev</a><span>|</span><a href="#39899898">next</a><span>|</span><label class="collapse" for="c-39899225">[-]</label><label class="expand" for="c-39899225">[2 more]</label></div><br/><div class="children"><div class="content">Much more valuable than any such extension would be a way to annotate types and byte lengths of keys and values so that parsers could work more efficiently.  I’ve spent a lot of time making a fast JSON parser in Java and the thing that makes it so hard is you don’t know how many bytes anything is, or what type.  It’s hard to do better than naive byte-by-byte parsing.</div><br/><div id="39900873" class="c"><input type="checkbox" id="c-39900873" checked=""/><div class="controls bullet"><span class="by">your_fin</span><span>|</span><a href="#39899043">root</a><span>|</span><a href="#39899225">parent</a><span>|</span><a href="#39899898">next</a><span>|</span><label class="collapse" for="c-39900873">[-]</label><label class="expand" for="c-39900873">[1 more]</label></div><br/><div class="children"><div class="content">If you control the underlying data, I must reccomend Amazon Ion! Its text format is a strict superset of JSON, but they also maintain binary format that will round-trip data and is designed for efficient scanning. There&#x27;s even prefixed annotations if you want them :)<p>It also specs proper decimal values, mitigating the issues presented in the OP.<p><a href="https:&#x2F;&#x2F;amazon-ion.github.io&#x2F;ion-docs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;amazon-ion.github.io&#x2F;ion-docs&#x2F;</a></div><br/></div></div></div></div><div id="39899898" class="c"><input type="checkbox" id="c-39899898" checked=""/><div class="controls bullet"><span class="by">zilti</span><span>|</span><a href="#39899043">parent</a><span>|</span><a href="#39899225">prev</a><span>|</span><label class="collapse" for="c-39899898">[-]</label><label class="expand" for="c-39899898">[1 more]</label></div><br/><div class="children"><div class="content">Or maaaybe use XML for such cases</div><br/></div></div></div></div></div></div></div></div></div></body></html>