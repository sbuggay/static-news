<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735722057169" as="style"/><link rel="stylesheet" href="styles.css?v=1735722057169"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://curiouscoding.nl/posts/static-search-tree/">Static search trees: faster than binary search</a> <span class="domain">(<a href="https://curiouscoding.nl">curiouscoding.nl</a>)</span></div><div class="subtext"><span>atombender</span> | <span>104 comments</span></div><br/><div><div id="42563407" class="c"><input type="checkbox" id="c-42563407" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#42563161">next</a><span>|</span><label class="collapse" for="c-42563407">[-]</label><label class="expand" for="c-42563407">[8 more]</label></div><br/><div class="children"><div class="content">One dimension that is not explored is partitioning the <i>queries</i> in batches. The primary cost is doing lookups on the out-of-cache table, so if you have a sufficiently large amount of queries you can resolve a couple layers of the tree in one step while those layers are in cache, grouping them based on where they land deeper in the tree, and then resolving all those queries that touch the same deeper part of the tree in one batch as well.<p>In theory, with an infinitely large amount of input queries you will never have to do an out-of-cache lookup, it can be completely amortized away into linear scans.<p>That said, you now end up with a bunch of results that need to be put back into the correct output order, which likely makes it not worth it. But if the operation can be fused into a reduction (e.g. find the <i>sum</i> of the binary search results) or the output order does not matter in some other way then all of a sudden it might make sense.</div><br/><div id="42563508" class="c"><input type="checkbox" id="c-42563508" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#42563407">parent</a><span>|</span><a href="#42564103">next</a><span>|</span><label class="collapse" for="c-42563508">[-]</label><label class="expand" for="c-42563508">[1 more]</label></div><br/><div class="children"><div class="content">Interesting stuff, definitely the kind of real world optimization that happens when you’re able to look at actual access characteristics rather highly abstracted models.<p>At one level you could just be saving the results into a hashtable to bubble them out again, but at the extreme end the lookup is actually spread across multiple machines in a cluster, so it’s more like throwing the query to the proper one with the right chunk of the index, along with instructions about where the final RPC is supposed to go with the result.</div><br/></div></div><div id="42564103" class="c"><input type="checkbox" id="c-42564103" checked=""/><div class="controls bullet"><span class="by">tmyklebu</span><span>|</span><a href="#42563407">parent</a><span>|</span><a href="#42563508">prev</a><span>|</span><a href="#42564253">next</a><span>|</span><label class="collapse" for="c-42564103">[-]</label><label class="expand" for="c-42564103">[3 more]</label></div><br/><div class="children"><div class="content">There are theory papers on &quot;buffer trees&quot;---B-trees where each node is augmented with an O(B)-length array of pending updates and queries.  I believe there were also some attempts at building SQL databases based on them.  It sounds like you&#x27;re reaching for the same trick.</div><br/><div id="42564169" class="c"><input type="checkbox" id="c-42564169" checked=""/><div class="controls bullet"><span class="by">koverstreet</span><span>|</span><a href="#42563407">root</a><span>|</span><a href="#42564103">parent</a><span>|</span><a href="#42564253">next</a><span>|</span><label class="collapse" for="c-42564169">[-]</label><label class="expand" for="c-42564169">[2 more]</label></div><br/><div class="children"><div class="content">that&#x27;s a hybrid compacting data structure: compacting within the btree node, normal btree topology otherwise.<p>And it works much better than pure compacting (i.e. the leveldb lineage), because you avoid lock contention at the root on multithreaded update workloads, and the compaction&#x2F;resort is much lower overhead when it fits in l2.<p>incidentally, there&#x27;s a filesystem that uses this technique.</div><br/><div id="42564274" class="c"><input type="checkbox" id="c-42564274" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42563407">root</a><span>|</span><a href="#42564169">parent</a><span>|</span><a href="#42564253">next</a><span>|</span><label class="collapse" for="c-42564274">[-]</label><label class="expand" for="c-42564274">[1 more]</label></div><br/><div class="children"><div class="content">&gt; incidentally, there&#x27;s a filesystem that uses this technique.<p>BetrFS?</div><br/></div></div></div></div></div></div><div id="42564253" class="c"><input type="checkbox" id="c-42564253" checked=""/><div class="controls bullet"><span class="by">natmaka</span><span>|</span><a href="#42563407">parent</a><span>|</span><a href="#42564103">prev</a><span>|</span><a href="#42564175">next</a><span>|</span><label class="collapse" for="c-42564253">[-]</label><label class="expand" for="c-42564253">[1 more]</label></div><br/><div class="children"><div class="content">It enhances the throughput (on average everyone waits less) at the price of a higher max latency (some, who posted a request mobilizing a very-recently-out-of-cache-index, will wait way, way more...), isn&#x27;t it?  In the real world those worst cases quite often kill such optimization.<p>The (data size &#x2F; cache size) ratio and queries local (in time) dispersion are key.</div><br/></div></div><div id="42564175" class="c"><input type="checkbox" id="c-42564175" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#42563407">parent</a><span>|</span><a href="#42564253">prev</a><span>|</span><a href="#42563882">next</a><span>|</span><label class="collapse" for="c-42564175">[-]</label><label class="expand" for="c-42564175">[1 more]</label></div><br/><div class="children"><div class="content">This works really well for subset testing, especially if sets sorted.<p>Walk the larger tree, using the smaller tree.</div><br/></div></div><div id="42563882" class="c"><input type="checkbox" id="c-42563882" checked=""/><div class="controls bullet"><span class="by">koverstreet</span><span>|</span><a href="#42563407">parent</a><span>|</span><a href="#42564175">prev</a><span>|</span><a href="#42563161">next</a><span>|</span><label class="collapse" for="c-42563882">[-]</label><label class="expand" for="c-42563882">[1 more]</label></div><br/><div class="children"><div class="content">That presumes there&#x27;s both locality in your queries, and it&#x27;s not an online system - result latency doesn&#x27;t matter much.<p>That&#x27;s not terribly common.</div><br/></div></div></div></div><div id="42563161" class="c"><input type="checkbox" id="c-42563161" checked=""/><div class="controls bullet"><span class="by">wolfgangK</span><span>|</span><a href="#42563407">prev</a><span>|</span><a href="#42563357">next</a><span>|</span><label class="collapse" for="c-42563161">[-]</label><label class="expand" for="c-42563161">[3 more]</label></div><br/><div class="children"><div class="content">Amazingly thorough ! I love how the author leaves no stone unturned. I had no idea you could do the kind of low level efficiency shaving in Rust.
I wonder how a C++ implementation with <a href="https:&#x2F;&#x2F;github.com&#x2F;jfalcou&#x2F;eve">https:&#x2F;&#x2F;github.com&#x2F;jfalcou&#x2F;eve</a> would compare.</div><br/><div id="42563187" class="c"><input type="checkbox" id="c-42563187" checked=""/><div class="controls bullet"><span class="by">curiouscoding</span><span>|</span><a href="#42563161">parent</a><span>|</span><a href="#42563254">next</a><span>|</span><label class="collapse" for="c-42563187">[-]</label><label class="expand" for="c-42563187">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!
It&#x27;s somewhat tiring to not have loose ends, but I agree it pays off :)<p>Doing this stuff in Rust is absolutely possible, and I&#x27;d do it again since my C++ days are now past me, but the endless transmuting between portable-simd types, plain rust arrays, and intrinsic types <i>is</i> quite annoying.<p>Also rust is not made for convenient raw pointer arithmetic. There plain C would be much more to the point.</div><br/></div></div><div id="42563254" class="c"><input type="checkbox" id="c-42563254" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#42563161">parent</a><span>|</span><a href="#42563187">prev</a><span>|</span><a href="#42563357">next</a><span>|</span><label class="collapse" for="c-42563254">[-]</label><label class="expand" for="c-42563254">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Compare to highway as well<p><a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway</a></div><br/></div></div></div></div><div id="42563357" class="c"><input type="checkbox" id="c-42563357" checked=""/><div class="controls bullet"><span class="by">sujayakar</span><span>|</span><a href="#42563161">prev</a><span>|</span><a href="#42563348">next</a><span>|</span><label class="collapse" for="c-42563357">[-]</label><label class="expand" for="c-42563357">[1 more]</label></div><br/><div class="children"><div class="content">this is unbelievably cool. ~27ns overhead for searching for a u32 in a 4GB set in memory is unreal.<p>it&#x27;s interesting that the wins for batching start diminishing at 8. I&#x27;m curious then how the subsequent optimizations fare with batch size 8 (rather than 128).<p>smaller batch sizes are nice since it determines how much request throughput we&#x27;d need to saturate this system. at batch size 8, we need 1s &#x2F; ~30ns * 8 = 266M searches per second to fully utilize this algorithm.<p>the multithreading results are also interesting -- going from 1 to 6 threads only improves overhead by 4x. curious how this fares on a much higher core count machine.</div><br/></div></div><div id="42563348" class="c"><input type="checkbox" id="c-42563348" checked=""/><div class="controls bullet"><span class="by">koverstreet</span><span>|</span><a href="#42563357">prev</a><span>|</span><a href="#42563600">next</a><span>|</span><label class="collapse" for="c-42563348">[-]</label><label class="expand" for="c-42563348">[1 more]</label></div><br/><div class="children"><div class="content">Nifty thing about eytzinger trees is that there&#x27;s a formula for converting from a node index to its position in an inorder traversal.<p>This is useful if your primary keystore is a normal sorted set of keys - easier to work with - you then don&#x27;t need to store explicit pointers.<p>Also, he didn&#x27;t mention that with eytzinger you can prefetch multiple loop iterations in advance - use 1-based indexing so that sibling nodes line up nicely on cachelines.</div><br/></div></div><div id="42563600" class="c"><input type="checkbox" id="c-42563600" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#42563348">prev</a><span>|</span><a href="#42564293">next</a><span>|</span><label class="collapse" for="c-42563600">[-]</label><label class="expand" for="c-42563600">[2 more]</label></div><br/><div class="children"><div class="content">All this nattering about rust and C++, and then there&#x27;s me thinking about how to do it in Common Lisp, possibly keeping the simd bits.</div><br/><div id="42564428" class="c"><input type="checkbox" id="c-42564428" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#42563600">parent</a><span>|</span><a href="#42564293">next</a><span>|</span><label class="collapse" for="c-42564428">[-]</label><label class="expand" for="c-42564428">[1 more]</label></div><br/><div class="children"><div class="content">FWIW, I’d love to read a blog post about that, too.</div><br/></div></div></div></div><div id="42564293" class="c"><input type="checkbox" id="c-42564293" checked=""/><div class="controls bullet"><span class="by">DerSaidin</span><span>|</span><a href="#42563600">prev</a><span>|</span><a href="#42564616">next</a><span>|</span><label class="collapse" for="c-42564293">[-]</label><label class="expand" for="c-42564293">[1 more]</label></div><br/><div class="children"><div class="content">I think there is an error in 1.7 figure 3:  Layer 1 should have a 10 instead of a 12.<p>Edit: Also, 1.3 figure 1: Should the y-axis label be &quot;Inverse throughput&quot; to match later figures?</div><br/></div></div><div id="42564616" class="c"><input type="checkbox" id="c-42564616" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42564293">prev</a><span>|</span><a href="#42563895">next</a><span>|</span><label class="collapse" for="c-42564616">[-]</label><label class="expand" for="c-42564616">[1 more]</label></div><br/><div class="children"><div class="content">Is binary search on su ch large integer data sets common? I guess maybe time series data. But I would think that this isn’t amenable to representing strings?</div><br/></div></div><div id="42563895" class="c"><input type="checkbox" id="c-42563895" checked=""/><div class="controls bullet"><span class="by">openquery</span><span>|</span><a href="#42564616">prev</a><span>|</span><a href="#42563450">next</a><span>|</span><label class="collapse" for="c-42563895">[-]</label><label class="expand" for="c-42563895">[1 more]</label></div><br/><div class="children"><div class="content">This is really interesting and a thorough write up. Thanks to the author for sharing their work.<p>Whenever I read about super low-level optimisation, my immediate feeling is that of gratitude to the author for spending so much time shaving off nanoseconds which the entire SE community gets to enjoy.<p>I wonder how much time humanity has collectively saved simply as a result of how all these optimisations stack up.</div><br/></div></div><div id="42563450" class="c"><input type="checkbox" id="c-42563450" checked=""/><div class="controls bullet"><span class="by">NooneAtAll3</span><span>|</span><a href="#42563895">prev</a><span>|</span><a href="#42563332">next</a><span>|</span><label class="collapse" for="c-42563450">[-]</label><label class="expand" for="c-42563450">[2 more]</label></div><br/><div class="children"><div class="content">I wish graph did not show 2 values with the same blue color</div><br/><div id="42563467" class="c"><input type="checkbox" id="c-42563467" checked=""/><div class="controls bullet"><span class="by">jasonjmcghee</span><span>|</span><a href="#42563450">parent</a><span>|</span><a href="#42563332">next</a><span>|</span><label class="collapse" for="c-42563467">[-]</label><label class="expand" for="c-42563467">[1 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t only the one graph - there&#x27;s another graph that has a whole spectrum of blue colors - nearly impossible to tell which is which without going in with an eye drop tool.<p>I found this to really detract from an otherwise interesting post.</div><br/></div></div></div></div><div id="42563332" class="c"><input type="checkbox" id="c-42563332" checked=""/><div class="controls bullet"><span class="by">estebarb</span><span>|</span><a href="#42563450">prev</a><span>|</span><a href="#42563464">next</a><span>|</span><label class="collapse" for="c-42563332">[-]</label><label class="expand" for="c-42563332">[1 more]</label></div><br/><div class="children"><div class="content">Recently I tried to optimize a set implementation and found that interpolation search works quite well, being competitive with HashSet in C# (both single digit ns for my use case), with zero memory overhead. Unfortunately, it only works well with uniform data, so I guess I&#x27;ll give static search trees a try. This explanation was clear and extremelly well detailed.</div><br/></div></div><div id="42563464" class="c"><input type="checkbox" id="c-42563464" checked=""/><div class="controls bullet"><span class="by">owenthejumper</span><span>|</span><a href="#42563332">prev</a><span>|</span><a href="#42563495">next</a><span>|</span><label class="collapse" for="c-42563464">[-]</label><label class="expand" for="c-42563464">[1 more]</label></div><br/><div class="children"><div class="content">Elastic Binary Trees <a href="https:&#x2F;&#x2F;wtarreau.blogspot.com&#x2F;2011&#x2F;12&#x2F;elastic-binary-trees-ebtree.html?m=1" rel="nofollow">https:&#x2F;&#x2F;wtarreau.blogspot.com&#x2F;2011&#x2F;12&#x2F;elastic-binary-trees-e...</a></div><br/></div></div><div id="42563495" class="c"><input type="checkbox" id="c-42563495" checked=""/><div class="controls bullet"><span class="by">purple-leafy</span><span>|</span><a href="#42563464">prev</a><span>|</span><a href="#42563085">next</a><span>|</span><label class="collapse" for="c-42563495">[-]</label><label class="expand" for="c-42563495">[1 more]</label></div><br/><div class="children"><div class="content">cant understand the comp sci stuff yet, but love the way this site looks</div><br/></div></div><div id="42563085" class="c"><input type="checkbox" id="c-42563085" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#42563495">prev</a><span>|</span><a href="#42563683">next</a><span>|</span><label class="collapse" for="c-42563085">[-]</label><label class="expand" for="c-42563085">[1 more]</label></div><br/><div class="children"><div class="content">suffix-array-searching&#x2F;static-search-tree&#x2F;src&#x2F;s_tree.rs: <a href="https:&#x2F;&#x2F;github.com&#x2F;RagnarGrootKoerkamp&#x2F;suffix-array-searching&#x2F;blob&#x2F;master&#x2F;static-search-tree&#x2F;src&#x2F;s_tree.rs">https:&#x2F;&#x2F;github.com&#x2F;RagnarGrootKoerkamp&#x2F;suffix-array-searchin...</a> partitioned_s_tree.rs: <a href="https:&#x2F;&#x2F;github.com&#x2F;RagnarGrootKoerkamp&#x2F;suffix-array-searching&#x2F;blob&#x2F;master&#x2F;static-search-tree&#x2F;src&#x2F;partitioned_s_tree.rs">https:&#x2F;&#x2F;github.com&#x2F;RagnarGrootKoerkamp&#x2F;suffix-array-searchin...</a></div><br/></div></div><div id="42563683" class="c"><input type="checkbox" id="c-42563683" checked=""/><div class="controls bullet"><span class="by">colesantiago</span><span>|</span><a href="#42563085">prev</a><span>|</span><a href="#42563115">next</a><span>|</span><label class="collapse" for="c-42563683">[-]</label><label class="expand" for="c-42563683">[2 more]</label></div><br/><div class="children"><div class="content">This is a great new interview question for junior and senior software engineering candidates.<p>Definitely going to use this for our next round of interviews.</div><br/><div id="42564242" class="c"><input type="checkbox" id="c-42564242" checked=""/><div class="controls bullet"><span class="by">butterlettuce</span><span>|</span><a href="#42563683">parent</a><span>|</span><a href="#42563115">next</a><span>|</span><label class="collapse" for="c-42564242">[-]</label><label class="expand" for="c-42564242">[1 more]</label></div><br/><div class="children"><div class="content">Please don’t. Just test us on how to center a div.</div><br/></div></div></div></div><div id="42563115" class="c"><input type="checkbox" id="c-42563115" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563683">prev</a><span>|</span><label class="collapse" for="c-42563115">[-]</label><label class="expand" for="c-42563115">[77 more]</label></div><br/><div class="children"><div class="content">This would have been easier for a larger number of people to read if it had been in C or Python.</div><br/><div id="42563280" class="c"><input type="checkbox" id="c-42563280" checked=""/><div class="controls bullet"><span class="by">unrealhoang</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563172">next</a><span>|</span><label class="collapse" for="c-42563280">[-]</label><label class="expand" for="c-42563280">[12 more]</label></div><br/><div class="children"><div class="content">What a weird thing to complain about. The Rust code in TFA are purely arithmetic and imperative function calls. Any C developer that is good enough to care about the algorithm mentioned will have no issue reading such Rust code, heck, they could even throw the code to chatgpt to translate for them no problem.<p>Such a good and detailed article that packed with techniques that are applicable everywhere yet the complaints are: “but rust”.<p>Regarding Python, how could such optimizations be implemented in Python? Generating LLVM bytecodes directly aside.</div><br/><div id="42563931" class="c"><input type="checkbox" id="c-42563931" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563280">parent</a><span>|</span><a href="#42563369">next</a><span>|</span><label class="collapse" for="c-42563931">[-]</label><label class="expand" for="c-42563931">[3 more]</label></div><br/><div class="children"><div class="content">Fluent in C and C++ among others, know nothing about Rust. It&#x27;s mostly easy to follow, but I&#x27;m having trouble with notation like `&amp;[u32]` and `&amp;[u32; P]`. Arrays that hold unsigned 32 bit integers? But there&#x27;s `Vec&lt;u32&gt;` which also seems like an array type? Is it like the difference between C++ primitive arrays and std::vector?</div><br/><div id="42564083" class="c"><input type="checkbox" id="c-42564083" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563931">parent</a><span>|</span><a href="#42564288">next</a><span>|</span><label class="collapse" for="c-42564083">[-]</label><label class="expand" for="c-42564083">[1 more]</label></div><br/><div class="children"><div class="content">For `&amp;[u32]` and `&amp;[u32; P]`, those are both references to an array of unsigned 32 but integers, however the former is to an array of any size (and carries its size at runtime), whereas the latter is to an array with an explicitly known size at compile time. It&#x27;s unusual in C, I think you can express it as `int[24] *` (or possibly some other permutation, I&#x27;m away from a compiler).<p>Vec&lt;u32&gt; is pretty much like std::vector compared to them, yeah.</div><br/></div></div><div id="42564288" class="c"><input type="checkbox" id="c-42564288" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563931">parent</a><span>|</span><a href="#42564083">prev</a><span>|</span><a href="#42563369">next</a><span>|</span><label class="collapse" for="c-42564288">[-]</label><label class="expand" for="c-42564288">[1 more]</label></div><br/><div class="children"><div class="content">`&amp;[u32]` is essentially `std::span&lt;const uint32_t&gt;`.<p>`&amp;[u32; P]` is similarly something like `std::span&lt;const uint32_t, P&gt;`.<p>`[u32; P]` (no `&amp;`) is essentially `std::array&lt;uint32_t, P&gt;`.<p>`Vec&lt;u32&gt;` is essentially `std::vector&lt;uint32_t&gt;`, yes.</div><br/></div></div></div></div><div id="42563369" class="c"><input type="checkbox" id="c-42563369" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563280">parent</a><span>|</span><a href="#42563931">prev</a><span>|</span><a href="#42563317">next</a><span>|</span><label class="collapse" for="c-42563369">[-]</label><label class="expand" for="c-42563369">[7 more]</label></div><br/><div class="children"><div class="content">I have not studied Rust and find its syntax alien. It looks like a cross between a functional language and C++. Trying to read it is like forcing myself to read Italian. I don’t know Italian, but have studied Spanish and Latin. I can sort of figure things out if I put in effort, but there is always uncertainty when I do. That is the problem with reading Rust.<p>This could be addressed if I just learned Rust (much like my difficulty with Italian could be addressed by studying Italian). However, I already know at least 10 programming languages. I am unwilling to learn the latest fashionable language unless it can promise me that the language will not change and there will never be another fashionable language for me to learn. Given that Rust rejected the standardization process that C and C++ embraced, and Zig is expected to replace Rust one day, I doubt Rust can make such assurances.<p>As for Python, it is often used for teaching CS and everything except the assembly code is doable in it. Using low level assembly from Python would require using the FFI. Also, Python has nothing to do with LLVM.</div><br/><div id="42563435" class="c"><input type="checkbox" id="c-42563435" checked=""/><div class="controls bullet"><span class="by">unrealhoang</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563369">parent</a><span>|</span><a href="#42563383">next</a><span>|</span><label class="collapse" for="c-42563435">[-]</label><label class="expand" for="c-42563435">[1 more]</label></div><br/><div class="children"><div class="content">Suck to be you, I guess? If you don’t care enough then you don’t care. You wouldn’t bitch when there’s an article written in Italian with good knowledge inside: “but Italian”. You either trying to read using translation tool or ignore it entirely.<p>I didn’t say python has anything to do with LLVM, it’s just a technique, read about it, or not.</div><br/></div></div><div id="42563383" class="c"><input type="checkbox" id="c-42563383" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563369">parent</a><span>|</span><a href="#42563435">prev</a><span>|</span><a href="#42563317">next</a><span>|</span><label class="collapse" for="c-42563383">[-]</label><label class="expand" for="c-42563383">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Zig is expected to replace Rust one day<p>That&#x27;s a bold prediction considering that Zig is unsafe and Rust is safe.<p>If Zig&#x27;s idioms make it safe, then modern C++ is safe too.</div><br/><div id="42564649" class="c"><input type="checkbox" id="c-42564649" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563383">parent</a><span>|</span><a href="#42563439">next</a><span>|</span><label class="collapse" for="c-42564649">[-]</label><label class="expand" for="c-42564649">[1 more]</label></div><br/><div class="children"><div class="content">Both are unsafe, just zig is usually safer than rust.<p>And also so more readable, ie. maintainable</div><br/></div></div><div id="42563439" class="c"><input type="checkbox" id="c-42563439" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563383">parent</a><span>|</span><a href="#42564649">prev</a><span>|</span><a href="#42563317">next</a><span>|</span><label class="collapse" for="c-42563439">[-]</label><label class="expand" for="c-42563439">[3 more]</label></div><br/><div class="children"><div class="content">Zig replacing Rust is not my prediction. It is what I am hearing from the Zig enthusiast I know. I have also seen others express the sentiment that the next fashionable language after Rust will be Zig. Regardless of whether it is Zig, there will be another. Rust is just one part of a never ending cycle of people trying to reinvent programming.</div><br/><div id="42563632" class="c"><input type="checkbox" id="c-42563632" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563439">parent</a><span>|</span><a href="#42563317">next</a><span>|</span><label class="collapse" for="c-42563632">[-]</label><label class="expand" for="c-42563632">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Rust is just one part of a never ending cycle of people trying to reinvent programming.<p>This is true of every single programming language.</div><br/><div id="42563736" class="c"><input type="checkbox" id="c-42563736" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563632">parent</a><span>|</span><a href="#42563317">next</a><span>|</span><label class="collapse" for="c-42563736">[-]</label><label class="expand" for="c-42563736">[1 more]</label></div><br/><div class="children"><div class="content">That is my complaint against the next fashionable language. Once you have some level of proficiency in around 10 languages, adding more to the list is a chore. It lacks the enjoyment that came from the first few. At least, that is my experience. That is why I am resistant to learning new languages unless software I want to modify is already written in it. Then, I am forced to learn and time spent on it is time that actually needed to be spent, unlike my brief time spent teaching myself FORTRAN in college, which was largely a waste of time.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42563317" class="c"><input type="checkbox" id="c-42563317" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563280">parent</a><span>|</span><a href="#42563369">prev</a><span>|</span><a href="#42563172">next</a><span>|</span><label class="collapse" for="c-42563317">[-]</label><label class="expand" for="c-42563317">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Regarding Python, how could such optimizations be implemented in Python? Generating LLVM bytecodes directly aside.<p>You don&#x27;t. You instead use your favorite Python extension system (regular Python modules, Cython, Numba, whatever) to implement this tree algorithm and expose it to Python already shaped into a container.</div><br/></div></div></div></div><div id="42563172" class="c"><input type="checkbox" id="c-42563172" checked=""/><div class="controls bullet"><span class="by">wolfgangK</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563280">prev</a><span>|</span><a href="#42563158">next</a><span>|</span><label class="collapse" for="c-42563172">[-]</label><label class="expand" for="c-42563172">[10 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that Python would be the right language for such low-level performance maxxing endeavor. I would have picked C++ but t was eye opening for me to see how rust enabled such low level optimization, so I&#x27;m grateful for the choice.</div><br/><div id="42563219" class="c"><input type="checkbox" id="c-42563219" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563172">parent</a><span>|</span><a href="#42563202">next</a><span>|</span><label class="collapse" for="c-42563219">[-]</label><label class="expand" for="c-42563219">[6 more]</label></div><br/><div class="children"><div class="content">C would be useful to the broadest audience. C++ programmers can read C while C programmers cannot always read C++, especially when the newer language constructs are used. I mentioned Python because of its popularity.<p>Interesting, the Algorithmica article the author cited is in C:<p><a href="https:&#x2F;&#x2F;en.algorithmica.org&#x2F;hpc&#x2F;data-structures&#x2F;s-tree&#x2F;" rel="nofollow">https:&#x2F;&#x2F;en.algorithmica.org&#x2F;hpc&#x2F;data-structures&#x2F;s-tree&#x2F;</a></div><br/><div id="42563242" class="c"><input type="checkbox" id="c-42563242" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563219">parent</a><span>|</span><a href="#42563202">next</a><span>|</span><label class="collapse" for="c-42563242">[-]</label><label class="expand" for="c-42563242">[5 more]</label></div><br/><div class="children"><div class="content">C++ not C. The author explains his choices elsewhere in the site.</div><br/><div id="42563277" class="c"><input type="checkbox" id="c-42563277" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563242">parent</a><span>|</span><a href="#42563202">next</a><span>|</span><label class="collapse" for="c-42563277">[-]</label><label class="expand" for="c-42563277">[4 more]</label></div><br/><div class="children"><div class="content">The code snippets should be accepted by a C compiler and therefore are valid C code.</div><br/><div id="42563302" class="c"><input type="checkbox" id="c-42563302" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563277">parent</a><span>|</span><a href="#42563202">next</a><span>|</span><label class="collapse" for="c-42563302">[-]</label><label class="expand" for="c-42563302">[3 more]</label></div><br/><div class="children"><div class="content">If you want to be pedantic, there is a constexpr in the snippets, wont be accepted by the C compiler. More broadly though it is a C++ tutorial. I insisted on it because the author of algorithmica actually explains he chose C++ and perhaps sometime later C&#x2F;Rust or something might be better. Should respect his POV.</div><br/><div id="42563380" class="c"><input type="checkbox" id="c-42563380" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563302">parent</a><span>|</span><a href="#42563202">next</a><span>|</span><label class="collapse" for="c-42563380">[-]</label><label class="expand" for="c-42563380">[2 more]</label></div><br/><div class="children"><div class="content">I had not seen the use of constexpr. You are correct that those are in C++.</div><br/><div id="42564567" class="c"><input type="checkbox" id="c-42564567" checked=""/><div class="controls bullet"><span class="by">lubutu</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563380">parent</a><span>|</span><a href="#42563202">next</a><span>|</span><label class="collapse" for="c-42564567">[-]</label><label class="expand" for="c-42564567">[1 more]</label></div><br/><div class="children"><div class="content">C23 has constexpr, albeit only for objects, not functions. The code also uses namespaces, as in `std::aligned_alloc(P, T)`.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42563202" class="c"><input type="checkbox" id="c-42563202" checked=""/><div class="controls bullet"><span class="by">curiouscoding</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563172">parent</a><span>|</span><a href="#42563219">prev</a><span>|</span><a href="#42563158">next</a><span>|</span><label class="collapse" for="c-42563202">[-]</label><label class="expand" for="c-42563202">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, I don&#x27;t think python is the right tool here. C++ definitely would be an option though.<p>Anyway very happy that this is also showing off what rust can do</div><br/><div id="42563688" class="c"><input type="checkbox" id="c-42563688" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563202">parent</a><span>|</span><a href="#42563800">next</a><span>|</span><label class="collapse" for="c-42563688">[-]</label><label class="expand" for="c-42563688">[1 more]</label></div><br/><div class="children"><div class="content">As far as I can tell, the community is largely divided into three major groups. Those that can read C, those that can read Python and those that can read both. Using either of them would have dodged criticism that your code examples are not accessible to much of the community.<p>That said, you are right that Python is not the best language to use when you need to use intrinsics, as you would be writing it in another language and using the Python FFI to access it.</div><br/></div></div><div id="42563800" class="c"><input type="checkbox" id="c-42563800" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563202">parent</a><span>|</span><a href="#42563688">prev</a><span>|</span><a href="#42563158">next</a><span>|</span><label class="collapse" for="c-42563800">[-]</label><label class="expand" for="c-42563800">[1 more]</label></div><br/><div class="children"><div class="content">&gt; this is also showing off what rust can do<p>To people who already know Rust, yes. To others, not so much</div><br/></div></div></div></div></div></div><div id="42563158" class="c"><input type="checkbox" id="c-42563158" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563172">prev</a><span>|</span><a href="#42563281">next</a><span>|</span><label class="collapse" for="c-42563158">[-]</label><label class="expand" for="c-42563158">[10 more]</label></div><br/><div class="children"><div class="content">Maybe, but should the author really cater to people who can’t overcome a language barrier? They probably won’t understand the concept anyway.</div><br/><div id="42563405" class="c"><input type="checkbox" id="c-42563405" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563158">parent</a><span>|</span><a href="#42563421">next</a><span>|</span><label class="collapse" for="c-42563405">[-]</label><label class="expand" for="c-42563405">[4 more]</label></div><br/><div class="children"><div class="content">The ACM for a time only accepted code examples in ALGOL because it was felt that there should be a standard language that everyone understood. ALGOL eventually gave way to C and others, but there is definite value in ensuring things are accessible to the largest possible audience.</div><br/><div id="42563498" class="c"><input type="checkbox" id="c-42563498" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563405">parent</a><span>|</span><a href="#42563438">next</a><span>|</span><label class="collapse" for="c-42563498">[-]</label><label class="expand" for="c-42563498">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re free to use ALGOL in your posts if you want. It reads like pseudocode used in algorithmic books, and should be familiar to anyone who used the Pascal family.<p>ALGOL gave way to C, and C is now giving way to Rust, Zig and others. You&#x27;re playing the role of the people who wanted to keep the example snippets in ALGOL.</div><br/><div id="42563515" class="c"><input type="checkbox" id="c-42563515" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563498">parent</a><span>|</span><a href="#42563438">next</a><span>|</span><label class="collapse" for="c-42563515">[-]</label><label class="expand" for="c-42563515">[1 more]</label></div><br/><div class="children"><div class="content">The point was that examples should be in widely understood languages. The niche languages you list do not qualify as widely understood.<p>Estne melius scribere exempla latine?</div><br/></div></div></div></div><div id="42563438" class="c"><input type="checkbox" id="c-42563438" checked=""/><div class="controls bullet"><span class="by">dxbydt</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563405">parent</a><span>|</span><a href="#42563498">prev</a><span>|</span><a href="#42563421">next</a><span>|</span><label class="collapse" for="c-42563438">[-]</label><label class="expand" for="c-42563438">[1 more]</label></div><br/><div class="children"><div class="content">usaco explicitly nudges you towards C++ on the first page itself. problems are graded on running time, even with moderately large datasets, Python simply doesn’t make the cut. So most high schoolers end up using C++ for usaco, and Java for AP Comp Science.</div><br/></div></div></div></div><div id="42563421" class="c"><input type="checkbox" id="c-42563421" checked=""/><div class="controls bullet"><span class="by">mangamadaiyan</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563158">parent</a><span>|</span><a href="#42563405">prev</a><span>|</span><a href="#42563281">next</a><span>|</span><label class="collapse" for="c-42563421">[-]</label><label class="expand" for="c-42563421">[5 more]</label></div><br/><div class="children"><div class="content">Erm, the concepts that you&#x27;re referring to are independent of the language being used. The author is free to use whatever language they want. The GP (I think) was merely trying to make a point about making the article accessible to a wider audience that is capable of appreciating the concepts involved.</div><br/><div id="42563482" class="c"><input type="checkbox" id="c-42563482" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563421">parent</a><span>|</span><a href="#42563552">next</a><span>|</span><label class="collapse" for="c-42563482">[-]</label><label class="expand" for="c-42563482">[3 more]</label></div><br/><div class="children"><div class="content">If you can&#x27;t understand the code snippets in this post, the concepts will most likely be lost on you, no matter what other language would be used for the code.</div><br/><div id="42564682" class="c"><input type="checkbox" id="c-42564682" checked=""/><div class="controls bullet"><span class="by">mangamadaiyan</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563482">parent</a><span>|</span><a href="#42563803">next</a><span>|</span><label class="collapse" for="c-42564682">[-]</label><label class="expand" for="c-42564682">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that precisely the point that the GP was trying to make, about the accessibility of the article?<p>Edit: Eytzinger layout, Cache lines, SIMD, et cetera are independent of the particular language used in the article. They&#x27;re just as valid in C, for example. I don&#x27;t understand your point about them being tied to Rust.</div><br/></div></div></div></div><div id="42563552" class="c"><input type="checkbox" id="c-42563552" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563421">parent</a><span>|</span><a href="#42563482">prev</a><span>|</span><a href="#42563281">next</a><span>|</span><label class="collapse" for="c-42563552">[-]</label><label class="expand" for="c-42563552">[1 more]</label></div><br/><div class="children"><div class="content">You are correct.</div><br/></div></div></div></div></div></div><div id="42563281" class="c"><input type="checkbox" id="c-42563281" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563158">prev</a><span>|</span><a href="#42563160">next</a><span>|</span><label class="collapse" for="c-42563281">[-]</label><label class="expand" for="c-42563281">[3 more]</label></div><br/><div class="children"><div class="content">I have a far easier time reading Rust than C. Probably because it’s been years since I’ve had to do C, and I find some of the syntax and patterns quite C-specific and confusing. Python also does not express some of the important implementation details well enough in its standard syntax IMO: there’s no obvious delineation between references and pass by value in Python, borrowing, etc.<p>So realistically, this is just the other half of the coin for all the articles where the code examples were written in C and everyone who didn’t really read C just had to put up with it.</div><br/><div id="42563284" class="c"><input type="checkbox" id="c-42563284" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563281">parent</a><span>|</span><a href="#42563160">next</a><span>|</span><label class="collapse" for="c-42563284">[-]</label><label class="expand" for="c-42563284">[2 more]</label></div><br/><div class="children"><div class="content">The TIOBE index suggests that you are in a much smaller group than those who have difficulty reading Rust:<p><a href="https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;</a></div><br/><div id="42563941" class="c"><input type="checkbox" id="c-42563941" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563284">parent</a><span>|</span><a href="#42563160">next</a><span>|</span><label class="collapse" for="c-42563941">[-]</label><label class="expand" for="c-42563941">[1 more]</label></div><br/><div class="children"><div class="content">Yes, he is in a bubble.</div><br/></div></div></div></div></div></div><div id="42563160" class="c"><input type="checkbox" id="c-42563160" checked=""/><div class="controls bullet"><span class="by">Rendello</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563281">prev</a><span>|</span><a href="#42563200">next</a><span>|</span><label class="collapse" for="c-42563160">[-]</label><label class="expand" for="c-42563160">[1 more]</label></div><br/><div class="children"><div class="content">I wonder what percentage of Rust users have significant experience with C. The difficulty curve of Rust was too high for me when I was coming from Python, but after doing HolyC and Zig, I find it fairly straightforward to conceptualize, though still difficult.<p>I&#x27;ve been working with real C today and have been having fun, but it&#x27;s very different for me to step back into the C world again after working with more modern tools.</div><br/></div></div><div id="42563200" class="c"><input type="checkbox" id="c-42563200" checked=""/><div class="controls bullet"><span class="by">plasticeagle</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563160">prev</a><span>|</span><a href="#42563829">next</a><span>|</span><label class="collapse" for="c-42563200">[-]</label><label class="expand" for="c-42563200">[6 more]</label></div><br/><div class="children"><div class="content">As a computer science article, it should have mostly been pseudocode. Concrete implementations can be given in an appendix, where they belong.</div><br/><div id="42563261" class="c"><input type="checkbox" id="c-42563261" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563200">parent</a><span>|</span><a href="#42563222">next</a><span>|</span><label class="collapse" for="c-42563261">[-]</label><label class="expand" for="c-42563261">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s unrealistic given that the author is not just doing computer science but also engineering using SIMD. The kind of available SIMD instructions actually affects code choice.</div><br/></div></div><div id="42563222" class="c"><input type="checkbox" id="c-42563222" checked=""/><div class="controls bullet"><span class="by">curiouscoding</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563200">parent</a><span>|</span><a href="#42563261">prev</a><span>|</span><a href="#42563829">next</a><span>|</span><label class="collapse" for="c-42563222">[-]</label><label class="expand" for="c-42563222">[4 more]</label></div><br/><div class="children"><div class="content">The problem with pseudocode is that it&#x27;s completely underspecified. And how would I ever write intrinsics in pseudocode? Much easier to do a proper language directly so people can actually Google things and read their official documentation.</div><br/><div id="42563575" class="c"><input type="checkbox" id="c-42563575" checked=""/><div class="controls bullet"><span class="by">sigbottle</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563222">parent</a><span>|</span><a href="#42563388">next</a><span>|</span><label class="collapse" for="c-42563575">[-]</label><label class="expand" for="c-42563575">[2 more]</label></div><br/><div class="children"><div class="content">My former roommate works in a similar domain; <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3448016.3452841" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3448016.3452841</a> is an example of a paper implementing intrinsics in pseudocode. They &quot;unroll&quot; the intrinsics with a comment saying that this is implemented with an intrinsic. Of course though, your blog isn&#x27;t a paper, don&#x27;t know why people are getting up in arms about it.<p>Also the other comment saying that &quot;psuedocode is not concerned with intrinsics&quot; is false. You can get &quot;great&quot; theoretical speedups (the shaveoffs are tiny but hey, they&#x27;re better) with &quot;simple&quot; intrinsic operations - that&#x27;s my roommate&#x27;s entire research lol. The external memory model, for example, formalizes caching and allows all these low level optimizations to flourish. I&#x27;m not sure how intrinsics tied into it, but he&#x27;s published so I&#x27;m not gonna question it :)<p>---<p>Speaking of which, I noticed that you did competitive programming. How does CP compare to research? I loved data structure manipulation problems in CP when they were clever - often because they involved noticing that you can take a &quot;common&quot; model, but then optimize it significantly because you only needed to support a subset of the operations through a clever mathematical proof based on the structure of the problem - but as I got to the higher levels it felt more and more that a lot of them became really obscure &quot;support 413 operations on a tree, and yes, you really need to support all 413 operations on a tree&quot; and that&#x27;s kind of my opinion of data structure research unfortunately as well :( I guess because solving broad general instances is more important. I&#x27;d love to hear your perspective though.</div><br/><div id="42563624" class="c"><input type="checkbox" id="c-42563624" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563575">parent</a><span>|</span><a href="#42563388">next</a><span>|</span><label class="collapse" for="c-42563624">[-]</label><label class="expand" for="c-42563624">[1 more]</label></div><br/><div class="children"><div class="content">Pseudo code can be whatever you want it to be. You can do SIMD pseudo code, but most generally don’t as that is often an implementation detail.</div><br/></div></div></div></div></div></div></div></div><div id="42563829" class="c"><input type="checkbox" id="c-42563829" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563200">prev</a><span>|</span><a href="#42563221">next</a><span>|</span><label class="collapse" for="c-42563829">[-]</label><label class="expand" for="c-42563829">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never programmed in rust and i can understand find.<p>At the end of the day rust is just another imperative programming language. You shouldn&#x27;t need to know the language at all to understand the very simple examples written in rust.</div><br/></div></div><div id="42563894" class="c"><input type="checkbox" id="c-42563894" checked=""/><div class="controls bullet"><span class="by">peutetre</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563221">prev</a><span>|</span><a href="#42563217">next</a><span>|</span><label class="collapse" for="c-42563894">[-]</label><label class="expand" for="c-42563894">[1 more]</label></div><br/><div class="children"><div class="content">Well, you can do the C implementation then.<p>Don&#x27;t see it as a problem, see it as an opportunity.</div><br/></div></div><div id="42563217" class="c"><input type="checkbox" id="c-42563217" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563894">prev</a><span>|</span><a href="#42563170">next</a><span>|</span><label class="collapse" for="c-42563217">[-]</label><label class="expand" for="c-42563217">[15 more]</label></div><br/><div class="children"><div class="content">Rust is now common enough in the industry that everyone should be expected to at least read it, just like every programmer should be able to fizzbuzz in Python and JavaScript just as a matter of general technical literacy. There&#x27;s no advanced Rust here and no concepts specific to the language.<p>It&#x27;s a good article.<p>If Heinlein were in our industry, he might write this:<p>A programmer should be able to write a shell, parse binary data, design a protocol (and reverse engineer one too), authenticate a password, not fumble multi-code-point graphemes, wrangle semaphores, plug memory leaks, compress data, migrate databases, automate builds, git rebase a tree, profile tail latency, write a simple design doc for a complex system, draw a triangle, multiply tensors, and do fizzbuzz in every popular language on GitHub. Specialization is for insects.</div><br/><div id="42563260" class="c"><input type="checkbox" id="c-42563260" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563217">parent</a><span>|</span><a href="#42563170">next</a><span>|</span><label class="collapse" for="c-42563260">[-]</label><label class="expand" for="c-42563260">[14 more]</label></div><br/><div class="children"><div class="content">Here is a list of languages people can be generally expected to be able to read:<p><pre><code>  * C
  * C++
  * Java
  * JavaScript
  * Python
</code></pre>
It is the top 6 of the TIOBE index, minus C#:<p><a href="https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;</a><p>Rust is not very high on the TIOBE index. It has rank 14 with a 1.29% rating. That is not much higher than COBOL.</div><br/><div id="42563345" class="c"><input type="checkbox" id="c-42563345" checked=""/><div class="controls bullet"><span class="by">bschwindHN</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563260">parent</a><span>|</span><a href="#42563666">next</a><span>|</span><label class="collapse" for="c-42563345">[-]</label><label class="expand" for="c-42563345">[4 more]</label></div><br/><div class="children"><div class="content">You forgot the part where no one cares about TIOBE though.</div><br/><div id="42563587" class="c"><input type="checkbox" id="c-42563587" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563345">parent</a><span>|</span><a href="#42563666">next</a><span>|</span><label class="collapse" for="c-42563587">[-]</label><label class="expand" for="c-42563587">[3 more]</label></div><br/><div class="children"><div class="content">As the TIOBE index says “The ratings are based on the number of skilled engineers world-wide, courses and third party vendors”. Very many people do care about that. Is there any reason I should think your remark is from some legitimate issue rather than you not liking the index results?</div><br/><div id="42563766" class="c"><input type="checkbox" id="c-42563766" checked=""/><div class="controls bullet"><span class="by">bschwindHN</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563587">parent</a><span>|</span><a href="#42563666">next</a><span>|</span><label class="collapse" for="c-42563766">[-]</label><label class="expand" for="c-42563766">[2 more]</label></div><br/><div class="children"><div class="content">I would argue most people working software jobs either haven&#x27;t heard of TIOBE or don&#x27;t care about it. I only occasionally hear about it from strange internet comments that are far too focused on language particulars.</div><br/><div id="42563950" class="c"><input type="checkbox" id="c-42563950" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563766">parent</a><span>|</span><a href="#42563666">next</a><span>|</span><label class="collapse" for="c-42563950">[-]</label><label class="expand" for="c-42563950">[1 more]</label></div><br/><div class="children"><div class="content">That is surprising. I heard about the TIOBE index often about 15 years ago, but now that I think about it, I have not heard about it lately. I wonder if the rise of Python and ML has caused people to stop asking “what language should I learn”. That is the question the TIOBE index often was cited to answer.</div><br/></div></div></div></div></div></div></div></div><div id="42563666" class="c"><input type="checkbox" id="c-42563666" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563260">parent</a><span>|</span><a href="#42563345">prev</a><span>|</span><a href="#42563294">next</a><span>|</span><label class="collapse" for="c-42563666">[-]</label><label class="expand" for="c-42563666">[1 more]</label></div><br/><div class="children"><div class="content">As an aside: why is Java winning out over C# these days? When I first experienced C# I didn&#x27;t want to go back.</div><br/></div></div><div id="42563294" class="c"><input type="checkbox" id="c-42563294" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563260">parent</a><span>|</span><a href="#42563666">prev</a><span>|</span><a href="#42564413">next</a><span>|</span><label class="collapse" for="c-42563294">[-]</label><label class="expand" for="c-42563294">[7 more]</label></div><br/><div class="children"><div class="content">Rust is where the action is though. It&#x27;s not just about cumulative SLOC weight, but about mindshare among the &quot;movers and shakers&quot; of the industry. Think of it as a prestige language, an acrolect, you should at least vaguely know so that you can participate in the most challenging conversations in the field.</div><br/><div id="42563492" class="c"><input type="checkbox" id="c-42563492" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563294">parent</a><span>|</span><a href="#42564413">next</a><span>|</span><label class="collapse" for="c-42563492">[-]</label><label class="expand" for="c-42563492">[6 more]</label></div><br/><div class="children"><div class="content">That is an interesting perspective. Here is my perspective. There are no popular projects that use Rust as a primary language. The current fashionable area of computers is machine learning. As far as high level languages go, you will see a mix of Python, C++ and perhaps a tiny bit of C there. Rust is nowhere to be seen.<p>Your description would be better applied to C, C++ and Python. That is what the majority of popular software uses and people having challenging conversations are often using one of those languages.</div><br/><div id="42563627" class="c"><input type="checkbox" id="c-42563627" checked=""/><div class="controls bullet"><span class="by">tyre</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563492">parent</a><span>|</span><a href="#42564107">next</a><span>|</span><label class="collapse" for="c-42563627">[-]</label><label class="expand" for="c-42563627">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There are no popular projects that use Rust as a primary language.<p>Servo is pretty notable and visible. ripgrep, influxdb, wasmer, deno. uv and ruff in the python ecosystem are written in rust.<p>AWS, Cloudflare, Discord (iirc), and Microsoft have all adopted Rust extensively.<p>As of late 2023 there are committed drivers in the Linux kernel written in rust. (Linux is pretty popular.) prior to those, only C and assembly were allowed.</div><br/><div id="42563919" class="c"><input type="checkbox" id="c-42563919" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563627">parent</a><span>|</span><a href="#42564382">next</a><span>|</span><label class="collapse" for="c-42563919">[-]</label><label class="expand" for="c-42563919">[1 more]</label></div><br/><div class="children"><div class="content">None of this contradicts what I said.</div><br/></div></div><div id="42564382" class="c"><input type="checkbox" id="c-42564382" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563627">parent</a><span>|</span><a href="#42563919">prev</a><span>|</span><a href="#42564107">next</a><span>|</span><label class="collapse" for="c-42564382">[-]</label><label class="expand" for="c-42564382">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget Pydantic</div><br/></div></div></div></div><div id="42564107" class="c"><input type="checkbox" id="c-42564107" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563492">parent</a><span>|</span><a href="#42563627">prev</a><span>|</span><a href="#42564413">next</a><span>|</span><label class="collapse" for="c-42564107">[-]</label><label class="expand" for="c-42564107">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There are no popular projects that use Rust as a primary language<p>You may be surprised to learn, Python&#x27;s `cryptography` project is written (EDIT: maybe not primarily, it&#x27;s hard to compare given dependencies) in Rust, and saw around 8.1 million downloads from PyPI yesterday. That puts it close to the top 20 (the 20th project comes in at 8.5m).</div><br/></div></div></div></div></div></div><div id="42564413" class="c"><input type="checkbox" id="c-42564413" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563260">parent</a><span>|</span><a href="#42563294">prev</a><span>|</span><a href="#42563170">next</a><span>|</span><label class="collapse" for="c-42564413">[-]</label><label class="expand" for="c-42564413">[1 more]</label></div><br/><div class="children"><div class="content">If you know C&#x2F;C++ you could have learned to read Rust in the time you spent commenting in this thread. The number of new syntaxes you need to learn is quite minimal.</div><br/></div></div></div></div></div></div><div id="42563170" class="c"><input type="checkbox" id="c-42563170" checked=""/><div class="controls bullet"><span class="by">barbegal</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563217">prev</a><span>|</span><a href="#42563196">next</a><span>|</span><label class="collapse" for="c-42563170">[-]</label><label class="expand" for="c-42563170">[3 more]</label></div><br/><div class="children"><div class="content">Neither of those languages gives you portable SIMD. Rust is rapidly becoming the language of choice for high performance code.</div><br/><div id="42563231" class="c"><input type="checkbox" id="c-42563231" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563170">parent</a><span>|</span><a href="#42563196">next</a><span>|</span><label class="collapse" for="c-42563231">[-]</label><label class="expand" for="c-42563231">[2 more]</label></div><br/><div class="children"><div class="content">google has a mature C++ library for portable SIMD. The original article seems to be a translation of the excellent algorithmica site which had it in C++.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;highway</a></div><br/><div id="42563457" class="c"><input type="checkbox" id="c-42563457" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563231">parent</a><span>|</span><a href="#42563196">next</a><span>|</span><label class="collapse" for="c-42563457">[-]</label><label class="expand" for="c-42563457">[1 more]</label></div><br/><div class="children"><div class="content">You can do portable SIMD in GNU C&#x2F;C++ using the vector extension:<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Vector-Extensions.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Vector-Extensions.html</a></div><br/></div></div></div></div></div></div><div id="42563196" class="c"><input type="checkbox" id="c-42563196" checked=""/><div class="controls bullet"><span class="by">pxmpxm</span><span>|</span><a href="#42563115">parent</a><span>|</span><a href="#42563170">prev</a><span>|</span><label class="collapse" for="c-42563196">[-]</label><label class="expand" for="c-42563196">[13 more]</label></div><br/><div class="children"><div class="content">I suspect like 9&#x2F;10 of these type of articles are really just meant to be PR for rust. Like someone that wants to write Bart Simpsonensque &quot;rust is great&quot; over and over, but have to hide it into something more interesting.</div><br/><div id="42563224" class="c"><input type="checkbox" id="c-42563224" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563196">parent</a><span>|</span><a href="#42563213">next</a><span>|</span><label class="collapse" for="c-42563224">[-]</label><label class="expand" for="c-42563224">[2 more]</label></div><br/><div class="children"><div class="content">Do you think <i>this article</i> was written specifically as just PR for Rust?<p>Who do you think is behind this? The government?</div><br/><div id="42563295" class="c"><input type="checkbox" id="c-42563295" checked=""/><div class="controls bullet"><span class="by">estebarb</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563224">parent</a><span>|</span><a href="#42563213">next</a><span>|</span><label class="collapse" for="c-42563295">[-]</label><label class="expand" for="c-42563295">[1 more]</label></div><br/><div class="children"><div class="content">Clearly it is Big Compiler propaganda! &lt;&#x2F;bazinga&gt;</div><br/></div></div></div></div><div id="42563213" class="c"><input type="checkbox" id="c-42563213" checked=""/><div class="controls bullet"><span class="by">curiouscoding</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563196">parent</a><span>|</span><a href="#42563224">prev</a><span>|</span><a href="#42564249">next</a><span>|</span><label class="collapse" for="c-42563213">[-]</label><label class="expand" for="c-42563213">[9 more]</label></div><br/><div class="children"><div class="content">Rust <i>is</i> great :&quot;)<p>But no, this is actually part of my PhD research. The next step will be to use this in a fast suffix-array search algorithm.</div><br/><div id="42563250" class="c"><input type="checkbox" id="c-42563250" checked=""/><div class="controls bullet"><span class="by">jackschultz</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563213">parent</a><span>|</span><a href="#42563569">next</a><span>|</span><label class="collapse" for="c-42563250">[-]</label><label class="expand" for="c-42563250">[6 more]</label></div><br/><div class="children"><div class="content">Great stuff. We get told O notation is what matters for data structures &#x2F; algorithms, but improvements low level with memory and storage with things like rust is much more where improves can be made. These types of tricks for anctual run times are so valuable, and interesting to follow.</div><br/><div id="42563278" class="c"><input type="checkbox" id="c-42563278" checked=""/><div class="controls bullet"><span class="by">curiouscoding</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563250">parent</a><span>|</span><a href="#42563569">next</a><span>|</span><label class="collapse" for="c-42563278">[-]</label><label class="expand" for="c-42563278">[5 more]</label></div><br/><div class="children"><div class="content">Ohh yeah, don&#x27;t get me started in big-O...<p>It was great while computers were not really a thing yet, but these days it&#x27;s often so meaningless. We see papers with 2x speedup with a lot of novel algorithmic stuff that sell better than 10x speedup just by exploiting CPUs to the fullest.<p>Even myself I kinda think theoretical contributions are cooler, and we really need to get rid of that (slightly exaggerating).</div><br/><div id="42563834" class="c"><input type="checkbox" id="c-42563834" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563278">parent</a><span>|</span><a href="#42563922">next</a><span>|</span><label class="collapse" for="c-42563834">[-]</label><label class="expand" for="c-42563834">[1 more]</label></div><br/><div class="children"><div class="content">Your article led me to wonder if our b-trees would be faster if I switched the intra node operations to use Eytzinger ordered arrays:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;commit&#x2F;677c6f8457943fe5b56d7aa8807010a104563e4a">https:&#x2F;&#x2F;github.com&#x2F;openzfs&#x2F;zfs&#x2F;commit&#x2F;677c6f8457943fe5b56d7a...</a><p>There are two ways to look at this Big O wise. One is that insertions and deletions would be asymptomatically faster since memmove() is a linear operation while bubble up&#x2F;down are logarithmic operations. Look ups would not be any different asymptotically, but the constant factor might improve from being able to do prefetch. The other way is that the N is bounded, such that it is all O(1) and the difference is how big the constant factor is.<p>I imagine I could implement it and benchmark it. However, my intuition is that the end result have lookups be marginally faster to the point of splitting hairs while insertions and deletions would be slower. While memmove() is a technically a linear time operation, it is a sequential operation that has a very low constant factor. The bubble up and bubble down operations needed to do insertions and deletions in a Eytzinger ordered array are technically random access, which has a higher constant factor. At some point, the Eytzinger ordered array operations should win, but that point is likely well beyond the size of a b-tree node.<p>My reason for saying this is to say that Big O notation still matters, but understanding when the constant factor is significant is important.</div><br/></div></div><div id="42563922" class="c"><input type="checkbox" id="c-42563922" checked=""/><div class="controls bullet"><span class="by">jackschultz</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563278">parent</a><span>|</span><a href="#42563834">prev</a><span>|</span><a href="#42563770">next</a><span>|</span><label class="collapse" for="c-42563922">[-]</label><label class="expand" for="c-42563922">[1 more]</label></div><br/><div class="children"><div class="content">Same with async and throwing threads at a problem. People love do those and think it&#x27;s the right answer, but you can do a ton with smarter memory management and actually looking at what the code is doing lower level rather than abstractions.<p>Video about this that was very interesting to follow and somewhat related to what you&#x27;re doing:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5rb0vvJ7NCY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5rb0vvJ7NCY</a></div><br/></div></div><div id="42563770" class="c"><input type="checkbox" id="c-42563770" checked=""/><div class="controls bullet"><span class="by">Andys</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563278">parent</a><span>|</span><a href="#42563922">prev</a><span>|</span><a href="#42563569">next</a><span>|</span><label class="collapse" for="c-42563770">[-]</label><label class="expand" for="c-42563770">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re really just exploiting hidden O(?) implementations inside the CPU, so it still applies, just less visibly.</div><br/><div id="42563938" class="c"><input type="checkbox" id="c-42563938" checked=""/><div class="controls bullet"><span class="by">ryao</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563770">parent</a><span>|</span><a href="#42563569">next</a><span>|</span><label class="collapse" for="c-42563938">[-]</label><label class="expand" for="c-42563938">[1 more]</label></div><br/><div class="children"><div class="content">He is improving the constant factor in big O notation. University algorithm classes tend to ignore cases where the constant factor difference is significant enough to favor a asymptomatically slower algorithm. Matrix multiplication is the quintessential example of this, since a good implementation of the O(n^3) algorithm will outperform asymptotically faster algorithms, such as the famous O(n^2 * log(n) * log(log(n))) one that uses the FFT. At least, it outperforms it on matrix multiplications people actually do in practice.</div><br/></div></div></div></div></div></div></div></div><div id="42563303" class="c"><input type="checkbox" id="c-42563303" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563213">parent</a><span>|</span><a href="#42563569">prev</a><span>|</span><a href="#42564249">next</a><span>|</span><label class="collapse" for="c-42563303">[-]</label><label class="expand" for="c-42563303">[1 more]</label></div><br/><div class="children"><div class="content">Rust is... okay. I still prefer C++&#x27;s template system to Rust generics, in part because Rust doesn&#x27;t have specialization and won&#x27;t for a while. Memory safety by default is a big enough win to make me overlook these nits. Really, though, most people most of the time should be writing managed code.</div><br/></div></div></div></div><div id="42564249" class="c"><input type="checkbox" id="c-42564249" checked=""/><div class="controls bullet"><span class="by">stevenhuang</span><span>|</span><a href="#42563115">root</a><span>|</span><a href="#42563196">parent</a><span>|</span><a href="#42563213">prev</a><span>|</span><label class="collapse" for="c-42564249">[-]</label><label class="expand" for="c-42564249">[1 more]</label></div><br/><div class="children"><div class="content">You suspect wrong. People are interested in things you&#x27;re not. Get over it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>