<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726390867081" as="style"/><link rel="stylesheet" href="styles.css?v=1726390867081"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/Articles/990281/">Falsehoods programmers believe about TCP</a> <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>190 comments</span></div><br/><div><div id="41542411" class="c"><input type="checkbox" id="c-41542411" checked=""/><div class="controls bullet"><span class="by">koala_man</span><span>|</span><a href="#41541907">next</a><span>|</span><label class="collapse" for="c-41542411">[-]</label><label class="expand" for="c-41542411">[51 more]</label></div><br/><div class="children"><div class="content">I find this &quot;falsehoods programmers believe&quot; format of making pointed claims that you intentionally don&#x27;t clarify to be unhelpful and obnoxious</div><br/><div id="41543032" class="c"><input type="checkbox" id="c-41543032" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41543389">next</a><span>|</span><label class="collapse" for="c-41543032">[-]</label><label class="expand" for="c-41543032">[14 more]</label></div><br/><div class="children"><div class="content">Yep, I work on low level networking software professionally and this post is largely meaningless dribble and is probably motivated by grandstanding.<p>It’s like an engineer who says “how does a screen show black” and then says “nope” to every response. It’s maybe a way to make people think, but beyond that the negativity and grandstanding of it is ultimately a turn off for many receivers which eventually either then has them bully others this way or deters them from the field, depending on how it affects them. There are far better teaching methods that work better for everyone and teach faster and result in higher accuracy and retention.</div><br/><div id="41544825" class="c"><input type="checkbox" id="c-41544825" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543032">parent</a><span>|</span><a href="#41543262">next</a><span>|</span><label class="collapse" for="c-41544825">[-]</label><label class="expand" for="c-41544825">[1 more]</label></div><br/><div class="children"><div class="content">I thought you were probably exaggerating, but yes. I&#x27;ve never heard anyone make anything resembling any of those claims.<p>What I <i>have</i> said is something to the effect that if TCP isn&#x27;t reliable over a given path, there&#x27;s not a whole lot I can do about it as an application engineer short of making my own ad hoc, informally-specified, bug-ridden, slow implementation of half of TCP inside my own app, which I&#x27;m not going to do.<p>&gt; 14. Weird networks that are not transparent to standard protocols are an aberration. I can safely ignore them.<p>I certainly can and will. If you wanna run an RFC 2549 network, I&#x27;m going to spend approximately 0 seconds making my app support it. If you want to do something weird, <i>you</i> make it work. I&#x27;m going to optimize for the other 99.99999% of customers.</div><br/></div></div><div id="41543262" class="c"><input type="checkbox" id="c-41543262" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543032">parent</a><span>|</span><a href="#41544825">prev</a><span>|</span><a href="#41543545">next</a><span>|</span><label class="collapse" for="c-41543262">[-]</label><label class="expand" for="c-41543262">[1 more]</label></div><br/><div class="children"><div class="content">The author probably doesn&#x27;t understand the answers very well themselves.</div><br/></div></div><div id="41543545" class="c"><input type="checkbox" id="c-41543545" checked=""/><div class="controls bullet"><span class="by">cubano</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543032">parent</a><span>|</span><a href="#41543262">prev</a><span>|</span><a href="#41543389">next</a><span>|</span><label class="collapse" for="c-41543545">[-]</label><label class="expand" for="c-41543545">[11 more]</label></div><br/><div class="children"><div class="content">Uhhh....how <i>does</i> the screen show black?</div><br/><div id="41543785" class="c"><input type="checkbox" id="c-41543785" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543545">parent</a><span>|</span><a href="#41543644">next</a><span>|</span><label class="collapse" for="c-41543785">[-]</label><label class="expand" for="c-41543785">[3 more]</label></div><br/><div class="children"><div class="content">The screen knows what color it displays at all times. It knows this because it knows what it doesn&#x27;t. By subtracting what it does from what it doesn’t, or what it doesn’t from what it does (whichever is greater), it obtains a difference, or deviation. The controller board uses deviations to generate corrective commands to drive the display from a state where it does not display black to a state where it does, and arriving at a state where it displays black, it now doesn&#x27;t display anything.</div><br/><div id="41544152" class="c"><input type="checkbox" id="c-41544152" checked=""/><div class="controls bullet"><span class="by">appendix-rock</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543785">parent</a><span>|</span><a href="#41543988">next</a><span>|</span><label class="collapse" for="c-41544152">[-]</label><label class="expand" for="c-41544152">[1 more]</label></div><br/><div class="children"><div class="content">I’ve just broken out in a rash. Thanks.</div><br/></div></div><div id="41543988" class="c"><input type="checkbox" id="c-41543988" checked=""/><div class="controls bullet"><span class="by">nilamo</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543785">parent</a><span>|</span><a href="#41544152">prev</a><span>|</span><a href="#41543644">next</a><span>|</span><label class="collapse" for="c-41543988">[-]</label><label class="expand" for="c-41543988">[1 more]</label></div><br/><div class="children"><div class="content">I love this pasta so much</div><br/></div></div></div></div><div id="41543644" class="c"><input type="checkbox" id="c-41543644" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543545">parent</a><span>|</span><a href="#41543785">prev</a><span>|</span><a href="#41544066">next</a><span>|</span><label class="collapse" for="c-41543644">[-]</label><label class="expand" for="c-41543644">[2 more]</label></div><br/><div class="children"><div class="content">Each of the pixels is actually a little shining eye which watches your every move. When the pixel’s eyelid closes, that pixel turns black. That’s why they call it putting a display “to sleep.”</div><br/><div id="41543894" class="c"><input type="checkbox" id="c-41543894" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543644">parent</a><span>|</span><a href="#41544066">next</a><span>|</span><label class="collapse" for="c-41543894">[-]</label><label class="expand" for="c-41543894">[1 more]</label></div><br/><div class="children"><div class="content">I like your explanation, but to be fair, it depends.<p>Some displays are implemented with dual-eyelid technology for the blackest of blacks.  Naturally, like all genius engineering, we see this in nature: cats.</div><br/></div></div></div></div><div id="41544066" class="c"><input type="checkbox" id="c-41544066" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543545">parent</a><span>|</span><a href="#41543644">prev</a><span>|</span><a href="#41544219">next</a><span>|</span><label class="collapse" for="c-41544066">[-]</label><label class="expand" for="c-41544066">[3 more]</label></div><br/><div class="children"><div class="content">It depends afaict. OLED screens have a per-pixel light, and they turn off pixels to make black. LCDs have a single large backlight and pixels that the light shines through and they can change color (but not turn off) so in that case they turn as opaque as possible, but don&#x27;t completely block the light.</div><br/><div id="41545562" class="c"><input type="checkbox" id="c-41545562" checked=""/><div class="controls bullet"><span class="by">Ekaros</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41544066">parent</a><span>|</span><a href="#41545513">next</a><span>|</span><label class="collapse" for="c-41545562">[-]</label><label class="expand" for="c-41545562">[1 more]</label></div><br/><div class="children"><div class="content">There is also things like microled. Which means that there is bunch of small(bigger than multiple pixels) lights that turn on and off as needed.</div><br/></div></div><div id="41545513" class="c"><input type="checkbox" id="c-41545513" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41544066">parent</a><span>|</span><a href="#41545562">prev</a><span>|</span><a href="#41544219">next</a><span>|</span><label class="collapse" for="c-41545513">[-]</label><label class="expand" for="c-41545513">[1 more]</label></div><br/><div class="children"><div class="content">And in a CRT the electron beam turns off when scanning over a pixel.</div><br/></div></div></div></div><div id="41544219" class="c"><input type="checkbox" id="c-41544219" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543545">parent</a><span>|</span><a href="#41544066">prev</a><span>|</span><a href="#41543389">next</a><span>|</span><label class="collapse" for="c-41544219">[-]</label><label class="expand" for="c-41544219">[2 more]</label></div><br/><div class="children"><div class="content">He said it, it is ultimately a turn off.</div><br/><div id="41545487" class="c"><input type="checkbox" id="c-41545487" checked=""/><div class="controls bullet"><span class="by">oneshtein</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41544219">parent</a><span>|</span><a href="#41543389">next</a><span>|</span><label class="collapse" for="c-41545487">[-]</label><label class="expand" for="c-41545487">[1 more]</label></div><br/><div class="children"><div class="content">In case of a LCD, black pixel is turned ON to block backlight. It&#x27;s clearly visible on monochrome LCD screens.<p>In case of e-paper, black pigment is attracted to the outer part of the screen.</div><br/></div></div></div></div></div></div></div></div><div id="41543389" class="c"><input type="checkbox" id="c-41543389" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41543032">prev</a><span>|</span><a href="#41543210">next</a><span>|</span><label class="collapse" for="c-41543389">[-]</label><label class="expand" for="c-41543389">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you&#x27;re taking into account the context or intended audience. It&#x27;s a casual forum message posted in reply to someone else&#x27;s message.<p>They have not written a &quot;falsehoods programmers believe&quot; article. They have proposed that one <i>ought to be</i> written and have given a starting point for what it might cover.<p>They offered their list to &quot;get the ball rolling&quot;, confirming that they don&#x27;t see it as a finished product.<p>They sent it to other readers of the same forum, who might be expected to have more knowledge of this topic, not to whoever runs across it on the front page of HN.</div><br/></div></div><div id="41543210" class="c"><input type="checkbox" id="c-41543210" checked=""/><div class="controls bullet"><span class="by">lovecg</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41543389">prev</a><span>|</span><a href="#41543239">next</a><span>|</span><label class="collapse" for="c-41543210">[-]</label><label class="expand" for="c-41543210">[10 more]</label></div><br/><div class="children"><div class="content">I believe the article that started it all is <a href="https:&#x2F;&#x2F;www.kalzumeus.com&#x2F;2010&#x2F;06&#x2F;17&#x2F;falsehoods-programmers-believe-about-names&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.kalzumeus.com&#x2F;2010&#x2F;06&#x2F;17&#x2F;falsehoods-programmers-...</a> - crucially every entry is self-explanatory, which is a point that a lot of the subsequent “Falsehood…” list authors miss.</div><br/><div id="41546180" class="c"><input type="checkbox" id="c-41546180" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543210">parent</a><span>|</span><a href="#41544250">next</a><span>|</span><label class="collapse" for="c-41546180">[-]</label><label class="expand" for="c-41546180">[1 more]</label></div><br/><div class="children"><div class="content">Every point is not self-explanatory, and some are clearly true (while the assumption is they must be false). For instance, it surely is true that any name will fit in under a Terabyte of text, if it can be encoded at all (and assuming the contrary is counter-productive). Claiming you should not assume any name can be spelled in Unicode is absurd as well. And, yes, it&#x27;s perfectly fine to assume that if your system <i>must</i> have &quot;real&quot; (i.e. proved by any kind of document) names, you won&#x27;t have to deal with Klingon names (even though it isn&#x27;t a huge relief, honestly, since they still can have pretty much whatever format). For most systems, even more restrictive assumptions than that are totally fine.<p>You don&#x27;t have to defend the &quot;original&quot; post just because it was patio11&#x27;s. This idea was awful and stupid from the very beginning, and every new post of this &quot;series&quot; just repeats the offence.</div><br/></div></div><div id="41544250" class="c"><input type="checkbox" id="c-41544250" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543210">parent</a><span>|</span><a href="#41546180">prev</a><span>|</span><a href="#41543606">next</a><span>|</span><label class="collapse" for="c-41544250">[-]</label><label class="expand" for="c-41544250">[5 more]</label></div><br/><div class="children"><div class="content">I wonder what he means by France having a “weird” naming system in common use. As far as I can tell, the traditional French naming system works exactly the same way as the traditional American one (except that it’s more common for French people to have several middle names rather than zero or one, but I don’t think that’s too rare in the US either).<p>Maybe he’s referring to the fact that some last names are two words (e.g. Marine Le Pen), but I don’t think that’s very common…<p>Anyway, it could be anything, so I wish he’d said!</div><br/><div id="41546067" class="c"><input type="checkbox" id="c-41546067" checked=""/><div class="controls bullet"><span class="by">overdrive110</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41544250">parent</a><span>|</span><a href="#41545528">next</a><span>|</span><label class="collapse" for="c-41546067">[-]</label><label class="expand" for="c-41546067">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps he is thinking of how marriage does not change your last name, but rather gives you an extra, optional last name. [1] The French ID card has two last name fields!<p>[1] <a href="https:&#x2F;&#x2F;fr.m.wikipedia.org&#x2F;wiki&#x2F;Nom_d%27usage_en_France" rel="nofollow">https:&#x2F;&#x2F;fr.m.wikipedia.org&#x2F;wiki&#x2F;Nom_d%27usage_en_France</a></div><br/></div></div><div id="41545528" class="c"><input type="checkbox" id="c-41545528" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41544250">parent</a><span>|</span><a href="#41546067">prev</a><span>|</span><a href="#41543606">next</a><span>|</span><label class="collapse" for="c-41545528">[-]</label><label class="expand" for="c-41545528">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I don’t think that’s too rare in the US eithe<p>Anecdotal, but the only people I&#x27;ve met in the US with more than one middle name are people who originally came from another country.<p>Although, I wonder if maybe that is enforced by the fact tha legal forms and similar typically assume you only have first, last, and optionally a (single) middle name.</div><br/><div id="41545927" class="c"><input type="checkbox" id="c-41545927" checked=""/><div class="controls bullet"><span class="by">Paradigma11</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41545528">parent</a><span>|</span><a href="#41543606">next</a><span>|</span><label class="collapse" for="c-41545927">[-]</label><label class="expand" for="c-41545927">[2 more]</label></div><br/><div class="children"><div class="content">So you are saying Donald John Trump is likely not a US born Citizen?</div><br/><div id="41546034" class="c"><input type="checkbox" id="c-41546034" checked=""/><div class="controls bullet"><span class="by">Max-q</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41545927">parent</a><span>|</span><a href="#41543606">next</a><span>|</span><label class="collapse" for="c-41546034">[-]</label><label class="expand" for="c-41546034">[1 more]</label></div><br/><div class="children"><div class="content">&quot;more than one middle name&quot; :)</div><br/></div></div></div></div></div></div></div></div><div id="41543606" class="c"><input type="checkbox" id="c-41543606" checked=""/><div class="controls bullet"><span class="by">subarctic</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543210">parent</a><span>|</span><a href="#41544250">prev</a><span>|</span><a href="#41543903">next</a><span>|</span><label class="collapse" for="c-41543606">[-]</label><label class="expand" for="c-41543606">[1 more]</label></div><br/><div class="children"><div class="content">Even that could benefit from including a counterexample in almost every point.</div><br/></div></div><div id="41543903" class="c"><input type="checkbox" id="c-41543903" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543210">parent</a><span>|</span><a href="#41543606">prev</a><span>|</span><a href="#41544853">next</a><span>|</span><label class="collapse" for="c-41543903">[-]</label><label class="expand" for="c-41543903">[1 more]</label></div><br/><div class="children"><div class="content">I saw this one first, but seems patio11 was first:<p><a href="https:&#x2F;&#x2F;infiniteundo.com&#x2F;post&#x2F;25326999628&#x2F;falsehoods-programmers-believe-about-time" rel="nofollow">https:&#x2F;&#x2F;infiniteundo.com&#x2F;post&#x2F;25326999628&#x2F;falsehoods-program...</a></div><br/></div></div><div id="41544853" class="c"><input type="checkbox" id="c-41544853" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543210">parent</a><span>|</span><a href="#41543903">prev</a><span>|</span><a href="#41543239">next</a><span>|</span><label class="collapse" for="c-41544853">[-]</label><label class="expand" for="c-41544853">[1 more]</label></div><br/><div class="children"><div class="content">i thought this list was also self-explanatory. i didn&#x27;t have a hard time thinking of counterexamples to any of the points, which is not true of patio11&#x27;s article. but what&#x27;s self-explanatory depends on your knowledge base. maybe i just know less about foreign cultures than i do about tcp</div><br/></div></div></div></div><div id="41543239" class="c"><input type="checkbox" id="c-41543239" checked=""/><div class="controls bullet"><span class="by">gweinberg</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41543210">prev</a><span>|</span><a href="#41542643">next</a><span>|</span><label class="collapse" for="c-41543239">[-]</label><label class="expand" for="c-41543239">[1 more]</label></div><br/><div class="children"><div class="content">This. If these lists contained things that programmers actually believed and explained why they are false, they might actually be useful. It&#x27;s hard to imagine an unsupported assertion that an ambiguous statement is &quot;false&quot; and yet its contradiction is also &quot;false&quot;.</div><br/></div></div><div id="41542643" class="c"><input type="checkbox" id="c-41542643" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41543239">prev</a><span>|</span><a href="#41545074">next</a><span>|</span><label class="collapse" for="c-41542643">[-]</label><label class="expand" for="c-41542643">[3 more]</label></div><br/><div class="children"><div class="content">I’m pretty sure originals that defined this format did have examples and citations.<p>But I do agree that some of the later entries have felt a little lazy.</div><br/><div id="41543190" class="c"><input type="checkbox" id="c-41543190" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41542643">parent</a><span>|</span><a href="#41545074">next</a><span>|</span><label class="collapse" for="c-41543190">[-]</label><label class="expand" for="c-41543190">[2 more]</label></div><br/><div class="children"><div class="content">Right, I was about to comment that. One of the first ones I remember was this one, about addresses[1]; or this one, about names[2]. Both provide examples and information, which is the only thing making the whole article useful.<p><pre><code>  [1]: https:&#x2F;&#x2F;www.mjt.me.uk&#x2F;posts&#x2F;falsehoods-programmers-believe-about-addresses&#x2F;
  [2]: https:&#x2F;&#x2F;shinesolutions.com&#x2F;2018&#x2F;01&#x2F;08&#x2F;falsehoods-programmers-believe-about-names-with-examples&#x2F;</code></pre></div><br/><div id="41543991" class="c"><input type="checkbox" id="c-41543991" checked=""/><div class="controls bullet"><span class="by">koala_man</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543190">parent</a><span>|</span><a href="#41545074">next</a><span>|</span><label class="collapse" for="c-41543991">[-]</label><label class="expand" for="c-41543991">[1 more]</label></div><br/><div class="children"><div class="content">I remember the address one. It was fantastic and I loved it. I wish they were all that helpful.</div><br/></div></div></div></div></div></div><div id="41545561" class="c"><input type="checkbox" id="c-41545561" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41545074">prev</a><span>|</span><a href="#41542506">next</a><span>|</span><label class="collapse" for="c-41545561">[-]</label><label class="expand" for="c-41545561">[1 more]</label></div><br/><div class="children"><div class="content">I think these lists are often primarily intended as humorous, and perhaps a way to get you thinking about exceptions, not as a way to teach you more about the topic.</div><br/></div></div><div id="41542506" class="c"><input type="checkbox" id="c-41542506" checked=""/><div class="controls bullet"><span class="by">IAmNotACellist</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41545561">prev</a><span>|</span><a href="#41543141">next</a><span>|</span><label class="collapse" for="c-41542506">[-]</label><label class="expand" for="c-41542506">[4 more]</label></div><br/><div class="children"><div class="content">The following list contains only falsehoods:<p>1. You&#x27;re wrong<p>2. Okay, you&#x27;re right<p>3. Okay maybe you&#x27;re right or wrong but certainly not both</div><br/><div id="41543563" class="c"><input type="checkbox" id="c-41543563" checked=""/><div class="controls bullet"><span class="by">cubano</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41542506">parent</a><span>|</span><a href="#41543361">next</a><span>|</span><label class="collapse" for="c-41543563">[-]</label><label class="expand" for="c-41543563">[1 more]</label></div><br/><div class="children"><div class="content">Well perhaps your a photon and then you certainly are both.</div><br/></div></div><div id="41543361" class="c"><input type="checkbox" id="c-41543361" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41542506">parent</a><span>|</span><a href="#41543563">prev</a><span>|</span><a href="#41543141">next</a><span>|</span><label class="collapse" for="c-41543361">[-]</label><label class="expand" for="c-41543361">[2 more]</label></div><br/><div class="children"><div class="content">Aha!  You&#x27;re null.</div><br/><div id="41545816" class="c"><input type="checkbox" id="c-41545816" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41543361">parent</a><span>|</span><a href="#41543141">next</a><span>|</span><label class="collapse" for="c-41545816">[-]</label><label class="expand" for="c-41545816">[1 more]</label></div><br/><div class="children"><div class="content">Or a false premise, perhaps (from which anything follows).</div><br/></div></div></div></div></div></div><div id="41543141" class="c"><input type="checkbox" id="c-41543141" checked=""/><div class="controls bullet"><span class="by">numpad0</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41542506">prev</a><span>|</span><a href="#41543981">next</a><span>|</span><label class="collapse" for="c-41543141">[-]</label><label class="expand" for="c-41543141">[1 more]</label></div><br/><div class="children"><div class="content">I think the original &quot;names&quot; and subsequent &quot;addresses&quot; were useful in that a conclusion(that programmers should embrace defeatism and refrain from parsing or evaluating or even trying to separate them into fields) can be drawn, and the lessons learned were slightly more specific than often realized...</div><br/></div></div><div id="41543981" class="c"><input type="checkbox" id="c-41543981" checked=""/><div class="controls bullet"><span class="by">ahazred8ta</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41543141">prev</a><span>|</span><a href="#41544553">next</a><span>|</span><label class="collapse" for="c-41543981">[-]</label><label class="expand" for="c-41543981">[1 more]</label></div><br/><div class="children"><div class="content">Previously: &quot;falseoods programmers believe about <i>X</i>&quot;:<p><a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=false&amp;query=falsehoods%20believe&amp;sort=byDate&amp;type=story" rel="nofollow">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=false&amp;qu...</a></div><br/></div></div><div id="41542947" class="c"><input type="checkbox" id="c-41542947" checked=""/><div class="controls bullet"><span class="by">tenebrisalietum</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41544553">prev</a><span>|</span><a href="#41544121">next</a><span>|</span><label class="collapse" for="c-41542947">[-]</label><label class="expand" for="c-41542947">[1 more]</label></div><br/><div class="children"><div class="content">Falsehoods falsehood-list makers believe.<p>1. That said items are falsehoods in the first place.<p>2. That said items are necessarily interesting or noteworthy.<p>3. That a list is necessarily the best format to present said items.<p>4. That they may speak for the involved parties beliefs.</div><br/></div></div><div id="41544121" class="c"><input type="checkbox" id="c-41544121" checked=""/><div class="controls bullet"><span class="by">niobe</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41542947">prev</a><span>|</span><a href="#41542994">next</a><span>|</span><label class="collapse" for="c-41544121">[-]</label><label class="expand" for="c-41544121">[1 more]</label></div><br/><div class="children"><div class="content">I agree, this article was uninsightful.</div><br/></div></div><div id="41542994" class="c"><input type="checkbox" id="c-41542994" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41544121">prev</a><span>|</span><a href="#41542635">next</a><span>|</span><label class="collapse" for="c-41542994">[-]</label><label class="expand" for="c-41542994">[1 more]</label></div><br/><div class="children"><div class="content">I agree. This isn&#x27;t even a good one of those lists. It&#x27;s more like &quot;dubious pedantry to make me feel smart about my TCP knowledge&quot;.<p>1-4. Yes we know about the 2 generals problem. And yes we know what &quot;reliable&quot; means in this context.
5-6. This is just stupid.
7. Obviously not true. Nobody thinks this.
8-9. The reasons for and flaws of Nagle&#x27;s algorithm are well known.
10. This isn&#x27;t even true. Most of the time you <i>don&#x27;t</i> need to care about it. That&#x27;s the whole point of abstraction. You need to care about it if you are doing extensive performance optimisation, but usually you aren&#x27;t.
11. Again untrue. You <i>can</i> think of TCP as a two way pipe. Again that&#x27;s the whole point of abstraction.
12. Not sure exactly what they&#x27;re trying to say here but again it&#x27;s very well known that TCP and UDP are pretty much the only protocols that are likely to work on the internet.
13. Ditto. We all know why so many protocols are &quot;over HTTPS&quot;, e.g. DoH.
14. This isn&#x27;t a technical point.
15. Dunno what this is talking about but I&#x27;m guessing it&#x27;s along the lines of &quot;a byte is 8 bits&quot;, i.e. it is actually true in the modern world.</div><br/></div></div><div id="41542635" class="c"><input type="checkbox" id="c-41542635" checked=""/><div class="controls bullet"><span class="by">kranuck</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41542994">prev</a><span>|</span><a href="#41545692">next</a><span>|</span><label class="collapse" for="c-41542635">[-]</label><label class="expand" for="c-41542635">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I stopped with 5 and 6 and will never give the slightest care what this person has to say ever again.</div><br/></div></div><div id="41545546" class="c"><input type="checkbox" id="c-41545546" checked=""/><div class="controls bullet"><span class="by">sassy_quat</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41545692">prev</a><span>|</span><a href="#41542567">next</a><span>|</span><label class="collapse" for="c-41545546">[-]</label><label class="expand" for="c-41545546">[1 more]</label></div><br/><div class="children"><div class="content">Falsehoods considered harmful.</div><br/></div></div><div id="41542567" class="c"><input type="checkbox" id="c-41542567" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#41542411">parent</a><span>|</span><a href="#41545546">prev</a><span>|</span><a href="#41541907">next</a><span>|</span><label class="collapse" for="c-41542567">[-]</label><label class="expand" for="c-41542567">[5 more]</label></div><br/><div class="children"><div class="content">You’re doing it wrong.<p>“Falsehoods programmers believe…” articles are designed to make you THINK about problematic assumptions.  They are not like the 10 commandments and they are not decrees of absolute truth.</div><br/><div id="41543100" class="c"><input type="checkbox" id="c-41543100" checked=""/><div class="controls bullet"><span class="by">homebrewer</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41542567">parent</a><span>|</span><a href="#41542971">next</a><span>|</span><label class="collapse" for="c-41543100">[-]</label><label class="expand" for="c-41543100">[1 more]</label></div><br/><div class="children"><div class="content">Now imagine how much time could have been saved globally if one person spent half an hour writing a short description of why each point is false instead of making hundreds (or thousands) of people spend hours <i>thinking</i> about and researching every one of them. You&#x27;re probably left with more knowledge in the end if you&#x27;re not spoon-fed by the author, but how many of us need really deep knowledge of the TCP inner workings?</div><br/></div></div><div id="41542971" class="c"><input type="checkbox" id="c-41542971" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41542567">parent</a><span>|</span><a href="#41543100">prev</a><span>|</span><a href="#41543365">next</a><span>|</span><label class="collapse" for="c-41542971">[-]</label><label class="expand" for="c-41542971">[2 more]</label></div><br/><div class="children"><div class="content">Saying a thing and then saying the opposite, without elaborating, is not good at making you THINK.  This list is doing it wrong.</div><br/><div id="41543223" class="c"><input type="checkbox" id="c-41543223" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41542971">parent</a><span>|</span><a href="#41543365">next</a><span>|</span><label class="collapse" for="c-41543223">[-]</label><label class="expand" for="c-41543223">[1 more]</label></div><br/><div class="children"><div class="content">Yep, the original &quot;names&quot; one was mostly written so negating each of the points gave you the exception you needed to handle. Even the cases written with both were done on a way it was obvious the negation didn&#x27;t apply universally, so both worked.</div><br/></div></div></div></div><div id="41543365" class="c"><input type="checkbox" id="c-41543365" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#41542411">root</a><span>|</span><a href="#41542567">parent</a><span>|</span><a href="#41542971">prev</a><span>|</span><a href="#41541907">next</a><span>|</span><label class="collapse" for="c-41543365">[-]</label><label class="expand" for="c-41543365">[1 more]</label></div><br/><div class="children"><div class="content">I look at &quot;Falsehoods programmers believe...&quot; articles as a good source of test cases. If I&#x27;m parsing a date (don&#x27;t do that), I&#x27;m going to look at &quot;Falsehoods programmers believe about dates&quot; to help build out my list of unit tests for that function. Same for names, street addresses and so on.</div><br/></div></div></div></div></div></div><div id="41541907" class="c"><input type="checkbox" id="c-41541907" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41542411">prev</a><span>|</span><a href="#41543923">next</a><span>|</span><label class="collapse" for="c-41541907">[-]</label><label class="expand" for="c-41541907">[36 more]</label></div><br/><div class="children"><div class="content">&gt; remember, all of the following statements are <i>false</i> at least some of the time, but for some of these, perhaps not very often<p>&gt; 5. There is a such thing as a TCP packet<p>&gt; 6. There is no such thing as a TCP packet<p>I don&#x27;t understand this at all.  Either the concept of a TCP packet exists, or the concept does not exist. Even it&#x27;s not being used in certain scenarios, I don&#x27;t see how you can argue that &quot;there&#x27;s no such thing&quot; any of the time. This might just be me misunderstanding whatever point they&#x27;re trying to make, but I don&#x27;t remember ever having such philosophical confusion from anything in any other &quot;falsehoods programmers believe about...&quot; article before.</div><br/><div id="41542052" class="c"><input type="checkbox" id="c-41542052" checked=""/><div class="controls bullet"><span class="by">ooterness</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41544067">next</a><span>|</span><label class="collapse" for="c-41542052">[-]</label><label class="expand" for="c-41542052">[11 more]</label></div><br/><div class="children"><div class="content">Pedantically: TCP has segments, IP has packets, and Ethernet has frames. They are one-to-one in simple cases, but not always.<p><a href="https:&#x2F;&#x2F;networkengineering.stackexchange.com&#x2F;questions&#x2F;50083&#x2F;" rel="nofollow">https:&#x2F;&#x2F;networkengineering.stackexchange.com&#x2F;questions&#x2F;50083...</a><p>In particular, fragmentation by intermediate routers means that the server and receiver may disagree about the frame and packet boundaries. TCP is expected to make a &quot;reliable&quot; pipe-like service out of whatever happens, and the application layer doesn&#x27;t have (shouldn&#x27;t need?) visibility into that process.</div><br/><div id="41543217" class="c"><input type="checkbox" id="c-41543217" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542052">parent</a><span>|</span><a href="#41544198">next</a><span>|</span><label class="collapse" for="c-41543217">[-]</label><label class="expand" for="c-41543217">[8 more]</label></div><br/><div class="children"><div class="content">Falsehoods programmers believe: TCP&#x2F;IP can be coherently mapped to the OSI model.</div><br/><div id="41543437" class="c"><input type="checkbox" id="c-41543437" checked=""/><div class="controls bullet"><span class="by">Rauchg</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41543217">parent</a><span>|</span><a href="#41544198">next</a><span>|</span><label class="collapse" for="c-41543437">[-]</label><label class="expand" for="c-41543437">[7 more]</label></div><br/><div class="children"><div class="content">Falsehoods programmers believe: the OSI model</div><br/><div id="41543657" class="c"><input type="checkbox" id="c-41543657" checked=""/><div class="controls bullet"><span class="by">devman0</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41543437">parent</a><span>|</span><a href="#41543570">next</a><span>|</span><label class="collapse" for="c-41543657">[-]</label><label class="expand" for="c-41543657">[4 more]</label></div><br/><div class="children"><div class="content">Falsehoods programmers believe: the OSI model is useless</div><br/><div id="41543944" class="c"><input type="checkbox" id="c-41543944" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41543657">parent</a><span>|</span><a href="#41543732">next</a><span>|</span><label class="collapse" for="c-41543944">[-]</label><label class="expand" for="c-41543944">[2 more]</label></div><br/><div class="children"><div class="content">Sure, it&#x27;s misleading, needs a lot of &quot;interpretation&quot; doing a non-trivial amount of the lifting to make it map to anything in the real world, mismatches things that happen in the real world while leaving no room for other things that happen in the real world a lot, and will lead anyone who tries to use it to understand the real world deeply astray, but it isn&#x27;t always wrong about absolutely everything so it has some non-zero &quot;utility&quot;.<p>Fine. It&#x27;s not wrong about absolutely everything all the time. It isn&#x27;t bereft of all truth. It&#x27;s just something that is of net negative value. I see no value in insisting on trying to &quot;rescue&quot; a net-negative value model of the world.<p>I suppose you could say ultimately I agree with you though. The OSI model isn&#x27;t useless. It&#x27;s <i>worse</i> than useless. You&#x27;re better off trying to understand networking from basic first principles than through the lens it provides.</div><br/><div id="41545234" class="c"><input type="checkbox" id="c-41545234" checked=""/><div class="controls bullet"><span class="by">devman0</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41543944">parent</a><span>|</span><a href="#41543732">next</a><span>|</span><label class="collapse" for="c-41545234">[-]</label><label class="expand" for="c-41545234">[1 more]</label></div><br/><div class="children"><div class="content">Analogies are rarely perfect, that&#x27;s why they are analogies. The OSI model isn&#x27;t intended to be perfect and yeah there are a lot of details that leak between layers, but is also expected, any non-trivial abstraction is always going to be leaky. That doesn&#x27;t mean it useless or absent of value in discussion at appropriate levels.</div><br/></div></div></div></div><div id="41543732" class="c"><input type="checkbox" id="c-41543732" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41543657">parent</a><span>|</span><a href="#41543944">prev</a><span>|</span><a href="#41543570">next</a><span>|</span><label class="collapse" for="c-41543732">[-]</label><label class="expand" for="c-41543732">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s useful.  It&#x27;s not controlling.</div><br/></div></div></div></div><div id="41543570" class="c"><input type="checkbox" id="c-41543570" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41543437">parent</a><span>|</span><a href="#41543657">prev</a><span>|</span><a href="#41544068">next</a><span>|</span><label class="collapse" for="c-41543570">[-]</label><label class="expand" for="c-41543570">[1 more]</label></div><br/><div class="children"><div class="content">Yep. <a href="https:&#x2F;&#x2F;dotat.at&#x2F;@&#x2F;2024-03-26-iso-osi-usw.html" rel="nofollow">https:&#x2F;&#x2F;dotat.at&#x2F;@&#x2F;2024-03-26-iso-osi-usw.html</a></div><br/></div></div></div></div></div></div><div id="41544198" class="c"><input type="checkbox" id="c-41544198" checked=""/><div class="controls bullet"><span class="by">ameliaquining</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542052">parent</a><span>|</span><a href="#41543217">prev</a><span>|</span><a href="#41544682">next</a><span>|</span><label class="collapse" for="c-41544198">[-]</label><label class="expand" for="c-41544198">[1 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;ve heard the term &quot;packet&quot; used to refer to the general category of thing that Ethernet frames, IP packets, and TCP segments are all examples of.</div><br/></div></div><div id="41544682" class="c"><input type="checkbox" id="c-41544682" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542052">parent</a><span>|</span><a href="#41544198">prev</a><span>|</span><a href="#41544067">next</a><span>|</span><label class="collapse" for="c-41544682">[-]</label><label class="expand" for="c-41544682">[1 more]</label></div><br/><div class="children"><div class="content">Those are all packets.</div><br/></div></div></div></div><div id="41544067" class="c"><input type="checkbox" id="c-41544067" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41542052">prev</a><span>|</span><a href="#41541979">next</a><span>|</span><label class="collapse" for="c-41544067">[-]</label><label class="expand" for="c-41544067">[2 more]</label></div><br/><div class="children"><div class="content">This one feels like the list-maker is struggling to communicate with me rather than telling me a surprising truth. I can&#x27;t tell whether it&#x27;s meant to mean &quot;a TCP segment won&#x27;t always fit 1:1 into an IP packet (but in the real world they mostly do)&quot;, &quot;TCP has segments instead of packets (but everyone knows what you mean when you say TCP packet)&quot;, or something else entirely.</div><br/><div id="41544283" class="c"><input type="checkbox" id="c-41544283" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41544067">parent</a><span>|</span><a href="#41541979">next</a><span>|</span><label class="collapse" for="c-41544283">[-]</label><label class="expand" for="c-41544283">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s basically the takeaway I had (and I failed to summarize as concisely, ironically enough). It seemed like there was some insight there, but I had absolutely no clue what it was.</div><br/></div></div></div></div><div id="41541979" class="c"><input type="checkbox" id="c-41541979" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41544067">prev</a><span>|</span><a href="#41542549">next</a><span>|</span><label class="collapse" for="c-41541979">[-]</label><label class="expand" for="c-41541979">[1 more]</label></div><br/><div class="children"><div class="content">What it really means is: Packets have well-defined boundaries between sufficiently-adjacent nodes. They are not guaranteed to keep those boundaries end-to-end over arbitrary middleware.</div><br/></div></div><div id="41542549" class="c"><input type="checkbox" id="c-41542549" checked=""/><div class="controls bullet"><span class="by">gwbas1c</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41541979">prev</a><span>|</span><a href="#41543559">next</a><span>|</span><label class="collapse" for="c-41542549">[-]</label><label class="expand" for="c-41542549">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 6. There is <i>no such thing</i> as a TCP packet<p>Because the software abstraction is a stream of bytes; and it&#x27;s up to the application to decide where the &quot;packets&quot; begin and end.<p>For example, I might write to a TCP socket: 100 bytes, 50 bytes, and then 125 bytes.<p>BUT, the receiver could get: A single event with 275 bytes. Or it could get an event with 75 bytes and then an event with 200 bytes. Or it could get 11 events of 25 bytes.<p>&gt; 5. There is a such thing as a TCP packet<p>This one I struggle with. I think the author is talking about connection set up, acking, and connection teardown.</div><br/><div id="41542841" class="c"><input type="checkbox" id="c-41542841" checked=""/><div class="controls bullet"><span class="by">sixfiveotwo</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542549">parent</a><span>|</span><a href="#41543559">next</a><span>|</span><label class="collapse" for="c-41542841">[-]</label><label class="expand" for="c-41542841">[1 more]</label></div><br/><div class="children"><div class="content">If you have a look at the underlying network traffic, you&#x27;ll see IP packets carrying TCP data, ie. The protocol field in the IP packet header will be set to TCP; this could be assimilated to a TCP packet.</div><br/></div></div></div></div><div id="41543559" class="c"><input type="checkbox" id="c-41543559" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41542549">prev</a><span>|</span><a href="#41541924">next</a><span>|</span><label class="collapse" for="c-41543559">[-]</label><label class="expand" for="c-41543559">[2 more]</label></div><br/><div class="children"><div class="content">I guess it’s talking about how the TCP data stream is segmented into IP packets. From the IP point of view, there are packets; from the application point of view there is a data stream; but it’s more complicated than that. Applications have some control over when TCP’s PSH flag is set, roughly speaking, at the end of each write(); and that in turn affects segmentation because small pushed writes cause small packets. But if the sender can’t send straight away then buffered data doesn’t preserve write() boundaries and will be sent with large packets.</div><br/><div id="41544701" class="c"><input type="checkbox" id="c-41544701" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41543559">parent</a><span>|</span><a href="#41541924">next</a><span>|</span><label class="collapse" for="c-41544701">[-]</label><label class="expand" for="c-41544701">[1 more]</label></div><br/><div class="children"><div class="content">I think we&#x27;re talking about different things.<p>TCP is a protocol that most certainly has packets (&quot;segments&quot;).<p>You are taking about a SOCK_STREAM-like programming interface, which can be used to create TCP connections.</div><br/></div></div></div></div><div id="41541924" class="c"><input type="checkbox" id="c-41541924" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41543559">prev</a><span>|</span><a href="#41542049">next</a><span>|</span><label class="collapse" for="c-41541924">[-]</label><label class="expand" for="c-41541924">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I agree with you here.<p>I think the thing most related to that that I see people thinking is that send(2) &amp; recv(2) calls translate 1:1 with packets send&#x2F;recv. I.e., that they don&#x27;t understand that the interface TCP exposes to applications is a byte stream. Which then results in things like thinking recv(2) will receive a complete &quot;message&quot; for some definition of message in the application protocol (i.e., the mistake belief that fragmentation won&#x27;t happen).</div><br/></div></div><div id="41542049" class="c"><input type="checkbox" id="c-41542049" checked=""/><div class="controls bullet"><span class="by">fracus</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41541924">prev</a><span>|</span><a href="#41542026">next</a><span>|</span><label class="collapse" for="c-41542049">[-]</label><label class="expand" for="c-41542049">[9 more]</label></div><br/><div class="children"><div class="content">5 and 6 are mutually exclusive.  They don&#x27;t make sense logically.  And most of the list was never explained at all.</div><br/><div id="41542197" class="c"><input type="checkbox" id="c-41542197" checked=""/><div class="controls bullet"><span class="by">ordu</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542049">parent</a><span>|</span><a href="#41542279">next</a><span>|</span><label class="collapse" for="c-41542197">[-]</label><label class="expand" for="c-41542197">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; They don&#x27;t make sense logically</i><p>In practice such situations can arise in one of two cases:<p>1. some non-sense creeped in<p>2. logic is applied to a self-contradictory set of axioms and definitions.<p>(1) is not very interesting, but (2) happens frequently enough because people often do not try to formalize their definitions and axioms. As a consequence they are using some vague concepts and their statements are true in some cases but not in others.<p>With all that said, I can propose the way how this logical non-sense could be <i>right</i>. (NB. I don&#x27;t know if it applies to TCP, I&#x27;m just thinking generally, and just as an example to all that abstract words above) The notion of &quot;existence&quot; of the mistaken programmer can be wrong. If we accept their definition of existence, then TCP packets doesn&#x27;t exist, but they exist in some other sense.</div><br/><div id="41542573" class="c"><input type="checkbox" id="c-41542573" checked=""/><div class="controls bullet"><span class="by">astrobe_</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542197">parent</a><span>|</span><a href="#41542279">next</a><span>|</span><label class="collapse" for="c-41542573">[-]</label><label class="expand" for="c-41542573">[1 more]</label></div><br/><div class="children"><div class="content">Yes. If one applies correctly the rules of logic on inconsistent axioms, the conclusions will be inconsistent. If one incorrectly applies logic to inconsistent axioms, the conclusions may or may not be consistent. It happens IRL sometimes; &quot;being right for the wrong reasons&quot;.
That being said, I suspect the game of the author is to play with leaky abstractions. TCP is a stream-oriented protocol, but is implemented on top of frames etc.</div><br/></div></div></div></div><div id="41542279" class="c"><input type="checkbox" id="c-41542279" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542049">parent</a><span>|</span><a href="#41542197">prev</a><span>|</span><a href="#41542206">next</a><span>|</span><label class="collapse" for="c-41542279">[-]</label><label class="expand" for="c-41542279">[5 more]</label></div><br/><div class="children"><div class="content">They are not mutually exclusive statements, because they don&#x27;t exist in isolation: they are both potentially true and false depending on the context of discussion.</div><br/><div id="41544306" class="c"><input type="checkbox" id="c-41544306" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542279">parent</a><span>|</span><a href="#41543428">next</a><span>|</span><label class="collapse" for="c-41544306">[-]</label><label class="expand" for="c-41544306">[2 more]</label></div><br/><div class="children"><div class="content">This seems like it&#x27;s either a linguistic or philosophical question; either I don&#x27;t interpret the words &quot;such a thing&quot; in a way that the author meant it, or I have a divergent different philosophical worldview on the concept of &quot;existence&quot; from the author&#x27;s own view.<p>Either way, this stuck out to me because usually these type of lists have very simple, understandable statements that just happen to surprise some people by not being true; in this case, the statements themselves are confusing, so I can&#x27;t really say for certain whether I believe them or not because I don&#x27;t even know what truth they&#x27;re asserting to try to negate it.</div><br/><div id="41546227" class="c"><input type="checkbox" id="c-41546227" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41544306">parent</a><span>|</span><a href="#41543428">next</a><span>|</span><label class="collapse" for="c-41546227">[-]</label><label class="expand" for="c-41546227">[1 more]</label></div><br/><div class="children"><div class="content">&gt; these type of lists have very simple, understandable statements<p>One of the defining characteristics of these lists is that they are <i>wry</i>. The couplet is clearly presented <i>in jest</i> to illustrate the point about assigning context, since this is the pathway to resolve the overt contradiction in terminology without getting stuck in a rigid thinking trap.</div><br/></div></div></div></div><div id="41543428" class="c"><input type="checkbox" id="c-41543428" checked=""/><div class="controls bullet"><span class="by">Feathercrown</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542279">parent</a><span>|</span><a href="#41544306">prev</a><span>|</span><a href="#41542206">next</a><span>|</span><label class="collapse" for="c-41543428">[-]</label><label class="expand" for="c-41543428">[2 more]</label></div><br/><div class="children"><div class="content">But they assert whether or not something exists, as an absolute statement. Maybe TCP packets don&#x27;t exist in a particular situation, but there is still such a thing as a TCP packet in that case.</div><br/></div></div></div></div><div id="41542206" class="c"><input type="checkbox" id="c-41542206" checked=""/><div class="controls bullet"><span class="by">alephnerd</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41542049">parent</a><span>|</span><a href="#41542279">prev</a><span>|</span><a href="#41542026">next</a><span>|</span><label class="collapse" for="c-41542206">[-]</label><label class="expand" for="c-41542206">[1 more]</label></div><br/><div class="children"><div class="content">The point is that a lot of stuff in Networking (and Computer Engineering in general) is very context dependent, and that you cannot be extremely opinionated about this stuff.</div><br/></div></div></div></div><div id="41542026" class="c"><input type="checkbox" id="c-41542026" checked=""/><div class="controls bullet"><span class="by">jpollock</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41542049">prev</a><span>|</span><a href="#41542017">next</a><span>|</span><label class="collapse" for="c-41542026">[-]</label><label class="expand" for="c-41542026">[1 more]</label></div><br/><div class="children"><div class="content">If I had to guess, it would be an assumption that TCP was edge to edge with no translation in the middle.<p>My guess is that this is talking about systems in the middle of the network, changing (for example) their sizes by combining and splitting packets to fit through various transits.</div><br/></div></div><div id="41542017" class="c"><input type="checkbox" id="c-41542017" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41542026">prev</a><span>|</span><a href="#41543490">next</a><span>|</span><label class="collapse" for="c-41542017">[-]</label><label class="expand" for="c-41542017">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s about your abstraction level and the kinds of problem you are ignoring. It&#x27;s true at the same time that you can&#x27;t ignore the problems of stream communication nor the problems of package-based communication.</div><br/></div></div><div id="41543490" class="c"><input type="checkbox" id="c-41543490" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41542017">prev</a><span>|</span><a href="#41543780">next</a><span>|</span><label class="collapse" for="c-41543490">[-]</label><label class="expand" for="c-41543490">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps it could be rescued by rephrasing them as &quot;is always&quot; versus &quot;is never&quot;?</div><br/><div id="41544321" class="c"><input type="checkbox" id="c-41544321" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41543490">parent</a><span>|</span><a href="#41543780">next</a><span>|</span><label class="collapse" for="c-41544321">[-]</label><label class="expand" for="c-41544321">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t really change my reading of those statements; the issue to me is that &quot;there is such a thing as X&quot; sounds to me like an existential proposition, i.e. &quot;X exists&quot;. The idea that an abstract descriptive concept only sometimes exists doesn&#x27;t really make sense to me; it sounds like saying that addition only &quot;sometimes&quot; exists because there are equations that only use division and not addition.</div><br/></div></div></div></div><div id="41543780" class="c"><input type="checkbox" id="c-41543780" checked=""/><div class="controls bullet"><span class="by">loopdoend</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41543490">prev</a><span>|</span><a href="#41541966">next</a><span>|</span><label class="collapse" for="c-41543780">[-]</label><label class="expand" for="c-41543780">[2 more]</label></div><br/><div class="children"><div class="content">It exists but more as a TCP stream, which is broadcast as packets...</div><br/><div id="41545586" class="c"><input type="checkbox" id="c-41545586" checked=""/><div class="controls bullet"><span class="by">Ekaros</span><span>|</span><a href="#41541907">root</a><span>|</span><a href="#41543780">parent</a><span>|</span><a href="#41541966">next</a><span>|</span><label class="collapse" for="c-41545586">[-]</label><label class="expand" for="c-41545586">[1 more]</label></div><br/><div class="children"><div class="content">Unicast. Unless we are talking about wifi... Which gets to very similar context based mess.</div><br/></div></div></div></div><div id="41541966" class="c"><input type="checkbox" id="c-41541966" checked=""/><div class="controls bullet"><span class="by">abnry</span><span>|</span><a href="#41541907">parent</a><span>|</span><a href="#41543780">prev</a><span>|</span><a href="#41543923">next</a><span>|</span><label class="collapse" for="c-41541966">[-]</label><label class="expand" for="c-41541966">[1 more]</label></div><br/><div class="children"><div class="content">My only guess how this could make sense is if there is some ambiguity in the definition of a TCP packet.</div><br/></div></div></div></div><div id="41543923" class="c"><input type="checkbox" id="c-41543923" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41541907">prev</a><span>|</span><a href="#41542045">next</a><span>|</span><label class="collapse" for="c-41543923">[-]</label><label class="expand" for="c-41543923">[7 more]</label></div><br/><div class="children"><div class="content">Has this author never heard of error correcting codes? The whole point of them is to <i>assume</i> there&#x27;s lossiness and add bytes to allow correction (or at least detection) of tampered or missing bytes. That&#x27;s why TCP (or maybe it&#x27;s Ethernet?) frames include FEC bytes in their message format.<p>Additionally, I&#x27;m sure they&#x27;re aware that HTTP over TLS has encrypted data frames, which would be unreceivable in a lot of cases if these situations arose a bunch. And considering how much of the modern Internet is built on this paradigm, I think that many of these points are rare and probably extremely pedantic.<p>This is coming from someone who agrees with much of the nuance implied (but not explained!) by the post.<p>All great technical writing (which I assume these clickbait articles are at least attempting to be) is written with mutual discovery and deeper understanding in mind, and if you leave no actual explanation in the post, you can&#x27;t really achieve either of those.</div><br/><div id="41544011" class="c"><input type="checkbox" id="c-41544011" checked=""/><div class="controls bullet"><span class="by">okl</span><span>|</span><a href="#41543923">parent</a><span>|</span><a href="#41544020">next</a><span>|</span><label class="collapse" for="c-41544011">[-]</label><label class="expand" for="c-41544011">[5 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s why TCP (or maybe it&#x27;s Ethernet?) frames include FEC bytes in their message format.<p>Neither TCP nor Ethernet provide for forward error correction. Ethernet frames include a 32-bit CRC while TCP segments use the so called &quot;internet checksum&quot;.</div><br/><div id="41544450" class="c"><input type="checkbox" id="c-41544450" checked=""/><div class="controls bullet"><span class="by">ephl</span><span>|</span><a href="#41543923">root</a><span>|</span><a href="#41544011">parent</a><span>|</span><a href="#41544116">next</a><span>|</span><label class="collapse" for="c-41544450">[-]</label><label class="expand" for="c-41544450">[1 more]</label></div><br/><div class="children"><div class="content">IEEE 802.3, the ethernet working group, defines FEC for many media types. While Ethernet frames do not themselves contain forward error correction, in many cases they are encoded with FEC before they hit the line. This is required by spec for most long low speed and all high speed links. You couldn’t get any frames through without it.</div><br/></div></div><div id="41544116" class="c"><input type="checkbox" id="c-41544116" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41543923">root</a><span>|</span><a href="#41544011">parent</a><span>|</span><a href="#41544450">prev</a><span>|</span><a href="#41544020">next</a><span>|</span><label class="collapse" for="c-41544116">[-]</label><label class="expand" for="c-41544116">[3 more]</label></div><br/><div class="children"><div class="content">Cunningham&#x27;s law at work!</div><br/><div id="41544178" class="c"><input type="checkbox" id="c-41544178" checked=""/><div class="controls bullet"><span class="by">minetest2048</span><span>|</span><a href="#41543923">root</a><span>|</span><a href="#41544116">parent</a><span>|</span><a href="#41544020">next</a><span>|</span><label class="collapse" for="c-41544178">[-]</label><label class="expand" for="c-41544178">[2 more]</label></div><br/><div class="children"><div class="content">Some flavors of optical ethernet do have FEC: <a href="https:&#x2F;&#x2F;www.cisco.com&#x2F;c&#x2F;en&#x2F;us&#x2F;products&#x2F;collateral&#x2F;interfaces-modules&#x2F;transceiver-modules&#x2F;implementation-optics-wp.html" rel="nofollow">https:&#x2F;&#x2F;www.cisco.com&#x2F;c&#x2F;en&#x2F;us&#x2F;products&#x2F;collateral&#x2F;interfaces...</a></div><br/><div id="41544217" class="c"><input type="checkbox" id="c-41544217" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41543923">root</a><span>|</span><a href="#41544178">parent</a><span>|</span><a href="#41544020">next</a><span>|</span><label class="collapse" for="c-41544217">[-]</label><label class="expand" for="c-41544217">[1 more]</label></div><br/><div class="children"><div class="content">See above :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41542045" class="c"><input type="checkbox" id="c-41542045" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41543923">prev</a><span>|</span><a href="#41545092">next</a><span>|</span><label class="collapse" for="c-41542045">[-]</label><label class="expand" for="c-41542045">[18 more]</label></div><br/><div class="children"><div class="content">I recall it blew my fiancée’s mind that I could unplug her ethernet cable, move it around an obstacle, plug it back in and all her connections were still alive. It’s designed to have bombs dropped on it.</div><br/><div id="41542266" class="c"><input type="checkbox" id="c-41542266" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41542045">parent</a><span>|</span><a href="#41542434">next</a><span>|</span><label class="collapse" for="c-41542266">[-]</label><label class="expand" for="c-41542266">[6 more]</label></div><br/><div class="children"><div class="content">Depends on OS settings these days. Lots of OSes want to help and detect link down and reset all your connections. Kind of a pain when you just want to move a cable.</div><br/><div id="41542625" class="c"><input type="checkbox" id="c-41542625" checked=""/><div class="controls bullet"><span class="by">sgerenser</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41542266">parent</a><span>|</span><a href="#41542434">next</a><span>|</span><label class="collapse" for="c-41542625">[-]</label><label class="expand" for="c-41542625">[5 more]</label></div><br/><div class="children"><div class="content">Like Chrome’s oh so helpful ERR_NETWORK_CHANGED</div><br/><div id="41543008" class="c"><input type="checkbox" id="c-41543008" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41542625">parent</a><span>|</span><a href="#41542708">next</a><span>|</span><label class="collapse" for="c-41543008">[-]</label><label class="expand" for="c-41543008">[2 more]</label></div><br/><div class="children"><div class="content">Also known as ERR_FUCK_YOU. Yes, I know that I&#x27;m connected to a misbehaving wifi router. Just load the fucking page.</div><br/><div id="41543214" class="c"><input type="checkbox" id="c-41543214" checked=""/><div class="controls bullet"><span class="by">whaleofatw2022</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41543008">parent</a><span>|</span><a href="#41542708">next</a><span>|</span><label class="collapse" for="c-41543214">[-]</label><label class="expand" for="c-41543214">[1 more]</label></div><br/><div class="children"><div class="content">Loud</div><br/></div></div></div></div><div id="41542708" class="c"><input type="checkbox" id="c-41542708" checked=""/><div class="controls bullet"><span class="by">Avamander</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41542625">parent</a><span>|</span><a href="#41543008">prev</a><span>|</span><a href="#41545517">next</a><span>|</span><label class="collapse" for="c-41542708">[-]</label><label class="expand" for="c-41542708">[1 more]</label></div><br/><div class="children"><div class="content">Like, I know?! Just reload the page already, I&#x27;ve told you twice.<p>It&#x27;s rather irritating.</div><br/></div></div><div id="41545517" class="c"><input type="checkbox" id="c-41545517" checked=""/><div class="controls bullet"><span class="by">switch007</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41542625">parent</a><span>|</span><a href="#41542708">prev</a><span>|</span><a href="#41542434">next</a><span>|</span><label class="collapse" for="c-41545517">[-]</label><label class="expand" for="c-41545517">[1 more]</label></div><br/><div class="children"><div class="content">Drives me insane on Android with a VPN</div><br/></div></div></div></div></div></div><div id="41542434" class="c"><input type="checkbox" id="c-41542434" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#41542045">parent</a><span>|</span><a href="#41542266">prev</a><span>|</span><a href="#41542250">next</a><span>|</span><label class="collapse" for="c-41542434">[-]</label><label class="expand" for="c-41542434">[6 more]</label></div><br/><div class="children"><div class="content">.. on Linux. If you do that on Windows the MAC will detect the loss of link pulses, report the interface as down, and Windows will &quot;helpfully&quot; reset all your TCP connections.</div><br/><div id="41544734" class="c"><input type="checkbox" id="c-41544734" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41542434">parent</a><span>|</span><a href="#41543010">next</a><span>|</span><label class="collapse" for="c-41544734">[-]</label><label class="expand" for="c-41544734">[1 more]</label></div><br/><div class="children"><div class="content">I remember there was a (now rather obscure) patch floating around in the days of Win9x&#x2F;2K that gave you the Linux behaviour, with an associated option to extend the timeout to <i>very</i> large values.<p>Later, Microsoft made it configurable:<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;troubleshoot&#x2F;windows-server&#x2F;networking&#x2F;disable-media-sensing-feature-for-tcpip" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;troubleshoot&#x2F;windows-serve...</a><p>Of course if the connection is active when that happens, the other end will probably not like the prolonged silence, and give up first.</div><br/></div></div><div id="41543010" class="c"><input type="checkbox" id="c-41543010" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41542434">parent</a><span>|</span><a href="#41544734">prev</a><span>|</span><a href="#41542250">next</a><span>|</span><label class="collapse" for="c-41543010">[-]</label><label class="expand" for="c-41543010">[4 more]</label></div><br/><div class="children"><div class="content">That seems like way more sensible behaviour.</div><br/><div id="41544496" class="c"><input type="checkbox" id="c-41544496" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41543010">parent</a><span>|</span><a href="#41543422">next</a><span>|</span><label class="collapse" for="c-41544496">[-]</label><label class="expand" for="c-41544496">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a tradeoff between robustness to transient errors and reporting errors quickly. &quot;Most errors are transient&quot; is a widely applicable rule of thumb. But both approaches have merit.</div><br/></div></div><div id="41543422" class="c"><input type="checkbox" id="c-41543422" checked=""/><div class="controls bullet"><span class="by">Rygian</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41543010">parent</a><span>|</span><a href="#41544496">prev</a><span>|</span><a href="#41542250">next</a><span>|</span><label class="collapse" for="c-41543422">[-]</label><label class="expand" for="c-41543422">[2 more]</label></div><br/><div class="children"><div class="content">How so?</div><br/><div id="41544720" class="c"><input type="checkbox" id="c-41544720" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41543422">parent</a><span>|</span><a href="#41542250">next</a><span>|</span><label class="collapse" for="c-41544720">[-]</label><label class="expand" for="c-41544720">[1 more]</label></div><br/><div class="children"><div class="content">More immediate response to disconnection.<p>Rather than &quot;IDK keep sending but I haven&#x27;t heard ACK in a while&quot;</div><br/></div></div></div></div></div></div></div></div><div id="41542250" class="c"><input type="checkbox" id="c-41542250" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#41542045">parent</a><span>|</span><a href="#41542434">prev</a><span>|</span><a href="#41545092">next</a><span>|</span><label class="collapse" for="c-41542250">[-]</label><label class="expand" for="c-41542250">[5 more]</label></div><br/><div class="children"><div class="content">What happens in that case? I&#x27;m going to speculate:<p>1. Remote keeps sending stuff to your unplugged connection<p>2. You plug your ethernet cable back in<p>3. Your computer&#x27;s TCP acknowledges the last sequence number it received for each new sequence it receives from remote<p>4. Remote sees duplicate ACKs for same sequence number, interprets it as packet loss and resends the stuff</div><br/><div id="41542310" class="c"><input type="checkbox" id="c-41542310" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41542250">parent</a><span>|</span><a href="#41542326">next</a><span>|</span><label class="collapse" for="c-41542310">[-]</label><label class="expand" for="c-41542310">[1 more]</label></div><br/><div class="children"><div class="content">With timeouts. You can’t unplug it for an hour and have this happen. But a few seconds is exactly what this is designed for. As another commenter pointed out, your OS could also try to be “helpful”.</div><br/></div></div><div id="41542326" class="c"><input type="checkbox" id="c-41542326" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41542250">parent</a><span>|</span><a href="#41542310">prev</a><span>|</span><a href="#41542307">next</a><span>|</span><label class="collapse" for="c-41542326">[-]</label><label class="expand" for="c-41542326">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s pretty much it.<p>If packets were sent while you were disconnected, they&#x27;ll be gone, but if you&#x27;re disconnected for only part of the burst, duplicate ACKing will trigger retransmits.<p>If you were gone for the whole burst, you&#x27;ll get put right by timer based retransmits.<p>If you&#x27;re gone for long enough, most peers will timeout on unacknowledged data (although that&#x27;s not in the TCP RFC), and if there&#x27;s no outstanding data,  most peers  eventually have some sort of periodic ping and timeout (tcp keep-alives is a reasonable fallback IMHO, if your application protocol doesn&#x27;t have someything, although the default of IIRC 2 hours feels long in todays world of lots of NATs and much shorter timeouts).</div><br/><div id="41543753" class="c"><input type="checkbox" id="c-41543753" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41542045">root</a><span>|</span><a href="#41542326">parent</a><span>|</span><a href="#41542307">next</a><span>|</span><label class="collapse" for="c-41543753">[-]</label><label class="expand" for="c-41543753">[1 more]</label></div><br/><div class="children"><div class="content">It may be your local gateway.  Seeing no packets from your host.  Attempting to refresh your MAC address via ARP.  Getting no response.  Generating an ICMP message as a result.</div><br/></div></div></div></div></div></div></div></div><div id="41545092" class="c"><input type="checkbox" id="c-41545092" checked=""/><div class="controls bullet"><span class="by">nirui</span><span>|</span><a href="#41542045">prev</a><span>|</span><a href="#41542316">next</a><span>|</span><label class="collapse" for="c-41545092">[-]</label><label class="expand" for="c-41545092">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If the connection breaks while an ACK is outstanding, the sender will have no way of knowing whether the segment was received<p>The real question is, why this should be a problem that TCP must solve? TCP gives you a bidirectional waterflow-like pipe, and that&#x27;s enough for you to create many useful applications. TCP never provided guarantee for correct delivery, that&#x27;s your job.<p>For example, if a HTTP request is interrupted before the respond is received, the sender should assume the request never reach the server and try again with a new connection, while the server should mitigate duplicated requests (reject or return a successful code).<p>Well, maybe that&#x27;s the point of the article, because many web pages gets confused if you send duplicated requests to them.</div><br/><div id="41545154" class="c"><input type="checkbox" id="c-41545154" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#41545092">parent</a><span>|</span><a href="#41542316">next</a><span>|</span><label class="collapse" for="c-41545154">[-]</label><label class="expand" for="c-41545154">[1 more]</label></div><br/><div class="children"><div class="content">The server may or may not have seen the request, and the <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two_Generals%27_Problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two_Generals%27_Problem</a> proves it <i>impossible</i> to know in every case (no matter how many acks, the last could be dropped). A request that alters state should be retried using the same idempotency key, and the server should try to ack with whether the requested work already happened.</div><br/></div></div></div></div><div id="41542316" class="c"><input type="checkbox" id="c-41542316" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#41545092">prev</a><span>|</span><a href="#41542780">next</a><span>|</span><label class="collapse" for="c-41542316">[-]</label><label class="expand" for="c-41542316">[37 more]</label></div><br/><div class="children"><div class="content">Related: you can get at most once delivery or at least once delivery; you cannot get exactly once delivery. If I had a dollar for every junior who thought that a lack of exactly once delivery guarantees was a bug...</div><br/><div id="41543157" class="c"><input type="checkbox" id="c-41543157" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">parent</a><span>|</span><a href="#41544505">next</a><span>|</span><label class="collapse" for="c-41543157">[-]</label><label class="expand" for="c-41543157">[33 more]</label></div><br/><div class="children"><div class="content">If you can get at-least-once delivery, why can you not build exactly-once on top of that?<p>[UPDATE] Apparently I need to be more explicit about this.  My question is: if I can get at-least-once delivery, why can I not build an abstraction layer on the receiving node that provides the illusion of exactly-once delivery?  It seems like it should be a simple matter of keeping a log of received messages, and discarding duplicates.</div><br/><div id="41544577" class="c"><input type="checkbox" id="c-41544577" checked=""/><div class="controls bullet"><span class="by">Ayyyyyron</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543157">parent</a><span>|</span><a href="#41545090">next</a><span>|</span><label class="collapse" for="c-41544577">[-]</label><label class="expand" for="c-41544577">[8 more]</label></div><br/><div class="children"><div class="content">The principal difference between &#x27;at most once&#x27; and &#x27;at least once&#x27; is whether a sender re-tries when it is unsure if the recipient has received the message.
If the recipient&#x27;s ack never makes it back, then a sender cannot know whether they actually received the message or not (the two-generals problem).<p>So this hypothetical middleman will receive a packet, check that it&#x27;s not a duplicate, and forward it to the recipient it&#x27;s proxying for. How will it know that the recipient has actually received it?
If the receiver doesn&#x27;t ack the message in some way, which causes your abstraction to re-transmit the message again, then it exhibits &#x27;at least once&#x27; behavior.
If it the abstraction only ever forwards the message along once and doesn&#x27;t care whether the recipient acknowledged it or not, then it exhibits &#x27;at most once&#x27; behavior.<p>As a more concise answer - &#x27;exactly once&#x27; delivery is impossible because you can&#x27;t know if the recipient actually got the message.
If you assume a perfect communication channel, then I agree the problem is trivial, but I challenge you to find such a channel! Even on the same machine, interprocess communication can fail in all sorts of fun ways.</div><br/><div id="41544730" class="c"><input type="checkbox" id="c-41544730" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544577">parent</a><span>|</span><a href="#41544704">next</a><span>|</span><label class="collapse" for="c-41544730">[-]</label><label class="expand" for="c-41544730">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So this hypothetical middleman will receive a packet, check that it&#x27;s not a duplicate, and forward it to the recipient it&#x27;s proxying for. How will it know that the recipient has actually received it?<p>It seems like the answer is in the first part, the &quot;check that it&#x27;s not a duplicate&quot;.<p>Implement at-least-once but with a unique token to identify the request, and the receiver sends back acknowledgement with that token every time it receives the original message, but only hands it off for processing the first time.  Stuff this behind library&#x2F;API so it&#x27;s hidden to the user and the application code doesn&#x27;t have to handle it, and... isn&#x27;t that it?</div><br/><div id="41544924" class="c"><input type="checkbox" id="c-41544924" checked=""/><div class="controls bullet"><span class="by">Ayyyyyron</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544730">parent</a><span>|</span><a href="#41544704">next</a><span>|</span><label class="collapse" for="c-41544924">[-]</label><label class="expand" for="c-41544924">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but the handoff can fail in the same way (it can&#x27;t know if the thing it&#x27;s handing off to actually got it). But the application can also just be resilient to that with idempotent operations and have the handoff be at-least-once.</div><br/></div></div></div></div><div id="41544704" class="c"><input type="checkbox" id="c-41544704" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544577">parent</a><span>|</span><a href="#41544730">prev</a><span>|</span><a href="#41545090">next</a><span>|</span><label class="collapse" for="c-41544704">[-]</label><label class="expand" for="c-41544704">[5 more]</label></div><br/><div class="children"><div class="content">&gt; So this hypothetical middleman will receive a packet, check that it&#x27;s not a duplicate, and forward it to the recipient it&#x27;s proxying for.<p>That&#x27;s not how I would implement exactly-once on top of at-lest-once.  I would do it at the recipient, not at the intermediate nodes.<p>&gt; &#x27;exactly once&#x27; delivery is impossible because you can&#x27;t know if the recipient actually got the message<p>But the <i>recipient</i> can know.</div><br/><div id="41544884" class="c"><input type="checkbox" id="c-41544884" checked=""/><div class="controls bullet"><span class="by">Ayyyyyron</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544704">parent</a><span>|</span><a href="#41545090">next</a><span>|</span><label class="collapse" for="c-41544884">[-]</label><label class="expand" for="c-41544884">[4 more]</label></div><br/><div class="children"><div class="content">But the recipient is not one atomic thing - we&#x27;re assuming perfect communication between the process&#x2F;driver&#x2F;hardware receiving the packets and doing the duplicate detection and the process which wants to receive the message exactly once.<p>There&#x27;s still communication happening there, and it can still fail. Buffers fill, processes pause for arbitrary delays which exceed timeouts, etc. Your assumptions based on your model are correct, but your model doesn&#x27;t include that communication.<p>But all models have some level of detail they care about, and assuming the computer always works is a perfectly valid model for plenty of cases. It&#x27;s just not all of them. You&#x27;ll be able to create real-world cases where this abstraction is faced with a choice of whether to retry or not, and at that moment it will be unable to deliver exactly once.</div><br/><div id="41544927" class="c"><input type="checkbox" id="c-41544927" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544884">parent</a><span>|</span><a href="#41545090">next</a><span>|</span><label class="collapse" for="c-41544927">[-]</label><label class="expand" for="c-41544927">[3 more]</label></div><br/><div class="children"><div class="content">&gt; we&#x27;re assuming perfect communication between the process&#x2F;driver&#x2F;hardware receiving the packets and doing the duplicate detection and the process which wants to receive the message exactly once<p>My claim is not that you can provide exactly-once delivery unconditionally.  My claim is that <i>if</i> you can provide at-least-once delivery then you can turn that into exactly-once delivery.  The word &quot;delivery&quot; is not rigorously defined, but IMO any reasonable definition necessarily entails a certain level of reliability at the receiving node.</div><br/><div id="41545113" class="c"><input type="checkbox" id="c-41545113" checked=""/><div class="controls bullet"><span class="by">Ayyyyyron</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544927">parent</a><span>|</span><a href="#41545090">next</a><span>|</span><label class="collapse" for="c-41545113">[-]</label><label class="expand" for="c-41545113">[2 more]</label></div><br/><div class="children"><div class="content">I agree with your claim, a recipient can cope with at-least-once delivery by being idempotent. You&#x27;re right.<p>The meaningful distinction is that something on the recipient needs to be idempotent because the message might get received twice. The application can be oblivious to this, so long as you assume that channel to be perfect.<p>People on the Internet won&#x27;t like you calling it &#x27;exactly once delivery&#x27; because it&#x27;s not exactly once - it&#x27;s an idempotent at-least-once. Which is great! But the statement of the at-least&#x2F;at-most problem is making a decision to re-try. There&#x27;s no middle ground, I either have to retry or not. People won&#x27;t like a claim that &#x27;exactly once&#x27; delivery is possible, because it isn&#x27;t, it&#x27;s just moving the at-least-once-ness to somewhere else.</div><br/><div id="41545241" class="c"><input type="checkbox" id="c-41545241" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41545113">parent</a><span>|</span><a href="#41545090">next</a><span>|</span><label class="collapse" for="c-41545241">[-]</label><label class="expand" for="c-41545241">[1 more]</label></div><br/><div class="children"><div class="content">&gt; People on the Internet won&#x27;t like you calling it &#x27;exactly once delivery&#x27; because it&#x27;s not exactly once<p>That depends entirely on what you mean by &quot;it&quot;.<p>Messages can get lost.  So if you want guaranteed delivery, you sometimes have to re-transmit the same message, and so you might end up with the same message being delivered more than once.  But it is trivial to put an abstraction layer on top of that to discard the duplicates and make it appear to the application as if every message is received exactly once.<p>The whole thing is a tempest in a teapot.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41545090" class="c"><input type="checkbox" id="c-41545090" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543157">parent</a><span>|</span><a href="#41544577">prev</a><span>|</span><a href="#41543470">next</a><span>|</span><label class="collapse" for="c-41545090">[-]</label><label class="expand" for="c-41545090">[2 more]</label></div><br/><div class="children"><div class="content">The problem is that sometimes your application intends to send messages[0] multiple times. If your &quot;log-and-discard&quot; system was implemented naively then each node could only ever send each possible message once and only once. Ever.<p>That would be like:<p>Alice: &quot;Honey, where did you put the keys?&quot;<p>Bob: &quot;They&#x27;re up on the counter.&quot;<p>(The next day...)<p>Alice: &quot;Honey, where did you put the keys?&quot;<p>Bob: (nothing, I already received this message, it could have echoed off the walls from yesterday)<p>What you need is for all sent messages to have unique IDs that will never repeat, and then log those. That&#x27;s known as an idempotency token.<p>But even then, logging all those UUIDs forever is probably not a good idea for disk usage. At some point you&#x27;ll have to trash old message logs and hope you don&#x27;t have a rogue network router retransmitting six month old messages or something.<p>[0] Or the moral equivalent of messages, e.g. HTTP POST requests</div><br/><div id="41545126" class="c"><input type="checkbox" id="c-41545126" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41545090">parent</a><span>|</span><a href="#41543470">next</a><span>|</span><label class="collapse" for="c-41545126">[-]</label><label class="expand" for="c-41545126">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What you need is for all sent messages to have unique IDs that will never repeat, and then log those. That&#x27;s known as an idempotency token.<p>So your problem is not really a problem because you yourself present the solution.  The real problem is:<p>&gt; But even then, logging all those UUIDs forever<p>But you don&#x27;t need to log them all forever.  Just make the UUIDs sequential, and all you need then is to keep track of the smallest id that has not yet been received.  (You can be more efficient by storing more state, but it&#x27;s not necessary.  Remember, we&#x27;re assuming at-least-once deliver here, so you can always force retransmission by not acknowledging receipt.)</div><br/></div></div></div></div><div id="41543470" class="c"><input type="checkbox" id="c-41543470" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543157">parent</a><span>|</span><a href="#41545090">prev</a><span>|</span><a href="#41543253">next</a><span>|</span><label class="collapse" for="c-41543470">[-]</label><label class="expand" for="c-41543470">[10 more]</label></div><br/><div class="children"><div class="content">You can get exactly once processing, but not exactly once delivery.<p><a href="https:&#x2F;&#x2F;bravenewgeek.com&#x2F;you-cannot-have-exactly-once-delivery&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bravenewgeek.com&#x2F;you-cannot-have-exactly-once-delive...</a></div><br/><div id="41543843" class="c"><input type="checkbox" id="c-41543843" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543470">parent</a><span>|</span><a href="#41543253">next</a><span>|</span><label class="collapse" for="c-41543843">[-]</label><label class="expand" for="c-41543843">[9 more]</label></div><br/><div class="children"><div class="content">That seems like a distinction without a difference to me.  Why should I care if the thing I get exactly one of is called &quot;processing&quot; or &quot;delivery&quot;?</div><br/><div id="41543980" class="c"><input type="checkbox" id="c-41543980" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543843">parent</a><span>|</span><a href="#41543990">next</a><span>|</span><label class="collapse" for="c-41543980">[-]</label><label class="expand" for="c-41543980">[7 more]</label></div><br/><div class="children"><div class="content">Because you need to understand that your processing code is constrained by the fact that you can&#x27;t get exactly-once delivery. You must write your processing code to handle it one way or another. There&#x27;s some libraries that try to wrap the abstraction of processing exactly once around the code, but those libraries still impose constraints on the sort of code you can write. They can make it easier but they can&#x27;t fully remove the need to think about how your processing code works. It isn&#x27;t exactly the same.<p>This is why people like me insist it&#x27;s important to understand that you can not have exactly-once delivery. There is no library that can make that just go away, they can only shuffle around exactly where the lumps under the carpet live, and if one programs with the mistaken idea that these libraries really do solve &quot;exactly once&quot; delivery, one <i>will</i> get into deep trouble. Possibly the &quot;my architecture is fundamentally broken and can&#x27;t be rescued&quot; sort of trouble.</div><br/><div id="41544169" class="c"><input type="checkbox" id="c-41544169" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543980">parent</a><span>|</span><a href="#41543990">next</a><span>|</span><label class="collapse" for="c-41544169">[-]</label><label class="expand" for="c-41544169">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Because you need to understand that your processing code is constrained by the fact that you can&#x27;t get exactly-once delivery.<p>Why do I need to understand that?  Why can I not put an abstraction layer that provides me with the illusion of exactly-once delivery?<p>&gt; There is no library that can make that just go away<p>Well, this is the thing that I dispute.  I believe that there <i>is</i> a library I can write to make it go away <i>if</i> I have at-least-once delivery.  In fact, I claim that writing such a library is an elementary exercise.  The TCP protocol is an existence proof.  Where is the flaw in my reasoning?</div><br/><div id="41544718" class="c"><input type="checkbox" id="c-41544718" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544169">parent</a><span>|</span><a href="#41544587">next</a><span>|</span><label class="collapse" for="c-41544718">[-]</label><label class="expand" for="c-41544718">[3 more]</label></div><br/><div class="children"><div class="content">TCP is at least once, not exactly once.<p>Here&#x27;s another useful article: <a href="https:&#x2F;&#x2F;blog.bulloak.io&#x2F;post&#x2F;20200917-the-impossibility-of-exactly-once&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.bulloak.io&#x2F;post&#x2F;20200917-the-impossibility-of-e...</a><p>TCP does not solve the two generals problem. TCP gets around this limitation by requiring only one ACK.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two_Generals%27_Problem#Engineering_approaches" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two_Generals%27_Problem#Engine...</a><p><a href="https:&#x2F;&#x2F;www.scaler.com&#x2F;topics&#x2F;computer-network&#x2F;two-generals-problem-in-tcp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scaler.com&#x2F;topics&#x2F;computer-network&#x2F;two-generals-...</a></div><br/><div id="41544736" class="c"><input type="checkbox" id="c-41544736" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544718">parent</a><span>|</span><a href="#41544587">next</a><span>|</span><label class="collapse" for="c-41544736">[-]</label><label class="expand" for="c-41544736">[2 more]</label></div><br/><div class="children"><div class="content">OK, but you have to do a little extrapolating here because the claim is not that you can do exactly-once under all circumstances.  That is obviously false because you can&#x27;t do exactly-once in a situation where all comms are down indefinitely.  My claim is that <i>if</i> I have at-least-once then I can build exactly-once out of that.</div><br/><div id="41545549" class="c"><input type="checkbox" id="c-41545549" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544736">parent</a><span>|</span><a href="#41544587">next</a><span>|</span><label class="collapse" for="c-41545549">[-]</label><label class="expand" for="c-41545549">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t about indefinite communication loss. Obviously no progress is possible in that case. The two generals&#x27; problem has nothing to do with a permanent failure.<p>I think there is a lot of literature out there if you&#x27;re really interested in understanding and I&#x27;m happy to provide more links if you&#x27;d like.</div><br/></div></div></div></div></div></div><div id="41544587" class="c"><input type="checkbox" id="c-41544587" checked=""/><div class="controls bullet"><span class="by">pton_xd</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544169">parent</a><span>|</span><a href="#41544718">prev</a><span>|</span><a href="#41543990">next</a><span>|</span><label class="collapse" for="c-41544587">[-]</label><label class="expand" for="c-41544587">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Why can I not put an abstraction layer that provides me with the illusion of exactly-once delivery?<p>You can do that. You can implement a video conferencing system ontop of TCP, and it will even work, technically. It will just have terrible performance characteristics that you&#x27;ll never be able to fix. You might even call it fundamentally broken.</div><br/><div id="41544687" class="c"><input type="checkbox" id="c-41544687" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544587">parent</a><span>|</span><a href="#41543990">next</a><span>|</span><label class="collapse" for="c-41544687">[-]</label><label class="expand" for="c-41544687">[1 more]</label></div><br/><div class="children"><div class="content">OK, I don&#x27;t dispute that, but that is a very different claim than &quot;you can&#x27;t get exactly-once delivery.&quot;  You can (if you have at-least-once delivery).</div><br/></div></div></div></div></div></div></div></div><div id="41543990" class="c"><input type="checkbox" id="c-41543990" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543843">parent</a><span>|</span><a href="#41543980">prev</a><span>|</span><a href="#41543253">next</a><span>|</span><label class="collapse" for="c-41543990">[-]</label><label class="expand" for="c-41543990">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know enough to answer this. I&#x27;m sure there is plenty of writing on this subject from people more qualified than me.</div><br/></div></div></div></div></div></div><div id="41543253" class="c"><input type="checkbox" id="c-41543253" checked=""/><div class="controls bullet"><span class="by">to11mtm</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543157">parent</a><span>|</span><a href="#41543470">prev</a><span>|</span><a href="#41543763">next</a><span>|</span><label class="collapse" for="c-41543253">[-]</label><label class="expand" for="c-41543253">[7 more]</label></div><br/><div class="children"><div class="content">Because &#x27;exactly once&#x27; delivery is arguably a misnomer, you usually <i>really</i> want &#x27;at least once delivery with acks and idempotent processing on the other side&#x27;.<p>The difference is subtle but important in practice and specification.</div><br/><div id="41543322" class="c"><input type="checkbox" id="c-41543322" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543253">parent</a><span>|</span><a href="#41543763">next</a><span>|</span><label class="collapse" for="c-41543322">[-]</label><label class="expand" for="c-41543322">[6 more]</label></div><br/><div class="children"><div class="content">&gt; you usually really want &#x27;at least once delivery with acks and idempotent processing on the other side&#x27;.<p>Why?  I&#x27;m pretty sure I really want (the illusion of) exactly-once delivery, and it seems to me that I can implement that pretty easily given at-least-once delivery.  Why would I not want that?<p>&gt; The difference is subtle but important<p>Why?</div><br/><div id="41544524" class="c"><input type="checkbox" id="c-41544524" checked=""/><div class="controls bullet"><span class="by">to11mtm</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543322">parent</a><span>|</span><a href="#41543521">next</a><span>|</span><label class="collapse" for="c-41544524">[-]</label><label class="expand" for="c-41544524">[2 more]</label></div><br/><div class="children"><div class="content">You can absolutely abstract 99% of it out.<p>But not 100%. At some point, a counter move on the delivery has to be stored... -somewhere-.<p>And sure you -can- make it very very close to EOD and for some subsets you can totally do EOD, but you <i>are</i>, realistically, better off with ALOD+Ack once it makes its way into a system. There&#x27;s always that &#x27;moving the counter&#x27; problem.<p>The upshot is, things tend to get faster, easier to code review, and simpler to test.<p><i>Pragmatically speaking</i>, I&#x27;ve found devs are better able to handle ALOD+ACK than &quot;Exactly once but because reality you might get a message that&#x27;s doubled because you couldn&#x27;t persist the ack&quot;.<p>And I&#x27;ll note I&#x27;m possibly extra pedantic about this because I&#x27;ve had a month and a half of dealing with the fallout of people trusting low-code salesmen alongside gartner reports leading to a &#x27;you people thought this was exactly once and it was not&#x27; sort of problem.</div><br/><div id="41544716" class="c"><input type="checkbox" id="c-41544716" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544524">parent</a><span>|</span><a href="#41543521">next</a><span>|</span><label class="collapse" for="c-41544716">[-]</label><label class="expand" for="c-41544716">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But not 100%.<p>Why not?<p>&gt; At some point, a counter move on the delivery has to be stored... -somewhere-.<p>What is a &quot;counter move on the delivery&quot;?</div><br/></div></div></div></div><div id="41543521" class="c"><input type="checkbox" id="c-41543521" checked=""/><div class="controls bullet"><span class="by">ZephyrBlu</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543322">parent</a><span>|</span><a href="#41544524">prev</a><span>|</span><a href="#41543763">next</a><span>|</span><label class="collapse" for="c-41543521">[-]</label><label class="expand" for="c-41543521">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I&#x27;m pretty sure I really want (the illusion of) exactly-once delivery</i><p>Do you know what idempotency is? This is exactly what he described.<p>Idempotency is important to prevent unwanted behaviour for duplicate actions. If you have &quot;exactly-once&quot;, and accidentally execute the action twice that could cause problems.</div><br/><div id="41543925" class="c"><input type="checkbox" id="c-41543925" checked=""/><div class="controls bullet"><span class="by">lttlrck</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543521">parent</a><span>|</span><a href="#41543799">next</a><span>|</span><label class="collapse" for="c-41543925">[-]</label><label class="expand" for="c-41543925">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you know what idempotency is? This is exactly what he described.<p>Is it though? It seems like a false equivalency, even if the outcome is approximately the same?</div><br/></div></div><div id="41543799" class="c"><input type="checkbox" id="c-41543799" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543521">parent</a><span>|</span><a href="#41543925">prev</a><span>|</span><a href="#41543763">next</a><span>|</span><label class="collapse" for="c-41543799">[-]</label><label class="expand" for="c-41543799">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you know what idempotency is?<p>Yes.<p>&gt; This is exactly what he described.<p>So?  Idempotency and an exactly-once delivery abstraction are not the same thing.</div><br/></div></div></div></div></div></div></div></div><div id="41543763" class="c"><input type="checkbox" id="c-41543763" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543157">parent</a><span>|</span><a href="#41543253">prev</a><span>|</span><a href="#41544505">next</a><span>|</span><label class="collapse" for="c-41543763">[-]</label><label class="expand" for="c-41543763">[5 more]</label></div><br/><div class="children"><div class="content">You cannot while maintaining the half-duplex behavior of the current system.</div><br/><div id="41543847" class="c"><input type="checkbox" id="c-41543847" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543763">parent</a><span>|</span><a href="#41544505">next</a><span>|</span><label class="collapse" for="c-41543847">[-]</label><label class="expand" for="c-41543847">[4 more]</label></div><br/><div class="children"><div class="content">Why not?  (Please see the update on my OP before answering that.)</div><br/><div id="41543942" class="c"><input type="checkbox" id="c-41543942" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543847">parent</a><span>|</span><a href="#41544505">next</a><span>|</span><label class="collapse" for="c-41543942">[-]</label><label class="expand" for="c-41543942">[3 more]</label></div><br/><div class="children"><div class="content">The mechanism you&#x27;re describing already exists.  TCP has sequence numbers.  It can drop duplicate data.<p>The difference between &quot;processing&quot; and &quot;delivery&quot; relates to &quot;network capacity.&quot;  Process handling wastes capacity in favor of latency.  Delivery handling increases latency in favor of capacity.<p>Systems which have &quot;exactly once&quot; delivery typically do so with &quot;send&#x2F;receive&quot; and &quot;release&#x2F;delete&quot; message pairs.  You need additional round trips to actually accomplish this at the &quot;delivery&quot; layer.</div><br/><div id="41544141" class="c"><input type="checkbox" id="c-41544141" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41543942">parent</a><span>|</span><a href="#41544505">next</a><span>|</span><label class="collapse" for="c-41544141">[-]</label><label class="expand" for="c-41544141">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The mechanism you&#x27;re describing already exists.<p>Yes, I know, which makes it all the more bizarre that people are claiming that this is impossible.<p>&gt; Systems which have &quot;exactly once&quot; delivery typically do so...<p>Ah, so exactly-once delivery <i>is</i> possible after all?</div><br/><div id="41545220" class="c"><input type="checkbox" id="c-41545220" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41542316">root</a><span>|</span><a href="#41544141">parent</a><span>|</span><a href="#41544505">next</a><span>|</span><label class="collapse" for="c-41545220">[-]</label><label class="expand" for="c-41545220">[1 more]</label></div><br/><div class="children"><div class="content">If your goal is simply to look smart then absorbing the subtlety of what is said to you before you reply should be top of list.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41544505" class="c"><input type="checkbox" id="c-41544505" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#41542316">parent</a><span>|</span><a href="#41543157">prev</a><span>|</span><a href="#41542373">next</a><span>|</span><label class="collapse" for="c-41544505">[-]</label><label class="expand" for="c-41544505">[1 more]</label></div><br/><div class="children"><div class="content">So fun fact, you actually <i>can</i> get exactly once delivery out of your network, but your network has to be not Ethernet&#x2F;IP&#x2F;TCP to do it.  Every single one of those layers is mis-designed to allow you to get exactly-once delivery of messages (TCP doesn&#x27;t even have a concept of messages).<p>Your network won&#x27;t have &quot;exactly once&quot; message transfer happening on it (it will internally be &quot;at least once&quot; for certain packets, but only small ones) and administering it will be very different than administering an Ethernet network, but network protocols absolutely can be designed to give exactly-once delivery to your software.<p>The real reason most people outside of HPC don&#x27;t do this is that exactly-once at the network layer is not that useful for most web stuff.  You&#x27;re going to have a higher layer that will drop stuff and retry anyway, so you might as well push the problem up the stack.</div><br/></div></div><div id="41542373" class="c"><input type="checkbox" id="c-41542373" checked=""/><div class="controls bullet"><span class="by">stanac</span><span>|</span><a href="#41542316">parent</a><span>|</span><a href="#41544505">prev</a><span>|</span><a href="#41542944">next</a><span>|</span><label class="collapse" for="c-41542373">[-]</label><label class="expand" for="c-41542373">[1 more]</label></div><br/><div class="children"><div class="content">Yup, I try to explain it with shouting a message to someone in a crowded room. You can yell at your boss &quot;I fixed the bug&quot;, they can confirm it or ignore you, which is delivery at most once if you don&#x27;t repeat the message. If you try to repeat the message until they confirm it, it is at least once delivery.<p>edit: Point is in confirming that message is received. If you don&#x27;t receive the confirmation the message was delivered at most once.</div><br/></div></div><div id="41542944" class="c"><input type="checkbox" id="c-41542944" checked=""/><div class="controls bullet"><span class="by">bcoates</span><span>|</span><a href="#41542316">parent</a><span>|</span><a href="#41542373">prev</a><span>|</span><a href="#41542780">next</a><span>|</span><label class="collapse" for="c-41542944">[-]</label><label class="expand" for="c-41542944">[1 more]</label></div><br/><div class="children"><div class="content">This is a popular saying that is basically wrong.<p>You have very limited guarantees around an arbitrarily bad partition, but this is also a detectable condition. Lots of defective systems exist, but in general non-defective systems generally guarantee &quot;exactly once delivery or detected failure&quot;</div><br/></div></div></div></div><div id="41542780" class="c"><input type="checkbox" id="c-41542780" checked=""/><div class="controls bullet"><span class="by">dasyatidprime</span><span>|</span><a href="#41542316">prev</a><span>|</span><a href="#41542085">next</a><span>|</span><label class="collapse" for="c-41542780">[-]</label><label class="expand" for="c-41542780">[1 more]</label></div><br/><div class="children"><div class="content">To some of the critics here: did you or did you not notice the “<i>Somebody ought to</i> write one of those […] Here, I&#x27;ll even <i>get the ball rolling</i>” framing? A polished such article this is not claiming itself to be! I would go as far as saying the HN submission title is misleading as a result.</div><br/></div></div><div id="41542085" class="c"><input type="checkbox" id="c-41542085" checked=""/><div class="controls bullet"><span class="by">dtaht</span><span>|</span><a href="#41542780">prev</a><span>|</span><a href="#41542845">next</a><span>|</span><label class="collapse" for="c-41542085">[-]</label><label class="expand" for="c-41542085">[2 more]</label></div><br/><div class="children"><div class="content">It really is astounding to me how so many still do not understand that tcp is not a function call, or behaviors like slow start and congestion avoidance.<p>Recently a new rate limiter for TCP went by that was so terribly, terribly broken, and I cannot help but imagine that most of the containers of the world suffer from Bufferbloat in general.</div><br/><div id="41542091" class="c"><input type="checkbox" id="c-41542091" checked=""/><div class="controls bullet"><span class="by">dtaht</span><span>|</span><a href="#41542085">parent</a><span>|</span><a href="#41542845">next</a><span>|</span><label class="collapse" for="c-41542091">[-]</label><label class="expand" for="c-41542091">[1 more]</label></div><br/><div class="children"><div class="content">The rate limiter in question: <a href="https:&#x2F;&#x2F;github.com&#x2F;cilium&#x2F;cilium&#x2F;issues&#x2F;29083">https:&#x2F;&#x2F;github.com&#x2F;cilium&#x2F;cilium&#x2F;issues&#x2F;29083</a></div><br/></div></div></div></div><div id="41542845" class="c"><input type="checkbox" id="c-41542845" checked=""/><div class="controls bullet"><span class="by">hamilyon2</span><span>|</span><a href="#41542085">prev</a><span>|</span><a href="#41545660">next</a><span>|</span><label class="collapse" for="c-41542845">[-]</label><label class="expand" for="c-41542845">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll go out on a limb: inside datacenter on your own hardware, you can safely ignore low-level pedantry and mostly ignore “weird networks” and use TCP as two-way Unix pipe.<p>“Mostly” because you still care about bandwidth limits and packet RPS limits and latency of course.</div><br/><div id="41542984" class="c"><input type="checkbox" id="c-41542984" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41542845">parent</a><span>|</span><a href="#41545660">next</a><span>|</span><label class="collapse" for="c-41542984">[-]</label><label class="expand" for="c-41542984">[5 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t, unless you&#x27;ve got a really solid understanding of your datacenter network and it&#x27;s 100% good all the time. Which is unlikely, from my experience as a server person.<p>If you&#x27;ve got dirty optics between two switches, now you&#x27;re getting packet loss and TCP rears its head. Hopefully it&#x27;s not an issue now, but diagnosing microbursting[1] was lots of fun, and really wigs TCP out. I&#x27;ve also run into &#x27;fabric congestion&#x27;. My true favorite though is when you&#x27;ve got 2x aggregation on servers, and 4x aggregation for top of rack switches to spine switches, so there&#x27;s 8 paths in each direction between two servers in adjacent racks, and only one path (sometimes in only one direction) is only running at 99.9%. That&#x27;s a real PITA to track down unless you have visibility into switching metrics.<p>[1] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Micro-bursting_(networking)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Micro-bursting_(networking)</a></div><br/><div id="41543327" class="c"><input type="checkbox" id="c-41543327" checked=""/><div class="controls bullet"><span class="by">to11mtm</span><span>|</span><a href="#41542845">root</a><span>|</span><a href="#41542984">parent</a><span>|</span><a href="#41543311">next</a><span>|</span><label class="collapse" for="c-41543327">[-]</label><label class="expand" for="c-41543327">[2 more]</label></div><br/><div class="children"><div class="content">Agreed.<p>Having done Akka.NET Remote&#x2F;Cluster setups in prod that survived <i>multiple</i> &#x27;new to the org&#x27; categories of DC Failures at their level of scale&#x2F;capacity [0] there&#x27;s a lot to account for if you want to keep everything happy and visible [1][2][3]<p>[0] - Cut fiber between DCs, Rack failures due to IO-ish type issues, bad switches... at least 2 out of 3.<p>[1] - The upshot was we were able to survive all of the scenarios in at worst a degraded state, Once or twice we needed a restart.<p>[2] - We also had enough metrics going on that we could detect DC&#x2F;server outages   about as quickly as whoever actually was monitoring the failing subsystem.<p>[3] - But here&#x27;s the funny rub. An APM tool was the Achilles heel for both our Akka Links, as well as our SQLServer connections. Once they installed an &#x27;agent&#x27; we more frequently had to do a &#x27;full cycle&#x27; to clean things up after an outage, or even an MSSQL Server reboot. After I left the shop I got confirmation that yes, the APM module was the problem.</div><br/><div id="41544064" class="c"><input type="checkbox" id="c-41544064" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41542845">root</a><span>|</span><a href="#41543327">parent</a><span>|</span><a href="#41543311">next</a><span>|</span><label class="collapse" for="c-41544064">[-]</label><label class="expand" for="c-41544064">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We also had enough metrics going on that we could detect DC&#x2F;server outages about as quickly as whoever actually was monitoring the failing subsystem.<p>Yeah, my Erlang clustering experience was that we (the customer) were the monitoring system for the DC&#x2F;managed hosting provider. Although, by the time we left there, they would have outage notifications before we put in tickets.</div><br/></div></div></div></div><div id="41543311" class="c"><input type="checkbox" id="c-41543311" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#41542845">root</a><span>|</span><a href="#41542984">parent</a><span>|</span><a href="#41543327">prev</a><span>|</span><a href="#41545660">next</a><span>|</span><label class="collapse" for="c-41543311">[-]</label><label class="expand" for="c-41543311">[2 more]</label></div><br/><div class="children"><div class="content">I was always suspicious about self-hosted high availability solutions (typically just diagrams, not yet implemented) that included redundant switches.<p>Given how generally reliable switches are, I was inclined to believe that a misconfiguration or flaky network cable on one switch was more likely to cause a downtime (or significant degradation) than an outright switch failure, so adding another switch was doubling the chances of trouble and, as you note, making it harder to troubleshoot.</div><br/><div id="41543542" class="c"><input type="checkbox" id="c-41543542" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41542845">root</a><span>|</span><a href="#41543311">parent</a><span>|</span><a href="#41545660">next</a><span>|</span><label class="collapse" for="c-41543542">[-]</label><label class="expand" for="c-41543542">[1 more]</label></div><br/><div class="children"><div class="content">It kind of depends. You do get some weird stuff to debug, and more connections = more likely that one of them is broken.<p>Otoh, if you ever do any scheduled maintenance on your switches (which is likely if they&#x27;re doing anything fancy), having properly setup redundancy means you can announce a likely brief loss of redundancy, rather than a likely brief full loss of connectivity. If you have the right knobs, you can gracefully fail out the switch under maintenance and everything goes smoothly. Of course, sometimes you reboot the redundant switch and it confuses the other one and servers lose connectivity anyway.</div><br/></div></div></div></div></div></div></div></div><div id="41545660" class="c"><input type="checkbox" id="c-41545660" checked=""/><div class="controls bullet"><span class="by">halayli</span><span>|</span><a href="#41542845">prev</a><span>|</span><a href="#41543203">next</a><span>|</span><label class="collapse" for="c-41545660">[-]</label><label class="expand" for="c-41545660">[1 more]</label></div><br/><div class="children"><div class="content">This post is meaningless without clearly defining what reliable means.<p>Regarding ack not being received by sender when connection breaks, it&#x27;s a weak and dishonest argument thinking it will strengthen their position, but completely ignoring the fact that TCP reliability is dependent on the simple and obvious fact that the connection exists!</div><br/></div></div><div id="41543203" class="c"><input type="checkbox" id="c-41543203" checked=""/><div class="controls bullet"><span class="by">grishka</span><span>|</span><a href="#41545660">prev</a><span>|</span><a href="#41542332">next</a><span>|</span><label class="collapse" for="c-41543203">[-]</label><label class="expand" for="c-41543203">[6 more]</label></div><br/><div class="children"><div class="content">This reminds me of a very particular problem that we tried to solve when I worked at VKontakte. It was about instant messaging and flaky mobile data connections.<p>The problem: you&#x27;re on a subway train and you send a message as it departs a station. The request does get to the server, but by the time the response arrives, the train is already in the tunnel and you don&#x27;t have a signal any more. So the client thinks that the message failed to send, but it was, in fact, sent successfully. The client would retry when it&#x27;s back online, and would send another copy of that message.<p>The solution was to send a client-generated &quot;random ID&quot; with each request. I much later learned that this is conventionally called an &quot;idempotency token&quot;. This worked, except there was now another problem: you sometimes receive your own message over the long-polling thing <i>before</i> the response to the request that sent it. You don&#x27;t know for sure whether it&#x27;s the message you just sent, or something else sent by a different client on the same account, because you don&#x27;t know the ID of your message yet. This was solved by me delaying the processing of outgoing messages on the client side until all outstanding messages are fully sent and their IDs are known.<p>Telegram solved this much more elegantly: when the client reconnects to the server, the server sends it all the responses that were not acknowledged during the previous connection. MTProto has its own acknowledgement mechanism in addition to TCP&#x27;s.<p>So yeah, instant messaging seems trivial at the first glance, but it turns out that TCP is a leaky enough abstraction that you need to somehow plug those leaks at the application level.</div><br/><div id="41545497" class="c"><input type="checkbox" id="c-41545497" checked=""/><div class="controls bullet"><span class="by">icehawk</span><span>|</span><a href="#41543203">parent</a><span>|</span><a href="#41543346">next</a><span>|</span><label class="collapse" for="c-41545497">[-]</label><label class="expand" for="c-41545497">[1 more]</label></div><br/><div class="children"><div class="content">Honest question: Why didn&#x27;t you send the message&#x27;s idempotency token back to the client?  Then you&#x27;re playing the familiar local database locking game.</div><br/></div></div><div id="41543346" class="c"><input type="checkbox" id="c-41543346" checked=""/><div class="controls bullet"><span class="by">zmj</span><span>|</span><a href="#41543203">parent</a><span>|</span><a href="#41545497">prev</a><span>|</span><a href="#41543963">next</a><span>|</span><label class="collapse" for="c-41543346">[-]</label><label class="expand" for="c-41543346">[1 more]</label></div><br/><div class="children"><div class="content">I had to deal with the second problem in a file synchronization app. The solution was to propagate a “device id” through the request and poll&#x2F;push, so the originating device could ignore changes that it originated.</div><br/></div></div><div id="41543963" class="c"><input type="checkbox" id="c-41543963" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#41543203">parent</a><span>|</span><a href="#41543346">prev</a><span>|</span><a href="#41543874">next</a><span>|</span><label class="collapse" for="c-41543963">[-]</label><label class="expand" for="c-41543963">[2 more]</label></div><br/><div class="children"><div class="content">&gt; because you don&#x27;t know the ID of your message yet<p>Wouldn&#x27;t the client know the ID if they randomly generated it? (honest question)</div><br/><div id="41544207" class="c"><input type="checkbox" id="c-41544207" checked=""/><div class="controls bullet"><span class="by">grishka</span><span>|</span><a href="#41543203">root</a><span>|</span><a href="#41543963">parent</a><span>|</span><a href="#41543874">next</a><span>|</span><label class="collapse" for="c-41544207">[-]</label><label class="expand" for="c-41544207">[1 more]</label></div><br/><div class="children"><div class="content">I meant the permanent unique ID assigned by the server.</div><br/></div></div></div></div><div id="41543874" class="c"><input type="checkbox" id="c-41543874" checked=""/><div class="controls bullet"><span class="by">HDThoreaun</span><span>|</span><a href="#41543203">parent</a><span>|</span><a href="#41543963">prev</a><span>|</span><a href="#41542332">next</a><span>|</span><label class="collapse" for="c-41543874">[-]</label><label class="expand" for="c-41543874">[1 more]</label></div><br/><div class="children"><div class="content">Ive learned that just about nothing is trivial when it comes to distributed systems</div><br/></div></div></div></div><div id="41542332" class="c"><input type="checkbox" id="c-41542332" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#41543203">prev</a><span>|</span><a href="#41542010">next</a><span>|</span><label class="collapse" for="c-41542332">[-]</label><label class="expand" for="c-41542332">[3 more]</label></div><br/><div class="children"><div class="content">So TCP has slow start, and exponential fall off and shit.<p><i>but</i> you can get round that in a lot of cases by just having a load of TCP connections in parallel.<p>TCP is cheap and well optimised, especially if you are keeping a bunch of connections open. (opening can be expensive)<p>so if you have a high latency connection, or a bit of packet loss, and you want to reach line speed without having to figure out cornercases with UDP, just open up 100-1k TCP connections and multiplex them.<p>bish bash bosh, mostly line speed over a high latency line (mind you this was in the days of 100m-500m cross atlantic internet, you&#x27;ll probably need more connections to saturate a 10gig line.)</div><br/><div id="41542463" class="c"><input type="checkbox" id="c-41542463" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#41542332">parent</a><span>|</span><a href="#41542010">next</a><span>|</span><label class="collapse" for="c-41542463">[-]</label><label class="expand" for="c-41542463">[2 more]</label></div><br/><div class="children"><div class="content">Such hack is often not necessary.<p>Set larger kernel TCP send and receive buffers and enable BBR congestion control. Speed will usually be good also across high latency links, and no multiplexing logic needed. Especially if you control both sides of the connection.</div><br/><div id="41542948" class="c"><input type="checkbox" id="c-41542948" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#41542332">root</a><span>|</span><a href="#41542463">parent</a><span>|</span><a href="#41542010">next</a><span>|</span><label class="collapse" for="c-41542948">[-]</label><label class="expand" for="c-41542948">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Set larger kernel TCP send and receive buffers and enable BBR congestion control<p>I mean yeah, but that requires having access to the kernel config. so for most people multiplexing TCP is a useful way to maximise a link, without having to fiddle with stuff that is a pain to deploy. (politically as well as logistically)<p>I deployed this &quot;technique&quot; before BBR was a thing. It worked well enough for what I needed it to do (move large images from London to California) It was pretty simple to engineer as well (mainly because I didn&#x27;t have to make a fancy custom error detection&#x2F;correction&#x2F;rate limiting system over UDP )</div><br/></div></div></div></div></div></div><div id="41542010" class="c"><input type="checkbox" id="c-41542010" checked=""/><div class="controls bullet"><span class="by">richm44</span><span>|</span><a href="#41542332">prev</a><span>|</span><a href="#41542617">next</a><span>|</span><label class="collapse" for="c-41542010">[-]</label><label class="expand" for="c-41542010">[2 more]</label></div><br/><div class="children"><div class="content">1. A SYN will receive a SYN-ACK or a RST
2. A host from my machine is the same as from your machine
3. An IP from my machine is the same as from your machine</div><br/><div id="41542192" class="c"><input type="checkbox" id="c-41542192" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#41542010">parent</a><span>|</span><a href="#41542617">next</a><span>|</span><label class="collapse" for="c-41542192">[-]</label><label class="expand" for="c-41542192">[1 more]</label></div><br/><div class="children"><div class="content">1. A SYN may receive a SYN-ACK, RST or nothing at all.</div><br/></div></div></div></div><div id="41542617" class="c"><input type="checkbox" id="c-41542617" checked=""/><div class="controls bullet"><span class="by">poorman</span><span>|</span><a href="#41542010">prev</a><span>|</span><a href="#41544664">next</a><span>|</span><label class="collapse" for="c-41542617">[-]</label><label class="expand" for="c-41542617">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Explainer for 1-4: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two_Generals%27_Problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two_Generals%27_Problem</a>. TL;DR: If the connection breaks while an ACK is outstanding, the sender will have no way of knowing whether the segment was received, and this turns out to be an insoluble problem no matter how much complexity you pile on top of it. You need something resembling Paxos or Raft to get a guarantee like that<p>The hashgraph algorithm is pretty sweet too and doesn&#x27;t have the issue of a single write leader like Paxos and Raft. Basically multi-writers &#x2F; leaderless<p><a href="https:&#x2F;&#x2F;www.swirlds.com&#x2F;downloads&#x2F;SWIRLDS-TR-2016-01.pdf" rel="nofollow">https:&#x2F;&#x2F;www.swirlds.com&#x2F;downloads&#x2F;SWIRLDS-TR-2016-01.pdf</a><p>But to be fair, I&#x27;m not certain that CAP theorem and partition tolerance really belong in a conversation about TCP anyway</div><br/></div></div><div id="41544664" class="c"><input type="checkbox" id="c-41544664" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41542617">prev</a><span>|</span><a href="#41544051">next</a><span>|</span><label class="collapse" for="c-41544664">[-]</label><label class="expand" for="c-41544664">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There is a such thing as a TCP packet<p>In what way is that a falsehood?</div><br/></div></div><div id="41544051" class="c"><input type="checkbox" id="c-41544051" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#41544664">prev</a><span>|</span><a href="#41542665">next</a><span>|</span><label class="collapse" for="c-41544051">[-]</label><label class="expand" for="c-41544051">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 11. This is all low-level pedantry. I can think of TCP like a two-way Unix pipe that goes over the network, and completely ignore how it is implemented.<p>I mean, that&#x27;s true, insofar as pipes have incredibly weak guarantees too — after all, the other end of a pipe might be a program reading from&#x2F;writing to a network socket, or other unreliable transport. Whenever you let your program be plugged into an arbitrary pipe, you have to expect all that same flakiness and then some.</div><br/></div></div><div id="41542665" class="c"><input type="checkbox" id="c-41542665" checked=""/><div class="controls bullet"><span class="by">kranuck</span><span>|</span><a href="#41544051">prev</a><span>|</span><a href="#41543886">next</a><span>|</span><label class="collapse" for="c-41542665">[-]</label><label class="expand" for="c-41542665">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 11. This is all low-level pedantry<p>Yeah pretty much.<p>maybe don&#x27;t write contradictory unexplained nonsense.</div><br/></div></div></div></div></div></div></div></body></html>