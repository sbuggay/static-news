<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721293263115" as="style"/><link rel="stylesheet" href="styles.css?v=1721293263115"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/impl/pseudo/0.html">Pseudo Scheme: Scheme Implemented on Top of Common Lisp</a>Â <span class="domain">(<a href="https://www.cs.cmu.edu">www.cs.cmu.edu</a>)</span></div><div class="subtext"><span>interpunct</span> | <span>14 comments</span></div><br/><div><div id="40992660" class="c"><input type="checkbox" id="c-40992660" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40954375">next</a><span>|</span><label class="collapse" for="c-40992660">[-]</label><label class="expand" for="c-40992660">[1 more]</label></div><br/><div class="children"><div class="content">Like almost always, there are chapters about that in PAIP:<p>22 Scheme: An Uncommon Lisp[what a pun!] 
<a href="https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp&#x2F;blob&#x2F;main&#x2F;docs&#x2F;chapter22.md">https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp&#x2F;blob&#x2F;main&#x2F;docs&#x2F;chapter22...</a><p>23 Compiling Lisp [Scheme] <a href="https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp&#x2F;blob&#x2F;main&#x2F;docs&#x2F;chapter23.md">https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp&#x2F;blob&#x2F;main&#x2F;docs&#x2F;chapter23...</a></div><br/></div></div><div id="40954375" class="c"><input type="checkbox" id="c-40954375" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40992660">prev</a><span>|</span><a href="#40991893">next</a><span>|</span><label class="collapse" for="c-40954375">[-]</label><label class="expand" for="c-40954375">[3 more]</label></div><br/><div class="children"><div class="content">I feel like one of the major benefits of using Scheme is how easy it is to interoperate with just about any environment. Want to embed Scheme in your C application? Take your pick from GNU Guile, Chibi, Gambit, or Chicken. How about the JVM? Kawa is solid, option. .NET? IronScheme has got you covered. Javascript? There is LIPS or BiwaScheme.</div><br/><div id="40963532" class="c"><input type="checkbox" id="c-40963532" checked=""/><div class="controls bullet"><span class="by">interpunct</span><span>|</span><a href="#40954375">parent</a><span>|</span><a href="#40991893">next</a><span>|</span><label class="collapse" for="c-40963532">[-]</label><label class="expand" for="c-40963532">[2 more]</label></div><br/><div class="children"><div class="content">I agree.  I recently started using an R4RS Scheme called &quot;STk&quot;, the precursor to STklos, which I modded into a build system (replacing Make and Sh, for the most part) and a graphics DSL front-end to C.  The author wrote a demo app web browser with Scheme as a scripting language, as was the original plan with Mozilla, and Tk as the GUI.  Writing extensions in C is a breeze too, as it supports dynamic loading:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;egallesio&#x2F;STk">https:&#x2F;&#x2F;github.com&#x2F;egallesio&#x2F;STk</a><p>I like Common Lisp too, although not as much as Scheme day-to-day--it is nice now to have both.  I was thinking about adding a TinyCLOS using Common Lisp.  Pseudo Scheme transpiles source to CL, so I might be able to do it with CLOS underlying it instead of how TinyCLOS does it.<p>Jonathan Rees, the original author, has a Pseudo Scheme repo up on Github, with a branch that uses ASDF (which I am testing with SBCL).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jar398&#x2F;pseudoscheme">https:&#x2F;&#x2F;github.com&#x2F;jar398&#x2F;pseudoscheme</a><p>Thanks for your comment, and thanks to the maintainers of both of the linked Scheme implementations.</div><br/><div id="40992255" class="c"><input type="checkbox" id="c-40992255" checked=""/><div class="controls bullet"><span class="by">fourthark</span><span>|</span><a href="#40954375">root</a><span>|</span><a href="#40963532">parent</a><span>|</span><a href="#40991893">next</a><span>|</span><label class="collapse" for="c-40992255">[-]</label><label class="expand" for="c-40992255">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Pseudoscheme consists primarily of a Scheme to Common Lisp translator that is written in Scheme. To obtain a version of the translator that runs in Common Lisp, it is applied to itself.<p>Yes!</div><br/></div></div></div></div></div></div><div id="40991893" class="c"><input type="checkbox" id="c-40991893" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#40954375">prev</a><span>|</span><a href="#40992665">next</a><span>|</span><label class="collapse" for="c-40991893">[-]</label><label class="expand" for="c-40991893">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve sometimes done the opposite - when working in scheme&#x2F;racket, searched for implementations of things like loop, defmacro or tagbody. (They have their quirks, but when they&#x27;re a good fit for a problem they can save a lot of typing.)</div><br/><div id="40992790" class="c"><input type="checkbox" id="c-40992790" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#40991893">parent</a><span>|</span><a href="#40992761">next</a><span>|</span><label class="collapse" for="c-40992790">[-]</label><label class="expand" for="c-40992790">[3 more]</label></div><br/><div class="children"><div class="content">Chicken has a Common Lisp style `loop` egg: <a href="https:&#x2F;&#x2F;wiki.call-cc.org&#x2F;eggref&#x2F;5&#x2F;loop" rel="nofollow">https:&#x2F;&#x2F;wiki.call-cc.org&#x2F;eggref&#x2F;5&#x2F;loop</a> I think it&#x27;s based on a more generic Scheme version but I don&#x27;t have a link to the original.<p>SLIB has an implementation of pretty much the entirety of CL&#x27;s `format` that I ported to Racket: <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;slib-format&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;slib-format&#x2F;index.html</a><p>I also implemented a bunch of other CL stuff for Racket in <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;soup-lib&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;soup-lib&#x2F;index.html</a> (but not `tagbody`. Yet.)</div><br/><div id="40992847" class="c"><input type="checkbox" id="c-40992847" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40991893">root</a><span>|</span><a href="#40992790">parent</a><span>|</span><a href="#40992761">next</a><span>|</span><label class="collapse" for="c-40992847">[-]</label><label class="expand" for="c-40992847">[2 more]</label></div><br/><div class="children"><div class="content">Oops! Chicken is BSD licensed, but this is GPL.<p>If you ship a program that includes this, it is tainted.<p>Possibly, the code generated by the loop macro doesn&#x27;t fall under the license, but you still have to ensure that the macro itself is scrubbed from your application.</div><br/><div id="40993023" class="c"><input type="checkbox" id="c-40993023" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#40991893">root</a><span>|</span><a href="#40992847">parent</a><span>|</span><a href="#40992761">next</a><span>|</span><label class="collapse" for="c-40993023">[-]</label><label class="expand" for="c-40993023">[1 more]</label></div><br/><div class="children"><div class="content">Or... Just release your program under the GPL.</div><br/></div></div></div></div></div></div><div id="40992761" class="c"><input type="checkbox" id="c-40992761" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#40991893">parent</a><span>|</span><a href="#40992790">prev</a><span>|</span><a href="#40992665">next</a><span>|</span><label class="collapse" for="c-40992761">[-]</label><label class="expand" for="c-40992761">[3 more]</label></div><br/><div class="children"><div class="content">Defmacro is trivial to implement in syntax-case, but you are in for a world of pain if you want to use bindings across modules.<p>In have an implementation of tagbody for guile scheme somewhere, using delimited continuations. I have seen it for racket as well. There is an implementation of loop for racket, but it relies heavily on set! which will tank performance, since chez and racket (and many schemes) is pretty bad at not boxing mutable values.<p>I wrote this which is definitely not as powerful as loop, but definitely more powerful than rackets for loops: <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~bjoli&#x2F;goof-loop" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~bjoli&#x2F;goof-loop</a></div><br/><div id="40992801" class="c"><input type="checkbox" id="c-40992801" checked=""/><div class="controls bullet"><span class="by">rmrfchik</span><span>|</span><a href="#40991893">root</a><span>|</span><a href="#40992761">parent</a><span>|</span><a href="#40992665">next</a><span>|</span><label class="collapse" for="c-40992801">[-]</label><label class="expand" for="c-40992801">[2 more]</label></div><br/><div class="children"><div class="content">Defmacro isn&#x27;t hygienic, while syntax- is.
Is there way to use arbitrary names in hygienic syntax- macros?</div><br/><div id="40993061" class="c"><input type="checkbox" id="c-40993061" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#40991893">root</a><span>|</span><a href="#40992801">parent</a><span>|</span><a href="#40992665">next</a><span>|</span><label class="collapse" for="c-40993061">[-]</label><label class="expand" for="c-40993061">[1 more]</label></div><br/><div class="children"><div class="content">If you know the name ahead of time, syntax parameters[1] (if your scheme supports them) work well. syntax-case lets you break hygiene to insert new names in a controlled fashion (but has issues with names known ahead of time; see linked paper). Renaming macros do too, I believe.<p>1: <a href="http:&#x2F;&#x2F;scheme2011.ucombinator.org&#x2F;papers&#x2F;Barzilay2011.pdf" rel="nofollow">http:&#x2F;&#x2F;scheme2011.ucombinator.org&#x2F;papers&#x2F;Barzilay2011.pdf</a></div><br/></div></div></div></div></div></div></div></div><div id="40992665" class="c"><input type="checkbox" id="c-40992665" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#40991893">prev</a><span>|</span><label class="collapse" for="c-40992665">[-]</label><label class="expand" for="c-40992665">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious how it handles call&#x2F;cc. I at least <i>think</i> you would have to make your own continuation stack, unless there&#x27;s some way to get at the internals of unwind-protect that would make doing it natively possible.</div><br/><div id="40992959" class="c"><input type="checkbox" id="c-40992959" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40992665">parent</a><span>|</span><label class="collapse" for="c-40992959">[-]</label><label class="expand" for="c-40992959">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how PAIP does it, their interpreter uses continuation passing style:<p>22.5 An Interpreter Supporting Call&#x2F;cc<p><a href="https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp&#x2F;blob&#x2F;main&#x2F;docs&#x2F;chapter22.md#225-an-interpreter-supporting-callcc">https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp&#x2F;blob&#x2F;main&#x2F;docs&#x2F;chapter22...</a><p>23.2 Introducing Call&#x2F;cc [see the next chapter, 23.3 The Abstract Machine, for the implementation in bytecode]<p><a href="https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp&#x2F;blob&#x2F;main&#x2F;docs&#x2F;chapter23.md#232-introducing-callcc">https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp&#x2F;blob&#x2F;main&#x2F;docs&#x2F;chapter23...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>