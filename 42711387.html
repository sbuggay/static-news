<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737018071587" as="style"/><link rel="stylesheet" href="styles.css?v=1737018071587"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.saaspegasus.com/guides/modern-javascript-for-django-developers/">Modern JavaScript for Django developers</a> <span class="domain">(<a href="https://www.saaspegasus.com">www.saaspegasus.com</a>)</span></div><div class="subtext"><span>rob</span> | <span>111 comments</span></div><br/><div><div id="42714358" class="c"><input type="checkbox" id="c-42714358" checked=""/><div class="controls bullet"><span class="by">nilsbunger</span><span>|</span><a href="#42714260">next</a><span>|</span><label class="collapse" for="c-42714358">[-]</label><label class="expand" for="c-42714358">[13 more]</label></div><br/><div class="children"><div class="content">This is an excellent article, and SaaS Pegasus is a great solution for people starting a project.<p>But some of the advice here is dated. The architectural patterns are still valid, but the specifics have changed:<p>* Vite instead of create-react-app (which is unmaintained now) &#x2F; webpack &#x2F; babel &#x2F;  Parcel &#x2F; etc.<p>* Django-ninja as a lightweight API service.<p>I think these are important to call out because they really simplify the frontend compared to the previous options.</div><br/><div id="42718303" class="c"><input type="checkbox" id="c-42718303" checked=""/><div class="controls bullet"><span class="by">blopker</span><span>|</span><a href="#42714358">parent</a><span>|</span><a href="#42715133">next</a><span>|</span><label class="collapse" for="c-42718303">[-]</label><label class="expand" for="c-42718303">[2 more]</label></div><br/><div class="children"><div class="content">I agree with you on Django Ninja, so refreshingly simple compared to DRF. I think Django core needs to adopt something like it.<p>However, Vite is pretty complicated. I prefer just esbuild if I don&#x27;t need all the extra features of Vite, which is usually true with Django. I wrote a post[0] with an example repo[1] if anyone wants to see how everything wires up.<p>With Solidjs, the minimum JS payload is around 9kb, and you get access to the whole JS ecosystem if you want it.<p>[0] <a href="https:&#x2F;&#x2F;blopker.com&#x2F;writing&#x2F;07-django-islands-part-1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blopker.com&#x2F;writing&#x2F;07-django-islands-part-1&#x2F;</a>
[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;blopker&#x2F;typesafedjango">https:&#x2F;&#x2F;github.com&#x2F;blopker&#x2F;typesafedjango</a></div><br/><div id="42719587" class="c"><input type="checkbox" id="c-42719587" checked=""/><div class="controls bullet"><span class="by">michaelcampbell</span><span>|</span><a href="#42714358">root</a><span>|</span><a href="#42718303">parent</a><span>|</span><a href="#42715133">next</a><span>|</span><label class="collapse" for="c-42719587">[-]</label><label class="expand" for="c-42719587">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I agree with you on Django Ninja, so refreshingly simple compared to DRF. I think Django core needs to adopt something like it.<p>I was going to ask about this with respect to DRF, but you answered it.  I am re-learning Django after having been away from it and Python for ~4 years now, and my previous experience was with DRF in a somewhat toxic group so I had less than ideal feelings about it.  I know PTSD is a real thing and I don&#x27;t mean to sound glib about it, but I think I actually had the beginnings of it from that experience.</div><br/></div></div></div></div><div id="42715133" class="c"><input type="checkbox" id="c-42715133" checked=""/><div class="controls bullet"><span class="by">bkovacev</span><span>|</span><a href="#42714358">parent</a><span>|</span><a href="#42718303">prev</a><span>|</span><a href="#42721157">next</a><span>|</span><label class="collapse" for="c-42715133">[-]</label><label class="expand" for="c-42715133">[7 more]</label></div><br/><div class="children"><div class="content">What seems to differentiate django-ninja over Flask or FastAPI or any Starlette derivative? You mention lightweight as well, can you expand further?</div><br/><div id="42715678" class="c"><input type="checkbox" id="c-42715678" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#42714358">root</a><span>|</span><a href="#42715133">parent</a><span>|</span><a href="#42718731">next</a><span>|</span><label class="collapse" for="c-42715678">[-]</label><label class="expand" for="c-42715678">[5 more]</label></div><br/><div class="children"><div class="content">Ninja lets you use django. There&#x27;s less config vs DRF</div><br/><div id="42715869" class="c"><input type="checkbox" id="c-42715869" checked=""/><div class="controls bullet"><span class="by">bkovacev</span><span>|</span><a href="#42714358">root</a><span>|</span><a href="#42715678">parent</a><span>|</span><a href="#42718731">next</a><span>|</span><label class="collapse" for="c-42715869">[-]</label><label class="expand" for="c-42715869">[4 more]</label></div><br/><div class="children"><div class="content">Aside from the obvious that ninja let&#x27;s you use django.</div><br/><div id="42718290" class="c"><input type="checkbox" id="c-42718290" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#42714358">root</a><span>|</span><a href="#42715869">parent</a><span>|</span><a href="#42718731">next</a><span>|</span><label class="collapse" for="c-42718290">[-]</label><label class="expand" for="c-42718290">[3 more]</label></div><br/><div class="children"><div class="content">The ability to use django is the main attractor. The other frameworks are great but make you reinvent Django if you require auth, orm, admin, etc</div><br/><div id="42722501" class="c"><input type="checkbox" id="c-42722501" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42714358">root</a><span>|</span><a href="#42718290">parent</a><span>|</span><a href="#42718731">next</a><span>|</span><label class="collapse" for="c-42722501">[-]</label><label class="expand" for="c-42722501">[2 more]</label></div><br/><div class="children"><div class="content">Oh but you wouldn&#x27;t reinvent Django, you&#x27;d build a properly architected, simple system.</div><br/><div id="42722766" class="c"><input type="checkbox" id="c-42722766" checked=""/><div class="controls bullet"><span class="by">WD-42</span><span>|</span><a href="#42714358">root</a><span>|</span><a href="#42722501">parent</a><span>|</span><a href="#42718731">next</a><span>|</span><label class="collapse" for="c-42722766">[-]</label><label class="expand" for="c-42722766">[1 more]</label></div><br/><div class="children"><div class="content">Of course you would.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42721157" class="c"><input type="checkbox" id="c-42721157" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#42714358">parent</a><span>|</span><a href="#42715133">prev</a><span>|</span><a href="#42714260">next</a><span>|</span><label class="collapse" for="c-42721157">[-]</label><label class="expand" for="c-42721157">[3 more]</label></div><br/><div class="children"><div class="content">I use both at work. I&#x27;m not sure I see any reason why you would use Vite over Webpack, other then a sense that Vite is newer. Is there a reason? They both seem perfectly fine but Webpack is mature with lots of support.</div><br/><div id="42722993" class="c"><input type="checkbox" id="c-42722993" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#42714358">root</a><span>|</span><a href="#42721157">parent</a><span>|</span><a href="#42721741">next</a><span>|</span><label class="collapse" for="c-42722993">[-]</label><label class="expand" for="c-42722993">[1 more]</label></div><br/><div class="children"><div class="content">All the different configuration you need for Webpack is built-in to Vite.  This includes built-in support for a lot of stuff that would come as separate plugins in Webpack (CSS loading, Typescript support, asset bundling, minification, autoprefix&#x2F;browserslist-based downleveling, env replacement, etc).  But more importantly, it includes fairly optimal configuration.<p>There&#x27;s usually an optimal way to bundle your code, and one of the issues with Webpack was that finding that optimal way through a maze of documentation and third-party plugins.  Vite does that work for you, because it&#x27;s mostly a solved problem and it&#x27;s not that hard.  For example, rather than having a number of different CSS plugins that you need to enable and disable in different configurations — just use Vite, which will do hot-reloading of CSS in development and link to the CSS files as external files in production.<p>In my experience, there are typically two types of Webpack configurations: fairly basic ones that include some essentials but are fairly unoptimised (either while developing or in production), or complex ones that include everything but are brittle and painful to update.  Vite gives you the power and optimisation of the latter with the configuration ease of the former.<p>Also, to be clear, I&#x27;m not trying to hype Vite up.  There are other similar tools out there, and Vite isn&#x27;t even the first tool to work like this — Parcel is older and also pretty good at doing zero&#x2F;minimal-config builds that work how you expect out-of-the-box.  Any of these tools are good, although Vite seems to be the most popular right now and so has the most support&#x2F;documentation&#x2F;information.  But I would generally encourage any project using Webpack to migrate away from that where possible (and where time allows), because these low-config tools are such a timesaver in the long-run.</div><br/></div></div><div id="42721741" class="c"><input type="checkbox" id="c-42721741" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#42714358">root</a><span>|</span><a href="#42721157">parent</a><span>|</span><a href="#42722993">prev</a><span>|</span><a href="#42714260">next</a><span>|</span><label class="collapse" for="c-42721741">[-]</label><label class="expand" for="c-42721741">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t Vite faster and less complex?
That&#x27;s my impression.</div><br/></div></div></div></div></div></div><div id="42714260" class="c"><input type="checkbox" id="c-42714260" checked=""/><div class="controls bullet"><span class="by">fmnxl</span><span>|</span><a href="#42714358">prev</a><span>|</span><a href="#42714446">next</a><span>|</span><label class="collapse" for="c-42714260">[-]</label><label class="expand" for="c-42714260">[6 more]</label></div><br/><div class="children"><div class="content">Having used HTMX and Unpoly with Django, for over 2 years now, I prefer using Unpoly more these days.<p>Unpoly feels just like Django, it is a more of a framework than a thin layer, but that means it comes with a lot of productive features built-in, albeit opinionated.<p>It covers 95% of the use-cases of a typical web app, with its layers and forms concepts. E.g. I love creating &quot;subinteractions&quot; with unpoly, where a complex process can be divided into smaller modal forms for creating the &quot;related&quot; objects of a model, which then updates the main form of the model itself. Unpoly makes these simple, and its documentation caters for exactly these scenarios.</div><br/><div id="42717704" class="c"><input type="checkbox" id="c-42717704" checked=""/><div class="controls bullet"><span class="by">spapas82</span><span>|</span><a href="#42714260">parent</a><span>|</span><a href="#42716089">next</a><span>|</span><label class="collapse" for="c-42717704">[-]</label><label class="expand" for="c-42717704">[1 more]</label></div><br/><div class="children"><div class="content">The funny thing is that unpoly was originally written for ror, but I also agree that its a great fit for Django and its philosophy.</div><br/></div></div><div id="42716089" class="c"><input type="checkbox" id="c-42716089" checked=""/><div class="controls bullet"><span class="by">SCUSKU</span><span>|</span><a href="#42714260">parent</a><span>|</span><a href="#42717704">prev</a><span>|</span><a href="#42716269">next</a><span>|</span><label class="collapse" for="c-42716089">[-]</label><label class="expand" for="c-42716089">[3 more]</label></div><br/><div class="children"><div class="content">The one thing I couldn&#x27;t get past when looking into Unpoly is that if you&#x27;re in a deeply nested modal&#x2F;layer, and then refresh the page, it just shows you the most recent modal as a full page. My expectation is that when you refresh, instead it would keep you on the base page, and then wipe all the modals.</div><br/><div id="42717686" class="c"><input type="checkbox" id="c-42717686" checked=""/><div class="controls bullet"><span class="by">spapas82</span><span>|</span><a href="#42714260">root</a><span>|</span><a href="#42716089">parent</a><span>|</span><a href="#42721272">next</a><span>|</span><label class="collapse" for="c-42717686">[-]</label><label class="expand" for="c-42717686">[1 more]</label></div><br/><div class="children"><div class="content">Unpoly by default changes the browser&#x27;s history to the url of the modal. Thus when your refresh you&#x27;ll get exactly that. You can modify that behavior with up-history, see here <a href="https:&#x2F;&#x2F;unpoly.com&#x2F;history-in-overlays" rel="nofollow">https:&#x2F;&#x2F;unpoly.com&#x2F;history-in-overlays</a></div><br/></div></div><div id="42721272" class="c"><input type="checkbox" id="c-42721272" checked=""/><div class="controls bullet"><span class="by">fmnxl</span><span>|</span><a href="#42714260">root</a><span>|</span><a href="#42716089">parent</a><span>|</span><a href="#42717686">prev</a><span>|</span><a href="#42716269">next</a><span>|</span><label class="collapse" for="c-42721272">[-]</label><label class="expand" for="c-42721272">[1 more]</label></div><br/><div class="children"><div class="content">You can set up-history=&quot;false&quot; and there&#x27;d be no navigation when opening the modal, so when you refresh the page it&#x27;d refresh the parent layer not the modal.<p>What&#x27;s more arguable I think is how pressing the browser Back button doesn&#x27;t preserve the layers, but opens the previous page as a full page. I think that can be changed in a config somewhere, though.</div><br/></div></div></div></div><div id="42716269" class="c"><input type="checkbox" id="c-42716269" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#42714260">parent</a><span>|</span><a href="#42716089">prev</a><span>|</span><a href="#42714446">next</a><span>|</span><label class="collapse" for="c-42716269">[-]</label><label class="expand" for="c-42716269">[1 more]</label></div><br/><div class="children"><div class="content">Same here... Unpoly is a perfect match for Django.</div><br/></div></div></div></div><div id="42714446" class="c"><input type="checkbox" id="c-42714446" checked=""/><div class="controls bullet"><span class="by">singhrac</span><span>|</span><a href="#42714260">prev</a><span>|</span><a href="#42714794">next</a><span>|</span><label class="collapse" for="c-42714446">[-]</label><label class="expand" for="c-42714446">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried several boilerplates like SaaSPegasus and one thing I can&#x27;t really get around is that I feel like the experience of developing in a docker-compose with two build-and-serve containers (e.g. one with gunicorn auto-reload and the other running something like esbuild for the frontend) is very clunky in VSCode?<p>I feel like I&#x27;m doing something crazy, this must be a problem many other people have, but things like language server integration on the JS and Python side separately do not mesh well.<p>If anyone sees this and has a minimal open source boilerplate to recommend I&#x27;d love to try it.</div><br/><div id="42715270" class="c"><input type="checkbox" id="c-42715270" checked=""/><div class="controls bullet"><span class="by">omarspira</span><span>|</span><a href="#42714446">parent</a><span>|</span><a href="#42721239">next</a><span>|</span><label class="collapse" for="c-42715270">[-]</label><label class="expand" for="c-42715270">[3 more]</label></div><br/><div class="children"><div class="content">So I actually recently dealt with this, sharing this as hopefully it helps you.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ospira&#x2F;docker-django-react-example">https:&#x2F;&#x2F;github.com&#x2F;ospira&#x2F;docker-django-react-example</a><p>In essence, you need two instances of VSCode running connected to two separate Docker container instances. As I understand it, it&#x27;s one remote container per VSCode window. Thus, I found this to be best, even though it isn&#x27;t strictly speaking necessary, but it ends up feeling that way because as you said the language server integration (intellisense and extensions) will not work properly if not connected to the right container.<p>If you load this up in vs code it should prompt you properly given the presence of the files in `.devcontainter` dir. Having two windows in VSCode is kind of annoying at first, but I found it was actually fine, especially on macOS where tabbing to the other VSCode window (as opposed to ungrouped alt+tab on windows) was painless, and also kept me more organized not having backend and frontend code right next to each other.</div><br/><div id="42716227" class="c"><input type="checkbox" id="c-42716227" checked=""/><div class="controls bullet"><span class="by">omarspira</span><span>|</span><a href="#42714446">root</a><span>|</span><a href="#42715270">parent</a><span>|</span><a href="#42721239">next</a><span>|</span><label class="collapse" for="c-42716227">[-]</label><label class="expand" for="c-42716227">[2 more]</label></div><br/><div class="children"><div class="content">Btw, two addendums:<p>1. I fixed some things in that repo, now it should work out of the box. Apologies if the initial version had some bugs, was taking it out of another project, and the first effort at cleaning it up was too hasty. Note it is still however just meant as an example.<p>2. You actually can run more than one container per window - see here <a href="https:&#x2F;&#x2F;code.visualstudio.com&#x2F;remote&#x2F;advancedcontainers&#x2F;connect-multiple-containers" rel="nofollow">https:&#x2F;&#x2F;code.visualstudio.com&#x2F;remote&#x2F;advancedcontainers&#x2F;conn...</a>. However, I opted for the double window method because I found that cleaner than toggling between in one window. In my template I assume the two windows method because it will load up the proper subfolder (django or react) of the workspace&#x2F;monorepo depending on which dev container you connect to.</div><br/><div id="42718889" class="c"><input type="checkbox" id="c-42718889" checked=""/><div class="controls bullet"><span class="by">singhrac</span><span>|</span><a href="#42714446">root</a><span>|</span><a href="#42716227">parent</a><span>|</span><a href="#42721239">next</a><span>|</span><label class="collapse" for="c-42718889">[-]</label><label class="expand" for="c-42718889">[1 more]</label></div><br/><div class="children"><div class="content">This was very kind of you, and I’ll give it a shot soon!</div><br/></div></div></div></div></div></div><div id="42721239" class="c"><input type="checkbox" id="c-42721239" checked=""/><div class="controls bullet"><span class="by">silviogutierrez</span><span>|</span><a href="#42714446">parent</a><span>|</span><a href="#42715270">prev</a><span>|</span><a href="#42715111">next</a><span>|</span><label class="collapse" for="c-42721239">[-]</label><label class="expand" for="c-42721239">[1 more]</label></div><br/><div class="children"><div class="content">I wrote about docker development (and a library that solves this for Django here): <a href="https:&#x2F;&#x2F;www.reactivated.io&#x2F;documentation&#x2F;why-nix&#x2F;#native-performance" rel="nofollow">https:&#x2F;&#x2F;www.reactivated.io&#x2F;documentation&#x2F;why-nix&#x2F;#native-per...</a></div><br/></div></div><div id="42715111" class="c"><input type="checkbox" id="c-42715111" checked=""/><div class="controls bullet"><span class="by">tubs</span><span>|</span><a href="#42714446">parent</a><span>|</span><a href="#42721239">prev</a><span>|</span><a href="#42722536">next</a><span>|</span><label class="collapse" for="c-42715111">[-]</label><label class="expand" for="c-42715111">[3 more]</label></div><br/><div class="children"><div class="content">Why do you need docker to run esbuild? It’s a static binary.</div><br/><div id="42715336" class="c"><input type="checkbox" id="c-42715336" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#42714446">root</a><span>|</span><a href="#42715111">parent</a><span>|</span><a href="#42718844">next</a><span>|</span><label class="collapse" for="c-42715336">[-]</label><label class="expand" for="c-42715336">[1 more]</label></div><br/><div class="children"><div class="content">Not everyone is aware of this fact. I include myself in the list of those who didn&#x27;t know that. Most likely because I didn&#x27;t bother to inform myself because my expectation of the JavaScript ecosystem is that you first need to install npm via node, and then have it pull a huge amount of files just to then have a tool with which you can bundle stuff without then understanding where you need to &quot;install&quot; it. It&#x27;s a chaotic ecosystem, much worse than Python, and I know and love Python.<p>```
Major features:<p>- Extreme speed without needing a cache
- JavaScript, CSS, TypeScript, and JSX built-in
- A straightforward API for CLI, JS, and Go
- Bundles ESM and CommonJS modules
- Bundles CSS including CSS modules
- Tree shaking, minification, and source maps
- Local server, watch mode, and plugins
```<p>No word of it being a single executable, on the landing page, in the &quot;major features&quot;-list.<p>`npm install --save-exact --save-dev esbuild`. We have different expectations on how to download a binary.<p>Edit: I found an instruction on how to get the binary [0], why is this so hidden?<p>[0] <a href="https:&#x2F;&#x2F;esbuild.github.io&#x2F;getting-started&#x2F;#download-a-build" rel="nofollow">https:&#x2F;&#x2F;esbuild.github.io&#x2F;getting-started&#x2F;#download-a-build</a></div><br/></div></div><div id="42718844" class="c"><input type="checkbox" id="c-42718844" checked=""/><div class="controls bullet"><span class="by">singhrac</span><span>|</span><a href="#42714446">root</a><span>|</span><a href="#42715111">parent</a><span>|</span><a href="#42715336">prev</a><span>|</span><a href="#42722536">next</a><span>|</span><label class="collapse" for="c-42718844">[-]</label><label class="expand" for="c-42718844">[1 more]</label></div><br/><div class="children"><div class="content">That’s a good question since usually these are built into the docker-compose by default. I think my answer would be that it’s to get the same build environment on my Mac as on prod (i.e. a Linux server), but in practice I don’t think platform-specific details matter.<p>If that’s the case, why not run Python&#x2F;gunicorn locally as well, and drop docker entirely?</div><br/></div></div></div></div><div id="42722536" class="c"><input type="checkbox" id="c-42722536" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42714446">parent</a><span>|</span><a href="#42715111">prev</a><span>|</span><a href="#42714794">next</a><span>|</span><label class="collapse" for="c-42722536">[-]</label><label class="expand" for="c-42722536">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t use vscode but never had this kind of problem. Does vscode try to run language servers inside the containers or something? I don&#x27;t even know how that would work, to be honest. I run language servers outside of containers and it all works just fine.</div><br/></div></div></div></div><div id="42714794" class="c"><input type="checkbox" id="c-42714794" checked=""/><div class="controls bullet"><span class="by">cwales95</span><span>|</span><a href="#42714446">prev</a><span>|</span><a href="#42712308">next</a><span>|</span><label class="collapse" for="c-42714794">[-]</label><label class="expand" for="c-42714794">[6 more]</label></div><br/><div class="children"><div class="content">I think this is a great resource but wish it had not chosen a hybrid architecture. All the guides on decoupled Django seem to choose hybrid. It makes sense because you get the CSRF &#x2F; XSS safety benefits but I&#x27;d love to see how others tackle a fully decoupled Django stack e.g. oAuth, JWTs and how they do their CSRF &#x2F; XSS security. It&#x27;s an area I need to learn more about.</div><br/><div id="42715697" class="c"><input type="checkbox" id="c-42715697" checked=""/><div class="controls bullet"><span class="by">lastofus</span><span>|</span><a href="#42714794">parent</a><span>|</span><a href="#42719729">next</a><span>|</span><label class="collapse" for="c-42715697">[-]</label><label class="expand" for="c-42715697">[3 more]</label></div><br/><div class="children"><div class="content">Decoupled Django usually means that you are providing a client SPA with a API, such as a DRF powered REST API.<p>If you are using something like token auth (you mentioned JWT), then you are not using cookies, at which point CSRF is not needed. This is because the user&#x27;s browser isn&#x27;t automatically sending the cooking containing a session ID on every request to the server.<p>That said, you can implement session auth with DRF REST APIs, which accept a session cookie on requests. For this, I believe you would receive&#x2F;send CSRF tokens via HTTP headers.<p>XSS is not something you would worry too much about in an API endpoint. It is something you should worry a lot about in your client side SPA though. If using something like React, your templates will be auto-escaped, and thus you have to go out of your way to make it a problem.</div><br/><div id="42717302" class="c"><input type="checkbox" id="c-42717302" checked=""/><div class="controls bullet"><span class="by">cwales95</span><span>|</span><a href="#42714794">root</a><span>|</span><a href="#42715697">parent</a><span>|</span><a href="#42719729">next</a><span>|</span><label class="collapse" for="c-42717302">[-]</label><label class="expand" for="c-42717302">[2 more]</label></div><br/><div class="children"><div class="content">Where I get confused is storing the tokens securely. There&#x27;s a lot of conflicting information online. I&#x27;ve come across many examples where they suggest localStorage which is a horrible idea.<p>A lot of the advice I see now is about http-only cookies but I think I&#x27;d probably look more into oAuth in the future.</div><br/><div id="42717849" class="c"><input type="checkbox" id="c-42717849" checked=""/><div class="controls bullet"><span class="by">skuxxlife</span><span>|</span><a href="#42714794">root</a><span>|</span><a href="#42717302">parent</a><span>|</span><a href="#42719729">next</a><span>|</span><label class="collapse" for="c-42717849">[-]</label><label class="expand" for="c-42717849">[1 more]</label></div><br/><div class="children"><div class="content">The current best practice is to keep the token in memory only and store a refresh token in an HTTP-only cookie.<p>In my experience though, if you’re only doing web-based auth and don’t _need_ to use JWTs for a specific reason, just use regular session cookies, it’s way less hassle. Coordinating auth and refresh state across page refreshes and tabs is a pain, and using a refresh token means you’re using cookies and saved session state anyway, so you lose pretty much all of the unique benefits of using JWTs and still have all the downsides.</div><br/></div></div></div></div></div></div><div id="42719729" class="c"><input type="checkbox" id="c-42719729" checked=""/><div class="controls bullet"><span class="by">michaelcampbell</span><span>|</span><a href="#42714794">parent</a><span>|</span><a href="#42715697">prev</a><span>|</span><a href="#42712308">next</a><span>|</span><label class="collapse" for="c-42719729">[-]</label><label class="expand" for="c-42719729">[2 more]</label></div><br/><div class="children"><div class="content">&gt; All the guides on decoupled Django seem to choose hybrid<p>For someone ignorant (me), can you expand on what you mean by &quot;Decoupled Django&quot; and &quot;hybrid&quot;?</div><br/><div id="42721792" class="c"><input type="checkbox" id="c-42721792" checked=""/><div class="controls bullet"><span class="by">czue</span><span>|</span><a href="#42714794">root</a><span>|</span><a href="#42719729">parent</a><span>|</span><a href="#42712308">next</a><span>|</span><label class="collapse" for="c-42721792">[-]</label><label class="expand" for="c-42721792">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s outlined in the linked series here: <a href="https:&#x2F;&#x2F;www.saaspegasus.com&#x2F;guides&#x2F;modern-javascript-for-django-developers&#x2F;client-server-architectures&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.saaspegasus.com&#x2F;guides&#x2F;modern-javascript-for-dja...</a></div><br/></div></div></div></div></div></div><div id="42712308" class="c"><input type="checkbox" id="c-42712308" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#42714794">prev</a><span>|</span><a href="#42714870">next</a><span>|</span><label class="collapse" for="c-42712308">[-]</label><label class="expand" for="c-42712308">[23 more]</label></div><br/><div class="children"><div class="content">Having done Blazor with C#. I just want Django to have its own version of Blazor. You never have to touch JavaScript, and &#x2F; or if you do, its very sparingly. Your front-end either runs AJAX style, or fully in WASM depending on your needs.<p>I have built some wonderful UIs with Blazor in drastically less time than I would have spent building a JavaScript UI.<p>HTMX and might be the closest thing to what I&#x27;m describing that is actually available for Django today, though minus the WASM capabilities.</div><br/><div id="42712813" class="c"><input type="checkbox" id="c-42712813" checked=""/><div class="controls bullet"><span class="by">leetharris</span><span>|</span><a href="#42712308">parent</a><span>|</span><a href="#42722375">next</a><span>|</span><label class="collapse" for="c-42712813">[-]</label><label class="expand" for="c-42712813">[18 more]</label></div><br/><div class="children"><div class="content">Laravel has something like this called Livewire. It&#x27;s excellent.<p>Laravel is so much better than Django, but I just can&#x27;t go back to PHP at this point.<p><a href="https:&#x2F;&#x2F;livewire.laravel.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;livewire.laravel.com&#x2F;</a></div><br/><div id="42713869" class="c"><input type="checkbox" id="c-42713869" checked=""/><div class="controls bullet"><span class="by">adamrt</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42712813">parent</a><span>|</span><a href="#42712919">next</a><span>|</span><label class="collapse" for="c-42713869">[-]</label><label class="expand" for="c-42713869">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard people complain about Django many time on HN. I started using it back in the 0.96 version, so maybe its just a familiarity thing.<p>But I built 3 large successful applications in it in that time. I loved it. I don&#x27;t use it regularly anymore since I mostly moved away from webdev, but I recently came back into contact with my largest project I build in 2018&#x2F;2019 and its been running perfect this whole time and was a pleasure to dive back into.<p>Django just felt logically organized, documentation was on point, core was very readable (at least then).<p>I always just felt so productive in it. I know everyone has different opinions, experiences and products they are building, but I&#x27;m always surprised with the negative comments. I definitely prefer SSR with its reasonable though, so maybe thats part of it.</div><br/><div id="42713929" class="c"><input type="checkbox" id="c-42713929" checked=""/><div class="controls bullet"><span class="by">oooyay</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42713869">parent</a><span>|</span><a href="#42717980">next</a><span>|</span><label class="collapse" for="c-42713929">[-]</label><label class="expand" for="c-42713929">[4 more]</label></div><br/><div class="children"><div class="content">Most of the complaints I&#x27;ve read about Django on HN have to do with ASGI support - which Django added. They&#x27;re valid but outdated complaints.</div><br/><div id="42714765" class="c"><input type="checkbox" id="c-42714765" checked=""/><div class="controls bullet"><span class="by">fmnxl</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42713929">parent</a><span>|</span><a href="#42714317">next</a><span>|</span><label class="collapse" for="c-42714765">[-]</label><label class="expand" for="c-42714765">[1 more]</label></div><br/><div class="children"><div class="content">Also I think most people don&#x27;t know how much you can scale with gunicorn+gevent before attempting to migrate to ASGI.</div><br/></div></div><div id="42714317" class="c"><input type="checkbox" id="c-42714317" checked=""/><div class="controls bullet"><span class="by">airstrike</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42713929">parent</a><span>|</span><a href="#42714765">prev</a><span>|</span><a href="#42717980">next</a><span>|</span><label class="collapse" for="c-42714317">[-]</label><label class="expand" for="c-42714317">[2 more]</label></div><br/><div class="children"><div class="content">ASGI support for Django landed in 2019. Those comments are <i>very</i> outdated<p><a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;releases&#x2F;3.0&#x2F;#asgi-support" rel="nofollow">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;releases&#x2F;3.0&#x2F;#asgi-sup...</a></div><br/><div id="42715474" class="c"><input type="checkbox" id="c-42715474" checked=""/><div class="controls bullet"><span class="by">black3r</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42714317">parent</a><span>|</span><a href="#42717980">next</a><span>|</span><label class="collapse" for="c-42715474">[-]</label><label class="expand" for="c-42715474">[1 more]</label></div><br/><div class="children"><div class="content">tbf it was borderline unusable until they added async DB query support in 4.1 (2022) - before that you had to wrap every DB query with sync_to_async, async_to_sync and it generated too much boilerplate code..., and even in 4.1 the DB queries themselves were still sync&#x2F;blocking, not truly async because at that point they didn&#x27;t yet rewrite their database &quot;backends&quot; to use async querying, and I believe that as of now the Django&#x27;s DB engine still doesn&#x27;t support natively async DB queries&#x2F;cursors&#x2F;transactions&#x2F;...<p>Also, lots of the &quot;batteries included&quot; into Django don&#x27;t have async interfaces yet.., for example the default auth&#x2F;permission system will get async functions like acreate_user, aauthenticate, ahas_perm only in 5.2 which is expected in April 2025, so as of now these still have to be wrapped in sync_to_async wrappers to work...</div><br/></div></div></div></div></div></div><div id="42717980" class="c"><input type="checkbox" id="c-42717980" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42713869">parent</a><span>|</span><a href="#42713929">prev</a><span>|</span><a href="#42712919">next</a><span>|</span><label class="collapse" for="c-42717980">[-]</label><label class="expand" for="c-42717980">[2 more]</label></div><br/><div class="children"><div class="content">My complaint with Django is&#x2F;was that it&#x27;s fantastic for building brand new apps starting from scratch, but less pleasure to integrate with existing databases. The last time I tried to add Django models to a DB we were already using, there was an impedance mismatch which made it hard to fully model, and I gave up trying to get the admin to work well with it. The ORM and admin are 2 of Django&#x27;s biggest draws, perhaps <i>the</i> biggest. Without them, it&#x27;s not so pleasant.<p>That&#x27;s when I first came to love Flask. SQLAlchemy will let you model just about anything that looks vaguely database-like, and Flask doesn&#x27;t really care what ORM (if any) you use.<p>TL;DR Django&#x27;s opinionated. If those opinions match what you&#x27;re trying to do and you can stay on the golden path, it&#x27;s freaking great! Once you get off in the weeds, it quickly becomes your enemy.</div><br/><div id="42718092" class="c"><input type="checkbox" id="c-42718092" checked=""/><div class="controls bullet"><span class="by">adamrt</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42717980">parent</a><span>|</span><a href="#42712919">next</a><span>|</span><label class="collapse" for="c-42718092">[-]</label><label class="expand" for="c-42718092">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If those opinions match what you&#x27;re trying to do and you can stay on the golden path, it&#x27;s freaking great!<p>That&#x27;s a great summary. I wrote a few significant flask apps many years ago as well and I&#x27;m a huge fan of SQLAlchemy. My flask apps were greenfield so I ended up building crappier versions of alot that Django provides. I still enjoyed it  but I wasn&#x27;t as productive. But with a legacy integration, it would be hard to beat SQLAlchemy (I think its great for greenfield too). I&#x27;ve basically landed on your comment above as well.</div><br/></div></div></div></div></div></div><div id="42712919" class="c"><input type="checkbox" id="c-42712919" checked=""/><div class="controls bullet"><span class="by">pier25</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42712813">parent</a><span>|</span><a href="#42713869">prev</a><span>|</span><a href="#42714845">next</a><span>|</span><label class="collapse" for="c-42712919">[-]</label><label class="expand" for="c-42712919">[7 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I just can&#x27;t go back to PHP at this point</i><p>Same.<p>During 2024 I evaluated multiple backend platforms&#x2F;frameworks to get away from Node. Laravel is great and modern PHP (the language) is also surprisingly good but betting on PHP feels like betting on coal and the steam engine. The runtime and execution model are extremely outdated and resource hungry.<p>There are some efforts like FrankenPHP and Swole that package a PHP app to have a persistent execution model. But IMO unless PHP officially adopts this model this will always feel like a hack to me.</div><br/><div id="42714405" class="c"><input type="checkbox" id="c-42714405" checked=""/><div class="controls bullet"><span class="by">morbicer</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42712919">parent</a><span>|</span><a href="#42713088">next</a><span>|</span><label class="collapse" for="c-42714405">[-]</label><label class="expand" for="c-42714405">[2 more]</label></div><br/><div class="children"><div class="content">The job market for php devs is also weird. Very few talented people. Because php jobs on average pay the worst, people who are motivated and smart often learn another language and abandon php. There are some very practical oriented and clever people willing to do php but you have to look very hard.</div><br/><div id="42714850" class="c"><input type="checkbox" id="c-42714850" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42714405">parent</a><span>|</span><a href="#42713088">next</a><span>|</span><label class="collapse" for="c-42714850">[-]</label><label class="expand" for="c-42714850">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like a great market for motivated, practically minded devs then right?</div><br/></div></div></div></div><div id="42713088" class="c"><input type="checkbox" id="c-42713088" checked=""/><div class="controls bullet"><span class="by">rob</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42712919">parent</a><span>|</span><a href="#42714405">prev</a><span>|</span><a href="#42713837">next</a><span>|</span><label class="collapse" for="c-42713088">[-]</label><label class="expand" for="c-42713088">[2 more]</label></div><br/><div class="children"><div class="content">What did you end up going with if not PHP&#x2F;Laravel?</div><br/><div id="42715056" class="c"><input type="checkbox" id="c-42715056" checked=""/><div class="controls bullet"><span class="by">pier25</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42713088">parent</a><span>|</span><a href="#42713837">next</a><span>|</span><label class="collapse" for="c-42715056">[-]</label><label class="expand" for="c-42715056">[1 more]</label></div><br/><div class="children"><div class="content">Dotnet for backend and SvelteKit for frontend.</div><br/></div></div></div></div><div id="42713837" class="c"><input type="checkbox" id="c-42713837" checked=""/><div class="controls bullet"><span class="by">cjohnson318</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42712919">parent</a><span>|</span><a href="#42713088">prev</a><span>|</span><a href="#42714845">next</a><span>|</span><label class="collapse" for="c-42713837">[-]</label><label class="expand" for="c-42713837">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure why this has been downvoted so much, this guy states something that might upset some people, but then goes on to provide a pretty sober list pros and cons. This is the kind of content that we want to encourage on HN.</div><br/><div id="42715729" class="c"><input type="checkbox" id="c-42715729" checked=""/><div class="controls bullet"><span class="by">gjsman-1000</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42713837">parent</a><span>|</span><a href="#42714845">next</a><span>|</span><label class="collapse" for="c-42715729">[-]</label><label class="expand" for="c-42715729">[1 more]</label></div><br/><div class="children"><div class="content">It’s downvoted because even if PHP has hacky behavior; he’s running with the assumption other frameworks don’t have their own hacky behavior, or other frameworks are worse.<p>This is not necessarily warranted. Modern PHP is faster than Ruby in many benchmarks; and Rails is still running GitHub and Shopify. Square uses Laravel in a backend serving 100M+ requests per day, with no plans to rewrite. To compare it to a Steam engine and Coal; that’s unfair stereotyping.<p>On that note, JavaScript’s amount of churn could be an entire discussion by itself. I’ll take some quirky behavior that just keeps working over mindless churn any day.</div><br/></div></div></div></div></div></div><div id="42714845" class="c"><input type="checkbox" id="c-42714845" checked=""/><div class="controls bullet"><span class="by">nop_slide</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42712813">parent</a><span>|</span><a href="#42712919">prev</a><span>|</span><a href="#42722522">next</a><span>|</span><label class="collapse" for="c-42714845">[-]</label><label class="expand" for="c-42714845">[1 more]</label></div><br/><div class="children"><div class="content">I thought the same. I evaluated the &quot;big 3&quot; (Laravel, Django, Rails) last year and decided to go all in on Rails for solo side web projects.<p>Was really wanting to like Django since I&#x27;m a python dev for my day job, but it didn&#x27;t have nearly the amount of DX and tools baked in as Laravel&#x2F;Rails.<p>Rails has been super fun, I hadn&#x27;t touched it in 10 years and the additions that versions 7&#x2F;8 have brought are awesome.</div><br/></div></div><div id="42722522" class="c"><input type="checkbox" id="c-42722522" checked=""/><div class="controls bullet"><span class="by">7bit</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42712813">parent</a><span>|</span><a href="#42714845">prev</a><span>|</span><a href="#42713411">next</a><span>|</span><label class="collapse" for="c-42722522">[-]</label><label class="expand" for="c-42722522">[1 more]</label></div><br/><div class="children"><div class="content">I tried Latavel, but there were some points that made me want to drop it very fast.<p>I work on Windows and I chose a PHP variant (don&#x27;t remember, maybe one that supports threads or async) that did not work on Windows very well. Starting up a Latavel server took minutes. Took me hours to finally find that the PHP binary itself was the root cause. It should not be that way.<p>Then installing Compose on Windows was horrible. I believe I had to install PHP and compose in C:\php or it just would not work. The compose &quot;installer&quot; did a bunch of stuff to my Windows which I did not want. Installing it manually was a pain in the ass.<p>All in all, the experience was exactly the same as in the 2000&#x27;s (horrible).<p>After I setup my first Latavel project and had some question, it was really difficult to get answers. The docs are really good, but also fragmented as hell with all the approaches one could take to rendering content, depending on what you choose and how you approach it. The forums - although big - seemed dead when I stated my question.<p>I don&#x27;t know man, my experience with Django is so much better.</div><br/></div></div><div id="42713411" class="c"><input type="checkbox" id="c-42713411" checked=""/><div class="controls bullet"><span class="by">lawn</span><span>|</span><a href="#42712308">root</a><span>|</span><a href="#42712813">parent</a><span>|</span><a href="#42722522">prev</a><span>|</span><a href="#42722375">next</a><span>|</span><label class="collapse" for="c-42713411">[-]</label><label class="expand" for="c-42713411">[1 more]</label></div><br/><div class="children"><div class="content">And Phoenix&#x2F;Elixir has LiveView, also excellent.</div><br/></div></div></div></div><div id="42722375" class="c"><input type="checkbox" id="c-42722375" checked=""/><div class="controls bullet"><span class="by">runekaagaard</span><span>|</span><a href="#42712308">parent</a><span>|</span><a href="#42712813">prev</a><span>|</span><a href="#42712791">next</a><span>|</span><label class="collapse" for="c-42722375">[-]</label><label class="expand" for="c-42722375">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve rolled our own liveview and have happily used it in production for several years now: <a href="https:&#x2F;&#x2F;hypergen.it&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hypergen.it&#x2F;</a></div><br/></div></div><div id="42712791" class="c"><input type="checkbox" id="c-42712791" checked=""/><div class="controls bullet"><span class="by">lowercased</span><span>|</span><a href="#42712308">parent</a><span>|</span><a href="#42722375">prev</a><span>|</span><a href="#42712661">next</a><span>|</span><label class="collapse" for="c-42712791">[-]</label><label class="expand" for="c-42712791">[1 more]</label></div><br/><div class="children"><div class="content">Is unicorn close?<p><a href="https:&#x2F;&#x2F;www.django-unicorn.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.django-unicorn.com&#x2F;</a><p>Wouldn&#x27;t be WASM based either, but most of these types of tech aren&#x27;t (yet?).  I&#x27;m in the livewire camp with Laravel.  I found a bit discussion of a webassembly version of livewire, but I don&#x27;t think it&#x27;s on the cards any time soon.</div><br/></div></div><div id="42712661" class="c"><input type="checkbox" id="c-42712661" checked=""/><div class="controls bullet"><span class="by">selecsosi</span><span>|</span><a href="#42712308">parent</a><span>|</span><a href="#42712791">prev</a><span>|</span><a href="#42714211">next</a><span>|</span><label class="collapse" for="c-42712661">[-]</label><label class="expand" for="c-42712661">[1 more]</label></div><br/><div class="children"><div class="content">Typed view model bindings to templates was always amazing and 100000x more ergonomic than WPF (in my experience). That being said with so many things going to client apps, I&#x27;m less inclined to go w&#x2F; server side rendering and treat my backend as a data API so I&#x27;m not stuck building that twice.</div><br/></div></div><div id="42714211" class="c"><input type="checkbox" id="c-42714211" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42712308">parent</a><span>|</span><a href="#42712661">prev</a><span>|</span><a href="#42714870">next</a><span>|</span><label class="collapse" for="c-42714211">[-]</label><label class="expand" for="c-42714211">[1 more]</label></div><br/><div class="children"><div class="content">If you liked Blazor (and it&#x27;s interesting to hear perspective of someone &quot;outside&quot; the .NET bubble), is there a reason to prefer Python and Django?</div><br/></div></div></div></div><div id="42714870" class="c"><input type="checkbox" id="c-42714870" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#42712308">prev</a><span>|</span><a href="#42714426">next</a><span>|</span><label class="collapse" for="c-42714870">[-]</label><label class="expand" for="c-42714870">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen some companies using React with Django REST Framework [1], to keep the benefits of Django while having a strong separation between front and back (separate projects, teams, deploys, etc).<p>[1] <a href="https:&#x2F;&#x2F;www.django-rest-framework.org" rel="nofollow">https:&#x2F;&#x2F;www.django-rest-framework.org</a></div><br/><div id="42715061" class="c"><input type="checkbox" id="c-42715061" checked=""/><div class="controls bullet"><span class="by">ryannevius</span><span>|</span><a href="#42714870">parent</a><span>|</span><a href="#42715084">next</a><span>|</span><label class="collapse" for="c-42715061">[-]</label><label class="expand" for="c-42715061">[6 more]</label></div><br/><div class="children"><div class="content">We use Django and django-ninja [1] and like it MUCH better than DRF.<p>[1] <a href="https:&#x2F;&#x2F;django-ninja.dev" rel="nofollow">https:&#x2F;&#x2F;django-ninja.dev</a></div><br/><div id="42715113" class="c"><input type="checkbox" id="c-42715113" checked=""/><div class="controls bullet"><span class="by">bkovacev</span><span>|</span><a href="#42714870">root</a><span>|</span><a href="#42715061">parent</a><span>|</span><a href="#42715084">next</a><span>|</span><label class="collapse" for="c-42715113">[-]</label><label class="expand" for="c-42715113">[5 more]</label></div><br/><div class="children"><div class="content">Care to elaborate further? I keep reading on this, but no one actually mentions anything specific that ninja does better than DRF.</div><br/><div id="42715578" class="c"><input type="checkbox" id="c-42715578" checked=""/><div class="controls bullet"><span class="by">godtoldmetodoit</span><span>|</span><a href="#42714870">root</a><span>|</span><a href="#42715113">parent</a><span>|</span><a href="#42716672">next</a><span>|</span><label class="collapse" for="c-42715578">[-]</label><label class="expand" for="c-42715578">[1 more]</label></div><br/><div class="children"><div class="content">The main benefit most people see right away is the Pydantic integration &amp; it requires less boiler plate for basic API&#x27;s. Ninja is essentially FastAPI + Django.<p>I prefer Ninja over DRF, but I know plenty of orgs who still love their class based  DRF views as once you are over the (significant) mental hurdle of understanding all the abstraction there, it does give you the common CRUD type operations on your models &quot;for free&quot;.</div><br/></div></div><div id="42716672" class="c"><input type="checkbox" id="c-42716672" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#42714870">root</a><span>|</span><a href="#42715113">parent</a><span>|</span><a href="#42715578">prev</a><span>|</span><a href="#42715421">next</a><span>|</span><label class="collapse" for="c-42716672">[-]</label><label class="expand" for="c-42716672">[1 more]</label></div><br/><div class="children"><div class="content">DRF has more abstraction. When I was new to Django I found DRF hard to build a larger API with it and not make mistakes or have things get confusing. You&#x27;re primarily working by extending classes etc.<p>With django-ninja you just define your APIs with annotated types as methods, there is no magic, and then you get a generated OpenAPI spec.<p>this was my experience anyway, I used DRF for this project [0] and ninja for this one [1]<p>[0] <a href="https:&#x2F;&#x2F;govscent.org&#x2F;api&#x2F;" rel="nofollow">https:&#x2F;&#x2F;govscent.org&#x2F;api&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;sidewaysdata.com&#x2F;api&#x2F;docs" rel="nofollow">https:&#x2F;&#x2F;sidewaysdata.com&#x2F;api&#x2F;docs</a></div><br/></div></div><div id="42715421" class="c"><input type="checkbox" id="c-42715421" checked=""/><div class="controls bullet"><span class="by">anentropic</span><span>|</span><a href="#42714870">root</a><span>|</span><a href="#42715113">parent</a><span>|</span><a href="#42716672">prev</a><span>|</span><a href="#42715084">next</a><span>|</span><label class="collapse" for="c-42715421">[-]</label><label class="expand" for="c-42715421">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used django-ninja but to me it looks like the API is a bit nicer or more &#x27;modern&#x27; looking (i.e. declarative via type annotations) and it&#x27;s faster, both due to being based on Pydantic<p>DRF is old and API looks more like Django forms or class-based views, more of an OOP hierarchy going on, and DRF serializers are slow</div><br/><div id="42715830" class="c"><input type="checkbox" id="c-42715830" checked=""/><div class="controls bullet"><span class="by">bkovacev</span><span>|</span><a href="#42714870">root</a><span>|</span><a href="#42715421">parent</a><span>|</span><a href="#42715084">next</a><span>|</span><label class="collapse" for="c-42715830">[-]</label><label class="expand" for="c-42715830">[1 more]</label></div><br/><div class="children"><div class="content">Old is a harsh word, maybe mature would be a better fit, not everything new and shiny is gold, and yet not everything old sucks.<p>Not arguing here about types and  Pydantic being faster than the built in ModelSerializers. However, for serializer speed improvements and performance in DRF I would advise dropping ModelSerializers and either going for Serializers or plain dict. Haki Benita has a beautiful article on that [0]. I was able to accomplish sub 200 response times on a fairly large response from tables that had tens of millions of records.<p>I think you have no objective reason other than your styling and rather personal preference for function based views?<p>[0] - <a href="https:&#x2F;&#x2F;hakibenita.com&#x2F;django-rest-framework-slow" rel="nofollow">https:&#x2F;&#x2F;hakibenita.com&#x2F;django-rest-framework-slow</a></div><br/></div></div></div></div></div></div></div></div><div id="42715084" class="c"><input type="checkbox" id="c-42715084" checked=""/><div class="controls bullet"><span class="by">holler</span><span>|</span><a href="#42714870">parent</a><span>|</span><a href="#42715061">prev</a><span>|</span><a href="#42714426">next</a><span>|</span><label class="collapse" for="c-42715084">[-]</label><label class="expand" for="c-42715084">[3 more]</label></div><br/><div class="children"><div class="content">DRF has been around a long time at this point, and that&#x27;s been a common stack (albeit with other frontend frameworks 10 years ago).<p>In recent times I&#x27;m a fan of Starlette, which is what the popular FastAPI lib is built on top of, and created by same author as DRF.</div><br/><div id="42715337" class="c"><input type="checkbox" id="c-42715337" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#42714870">root</a><span>|</span><a href="#42715084">parent</a><span>|</span><a href="#42714426">next</a><span>|</span><label class="collapse" for="c-42715337">[-]</label><label class="expand" for="c-42715337">[2 more]</label></div><br/><div class="children"><div class="content">I used to make my APIs with Starlette&#x2F;FastAPI, didn&#x27;t know it was the same author!<p>Nowadays I just use PostgREST for all my new APIs. It&#x27;s a phenomenal piece of software, save me so much time.</div><br/><div id="42719793" class="c"><input type="checkbox" id="c-42719793" checked=""/><div class="controls bullet"><span class="by">darkteflon</span><span>|</span><a href="#42714870">root</a><span>|</span><a href="#42715337">parent</a><span>|</span><a href="#42714426">next</a><span>|</span><label class="collapse" for="c-42719793">[-]</label><label class="expand" for="c-42719793">[1 more]</label></div><br/><div class="children"><div class="content">Are there any footguns to be aware of when integrating PostgREST with an existing “low-JS” Django project, do you know? I’m considering it for headless access to an existing Django-ORM managed Postgres instance by a data orchestrator (i.e., not for the web UI). I’d like to be able to keep using Django auth in particular and just wondering if there’s any risk of impedance mismatch (in which case I’ll probably go with django-ninja).</div><br/></div></div></div></div></div></div></div></div><div id="42714426" class="c"><input type="checkbox" id="c-42714426" checked=""/><div class="controls bullet"><span class="by">jilles</span><span>|</span><a href="#42714870">prev</a><span>|</span><a href="#42712982">next</a><span>|</span><label class="collapse" for="c-42714426">[-]</label><label class="expand" for="c-42714426">[14 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think Alpine.js and HTMX qualify as &quot;Modern JavaScript&quot;. There is an approach that is rarely talked about: render templates in Django and hydrate using your favorite JavaScript framework.<p>For example the Django template renders a &lt;template id=&quot;abc&quot;&gt;&lt;button disabled&gt;open modal!&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;. Then your JavaScript bundle can &quot;hydrate&quot;. For example ReactDOM.render(&lt;OpenModalButton &#x2F;&gt;, &#x27;#abc&#x27;&#x27;).<p>You just have to be diligent to make sure that the template and your front-end have <i>somewhat similar markup</i> to not have layout shift. It&#x27;s really not that hard and works for a lot of use-cases.<p>Not saying this is a golden bullet, but you should be able to figure out which parts are static and just render them using Django templates. The dynamic parts you can render&#x2F;hydrate using whatever front-end framework.<p>I built a Django app with very little JavaScript and only using HTMX and it was... alright. It works. I can say &quot;no fancy build step!&quot; but I totally miss the testability of modern frontend. Creating an image upload component was a pain. I don&#x27;t think I would use HTMX again and instead go for the hybrid approach I described earlier.</div><br/><div id="42714553" class="c"><input type="checkbox" id="c-42714553" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#42714426">parent</a><span>|</span><a href="#42714860">next</a><span>|</span><label class="collapse" for="c-42714553">[-]</label><label class="expand" for="c-42714553">[7 more]</label></div><br/><div class="children"><div class="content">Why wouldn&#x27;t Alpine.js and HTMX be modern javascript? They&#x27;re both written with modern javascript.<p>React was created in 2013, Alpine in 2020, HTMX 2020. React is the elder of the bunch. React is the bloated tool nowadays.</div><br/><div id="42714723" class="c"><input type="checkbox" id="c-42714723" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#42714426">root</a><span>|</span><a href="#42714553">parent</a><span>|</span><a href="#42719786">next</a><span>|</span><label class="collapse" for="c-42714723">[-]</label><label class="expand" for="c-42714723">[2 more]</label></div><br/><div class="children"><div class="content">Personally, I don&#x27;t think the term &quot;modern JavaScript&quot; makes much sense - it&#x27;s just a nice-sounding but mostly meaningless buzzword, but I can guess the reason about the disagreement.<p>Alpine and HTMX are entirely different architectural <i>approach</i> to script <i>webpages</i>, as compared to React&#x2F;Vue&#x2F;Svelte&#x2F;Elm&#x2F;... approach to build SPA <i>webapps</i>. And the latter approach was very frequently called &quot;modern JavaScript&quot; (and that&#x27;s why I think it&#x27;s more of a buzzword now, and less of an actually meaningful term).</div><br/><div id="42715380" class="c"><input type="checkbox" id="c-42715380" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#42714426">root</a><span>|</span><a href="#42714723">parent</a><span>|</span><a href="#42719786">next</a><span>|</span><label class="collapse" for="c-42715380">[-]</label><label class="expand" for="c-42715380">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Modern JavaScript&quot; === &quot;Whatever just came out in the past week to six months and has had several articles written about it on the front page of Hacker News&quot;</div><br/></div></div></div></div><div id="42719786" class="c"><input type="checkbox" id="c-42719786" checked=""/><div class="controls bullet"><span class="by">andy800</span><span>|</span><a href="#42714426">root</a><span>|</span><a href="#42714553">parent</a><span>|</span><a href="#42714723">prev</a><span>|</span><a href="#42715928">next</a><span>|</span><label class="collapse" for="c-42719786">[-]</label><label class="expand" for="c-42719786">[3 more]</label></div><br/><div class="children"><div class="content">Somewhat pedantic - <i>Using</i> HTMX represents a modern approach to building a web front-end. However, I&#x27;m confident that recursivedoubts (creator of HTMX) would agree HTMX is not itself <i>written in</i> modern Javascript. No Typescript, no modules, no functional programming, no async, etc.<p><a href="https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;no-build-step&#x2F;" rel="nofollow">https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;no-build-step&#x2F;</a></div><br/><div id="42720312" class="c"><input type="checkbox" id="c-42720312" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#42714426">root</a><span>|</span><a href="#42719786">parent</a><span>|</span><a href="#42715928">next</a><span>|</span><label class="collapse" for="c-42720312">[-]</label><label class="expand" for="c-42720312">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s poppycock. A library that doesn&#x27;t require several dozen unrelated libraries to use is a good thing and something we should actually hold up as good engineering.<p>I&#x27;m also confident that recursivedoubts wouldn&#x27;t like you calling his library not modern. That&#x27;s just insulting.</div><br/><div id="42720672" class="c"><input type="checkbox" id="c-42720672" checked=""/><div class="controls bullet"><span class="by">andy800</span><span>|</span><a href="#42714426">root</a><span>|</span><a href="#42720312">parent</a><span>|</span><a href="#42715928">next</a><span>|</span><label class="collapse" for="c-42720672">[-]</label><label class="expand" for="c-42720672">[1 more]</label></div><br/><div class="children"><div class="content">As a CEO of HTMX, I&#x27;m qualified to say that recursivedoubts is best described as a grug-brained developer.<p><a href="https:&#x2F;&#x2F;grugbrain.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;grugbrain.dev&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42715928" class="c"><input type="checkbox" id="c-42715928" checked=""/><div class="controls bullet"><span class="by">harrall</span><span>|</span><a href="#42714426">root</a><span>|</span><a href="#42714553">parent</a><span>|</span><a href="#42719786">prev</a><span>|</span><a href="#42714860">next</a><span>|</span><label class="collapse" for="c-42715928">[-]</label><label class="expand" for="c-42715928">[1 more]</label></div><br/><div class="children"><div class="content">Things aren’t that rigid. React is just a template library (it doesn’t have any franework stuff at all). You don&#x27;t have to make an SPA with it.<p>In 2015 we were doing<p>$(&#x27;[data-widget=&quot;colorpicker&quot;]&#x27;).each(() =&gt; ReactDOM.render(&lt;ColorPicker &#x2F;&gt;));<p>Basically what HTMX is trying to do but with jQuery + React. No SPA. Just static pages with dynamic elements.</div><br/></div></div></div></div><div id="42714860" class="c"><input type="checkbox" id="c-42714860" checked=""/><div class="controls bullet"><span class="by">evantbyrne</span><span>|</span><a href="#42714426">parent</a><span>|</span><a href="#42714553">prev</a><span>|</span><a href="#42714611">next</a><span>|</span><label class="collapse" for="c-42714860">[-]</label><label class="expand" for="c-42714860">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak for HTMX specifically, but going to progressively enhanced server-rendered HTML from React requires a certain amount of mental deprogramming. I&#x27;ve been using Turbo lately for side projects (e.g., Pocket SQL) and found it involves working much more closely with browser APIs, but also writing way less UI code. Pocket SQL required writing about 50 lines of JS and people probably wouldn&#x27;t notice that it&#x27;s not a SPA unless they looked under the hood.</div><br/><div id="42719838" class="c"><input type="checkbox" id="c-42719838" checked=""/><div class="controls bullet"><span class="by">andy800</span><span>|</span><a href="#42714426">root</a><span>|</span><a href="#42714860">parent</a><span>|</span><a href="#42714611">next</a><span>|</span><label class="collapse" for="c-42719838">[-]</label><label class="expand" for="c-42719838">[1 more]</label></div><br/><div class="children"><div class="content">This is often why people get frustrated switching HTMX for the first time. The idea isn&#x27;t to &quot;translate&quot; the code, but to completely rethink concepts like state and pages and things like components. Not everyone is able to conceptualize their application outside the boundaries of a specific framework.</div><br/></div></div></div></div><div id="42714611" class="c"><input type="checkbox" id="c-42714611" checked=""/><div class="controls bullet"><span class="by">dimgl</span><span>|</span><a href="#42714426">parent</a><span>|</span><a href="#42714860">prev</a><span>|</span><a href="#42714707">next</a><span>|</span><label class="collapse" for="c-42714611">[-]</label><label class="expand" for="c-42714611">[1 more]</label></div><br/><div class="children"><div class="content">I was doing with this Knockout back when I was using ASP.NET MVC! I&#x27;m surprised it&#x27;s not a more common pattern.</div><br/></div></div><div id="42714707" class="c"><input type="checkbox" id="c-42714707" checked=""/><div class="controls bullet"><span class="by">rob</span><span>|</span><a href="#42714426">parent</a><span>|</span><a href="#42714611">prev</a><span>|</span><a href="#42716400">next</a><span>|</span><label class="collapse" for="c-42714707">[-]</label><label class="expand" for="c-42714707">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s &quot;Part 4&quot; I believe:<p><a href="https:&#x2F;&#x2F;www.saaspegasus.com&#x2F;guides&#x2F;modern-javascript-for-django-developers&#x2F;integrating-django-react&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.saaspegasus.com&#x2F;guides&#x2F;modern-javascript-for-dja...</a></div><br/></div></div><div id="42716400" class="c"><input type="checkbox" id="c-42716400" checked=""/><div class="controls bullet"><span class="by">65</span><span>|</span><a href="#42714426">parent</a><span>|</span><a href="#42714707">prev</a><span>|</span><a href="#42712982">next</a><span>|</span><label class="collapse" for="c-42716400">[-]</label><label class="expand" for="c-42716400">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t this throw hydration errors if your SSR HTML does not exactly match your client side HTML?</div><br/></div></div></div></div><div id="42712982" class="c"><input type="checkbox" id="c-42712982" checked=""/><div class="controls bullet"><span class="by">yoyohello13</span><span>|</span><a href="#42714426">prev</a><span>|</span><a href="#42713707">next</a><span>|</span><label class="collapse" for="c-42712982">[-]</label><label class="expand" for="c-42712982">[1 more]</label></div><br/><div class="children"><div class="content">BTW, this guy&#x27;s Django templates are really good.</div><br/></div></div><div id="42713707" class="c"><input type="checkbox" id="c-42713707" checked=""/><div class="controls bullet"><span class="by">0xblinq</span><span>|</span><a href="#42712982">prev</a><span>|</span><a href="#42716547">next</a><span>|</span><label class="collapse" for="c-42713707">[-]</label><label class="expand" for="c-42713707">[3 more]</label></div><br/><div class="children"><div class="content">Check out <a href="https:&#x2F;&#x2F;inertiajs.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;inertiajs.com&#x2F;</a>.<p>I&#x27;ve never used it with Django (there&#x27;s an adapter here <a href="https:&#x2F;&#x2F;github.com&#x2F;inertiajs&#x2F;inertia-django">https:&#x2F;&#x2F;github.com&#x2F;inertiajs&#x2F;inertia-django</a>) but I did use it a lot with AdonisJS and Rails.<p>It&#x27;s wonderful. The best of both worlds. TL;DR you can use React&#x2F;Vue as your &quot;template&quot; layer and keep everything in your batteries included backend framework of choice, avoiding all the bull**t and madness going on with Next, Remix, React Router, etc, etc...</div><br/><div id="42720071" class="c"><input type="checkbox" id="c-42720071" checked=""/><div class="controls bullet"><span class="by">DangitBobby</span><span>|</span><a href="#42713707">parent</a><span>|</span><a href="#42716547">next</a><span>|</span><label class="collapse" for="c-42720071">[-]</label><label class="expand" for="c-42720071">[2 more]</label></div><br/><div class="children"><div class="content">I eventually came to regret using Inertia and just wished we had used e.g. django-rest-framework and React Router. React Router is excellent. I feel pretty much the same way you do about Next.js, though.</div><br/><div id="42721919" class="c"><input type="checkbox" id="c-42721919" checked=""/><div class="controls bullet"><span class="by">0xblinq</span><span>|</span><a href="#42713707">root</a><span>|</span><a href="#42720071">parent</a><span>|</span><a href="#42716547">next</a><span>|</span><label class="collapse" for="c-42721919">[-]</label><label class="expand" for="c-42721919">[1 more]</label></div><br/><div class="children"><div class="content">I have the exact opposite experience, but context is everything here I guess.<p>&gt; React Router is excellent.<p>When you compare it to Next, etc... yes, I agree. The issue I have is the constant change of mind their devs have regarding how to do things, even when they say &quot;it&#x27;s stable&quot;... it&#x27;s not... every day they come up with &quot;a better way&quot; to do things which usually is not better, just different.<p>But using it when you already have django&#x2F;rails&#x2F;laravel&#x2F;adonis means you have to do a ton more work and reinvent a lot of things (such as authentication, validation, etc).<p>Care to extend on what problems you found or what you didn&#x27;t like about inertia?</div><br/></div></div></div></div></div></div><div id="42716547" class="c"><input type="checkbox" id="c-42716547" checked=""/><div class="controls bullet"><span class="by">sailfast</span><span>|</span><a href="#42713707">prev</a><span>|</span><a href="#42715265">next</a><span>|</span><label class="collapse" for="c-42716547">[-]</label><label class="expand" for="c-42716547">[2 more]</label></div><br/><div class="children"><div class="content">I like this setup, but I had kinda thought &quot;modern&quot; javascript had mostly moved to server-side rendered at this point and I didn&#x27;t see anything about that in the syllabus. Anyone know if this tutorial addresses that kind of thing?<p>EDIT: Nevermind I guess this is the HTMX example? But how would this compare to manually building something with next.js as part of your front-end build and incorporating those assets into your templates?</div><br/><div id="42716702" class="c"><input type="checkbox" id="c-42716702" checked=""/><div class="controls bullet"><span class="by">omarspira</span><span>|</span><a href="#42716547">parent</a><span>|</span><a href="#42715265">next</a><span>|</span><label class="collapse" for="c-42716702">[-]</label><label class="expand" for="c-42716702">[1 more]</label></div><br/><div class="children"><div class="content">You can do essentially the same thing with Next or Nuxt.js<p>With Next.js now it is very easy and elegant to load up data from your Django server in a React Server Component. You can also build entire static pages manually from the same API.<p>Here is an excerpted example from the same simple template I posted in response to an earlier comment - <a href="https:&#x2F;&#x2F;github.com&#x2F;ospira&#x2F;docker-django-react-example&#x2F;blob&#x2F;main&#x2F;react&#x2F;src&#x2F;app&#x2F;page.tsx#L4-L6">https:&#x2F;&#x2F;github.com&#x2F;ospira&#x2F;docker-django-react-example&#x2F;blob&#x2F;m...</a><p>If doing this as part of a production pipeline you would have to ensure some version of your Django API (hopefully the latest one) is present before deploying the Next.js app, so that the data is available for Next to do things like fully static pages.</div><br/></div></div></div></div><div id="42715265" class="c"><input type="checkbox" id="c-42715265" checked=""/><div class="controls bullet"><span class="by">anentropic</span><span>|</span><a href="#42716547">prev</a><span>|</span><a href="#42714474">next</a><span>|</span><label class="collapse" for="c-42715265">[-]</label><label class="expand" for="c-42715265">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been working on a Django + Vite + HTMX + Alpine project for the past year or so<p>Using django-htmx and django-vite libs (the latter forked to add Jinja support)<p>Been pretty happy with it<p>The main wart I find is the lack of type-safe templating in Python, feels primitive and clunky compared to what you have with TSX in a React project<p>Been using Jinja macros as &#x27;components&#x27; which... works. The syntax is kinda ugly to read though, and haven&#x27;t found any really great linter.</div><br/><div id="42722786" class="c"><input type="checkbox" id="c-42722786" checked=""/><div class="controls bullet"><span class="by">jakobgm</span><span>|</span><a href="#42715265">parent</a><span>|</span><a href="#42719883">next</a><span>|</span><label class="collapse" for="c-42722786">[-]</label><label class="expand" for="c-42722786">[1 more]</label></div><br/><div class="children"><div class="content">I can also highly recommend JinjaX [0] as a way to introduce a much more ergonomic component syntax in Jinja2 templates. We have been using it for almost 2 years and have only recently started to write new templates in htpy as a way to attain greater type safety.<p>[0] <a href="https:&#x2F;&#x2F;jinjax.scaletti.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jinjax.scaletti.dev&#x2F;</a></div><br/></div></div><div id="42719883" class="c"><input type="checkbox" id="c-42719883" checked=""/><div class="controls bullet"><span class="by">andy800</span><span>|</span><a href="#42715265">parent</a><span>|</span><a href="#42722786">prev</a><span>|</span><a href="#42720065">next</a><span>|</span><label class="collapse" for="c-42719883">[-]</label><label class="expand" for="c-42719883">[1 more]</label></div><br/><div class="children"><div class="content">Kotlin is an awesome back-end language with strong typing, tons of libraries and multiple HTTP frameworks (http4k, ktor, vert.x, many more) and templating options (jte is terrific, and fully typed). Guessing it&#x27;s too late to switch now but worth checking out.</div><br/></div></div><div id="42720065" class="c"><input type="checkbox" id="c-42720065" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#42715265">parent</a><span>|</span><a href="#42719883">prev</a><span>|</span><a href="#42714474">next</a><span>|</span><label class="collapse" for="c-42720065">[-]</label><label class="expand" for="c-42720065">[1 more]</label></div><br/><div class="children"><div class="content">&gt; lack of type-safe templating in Python<p>Try htpy.  It moves templating into python where it can be linted&#x2F;typed:
<a href="https:&#x2F;&#x2F;htpy.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;htpy.dev&#x2F;</a></div><br/></div></div></div></div><div id="42714073" class="c"><input type="checkbox" id="c-42714073" checked=""/><div class="controls bullet"><span class="by">chis</span><span>|</span><a href="#42714474">prev</a><span>|</span><a href="#42714016">next</a><span>|</span><label class="collapse" for="c-42714073">[-]</label><label class="expand" for="c-42714073">[11 more]</label></div><br/><div class="children"><div class="content">I wish there was some way to just get react-style data bindings, html generation from JS, and code organization, while still hosting from purely a flask&#x2F;django backend. The traditional split of a flask API and a react frontend consuming it, just feels like overkill.<p>Plus native JavaScript+html is just so close to a complete solution these days. I don’t miss components at all. I just want better code organization.</div><br/><div id="42714305" class="c"><input type="checkbox" id="c-42714305" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#42714073">parent</a><span>|</span><a href="#42714263">next</a><span>|</span><label class="collapse" for="c-42714305">[-]</label><label class="expand" for="c-42714305">[1 more]</label></div><br/><div class="children"><div class="content">I have found that inertia.js is a great solution, it basically allows you to program in your traditional back end multi-page application, MVC kind of style, but with all the benefits of an SPA. So, you get to skip writing an API and just pass data into a view like in the old days, but the view is a React component (or Vue or Svelte)</div><br/></div></div><div id="42714263" class="c"><input type="checkbox" id="c-42714263" checked=""/><div class="controls bullet"><span class="by">morbicer</span><span>|</span><a href="#42714073">parent</a><span>|</span><a href="#42714305">prev</a><span>|</span><a href="#42718111">next</a><span>|</span><label class="collapse" for="c-42714263">[-]</label><label class="expand" for="c-42714263">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand the second sentence. As someone developing web apps for over 20 years, components ARE the better code organization.</div><br/><div id="42714412" class="c"><input type="checkbox" id="c-42714412" checked=""/><div class="controls bullet"><span class="by">fmnxl</span><span>|</span><a href="#42714073">root</a><span>|</span><a href="#42714263">parent</a><span>|</span><a href="#42718111">next</a><span>|</span><label class="collapse" for="c-42714412">[-]</label><label class="expand" for="c-42714412">[6 more]</label></div><br/><div class="children"><div class="content">Well there&#x27;s a cost to that abstraction, e.g. you&#x27;d have to pass the context into the component, so every time you need to modify the component&#x27;s schema&#x2F;props you&#x27;d need to change it twice, both in the parent and the component.<p>You must have seen some huge React components with 20 different props or even more, and you&#x27;d need to think about memoizing those props to prevent a re-render, etc etc.<p>I&#x27;ve also been a web dev for over 20 years, and 10 years with React. I&#x27;d say that going back to native HTML APIs for handling stateful things like forms and form validation is a breeze, rather than writing components and endless abstractions. It&#x27;s enough for the vast majority of the time.</div><br/><div id="42714554" class="c"><input type="checkbox" id="c-42714554" checked=""/><div class="controls bullet"><span class="by">morbicer</span><span>|</span><a href="#42714073">root</a><span>|</span><a href="#42714412">parent</a><span>|</span><a href="#42718111">next</a><span>|</span><label class="collapse" for="c-42714554">[-]</label><label class="expand" for="c-42714554">[5 more]</label></div><br/><div class="children"><div class="content">Those are just shitty codebases. I maintain a React app that&#x27;s over 10 years old, almost milion lines of code and we have zero components with 20 props, no issues with performance or whatnot.<p>I am an oponent of over-abstraction but components are very light abstraction and provide just sensible encapsulation and reusability.</div><br/><div id="42714667" class="c"><input type="checkbox" id="c-42714667" checked=""/><div class="controls bullet"><span class="by">fmnxl</span><span>|</span><a href="#42714073">root</a><span>|</span><a href="#42714554">parent</a><span>|</span><a href="#42718111">next</a><span>|</span><label class="collapse" for="c-42714667">[-]</label><label class="expand" for="c-42714667">[4 more]</label></div><br/><div class="children"><div class="content">Show me this amazing site of yours. With that amount of talent maybe you should go over to Next.js and solve their RSC issues.</div><br/><div id="42714745" class="c"><input type="checkbox" id="c-42714745" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#42714073">root</a><span>|</span><a href="#42714667">parent</a><span>|</span><a href="#42714820">next</a><span>|</span><label class="collapse" for="c-42714745">[-]</label><label class="expand" for="c-42714745">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really curious too, the only codebase I&#x27;ve seen that was like their description with react treated different pages&#x2F;routes as one massive separate component.<p>Not exactly utilizing the benefit of JSX but it&#x27;s a pattern you might blindly fall into if you only came from a templating background.</div><br/></div></div><div id="42714820" class="c"><input type="checkbox" id="c-42714820" checked=""/><div class="controls bullet"><span class="by">morbicer</span><span>|</span><a href="#42714073">root</a><span>|</span><a href="#42714667">parent</a><span>|</span><a href="#42714745">prev</a><span>|</span><a href="#42718111">next</a><span>|</span><label class="collapse" for="c-42714820">[-]</label><label class="expand" for="c-42714820">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t, our app is enterprise SaaS built as SPA. Nextjs is imho garbage. The only reason I can imagine it is so popular is that average React devs are indeed very bad with code organization. If I needed server rendering I would go with Astro + interactive islands.</div><br/><div id="42715147" class="c"><input type="checkbox" id="c-42715147" checked=""/><div class="controls bullet"><span class="by">fmnxl</span><span>|</span><a href="#42714073">root</a><span>|</span><a href="#42714820">parent</a><span>|</span><a href="#42718111">next</a><span>|</span><label class="collapse" for="c-42715147">[-]</label><label class="expand" for="c-42715147">[1 more]</label></div><br/><div class="children"><div class="content">I see, you&#x27;re talking about a fully client-rendered SPA. I guess you can always count on your users running modern PCs, with fast internet and no SEO needs. Things aren&#x27;t that nice in the outside world lol.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42718111" class="c"><input type="checkbox" id="c-42718111" checked=""/><div class="controls bullet"><span class="by">chis</span><span>|</span><a href="#42714073">parent</a><span>|</span><a href="#42714263">prev</a><span>|</span><a href="#42716499">next</a><span>|</span><label class="collapse" for="c-42718111">[-]</label><label class="expand" for="c-42718111">[1 more]</label></div><br/><div class="children"><div class="content">Claude suggests preact+htm, to get pleasant html generation and react-style imperative state transitions but avoid a build stage.  I will give it a shot</div><br/></div></div><div id="42716499" class="c"><input type="checkbox" id="c-42716499" checked=""/><div class="controls bullet"><span class="by">65</span><span>|</span><a href="#42714073">parent</a><span>|</span><a href="#42718111">prev</a><span>|</span><a href="#42714016">next</a><span>|</span><label class="collapse" for="c-42716499">[-]</label><label class="expand" for="c-42716499">[1 more]</label></div><br/><div class="children"><div class="content">You might like Vike (it&#x27;d be an Express backend but generally people like Express)<p><a href="https:&#x2F;&#x2F;vike.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vike.dev&#x2F;</a></div><br/></div></div></div></div><div id="42714016" class="c"><input type="checkbox" id="c-42714016" checked=""/><div class="controls bullet"><span class="by">cdfuller</span><span>|</span><a href="#42714073">prev</a><span>|</span><a href="#42712883">next</a><span>|</span><label class="collapse" for="c-42714016">[-]</label><label class="expand" for="c-42714016">[4 more]</label></div><br/><div class="children"><div class="content">This guide is a bit over two years old. Can someone comment on whether it still holds up and the tools recommended are still being recommended today?</div><br/><div id="42714318" class="c"><input type="checkbox" id="c-42714318" checked=""/><div class="controls bullet"><span class="by">czue</span><span>|</span><a href="#42714016">parent</a><span>|</span><a href="#42712883">next</a><span>|</span><label class="collapse" for="c-42714318">[-]</label><label class="expand" for="c-42714318">[3 more]</label></div><br/><div class="children"><div class="content">Author here. I would say the core principles still hold up well, though the tooling and libraries are constantly evolving.<p>An incomplete list of things I&#x27;d add &#x2F; change today (and are on my roadmap to cover in more detail):<p>I would probably recommend Vite over Webpack as the main bundler&#x2F;builder, as it&#x27;s faster and rapidly taking over as the default tool to solve the same use cases.<p>The other gap that is missing is a treatment of the &quot;nobuild&quot; options that exist today. Essentially things like ES modules and import maps and other stuff that lets you (if you want) run a lot of modern JavaScript libraries with zero toolchain directly in the browser.<p>I&#x27;d also want to revisit the fully decoupled approach a bit more. With the advent of LLM-based tools that can generate complete front ends for you, as well as libraries like shadcn, there is a larger upside to adopting the complexity of the decoupled API set up, even if it definitely still is slower and more painful for anything that touches the backend.<p>Django ninja has been gaining traction against DRF as an API library and the developer experience and performance are definitely better, though DRF still has way more batteries in terms of 3rd party library support for various use case.<p>The Django + HTMX + Alpine stack has only gotten more widely adopted since I published Part 5, and I&#x27;d say that part has held up quite well in the &quot;low to no JavaScript&quot; ecosystem for Django, and is the default choice for many Django devs now.</div><br/><div id="42715144" class="c"><input type="checkbox" id="c-42715144" checked=""/><div class="controls bullet"><span class="by">bkovacev</span><span>|</span><a href="#42714016">root</a><span>|</span><a href="#42714318">parent</a><span>|</span><a href="#42712883">next</a><span>|</span><label class="collapse" for="c-42715144">[-]</label><label class="expand" for="c-42715144">[2 more]</label></div><br/><div class="children"><div class="content">Can you explain further on the performance aspect of Django Ninja vs DRF?</div><br/><div id="42715702" class="c"><input type="checkbox" id="c-42715702" checked=""/><div class="controls bullet"><span class="by">e-brake</span><span>|</span><a href="#42714016">root</a><span>|</span><a href="#42715144">parent</a><span>|</span><a href="#42712883">next</a><span>|</span><label class="collapse" for="c-42715702">[-]</label><label class="expand" for="c-42715702">[1 more]</label></div><br/><div class="children"><div class="content">It is built to fully support asynchronous endpoints, and uses pydantic models for validation and parsing - lightweight and nicely fast</div><br/></div></div></div></div></div></div></div></div><div id="42712883" class="c"><input type="checkbox" id="c-42712883" checked=""/><div class="controls bullet"><span class="by">grajaganDev</span><span>|</span><a href="#42714016">prev</a><span>|</span><a href="#42720461">next</a><span>|</span><label class="collapse" for="c-42712883">[-]</label><label class="expand" for="c-42712883">[1 more]</label></div><br/><div class="children"><div class="content">Excellent article - thank you for posting.</div><br/></div></div><div id="42720461" class="c"><input type="checkbox" id="c-42720461" checked=""/><div class="controls bullet"><span class="by">jgord</span><span>|</span><a href="#42712883">prev</a><span>|</span><a href="#42714287">next</a><span>|</span><label class="collapse" for="c-42720461">[-]</label><label class="expand" for="c-42720461">[1 more]</label></div><br/><div class="children"><div class="content">My opinionated view, based on the ancient katra of code practitioners - seek smaller code, fewer dependencies :<p>When moving from PHP, better to ditch &#x27;modern&#x27; over-engineered compiled javascript, and instead use javascript at first procedurally to get acquainted, then gradually use functional idioms from a good example library such as Ramda.js to reap language and productivity benefits over PHP-the-language.<p>I live in hope that tomorrows code thought leaders choose vue.js over the byzantine-borg-machinery that is the modern react ecosystem.<p>The good parts of Javascript [ which dont include prototype OOP ] make for a very productive language.<p>The node.js ecosystem is incredible for getting stuff done, I just hope we dont kill it via forced &#x27;modernization&#x27;.   We have a generation of javascript developers who have only known javascript as a compiled language.. and the current will use LLMs to spew out react apps, not apps that use standard web apis.  The react+build+bundle ecosystem is so verbose that you almost need an LLM AI assistant frontend to do the grunt work.<p>Its a sad quirk of history that python has become the lingua franca for AI .. javascript is a better language, and great at all that wrangling of data before you pass it to the matmull compiler [ a case where you actually need compilation to better fit the lower level NPU&#x2F;GPU ]<p>While Im channeling my inner boomer, I have to say, hand on heart : callbacks are more elegant than async&#x2F;await&#x2F;promises&#x2F;then .. and they are a better conceptual match for the underlying reality.  The future has been here for some time and it is multicore - perhaps our sequential mindset is preventing us from adapting as an industry to software that makes use of very many cheap cores?</div><br/></div></div><div id="42714287" class="c"><input type="checkbox" id="c-42714287" checked=""/><div class="controls bullet"><span class="by">mlamina</span><span>|</span><a href="#42720461">prev</a><span>|</span><label class="collapse" for="c-42714287">[-]</label><label class="expand" for="c-42714287">[1 more]</label></div><br/><div class="children"><div class="content">Cory, your content is killing it :D</div><br/></div></div></div></div></div></div></div></body></html>