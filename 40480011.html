<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716800484453" as="style"/><link rel="stylesheet" href="styles.css?v=1716800484453"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fwsgonzo.medium.com/an-introduction-to-low-latency-scripting-with-libriscv-ad0619edab40">An Introduction to Low-Latency Scripting for Game Engines</a> <span class="domain">(<a href="https://fwsgonzo.medium.com">fwsgonzo.medium.com</a>)</span></div><div class="subtext"><span>fwsgonzo</span> | <span>9 comments</span></div><br/><div><div id="40488984" class="c"><input type="checkbox" id="c-40488984" checked=""/><div class="controls bullet"><span class="by">dazzawazza</span><span>|</span><a href="#40488874">next</a><span>|</span><label class="collapse" for="c-40488984">[-]</label><label class="expand" for="c-40488984">[1 more]</label></div><br/><div class="children"><div class="content">This is seriously cool but I really think we are losing our way in game development.<p>We used to create DSLs to make scripting of games simpler and less error prone... so that coders&#x2F;designers could write Scripts&#x2F;AI in a language better suited to the problems they face. It was sort of a side issue that is was a sandbox although that was really useful for lots of reasons.<p>Now we seem to be creating more and more complex toolchains while complaining that game development is getting more and more expensive. We&#x27;re not solving the correct problems at all.<p>Oh well.</div><br/></div></div><div id="40488874" class="c"><input type="checkbox" id="c-40488874" checked=""/><div class="controls bullet"><span class="by">gudzpoz</span><span>|</span><a href="#40488984">prev</a><span>|</span><a href="#40488621">next</a><span>|</span><label class="collapse" for="c-40488874">[-]</label><label class="expand" for="c-40488874">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ... but Lua still creates issues now and then. Like if you forget return, the return value is that of the last expression.<p>Is this true? Or was it true for some Lua 2.X versions? Because it does not seem to be the case for Lua 3.0 and on: [1]<p>&gt; If control reaches the end of a function without a return instruction, then the function returns with no results.<p>As to the idea of using an emulator for scripting, it seems a bit similar to approaches using WebAssembly. But looking into the benchmarks [2] provided by libriscv, it is quite interesting to see it outperforms luajit and wasm3 (in its &quot;hand-picked&quot; tests, at the very least).<p>[1] <a href="https:&#x2F;&#x2F;www.lua.org&#x2F;manual&#x2F;3.0&#x2F;manual.html" rel="nofollow">https:&#x2F;&#x2F;www.lua.org&#x2F;manual&#x2F;3.0&#x2F;manual.html</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;fwsGonzo&#x2F;libriscv?tab=readme-ov-file#benchmarks">https:&#x2F;&#x2F;github.com&#x2F;fwsGonzo&#x2F;libriscv?tab=readme-ov-file#benc...</a></div><br/><div id="40488979" class="c"><input type="checkbox" id="c-40488979" checked=""/><div class="controls bullet"><span class="by">sebstefan</span><span>|</span><a href="#40488874">parent</a><span>|</span><a href="#40488621">next</a><span>|</span><label class="collapse" for="c-40488979">[-]</label><label class="expand" for="c-40488979">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve forgotten `return` plenty of times and to the best of my recollection it&#x27;s always returned `nil` to the caller.<p>Maybe he&#x27;s talking about something else than pure lua? Something with the game&#x27;s bindings?</div><br/></div></div></div></div><div id="40488621" class="c"><input type="checkbox" id="c-40488621" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#40488874">prev</a><span>|</span><label class="collapse" for="c-40488621">[-]</label><label class="expand" for="c-40488621">[5 more]</label></div><br/><div class="children"><div class="content">I must be missing some idea used there. Why does scripting need emulation of hardware?</div><br/><div id="40488658" class="c"><input type="checkbox" id="c-40488658" checked=""/><div class="controls bullet"><span class="by">fp64</span><span>|</span><a href="#40488621">parent</a><span>|</span><a href="#40488720">next</a><span>|</span><label class="collapse" for="c-40488658">[-]</label><label class="expand" for="c-40488658">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have an answer either, but I&#x27;ve seen people who want to use bytecode&#x2F;a VM using RISC-V just because it&#x27;s well defined and tooling is already there. This has less to do with RISC-V hardware, or even really the fact that it&#x27;s RISC-V, and more with using a simple bytecode and VM - e.g. JVM could also work there, but the Java ecosystem comes with what some people consider considerable pain.</div><br/></div></div><div id="40488720" class="c"><input type="checkbox" id="c-40488720" checked=""/><div class="controls bullet"><span class="by">boffinAudio</span><span>|</span><a href="#40488621">parent</a><span>|</span><a href="#40488658">prev</a><span>|</span><a href="#40488920">next</a><span>|</span><label class="collapse" for="c-40488720">[-]</label><label class="expand" for="c-40488720">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t need emulation of <i>hardware</i> per se, but most scripting environments are already <i>virtual machines</i> of some variety or another - and RISC-V just happens to be the latest in a long line of virtual machine architectures available for the purpose.<p>The author is cleverly using libriscv for this purpose - and it is indeed a neat use of the library - but I fail to see the &#x27;scripting&#x27; part, personally - isn&#x27;t it scripting when you can just load a text file off the disk, containing program instructions, have it interpreted into some (hopefully optimized) interim representation, and then pushed through a virtual machine?  I don&#x27;t see the &quot;text files&quot; part here - but perhaps it gets more relevant in parts 2&#x2F;3&#x2F;4, which I haven&#x27;t read yet, either...<p>EDIT: I heard you like ABI, so I put a foreign ABI within your ABI so you can ABI with your ABI .. actually, this started off as a joke but its kind of painful to think about. This isn&#x27;t really &quot;scripting&quot; .. its more &quot;embed a foreign ABI into your application so you can throw a foreign binary at it, any time, and modify program behaviour extensively &quot;without needing to recompile&quot; .. maybe the author should rename the article &quot;how to embed a virtual machine into your app so you never have to write (your app code) again ..&quot;<p>I can see why they call it &quot;scripting&quot; since, this is what you usually do when embedding the Lua VM into an app - but the fact that I have to use a compiler disqualifies the term &#x27;scripting&#x27; from being applicable here, imho ..</div><br/><div id="40488918" class="c"><input type="checkbox" id="c-40488918" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#40488621">root</a><span>|</span><a href="#40488720">parent</a><span>|</span><a href="#40488920">next</a><span>|</span><label class="collapse" for="c-40488918">[-]</label><label class="expand" for="c-40488918">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but the fact that I have to use a compiler disqualifies the term &#x27;scripting&#x27; from being applicable here, imho ..<p>I&#x27;m not sure if this is a useful distinction to make.<p>Lua, perhaps the most used scripting language out there, runs through a compiler too and then runs a bytecode interpreter on the resulting code. Most scripting languages work this way. The compiler is still there even if it gets invoked at runtime. Most games ship the compiled bytecode files, not the script source.<p>The key part here is loading the &quot;script&quot; bytecode at runtime and then executing it in the host, allowing reloading and restarting the script without restarting the &quot;host&quot; process (often a game engine with long load times and lots of resident assets like textures, shaders, models etc that don&#x27;t need reloading).<p>The host process <i>could</i> also include a mechanism to invoke the compiler at runtime, pass in the script as text, grab the output and then run it as it does currently. This would be identical to how Lua et al work, but quite a bit of work to set up for limited benefit.</div><br/></div></div></div></div><div id="40488920" class="c"><input type="checkbox" id="c-40488920" checked=""/><div class="controls bullet"><span class="by">fsniper</span><span>|</span><a href="#40488621">parent</a><span>|</span><a href="#40488720">prev</a><span>|</span><label class="collapse" for="c-40488920">[-]</label><label class="expand" for="c-40488920">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t it mentioned as “sandboxing”? If the script runs in a controlled vm, it can not reach the game’s internal state unless it is exposed to the vm.</div><br/></div></div></div></div></div></div></div></div></div></body></html>