<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721725254542" as="style"/><link rel="stylesheet" href="styles.css?v=1721725254542"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.brendangregg.com/blog/2024-07-22/no-more-blue-fridays.html">No More Blue Fridays</a> <span class="domain">(<a href="https://www.brendangregg.com">www.brendangregg.com</a>)</span></div><div class="subtext"><span>moreati</span> | <span>135 comments</span></div><br/><div><div id="41034183" class="c"><input type="checkbox" id="c-41034183" checked=""/><div class="controls bullet"><span class="by">mrpippy</span><span>|</span><a href="#41034427">next</a><span>|</span><label class="collapse" for="c-41034183">[-]</label><label class="expand" for="c-41034183">[53 more]</label></div><br/><div class="children"><div class="content">&gt; Once Microsoft&#x27;s eBPF support for Windows becomes production-ready, Windows security software can be ported to eBPF as well.<p>This doesn’t seem grounded in reality. If you follow the link to the “hooks” that Windows eBPF makes available [1], it’s just for incoming packets and socket operations. IOW, MS is expecting you to use the Berkeley Packet Filter for packet filtering. Not for  filtering I&#x2F;O, or object creation&#x2F;use, or any of the other million places a driver like Crowdstrike’s hooks into the NT kernel.<p>In addition, they need to be in the kernel in order to monitor all the other 3rd party garbage running in kernel-space. ELAM (early-launch anti-malware) loads anti-malware drivers first so they can monitor everything that other drivers do. I highly doubt this is available to eBPF.<p>If Microsoft intends eBPF to be used to replace kernel-space anti-malware drivers, they have a long, long way to go.<p>[1]: <a href="https:&#x2F;&#x2F;microsoft.github.io&#x2F;ebpf-for-windows&#x2F;ebpf__structs_8h.html#a0f8242763b15ec665eaa47c6add861a0" rel="nofollow">https:&#x2F;&#x2F;microsoft.github.io&#x2F;ebpf-for-windows&#x2F;ebpf__structs_8...</a></div><br/><div id="41034397" class="c"><input type="checkbox" id="c-41034397" checked=""/><div class="controls bullet"><span class="by">brendangregg</span><span>|</span><a href="#41034183">parent</a><span>|</span><a href="#41034878">next</a><span>|</span><label class="collapse" for="c-41034397">[-]</label><label class="expand" for="c-41034397">[22 more]</label></div><br/><div class="children"><div class="content">Yes, we know eBPF must attach to equivalent events to Linux, but given there are already many event sources and consumers in Windows, the work is to make eBPF another consumer -- not to invent instrumentation frameworks from scratch.<p>Just to use an analogy: Imagine people do their banking on JavaScript websites with Google Chrome, but if they use Microsoft Edge it says &quot;JavaScript isn&#x27;t supported, please download and run this .EXE&quot;. I&#x27;m not sure we&#x27;d be asking &quot;if&quot; Microsoft would support JavaScript (or eBPF), but &quot;when.&quot;</div><br/><div id="41034530" class="c"><input type="checkbox" id="c-41034530" checked=""/><div class="controls bullet"><span class="by">surajrmal</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034397">parent</a><span>|</span><a href="#41041319">next</a><span>|</span><label class="collapse" for="c-41034530">[-]</label><label class="expand" for="c-41034530">[20 more]</label></div><br/><div class="children"><div class="content">This assumes eBPF becomes the standard. It&#x27;s not clear Microsoft wants that. They could create something else which integrates with dot net and push for that instead.<p>Also this problem of too much software running in the kernel in an unbounded manner has long existed. Why should Microsoft suddenly invest in solving it on Windows?</div><br/><div id="41037244" class="c"><input type="checkbox" id="c-41037244" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034530">parent</a><span>|</span><a href="#41034752">next</a><span>|</span><label class="collapse" for="c-41037244">[-]</label><label class="expand" for="c-41037244">[4 more]</label></div><br/><div class="children"><div class="content">Microsoft has invested in solving this for at least two decades, probably longer. They are just using a different (arguably worse) approach to this than the Unix world.<p>In Windows 9x anti-malware would just run arbitrary code in the kernel that hooked whatever it wanted. In Windows XP a lot of these things got proper interfaces (like the file system filter drivers to facilitate scanning files before they are accessed, later replaced by minifilters), and the 64 bit edition of XP introduced PatchGuard [1] to prevent drivers from modifying Microsoft&#x27;s kernel code. Additionally Microsoft is requiring ever more static and dynamic analysis to allow drivers to be signed (and thus easily deployed).<p>This is a very leaky security barrier. Instead of a hardware-enforced barrier like the kernel-userspace barrier it&#x27;s an effort to get software running at the same protection level to behave. PatchGuard is a cat-and-mouse game Microsoft is always loosing, and the analysis mostly helps against memory bugs but can&#x27;t catch everything. But MS has invested a lot of work over the years in attempts to make this path work. So expecting future actions isn&#x27;t unreasonable.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Kernel_Patch_Protection" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Kernel_Patch_Protection</a></div><br/><div id="41038976" class="c"><input type="checkbox" id="c-41038976" checked=""/><div class="controls bullet"><span class="by">Analemma_</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41037244">parent</a><span>|</span><a href="#41034752">next</a><span>|</span><label class="collapse" for="c-41038976">[-]</label><label class="expand" for="c-41038976">[3 more]</label></div><br/><div class="children"><div class="content">This is a weird reading of history. Microsoft has spent tons of effort getting as much code out of the kernel as possible: Windows drivers used to be almost all kernel-mode, now they&#x27;re nearly all in userspace and you almost never need to write a kernel-mode Windows driver unless you&#x27;re doing something with deep OS hooks (like CS was, although apparently even that wasn&#x27;t actually necessary). The safeguards on kernel code are for the tiny sliver of use cases left that need it, it is not Microsoft patching individual holes on the leaky ship.<p>They haven&#x27;t yet gone as far as Apple in banning third-party kernel-mode code entirely, but I wouldn&#x27;t be surprised if it&#x27;s coming.</div><br/><div id="41041647" class="c"><input type="checkbox" id="c-41041647" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41038976">parent</a><span>|</span><a href="#41040051">next</a><span>|</span><label class="collapse" for="c-41041647">[-]</label><label class="expand" for="c-41041647">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft made the reasonable point that locking 3rd parties out of the kernel might have resulted in legal challenges in the EU [0]. It is an interesting case where everyone is certain in hindsight that they would have been ok with MS blocking access, but it is less obvious that they would have taken that view if MS had pressured a bunch of security products out of the kernel with no obvious prompting.<p>[0] <a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;07&#x2F;22&#x2F;windows_crowdstrike_kernel_eu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;07&#x2F;22&#x2F;windows_crowdstrike_k...</a></div><br/></div></div><div id="41040051" class="c"><input type="checkbox" id="c-41040051" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41038976">parent</a><span>|</span><a href="#41041647">prev</a><span>|</span><a href="#41034752">next</a><span>|</span><label class="collapse" for="c-41040051">[-]</label><label class="expand" for="c-41040051">[1 more]</label></div><br/><div class="children"><div class="content">A thing I think a lot of people don&#x27;t include in their premises about Crowdstrike is that they&#x27;re probably the most significant aftermarket endpoint security product in the world (they are what Norton and McAfee were in 2000), which means they&#x27;re more than large enough for malware to target their code directly, which creates interesting constraints for where their code can run.<p>I&#x27;m not saying I&#x27;d run it (I would not), just that I can see why they have a lot of kernel-resident code.</div><br/></div></div></div></div></div></div><div id="41034752" class="c"><input type="checkbox" id="c-41034752" checked=""/><div class="controls bullet"><span class="by">philistine</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034530">parent</a><span>|</span><a href="#41037244">prev</a><span>|</span><a href="#41034599">next</a><span>|</span><label class="collapse" for="c-41034752">[-]</label><label class="expand" for="c-41034752">[10 more]</label></div><br/><div class="children"><div class="content">Apple took the lead on this front. It has closed easy access to the kernel by apps, and made a list of APIs to try and replace the lost functionality. Anyone maintaining a kernel module on macOS is stuck in the past.<p>Of course, the target area of macOS is much smaller than Windows, but it is absolutely possible to kick all code, malware and parasitic security services alike, from accessing the kernel.<p>The safest kernel is the one that cannot be touched at runtime.</div><br/><div id="41034904" class="c"><input type="checkbox" id="c-41034904" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034752">parent</a><span>|</span><a href="#41034788">next</a><span>|</span><label class="collapse" for="c-41034904">[-]</label><label class="expand" for="c-41034904">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think Microsoft has a choice with regards to kernel access. Hell, individuals currently use undocumented NT APIs. I can&#x27;t imagine what happens to backwards compat if kernel access is closed.<p>Apple&#x27;s closed ecosystem is entirely different. They&#x27;ll change architectures on a whim and users will go with the flow (myself included).</div><br/><div id="41035817" class="c"><input type="checkbox" id="c-41035817" checked=""/><div class="controls bullet"><span class="by">becurious</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034904">parent</a><span>|</span><a href="#41034788">next</a><span>|</span><label class="collapse" for="c-41035817">[-]</label><label class="expand" for="c-41035817">[4 more]</label></div><br/><div class="children"><div class="content">But Apple doesn’t have the industrial and commercial uses that Linux and Windows have. Where you can’t suddenly switch out to a new architecture without massive amounts of validation costs.<p>At my previous job they used to use Macs to control scientific instrumentation that needed a data acquisition card. Eventually most of the newer product lines moved over to Windows but one that was used in a validated FDA regulated environment stayed on the Mac. Over time supporting that got harder and harder: they managed through the PowerPC to Intel transition but eventually the Macs with PCIe slots went away. I think they looked at putting the PCIe card in a Thunderbolt enclosure. But the bigger problem is guaranteeing supply of a specific computer for a reasonable amount of time. Very difficult to do these days with Macs.</div><br/><div id="41036269" class="c"><input type="checkbox" id="c-41036269" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41035817">parent</a><span>|</span><a href="#41038379">next</a><span>|</span><label class="collapse" for="c-41036269">[-]</label><label class="expand" for="c-41036269">[1 more]</label></div><br/><div class="children"><div class="content">&gt; validated FDA regulated environment stayed on the Mac<p>Given how long it takes to validate in a GxP environment, and the cost, this makes sense.</div><br/></div></div><div id="41038379" class="c"><input type="checkbox" id="c-41038379" checked=""/><div class="controls bullet"><span class="by">adolph</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41035817">parent</a><span>|</span><a href="#41036269">prev</a><span>|</span><a href="#41034788">next</a><span>|</span><label class="collapse" for="c-41038379">[-]</label><label class="expand" for="c-41038379">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like they need a nice Hackintosh for that validated FDA regulation app-OS-HW combo.</div><br/><div id="41040468" class="c"><input type="checkbox" id="c-41040468" checked=""/><div class="controls bullet"><span class="by">becurious</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41038379">parent</a><span>|</span><a href="#41034788">next</a><span>|</span><label class="collapse" for="c-41040468">[-]</label><label class="expand" for="c-41040468">[1 more]</label></div><br/><div class="children"><div class="content">Good luck getting that through a regulated company’s Quality Management System or their legal department. Way too much business risk and the last thing you want is a yellow or red flag to an inspector who can stop ship on your product until all the recall and remediation is done.</div><br/></div></div></div></div></div></div></div></div><div id="41034788" class="c"><input type="checkbox" id="c-41034788" checked=""/><div class="controls bullet"><span class="by">Xunjin</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034752">parent</a><span>|</span><a href="#41034904">prev</a><span>|</span><a href="#41034599">next</a><span>|</span><label class="collapse" for="c-41034788">[-]</label><label class="expand" for="c-41034788">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The safest kernel is the one that cannot be touched at runtime.<p>Can you expand what you mean here? Because depending on the application you are running, you will need at least talk with some APIs to get privileged access?</div><br/><div id="41037314" class="c"><input type="checkbox" id="c-41037314" checked=""/><div class="controls bullet"><span class="by">Agingcoder</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034788">parent</a><span>|</span><a href="#41036213">next</a><span>|</span><label class="collapse" for="c-41037314">[-]</label><label class="expand" for="c-41037314">[1 more]</label></div><br/><div class="children"><div class="content">Being allowed to talk to the kernel to get info and running with the same privileges ( basically being able to read &#x2F; write any memory ) is different.</div><br/></div></div><div id="41036213" class="c"><input type="checkbox" id="c-41036213" checked=""/><div class="controls bullet"><span class="by">odo1242</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034788">parent</a><span>|</span><a href="#41037314">prev</a><span>|</span><a href="#41034599">next</a><span>|</span><label class="collapse" for="c-41036213">[-]</label><label class="expand" for="c-41036213">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, Apple doesn’t allow any user code to run in kernel mode without significant hoops (the kernel is code signed) and tries to provide a user space API (e.g. DriverKit) as an alternative for the missing functionality.<p>Some things (FUSE) are still annoying though.</div><br/><div id="41043044" class="c"><input type="checkbox" id="c-41043044" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41036213">parent</a><span>|</span><a href="#41034599">next</a><span>|</span><label class="collapse" for="c-41043044">[-]</label><label class="expand" for="c-41043044">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some things (FUSE) are still annoying though.<p>That should get much easier in macOS Sequoia with FSKit.<p><a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;fskit&#x2F;" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;fskit&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="41034599" class="c"><input type="checkbox" id="c-41034599" checked=""/><div class="controls bullet"><span class="by">brendangregg</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034530">parent</a><span>|</span><a href="#41034752">prev</a><span>|</span><a href="#41036717">next</a><span>|</span><label class="collapse" for="c-41034599">[-]</label><label class="expand" for="c-41034599">[4 more]</label></div><br/><div class="children"><div class="content">Microsoft have been driving the work to make eBPF an IETF industry standard.</div><br/><div id="41036332" class="c"><input type="checkbox" id="c-41036332" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034599">parent</a><span>|</span><a href="#41036717">next</a><span>|</span><label class="collapse" for="c-41036332">[-]</label><label class="expand" for="c-41036332">[3 more]</label></div><br/><div class="children"><div class="content">...just like they did with Kerberos!  And just like with Kerberos they&#x27;ll define a standard <i>then refuse to follow it</i>.  Instead, they will implement subtle changes to the Windows implementation that make solutions that use Windows eBPF incompatible with anything else, making it much more difficult to write software that works with all platforms eBPF (or even just its output).<p>Everything&#x27;s gotta be different in Windows land.  Otherwise, migrating <i>off</i> of Windows land would be too easy!<p>In case you were wondering what Microsoft refused to implement with its Kerberos implementation it&#x27;s the DNS records.  Instead of following the standard (they wrote!) they decided that all Windows clients will use AD&#x27;s Global Catalog to figure out which KDC to talk to (e.g. which one is &quot;local&quot; or closest to the client).  Since nothing but Windows uses the Global Catalog they effectively locked out other platforms from being able to integrate with Windows Kerberos implementation <i>as effectively</i> (it&#x27;ll still work, just extremely inefficiently as the clients won&#x27;t know which KDC is local so you either have to hard-code them into the krb5.conf on every single device&#x2F;server&#x2F;endpoint and hope for the best or DNS-and-pray you don&#x27;t get a Domain Controller&#x2F;KDC that&#x27;s on an ISDN line in some other country).</div><br/><div id="41037131" class="c"><input type="checkbox" id="c-41037131" checked=""/><div class="controls bullet"><span class="by">MawKKe</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41036332">parent</a><span>|</span><a href="#41036717">next</a><span>|</span><label class="collapse" for="c-41037131">[-]</label><label class="expand" for="c-41037131">[2 more]</label></div><br/><div class="children"><div class="content">Embrace, extend, ...</div><br/><div id="41038331" class="c"><input type="checkbox" id="c-41038331" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41037131">parent</a><span>|</span><a href="#41036717">next</a><span>|</span><label class="collapse" for="c-41038331">[-]</label><label class="expand" for="c-41038331">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t really seem like their strategy anymore.  It&#x27;s not like Edge directly interprets Typescript, for example.  While they embraced and extended Javascript, any extinguishing seems to be on the technical merits rather than corporate will.<p>In the case of security scanners that run in the kernel, we learned this weekend that a market need exists.  The mainstream media blamed Crowdstrike&#x27;s bugs on &quot;Windows&quot;.  Microsoft would likely like to wash its hands of future events of this class.  Linux-like eBPF is a path forward for them that allows people to run the software they want (work-slowers like Crowdstrike) while isolating their reputation from this software.</div><br/></div></div></div></div></div></div></div></div><div id="41036717" class="c"><input type="checkbox" id="c-41036717" checked=""/><div class="controls bullet"><span class="by">numbsafari</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034530">parent</a><span>|</span><a href="#41034599">prev</a><span>|</span><a href="#41041319">next</a><span>|</span><label class="collapse" for="c-41036717">[-]</label><label class="expand" for="c-41036717">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why should Microsoft suddenly invest in solving it on Windows?<p>If they can continue to avoid commercial repercussions for failing to provide a stable and secure system, then society should begin to hold them to account and force them to.<p>I’m not necessarily advocating for eBPF here, either. If they want to get there through some “proprietary” means, so be it. Apple is doing much the same on their end by locking down kexts and providing APIs for user mode system extensions instead. If MS wants to do this with some kind of .net-based solution (or some other fever dream out of MSR) then cool. The only caveat would seem to be that they are under a number of “consent decree” type agreements that would require that their own extensions be implemented on a level playing field.<p>So what. Windows Defender shouldn’t be in the kernel any more than CrowdStrike. Add an API. If that means being able to send eBPF type “programs” into kernel space, cool. If that means some user mode APIs, cool.<p>But lock it down already.</div><br/></div></div></div></div><div id="41041319" class="c"><input type="checkbox" id="c-41041319" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034397">parent</a><span>|</span><a href="#41034530">prev</a><span>|</span><a href="#41034878">next</a><span>|</span><label class="collapse" for="c-41041319">[-]</label><label class="expand" for="c-41041319">[1 more]</label></div><br/><div class="children"><div class="content">Windows development on eBPF is slower than Linux development on eBPF, so it will never be supported. A source code user licensee could develop it faster, but who licenses Windows source and already has great eBPF experience?</div><br/></div></div></div></div><div id="41034878" class="c"><input type="checkbox" id="c-41034878" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#41034183">parent</a><span>|</span><a href="#41034397">prev</a><span>|</span><a href="#41034304">next</a><span>|</span><label class="collapse" for="c-41034878">[-]</label><label class="expand" for="c-41034878">[2 more]</label></div><br/><div class="children"><div class="content">Microsoft already has an extensible file system filter capability in place, which is what current AV uses. Does it make sense to add eBPF on top of that and if so, are there any performance downsides, like we see with file system filters?</div><br/><div id="41035698" class="c"><input type="checkbox" id="c-41035698" checked=""/><div class="controls bullet"><span class="by">mauvehaus</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034878">parent</a><span>|</span><a href="#41034304">next</a><span>|</span><label class="collapse" for="c-41035698">[-]</label><label class="expand" for="c-41035698">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;ve done a technology transition once already from legacy file system filter drivers to the minifilter model. If they see enough benefit to another change, it wouldn&#x27;t be unprecedented.<p>Mind you, it looks like after 20-ish years Windows still supports loading legacy filter drivers. Given the considerable work that goes into getting even a simple filesystem minifilter driver working reliably, it&#x27;s safe to assume that we&#x27;d be looking at a similarly protracted transition period.<p>As to the performance, I don&#x27;t think the raw infrastructure to support minifilters is the major performance hit. The work the drivers themselves end up doing tends to be the bigger hit in my experience.<p>Some background for the curious:<p><a href="https:&#x2F;&#x2F;www.osr.com&#x2F;nt-insider&#x2F;2019-issue1&#x2F;the-state-of-windows-file-system-filtering-in-2019&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.osr.com&#x2F;nt-insider&#x2F;2019-issue1&#x2F;the-state-of-wind...</a></div><br/></div></div></div></div><div id="41034304" class="c"><input type="checkbox" id="c-41034304" checked=""/><div class="controls bullet"><span class="by">shahahqq</span><span>|</span><a href="#41034183">parent</a><span>|</span><a href="#41034878">prev</a><span>|</span><a href="#41034427">next</a><span>|</span><label class="collapse" for="c-41034304">[-]</label><label class="expand" for="c-41034304">[28 more]</label></div><br/><div class="children"><div class="content">I hope though that Microsoft will double down on their eBPF support for Windows after this incident.</div><br/><div id="41034848" class="c"><input type="checkbox" id="c-41034848" checked=""/><div class="controls bullet"><span class="by">benfortuna</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034304">parent</a><span>|</span><a href="#41034534">next</a><span>|</span><label class="collapse" for="c-41034848">[-]</label><label class="expand" for="c-41034848">[7 more]</label></div><br/><div class="children"><div class="content">Keep in mind they don&#x27;t just allow any old code to execute in the kernel.<p>They do have rigorous tests (WHQL), it&#x27;s just Crowdstrike decided that was too burdensome for their frequent updates, and decided to inject code from config files (thus bypassing the control).<p>The fault here is entirely with Crowdstrike.</div><br/><div id="41034990" class="c"><input type="checkbox" id="c-41034990" checked=""/><div class="controls bullet"><span class="by">capitainenemo</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034848">parent</a><span>|</span><a href="#41036037">next</a><span>|</span><label class="collapse" for="c-41034990">[-]</label><label class="expand" for="c-41034990">[4 more]</label></div><br/><div class="children"><div class="content">Is there any evidence that the config files had arbitrary code in them? The only analysis I&#x27;d seen so far indicated a parsing error loading a viral signature database that was routinely updated, but in this case was full of garbage data.</div><br/><div id="41035079" class="c"><input type="checkbox" id="c-41035079" checked=""/><div class="controls bullet"><span class="by">benfortuna</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034990">parent</a><span>|</span><a href="#41036037">next</a><span>|</span><label class="collapse" for="c-41035079">[-]</label><label class="expand" for="c-41035079">[3 more]</label></div><br/><div class="children"><div class="content">Perhaps not verified, but some smart people do have convincing arguments:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;wAzEJxOo1ts?si=UNNxAN27VV1E6mcP&amp;t=505" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;wAzEJxOo1ts?si=UNNxAN27VV1E6mcP&amp;t=505</a></div><br/><div id="41035300" class="c"><input type="checkbox" id="c-41035300" checked=""/><div class="controls bullet"><span class="by">capitainenemo</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41035079">parent</a><span>|</span><a href="#41036037">next</a><span>|</span><label class="collapse" for="c-41035300">[-]</label><label class="expand" for="c-41035300">[2 more]</label></div><br/><div class="children"><div class="content">Any article&#x2F;blog&#x2F;text-that-can-be-read?</div><br/><div id="41036767" class="c"><input type="checkbox" id="c-41036767" checked=""/><div class="controls bullet"><span class="by">alecco</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41035300">parent</a><span>|</span><a href="#41036037">next</a><span>|</span><label class="collapse" for="c-41036767">[-]</label><label class="expand" for="c-41036767">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t bother. He just repeats a tweet saying a null+offset dereference and also the speculation of that null picked from the sys file.</div><br/></div></div></div></div></div></div></div></div><div id="41036037" class="c"><input type="checkbox" id="c-41036037" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034848">parent</a><span>|</span><a href="#41034990">prev</a><span>|</span><a href="#41034534">next</a><span>|</span><label class="collapse" for="c-41036037">[-]</label><label class="expand" for="c-41036037">[2 more]</label></div><br/><div class="children"><div class="content">How rigorous are the tests if faulty data can brick the machine?</div><br/><div id="41036178" class="c"><input type="checkbox" id="c-41036178" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41036037">parent</a><span>|</span><a href="#41034534">next</a><span>|</span><label class="collapse" for="c-41036178">[-]</label><label class="expand" for="c-41036178">[1 more]</label></div><br/><div class="children"><div class="content">Not rigorous enough to have detected this flaw in the kernel sensor, although effectively any bug in this situation (an AV driver) can brick a machine. I imagine WHQL isn&#x27;t able to find every possible bug in a driver you submit to them, they&#x27;re not your QA team.</div><br/></div></div></div></div></div></div><div id="41034534" class="c"><input type="checkbox" id="c-41034534" checked=""/><div class="controls bullet"><span class="by">stackskipton</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034304">parent</a><span>|</span><a href="#41034848">prev</a><span>|</span><a href="#41034427">next</a><span>|</span><label class="collapse" for="c-41034534">[-]</label><label class="expand" for="c-41034534">[20 more]</label></div><br/><div class="children"><div class="content">Doubt it. Microsoft is clearly over Windows. They continue to produce it but every release feels like &quot;Ugh, fine, since you are paying me a ton of money.&quot;<p>Internally, Microsoft is running more and more workloads on Linux and externally, I&#x27;ve had .Net team tell me more than once that Linux is preferred environment for .Net. SQL Server team continues to push hard for Linux compatibility with every release.<p>EDIT: Windows Desktop gets more love because they clearly see that as important market. I&#x27;m talking more Windows Server.</div><br/><div id="41035001" class="c"><input type="checkbox" id="c-41035001" checked=""/><div class="controls bullet"><span class="by">mosburger</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034534">parent</a><span>|</span><a href="#41034714">next</a><span>|</span><label class="collapse" for="c-41035001">[-]</label><label class="expand" for="c-41035001">[1 more]</label></div><br/><div class="children"><div class="content">&gt; SQL Server team continues to push hard for Linux compatibility with every release.<p>It&#x27;s kinda funny that the DB that was once a fork of Sybase that was ported to Windows is trying to make its way back to Unix.</div><br/></div></div><div id="41034714" class="c"><input type="checkbox" id="c-41034714" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034534">parent</a><span>|</span><a href="#41035001">prev</a><span>|</span><a href="#41034668">next</a><span>|</span><label class="collapse" for="c-41034714">[-]</label><label class="expand" for="c-41034714">[8 more]</label></div><br/><div class="children"><div class="content">This claim about SQL Server: Is it due to disk access being slower from NT kernel compared to Linux kernel?</div><br/><div id="41036442" class="c"><input type="checkbox" id="c-41036442" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034714">parent</a><span>|</span><a href="#41034930">next</a><span>|</span><label class="collapse" for="c-41036442">[-]</label><label class="expand" for="c-41036442">[3 more]</label></div><br/><div class="children"><div class="content">I had read previously from an unverified SQL Server engineer that the thing they wanted most (with Linux support) was proper containerization (from a developer perspective).  Apparently containers on Windows just don&#x27;t cut it (which is why nobody uses them in production).  Take it with a grain of salt though.<p>I don&#x27;t think they&#x27;d ever admit that filesystem performance was an issue (though we all know it is; NTFS is over 30 years old!).</div><br/><div id="41042517" class="c"><input type="checkbox" id="c-41042517" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41036442">parent</a><span>|</span><a href="#41037262">next</a><span>|</span><label class="collapse" for="c-41042517">[-]</label><label class="expand" for="c-41042517">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s my understanding, having done benchmarks on file access on Windows, that NTFS itself is not the problem. It&#x27;s old, but the revision of the on-disk structure that we use today hails from Windows XP, and it&#x27;s about on par in terms of feature parity (and backwards compatibility, given that I can still read native NT 3.51 volumes on Windows 11) with ext4.<p>A lot of the weirdly bad performance comes from all of the machinery that Windows wraps around file access for things like filter drivers. As long as you don&#x27;t, say, indiscriminately follow every CreateFile() with a CloseHandle() and instead treat handle closure like garbage collection, you can actually eke out pretty good performance.<p>That all said, yeah, Windows containers are less than great for what I&#x27;d argue is one strikingly glaring flaw: Docker container images are built from smss.exe upward. That makes them not immediately portable between ntoskrnl.exe releases.</div><br/></div></div><div id="41037262" class="c"><input type="checkbox" id="c-41037262" checked=""/><div class="controls bullet"><span class="by">shawnz</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41036442">parent</a><span>|</span><a href="#41042517">prev</a><span>|</span><a href="#41034930">next</a><span>|</span><label class="collapse" for="c-41037262">[-]</label><label class="expand" for="c-41037262">[1 more]</label></div><br/><div class="children"><div class="content">&gt; though we all know it is; NTFS is over 30 years old!<p>ext2, which is forwards compatible with ext3 and ext4, is slightly older than NTFS</div><br/></div></div></div></div><div id="41034930" class="c"><input type="checkbox" id="c-41034930" checked=""/><div class="controls bullet"><span class="by">stackskipton</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034714">parent</a><span>|</span><a href="#41036442">prev</a><span>|</span><a href="#41035660">next</a><span>|</span><label class="collapse" for="c-41034930">[-]</label><label class="expand" for="c-41034930">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just easier for everyone involved (outside Windows GUI clicker admins) if it runs on Linux. Containerization is easier, configuration is easier and operating system is much more robust.</div><br/><div id="41044013" class="c"><input type="checkbox" id="c-41044013" checked=""/><div class="controls bullet"><span class="by">psd1</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034930">parent</a><span>|</span><a href="#41035660">next</a><span>|</span><label class="collapse" for="c-41044013">[-]</label><label class="expand" for="c-41044013">[1 more]</label></div><br/><div class="children"><div class="content">Operating system can be more robust, depending on admin skill. Let idiots configure and operate your rhel and you may not get those five nines.<p>There are costs to it, in the form of architectural baggage and slower iteration, but what windows brings to the table is a deck swept mostly clear of footguns. That can give you a different form of robustness.</div><br/></div></div></div></div><div id="41035660" class="c"><input type="checkbox" id="c-41035660" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034714">parent</a><span>|</span><a href="#41034930">prev</a><span>|</span><a href="#41034668">next</a><span>|</span><label class="collapse" for="c-41035660">[-]</label><label class="expand" for="c-41035660">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s something very wrong with Windows disk access, you can see it easily by trying to run a Windows desktop with rotating disks.<p>But SQL Server is in the unique position of being able to optimize Windows for their own needs. So they shouldn&#x27;t have this kind of problem.</div><br/><div id="41041052" class="c"><input type="checkbox" id="c-41041052" checked=""/><div class="controls bullet"><span class="by">devbent</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41035660">parent</a><span>|</span><a href="#41034668">next</a><span>|</span><label class="collapse" for="c-41041052">[-]</label><label class="expand" for="c-41041052">[1 more]</label></div><br/><div class="children"><div class="content">The file system is almost 30 years old.<p>When NTFS came out it was way better than anything on Linux. Heck even in 2006 NTFS was better.<p>But Linux keeps getting new file systems while Windows keeps NTFS.</div><br/></div></div></div></div></div></div><div id="41034668" class="c"><input type="checkbox" id="c-41034668" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034534">parent</a><span>|</span><a href="#41034714">prev</a><span>|</span><a href="#41034427">next</a><span>|</span><label class="collapse" for="c-41034668">[-]</label><label class="expand" for="c-41034668">[10 more]</label></div><br/><div class="children"><div class="content">They aren&#x27;t over windows. They continue to be incredibly interested in and actively developing how much money they can suck from their users. Especially via various forms of ads.<p>But yeah, kernel features are few and far between.</div><br/><div id="41036461" class="c"><input type="checkbox" id="c-41036461" checked=""/><div class="controls bullet"><span class="by">queuebert</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034668">parent</a><span>|</span><a href="#41034867">next</a><span>|</span><label class="collapse" for="c-41036461">[-]</label><label class="expand" for="c-41036461">[8 more]</label></div><br/><div class="children"><div class="content">I believe the term you are looking for is &quot;rent seeking&quot;.  Other than visual changes, what new functionality does Windows 11 actually have that Windows XP didn&#x27;t have?  (I&#x27;m being generous with XP, because actually 95 was already mostly internet ready.) Yet how many times have many of us paid for a Windows license on a new computer or because the old version stopped getting updates?</div><br/><div id="41036919" class="c"><input type="checkbox" id="c-41036919" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41036461">parent</a><span>|</span><a href="#41037286">next</a><span>|</span><label class="collapse" for="c-41036919">[-]</label><label class="expand" for="c-41036919">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Other than visual changes, what new functionality does Windows 11 actually have that Windows XP didn&#x27;t have?<p>Off the top of my head, limiting myself to just NT kernel stuff: WSL and Hyper-V, pseudo-terminals, condvars, WDDM, DWM, elevated privilege programs on the same desktop, font driver isolation, and limiting access to win32k for sandboxing.</div><br/></div></div><div id="41037286" class="c"><input type="checkbox" id="c-41037286" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41036461">parent</a><span>|</span><a href="#41036919">prev</a><span>|</span><a href="#41038696">next</a><span>|</span><label class="collapse" for="c-41037286">[-]</label><label class="expand" for="c-41037286">[4 more]</label></div><br/><div class="children"><div class="content">&gt; what new functionality does Windows 11 actually have that Windows XP didn&#x27;t have? (<p>Off the top of my head, built-in bluetooth support, an OS-level volume mixer, and more support for a wider variety of class-compliant devices.  I&#x27;m sure there are a lot more, and if you actually care about the answer, I don&#x27;t think it would be hard to find.</div><br/><div id="41039496" class="c"><input type="checkbox" id="c-41039496" checked=""/><div class="controls bullet"><span class="by">queuebert</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41037286">parent</a><span>|</span><a href="#41038696">next</a><span>|</span><label class="collapse" for="c-41039496">[-]</label><label class="expand" for="c-41039496">[3 more]</label></div><br/><div class="children"><div class="content">All of this could&#x27;ve been added to XP, right?</div><br/><div id="41044044" class="c"><input type="checkbox" id="c-41044044" checked=""/><div class="controls bullet"><span class="by">psd1</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41039496">parent</a><span>|</span><a href="#41039804">next</a><span>|</span><label class="collapse" for="c-41044044">[-]</label><label class="expand" for="c-41044044">[1 more]</label></div><br/><div class="children"><div class="content">Longhorn was a significant rewrite, actually. The two big upheavals in windows history were: 2000, which essentially scrapped the 95 lineage in favour of NT; and Vista, which kicked a lot of 3rd-party crap out of the kernel and added a quality gate for drivers.</div><br/></div></div><div id="41039804" class="c"><input type="checkbox" id="c-41039804" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41039496">parent</a><span>|</span><a href="#41044044">prev</a><span>|</span><a href="#41038696">next</a><span>|</span><label class="collapse" for="c-41039804">[-]</label><label class="expand" for="c-41039804">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know.<p>If it could, Then XP would just be Windows 11.  What&#x27;s the objection here.</div><br/></div></div></div></div></div></div><div id="41038696" class="c"><input type="checkbox" id="c-41038696" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41036461">parent</a><span>|</span><a href="#41037286">prev</a><span>|</span><a href="#41039816">next</a><span>|</span><label class="collapse" for="c-41038696">[-]</label><label class="expand" for="c-41038696">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Other than visual changes, what new functionality does Windows 11 actually have that Windows XP didn&#x27;t have?<p>Modern crypto ciphersuites that aren&#x27;t utterly broken? Your best options for symmetric crypto with XP are 3DES (officially retired by NIST as of this year) and RC4 (prohibited in TLS as of RFC 7465).<p>(And if you think 3DES isn&#x27;t totally broken by itself, you&#x27;re right... except for the part where the ciphersuite in question is in CBC mode and is vulnerable to BEAST. Thanks, mandated ciphersuites.)</div><br/></div></div><div id="41039816" class="c"><input type="checkbox" id="c-41039816" checked=""/><div class="controls bullet"><span class="by">wolrah</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41036461">parent</a><span>|</span><a href="#41038696">prev</a><span>|</span><a href="#41034867">next</a><span>|</span><label class="collapse" for="c-41039816">[-]</label><label class="expand" for="c-41039816">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Other than visual changes, what new functionality does Windows 11 actually have that Windows XP didn&#x27;t have?<p>XP-&gt;Vista alone brought a bunch of huge changes that massively improved security (UAC), capability (64 bit desktops), and future-proofing (UEFI) among many many other things.<p>Some helpful Wikipedia editors have answered this question in excessive detail, so I&#x27;m just going to link those for more info.  Also I&#x27;m going to start with what XP changed from 2003 both because it makes a good comparison and I&#x27;d argue 2000&#x2F;NT 5.0 is the root of the modern Windows era.  Your next sentence after the quote implies you probably won&#x27;t have a problem with that.<p>* XP&#x2F;2003: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_XP" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_XP</a><p>* 2003R2: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2003#Windows_Server_2003_R2" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2003#Windows_Se...</a><p>* Vista: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_Vista" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_Vista</a><p>* 2008: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2008#Features" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2008#Features</a><p>* 7: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_7" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_7</a><p>* 2008R2: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2008_R2#New_features" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2008_R2#New_fea...</a><p>* 8: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_8" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_8</a><p>* 2012: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2012#Features" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2012#Features</a><p>* 8.1: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_8.1#New_and_changed_features" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_8.1#New_and_changed_fe...</a><p>* 2012R2: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2012_R2#Features" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2012_R2#Feature...</a><p>* 10: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_10" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_10</a><p>* 2016: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2016#Features" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2016#Features</a><p>* 2019: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2019#Features" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2019#Features</a><p>* 2022: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2022#Features" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_Server_2022#Features</a><p>* 11: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_11" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Features_new_to_Windows_11</a><p>* 2025: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-server&#x2F;get-started&#x2F;whats-new-windows-server-2025" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows-server&#x2F;get-started...</a><p>Obviously some of this will be &quot;fluff&quot; and that&#x27;s up to your own personal definitions, but to act like there haven&#x27;t been significant changes in every major revision is just nonsense.</div><br/></div></div></div></div><div id="41034867" class="c"><input type="checkbox" id="c-41034867" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#41034183">root</a><span>|</span><a href="#41034668">parent</a><span>|</span><a href="#41036461">prev</a><span>|</span><a href="#41034427">next</a><span>|</span><label class="collapse" for="c-41034867">[-]</label><label class="expand" for="c-41034867">[1 more]</label></div><br/><div class="children"><div class="content">See also: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cash_cow" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cash_cow</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41034427" class="c"><input type="checkbox" id="c-41034427" checked=""/><div class="controls bullet"><span class="by">kevin_nisbet</span><span>|</span><a href="#41034183">prev</a><span>|</span><a href="#41034004">next</a><span>|</span><label class="collapse" for="c-41034427">[-]</label><label class="expand" for="c-41034427">[3 more]</label></div><br/><div class="children"><div class="content">I hate to dispute with someone like Brendan Gregg, but I&#x27;m hoping vendors in this space take a more holistic approach to investigating the complete failure chain. I personally tend to get cautious when there is a proposal that x will solve the problem that occurred on y date, especially 3 days after the failure. It may be true, but if we don&#x27;t do the analysis we could leave ourselves open to blindspots. There may also be plenty of alternative approaches that should be considered and appropriately discarded.<p>I think the part I specifically dispute is the only negative outcome is wasted CPU cycles. That&#x27;s likely the case for the class of bug, but there are plenty of failure modes where a bad ruleset could badly brick a system and make it hard to recover.<p>That&#x27;s not to say eBPF based security modules isn&#x27;t the right choice for many vendors, just that let&#x27;s understand what risks they do and do not avoid, and what part of the failure chain they particularly address.</div><br/><div id="41036258" class="c"><input type="checkbox" id="c-41036258" checked=""/><div class="controls bullet"><span class="by">mirashii</span><span>|</span><a href="#41034427">parent</a><span>|</span><a href="#41036707">next</a><span>|</span><label class="collapse" for="c-41036258">[-]</label><label class="expand" for="c-41036258">[1 more]</label></div><br/><div class="children"><div class="content">Just because you have not been aware of the discussions on this topic that have been happening for years, doesn&#x27;t mean that they haven&#x27;t been happening. This isn&#x27;t some new analysis formed 3 days after an incident, this is the generally accepted consensus among many experts who have been working in the space, introducing these new APIs specifically to improve stability, security, etc. of systems.</div><br/></div></div><div id="41036707" class="c"><input type="checkbox" id="c-41036707" checked=""/><div class="controls bullet"><span class="by">ohmyiv</span><span>|</span><a href="#41034427">parent</a><span>|</span><a href="#41036258">prev</a><span>|</span><a href="#41034004">next</a><span>|</span><label class="collapse" for="c-41036707">[-]</label><label class="expand" for="c-41036707">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I personally tend to get cautious when there is a proposal that x will solve the problem that occurred on y date, especially 3 days after the failure.<p>Microsoft has been working on eBPF for a few years at least.<p><a href="https:&#x2F;&#x2F;opensource.microsoft.com&#x2F;blog&#x2F;2021&#x2F;05&#x2F;10&#x2F;making-ebpf-work-on-windows&#x2F;" rel="nofollow">https:&#x2F;&#x2F;opensource.microsoft.com&#x2F;blog&#x2F;2021&#x2F;05&#x2F;10&#x2F;making-ebpf...</a><p><a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;857215&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;857215&#x2F;</a><p>If you&#x27;re really concerned, they have discussions and communication channels where you&#x27;re invited to air your concerns. They&#x27;re listed on their github:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;ebpf-for-windows">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;ebpf-for-windows</a><p>Who knows, maybe they already have answers to your concerns. If not, they can address them there.</div><br/></div></div></div></div><div id="41034004" class="c"><input type="checkbox" id="c-41034004" checked=""/><div class="controls bullet"><span class="by">kayo_20211030</span><span>|</span><a href="#41034427">prev</a><span>|</span><a href="#41035225">next</a><span>|</span><label class="collapse" for="c-41034004">[-]</label><label class="expand" for="c-41034004">[12 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t right. If I need a system to run <i>with</i> a piece of code, then it shouldn&#x27;t run at all if that piece of code is broken. Ignoring the failure is perverse. Let&#x27;s say that the driver code ensures that some medical machine has safety locks (safeguards) in place to make sure that piece of equipment won&#x27;t fry you to a crisp; I&#x27;d prefer that the whole thing not run at all rather than blithely operate with the safeguards disabled.
It&#x27;s turtles all the way down.</div><br/><div id="41034237" class="c"><input type="checkbox" id="c-41034237" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#41034004">parent</a><span>|</span><a href="#41034327">next</a><span>|</span><label class="collapse" for="c-41034237">[-]</label><label class="expand" for="c-41034237">[2 more]</label></div><br/><div class="children"><div class="content">I think the premise is false? It&#x27;s up to the eBPF implementor what to do in the case of invalid input; the kernel could choose to perform a controlled shutdown in that case. (I have no idea what e.g. Linux actually does here, but one could imagine worlds where the action it takes on invalid input is configurable.)<p>Also your statement is <i>sometimes</i> not true, although I certainly sympathise in the mainline case. In some contexts you really do need to keep on trucking. The first example to spring to mind is &quot;the guidance computers on an automated Mars lander&quot;; the round-trip to Earth is simply too long to defer responsibility in that case. If you shut down then you <i>will</i> crash, but if you do your best from a corrupted state then you merely <i>probably</i> crash, which is presumably better.</div><br/><div id="41034495" class="c"><input type="checkbox" id="c-41034495" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41034004">root</a><span>|</span><a href="#41034237">parent</a><span>|</span><a href="#41034327">next</a><span>|</span><label class="collapse" for="c-41034495">[-]</label><label class="expand" for="c-41034495">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have no idea what e.g. Linux actually does here<p>If you attempt to load an eBPF program that the verifier rejects, the syscall to load it fails with EINVAL or E2BIG. What your user-space program then does is up to you, of course.</div><br/></div></div></div></div><div id="41034327" class="c"><input type="checkbox" id="c-41034327" checked=""/><div class="controls bullet"><span class="by">phartenfeller</span><span>|</span><a href="#41034004">parent</a><span>|</span><a href="#41034237">prev</a><span>|</span><a href="#41036957">next</a><span>|</span><label class="collapse" for="c-41034327">[-]</label><label class="expand" for="c-41034327">[3 more]</label></div><br/><div class="children"><div class="content">The medical machine software should just refuse to run with an error message if a critical driver was not loaded.
The OS bricking is causing way more trouble where an IT technician now needs to fix something where it otherwise would just be updating the faulty driver...
Also does your car not start if you are missing water for the wiper?</div><br/><div id="41034452" class="c"><input type="checkbox" id="c-41034452" checked=""/><div class="controls bullet"><span class="by">jve</span><span>|</span><a href="#41034004">root</a><span>|</span><a href="#41034327">parent</a><span>|</span><a href="#41036957">next</a><span>|</span><label class="collapse" for="c-41034452">[-]</label><label class="expand" for="c-41034452">[2 more]</label></div><br/><div class="children"><div class="content">Water for the wiper is userland feature.<p>3rd party hooking into kernel is 3rd party responsibility. It is like equipping your car with LPG - THAT hooks into engine (kernel). And When I had a faulty gas pressure sensor then my car actually halted (BSOD if you will) instead of automatically failing over to gasoline as it is by design.<p>You can argue that car had no means to continue execution but kernel has, however invalid kernel state can cause more corruption down the road. Or as parent even points out - carry out lethal doses of something.</div><br/><div id="41034924" class="c"><input type="checkbox" id="c-41034924" checked=""/><div class="controls bullet"><span class="by">pinebox</span><span>|</span><a href="#41034004">root</a><span>|</span><a href="#41034452">parent</a><span>|</span><a href="#41036957">next</a><span>|</span><label class="collapse" for="c-41034924">[-]</label><label class="expand" for="c-41034924">[1 more]</label></div><br/><div class="children"><div class="content">Initially I was inclined to disagree (&quot;these things should always fail safe&quot;) however with more and more stuff being pushed into the kernel it&#x27;s hard to say that you&#x27;re wrong or exactly where a line needs to be drawn between &quot;minimally functional system&quot; and &quot;dangerously out of control system&quot;.<p>I think until we discover a technology that forces commercial software vendors to employ functioning QA departments none of this will really solve anything.</div><br/></div></div></div></div></div></div><div id="41036957" class="c"><input type="checkbox" id="c-41036957" checked=""/><div class="controls bullet"><span class="by">enragedcacti</span><span>|</span><a href="#41034004">parent</a><span>|</span><a href="#41034327">prev</a><span>|</span><a href="#41035394">next</a><span>|</span><label class="collapse" for="c-41036957">[-]</label><label class="expand" for="c-41036957">[2 more]</label></div><br/><div class="children"><div class="content">I agree that some system components should be treated as critical no matter what, but the software at issue in this case (Falcon Sensor or Antivirus more generally) is precautionary and only best effort anyways. I would wager the vast majority of the orgs affected on Friday would have preferred the marginally increased risk of a malware attack or unauthorized use over a 24 hour period instead of the total IT collapse they experienced. Further, there&#x27;s no reason the bug HAD to cause a BSOD, it&#x27;s possible the systems could have kept on trucking but with an undefined state and limitless consequences. At least with eBPF you get to detect a subset of possible errors and make a risk management decision based on the result.</div><br/><div id="41040224" class="c"><input type="checkbox" id="c-41040224" checked=""/><div class="controls bullet"><span class="by">kayo_20211030</span><span>|</span><a href="#41034004">root</a><span>|</span><a href="#41036957">parent</a><span>|</span><a href="#41035394">next</a><span>|</span><label class="collapse" for="c-41040224">[-]</label><label class="expand" for="c-41040224">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m with you.
What&#x27;s critical, and what&#x27;s not? Is it a big thing, or not a big thing? Is this particular machine more critical than the one over there?
Security systems need to be at the lowest level, or else some shifty bastard will find a path around them. If it&#x27;s at the lowest level, the downside of a failure is catastrophic, as we experienced last Friday. The carnage here is ultimately on CrowdStrike. The testing must have been slapdash at best, and missing at worst. eBPF changes nothing. The question is: should we fail, or carry on? eBPF doesn&#x27;t help with that decision, it only determines the outcome from a system perspective. Any decision is a value judgement; it might be right or wrong, and its outcome either benign or deadly.
Choices!</div><br/></div></div></div></div><div id="41035394" class="c"><input type="checkbox" id="c-41035394" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41034004">parent</a><span>|</span><a href="#41036957">prev</a><span>|</span><a href="#41039366">next</a><span>|</span><label class="collapse" for="c-41035394">[-]</label><label class="expand" for="c-41035394">[1 more]</label></div><br/><div class="children"><div class="content">I like how Unison works for this reason.  You call functions by cryptographic hash, so you have some assurance that you&#x27;re calling the same function you called yesterday.<p>Updates would require the caller to call different functions which means putting the responsibility in the hands of the caller, where it should be, instead of on whoever has a side channel to tamper with the kernel.<p>You end up with the work-perfectly-or-not-at-all behavior that you&#x27;re after because if the function that goes with the indicated hash is not present, you can&#x27;t call it, and if it is present you can&#x27;t call it in any way besides how it was intended</div><br/></div></div><div id="41039366" class="c"><input type="checkbox" id="c-41039366" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#41034004">parent</a><span>|</span><a href="#41035394">prev</a><span>|</span><a href="#41035317">next</a><span>|</span><label class="collapse" for="c-41039366">[-]</label><label class="expand" for="c-41039366">[1 more]</label></div><br/><div class="children"><div class="content">The system clearly already behaves that way (i.e. ignores failure) - after all, the fix was to simply delete the offending file.  If that&#x27;s an option, then loader can do that too. It can and perhaps even is smarter, such as &quot;fallback onto previous version&quot;.<p>Furthermore, the reaction to a malformed state need not be &quot;ignore&quot;.  It could disable restricted user login; or turn off the screen.<p>If the worry is that this is viable to abuse by malware, well, if the malware can already rewrite the on-disk files for the AV, I wonder whether it&#x27;s really a good idea to trust the system itself to be able to deal with that. It&#x27;d probably be safer to just report that up the security foodchain, and potentially let some external system take measures such as disable or restrict network access.  Better yet, such measures don&#x27;t even require the same capabilities to intervene in the system, merely to observe - which makes the AV system less likely to serve as a malware vector itself or to cause bugs like this.</div><br/></div></div><div id="41035317" class="c"><input type="checkbox" id="c-41035317" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#41034004">parent</a><span>|</span><a href="#41039366">prev</a><span>|</span><a href="#41035225">next</a><span>|</span><label class="collapse" for="c-41035317">[-]</label><label class="expand" for="c-41035317">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Ignoring the failure is perverse.</i><p>If the failed system is a security module, I think that&#x27;s absolutely correct. If the system runs, without the security module, well, that&#x27;s like forgetting to pack condoms on Shore Leave. You&#x27;ll likely be bringing something back to the ship with you.<p><i>Someone</i> needs to be testing the module, and the enclosing system, to make sure it doesn&#x27;t cause problems.<p>I suspect that it got a great deal of automated unit testing, but maybe not so much fuzz and monkey (especially &quot;Chaos Monkey&quot;-style) testing.<p>It&#x27;s a fuzzy, monkey-filled world out there...</div><br/><div id="41040300" class="c"><input type="checkbox" id="c-41040300" checked=""/><div class="controls bullet"><span class="by">kayo_20211030</span><span>|</span><a href="#41034004">root</a><span>|</span><a href="#41035317">parent</a><span>|</span><a href="#41035225">next</a><span>|</span><label class="collapse" for="c-41040300">[-]</label><label class="expand" for="c-41040300">[1 more]</label></div><br/><div class="children"><div class="content">Interesting analogy, but yes. If the module *is* necessary, well, it&#x27;s necessary and nothing should work without it. Testing must have been a mess here.</div><br/></div></div></div></div></div></div><div id="41035225" class="c"><input type="checkbox" id="c-41035225" checked=""/><div class="controls bullet"><span class="by">uticus</span><span>|</span><a href="#41034004">prev</a><span>|</span><a href="#41036376">next</a><span>|</span><label class="collapse" for="c-41035225">[-]</label><label class="expand" for="c-41035225">[3 more]</label></div><br/><div class="children"><div class="content">&gt; eBPF programs cannot crash the entire system because they are safety-checked by a software verifier and are effectively run in a sandbox.<p>Isn’t one of the purposes of an OS to police software? I get that this has to do with the OS itself, but what does watching the watchers accomplish other than adding a layer which must then be watched?<p>Why not reduce complexity instead of naively trusting that the new complexity will be better long term?</div><br/><div id="41036607" class="c"><input type="checkbox" id="c-41036607" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#41035225">parent</a><span>|</span><a href="#41035589">next</a><span>|</span><label class="collapse" for="c-41036607">[-]</label><label class="expand" for="c-41036607">[1 more]</label></div><br/><div class="children"><div class="content">eBPF isn&#x27;t &quot;watching the watchers&quot; it&#x27;s just a tool that lets <i>other</i> tools access low-level things in the kernel via a very picky sandbox.  Think of it like this:<p>Old way: Load kernel driver, hook into bazillions of system calls (doing whatever it is you want to do), pray you don&#x27;t screw anything up (otherwise you <i>can</i> get a panic though not necessarily--Linux is quite robust).<p>eBPF way: Just ask eBPF to tell you what you want by giving it some eBPF-specific instructions.<p>There&#x27;s a rundown on how it works here: <a href="https:&#x2F;&#x2F;ebpf.io&#x2F;what-is-ebpf&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ebpf.io&#x2F;what-is-ebpf&#x2F;</a></div><br/></div></div><div id="41035589" class="c"><input type="checkbox" id="c-41035589" checked=""/><div class="controls bullet"><span class="by">MetaWhirledPeas</span><span>|</span><a href="#41035225">parent</a><span>|</span><a href="#41036607">prev</a><span>|</span><a href="#41036376">next</a><span>|</span><label class="collapse" for="c-41035589">[-]</label><label class="expand" for="c-41035589">[1 more]</label></div><br/><div class="children"><div class="content">Right? I might spend a few minutes seeing if an AI chatbot can explain all the justifications that lead to using something like CrowdStrike in the first place.</div><br/></div></div></div></div><div id="41036376" class="c"><input type="checkbox" id="c-41036376" checked=""/><div class="controls bullet"><span class="by">muth02446</span><span>|</span><a href="#41035225">prev</a><span>|</span><a href="#41036392">next</a><span>|</span><label class="collapse" for="c-41036376">[-]</label><label class="expand" for="c-41036376">[3 more]</label></div><br/><div class="children"><div class="content">```The verifier is rigorous -- the Linux implementation has over 20,000 lines of code -- with contributions from industry (e.g., Meta, Isovalent, Google) and academia (e.g., Rutgers University, University of Washington). The safety this provides is a key benefit of eBPF, along with heightened security and lower resource usage.
```
Wow, 20k is not exactly encouraging. Besides the extra attack surface, who can vouch for such a large code base?</div><br/><div id="41038527" class="c"><input type="checkbox" id="c-41038527" checked=""/><div class="controls bullet"><span class="by">haberman</span><span>|</span><a href="#41036376">parent</a><span>|</span><a href="#41036392">next</a><span>|</span><label class="collapse" for="c-41038527">[-]</label><label class="expand" for="c-41038527">[2 more]</label></div><br/><div class="children"><div class="content">I had exactly the same thought. I don’t know if that 20k number was supposed to inspire confidence, but for me it did the opposite. It would have inspired confidence if it was 300 lines of code.<p>My impression is that the WebAssembly verifier is much simpler.</div><br/></div></div></div></div><div id="41036392" class="c"><input type="checkbox" id="c-41036392" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#41036376">prev</a><span>|</span><a href="#41034716">next</a><span>|</span><label class="collapse" for="c-41036392">[-]</label><label class="expand" for="c-41036392">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like a cool technology, but this was the really egregious problem:<p>&gt; There are other ways to reduce risks during software deployment that can be employed as well: canary testing, staged rollouts, and &quot;resilience engineering&quot; in general<p>You don&#x27;t need a new technology to implement basic industry-standard quality control</div><br/></div></div><div id="41034716" class="c"><input type="checkbox" id="c-41034716" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41036392">prev</a><span>|</span><a href="#41034684">next</a><span>|</span><label class="collapse" for="c-41034716">[-]</label><label class="expand" for="c-41034716">[1 more]</label></div><br/><div class="children"><div class="content">Maybe we should start taking Fridays off to commemorate the event, which probably would have been less bad if more people spent less time with their nose to the grindstone and had more time to stop and think about how it all was shaping up and how they could influence that shape.</div><br/></div></div><div id="41034684" class="c"><input type="checkbox" id="c-41034684" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41034716">prev</a><span>|</span><a href="#41034454">next</a><span>|</span><label class="collapse" for="c-41034684">[-]</label><label class="expand" for="c-41034684">[9 more]</label></div><br/><div class="children"><div class="content">The blog post says:<p><pre><code>    &gt; eBPF, which is immune to such crashes.
</code></pre>
I tried to Google about this, but I cannot find anything definitive.  It looks like you can still break things.  Can an expert on eBPF please comment on this claim?  This is the best that I could find: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;70403212&#x2F;why-is-ebpf-said-to-be-safer-than-lkm" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;70403212&#x2F;why-is-ebpf-sai...</a></div><br/><div id="41035206" class="c"><input type="checkbox" id="c-41035206" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41034684">parent</a><span>|</span><a href="#41034454">next</a><span>|</span><label class="collapse" for="c-41035206">[-]</label><label class="expand" for="c-41035206">[8 more]</label></div><br/><div class="children"><div class="content">eBPF programs cannot crash the kernel, assuming there are no bugs in the eBPF verifier. There have been such bugs in the past but they seem to be getting more and more rare.</div><br/><div id="41035788" class="c"><input type="checkbox" id="c-41035788" checked=""/><div class="controls bullet"><span class="by">javierhonduco</span><span>|</span><a href="#41034684">root</a><span>|</span><a href="#41035206">parent</a><span>|</span><a href="#41035845">next</a><span>|</span><label class="collapse" for="c-41035788">[-]</label><label class="expand" for="c-41035788">[2 more]</label></div><br/><div class="children"><div class="content">Or in other parts of the kernel. It&#x27;s been the case in multiple occasions that buggy locking (or more generalised, missing &#x27;resource&#x27; release) has caused problems for perfectly safe BPF programs. For example, see <a href="https:&#x2F;&#x2F;bugs.debian.org&#x2F;cgi-bin&#x2F;bugreport.cgi?bug=1033398" rel="nofollow">https:&#x2F;&#x2F;bugs.debian.org&#x2F;cgi-bin&#x2F;bugreport.cgi?bug=1033398</a> and the fix <a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;commit&#x2F;mm&#x2F;maccess.c?id=d319f344561de23e810515d109c7278919bff7b0" rel="nofollow">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a></div><br/><div id="41036525" class="c"><input type="checkbox" id="c-41036525" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41034684">root</a><span>|</span><a href="#41035788">parent</a><span>|</span><a href="#41035845">next</a><span>|</span><label class="collapse" for="c-41036525">[-]</label><label class="expand" for="c-41036525">[1 more]</label></div><br/><div class="children"><div class="content">This is actually exactly the bug I was thinking of, so fair point! (I work at PS now and am aware you worked on debugging it a while back).</div><br/></div></div></div></div><div id="41035845" class="c"><input type="checkbox" id="c-41035845" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#41034684">root</a><span>|</span><a href="#41035206">parent</a><span>|</span><a href="#41035788">prev</a><span>|</span><a href="#41036491">next</a><span>|</span><label class="collapse" for="c-41035845">[-]</label><label class="expand" for="c-41035845">[2 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t really true.  eBPF programs in Linux have access to a large set of helper functions written in plain C.  <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;856005&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;856005&#x2F;</a></div><br/><div id="41036253" class="c"><input type="checkbox" id="c-41036253" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41034684">root</a><span>|</span><a href="#41035845">parent</a><span>|</span><a href="#41036491">next</a><span>|</span><label class="collapse" for="c-41036253">[-]</label><label class="expand" for="c-41036253">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see how this contradicts what I said. Indeed, there are helpers, but the verifier is supposed to check that the eBPF program isn&#x27;t calling them with invalid arguments.</div><br/></div></div></div></div><div id="41036491" class="c"><input type="checkbox" id="c-41036491" checked=""/><div class="controls bullet"><span class="by">queuebert</span><span>|</span><a href="#41034684">root</a><span>|</span><a href="#41035206">parent</a><span>|</span><a href="#41035845">prev</a><span>|</span><a href="#41035577">next</a><span>|</span><label class="collapse" for="c-41036491">[-]</label><label class="expand" for="c-41036491">[2 more]</label></div><br/><div class="children"><div class="content">I would be very hesitant to say &quot;cannot&quot; in a million-line C code base.</div><br/><div id="41036513" class="c"><input type="checkbox" id="c-41036513" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41034684">root</a><span>|</span><a href="#41036491">parent</a><span>|</span><a href="#41035577">next</a><span>|</span><label class="collapse" for="c-41036513">[-]</label><label class="expand" for="c-41036513">[1 more]</label></div><br/><div class="children"><div class="content">Yes, bugs in Linux are possible, so there might be some eBPF code that crashes the kernel. Just like bugs in Chrome are possible, so there might be some JavaScript that crashes the browser. Still, JavaScript is much safer than native code, because fixing the bugs in one implementation is a tractable problem, whereas fixing the bugs in all user code is not.</div><br/></div></div></div></div></div></div></div></div><div id="41034454" class="c"><input type="checkbox" id="c-41034454" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#41034684">prev</a><span>|</span><a href="#41036297">next</a><span>|</span><label class="collapse" for="c-41034454">[-]</label><label class="expand" for="c-41034454">[1 more]</label></div><br/><div class="children"><div class="content">If the filters are loaded at boot and hook into everything then a bug can still lock down the system to a point where it can&#x27;t be operated or patched anymore (e.g. because you loaded an empty whitelist). So it could end up replacing a boot loop with another form of DoS.<p>If microsoft includes a hardcoded whitelist that covers some essentials needed for recovery that could make a bug in such a tool easier to fix, but could still cause effective downtimes (system running but unusuable) until such a fix is delivered.</div><br/></div></div><div id="41036297" class="c"><input type="checkbox" id="c-41036297" checked=""/><div class="controls bullet"><span class="by">kaliszad</span><span>|</span><a href="#41034454">prev</a><span>|</span><a href="#41040818">next</a><span>|</span><label class="collapse" for="c-41036297">[-]</label><label class="expand" for="c-41036297">[2 more]</label></div><br/><div class="children"><div class="content">&quot;These security agents will then be safe and unable to cause a Windows kernel crash.&quot;<p>Unless of course there is a bug in eBPF (<a href="https:&#x2F;&#x2F;access.redhat.com&#x2F;solutions&#x2F;7068083" rel="nofollow">https:&#x2F;&#x2F;access.redhat.com&#x2F;solutions&#x2F;7068083</a>) @brendangregg and the kernel panics&#x2F; BSoDs anyway which you mention later in the article of course.</div><br/><div id="41036572" class="c"><input type="checkbox" id="c-41036572" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#41036297">parent</a><span>|</span><a href="#41040818">next</a><span>|</span><label class="collapse" for="c-41036572">[-]</label><label class="expand" for="c-41036572">[1 more]</label></div><br/><div class="children"><div class="content">Benefit of fixing that bug is that all ebpf programs benefit versus every security vendor needing to ensure they write perfect c code.</div><br/></div></div></div></div><div id="41040818" class="c"><input type="checkbox" id="c-41040818" checked=""/><div class="controls bullet"><span class="by">kjellsbells</span><span>|</span><a href="#41036297">prev</a><span>|</span><a href="#41033795">next</a><span>|</span><label class="collapse" for="c-41040818">[-]</label><label class="expand" for="c-41040818">[2 more]</label></div><br/><div class="children"><div class="content">Lets suppose that eBPF solves this particular problem, eventually, for Windows. Doesn&#x27;t sidestepping the entire class of Crowdstrike-style fubars require that Microsoft then mandate that no, backward compatibility will not be offered?<p>Back compat seems to be such a shibboleth in the Windows world, but comes at an incredible price. The reasons cited all seem to boil down to keeping some imagined customers&#x27; obscure LOB app running for decades. But that seems like an excuse to me. Surely Microsoft would <i>like</i> to shake out the last diehards running some VB5 app on a patched up PC in a factory. Isn&#x27;t it more beneficial to everyone to start sunsetting acres of ancient NT code and approaches and streamline the entire attack surface?</div><br/><div id="41041097" class="c"><input type="checkbox" id="c-41041097" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#41040818">parent</a><span>|</span><a href="#41033795">next</a><span>|</span><label class="collapse" for="c-41041097">[-]</label><label class="expand" for="c-41041097">[1 more]</label></div><br/><div class="children"><div class="content">it would be enough if MS offered knobs and switches for admins&#x2F;devs&#x2F;vendors to disallow non-static-verified stuff in the kernel</div><br/></div></div></div></div><div id="41033795" class="c"><input type="checkbox" id="c-41033795" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#41040818">prev</a><span>|</span><a href="#41034166">next</a><span>|</span><label class="collapse" for="c-41033795">[-]</label><label class="expand" for="c-41033795">[9 more]</label></div><br/><div class="children"><div class="content">&gt; <i>In the future, computers will not crash due to bad software updates, even those updates that involve kernel code. In the future, these updates will push eBPF code.</i><p>Assuming every security critical system will be on a recent enough kernel to support this...</div><br/><div id="41033905" class="c"><input type="checkbox" id="c-41033905" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#41033795">parent</a><span>|</span><a href="#41034528">next</a><span>|</span><label class="collapse" for="c-41033905">[-]</label><label class="expand" for="c-41033905">[5 more]</label></div><br/><div class="children"><div class="content">And assuming there&#x27;s no bugs in the BPF code...<p>Oh wait: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41031699">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41031699</a></div><br/><div id="41033978" class="c"><input type="checkbox" id="c-41033978" checked=""/><div class="controls bullet"><span class="by">efee22</span><span>|</span><a href="#41033795">root</a><span>|</span><a href="#41033905">parent</a><span>|</span><a href="#41034528">next</a><span>|</span><label class="collapse" for="c-41033978">[-]</label><label class="expand" for="c-41033978">[4 more]</label></div><br/><div class="children"><div class="content">RHEL kernel.. right. Imho, I&#x27;d trust an upstream stable kernel far more than a RHEL one for production which has dozen of feature backports and an internal kABI to maintain.. granted RH has a QA team, but it is still impossible to test everything beforehand.</div><br/><div id="41034213" class="c"><input type="checkbox" id="c-41034213" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#41033795">root</a><span>|</span><a href="#41033978">parent</a><span>|</span><a href="#41034528">next</a><span>|</span><label class="collapse" for="c-41034213">[-]</label><label class="expand" for="c-41034213">[3 more]</label></div><br/><div class="children"><div class="content">On the upside, non root users can&#x27;t insert ebpf code, so its a priv&#x27;ed operation, not like other distros.</div><br/><div id="41034690" class="c"><input type="checkbox" id="c-41034690" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#41033795">root</a><span>|</span><a href="#41034213">parent</a><span>|</span><a href="#41034528">next</a><span>|</span><label class="collapse" for="c-41034690">[-]</label><label class="expand" for="c-41034690">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t it tied to CAP_BPF on every distro since the 5.8 kernel?<p><a href="https:&#x2F;&#x2F;mdaverde.com&#x2F;posts&#x2F;cap-bpf&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mdaverde.com&#x2F;posts&#x2F;cap-bpf&#x2F;</a></div><br/><div id="41043826" class="c"><input type="checkbox" id="c-41043826" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#41033795">root</a><span>|</span><a href="#41034690">parent</a><span>|</span><a href="#41034528">next</a><span>|</span><label class="collapse" for="c-41043826">[-]</label><label class="expand" for="c-41043826">[1 more]</label></div><br/><div class="children"><div class="content">Rhel8 is based on 4.18
RHEL9 is based on 5.14 , i think it still has the same restriction ( kernel.unprivileged_bpf_disabled ).<p>I reckon Red Hat may duplicate upstreams behavior by RHEL10.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41034528" class="c"><input type="checkbox" id="c-41034528" checked=""/><div class="controls bullet"><span class="by">dredmorbius</span><span>|</span><a href="#41033795">parent</a><span>|</span><a href="#41033905">prev</a><span>|</span><a href="#41033887">next</a><span>|</span><label class="collapse" for="c-41034528">[-]</label><label class="expand" for="c-41034528">[1 more]</label></div><br/><div class="children"><div class="content">Considering the number of systems running very obsolete OSes these days:  WinNT (4x or 3x), Windows, DOS, or various proprietary Unixen, stale Linux flavours, etc., etc., ... yes, quite.</div><br/></div></div><div id="41033887" class="c"><input type="checkbox" id="c-41033887" checked=""/><div class="controls bullet"><span class="by">efee22</span><span>|</span><a href="#41033795">parent</a><span>|</span><a href="#41034528">prev</a><span>|</span><a href="#41034166">next</a><span>|</span><label class="collapse" for="c-41033887">[-]</label><label class="expand" for="c-41033887">[2 more]</label></div><br/><div class="children"><div class="content">I think with a LTS distribution you should get very far these days when it comes to implementing such sensors.</div><br/><div id="41034933" class="c"><input type="checkbox" id="c-41034933" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41033795">root</a><span>|</span><a href="#41033887">parent</a><span>|</span><a href="#41034166">next</a><span>|</span><label class="collapse" for="c-41034933">[-]</label><label class="expand" for="c-41034933">[1 more]</label></div><br/><div class="children"><div class="content">On rhel8 variants, you can use the Oracle UEK to get eBPF.<p><a href="https:&#x2F;&#x2F;blogs.oracle.com&#x2F;linux&#x2F;post&#x2F;oracle-linux-and-bpf" rel="nofollow">https:&#x2F;&#x2F;blogs.oracle.com&#x2F;linux&#x2F;post&#x2F;oracle-linux-and-bpf</a><p><pre><code>  $ cat &#x2F;etc&#x2F;redhat-release &#x2F;etc&#x2F;oracle-release &#x2F;proc&#x2F;version
  Red Hat Enterprise Linux release 8.10 (Ootpa)
  Oracle Linux Server release 8.10
  Linux version 5.15.0-203.146.5.1.el8uek.x86_64 (mockbuild@host-100-100-224-48) (gcc (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9.2.0.1), GNU ld version 2.36.1-4.0.1.el8_6) #2 SMP Thu Feb 8 17:14:39 PST 2024</code></pre></div><br/></div></div></div></div></div></div><div id="41034166" class="c"><input type="checkbox" id="c-41034166" checked=""/><div class="controls bullet"><span class="by">blinkingled</span><span>|</span><a href="#41033795">prev</a><span>|</span><a href="#41041266">next</a><span>|</span><label class="collapse" for="c-41034166">[-]</label><label class="expand" for="c-41034166">[6 more]</label></div><br/><div class="children"><div class="content">Ok. But the good old push code to staging &#x2F; canary it before mainstream updates was a simpler way of solving the same problem.<p>Crowdstrike knows the computers they&#x27;re running on, it is trivial to implement a system where only few designated computers download and install the update and report metrics before the update controller decides to push it to next set.</div><br/><div id="41043695" class="c"><input type="checkbox" id="c-41043695" checked=""/><div class="controls bullet"><span class="by">rldjbpin</span><span>|</span><a href="#41034166">parent</a><span>|</span><a href="#41034292">next</a><span>|</span><label class="collapse" for="c-41043695">[-]</label><label class="expand" for="c-41043695">[1 more]</label></div><br/><div class="children"><div class="content">with the way they handled the debian crashing a little while ago, frankly they are happy to still go ahead with testing this way. still much better way to handle things than pushing to everybody at the same time.</div><br/></div></div><div id="41034292" class="c"><input type="checkbox" id="c-41034292" checked=""/><div class="controls bullet"><span class="by">Archelaos</span><span>|</span><a href="#41034166">parent</a><span>|</span><a href="#41043695">prev</a><span>|</span><a href="#41034350">next</a><span>|</span><label class="collapse" for="c-41034292">[-]</label><label class="expand" for="c-41034292">[3 more]</label></div><br/><div class="children"><div class="content">It would mitigate the problem, but not solve it. You can still imagine a condition that only occurs after the update has been rolled out everywhere. Furthermore, such a bug would still be extremely problematic for the concerned customers, even if not all of them were affected. In addition, it would be necessary to react very quickly in the case of zero-day vulnerabilities.</div><br/><div id="41034688" class="c"><input type="checkbox" id="c-41034688" checked=""/><div class="controls bullet"><span class="by">blinkingled</span><span>|</span><a href="#41034166">root</a><span>|</span><a href="#41034292">parent</a><span>|</span><a href="#41034413">next</a><span>|</span><label class="collapse" for="c-41034688">[-]</label><label class="expand" for="c-41034688">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I am not arguing against having the ability to deal with it quickly - I am saying canary&#x2F; staging helps you do exactly that. Because as we see in the case of Intel CPUs and Crowdstrike some problems or scale of some problems is best prevented.</div><br/></div></div><div id="41034413" class="c"><input type="checkbox" id="c-41034413" checked=""/><div class="controls bullet"><span class="by">tantalor</span><span>|</span><a href="#41034166">root</a><span>|</span><a href="#41034292">parent</a><span>|</span><a href="#41034688">prev</a><span>|</span><a href="#41034350">next</a><span>|</span><label class="collapse" for="c-41034413">[-]</label><label class="expand" for="c-41034413">[1 more]</label></div><br/><div class="children"><div class="content">(semantic argument warning)<p>&quot;Mitigation&quot; is dealing with an outage&#x2F;breakage after it occurs, to reduce the impact or get system healthy again.<p>You&#x27;re talking about &quot;prevention&quot; which keeps it from happening at all.<p>Canarying is generic approach to prevention, and should not be skipped.<p>Avoiding the risk entirely (eBPF) would also help prevent outage, but I think we&#x27;re deluding ourselves to say it &quot;solves&quot; the problem once and for all; systems will still go down due to bad deploys.</div><br/></div></div></div></div><div id="41034350" class="c"><input type="checkbox" id="c-41034350" checked=""/><div class="controls bullet"><span class="by">phartenfeller</span><span>|</span><a href="#41034166">parent</a><span>|</span><a href="#41034292">prev</a><span>|</span><a href="#41041266">next</a><span>|</span><label class="collapse" for="c-41034350">[-]</label><label class="expand" for="c-41034350">[1 more]</label></div><br/><div class="children"><div class="content">Why trust somebody else not messing up? With that in place for windows and crowdstrike billions of dollars would be saved and many lives not negatively impacted
...</div><br/></div></div></div></div><div id="41041266" class="c"><input type="checkbox" id="c-41041266" checked=""/><div class="controls bullet"><span class="by">3np</span><span>|</span><a href="#41034166">prev</a><span>|</span><a href="#41042784">next</a><span>|</span><label class="collapse" for="c-41041266">[-]</label><label class="expand" for="c-41041266">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The worst thing an eBPF program can do is to merely consume more resources than is desirable, such as CPU cycles and memory.<p>This is obviously not true. It might be the worst it can do, by itself, to the currently running kernel. It&#x27;s not the worst it can do to the machine or its user(s).<p>There are infinite harmful things an eBPF program can do. As can programs solely in user-space. There is a specific class of vulnerabilities being mitigated by moving code from kernel to BPF. That does not mean that eBPF programs are in general safe.</div><br/></div></div><div id="41042784" class="c"><input type="checkbox" id="c-41042784" checked=""/><div class="controls bullet"><span class="by">yubiox</span><span>|</span><a href="#41041266">prev</a><span>|</span><a href="#41038060">next</a><span>|</span><label class="collapse" for="c-41042784">[-]</label><label class="expand" for="c-41042784">[1 more]</label></div><br/><div class="children"><div class="content">Title reminds me of when microsoft promised no more UAEs back in 92.  They just renamed them to GPFs in windows 3.1.</div><br/></div></div><div id="41038060" class="c"><input type="checkbox" id="c-41038060" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#41042784">prev</a><span>|</span><a href="#41034575">next</a><span>|</span><label class="collapse" for="c-41038060">[-]</label><label class="expand" for="c-41038060">[1 more]</label></div><br/><div class="children"><div class="content">WebAssembly is a better choice for sandboxing kernel code. It has a full formal specification with a mechanized proof of type safety, many high-performance implementations, broad toolchain support, is targetable from many languages, and a capability security model.</div><br/></div></div><div id="41034575" class="c"><input type="checkbox" id="c-41034575" checked=""/><div class="controls bullet"><span class="by">nkozyra</span><span>|</span><a href="#41038060">prev</a><span>|</span><a href="#41036656">next</a><span>|</span><label class="collapse" for="c-41034575">[-]</label><label class="expand" for="c-41034575">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t do any kernel stuff so I&#x27;m out of my element, but doesn&#x27;t the fact that Crowdstrike &amp; Linux kernel eBPF already caused kernel crashes[1] sort of downplay the rosiness of the state of things?<p>[1]: <a href="https:&#x2F;&#x2F;access.redhat.com&#x2F;solutions&#x2F;7068083" rel="nofollow">https:&#x2F;&#x2F;access.redhat.com&#x2F;solutions&#x2F;7068083</a></div><br/><div id="41034963" class="c"><input type="checkbox" id="c-41034963" checked=""/><div class="controls bullet"><span class="by">guipsp</span><span>|</span><a href="#41034575">parent</a><span>|</span><a href="#41036656">next</a><span>|</span><label class="collapse" for="c-41034963">[-]</label><label class="expand" for="c-41034963">[3 more]</label></div><br/><div class="children"><div class="content">This is specifically addressed in the post you are replying to</div><br/><div id="41040351" class="c"><input type="checkbox" id="c-41040351" checked=""/><div class="controls bullet"><span class="by">nkozyra</span><span>|</span><a href="#41034575">root</a><span>|</span><a href="#41034963">parent</a><span>|</span><a href="#41036656">next</a><span>|</span><label class="collapse" for="c-41040351">[-]</label><label class="expand" for="c-41040351">[2 more]</label></div><br/><div class="children"><div class="content">Can you elaborate? What I see about Linux is that Crowdstrike was in the process of adopting eBPF which is ostensibly immune to kernel panics, but that issue shows their eBPF implementation specifically causing a kernel panic.</div><br/><div id="41040750" class="c"><input type="checkbox" id="c-41040750" checked=""/><div class="controls bullet"><span class="by">olddustytrail</span><span>|</span><a href="#41034575">root</a><span>|</span><a href="#41040351">parent</a><span>|</span><a href="#41036656">next</a><span>|</span><label class="collapse" for="c-41040750">[-]</label><label class="expand" for="c-41040750">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the elaboration is that the same link you posted is included in the article you&#x27;re supposed to have just read.</div><br/></div></div></div></div></div></div></div></div><div id="41036656" class="c"><input type="checkbox" id="c-41036656" checked=""/><div class="controls bullet"><span class="by">lazycog512</span><span>|</span><a href="#41034575">prev</a><span>|</span><a href="#41034321">next</a><span>|</span><label class="collapse" for="c-41036656">[-]</label><label class="expand" for="c-41036656">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The major difference between a thing that might go wrong and a thing that cannot possibly go wrong is that when a thing that cannot possibly go wrong goes wrong it usually turns out to be impossible to get at and repair.&quot;<p>- Douglas Adams</div><br/></div></div><div id="41034321" class="c"><input type="checkbox" id="c-41034321" checked=""/><div class="controls bullet"><span class="by">xyzzy123</span><span>|</span><a href="#41036656">prev</a><span>|</span><a href="#41037438">next</a><span>|</span><label class="collapse" for="c-41034321">[-]</label><label class="expand" for="c-41034321">[2 more]</label></div><br/><div class="children"><div class="content">So many problems though! including commercial monocultures, lack of update consent, blast radius issues, etc etc. There&#x27;s a commons in our pockets but that is very difficult to regulate for. The will keep putting the gun to your head until you keep choosing the monoculture.</div><br/><div id="41034433" class="c"><input type="checkbox" id="c-41034433" checked=""/><div class="controls bullet"><span class="by">shahahqq</span><span>|</span><a href="#41034321">parent</a><span>|</span><a href="#41037438">next</a><span>|</span><label class="collapse" for="c-41034433">[-]</label><label class="expand" for="c-41034433">[1 more]</label></div><br/><div class="children"><div class="content">worrisome indeed that now the world knows how many users are affected by crowdstrike so the bad guys just need to poke deeper there</div><br/></div></div></div></div><div id="41037438" class="c"><input type="checkbox" id="c-41037438" checked=""/><div class="controls bullet"><span class="by">tgtweak</span><span>|</span><a href="#41034321">prev</a><span>|</span><a href="#41033801">next</a><span>|</span><label class="collapse" for="c-41037438">[-]</label><label class="expand" for="c-41037438">[1 more]</label></div><br/><div class="children"><div class="content">Even if Microsoft rolls out eBPF and mainstreams it - it will be years before everything is ported over and it still won&#x27;t address legacy windows versions (which appear to be a good chunk of what was impacted).<p>It&#x27;s a move in the right direction but it probably won&#x27;t fully mitigate issues like this for another 5+ years.</div><br/></div></div><div id="41033801" class="c"><input type="checkbox" id="c-41033801" checked=""/><div class="controls bullet"><span class="by">usrme</span><span>|</span><a href="#41037438">prev</a><span>|</span><a href="#41036118">next</a><span>|</span><label class="collapse" for="c-41033801">[-]</label><label class="expand" for="c-41033801">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone know how far along the eBPF implementation for Windows actually is? In the sense that it could start feasibly replacing existing kernel drivers.</div><br/></div></div><div id="41036118" class="c"><input type="checkbox" id="c-41036118" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#41033801">prev</a><span>|</span><a href="#41034984">next</a><span>|</span><label class="collapse" for="c-41036118">[-]</label><label class="expand" for="c-41036118">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t buy it... didn&#x27;t a bug from RedHat + Crowdstrike have a similar panic issue?  I understand in that case it was because of RedHat, but still.  I don&#x27;t think this, by itself will change much.</div><br/></div></div><div id="41034984" class="c"><input type="checkbox" id="c-41034984" checked=""/><div class="controls bullet"><span class="by">Yawrehto</span><span>|</span><a href="#41036118">prev</a><span>|</span><a href="#41034461">next</a><span>|</span><label class="collapse" for="c-41034984">[-]</label><label class="expand" for="c-41034984">[2 more]</label></div><br/><div class="children"><div class="content">1. How does eBPF solve this? It makes it more difficult, sure, but it&#x27;ll almost always be <i>possible</i> to cause a crash, if you try hard enough.
2. More importantly, the problem is rarely fixable by changing technology, because typically, problems are caused by people and their connections: social&#x2F;corporate pressures, profit-seeking, mental health being treated as unimportant, et cetera. eBPF can&#x27;t fix those, and as long as corporations have social structures that penalize thoroughness and caution, and incentivize getting &#x27;the most stuff&#x27; done, this will persist as a problem.</div><br/><div id="41035094" class="c"><input type="checkbox" id="c-41035094" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41034984">parent</a><span>|</span><a href="#41034461">next</a><span>|</span><label class="collapse" for="c-41035094">[-]</label><label class="expand" for="c-41035094">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;ll almost always be possible to cause a crash, if you try hard enough.<p>If you think you know a way to crash the Linux kernel by loading and running an eBPF program, you should report a bug.</div><br/></div></div></div></div><div id="41034461" class="c"><input type="checkbox" id="c-41034461" checked=""/><div class="controls bullet"><span class="by">twen_ty</span><span>|</span><a href="#41034984">prev</a><span>|</span><a href="#41036344">next</a><span>|</span><label class="collapse" for="c-41034461">[-]</label><label class="expand" for="c-41034461">[5 more]</label></div><br/><div class="children"><div class="content">Can someone tell me what&#x27;s the advantage of eBPF over a user mode driver? The article makes it look it eBPF is have your cake and eat it too solution which is too good to be true? Can you run graphics drivers in eBPF for example?</div><br/><div id="41035179" class="c"><input type="checkbox" id="c-41035179" checked=""/><div class="controls bullet"><span class="by">bewo001</span><span>|</span><a href="#41034461">parent</a><span>|</span><a href="#41034665">next</a><span>|</span><label class="collapse" for="c-41035179">[-]</label><label class="expand" for="c-41035179">[2 more]</label></div><br/><div class="children"><div class="content">AFAIK, an ebpf function can only access memory it got handed as an argument or as result from a very limited number of kernel functions. Your function will not load if you don&#x27;t have boundary checks. Fighting the ebpf validator is a bit like fighting Rust&#x27;s borrow checker; annoying, at times it&#x27;s too conservative and rejects perfectly correct code, but it will protect you from panics. Loops will only be accepted if the validator can prove they&#x27;ll end in time; this means it can be a pain to make the validator to accept a loop. Also, ebpf is a processor-independent byte code, so vectorizing code is not possible (unless the byte code interpreter itself does it).<p>Given all its restrictions, I doubt something complex like a graphics driver would be possible. But then, I know nothing about graphics driver programming.</div><br/><div id="41035253" class="c"><input type="checkbox" id="c-41035253" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41034461">root</a><span>|</span><a href="#41035179">parent</a><span>|</span><a href="#41034665">next</a><span>|</span><label class="collapse" for="c-41035253">[-]</label><label class="expand" for="c-41035253">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Fighting the ebpf validator is a bit like fighting Rust&#x27;s borrow checker<p>I think this undersells how annoying it is. There&#x27;s a bit of an impedance mismatch. Typically you write code in C and compile it with clang to eBPF bytecode, which is then checked by the kernel&#x27;s eBPF verifier. But in some cases clang is smart enough to optimize away bounds checks, but the eBPF verifier isn&#x27;t smart enough to realize the bound checks aren&#x27;t needed. This requires manual hacking to trick clang into not optimizing things in a way that will confuse the verifier, and sometimes you just can&#x27;t get the C code to work and need to write things in eBPF bytecode by hand using inline assembly. All of these problems are massively compounded if you need to support several different kernel versions. At least with the Rust borrow checker there is a clearly defined set of rules you can follow.</div><br/></div></div></div></div><div id="41034665" class="c"><input type="checkbox" id="c-41034665" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#41034461">parent</a><span>|</span><a href="#41035179">prev</a><span>|</span><a href="#41034566">next</a><span>|</span><label class="collapse" for="c-41034665">[-]</label><label class="expand" for="c-41034665">[1 more]</label></div><br/><div class="children"><div class="content">This is the wiki. I haven&#x27;t kept up, but this isn&#x27;t a kernel module.<p>&quot;eBPF is a technology that can run programs in a privileged context such as the operating system kernel. It is the successor to the Berkeley Packet Filter (BPF, with the &quot;e&quot; originally meaning &quot;extended&quot;) filtering mechanism in Linux <i>and is also used in non-networking parts of the Linux kernel as well.</i>&quot;<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;EBPF" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;EBPF</a></div><br/></div></div><div id="41034566" class="c"><input type="checkbox" id="c-41034566" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41034461">parent</a><span>|</span><a href="#41034665">prev</a><span>|</span><a href="#41036344">next</a><span>|</span><label class="collapse" for="c-41034566">[-]</label><label class="expand" for="c-41034566">[1 more]</label></div><br/><div class="children"><div class="content">No, you can&#x27;t run arbitrary general-purpose programs in eBPF, and you cannot run graphics drivers in it. You generally can&#x27;t run programs with unprovably bounded loops in eBPF, and your program can interact with the kernel only through a small series of explicitly enumerated &quot;helpers&quot; (for any given type of eBPF program, you probably have about 20 of these in total).</div><br/></div></div></div></div><div id="41036344" class="c"><input type="checkbox" id="c-41036344" checked=""/><div class="controls bullet"><span class="by">dveeden2</span><span>|</span><a href="#41034461">prev</a><span>|</span><a href="#41034480">next</a><span>|</span><label class="collapse" for="c-41036344">[-]</label><label class="expand" for="c-41036344">[1 more]</label></div><br/><div class="children"><div class="content">So eBPF is giving us eBFP (enhanced Blue Friday Protection)?</div><br/></div></div><div id="41034480" class="c"><input type="checkbox" id="c-41034480" checked=""/><div class="controls bullet"><span class="by">WaitWaitWha</span><span>|</span><a href="#41036344">prev</a><span>|</span><a href="#41038413">next</a><span>|</span><label class="collapse" for="c-41034480">[-]</label><label class="expand" for="c-41034480">[2 more]</label></div><br/><div class="children"><div class="content">eBPF == extended Berkeley Packet Filter<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Berkeley_Packet_Filter" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Berkeley_Packet_Filter</a></div><br/><div id="41035775" class="c"><input type="checkbox" id="c-41035775" checked=""/><div class="controls bullet"><span class="by">kayge</span><span>|</span><a href="#41034480">parent</a><span>|</span><a href="#41038413">next</a><span>|</span><label class="collapse" for="c-41035775">[-]</label><label class="expand" for="c-41035775">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! This was not a familiar acronym to me... and after some digging[0] apparently it&#x27;s no longer an acronym:<p>&quot;BPF originally stood for Berkeley Packet Filter, but now that eBPF (extended BPF) can do so much more than packet filtering, the acronym no longer makes sense. eBPF is now considered a standalone term that doesn’t stand for anything.&quot;<p>[0] <a href="https:&#x2F;&#x2F;ebpf.io&#x2F;what-is-ebpf&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ebpf.io&#x2F;what-is-ebpf&#x2F;</a></div><br/></div></div></div></div><div id="41038413" class="c"><input type="checkbox" id="c-41038413" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#41034480">prev</a><span>|</span><a href="#41036877">next</a><span>|</span><label class="collapse" for="c-41038413">[-]</label><label class="expand" for="c-41038413">[1 more]</label></div><br/><div class="children"><div class="content">It is great that we need a linux kernel feature to be ported to Windows so we don’t have blue Fridays</div><br/></div></div><div id="41036877" class="c"><input type="checkbox" id="c-41036877" checked=""/><div class="controls bullet"><span class="by">egorfine</span><span>|</span><a href="#41038413">prev</a><span>|</span><a href="#41038641">next</a><span>|</span><label class="collapse" for="c-41036877">[-]</label><label class="expand" for="c-41036877">[3 more]</label></div><br/><div class="children"><div class="content">One option to prevent this is to not run corporate spyware. But I guess for some industries this isn&#x27;t an option.</div><br/><div id="41042412" class="c"><input type="checkbox" id="c-41042412" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#41036877">parent</a><span>|</span><a href="#41038641">next</a><span>|</span><label class="collapse" for="c-41042412">[-]</label><label class="expand" for="c-41042412">[2 more]</label></div><br/><div class="children"><div class="content">I don’t understand statements like this. You only need to have some employee install some malware (unintentionally or otherwise); and you have a data breach on your hands.</div><br/><div id="41043559" class="c"><input type="checkbox" id="c-41043559" checked=""/><div class="controls bullet"><span class="by">egorfine</span><span>|</span><a href="#41036877">root</a><span>|</span><a href="#41042412">parent</a><span>|</span><a href="#41038641">next</a><span>|</span><label class="collapse" for="c-41043559">[-]</label><label class="expand" for="c-41043559">[1 more]</label></div><br/><div class="children"><div class="content">I agree it&#x27;s much more scalable to have a vendor install a spyware on all your workstations and have a centralized data breach.</div><br/></div></div></div></div></div></div><div id="41038641" class="c"><input type="checkbox" id="c-41038641" checked=""/><div class="controls bullet"><span class="by">wiresurfer</span><span>|</span><a href="#41036877">prev</a><span>|</span><a href="#41042602">next</a><span>|</span><label class="collapse" for="c-41038641">[-]</label><label class="expand" for="c-41038641">[1 more]</label></div><br/><div class="children"><div class="content">Hey Brendan,<p>&gt; If your company is paying for commercial software that includes kernel drivers or kernel modules, you can make eBPF a requirement.<p>Windows soon, may still be atleast a year ahead. Would that be a fair statement? atleast being the operating keyword here.<p>Specifically in the context of network security software, for eBPF programs to be portable across windows&#x2F;linux, we would need MSFT to add a lot more hooks and expose internal kernel stucts. Hopefully via a common libbpf definition. 
Otherwise, I fear, having two versions of the same product, across two OSs would mean more secuirty and quality issues.<p>I guess the point I am trying to make is, we would get there, but we are more than a few years away.  
I would love to see something like cilium on vanilla windows for a Software defined Company Wide network. We can then start building enterprise network secutiry into it. Baby steps!<p>---<p>btw, your talks and blog posts about bpftools is godsent!</div><br/></div></div><div id="41042602" class="c"><input type="checkbox" id="c-41042602" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41038641">prev</a><span>|</span><label class="collapse" for="c-41042602">[-]</label><label class="expand" for="c-41042602">[1 more]</label></div><br/><div class="children"><div class="content"><i>In the future, computers will not crash due to bad software updates, even those updates that involve kernel code.</i><p>100% BS. Even if they don&#x27;t &quot;crash&quot; they will &quot;stop functioning as intended&quot; which is just the same. It&#x27;s absolutely disgusting how this industry is now using this one outage as a talking point to further their totalitarian agenda.<p>It reminds me of how Google went after adblockers with their new extension model that also promised more &quot;security&quot;. It&#x27;s time we realised what they&#x27;re really trying to do. In fact, I wonder whether this outage was not accidental after all.</div><br/></div></div></div></div></div></div></div></body></html>