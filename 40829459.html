<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719738059202" as="style"/><link rel="stylesheet" href="styles.css?v=1719738059202"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ethz.ch/en/news-and-events/eth-news/news/2024/06/researchers-at-eth-zurich-develop-the-fastest-possible-flow-algorithm.html">Researchers at ETH Zurich develop the fastest possible flow algorithm</a> <span class="domain">(<a href="https://ethz.ch">ethz.ch</a>)</span></div><div class="subtext"><span>jeroenvlek</span> | <span>35 comments</span></div><br/><div><div id="40833293" class="c"><input type="checkbox" id="c-40833293" checked=""/><div class="controls bullet"><span class="by">nabla9</span><span>|</span><a href="#40835459">next</a><span>|</span><label class="collapse" for="c-40833293">[-]</label><label class="expand" for="c-40833293">[8 more]</label></div><br/><div class="children"><div class="content">The algorithm is  near linear asymptotically <i>at the limit</i> when n -&gt; inf.<p>In the end of video they tell there is no way that any implementation of their algorithm gets close to beating existing algorithms in the real world.<p><a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;almost-linear-time-algorithms-for-maximum-flow-and-minimum-cost-flow&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;almost-linear-time-algorithms-...</a></div><br/><div id="40834054" class="c"><input type="checkbox" id="c-40834054" checked=""/><div class="controls bullet"><span class="by">optimalsolver</span><span>|</span><a href="#40833293">parent</a><span>|</span><a href="#40835819">next</a><span>|</span><label class="collapse" for="c-40834054">[-]</label><label class="expand" for="c-40834054">[5 more]</label></div><br/><div class="children"><div class="content">So it&#x27;s another galactic algorithm?<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Galactic_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Galactic_algorithm</a></div><br/><div id="40834344" class="c"><input type="checkbox" id="c-40834344" checked=""/><div class="controls bullet"><span class="by">poincaredisk</span><span>|</span><a href="#40833293">root</a><span>|</span><a href="#40834054">parent</a><span>|</span><a href="#40835136">next</a><span>|</span><label class="collapse" for="c-40834344">[-]</label><label class="expand" for="c-40834344">[3 more]</label></div><br/><div class="children"><div class="content">I imagine the point of this algorithm, like a lot of algorithm research, is to prove the upper bound of complexity for this problem. Not to be used in practice (despite what this article seem to suggest).<p>On a similar note, there&#x27;s a lot of work put into optimal matrix multiplication algorithm. We know the lower bound is N*2, the obvious upper bound is N*3, the best (complexity wise, not practical at all) current algorithm is N*2.37, but we don&#x27;t know how fast can it really get. Is it possible to write N*2 algorithm? We don&#x27;t know.</div><br/><div id="40835871" class="c"><input type="checkbox" id="c-40835871" checked=""/><div class="controls bullet"><span class="by">nnoremap2</span><span>|</span><a href="#40833293">root</a><span>|</span><a href="#40834344">parent</a><span>|</span><a href="#40835516">next</a><span>|</span><label class="collapse" for="c-40835871">[-]</label><label class="expand" for="c-40835871">[1 more]</label></div><br/><div class="children"><div class="content">I mean nobody is stopping me from writing an exponential time algorithm.</div><br/></div></div></div></div><div id="40835136" class="c"><input type="checkbox" id="c-40835136" checked=""/><div class="controls bullet"><span class="by">ddtaylor</span><span>|</span><a href="#40833293">root</a><span>|</span><a href="#40834054">parent</a><span>|</span><a href="#40834344">prev</a><span>|</span><a href="#40835819">next</a><span>|</span><label class="collapse" for="c-40835136">[-]</label><label class="expand" for="c-40835136">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for introducing a term and concept I was not familiar with.</div><br/></div></div></div></div><div id="40835819" class="c"><input type="checkbox" id="c-40835819" checked=""/><div class="controls bullet"><span class="by">torginus</span><span>|</span><a href="#40833293">parent</a><span>|</span><a href="#40834054">prev</a><span>|</span><a href="#40833971">next</a><span>|</span><label class="collapse" for="c-40835819">[-]</label><label class="expand" for="c-40835819">[1 more]</label></div><br/><div class="children"><div class="content">yeah, and another caveat tends to be with these kinds of cases is that you nearly need the absolute optimum - something that gets a 99% in 1% the time tends to be much more practical</div><br/></div></div></div></div><div id="40835459" class="c"><input type="checkbox" id="c-40835459" checked=""/><div class="controls bullet"><span class="by">josefrichter</span><span>|</span><a href="#40833293">prev</a><span>|</span><a href="#40835399">next</a><span>|</span><label class="collapse" for="c-40835459">[-]</label><label class="expand" for="c-40835459">[1 more]</label></div><br/><div class="children"><div class="content">I don’t want to spam, but I’ve been using rome2rio website&#x2F;app to find complex connections. They’re definitely not using this algorithm, but I’ve always been fascinated that you get complex results almost immediately. I don’t know how they do it, but for me it’s one of the most fascinating works on the internet. Great job. [I’m not affiliated with them in any way]</div><br/></div></div><div id="40835399" class="c"><input type="checkbox" id="c-40835399" checked=""/><div class="controls bullet"><span class="by">jpster</span><span>|</span><a href="#40835459">prev</a><span>|</span><a href="#40832673">next</a><span>|</span><label class="collapse" for="c-40835399">[-]</label><label class="expand" for="c-40835399">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A glance at the raw figures shows just how far we have come: until the turn of the millennium, no algorithm managed to compute faster than m1.5, where m stands for the number of connections in a network that the computer has to calculate, and just reading the network data once takes m time. In 2004, the computing speed required to solve the problem was successfully reduced to m1.33. Using Kyng’s algorithm, the “additional” computing time required to reach the solution after reading the network data is now negligible.<p>TFA didn’t describe Kyng’s breakthrough in terms of this mscore it considers so important. What’s up with that?</div><br/></div></div><div id="40832673" class="c"><input type="checkbox" id="c-40832673" checked=""/><div class="controls bullet"><span class="by">c-smile</span><span>|</span><a href="#40835399">prev</a><span>|</span><a href="#40835867">next</a><span>|</span><label class="collapse" for="c-40832673">[-]</label><label class="expand" for="c-40832673">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Almost-Linear-Time Algorithm<p>From O(mn) to O(m) ... thus excluding N (number of vertices) from computation ...<p>Too good to be true?</div><br/><div id="40833476" class="c"><input type="checkbox" id="c-40833476" checked=""/><div class="controls bullet"><span class="by">progbits</span><span>|</span><a href="#40832673">parent</a><span>|</span><a href="#40835867">next</a><span>|</span><label class="collapse" for="c-40833476">[-]</label><label class="expand" for="c-40833476">[3 more]</label></div><br/><div class="children"><div class="content">Constant factor so large it&#x27;s going to be slower than existing (asymptotically worse) algorithms on any practical inputs.<p>Still, a neat theoretical result.</div><br/><div id="40835309" class="c"><input type="checkbox" id="c-40835309" checked=""/><div class="controls bullet"><span class="by">8474_s</span><span>|</span><a href="#40832673">root</a><span>|</span><a href="#40833476">parent</a><span>|</span><a href="#40835867">next</a><span>|</span><label class="collapse" for="c-40835309">[-]</label><label class="expand" for="c-40835309">[2 more]</label></div><br/><div class="children"><div class="content">The constant factors could be optimized or
 even accelerated with special-purpose hardware.
There could be a simplification or even something
like reuse&#x2F;caching&#x2F;memoization that in real world
will reduce the constant factor significantly.</div><br/><div id="40835857" class="c"><input type="checkbox" id="c-40835857" checked=""/><div class="controls bullet"><span class="by">Jabbles</span><span>|</span><a href="#40832673">root</a><span>|</span><a href="#40835309">parent</a><span>|</span><a href="#40835867">next</a><span>|</span><label class="collapse" for="c-40835857">[-]</label><label class="expand" for="c-40835857">[1 more]</label></div><br/><div class="children"><div class="content">Maybe, but that would be a different research project.<p>The constant factors are currently so large that even multiple orders of magnitude speedups would not make this practical.</div><br/></div></div></div></div></div></div></div></div><div id="40835867" class="c"><input type="checkbox" id="c-40835867" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#40832673">prev</a><span>|</span><a href="#40833579">next</a><span>|</span><label class="collapse" for="c-40835867">[-]</label><label class="expand" for="c-40835867">[1 more]</label></div><br/><div class="children"><div class="content">I was hoping for some kind of evolutionary algorithm. Giving up optimality in exchange for being able to solve problem instances with billions of items would be worth it.</div><br/></div></div><div id="40833579" class="c"><input type="checkbox" id="c-40833579" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#40835867">prev</a><span>|</span><a href="#40832535">next</a><span>|</span><label class="collapse" for="c-40833579">[-]</label><label class="expand" for="c-40833579">[2 more]</label></div><br/><div class="children"><div class="content">Related: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31149038">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31149038</a> (40 comments)<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31675015">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31675015</a> (72 comments)</div><br/><div id="40835292" class="c"><input type="checkbox" id="c-40835292" checked=""/><div class="controls bullet"><span class="by">nothrowaways</span><span>|</span><a href="#40833579">parent</a><span>|</span><a href="#40832535">next</a><span>|</span><label class="collapse" for="c-40835292">[-]</label><label class="expand" for="c-40835292">[1 more]</label></div><br/><div class="children"><div class="content">2022</div><br/></div></div></div></div><div id="40832535" class="c"><input type="checkbox" id="c-40832535" checked=""/><div class="controls bullet"><span class="by">squarerootof-1</span><span>|</span><a href="#40833579">prev</a><span>|</span><a href="#40834246">next</a><span>|</span><label class="collapse" for="c-40832535">[-]</label><label class="expand" for="c-40832535">[3 more]</label></div><br/><div class="children"><div class="content">Where is the paper &#x2F; code for this?</div><br/><div id="40832547" class="c"><input type="checkbox" id="c-40832547" checked=""/><div class="controls bullet"><span class="by">styluss</span><span>|</span><a href="#40832535">parent</a><span>|</span><a href="#40834246">next</a><span>|</span><label class="collapse" for="c-40832547">[-]</label><label class="expand" for="c-40832547">[2 more]</label></div><br/><div class="children"><div class="content">First link in &quot;further information&quot;<p><a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;almost-linear-time-algorithms-for-maximum-flow-and-minimum-cost-flow&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;almost-linear-time-algorithms-...</a></div><br/><div id="40833248" class="c"><input type="checkbox" id="c-40833248" checked=""/><div class="controls bullet"><span class="by">elwell</span><span>|</span><a href="#40832535">root</a><span>|</span><a href="#40832547">parent</a><span>|</span><a href="#40834246">next</a><span>|</span><label class="collapse" for="c-40833248">[-]</label><label class="expand" for="c-40833248">[1 more]</label></div><br/><div class="children"><div class="content">In 2030, this algorithm will be expected to optimally solve some leetcode interview question.</div><br/></div></div></div></div></div></div><div id="40834246" class="c"><input type="checkbox" id="c-40834246" checked=""/><div class="controls bullet"><span class="by">ziofill</span><span>|</span><a href="#40832535">prev</a><span>|</span><a href="#40832814">next</a><span>|</span><label class="collapse" for="c-40834246">[-]</label><label class="expand" for="c-40834246">[1 more]</label></div><br/><div class="children"><div class="content">damn you constant factors [shakes fist in the air]</div><br/></div></div><div id="40832814" class="c"><input type="checkbox" id="c-40832814" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40834246">prev</a><span>|</span><a href="#40834525">next</a><span>|</span><label class="collapse" for="c-40832814">[-]</label><label class="expand" for="c-40832814">[9 more]</label></div><br/><div class="children"><div class="content">The abstract just says the time is m^(1+o(1))... anyone know if a more specific bound is stated anywhere?</div><br/><div id="40833291" class="c"><input type="checkbox" id="c-40833291" checked=""/><div class="controls bullet"><span class="by">Zacharias030</span><span>|</span><a href="#40832814">parent</a><span>|</span><a href="#40833592">next</a><span>|</span><label class="collapse" for="c-40833291">[-]</label><label class="expand" for="c-40833291">[2 more]</label></div><br/><div class="children"><div class="content">Note that this is a „small o“, so o(1) captures terms that „divided by 1“ go to zero as m to infinity.<p><a href="https:&#x2F;&#x2F;de.m.wikipedia.org&#x2F;wiki&#x2F;Landau-Symbole" rel="nofollow">https:&#x2F;&#x2F;de.m.wikipedia.org&#x2F;wiki&#x2F;Landau-Symbole</a></div><br/><div id="40833557" class="c"><input type="checkbox" id="c-40833557" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#40832814">root</a><span>|</span><a href="#40833291">parent</a><span>|</span><a href="#40833592">next</a><span>|</span><label class="collapse" for="c-40833557">[-]</label><label class="expand" for="c-40833557">[1 more]</label></div><br/><div class="children"><div class="content">English Wikipedia has an explanation, too: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Big_O_notation#Little-o_notation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Big_O_notation#Little-o_notati...</a></div><br/></div></div></div></div><div id="40833592" class="c"><input type="checkbox" id="c-40833592" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#40832814">parent</a><span>|</span><a href="#40833291">prev</a><span>|</span><a href="#40833927">next</a><span>|</span><label class="collapse" for="c-40833592">[-]</label><label class="expand" for="c-40833592">[3 more]</label></div><br/><div class="children"><div class="content">It means that you can choose constants such that the algorithm is as close to O(m) as you&#x27;d like.<p>In other words, it&#x27;s an algorithm scheme that allows you to get an algorithm running in time O(m^ɛ) for any ɛ&gt;1.</div><br/><div id="40833797" class="c"><input type="checkbox" id="c-40833797" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40832814">root</a><span>|</span><a href="#40833592">parent</a><span>|</span><a href="#40833927">next</a><span>|</span><label class="collapse" for="c-40833797">[-]</label><label class="expand" for="c-40833797">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, where&#x27;s that stated?  I&#x27;m pretty doubtful of that claim because if that&#x27;s what they meant they would say that -- they&#x27;d say it was O(m^(1+ɛ)), that would be well-understood notation.  But what they wrote is that it&#x27;s O(m^(1+o(1))), which, read as written, means it&#x27;s a single bound that they&#x27;re just not being very specific about.<p>I&#x27;m not asking for help decoding the notation; I&#x27;m asking for if anyone knows what the more detailed bound is that O(m^(1+o(1))) is abstracting.</div><br/><div id="40834430" class="c"><input type="checkbox" id="c-40834430" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#40832814">root</a><span>|</span><a href="#40833797">parent</a><span>|</span><a href="#40833927">next</a><span>|</span><label class="collapse" for="c-40834430">[-]</label><label class="expand" for="c-40834430">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because even the ACM link is an abbreviation of the actual paper.<p>Preprint at <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2203.00671" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2203.00671</a><p>(Pages 68-75 build up the full details of the bound, which looks something like Õ(mκ⁻²α⁻²ϵ⁻¹). There are enough details over the preceding dozens of pages that I can&#x27;t tell at a glance exactly what all the variables stand for.)<p>Technically this captures any logarithmic factors, such as exp(O(log^(7&#x2F;8) m log log m)) as presented on page 75).</div><br/></div></div></div></div></div></div><div id="40833927" class="c"><input type="checkbox" id="c-40833927" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#40832814">parent</a><span>|</span><a href="#40833592">prev</a><span>|</span><a href="#40834525">next</a><span>|</span><label class="collapse" for="c-40833927">[-]</label><label class="expand" for="c-40833927">[3 more]</label></div><br/><div class="children"><div class="content">That is the specific bound. The little o is a function that aproaches 0 as n approaches infinity, referred to as asymptotically negligible.</div><br/><div id="40834624" class="c"><input type="checkbox" id="c-40834624" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40832814">root</a><span>|</span><a href="#40833927">parent</a><span>|</span><a href="#40834525">next</a><span>|</span><label class="collapse" for="c-40834624">[-]</label><label class="expand" for="c-40834624">[2 more]</label></div><br/><div class="children"><div class="content">I know what the notation means.  I&#x27;m wondering what the actual function is.  Using little o is a way of abstracting that information away.</div><br/><div id="40835865" class="c"><input type="checkbox" id="c-40835865" checked=""/><div class="controls bullet"><span class="by">Rarebox</span><span>|</span><a href="#40832814">root</a><span>|</span><a href="#40834624">parent</a><span>|</span><a href="#40834525">next</a><span>|</span><label class="collapse" for="c-40835865">[-]</label><label class="expand" for="c-40835865">[1 more]</label></div><br/><div class="children"><div class="content">I could be wrong but I think many times the researchers don&#x27;t care about the exact function. It could be something like 1&#x2F;log(log(n)) .</div><br/></div></div></div></div></div></div></div></div><div id="40834525" class="c"><input type="checkbox" id="c-40834525" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#40832814">prev</a><span>|</span><a href="#40833055">next</a><span>|</span><label class="collapse" for="c-40834525">[-]</label><label class="expand" for="c-40834525">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes I think we have lost the plot completely with complexity as a metric. Increasingly we are seeing algorithms which have optimized the complexity metric to an insane degree but which aren&#x27;t actually useful.</div><br/></div></div><div id="40835314" class="c"><input type="checkbox" id="c-40835314" checked=""/><div class="controls bullet"><span class="by">imvetri</span><span>|</span><a href="#40833055">prev</a><span>|</span><label class="collapse" for="c-40835314">[-]</label><label class="expand" for="c-40835314">[2 more]</label></div><br/><div class="children"><div class="content">My words.<p>Solving a problem for computational efficiency is pointless.<p>Wy<p>Take a look at AI neural networks where they blast computational resources.<p>May be<p>One day this might help.<p>Reply to myself<p>Appreciate this post. And get back to writing.<p>Appreciation<p>Out of so many other less interesting post, this post caught my attention and nowhere it spoke about how it works, most importantly why it is needed.</div><br/><div id="40835318" class="c"><input type="checkbox" id="c-40835318" checked=""/><div class="controls bullet"><span class="by">imvetri</span><span>|</span><a href="#40835314">parent</a><span>|</span><label class="collapse" for="c-40835318">[-]</label><label class="expand" for="c-40835318">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not expert, saying out of experience</div><br/></div></div></div></div></div></div></div></div></div></body></html>