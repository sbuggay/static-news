<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694422870094" as="style"/><link rel="stylesheet" href="styles.css?v=1694422870094"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://benhoyt.com/writings/awk-make/">The Awk book’s 60-line version of Make</a> <span class="domain">(<a href="https://benhoyt.com">benhoyt.com</a>)</span></div><div class="subtext"><span>nalgeon</span> | <span>35 comments</span></div><br/><div><div id="37461585" class="c"><input type="checkbox" id="c-37461585" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37464420">next</a><span>|</span><label class="collapse" for="c-37461585">[-]</label><label class="expand" for="c-37461585">[3 more]</label></div><br/><div class="children"><div class="content">Ben notes that Kernighan regrets the way local variables are handled in Awk.<p>I patched GNU Awk to have a @let extension that gives you scoped locals (usable in functions as well as in BEGIN&#x2F;END blocks):<p><pre><code>  $ egawk  &#x27;BEGIN { x = 3; print x; @let (x = 4, y) { print x } print x }&#x27;
  3
  4
  3
</code></pre>
@ is used because there is at least one other existing extension which is like that: @include.<p><a href="https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;egawk&#x2F;about&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;egawk&#x2F;about&#x2F;</a><p>This was rejected by the GNU Awk project, though. I was encouraged to make a fork and give it some kind of different name, so I did that.</div><br/><div id="37462459" class="c"><input type="checkbox" id="c-37462459" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#37461585">parent</a><span>|</span><a href="#37464420">next</a><span>|</span><label class="collapse" for="c-37462459">[-]</label><label class="expand" for="c-37462459">[2 more]</label></div><br/><div class="children"><div class="content">Did they cite a reason that sounded reasonable? Like the particular implementation breaks some design principle they want to stick to or something? Did they suggest it might be acceptable some other way or in some other form?<p>It&#x27;s curious because gawk cannot for one second claim something like needing to stick to some legacy standard, not with a straight face.</div><br/><div id="37463353" class="c"><input type="checkbox" id="c-37463353" checked=""/><div class="controls bullet"><span class="by">Joeri</span><span>|</span><a href="#37461585">root</a><span>|</span><a href="#37462459">parent</a><span>|</span><a href="#37464420">next</a><span>|</span><label class="collapse" for="c-37463353">[-]</label><label class="expand" for="c-37463353">[1 more]</label></div><br/><div class="children"><div class="content">If I were the gawk maintainer I would be unwilling to take on features by default. It is widely used infrastructure and keeping out bugs is far more important than taking on features. If the userbase keeps asking for the same feature over and over, at that point it would be up for consideration, but no sooner.</div><br/></div></div></div></div></div></div><div id="37464420" class="c"><input type="checkbox" id="c-37464420" checked=""/><div class="controls bullet"><span class="by">jph00</span><span>|</span><a href="#37461585">prev</a><span>|</span><a href="#37461101">next</a><span>|</span><label class="collapse" for="c-37464420">[-]</label><label class="expand" for="c-37464420">[1 more]</label></div><br/><div class="children"><div class="content">awk and sed are cool, but whenever someone tells me they&#x27;re interested in learning them, I always redirect them to learn perl&#x27;s `-n` and `-p` flags instead, particularly with `-la` added. This gives you, basically, a superset of sed and awk, which makes many things easier to express, often resulting in clearer and more concise code.<p>For those who have taken this advice, they&#x27;ve always told me later they&#x27;re really glad they did so, and generally express surprise that this isn&#x27;t more widely known.<p>(If you already know awk and sed well, then you mightn&#x27;t view learning perl in addition worth the effort -- I&#x27;m not sure either way. This advice is for people that currently are not strong users of either.)</div><br/></div></div><div id="37461101" class="c"><input type="checkbox" id="c-37461101" checked=""/><div class="controls bullet"><span class="by">version_five</span><span>|</span><a href="#37464420">prev</a><span>|</span><a href="#37464426">next</a><span>|</span><label class="collapse" for="c-37461101">[-]</label><label class="expand" for="c-37461101">[20 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a big awk fan but I&#x27;m not sold on this. The awk program is not very readable- I think that&#x27;s fine for a dense one-liner, I&#x27;m not really sure it carries over to a 60 line script. I think for something like this I&#x27;d prefer a bash script, maybe with awk invoked somewhere, that would be much easier to understand at a glance.<p>Is there something in the awk script that makes it advantageous over a shell script?<p>Edit: I hadn&#x27;t read the author&#x27;s conclusion yet when I posted, he agrees<p><pre><code>  I consider AWK amazing, but I think it should remain where it excels: for exploratory data analysis and for one-liner data extraction scripts</code></pre></div><br/><div id="37462785" class="c"><input type="checkbox" id="c-37462785" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#37461101">parent</a><span>|</span><a href="#37461170">next</a><span>|</span><label class="collapse" for="c-37462785">[-]</label><label class="expand" for="c-37462785">[1 more]</label></div><br/><div class="children"><div class="content">A while ago I wrote a program to renumber TRS-80 Model 100 BASIC code in awk. Then re-wrote it in bash (pure bash, no sed&#x2F;grep&#x2F;cut&#x2F;tr&#x2F;awk&#x2F;bc&#x2F;etc), and the two are practically identical. That suprised me just how practically identical they wwere in the end.<p>awk is like a hidden miracle of utility just sitting there unused on every machine since the dawn of time.<p>Normally if you want something to be ultra portable, you write it in sh or ksh, (though by now, bash would be ok, I mean there is bash for xenix), but to get the most out of ksh or bash, you have to use all the available features and tricks that are powerful and useful but NOT readable. 50% of the logic of a given line of code is not spelled out in the keywords but in arcane brace expansion and word splitting rules.<p>But every system that might have some version of bash or ksh or plain sh, <i>always</i> has awk too, and even the oldest plain not-gnu awk is a real, &quot;normal&quot;, more or less straighforward explicit programming language compared to bash. Not all that much more pawerful, but more readable and more straightforward to write. Things are done with functions that take parameters and do things to the parameters, not with special syntax that does magic transformations of variables which you then parlay into various uses.<p>Everyone uses perl&#x2F;python&#x2F;ruby&#x2F;php&#x2F;whatever when the project goes beyond bash scope, but they all need to be installed and need to be a particular version, and almost always need some library of modules as well, and every python script breaks every other year or on every other new platform. But awk is already there, even on ancient obscure systems that absolutely can not have the current version of python or ruby and all the gems.<p>I don&#x27;t use it for current day to day stuff either, there&#x27;s too many common things today that it has no knowledge of. I don&#x27;t want to try to do https transactions or parse xml in awk. I&#x27;m just saying it&#x27;s interesting or somehow notable how generically useful awk is pretty much just like bash or python, installed everywhere already, and almost utterly unused.</div><br/></div></div><div id="37461170" class="c"><input type="checkbox" id="c-37461170" checked=""/><div class="controls bullet"><span class="by">Avshalom</span><span>|</span><a href="#37461101">parent</a><span>|</span><a href="#37462785">prev</a><span>|</span><a href="#37464428">next</a><span>|</span><label class="collapse" for="c-37461170">[-]</label><label class="expand" for="c-37461170">[9 more]</label></div><br/><div class="children"><div class="content">Well I think generally a 60 line program fits in that spot of &quot;write once, read never, start from scratch if it ever turns out to be inadequate&quot;<p>... also known as the APL Zone</div><br/><div id="37461731" class="c"><input type="checkbox" id="c-37461731" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37461170">parent</a><span>|</span><a href="#37464428">next</a><span>|</span><label class="collapse" for="c-37461731">[-]</label><label class="expand" for="c-37461731">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not dead set against it, but if there was any mistake or bugs I don&#x27;t know how you&#x27;d find them and fix them in that approach</div><br/><div id="37462210" class="c"><input type="checkbox" id="c-37462210" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37461731">parent</a><span>|</span><a href="#37464428">next</a><span>|</span><label class="collapse" for="c-37462210">[-]</label><label class="expand" for="c-37462210">[7 more]</label></div><br/><div class="children"><div class="content">By checking the correctness of the outputs, which you need to do anyway?</div><br/><div id="37463119" class="c"><input type="checkbox" id="c-37463119" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37462210">parent</a><span>|</span><a href="#37462999">next</a><span>|</span><label class="collapse" for="c-37463119">[-]</label><label class="expand" for="c-37463119">[3 more]</label></div><br/><div class="children"><div class="content">Okay, so the first dev writes 60 lines of indecipherable code, runs some sample invocations, looks at the output, says it looks good. A few months later, someone - maybe the original dev, maybe some other sucker - notices that in some edge case the code misbehaves. Now what? (Obviously, any answer that involves &quot;don&#x27;t write code with bugs&quot; or &quot;write perfect tests&quot; is a nonstarter)</div><br/><div id="37463250" class="c"><input type="checkbox" id="c-37463250" checked=""/><div class="controls bullet"><span class="by">HALtheWise</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37463119">parent</a><span>|</span><a href="#37462999">next</a><span>|</span><label class="collapse" for="c-37463250">[-]</label><label class="expand" for="c-37463250">[2 more]</label></div><br/><div class="children"><div class="content">If we&#x27;re going with the &quot;start from scratch if it ever proves inadequate&quot; philosophy, then the person who notices the misbehavior looks at the original code, sees that it&#x27;s written in some obscure language, is undecipherable, but also is only 60 lines long, and decides that it will probably be simpler to make a new (short) implementation in their <i>own</i> favorite language that correctly handles both the original use case and their new requirement. The key insight is that given how much easier it is to write fresh code than understand old stuff, they could very well be correct in that guess, and the end result is a single piece of small clean code, rather than a simple core with layers of patches glued on top.<p>In this <i>particular</i> case, we&#x27;re talking about a &quot;make&quot; replacement, so testing the new implementation can be done by simply running &quot;make all&quot; for the project. If it passes, then the new implementation must be identical to the old one in all the ways that <i>actually matter</i> for the project at hand. In all likelihood, for a simple program like this, fixing one bug will also silently fix others because the new architecture is probably better than the old one.</div><br/><div id="37464514" class="c"><input type="checkbox" id="c-37464514" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37463250">parent</a><span>|</span><a href="#37462999">next</a><span>|</span><label class="collapse" for="c-37464514">[-]</label><label class="expand" for="c-37464514">[1 more]</label></div><br/><div class="children"><div class="content">I actually really like this approach, and have been thinking about this in regards to coding with an LLM - for a sufficiently simple program (and assuming no security concerns), once you trust your test suite, you should trust AI generated code that passes it. And then if requirements change, you should be able to amend the test cases, rerun the AI until it passes all tests and linters, maybe give the code a quick glance, and be on with your life.</div><br/></div></div></div></div></div></div><div id="37462999" class="c"><input type="checkbox" id="c-37462999" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37462210">parent</a><span>|</span><a href="#37463119">prev</a><span>|</span><a href="#37462624">next</a><span>|</span><label class="collapse" for="c-37462999">[-]</label><label class="expand" for="c-37462999">[1 more]</label></div><br/><div class="children"><div class="content">Not only is fixing more difficult, but also looking for likely weaknesses (and thus the inputs and outputs to focus on for testing).</div><br/></div></div><div id="37462624" class="c"><input type="checkbox" id="c-37462624" checked=""/><div class="controls bullet"><span class="by">edgyquant</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37462210">parent</a><span>|</span><a href="#37462999">prev</a><span>|</span><a href="#37464428">next</a><span>|</span><label class="collapse" for="c-37462624">[-]</label><label class="expand" for="c-37462624">[2 more]</label></div><br/><div class="children"><div class="content">The point is the “and fix them”</div><br/></div></div></div></div></div></div></div></div><div id="37464428" class="c"><input type="checkbox" id="c-37464428" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#37461101">parent</a><span>|</span><a href="#37461170">prev</a><span>|</span><a href="#37461502">next</a><span>|</span><label class="collapse" for="c-37464428">[-]</label><label class="expand" for="c-37464428">[1 more]</label></div><br/><div class="children"><div class="content">It seems pretty readable to me, in particular the &quot;update&quot; function parses as JavaScript if you fix the implicit string concatenation (template literals or +) and replace the # comments with &#x2F;&#x2F;. I&#x27;m actually surprised JavaScript is so similar to awk; it feels like a descendant language tbh.</div><br/></div></div><div id="37461502" class="c"><input type="checkbox" id="c-37461502" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#37461101">parent</a><span>|</span><a href="#37464428">prev</a><span>|</span><a href="#37461693">next</a><span>|</span><label class="collapse" for="c-37461502">[-]</label><label class="expand" for="c-37461502">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The awk program is not very readable<p>What do you find hard to read about it? If you know what <i>make</i> does, I think it is fairly easy to read, even for those who don’t know awk at all, but do know the Unix shell (to recognize ‘ls -t’) and C (both of which, probably the audience for this book knew, given that the book is from 1988)<p>&gt; I think for something like this I&#x27;d prefer a bash script<p>But would it be easier to read? I doubt see why it would.</div><br/><div id="37461762" class="c"><input type="checkbox" id="c-37461762" checked=""/><div class="controls bullet"><span class="by">mauvehaus</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37461502">parent</a><span>|</span><a href="#37461693">next</a><span>|</span><label class="collapse" for="c-37461762">[-]</label><label class="expand" for="c-37461762">[3 more]</label></div><br/><div class="children"><div class="content">Bash <i>also</i> would have been an unlikely choice for a book published in 1988, considering it wasn&#x27;t released until 1989 (Per Wikipedia).</div><br/><div id="37462863" class="c"><input type="checkbox" id="c-37462863" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37461762">parent</a><span>|</span><a href="#37461693">next</a><span>|</span><label class="collapse" for="c-37462863">[-]</label><label class="expand" for="c-37462863">[2 more]</label></div><br/><div class="children"><div class="content">It would have been ksh, which was the bash of the day, as in, the more featureful sh-compatible sh-superset.<p>But a bash or ksh script would have been less readable than awk.<p>bash (or ksh88 or ksh93) is powrful and useful but not readable if you&#x27;re actually using the powerful useful features.<p>In bash, a lot of functionality comes in the form of brace expansions and word splitting, basically abusing the command parser to get results there is no actual function for. In awk and any other more normal programming language, those same features come in the form of an explicit function to do that thing.</div><br/><div id="37463970" class="c"><input type="checkbox" id="c-37463970" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#37461101">root</a><span>|</span><a href="#37462863">parent</a><span>|</span><a href="#37461693">next</a><span>|</span><label class="collapse" for="c-37463970">[-]</label><label class="expand" for="c-37463970">[1 more]</label></div><br/><div class="children"><div class="content">&gt;In bash, a lot of functionality comes in the form of brace expansions and word splitting, basically abusing the command parser to get results there is no actual function for. In awk and any other more normal programming language, those same features come in the form of an explicit function to do that thing.<p>Right. That&#x27;s one of the reasons why the man page for bash is so long. IIRC, going way back, even the page for plain sh was long, for the same reason.</div><br/></div></div></div></div></div></div></div></div><div id="37461693" class="c"><input type="checkbox" id="c-37461693" checked=""/><div class="controls bullet"><span class="by">mbivert</span><span>|</span><a href="#37461101">parent</a><span>|</span><a href="#37461502">prev</a><span>|</span><a href="#37462987">next</a><span>|</span><label class="collapse" for="c-37461693">[-]</label><label class="expand" for="c-37461693">[1 more]</label></div><br/><div class="children"><div class="content">I think it should be appreciated in context: it&#x27;s a good way to teach both awk(1) and make(1) to someone new to UNIX. It also demonstrates how to use awk(1) for prototyping, which IMO is a good programming habit to &quot;develop&quot;: it forces to focus on the essential, and not to unnecessarily overthink.</div><br/></div></div><div id="37462987" class="c"><input type="checkbox" id="c-37462987" checked=""/><div class="controls bullet"><span class="by">rottc0dd</span><span>|</span><a href="#37461101">parent</a><span>|</span><a href="#37461693">prev</a><span>|</span><a href="#37461999">next</a><span>|</span><label class="collapse" for="c-37462987">[-]</label><label class="expand" for="c-37462987">[1 more]</label></div><br/><div class="children"><div class="content">Bash would really be bad idea if it is going to use bash stitching so many gnu utils for this kind of job.<p>I once had to rewrite a bash script into awk[1] that is big enough and it made the program more readable and the total time execution came down from 12 mins to less than 1 second.<p>I think maybe the original bash script would have written badly, (each util command will invoke it&#x27;s own process and it has to piped to others instead of using awk which will be running in a single process).<p>[1] - <a href="https:&#x2F;&#x2F;github.com&#x2F;berry-thawson&#x2F;diff2html&#x2F;blob&#x2F;master&#x2F;diff2html.sh">https:&#x2F;&#x2F;github.com&#x2F;berry-thawson&#x2F;diff2html&#x2F;blob&#x2F;master&#x2F;diff2...</a></div><br/></div></div><div id="37461999" class="c"><input type="checkbox" id="c-37461999" checked=""/><div class="controls bullet"><span class="by">pushedx</span><span>|</span><a href="#37461101">parent</a><span>|</span><a href="#37462987">prev</a><span>|</span><a href="#37461387">next</a><span>|</span><label class="collapse" for="c-37461999">[-]</label><label class="expand" for="c-37461999">[1 more]</label></div><br/><div class="children"><div class="content">Writing this make program in bash would invovle even more difficult to read hacks, as bash also does not support multidimensional arrays.</div><br/></div></div><div id="37461387" class="c"><input type="checkbox" id="c-37461387" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#37461101">parent</a><span>|</span><a href="#37461999">prev</a><span>|</span><a href="#37464426">next</a><span>|</span><label class="collapse" for="c-37461387">[-]</label><label class="expand" for="c-37461387">[1 more]</label></div><br/><div class="children"><div class="content">&gt; for exploratory data analysis and for one-liner data extraction scripts<p>I think both you and the author just don&#x27;t like AWK if that&#x27;s the takeaway. What you&#x27;re describing is literally 1% of the AWK language -- like you don&#x27;t have to like it, it&#x27;s weird in many respects but you&#x27;re treating AWK like it&#x27;s jq when it&#x27;s actually closer to like a Perl-Lite&#x2F;Bash mix. An AWK focused on just those use-cases would look <i>very</i> different.<p>One of my favorite resources on AWK: <a href="https:&#x2F;&#x2F;www.grymoire.com&#x2F;Unix&#x2F;Awk.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.grymoire.com&#x2F;Unix&#x2F;Awk.html</a></div><br/></div></div></div></div><div id="37464426" class="c"><input type="checkbox" id="c-37464426" checked=""/><div class="controls bullet"><span class="by">greyman</span><span>|</span><a href="#37461101">prev</a><span>|</span><a href="#37462764">next</a><span>|</span><label class="collapse" for="c-37464426">[-]</label><label class="expand" for="c-37464426">[1 more]</label></div><br/><div class="children"><div class="content">I must admit that I use awk only via GPT-4, which will write me the one-liner I need and I just run it. I somewhat cannot remember the syntax, provided I use the tool only occasionally.</div><br/></div></div><div id="37462764" class="c"><input type="checkbox" id="c-37462764" checked=""/><div class="controls bullet"><span class="by">mtillman</span><span>|</span><a href="#37464426">prev</a><span>|</span><a href="#37462235">next</a><span>|</span><label class="collapse" for="c-37462764">[-]</label><label class="expand" for="c-37462764">[1 more]</label></div><br/><div class="children"><div class="content">I wan’t aware that an updated book was on the way. Pre-ordered it immediately. It&#x27;s wonderful to see that, even after 40+ years, the people who created a scripting language are still providing new, well-documented features.</div><br/></div></div><div id="37462235" class="c"><input type="checkbox" id="c-37462235" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#37462764">prev</a><span>|</span><a href="#37461484">next</a><span>|</span><label class="collapse" for="c-37462235">[-]</label><label class="expand" for="c-37462235">[1 more]</label></div><br/><div class="children"><div class="content">Funny, I would have approached this by removing the while loop and the if else parts of the BEGIN clause, leveraging the stock file reading and line iteration along with AWK pattern matching (terminated with a next statement to skip to the next row), and then shoved the rest in the END clause.<p>It’s always been a “thing” with me of not liking to put everything into BEGIN. Kind of a “if I’m doing that, why am I using awk” thing.<p>Just how I approach problems with awk.</div><br/></div></div><div id="37461484" class="c"><input type="checkbox" id="c-37461484" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#37462235">prev</a><span>|</span><label class="collapse" for="c-37461484">[-]</label><label class="expand" for="c-37461484">[7 more]</label></div><br/><div class="children"><div class="content">These blog posts and discussion usually pit one language against others and often attempt to restrict a language to some specific context, ignoring that each user&#x27;s experience, needs and <i>preferences</i> may be different.  A more interesting debate would be language-agnostic, such as writing one-liners versus writing lengthy programs.<p>In short, the debate might be something like: What does the computer user prefer more: (a) writing one-liners or (b) writing lengthy programs.  Not everyone will have the same answer.  Knuth might prefer (b).  McIllroy might prefer (a).<p>Assuming one reading this blog post knew nothing about programming languages, it seems to imply Python is not well-suited for one-liners, or at least not comparable to AWK in that context.  Perhaps the interpreter startup time might have something to do with the failure to consider Python for one-liners.</div><br/><div id="37461943" class="c"><input type="checkbox" id="c-37461943" checked=""/><div class="controls bullet"><span class="by">benhoyt</span><span>|</span><a href="#37461484">parent</a><span>|</span><a href="#37463407">next</a><span>|</span><label class="collapse" for="c-37461943">[-]</label><label class="expand" for="c-37461943">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think Python <i>is</i> very well suited to one-liners, but it&#x27;s not due to interpreter startup time (20ms on my machine). Rather, it&#x27;s due to all the scaffolding needed, which AWK provides implicitly: AWK automatically reads input lines and splits them into fields, automatically initializes variables to the type&#x27;s default value, and has terser syntax for things like regex matching.<p>Consider the following AWK one-liner which, for every input line that starts with a letter, prints the line number and the line&#x27;s second field:<p><pre><code>  awk &#x27;&#x2F;^[A-Za-z]&#x2F; { print NR, $2 }&#x27;
</code></pre>
The equivalent Python program has a <i>ton</i> more boilerplate: import statements, explicit input reading and field splitting, and more verbose regex matching:<p><pre><code>  import re
  import fileinput

  inp = fileinput.input(encoding=&#x27;utf-8&#x27;)
  for line in inp:
      if re.match(r&#x27;[A-Za-z]&#x27;, line):
          fields = line.split()
          print(inp.lineno(), fields[1])</code></pre></div><br/><div id="37462540" class="c"><input type="checkbox" id="c-37462540" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#37461484">root</a><span>|</span><a href="#37461943">parent</a><span>|</span><a href="#37462736">next</a><span>|</span><label class="collapse" for="c-37462540">[-]</label><label class="expand" for="c-37462540">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The equivalent Python program has a ton more boilerplate: import statements, explicit input reading and field splitting, and more verbose regex matching:<p>&quot;awks and pythons&quot;</div><br/></div></div><div id="37462736" class="c"><input type="checkbox" id="c-37462736" checked=""/><div class="controls bullet"><span class="by">make3</span><span>|</span><a href="#37461484">root</a><span>|</span><a href="#37461943">parent</a><span>|</span><a href="#37462540">prev</a><span>|</span><a href="#37463407">next</a><span>|</span><label class="collapse" for="c-37462736">[-]</label><label class="expand" for="c-37462736">[3 more]</label></div><br/><div class="children"><div class="content">I always thought we should make a short of Python for one liners inspired from awk, where the loop over the lines would be implied.<p>the line, lineno and fields would be predifined, and I guess re, os, shutil, pathlib and sys are pre imported. maybe the whole stdlib acts as if it&#x27;s preimported, while only being imported lazyly<p>here it would be something like<p>```<p>if re.match(r&#x27;[A-Za-z]&#x27;, line):
          fields = line.split()
          print(inp.lineno(), fields[1])<p>```<p>so<p>```<p>cat makefile | pyawk &#x27;if re.match(r&quot;[A-Za-z]&quot;, line): print(lineno, fields[1])&#x27;<p>```<p>I don&#x27;t see a way out of multiple if statements requiring multiple lines though, otherwise you would have to introduce brackets to Python lol</div><br/><div id="37462880" class="c"><input type="checkbox" id="c-37462880" checked=""/><div class="controls bullet"><span class="by">benhoyt</span><span>|</span><a href="#37461484">root</a><span>|</span><a href="#37462736">parent</a><span>|</span><a href="#37464229">next</a><span>|</span><label class="collapse" for="c-37462880">[-]</label><label class="expand" for="c-37462880">[1 more]</label></div><br/><div class="children"><div class="content">Alec Thomas wrote a script like this called pawk.py (<a href="https:&#x2F;&#x2F;github.com&#x2F;alecthomas&#x2F;pawk">https:&#x2F;&#x2F;github.com&#x2F;alecthomas&#x2F;pawk</a>). It reads input automatically, and for each line, defines &quot;n&quot; and &quot;f&quot; to the line number and fields list (among other things). It even supports &#x2F;regex&#x2F; patterns. Even the print is implicit. So the example above would be:<p><pre><code>  pawk &#x27;&#x2F;^[A-Za-z]&#x2F; (n, f[1])&#x27;
</code></pre>
By the way, triple backticks don&#x27;t work on HN. You have to indent by 2 spaces to get a code block.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>