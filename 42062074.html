<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730970052096" as="style"/><link rel="stylesheet" href="styles.css?v=1730970052096"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ente.io/blog/monorepo-retrospective/">Monorepo – Our Experience</a> <span class="domain">(<a href="https://ente.io">ente.io</a>)</span></div><div class="subtext"><span>vishnumohandas</span> | <span>202 comments</span></div><br/><div><div id="42064636" class="c"><input type="checkbox" id="c-42064636" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42070849">next</a><span>|</span><label class="collapse" for="c-42064636">[-]</label><label class="expand" for="c-42064636">[95 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; Moving to a monorepo didn&#x27;t change much, and what minor changes it made have been positive.
</code></pre>
I&#x27;m not sure that this statement in the summary jives with this statement from the next section:<p><pre><code>    &gt; In the previous, separate repository world, this would&#x27;ve been four separate pull requests in four separate repositories, and with comments linking them together for posterity.
    &gt; 
    &gt; Now, it is a single one. Easy to review, easy to merge, easy to revert.
</code></pre>
IMO, this is a huge quality of life improvement and prevents a lot of mistakes from not having the right revision synced down across different repos.  This alone is a HUGE improvement where a dev doesn&#x27;t accidentally end up with one repo in this branch and forgot to pull this other repo at the same branch and get weird issues due to this basic hassle.<p>When I&#x27;ve encountered this, we&#x27;ve had to use <i>another repo</i> to keep scripts that managed this.  But this was also sometimes problematic because each developer&#x27;s setup had to be identical on their local file system (for the script to work) or we had to each create a config file pointing to where each repo lived.<p>This also impacts tracking down bugs and regression analysis; this is much easier to manage in a mono-repo setup because you can get everything at the same revision instead of managing synchronization of multiple repos to figure out where something broke.</div><br/><div id="42067413" class="c"><input type="checkbox" id="c-42067413" checked=""/><div class="controls bullet"><span class="by">danudey</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42066059">next</a><span>|</span><label class="collapse" for="c-42067413">[-]</label><label class="expand" for="c-42067413">[17 more]</label></div><br/><div class="children"><div class="content">I prefer microservices&#x2F;microrepos _conceptually_, but we had the same experience as your quoted text - making changes to four repos, and backporting those changes to the previous two release branches, means twelve separate PRs to make a change.<p>Having a centralized configuration library (a shared Makefile that we can pull down into our repo and include into the local Makefile) helps, until you have to make a backwards-incompatible change to that Makefile and then post PRs to every branch of every repo that uses that Makefile.<p>Now we have almost the entirety of our projects back into one repository and everything is simpler; one PR per release branch, three PRs (typically) for any change that needs backporting. Vastly simpler process and much less room for error.</div><br/><div id="42072213" class="c"><input type="checkbox" id="c-42072213" checked=""/><div class="controls bullet"><span class="by">esperent</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42067413">parent</a><span>|</span><a href="#42073662">next</a><span>|</span><label class="collapse" for="c-42072213">[-]</label><label class="expand" for="c-42072213">[13 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t there some middle ground between microservices and monorepos? For example, a few large clearly defined projects that talk to each other via versioned APIs?</div><br/><div id="42072911" class="c"><input type="checkbox" id="c-42072911" checked=""/><div class="controls bullet"><span class="by">0xFACEFEED</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42072213">parent</a><span>|</span><a href="#42074114">next</a><span>|</span><label class="collapse" for="c-42072911">[-]</label><label class="expand" for="c-42072911">[9 more]</label></div><br/><div class="children"><div class="content">Assuming you&#x27;re just referring to repos: not really IMO.<p>As soon as you split 1 repo into 2 repos you need to start building tooling to support your 2 repos. If your infrastructure is sufficiently robust with 2 repos then you might as well have 3 or 4 or 10. If it&#x27;s built to _only_ support 2 repos (or 3 or 4) then it&#x27;s brittle out of the gate.<p>The value of a monorepo is that you completely eliminate certain classes of problems and take on other classes of problems. Classic trade off. Folks that prefer monorepos take the position that multirepo problems are much harder than monorepo problems most of the time.</div><br/><div id="42074936" class="c"><input type="checkbox" id="c-42074936" checked=""/><div class="controls bullet"><span class="by">amjnsx</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42072911">parent</a><span>|</span><a href="#42073697">next</a><span>|</span><label class="collapse" for="c-42074936">[-]</label><label class="expand" for="c-42074936">[1 more]</label></div><br/><div class="children"><div class="content">Do you not just write code that’s backwards compatible?e.g an api deployment should not break the front end. The api changes should work on the old front end and the updated front end that uses the api change.</div><br/></div></div><div id="42073697" class="c"><input type="checkbox" id="c-42073697" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42072911">parent</a><span>|</span><a href="#42074936">prev</a><span>|</span><a href="#42074000">next</a><span>|</span><label class="collapse" for="c-42073697">[-]</label><label class="expand" for="c-42073697">[2 more]</label></div><br/><div class="children"><div class="content">&gt; As soon as you split 1 repo into 2 repos you need to start building tooling to support your 2 repos.<p>No, not really.<p>If you&#x27;re talking about projects for modules and components, all you need is a versioning strategy and release consumable packages of your projects.<p>If you&#x27;re talking about services, all you need to do is support versioned APIs and preserve your contracts.<p>No tooling required. For projects you can even make do with git submodules. For services, all you need to do is update clients of your downstream dependencies.<p>What problems are you facing, exactly?</div><br/><div id="42074744" class="c"><input type="checkbox" id="c-42074744" checked=""/><div class="controls bullet"><span class="by">joshuamorton</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073697">parent</a><span>|</span><a href="#42074000">next</a><span>|</span><label class="collapse" for="c-42074744">[-]</label><label class="expand" for="c-42074744">[1 more]</label></div><br/><div class="children"><div class="content">Let me rephrase this:<p>If you aren&#x27;t using a monorepo, you need some versioning process, as well as procedural systems in place to ensure that everyone&#x27;s dependencies, stay reasonably up to date. Otherwise, you end up deferring pain in really unwanted ways, and require sudden, unwanted upgrades through api incompatibility due to external pressure.<p>This also has the downside of allowing api-owning teams to make changes willy-nilly and break backwards compatibility because they can just do it behind SemVer, and then clients of the api need to own the process of migrating to the new version.<p>A monorepo fixes both of these: you cannot get out of sync, so it is the api-owning team&#x27;s responsibility to upgrade clients, since they can&#x27;t break the API otherwise. Similarly, you get a versioning process for free, and clients can never be using out of date or out of support versions of a dependency.<p>Services work approximately the same either way, since you can&#x27;t assume synchronous upgrades across service&#x2F;rpc boundaries anyway.</div><br/></div></div></div></div><div id="42074000" class="c"><input type="checkbox" id="c-42074000" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42072911">parent</a><span>|</span><a href="#42073697">prev</a><span>|</span><a href="#42073375">next</a><span>|</span><label class="collapse" for="c-42074000">[-]</label><label class="expand" for="c-42074000">[2 more]</label></div><br/><div class="children"><div class="content">Hard disagree. I&#x27;ve found that the best setup is two monorepos - one with feature&#x2F;app code, and one with operations configuration.<p>The fundamental mismatch is the feature&#x2F;app code will have longer testing times, stuff like Puppeteer and creating-infra-per-MR that just fundamentally takes a long time to run. But in ops, you need configuration to roll out <i>quickly</i>, maybe run an autoformatter and a linter or two beforehand and that&#x27;s it. When you want to rollback, you don&#x27;t need to wait for all your tests to run.<p>Yes you need to deal with versioning. You can just use automatic timestamps. You can write easy automation to push new timestamps to the ops&#x2F;config repository when there are new releases in the app repository. The ops repository has minimal configuration to pull the latest version of the app repository and apply it, where the app repository includes infra and deployment scripts themselves.</div><br/><div id="42074123" class="c"><input type="checkbox" id="c-42074123" checked=""/><div class="controls bullet"><span class="by">gugagore</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42074000">parent</a><span>|</span><a href="#42073375">next</a><span>|</span><label class="collapse" for="c-42074123">[-]</label><label class="expand" for="c-42074123">[1 more]</label></div><br/><div class="children"><div class="content">The problem you describe with waiting for tests for unrelated code changes (or potentially related but you want to skip it for the reasons you describe) is a problem that seems to deserve a solution even within a single monorepo.<p>What are the solutions? You would need multiple merge queues.</div><br/></div></div></div></div><div id="42073375" class="c"><input type="checkbox" id="c-42073375" checked=""/><div class="controls bullet"><span class="by">Lvl999Noob</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42072911">parent</a><span>|</span><a href="#42074000">prev</a><span>|</span><a href="#42074114">next</a><span>|</span><label class="collapse" for="c-42073375">[-]</label><label class="expand" for="c-42073375">[3 more]</label></div><br/><div class="children"><div class="content">The classic 0, 1, or N. You can have 0 repos (no-code or outsourced or just some unversioned blob of code). You can have 1 repo (a mono-repo). Or you can have N number of repos (individual micro services). Limiting yourself to a number that&#x27;s higher than 1 but still finite is just asking for pain. (Of course implementation limits can apply but there shouldn&#x27;t be logical limits)</div><br/><div id="42073435" class="c"><input type="checkbox" id="c-42073435" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073375">parent</a><span>|</span><a href="#42074114">next</a><span>|</span><label class="collapse" for="c-42073435">[-]</label><label class="expand" for="c-42073435">[2 more]</label></div><br/><div class="children"><div class="content">Monorepo and microservices are orthogonal.<p>You can have as many build targets in a monorepo as you like. You can also have large monoliths in a monorepo.</div><br/><div id="42074534" class="c"><input type="checkbox" id="c-42074534" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073435">parent</a><span>|</span><a href="#42074114">next</a><span>|</span><label class="collapse" for="c-42074534">[-]</label><label class="expand" for="c-42074534">[1 more]</label></div><br/><div class="children"><div class="content">I worked with monolith split into multiple repos as well. It&#x27;s orthogonal indeed.</div><br/></div></div></div></div></div></div></div></div><div id="42074114" class="c"><input type="checkbox" id="c-42074114" checked=""/><div class="controls bullet"><span class="by">KGunnerud</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42072213">parent</a><span>|</span><a href="#42072911">prev</a><span>|</span><a href="#42074253">next</a><span>|</span><label class="collapse" for="c-42074114">[-]</label><label class="expand" for="c-42074114">[1 more]</label></div><br/><div class="children"><div class="content">Done that at two different places. This was public sector in both cases so typically many products in the organization. So one product was one monorepo.<p>Wrote this some years ago: <a href="https:&#x2F;&#x2F;dev.to&#x2F;kgunnerud&#x2F;our-experience-monorepo-with-java-maven-and-github-actions-2aho" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;kgunnerud&#x2F;our-experience-monorepo-with-java-m...</a><p>Nobody in our team wants to go back to nonmonorepo now, although everone was sceptical initially</div><br/></div></div><div id="42074253" class="c"><input type="checkbox" id="c-42074253" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42072213">parent</a><span>|</span><a href="#42074114">prev</a><span>|</span><a href="#42072350">next</a><span>|</span><label class="collapse" for="c-42074253">[-]</label><label class="expand" for="c-42074253">[1 more]</label></div><br/><div class="children"><div class="content">Two monorepos:<p>Primary monorepo – single versioned packages for libraries and services that are deployed as a whole.<p>Secondary monorepo – individually versioned packages for shared libraries and independent (micro)services.</div><br/></div></div><div id="42072350" class="c"><input type="checkbox" id="c-42072350" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42072213">parent</a><span>|</span><a href="#42074253">prev</a><span>|</span><a href="#42073662">next</a><span>|</span><label class="collapse" for="c-42072350">[-]</label><label class="expand" for="c-42072350">[1 more]</label></div><br/><div class="children"><div class="content">Mono-repo is not the same as mono-service. You can deploy multiple services out of a single repository.</div><br/></div></div></div></div><div id="42073662" class="c"><input type="checkbox" id="c-42073662" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42067413">parent</a><span>|</span><a href="#42072213">prev</a><span>|</span><a href="#42066059">next</a><span>|</span><label class="collapse" for="c-42073662">[-]</label><label class="expand" for="c-42073662">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I prefer microservices&#x2F;microrepos _conceptually_, but we had the same experience as your quoted text - making changes to four repos, and backporting those changes to the previous two release branches, means twelve separate PRs to make a change.<p>You only need to coordinate this sort of changes if you have absolutely no versioning strategy in place and accept breaking contracts for no reason at all.<p>If you have any form of versioning in place, you do not need to push multi-project commits. You update upstream packages and services, roll them out, and proceed to update the projects that consume them to gradually point them to the newly released versions.</div><br/><div id="42074098" class="c"><input type="checkbox" id="c-42074098" checked=""/><div class="controls bullet"><span class="by">gugagore</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073662">parent</a><span>|</span><a href="#42066059">next</a><span>|</span><label class="collapse" for="c-42074098">[-]</label><label class="expand" for="c-42074098">[2 more]</label></div><br/><div class="children"><div class="content">Surely the git SHA is &quot;a form of versioning&quot;, isn&#x27;t it? Yet I don&#x27;t see how that form of versioning helps.</div><br/><div id="42074154" class="c"><input type="checkbox" id="c-42074154" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42074098">parent</a><span>|</span><a href="#42066059">next</a><span>|</span><label class="collapse" for="c-42074154">[-]</label><label class="expand" for="c-42074154">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Surely the git SHA is &quot;a form of versioning&quot;, isn&#x27;t it?<p>If you&#x27;re consuming a module from a git as a submodule, yes.</div><br/></div></div></div></div></div></div></div></div><div id="42066059" class="c"><input type="checkbox" id="c-42066059" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42067413">prev</a><span>|</span><a href="#42073634">next</a><span>|</span><label class="collapse" for="c-42066059">[-]</label><label class="expand" for="c-42066059">[20 more]</label></div><br/><div class="children"><div class="content">My only counter argument here, is when those 4 things deploy independently.  Sometimes, people will get tricked into thinking a code change is atomic because it is in one commit, when it will lead to a mixed fleet because of deployment realities.  In that world, having them separate is easier to work with, as you may have to revert one of the deployments separately from the others.</div><br/><div id="42069461" class="c"><input type="checkbox" id="c-42069461" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066059">parent</a><span>|</span><a href="#42073724">next</a><span>|</span><label class="collapse" for="c-42069461">[-]</label><label class="expand" for="c-42069461">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just an argument for not doing &quot;implicit GitOps&quot;, treating the tip of your monorepo&#x27;s main branch as the source-of-truth on the correct deployment state of your entire system. (&quot;Implicit GitOps&quot; sorta-kinda works when you have a 1:1 correspondence between repos and deployable components — though not always! — but it isn&#x27;t tenable for a monorepo.)<p>What instead, then? Explicit GitOps. Explicit, reified release specifications (think k8s resource manifests, or Erlang .relup files), one per separately-deploy-cadenced component. If you have a monorepo, then these live <i>also</i> as a dir in the monorepo. CD happens only when these files change.<p>With this approach, a single PR <i>can</i> atomically merge code <i>and</i> update one or more release specifications (triggering CD for those components), <i>if and when</i> that is a sensible thing to do. But there can also be separate PRs for updating the code vs. &quot;integrating and deploying changes&quot; to a component, if-and-when <i>that</i> is sensible.</div><br/><div id="42070853" class="c"><input type="checkbox" id="c-42070853" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42069461">parent</a><span>|</span><a href="#42069801">next</a><span>|</span><label class="collapse" for="c-42070853">[-]</label><label class="expand" for="c-42070853">[4 more]</label></div><br/><div class="children"><div class="content">&gt; With this approach, a single PR can atomically merge code and update one or more release specifications (triggering CD for those components), if and when that is a sensible thing to do.<p>How do you avoid the chicken-and-egg problem? Like if the k8s manifest contains a container tag, and the tag is created by CI when the PR is merged to main, it would seem you can’t add code and deploy that code in the same PR.</div><br/><div id="42071164" class="c"><input type="checkbox" id="c-42071164" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42070853">parent</a><span>|</span><a href="#42073326">next</a><span>|</span><label class="collapse" for="c-42071164">[-]</label><label class="expand" for="c-42071164">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen this approach in action personally, but I assume you&#x27;d set it up similarly to how Homebrew builds + pins bottles for formulae:<p>- PR creation (or any update to the PR branch by a human) would trigger a CI workflow to build+push the container;<p>- if this succeeds, the workflow would <i>push a commit to the PR feature branch</i> that pins the container ref;<p>- and the base branch would have a branch protection rule that makes the success of this CI workflow a prerequisite for PR mergeability.<p>In the explicit-GitOps-in-monorepo case, you&#x27;d probably want to do this by having the PR author modify the release spec file of each component they want to build a release for, replacing the old static ref with a temporary symbolic ref meaning &quot;hey CI system, calculate this.&quot; Then the CI&#x27;s added commit would rewrite those temporary symbolic refs into new static ones.<p>---<p>Although, that&#x27;s all assuming that you even want to do CI builds in the first place. If you&#x27;re developing containerized server software — rather than an operating system, a web browser, etc — then it shouldn&#x27;t matter <i>where</i> you&#x27;re building, and there isn&#x27;t much impetus for deterministic, auditable builds, either. So why bottleneck builds by shoving them all onto some wimpy CI system—when every engineer already has a powerful workstation that can do builds often 4x faster, sitting there idle?<p>Here&#x27;s what I call &quot;local-first explicit GitOps&quot;:<p>1. you give your engineers the ability to push refs to the container registry (but you never use symbolic refs, always static manifest SHAs, so a malicious engineer can&#x27;t do anything dangerous with this.<p>2. you add a script to your monorepo, that an engineer can run against their feature branch, that&#x27;ll notice their current branch&#x27;s <i>local</i> symbolic refs, and build+push containers <i>locally</i> in order to rewrite those into static refs.<p>3. On success, the script can use `gh` (or equivalent) to trigger PR creation.<p>Now every PR will come into existence already pinning valid new build artifacts by their static refs!</div><br/></div></div><div id="42073326" class="c"><input type="checkbox" id="c-42073326" checked=""/><div class="controls bullet"><span class="by">claytonjy</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42070853">parent</a><span>|</span><a href="#42071164">prev</a><span>|</span><a href="#42071775">next</a><span>|</span><label class="collapse" for="c-42073326">[-]</label><label class="expand" for="c-42073326">[1 more]</label></div><br/><div class="children"><div class="content">I just implemented something like this in Github Actions for a single python application which includes 2 containers and a model repository, deployed to Kubernetes via Argo from the in-repo Helm chart.<p>The same semantic version string is in pyproject.toml and values.yaml. These are enforced to be the same via pre-commit hook. Environment-specific versions are in env-specific values files like values-prod.yaml.<p>I have a build workflow which triggers on PRs that change certain files, computes either a pre- or post-release tag by appending the git hash to the server tag, and pushes the images and model repo using that tag. This will re-trigger as the PR is updated.<p>Users deploy these pre&#x2F;post-releases in a few clicks with a manual github action which updates the branch and tag in our dev cluster Argo.<p>The PR can’t be merged unless the version is bumped.<p>When the PR is merged, a “promote” workflow runs which re-tags the latest image and model repo with the release version (pre-release without git hash suffix). This is fast, which means there’s no risk of image backoff loop from Argo trying to sync before artifacts are available.<p>Most PRs don’t touch the version in values-prod.yaml, so merges to main auto-deploy to staging while prod requires another PR updating only values-prod.yaml.<p>Folks complain a bit about manually bumping the version, and needing 2 PRs to take a change to prod, but it’s pretty smooth otherwise!</div><br/></div></div><div id="42071775" class="c"><input type="checkbox" id="c-42071775" checked=""/><div class="controls bullet"><span class="by">someone654</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42070853">parent</a><span>|</span><a href="#42073326">prev</a><span>|</span><a href="#42069801">next</a><span>|</span><label class="collapse" for="c-42071775">[-]</label><label class="expand" for="c-42071775">[1 more]</label></div><br/><div class="children"><div class="content">If you use helm charts or similar, the version of the image would be a variable that is updated outside the repo. ArgoCD can do this with the Application resource.<p>For example: build code and image, update git reference and version number in Application when build done.<p>You then get atomic updates of both code and configuration.</div><br/></div></div></div></div><div id="42069801" class="c"><input type="checkbox" id="c-42069801" checked=""/><div class="controls bullet"><span class="by">scubbo</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42069461">parent</a><span>|</span><a href="#42070853">prev</a><span>|</span><a href="#42070373">next</a><span>|</span><label class="collapse" for="c-42069801">[-]</label><label class="expand" for="c-42069801">[1 more]</label></div><br/><div class="children"><div class="content">...I can&#x27;t believe I&#x27;d never thought about the fact that a &quot;Deployment Repo&quot; can, in fact, just be a directory within the Code Repo. Interesting thought - thanks!</div><br/></div></div><div id="42070373" class="c"><input type="checkbox" id="c-42070373" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42069461">parent</a><span>|</span><a href="#42069801">prev</a><span>|</span><a href="#42073724">next</a><span>|</span><label class="collapse" for="c-42070373">[-]</label><label class="expand" for="c-42070373">[1 more]</label></div><br/><div class="children"><div class="content">I mean... sure?  Yes, if you add extra structure on top of your code that is there to model the deployments, then you get a bit closer to modeling your deployments.  Isn&#x27;t that the exact argument for why you might want multiple repositories, as well?</div><br/></div></div></div></div><div id="42073724" class="c"><input type="checkbox" id="c-42073724" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066059">parent</a><span>|</span><a href="#42069461">prev</a><span>|</span><a href="#42070913">next</a><span>|</span><label class="collapse" for="c-42073724">[-]</label><label class="expand" for="c-42073724">[6 more]</label></div><br/><div class="children"><div class="content">&gt; My only counter argument here, is when those 4 things deploy independently.<p>This brings us to the elephant in the room: monorepo strategies are just naive and futile attempts at fixing the problems created by an absolute lack of support for versioning.<p>If you support versioning, you don&#x27;t care where and how you store your code. You just push the changes you need to push, and make sure you bump versions to reflect the nature of your changes. Consumers are left with the responsibility of picking which to consume, and when to consume it.</div><br/><div id="42074591" class="c"><input type="checkbox" id="c-42074591" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073724">parent</a><span>|</span><a href="#42073928">next</a><span>|</span><label class="collapse" for="c-42074591">[-]</label><label class="expand" for="c-42074591">[2 more]</label></div><br/><div class="children"><div class="content">Versioning sometimes becomes a problem itself.<p>You can&#x27;t always allow support for V1 of some API to continue because it&#x27;s just &quot;wrong&quot; in the light of your work. It can turn out that your &quot;micro&quot; architecture just didn&#x27;t really work because factors X or Y tie certain groups of services together so much that a change to one forces changes to the others.<p>So redesign right? Well, the contractors are all gone and your small team can barely manage the bugs and minor features, let alone redesigns which tend to force huge changes in the entire system because it wasn&#x27;t thought out that well to start with. i.e. the mountain to climb to fix a little problem is as high as fixing all the problems.<p>So you might have to update everything that references your changing API to use the new version....but your company has tons of repos and you don&#x27;t know which ones reference your API, and they&#x27;re owned by other teams and there&#x27;s no central set of tests which have been run against the combination of the head of all these repos to ensure that they do in fact work together at exactly the state the combination is at when you are working.<p>All deployments are a guess - which repos do you need to deploy for change X? Some other team deploys their repo without realising that it now depends on a new version of yours.  Oh dear. We should have created a versioning mechanism of some kind and made their deployment depend on ours......but no time to do that kind of thing and could you get other people to agree to use it and how does it work with your CI system and.........well....you just muddle on, force yourself to remember the details, make mistakes etc etc. Busy work.<p>IMO monorepos make a good place to put a set of whole-system end to end tests that everyone can run before they merge. That&#x27;s going to sort out many conflicts before they turn into a bug hunt.</div><br/><div id="42074830" class="c"><input type="checkbox" id="c-42074830" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42074591">parent</a><span>|</span><a href="#42073928">next</a><span>|</span><label class="collapse" for="c-42074830">[-]</label><label class="expand" for="c-42074830">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So you might have to update everything that references your changing API to use the new version....<p>That&#x27;s how versioning works.<p>- You allow legacy applications to consume the legacy interface,<p>- you provide a new interface to the world so that they have a path forward to migrate out of consuming the legacy service through the legacy interface,<p>- the consumers migrate in a time frame that makes sense to them.<p>- in the end you sunset the legacy API, and pull the plug.<p>This scenario is not eliminated by monorepos.<p>What monorepos do is force consumers to migrate to the new interface as an urgent task that&#x27;s part of the critical path. If you have resources to do that migration, it does not matter how you store your code.</div><br/></div></div></div></div><div id="42073928" class="c"><input type="checkbox" id="c-42073928" checked=""/><div class="controls bullet"><span class="by">dieortin</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073724">parent</a><span>|</span><a href="#42074591">prev</a><span>|</span><a href="#42074632">next</a><span>|</span><label class="collapse" for="c-42073928">[-]</label><label class="expand" for="c-42073928">[2 more]</label></div><br/><div class="children"><div class="content">Versioning introduces a big maintenance cost, both on the side of the developer of a service and on the consumer side. 
On a monorepo you have a single version, and can be sure that everything works together on it. You are forced to address the costs of changing APIs continuously, but all components are always up to date. 
With multiple repos, versioning hell is real.</div><br/><div id="42074071" class="c"><input type="checkbox" id="c-42074071" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073928">parent</a><span>|</span><a href="#42074632">next</a><span>|</span><label class="collapse" for="c-42074071">[-]</label><label class="expand" for="c-42074071">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Versioning introduces a big maintenance cost, both on the side of the developer of a service and on the consumer side.<p>Not really.<p>From the producer side it only requires that a) you do not break your contract, b) when you need to break a contract, you bump your version number, c) when no one uses older versions, remove the code.<p>From the consumer, it&#x27;s even easier: you just need to point to the version you&#x27;re consuming.<p>What exactly do you think is the problem?</div><br/></div></div></div></div><div id="42074632" class="c"><input type="checkbox" id="c-42074632" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073724">parent</a><span>|</span><a href="#42073928">prev</a><span>|</span><a href="#42070913">next</a><span>|</span><label class="collapse" for="c-42074632">[-]</label><label class="expand" for="c-42074632">[1 more]</label></div><br/><div class="children"><div class="content">You actually have to do versioning property, though. Most people I&#x27;ve worked with do not understand semantic versioning and basically don&#x27;t understand how to ship new features in a non-breaking way. That or they&#x27;re too lazy to do it. Either way, dependencies get broken constantly.<p>That&#x27;s the real point of a monorepo: you can treat the whole thing as internal, break it to your heart&#x27;s content. You only need to make sure you don&#x27;t break the user-facing part, for some subjective value of break.</div><br/></div></div></div></div><div id="42070913" class="c"><input type="checkbox" id="c-42070913" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066059">parent</a><span>|</span><a href="#42073724">prev</a><span>|</span><a href="#42069599">next</a><span>|</span><label class="collapse" for="c-42070913">[-]</label><label class="expand" for="c-42070913">[1 more]</label></div><br/><div class="children"><div class="content">If the version numbers of all services built from the PR are identical, you at least have a pretty clear trail to figuring out WTF happened.<p>Even with a few services, we saw some pretty crunchy issues with people not understanding that service A had version 1.3.1234 of a module and Service B had version 1.3.1245 and that was enough skew to cause problems.<p>Distinct repos tend to have distinct builds, and sooner or later one of the ten you&#x27;re building will glitch out and have to be run twice, or the trigger will fail and it won&#x27;t build at all until the subsequent merge, and having numbers that are close results in a false sense of confidence.</div><br/></div></div><div id="42069599" class="c"><input type="checkbox" id="c-42069599" checked=""/><div class="controls bullet"><span class="by">lmz</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066059">parent</a><span>|</span><a href="#42070913">prev</a><span>|</span><a href="#42072472">next</a><span>|</span><label class="collapse" for="c-42069599">[-]</label><label class="expand" for="c-42069599">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t a mixed fleet always the case once you have more than one server and do rolling updates?</div><br/><div id="42070970" class="c"><input type="checkbox" id="c-42070970" checked=""/><div class="controls bullet"><span class="by">xyzzy123</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42069599">parent</a><span>|</span><a href="#42070350">next</a><span>|</span><label class="collapse" for="c-42070970">[-]</label><label class="expand" for="c-42070970">[2 more]</label></div><br/><div class="children"><div class="content">Sort of; at medium scale you can blue&#x2F;green your whole system out of the monorepo (even if its  say 20 services) in k8s and flip the ingresses to cut over during release.<p>Of course k8s not required, you can do it in straight IaC etc (i.e deploy a whole parallel system and switch).<p>It&#x27;s still &quot;mixed fleet&quot; in terms of any shared external resources (queues, db state, etc) but you can change service interfaces etc with impunity and not worry about compatibility &#x2F; versioning between services.<p>Throwing temporary compute at the problem can save a <i>lot</i> of busywork and&#x2F;or thinking about integration problems.<p>This stops being practical if you get _very_ big but at that point you presumably have more money and engineers to throw at the problem.</div><br/><div id="42073763" class="c"><input type="checkbox" id="c-42073763" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42070970">parent</a><span>|</span><a href="#42070350">next</a><span>|</span><label class="collapse" for="c-42073763">[-]</label><label class="expand" for="c-42073763">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sort of; at medium scale you can blue&#x2F;green your whole system out of the monorepo (even if its say 20 services) in k8s and flip the ingresses to cut over during release.<p>That&#x27;s overall a bad idea, and negates the whole point of blue-green deployments. This is particularly bad if you have in place any form of distributed transaction.<p>There are very good reasons why deployment strategies such as rolling deployments and one-box deployments were developed. You need to be able to gradually roll out a change to prevent problems from escalating and causing downtime. If you use all that infrastructure to then flip global switches then you&#x27;re building up all this infrastructure to the negate any of that with practices that invariably cause problems.<p>And this is being done just because someone thinks it&#x27;s a good idea to keep all code in a single repo?</div><br/></div></div></div></div><div id="42070350" class="c"><input type="checkbox" id="c-42070350" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42069599">parent</a><span>|</span><a href="#42070970">prev</a><span>|</span><a href="#42072472">next</a><span>|</span><label class="collapse" for="c-42070350">[-]</label><label class="expand" for="c-42070350">[1 more]</label></div><br/><div class="children"><div class="content">Yes.  And if you structure your code to explicitly do this, it is a lot easier to reason about.</div><br/></div></div></div></div><div id="42072472" class="c"><input type="checkbox" id="c-42072472" checked=""/><div class="controls bullet"><span class="by">oftenwrong</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066059">parent</a><span>|</span><a href="#42069599">prev</a><span>|</span><a href="#42073634">next</a><span>|</span><label class="collapse" for="c-42072472">[-]</label><label class="expand" for="c-42072472">[1 more]</label></div><br/><div class="children"><div class="content">This is generally seen as a feature. Most developers won&#x27;t need to confront the messy reality of the deployed &quot;world&quot;. They can work within the relatively pure world of the code history. Of course, some will have to do the work of actually producing releases, performing deployments, and operating the systems.</div><br/></div></div></div></div><div id="42073634" class="c"><input type="checkbox" id="c-42073634" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42066059">prev</a><span>|</span><a href="#42070122">next</a><span>|</span><label class="collapse" for="c-42073634">[-]</label><label class="expand" for="c-42073634">[6 more]</label></div><br/><div class="children"><div class="content">&gt; IMO, this is a huge quality of life improvement and prevents a lot of mistakes from not having the right revision synced down across different repos. This alone is a HUGE improvement where a dev doesn&#x27;t accidentally end up with one repo in this branch and forgot to pull this other repo at the same branch and get weird issues due to this basic hassle.<p>This scenario only happens if you&#x27;re working with a distributed monolith, you care nothing about breaking existing APIs, and you own all producers and consumers.<p>When this happens, your problem is obviously not how you maintain projects independently in separate repos. Your problems is how you&#x27;re failing to preserve API contracts, and instead you go to the extreme of insisting in breaking all contracts at once.<p>It&#x27;s also a huge red flag when you talk about &quot;accidentally end up with one repo in this branch&quot;. Don&#x27;t you know what you are pushing to production?<p>As always, monorepo talks are just a thin veil of optimization placed over a huge mess of major operational and technical problems.</div><br/><div id="42073751" class="c"><input type="checkbox" id="c-42073751" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073634">parent</a><span>|</span><a href="#42073776">next</a><span>|</span><label class="collapse" for="c-42073751">[-]</label><label class="expand" for="c-42073751">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Your problems is how you&#x27;re failing to preserve API contracts, and instead you go to the extreme of insisting in breaking all contracts at once.<p>Preserving contracts has a significant cost. Why would you try to preserve contracts if you&#x27;re in fact in control of all producers and consumers?</div><br/><div id="42073905" class="c"><input type="checkbox" id="c-42073905" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073751">parent</a><span>|</span><a href="#42073776">next</a><span>|</span><label class="collapse" for="c-42073905">[-]</label><label class="expand" for="c-42073905">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Preserving contracts has a significant cost.<p>Not really. You just need to break out a new version when you put out a breaking change. This can mean anything between duplicating the code that implements your interface to then apply a change and checking a version flag when invoking an operation to determine which version to run.<p>Do you struggle to not break your code? To me it&#x27;s like the main responsibility of any developer, isn&#x27;t it?<p>&gt; Why would you try to preserve contracts if you&#x27;re in fact in control of all producers and consumers?<p>Because you clearly aren&#x27;t in control, if you feel compelled to dump anything and everything in the same repository to try to prevent things from breaking.<p>Also, as others have pointed out, storing code in the same repository gives you no assurance that all your services will be deployed at the same exact moment in time. Consider for example multi-region deployments, or even deployments to multiple availability zones. Those aren&#x27;t atomic. Why does anyone believe that storing all code in the same repository is enough to make these operations atomic?</div><br/><div id="42074134" class="c"><input type="checkbox" id="c-42074134" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073905">parent</a><span>|</span><a href="#42073776">next</a><span>|</span><label class="collapse" for="c-42074134">[-]</label><label class="expand" for="c-42074134">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why does anyone believe that storing all code in the same repository is enough to make these operations atomic?<p>Not isolated to this particular issue. People really like to pretend that problems are much simpler than they actually are and that inherent complexity is just some edge cases to be ironed out.</div><br/></div></div></div></div></div></div><div id="42073776" class="c"><input type="checkbox" id="c-42073776" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073634">parent</a><span>|</span><a href="#42073751">prev</a><span>|</span><a href="#42070122">next</a><span>|</span><label class="collapse" for="c-42073776">[-]</label><label class="expand" for="c-42073776">[2 more]</label></div><br/><div class="children"><div class="content">API contracts are not free, and for things that were not decided to be an API and or a contract an absolute waste of time.<p>Of course I’m “breaking all contracts at once”, for most of them were never a contract to begin with, and the monorepo effectively discourages people from assuming random behaviors are in fact contracts, and that preserves my sanity and the sanity of the code base that now doesn’t suffer from the combinatorial explosion in complexity that happens when people want everything to be an API contract.</div><br/><div id="42073931" class="c"><input type="checkbox" id="c-42073931" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42073776">parent</a><span>|</span><a href="#42070122">next</a><span>|</span><label class="collapse" for="c-42073931">[-]</label><label class="expand" for="c-42073931">[1 more]</label></div><br/><div class="children"><div class="content">&gt; API contracts are not free<p>Yes, they are. They are as free as adding a new endpoint.<p>&gt; and for things that were not decided to be an API and or a contract an absolute waste of time.<p>You&#x27;re talking about integrating multiple projects. There are always contract. You simply chose to be ignorant of that fact and fail to interpret breaking those contracts as the root cause of all your problems.<p>You point out anyone lauding monorepos as some kind of solution to any problem and I assure you that we can immediately isolate one or more problems caused by versioning and breaking contracts.<p>The only reason why we see this nonsense paraded in web services is that they are loosely coupled. When people worked mainly with modules and libraries, compiler and linking errors made this sort of error very obvious. Now people chose to unlearn facts and want to call that operational improvements.</div><br/></div></div></div></div></div></div><div id="42070122" class="c"><input type="checkbox" id="c-42070122" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42073634">prev</a><span>|</span><a href="#42066140">next</a><span>|</span><label class="collapse" for="c-42070122">[-]</label><label class="expand" for="c-42070122">[5 more]</label></div><br/><div class="children"><div class="content">I thought one of the whole points behind separate (non-mono)repos was to help enforce loose coupling and if you came to a point where a single feature change required PRs on 4 separate repos then that was an indicator that your project needed refactoring as it was becoming to tightly coupled. The example in the article could have been interpreted to mean that they should refactor the functionality for interacting with the ML model into it&#x27;s own repo so it could encapsulate this aspect of the project. Instead they doubled down on the tighter coupling by  putting them in a monorepo (which itself encourages tighter coupling).</div><br/><div id="42074176" class="c"><input type="checkbox" id="c-42074176" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42070122">parent</a><span>|</span><a href="#42070928">next</a><span>|</span><label class="collapse" for="c-42074176">[-]</label><label class="expand" for="c-42074176">[1 more]</label></div><br/><div class="children"><div class="content">Every decoupling point is based on certain contract. You can get away with <i>a lot</i> with well thought out contracts and interfaces, but sometimes the contract has to change and then both sides of the contract must change in lockstep. Usually it is possible to isolate changes to a contract, but the overhead is just not worth it most of the time.</div><br/></div></div><div id="42070928" class="c"><input type="checkbox" id="c-42070928" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42070122">parent</a><span>|</span><a href="#42074176">prev</a><span>|</span><a href="#42066140">next</a><span>|</span><label class="collapse" for="c-42070928">[-]</label><label class="expand" for="c-42070928">[3 more]</label></div><br/><div class="children"><div class="content">The issue is that you can&#x27;t &quot;enforce&quot; loose coupling. The causality is reversed here.<p>Your software artifacts will have loose coupling if you divided them well enough on their creation. As soon as they are created, you can&#x27;t do anything else to change it, except for joining or splitting them.</div><br/><div id="42071236" class="c"><input type="checkbox" id="c-42071236" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42070928">parent</a><span>|</span><a href="#42066140">next</a><span>|</span><label class="collapse" for="c-42071236">[-]</label><label class="expand" for="c-42071236">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about enforcement, it&#x27;s about encouragement and path of least resistance. In monorepos the path of least resistance is tight coupling (unless discouraged in other ways). In &#x27;microrepros&#x27; (?) there is added resistance to tight coupling as was presented in the article. This encourages people down the correct path but cannot enforce it (again, as was presented in the article).</div><br/><div id="42072656" class="c"><input type="checkbox" id="c-42072656" checked=""/><div class="controls bullet"><span class="by">MajimasEyepatch</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42071236">parent</a><span>|</span><a href="#42066140">next</a><span>|</span><label class="collapse" for="c-42072656">[-]</label><label class="expand" for="c-42072656">[1 more]</label></div><br/><div class="children"><div class="content">It leads people down a different path, but that&#x27;s not necessarily the correct path. For example, between the lack of discoverability of separate repos and the hurdle of modifying multiple separate repos, teams might be tempted to duplicate functionality and data instead of figuring out the appropriate relationships between services. Some amount of coupling is normal and reasonable. There are ways to manage it well.</div><br/></div></div></div></div></div></div></div></div><div id="42066140" class="c"><input type="checkbox" id="c-42066140" checked=""/><div class="controls bullet"><span class="by">audunw</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42070122">prev</a><span>|</span><a href="#42069618">next</a><span>|</span><label class="collapse" for="c-42066140">[-]</label><label class="expand" for="c-42066140">[7 more]</label></div><br/><div class="children"><div class="content">There’s nothing preventing you from having a single pull request in for merging branches over multiple repos. There’s nothing preventing you from having a parent repo with a lock file that gives you a single linear set of commits tracking the state of multiple repos.<p>That is, if you’re not tied to using just Github of course.<p>Big monorepos and multiple repo solutions require some tooling to deal with scaling issues.<p>What surprises me is the attitude that monorepos are the right solution to these challenges. For some projects it makes sense yes, but it’s clear to me that we should have a solution that allows repositories to be composed&#x2F;combined in elegant ways. Multi-repository pull requests should be a first class feature of any serious source code management system. If you start two projects separately and then later find out you need to combine their history and work with them as if they were one repository, you shouldn’t be forced to restructure the repositories.</div><br/><div id="42066395" class="c"><input type="checkbox" id="c-42066395" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066140">parent</a><span>|</span><a href="#42066283">next</a><span>|</span><label class="collapse" for="c-42066395">[-]</label><label class="expand" for="c-42066395">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; Multi-repository pull requests should be a first class feature of any serious source code management system. 
</code></pre>
But it&#x27;s currently not?<p><pre><code>    &gt; If you start two projects separately and then later find out you need to combine their history and work with them as if they were one repository, you shouldn’t be forced to restructure the repositories.
</code></pre>
It&#x27;s called a directory copy.  Cut + paste.  I&#x27;d add a tag with a comment pointing to the old repo (if needed).  But probably after a few weeks, no one is going to look at the old repo.</div><br/><div id="42069732" class="c"><input type="checkbox" id="c-42069732" checked=""/><div class="controls bullet"><span class="by">dmazzoni</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066395">parent</a><span>|</span><a href="#42066283">next</a><span>|</span><label class="collapse" for="c-42069732">[-]</label><label class="expand" for="c-42069732">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s called a directory copy. Cut + paste. I&#x27;d add a tag with a comment pointing to the old repo (if needed). But probably after a few weeks, no one is going to look at the old repo.<p>Not in my experience. I use &quot;git blame&quot; all the time, and routinely read through commits from many years ago in order to understand why a particular method works the way it does.<p>Luckily, there are many tools for merging git repos into each other while preserving history. It&#x27;s not as simple as copy and paste, but it&#x27;s worth the extra efford.</div><br/></div></div></div></div><div id="42066283" class="c"><input type="checkbox" id="c-42066283" checked=""/><div class="controls bullet"><span class="by">pelletier</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066140">parent</a><span>|</span><a href="#42066395">prev</a><span>|</span><a href="#42069618">next</a><span>|</span><label class="collapse" for="c-42066283">[-]</label><label class="expand" for="c-42066283">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Multi-repository pull requests should be a first class feature of any serious source code management system.<p>Do you have examples of source code management systems that provide this feature and do you have experience with them? repo-centric approach of GitHub often feels limiting.</div><br/><div id="42066883" class="c"><input type="checkbox" id="c-42066883" checked=""/><div class="controls bullet"><span class="by">jvolkman</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066283">parent</a><span>|</span><a href="#42072129">next</a><span>|</span><label class="collapse" for="c-42066883">[-]</label><label class="expand" for="c-42066883">[1 more]</label></div><br/><div class="children"><div class="content">Apparently Gerrit supports this with topics: <a href="https:&#x2F;&#x2F;gerrit-review.googlesource.com&#x2F;Documentation&#x2F;cross-repository-changes.html" rel="nofollow">https:&#x2F;&#x2F;gerrit-review.googlesource.com&#x2F;Documentation&#x2F;cross-r...</a></div><br/></div></div><div id="42072129" class="c"><input type="checkbox" id="c-42072129" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066283">parent</a><span>|</span><a href="#42066883">prev</a><span>|</span><a href="#42069618">next</a><span>|</span><label class="collapse" for="c-42072129">[-]</label><label class="expand" for="c-42072129">[1 more]</label></div><br/><div class="children"><div class="content">At a company I used to be at they used GitHub Enterprise and some repos definitely seemed to have linked repos or linked commits (I don&#x27;t remember exactly but there was some way of linking for repos that depended on each other).</div><br/></div></div></div></div></div></div><div id="42069618" class="c"><input type="checkbox" id="c-42069618" checked=""/><div class="controls bullet"><span class="by">ericyd</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42066140">prev</a><span>|</span><a href="#42074132">next</a><span>|</span><label class="collapse" for="c-42069618">[-]</label><label class="expand" for="c-42069618">[1 more]</label></div><br/><div class="children"><div class="content">I felt the same, the author seemed to downplay the success while every effect listed in the article felt like a huge improvement.</div><br/></div></div><div id="42074132" class="c"><input type="checkbox" id="c-42074132" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42069618">prev</a><span>|</span><a href="#42064679">next</a><span>|</span><label class="collapse" for="c-42074132">[-]</label><label class="expand" for="c-42074132">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; In the previous, separate repository world, this would&#x27;ve been four separate pull requests in four separate repositories, and with comments linking them together for posterity.<p>Tooling issue. Bitbucket will happily link PRs if instructed so.<p>&gt; prevents a lot of mistakes from not having the right revision synced down across different repos.<p>Tooling issue. Depending on setup, &quot;tooling&quot; could be few lines in your favorite scripting language.<p>---<p>Monorepo steps around some tooling issues, but sacrifices access control, checkout speed</div><br/></div></div><div id="42064679" class="c"><input type="checkbox" id="c-42064679" checked=""/><div class="controls bullet"><span class="by">notwhereyouare</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42074132">prev</a><span>|</span><a href="#42067533">next</a><span>|</span><label class="collapse" for="c-42064679">[-]</label><label class="expand" for="c-42064679">[27 more]</label></div><br/><div class="children"><div class="content">ironically was gonna come and comment on that same second block of text.<p>We went from monorepo to multi-repo at work and it&#x27;s been a huge set back and disappointment with the devs because it&#x27;s what our contractors recommended.<p>I&#x27;ve asked for a code deploy and everything and it&#x27;s failed in prod due to a missing check in</div><br/><div id="42064807" class="c"><input type="checkbox" id="c-42064807" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42064679">parent</a><span>|</span><a href="#42066279">next</a><span>|</span><label class="collapse" for="c-42064807">[-]</label><label class="expand" for="c-42064807">[24 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; ...because it&#x27;s what our contractors recommended
</code></pre>
It&#x27;s sad when this happens instead of taking input from the team on how to actually improve productivity&#x2F;quality.<p>A startup I joined started with a multi-repo because the senior team came from a FAANG where this was common practice to have multiple services and a repo for each service.<p>Problem was that it was a startup with one team of 6 devs and each of the pieces was connected by REST APIs.  So now any change to one service required deploying that service and pulling down the OpenAPI spec to regenerate client bindings.  It was so clumsy and easy to make simple mistakes.<p>I refactored the whole thing in one weekend into a monorepo , collapsed the handful of services into one service, and we never looked back.<p>That refactoring and a later paper out of Google actually inspired me to write this article as a practical guide to building a <i>&quot;modular monolith&quot;</i>: <a href="https:&#x2F;&#x2F;chrlschn.dev&#x2F;blog&#x2F;2024&#x2F;01&#x2F;a-practical-guide-to-modular-monoliths&#x2F;" rel="nofollow">https:&#x2F;&#x2F;chrlschn.dev&#x2F;blog&#x2F;2024&#x2F;01&#x2F;a-practical-guide-to-modul...</a></div><br/><div id="42065245" class="c"><input type="checkbox" id="c-42065245" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42064807">parent</a><span>|</span><a href="#42067728">next</a><span>|</span><label class="collapse" for="c-42065245">[-]</label><label class="expand" for="c-42065245">[22 more]</label></div><br/><div class="children"><div class="content">At least google and meta are heavy into monorepos, I&#x27;m really curious what company is using a _repo per service_. That&#x27;s insane.</div><br/><div id="42065834" class="c"><input type="checkbox" id="c-42065834" checked=""/><div class="controls bullet"><span class="by">pc86</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065245">parent</a><span>|</span><a href="#42065838">next</a><span>|</span><label class="collapse" for="c-42065834">[-]</label><label class="expand" for="c-42065834">[2 more]</label></div><br/><div class="children"><div class="content">It can make sense when you have a huge team of devs and different teams responsible for everything where you may be on multiple teams, and nobody is exactly responsible for all the same set of services you are. Depending on the security&#x2F;access provisioning culture of the org, &quot;taking half a day to manually grant access to the repos so-and-so needs access to&quot; may actually be an easier sell than &quot;give everyone access to all our code.&quot;<p>If you just have 20-30 devs and everyone is pretty silo&#x27;d (e.g. frontend or backend, data or API, etc) having 75 repos for your stuff is just silly.</div><br/><div id="42073258" class="c"><input type="checkbox" id="c-42073258" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065834">parent</a><span>|</span><a href="#42065838">next</a><span>|</span><label class="collapse" for="c-42073258">[-]</label><label class="expand" for="c-42073258">[1 more]</label></div><br/><div class="children"><div class="content">Even then, what are the benefits? I understand that sometimes there are conditions that require more repos, like open source components, collaboration with other companies, etc. but when everything is under your control you can basically treat any directory as its own &quot;repository&quot;.</div><br/></div></div></div></div><div id="42065838" class="c"><input type="checkbox" id="c-42065838" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065245">parent</a><span>|</span><a href="#42065834">prev</a><span>|</span><a href="#42065891">next</a><span>|</span><label class="collapse" for="c-42065838">[-]</label><label class="expand" for="c-42065838">[2 more]</label></div><br/><div class="children"><div class="content">Amazon uses &quot;repo per service&quot; and it is semi insane, but Brazil (the big ol&#x27; internal build system) and Coral (the internal service framework) make it &quot;workable&quot;.<p>As someone who worked in the dev tooling org, getting teams to keep their deps up to date was a nightmare.</div><br/><div id="42066034" class="c"><input type="checkbox" id="c-42066034" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065838">parent</a><span>|</span><a href="#42065891">next</a><span>|</span><label class="collapse" for="c-42066034">[-]</label><label class="expand" for="c-42066034">[1 more]</label></div><br/><div class="children"><div class="content">Monorepo and multi repo both have their own need for teams to work on dev tooling when the project gets large.</div><br/></div></div></div></div><div id="42065891" class="c"><input type="checkbox" id="c-42065891" checked=""/><div class="controls bullet"><span class="by">jgtrosh</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065245">parent</a><span>|</span><a href="#42065838">prev</a><span>|</span><a href="#42067716">next</a><span>|</span><label class="collapse" for="c-42065891">[-]</label><label class="expand" for="c-42065891">[2 more]</label></div><br/><div class="children"><div class="content">My team implemented (and reimplemented!) a project using one repo per module. I think the main benefit was ensuring enough separation of concern due to the burden of changing multiple parts together. I managed to reduce something like 10 repos down to 3... Work in progress.</div><br/><div id="42067121" class="c"><input type="checkbox" id="c-42067121" checked=""/><div class="controls bullet"><span class="by">tpm</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065891">parent</a><span>|</span><a href="#42067716">next</a><span>|</span><label class="collapse" for="c-42067121">[-]</label><label class="expand" for="c-42067121">[1 more]</label></div><br/><div class="children"><div class="content">&gt; burden of changing multiple parts together<p>Then you are adapting your project to the properties of code repository. I don&#x27;t see that as a benefit.</div><br/></div></div></div></div><div id="42067716" class="c"><input type="checkbox" id="c-42067716" checked=""/><div class="controls bullet"><span class="by">psoundy</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065245">parent</a><span>|</span><a href="#42065891">prev</a><span>|</span><a href="#42071088">next</a><span>|</span><label class="collapse" for="c-42067716">[-]</label><label class="expand" for="c-42067716">[3 more]</label></div><br/><div class="children"><div class="content">Have you heard of OpenShift 4? Self-hosted Kubernetes by Red Hat. Every little piece of the control plane is its own &#x27;operator&#x27; (basically a microservice) and every operator is developed in its own repo.<p>A github search for &#x27;operator&#x27; in the openshift org has 178 results:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;openshift&#x2F;repositories?language=&amp;q=operator&amp;sort=&amp;type=all">https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;openshift&#x2F;repositories?language=&amp;q=o...</a><p>Not all are repos hosting one or more microservices, but most appear to be. Best of luck ensuring consistency and quality across so many repos.</div><br/><div id="42069420" class="c"><input type="checkbox" id="c-42069420" checked=""/><div class="controls bullet"><span class="by">adra</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42067716">parent</a><span>|</span><a href="#42071088">next</a><span>|</span><label class="collapse" for="c-42069420">[-]</label><label class="expand" for="c-42069420">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just as easy? When you have a monorepo with 5 million lines of code, you&#x27;re only going to focus on the part of the code you care about and forget the rest. Same with 50 repos of 100,000 loc.<p>Enforcing standards means actually having org level mandates around acceptable development standards, and it&#x27;s enforced using tools. Those tools should be just as easily run on one monorepo than 50+  distributed repositories, nay?</div><br/><div id="42070506" class="c"><input type="checkbox" id="c-42070506" checked=""/><div class="controls bullet"><span class="by">psoundy</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42069420">parent</a><span>|</span><a href="#42071088">next</a><span>|</span><label class="collapse" for="c-42070506">[-]</label><label class="expand" for="c-42070506">[1 more]</label></div><br/><div class="children"><div class="content">Even in the best case of what you are describing, how are these tools configured and their configuration maintained except via PRs to the repos in question? For every such change, N PRs having to be proposed, reviewed and merged. And all this without considering the common need (in a healthy project at least) to make cross-cutting changes with similar friction around landing a change across repos.<p>If you wanted to, sure, applying enough time and money could make it work. I like to think that those resources might be better spent, though.</div><br/></div></div></div></div></div></div><div id="42071088" class="c"><input type="checkbox" id="c-42071088" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065245">parent</a><span>|</span><a href="#42067716">prev</a><span>|</span><a href="#42068925">next</a><span>|</span><label class="collapse" for="c-42071088">[-]</label><label class="expand" for="c-42071088">[1 more]</label></div><br/><div class="children"><div class="content">Compared to all the issues with keeping a service running, pushing code to a different repo is trivial. If you think that&#x27;s insane, the insanity is definitively not on the repository separation.</div><br/></div></div><div id="42067710" class="c"><input type="checkbox" id="c-42067710" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065245">parent</a><span>|</span><a href="#42068925">prev</a><span>|</span><a href="#42073757">next</a><span>|</span><label class="collapse" for="c-42067710">[-]</label><label class="expand" for="c-42067710">[4 more]</label></div><br/><div class="children"><div class="content">I worked at a Fortune 1 company that used one repo <i>per release</i> for a certain major software component.</div><br/><div id="42069597" class="c"><input type="checkbox" id="c-42069597" checked=""/><div class="controls bullet"><span class="by">seadan83</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42067710">parent</a><span>|</span><a href="#42068699">next</a><span>|</span><label class="collapse" for="c-42069597">[-]</label><label class="expand" for="c-42069597">[2 more]</label></div><br/><div class="children"><div class="content">Did that work out well at all? Any silver lining? My first thought is: &quot;branches&quot; &amp; &quot;tags&quot; - wow... Would branches&#x2F;tags have just been easier to work with?<p>Were they working with multiple services in a multi-repo? Seems like a cross-product explosion of repos. Did that configuration inhibit releases, or was the process cumbersome but just smooth because it was so rote?</div><br/><div id="42069799" class="c"><input type="checkbox" id="c-42069799" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42069597">parent</a><span>|</span><a href="#42068699">next</a><span>|</span><label class="collapse" for="c-42069799">[-]</label><label class="expand" for="c-42069799">[1 more]</label></div><br/><div class="children"><div class="content">It was a venerable on-prem application done in classic three-tier architecture (VB.NET client, app server, and database). It was deployed on a regular basis to thousands of locations (one deploy per location) and was critical to a business with 11-digit revenue.<p>So yeah, cumbersome, but established, and huge downside risk to messing with the status quo. It was basically Git applied on top of an existing “copy the source” release process.</div><br/></div></div></div></div><div id="42068699" class="c"><input type="checkbox" id="c-42068699" checked=""/><div class="controls bullet"><span class="by">biorach</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42067710">parent</a><span>|</span><a href="#42069597">prev</a><span>|</span><a href="#42073757">next</a><span>|</span><label class="collapse" for="c-42068699">[-]</label><label class="expand" for="c-42068699">[1 more]</label></div><br/><div class="children"><div class="content">was that as insane as it sounds?</div><br/></div></div></div></div><div id="42073757" class="c"><input type="checkbox" id="c-42073757" checked=""/><div class="controls bullet"><span class="by">LaserToy</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065245">parent</a><span>|</span><a href="#42067710">prev</a><span>|</span><a href="#42065663">next</a><span>|</span><label class="collapse" for="c-42073757">[-]</label><label class="expand" for="c-42073757">[1 more]</label></div><br/><div class="children"><div class="content">Amazon</div><br/></div></div><div id="42065663" class="c"><input type="checkbox" id="c-42065663" checked=""/><div class="controls bullet"><span class="by">dewey</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065245">parent</a><span>|</span><a href="#42073757">prev</a><span>|</span><a href="#42067728">next</a><span>|</span><label class="collapse" for="c-42065663">[-]</label><label class="expand" for="c-42065663">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s almost never a good idea to get inspired by what Google &#x2F; Meta &#x2F; Huge Company is doing as most of the times you don&#x27;t have their problems and they have custom toolings and teams making everything work on that scale.</div><br/><div id="42066015" class="c"><input type="checkbox" id="c-42066015" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065663">parent</a><span>|</span><a href="#42070010">next</a><span>|</span><label class="collapse" for="c-42066015">[-]</label><label class="expand" for="c-42066015">[3 more]</label></div><br/><div class="children"><div class="content">In this case, I&#x27;d say it&#x27;s the opposite: monorepo as an approach works amazingly well for small teams all the ways up to huge orgs (with the right tooling to support it).<p>The difference is that past a certain level of complexity, the org will most certainly need specialized tooling to support massive codebases to make CI&#x2F;CD (build, test, deploy, etc.) times sane.<p>On the other hand, multi-repos may work for massive orgs, but is always going to add friction for small orgs.</div><br/><div id="42066066" class="c"><input type="checkbox" id="c-42066066" checked=""/><div class="controls bullet"><span class="by">dewey</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066015">parent</a><span>|</span><a href="#42066892">next</a><span>|</span><label class="collapse" for="c-42066066">[-]</label><label class="expand" for="c-42066066">[1 more]</label></div><br/><div class="children"><div class="content">In this case I wasn&#x27;t even referring to mono repo or not, but more about the idea of taking inspiration from very large companies for your own not-large-company problems.</div><br/></div></div><div id="42066892" class="c"><input type="checkbox" id="c-42066892" checked=""/><div class="controls bullet"><span class="by">influx</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066015">parent</a><span>|</span><a href="#42066066">prev</a><span>|</span><a href="#42070010">next</a><span>|</span><label class="collapse" for="c-42066892">[-]</label><label class="expand" for="c-42066892">[1 more]</label></div><br/><div class="children"><div class="content">I’ve used one of the Meta monorepos (yeah there’s not just one!) and it’s super painful at that scale.</div><br/></div></div></div></div><div id="42070010" class="c"><input type="checkbox" id="c-42070010" checked=""/><div class="controls bullet"><span class="by">aleksiy123</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42065663">parent</a><span>|</span><a href="#42066015">prev</a><span>|</span><a href="#42067728">next</a><span>|</span><label class="collapse" for="c-42070010">[-]</label><label class="expand" for="c-42070010">[1 more]</label></div><br/><div class="children"><div class="content">I feel like this has been repeated so much now that peoples takeaway is that you shouldn&#x27;t adopt anything from large companies as a small company by default. And thats simply not true.<p>The point here is to understand what are the problems that are being solved, understand if they are similar to yours, and make a decision based on wether the tradeoffs are a good fit for you.<p>Not necessarily disagreeing with you but I just feel the pendulum on this statement has swung to far to the other side now.</div><br/></div></div></div></div></div></div><div id="42067728" class="c"><input type="checkbox" id="c-42067728" checked=""/><div class="controls bullet"><span class="by">stackskipton</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42064807">parent</a><span>|</span><a href="#42065245">prev</a><span>|</span><a href="#42066279">next</a><span>|</span><label class="collapse" for="c-42067728">[-]</label><label class="expand" for="c-42067728">[1 more]</label></div><br/><div class="children"><div class="content">&gt;So now any change to one service required deploying that service and pulling down the OpenAPI spec to regenerate client bindings. It was so clumsy and easy to make simple mistakes.<p>Why? Is your framework heavily tied to client bindings? APIs I consume occasionally get new fields added to it for data I don&#x27;t need. My code just ignores it. We also have a policy you cannot add a new mandatory field to API without version bump. So maybe REST API would have new field but I didn&#x27;t send it and it happily didn&#x27;t care.</div><br/></div></div></div></div><div id="42066279" class="c"><input type="checkbox" id="c-42066279" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42064679">parent</a><span>|</span><a href="#42064807">prev</a><span>|</span><a href="#42067533">next</a><span>|</span><label class="collapse" for="c-42066279">[-]</label><label class="expand" for="c-42066279">[2 more]</label></div><br/><div class="children"><div class="content">If prod went down because of a missing check in, there are other problems.</div><br/><div id="42069189" class="c"><input type="checkbox" id="c-42069189" checked=""/><div class="controls bullet"><span class="by">notwhereyouare</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42066279">parent</a><span>|</span><a href="#42067533">next</a><span>|</span><label class="collapse" for="c-42069189">[-]</label><label class="expand" for="c-42069189">[1 more]</label></div><br/><div class="children"><div class="content">did I say prod went down? I just said it failed in prod. it was a logging change and only half the logging went out. To me, that&#x27;s a failure</div><br/></div></div></div></div></div></div><div id="42067533" class="c"><input type="checkbox" id="c-42067533" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42064679">prev</a><span>|</span><a href="#42070436">next</a><span>|</span><label class="collapse" for="c-42067533">[-]</label><label class="expand" for="c-42067533">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not <i>as much</i> of a pain if your tooling supports git repos as dependencies. For example a typical multi-repo PR for us with rust is 1) PR against library 2) PR against application that points dependency to PR&#x27;s branch, makes changes 3) PR review 4) PR 1 is approved and merged 5) PR 2 is changed to point to new master branch of commit 6) PR 2 is approved and merged<p>Same idea if you use some kind of versioning and release system. It&#x27;s still a bit of a pain with all the PRs and coordination involved, but at every step every branch is consistent and buildable, you just check it out and hit build.<p>This is obviously more difficult if you have a more loosely coupled architecture like microservices. But that&#x27;s self-inflicted pain</div><br/></div></div><div id="42070436" class="c"><input type="checkbox" id="c-42070436" checked=""/><div class="controls bullet"><span class="by">Attummm</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42067533">prev</a><span>|</span><a href="#42073808">next</a><span>|</span><label class="collapse" for="c-42070436">[-]</label><label class="expand" for="c-42070436">[6 more]</label></div><br/><div class="children"><div class="content">The issue you faced stemmed from the previous best practice of &quot;everything in its own repository.&quot; This approach caused major issues. Such as versioning challenges and data model inconsistencies you mentioned. The situations it could lead to are comedy sketches, but it&#x27;s a real pain especially when you’re part of a team struggling with these problems. And it’s almost impossible to convince a team to change direction once they’ve committed to it.<p>Now, though, it seems the pendulum has swung in the opposite direction, from “everything in its own repo” to “everything in one repo.” This, too, will create its own set of problems, which also can be comedic, but frustrating to experience.
For instance, what happens when someone accidentally pushes a certificate or API key and you need to force an update upstream? Coordinating that with 50 developers spread across 8 projects, all in a single repo.<p>Instead we could also face the problems we currently  face and start out wirn a balanced approach. Start with one repository, or split frontend and backend if needed. For data pipelines that share models with the API, keep them in the same repository, creating a single source of truth for the data model. This method has often led to other developers telling me about the supposed benefits of “everything in its own repo.” Just as I pushed back then, I feel the  need to push back now against the monorepo trend.<p>The same can be said for monoliths and microservices, where the middle ground is often overlooked in discussions about best practices.<p>They all reminded me of the concept of “no silver bullet”[0]. Any decision will face its own unique challenges. But silver bullet solution can create artificial challenges that are wasteful, painful, and most of all unnecessary.<p>[0]<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;No_Silver_Bullet" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;No_Silver_Bullet</a></div><br/><div id="42071065" class="c"><input type="checkbox" id="c-42071065" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42070436">parent</a><span>|</span><a href="#42073808">next</a><span>|</span><label class="collapse" for="c-42071065">[-]</label><label class="expand" for="c-42071065">[5 more]</label></div><br/><div class="children"><div class="content">&gt; what happens when someone accidentally pushes a certificate or API key and you need to force an update upstream<p>The correct approach here is typically to invalidate the certificate or API key. A force push usually doesn&#x27;t work.<p>If you&#x27;re using GitHub, the dangerous commit lives on effectively forever in an awkward &quot;not in a repository&quot; state. Even if you&#x27;re not on GitHub and your system actually garbage collects, the repo has been cloned onto enough build machines and dev machines that you&#x27;re better off just treating the key or cert as compromised than trying to track down all the places where it might have been copied.</div><br/><div id="42071421" class="c"><input type="checkbox" id="c-42071421" checked=""/><div class="controls bullet"><span class="by">Attummm</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42071065">parent</a><span>|</span><a href="#42073808">next</a><span>|</span><label class="collapse" for="c-42071421">[-]</label><label class="expand" for="c-42071421">[4 more]</label></div><br/><div class="children"><div class="content">The example was just to illustrate a point about a forced push.<p>You’re correct about keys&#x2F;certs once uploaded, they should be treated as compromised, especially when the repository isn’t self-hosted. However, replacing API keys and certificates can take time, and within a large corporation, it could take months.</div><br/><div id="42072071" class="c"><input type="checkbox" id="c-42072071" checked=""/><div class="controls bullet"><span class="by">someone654</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42071421">parent</a><span>|</span><a href="#42071570">next</a><span>|</span><label class="collapse" for="c-42072071">[-]</label><label class="expand" for="c-42072071">[2 more]</label></div><br/><div class="children"><div class="content">Can you find other examples for when force pushing a shared branch is acceptable? I have trouble finding plausible examples for communicating a force push with 50 colleagues.</div><br/><div id="42074886" class="c"><input type="checkbox" id="c-42074886" checked=""/><div class="controls bullet"><span class="by">Attummm</span><span>|</span><a href="#42064636">root</a><span>|</span><a href="#42072071">parent</a><span>|</span><a href="#42071570">next</a><span>|</span><label class="collapse" for="c-42074886">[-]</label><label class="expand" for="c-42074886">[1 more]</label></div><br/><div class="children"><div class="content">API keys and certs must be removed from git even if compromised. Many firms use in-house GitLab, Bitbucket, etc. GitHub has enterprise support for removal of sensitive data.<p>Force pushes occur for various reasons.
Sensitive data includes customer and employee personal info.<p>Other cases involve logs, DB backups, cache, PDFs, configs, and binary files.<p>Maintenance and performance needs form another category.<p>Team dynamics and varying git expertise can lead to accidental or uninformed force pushes, especially challenging in a monorepo with 50+ contributors.<p>In summary, reasons range from personal data (GDPR compliance), security requirements for logs&#x2F;configs, to resolving merge conflicts and performance issues.<p>Your question regarding the need to communicate between 50 or more devs, there was no need but monorepo idea forces unnecessary communication and team effort when none was needed if there would be more repositories.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42073808" class="c"><input type="checkbox" id="c-42073808" checked=""/><div class="controls bullet"><span class="by">throwawayk7h</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42070436">prev</a><span>|</span><a href="#42073742">next</a><span>|</span><label class="collapse" for="c-42073808">[-]</label><label class="expand" for="c-42073808">[1 more]</label></div><br/><div class="children"><div class="content">Why can&#x27;t we have one PR, many repos?</div><br/></div></div><div id="42073742" class="c"><input type="checkbox" id="c-42073742" checked=""/><div class="controls bullet"><span class="by">eduction</span><span>|</span><a href="#42064636">parent</a><span>|</span><a href="#42073808">prev</a><span>|</span><a href="#42070849">next</a><span>|</span><label class="collapse" for="c-42073742">[-]</label><label class="expand" for="c-42073742">[1 more]</label></div><br/><div class="children"><div class="content">Jibes. Not jives. The word is jibes.</div><br/></div></div></div></div><div id="42070849" class="c"><input type="checkbox" id="c-42070849" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42064636">prev</a><span>|</span><a href="#42072395">next</a><span>|</span><label class="collapse" for="c-42070849">[-]</label><label class="expand" for="c-42070849">[11 more]</label></div><br/><div class="children"><div class="content">Every monorepo I&#x27;ve ever met (n=3) has some kind of radioactive DMZ that everybody is afraid to touch because it&#x27;s not clear who owns it but it is clear from its quality that you don&#x27;t want to be the last person who touched it because then maybe somebody will think that you own it.  It&#x27;s usually called &quot;core&quot; or somesuch.<p>Separate repos for each team means that when two teams own components that need to interact, they have to expose a &quot;public&quot; interface to the other team--which is the kind of disciplined engineering work that we should be striving for.  The monorepo-alternative is that you solve it in the DMZ where it feels less like engineering and more like some kind of multiparty political endeavor where PR reviewers of dubious stakeholder status are using the exercise to further agendas which are unrelated to the feature except that it somehow proves them right about whatever architectural point is recently contentious.<p>Plus, it&#x27;s always harder to remove something from the DMZ than to add it, so it&#x27;s always growing and there&#x27;s this sort of gravitational attractor which, eventually starts warping time such that PR&#x27;s take longer to merge the closer they are to it.<p>Better to just do the &quot;hard&quot; work of maintaining versioned interfaces with documented compatibility (backed by tests).  You can always decide to collapse your codebase into a black hole later--but once you start on that path you may never escape.</div><br/><div id="42071215" class="c"><input type="checkbox" id="c-42071215" checked=""/><div class="controls bullet"><span class="by">zaphar</span><span>|</span><a href="#42070849">parent</a><span>|</span><a href="#42073813">next</a><span>|</span><label class="collapse" for="c-42071215">[-]</label><label class="expand" for="c-42071215">[2 more]</label></div><br/><div class="children"><div class="content">Since we are indulging in generalizations from our past. With separate repos you end up with 10 &quot;cores&quot; that are radioctive DMZ&#x27;s everybody is afraid to touch. And those &quot;disciplined&quot; public API&#x27;s will be universally hated by everyone who consumes them.<p>Neither a monorepo nor separate repos will result in people being disciplined. If you already have the discipline to do separate repositories correctly then you&#x27;ll be fine with a monorepo.<p>So I guess it&#x27;s six on one hand, half dozen in the other.</div><br/><div id="42071665" class="c"><input type="checkbox" id="c-42071665" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42070849">root</a><span>|</span><a href="#42071215">parent</a><span>|</span><a href="#42073813">next</a><span>|</span><label class="collapse" for="c-42071665">[-]</label><label class="expand" for="c-42071665">[1 more]</label></div><br/><div class="children"><div class="content">No I think there&#x27;s a clear difference.  I&#x27;ve seen this several times:  Somebody changes teams and now they&#x27;re no longer responsible for a bit of code, but then they learn that it is broken in some way, and now they&#x27;re sneaking in commits that--on paper--should now be handled by somebody else.<p>Dev&#x27;s *like* to feel ownership of reasonably sized chunks of code.  We like to arrange it in ways that is pleasing for us to work on later down the road.  And once we&#x27;ve made those investments, we like to see them pay off by making quick easy changes that make users happy.  Sharing a small codebase with three or four other people and finding ways to make each other&#x27;s lives easier while supporting it is *fun* and it makes for better code too.<p>But it only stays fun if you have enough autonomy that you can really own it--you and your small team.  Footguns introduced need to be pointed at your feet. Automation introduced needs to save you time.  If you&#x27;ve got the preferences of 50 other people to consider, and you know that whatever you do you&#x27;re going to piss off some 10 of them or another... the fun goes away.<p>This is simple:<p>&gt; we own this whole repo and only this 10% of it (the public interface) needs to make external stakeholders happy, otherwise we just care about making each other happy.<p>...and it has no space in it for there to be any code which is not clearly owned by somebody.  In a monorepo, there are plenty of places for that.</div><br/></div></div></div></div><div id="42073813" class="c"><input type="checkbox" id="c-42073813" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#42070849">parent</a><span>|</span><a href="#42071215">prev</a><span>|</span><a href="#42071587">next</a><span>|</span><label class="collapse" for="c-42073813">[-]</label><label class="expand" for="c-42073813">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Separate repos for each team means that when two teams own components that need to interact, they have to expose a &quot;public&quot; interface to the other team--which is the kind of disciplined engineering work that we should be striving for.<p>This pattern has its own set of problems. Strict ownerships separation creates strong dependencies and capacity constraints on the project organization. A single team is rarely able to deliver a complete feature, because it will mean changes in a couple of services. If you go with a model where teams are allowed to build features in &quot;foreign&quot; services, you will still come to the situation that the owning team doesn&#x27;t feel that responsible for something they haven&#x27;t built &#x2F; don&#x27;t really understand. You can tweak it, involve the owning team more etc. but it has trade-offs &#x2F; friction.<p>The worst anti-pattern coming from this is &quot;we have dependency on service X &#x2F; team Y, but their code reviews are usually very long and pedantic, threatening our delivery. Can we do it locally in our service instead?&quot; which results in people putting stuff where it doesn&#x27;t belong, for organisational reasons.</div><br/><div id="42074171" class="c"><input type="checkbox" id="c-42074171" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42070849">root</a><span>|</span><a href="#42073813">parent</a><span>|</span><a href="#42071587">next</a><span>|</span><label class="collapse" for="c-42074171">[-]</label><label class="expand" for="c-42074171">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not saying that the ownership should be strict, you should feel free to submit PRs to my repo, and I to yours.<p>I just don&#x27;t want there to be a no-man&#x27;s-land.  And if there must be an every-mans-land, let it be explicitly so, not some pile of stuff that didn&#x27;t fit anywhere else.</div><br/><div id="42074672" class="c"><input type="checkbox" id="c-42074672" checked=""/><div class="controls bullet"><span class="by">jatins</span><span>|</span><a href="#42070849">root</a><span>|</span><a href="#42074171">parent</a><span>|</span><a href="#42071587">next</a><span>|</span><label class="collapse" for="c-42074672">[-]</label><label class="expand" for="c-42074672">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you should feel free to submit PRs to my repo, and I to yours<p>Haven&#x27;t seen it happen in practice. For some reason a separate repo induces more of &quot;not my backyard&quot; feeling that a separate folder</div><br/></div></div></div></div></div></div><div id="42071587" class="c"><input type="checkbox" id="c-42071587" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#42070849">parent</a><span>|</span><a href="#42073813">prev</a><span>|</span><a href="#42074344">next</a><span>|</span><label class="collapse" for="c-42071587">[-]</label><label class="expand" for="c-42071587">[1 more]</label></div><br/><div class="children"><div class="content">I would advise annotating your experience anecdotes, which are surely valuable, with some information about team size, company size, corporate structure (tech team in a non tech corp, vs pure tech), age etc.<p>The meat is in the detail, I find.</div><br/></div></div><div id="42074344" class="c"><input type="checkbox" id="c-42074344" checked=""/><div class="controls bullet"><span class="by">materielle</span><span>|</span><a href="#42070849">parent</a><span>|</span><a href="#42071587">prev</a><span>|</span><a href="#42071606">next</a><span>|</span><label class="collapse" for="c-42074344">[-]</label><label class="expand" for="c-42074344">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that DRY principles have be cargo culted way past the point of being useful.<p>People see two pieces of duplicate, or even similar code in a monorepo, and they feel the urge create some sort of shared directory to de duplicate them. The problem, is this introduces more edges to your graph, which over time increases the monorepo complexity exponentially. And who is going to maintain that shared directory?<p>Even in a mono-repo, you should probably start off by copy and pasting code around, until you figure out how to design and find ownership for an actual well thought through public api. And maybe for some code, that never happens.<p>Also, like many things, people cargo cult big tech ideas without understanding why they work. In Google, the monorepo has two key features: 1) every directory has an owner by default 2) the owner can control build target visibility lists.<p>That means that the ownership team controls who depends on them. By default, everything is private.<p>Basically, every directory should either be a project, owned by a team. Or some common library code, owned by the library maintainers.<p>The other thing, is library maintainers need to be discerning with what APIs and code they support. Again, a common refrain I here is “when it doubt, it’s better to put it in the company’s common library to promote code reuse”. That’s the exact wrong way to think about it. Library teams should be very careful about what APIs they support because they will be on the hook maintaining them forever.<p>This is all to say, I can see how monorepos fail. Because people cherry-pick the ideas they like, but ignore the important things which make them work at Google: 1) default code owners 2) visibility lists that default to private 3) discerning library teams that aggressively reject code additions 4) don’t be too dry, if it can’t be exposed in a public api, just copy and paste, just like you would in a microservice.</div><br/></div></div><div id="42071606" class="c"><input type="checkbox" id="c-42071606" checked=""/><div class="controls bullet"><span class="by">Boxxed</span><span>|</span><a href="#42070849">parent</a><span>|</span><a href="#42074344">prev</a><span>|</span><a href="#42072592">next</a><span>|</span><label class="collapse" for="c-42071606">[-]</label><label class="expand" for="c-42071606">[1 more]</label></div><br/><div class="children"><div class="content">You can have well-defined interfaces without splitting it into many repos just like how you can have well-defined interfaces without splitting it into microservices. In fact, I&#x27;ve seen enough garbage to know that forcing the issue via these mechanisms just makes bad software worse.</div><br/></div></div><div id="42072592" class="c"><input type="checkbox" id="c-42072592" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#42070849">parent</a><span>|</span><a href="#42071606">prev</a><span>|</span><a href="#42072395">next</a><span>|</span><label class="collapse" for="c-42072592">[-]</label><label class="expand" for="c-42072592">[2 more]</label></div><br/><div class="children"><div class="content">Code ownership is a scam</div><br/><div id="42072927" class="c"><input type="checkbox" id="c-42072927" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42070849">root</a><span>|</span><a href="#42072592">parent</a><span>|</span><a href="#42072395">next</a><span>|</span><label class="collapse" for="c-42072927">[-]</label><label class="expand" for="c-42072927">[1 more]</label></div><br/><div class="children"><div class="content">Only when somebody else pushes it on you.</div><br/></div></div></div></div></div></div><div id="42072395" class="c"><input type="checkbox" id="c-42072395" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42070849">prev</a><span>|</span><a href="#42071662">next</a><span>|</span><label class="collapse" for="c-42072395">[-]</label><label class="expand" for="c-42072395">[2 more]</label></div><br/><div class="children"><div class="content">The #1 benefit for me regarding the monorepo strategy is that when someone on the team refers to a commit hash, there is exactly one place to go and it provides a consistent point-in-time snapshot of <i>everything</i>. Ideally, all of the commits on master are ~good, so you have approximately a perfect time machine to work with.<p>I have solved more bugs looking at diffs in GitHub than I have in my debugger simply by having everything in one happy scrolly view. Being able to flick my mouse wheel a few clicks and confirm that the schema does indeed align with the new DTO model props has saved me countless hours. Confirming stuff like this across multiple repos &amp; commits can encourage a more lackadaisical approach. This also dramatically simplifies things like ORM migrations, especially if you require that all branches rebase &amp; pass tests before merging.<p>I agree with most of the hypothetical caveats, but if you can overcome them even with some mild degree of suffering, I don&#x27;t see why you wouldn&#x27;t fight for it.</div><br/><div id="42072967" class="c"><input type="checkbox" id="c-42072967" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#42072395">parent</a><span>|</span><a href="#42071662">next</a><span>|</span><label class="collapse" for="c-42072967">[-]</label><label class="expand" for="c-42072967">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen teams take this even further and vendor all dependencies.<p>This way a commit hash contains even the exact third party code involved.</div><br/></div></div></div></div><div id="42071662" class="c"><input type="checkbox" id="c-42071662" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#42072395">prev</a><span>|</span><a href="#42069502">next</a><span>|</span><label class="collapse" for="c-42071662">[-]</label><label class="expand" for="c-42071662">[1 more]</label></div><br/><div class="children"><div class="content">Repository boundaries are affected far more by the social structure of your organisation than anything technical.<p>Do you want hard boundaries between teams — clear responsibilities with formal ceremony across boundaries, but at the expense of living with inflexibility?<p>Do you want fluidity in engineering, without fixed silos and a flat org structure that encourages anyone to take on anything that’s important to the business right now, but with the much bigger overhead of needing strong people leaders capable of herding the chaos?<p>I’m sure there are dozens of other examples of org structures and how they are reflected in code layout, repo layout, shared directories, dropboxes, chat channels, and email groups etc.</div><br/></div></div><div id="42069502" class="c"><input type="checkbox" id="c-42069502" checked=""/><div class="controls bullet"><span class="by">msoad</span><span>|</span><a href="#42071662">prev</a><span>|</span><a href="#42064563">next</a><span>|</span><label class="collapse" for="c-42069502">[-]</label><label class="expand" for="c-42069502">[6 more]</label></div><br/><div class="children"><div class="content">I love monorepos but I&#x27;m not sure if Git is the right tool beyond certain scale. Where I work doing a simple `git status` takes seconds due to the size of the repo. There has been various attempts to solve Git performance but so far this is nothing close to what I experienced at Google.<p>The Git team should really invest in tooling for very large repos. Our repo is around 10M files and 100M lines of code and no amount of hacks on top of Git (cache, sparse checkout etc etc) is not really solving the core problem.<p>Meta and Google have really solved this problem internally but there is no real open source solution that works for everyone out there.</div><br/><div id="42069761" class="c"><input type="checkbox" id="c-42069761" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42069502">parent</a><span>|</span><a href="#42071713">next</a><span>|</span><label class="collapse" for="c-42069761">[-]</label><label class="expand" for="c-42069761">[3 more]</label></div><br/><div class="children"><div class="content">I’m secretly hoping that google releases piper (and Mondrian); the gaming industry would go wild.<p>Perforce is pretty brutal, and the code review tools are awful - but its still the undisputed king of mixed text and binary assets in a huge monorepo.</div><br/><div id="42073162" class="c"><input type="checkbox" id="c-42073162" checked=""/><div class="controls bullet"><span class="by">habosa</span><span>|</span><a href="#42069502">root</a><span>|</span><a href="#42069761">parent</a><span>|</span><a href="#42073936">next</a><span>|</span><label class="collapse" for="c-42073162">[-]</label><label class="expand" for="c-42073162">[1 more]</label></div><br/><div class="children"><div class="content">Mondrian! That’s a name I haven’t heard in a while. Google uses Critique for code review these days.<p>I tried to bring the best of Critique to GitHub with <a href="https:&#x2F;&#x2F;codeapprove.com" rel="nofollow">https:&#x2F;&#x2F;codeapprove.com</a> but you’re right there’s a lot that just doesn’t work on top of git.</div><br/></div></div><div id="42073936" class="c"><input type="checkbox" id="c-42073936" checked=""/><div class="controls bullet"><span class="by">ralph84</span><span>|</span><a href="#42069502">root</a><span>|</span><a href="#42069761">parent</a><span>|</span><a href="#42073162">prev</a><span>|</span><a href="#42071713">next</a><span>|</span><label class="collapse" for="c-42073936">[-]</label><label class="expand" for="c-42073936">[1 more]</label></div><br/><div class="children"><div class="content">There were rumors that at one point piper included source code licensed from Perforce. That could make open sourcing it more difficult if any of that code is still hanging around.</div><br/></div></div></div></div><div id="42071713" class="c"><input type="checkbox" id="c-42071713" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42069502">parent</a><span>|</span><a href="#42069761">prev</a><span>|</span><a href="#42072284">next</a><span>|</span><label class="collapse" for="c-42071713">[-]</label><label class="expand" for="c-42071713">[1 more]</label></div><br/><div class="children"><div class="content">Meta open-sourced their complete stack: <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;sapling">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;sapling</a><p>Microsoft released Scalar (<a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;scalar">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;scalar</a>) although it&#x27;s not a complete stack yet but it is already planning on releasing the backend components eventually.<p>Have you tried Sapling? It has EdenFS baked in so it&#x27;ll only materialize the files you touch and operations are fast because it has a filesystem watcher for activity so it doesn&#x27;t need to do a lot of work to maintain a view of what has been invalidated.</div><br/></div></div><div id="42072284" class="c"><input type="checkbox" id="c-42072284" checked=""/><div class="controls bullet"><span class="by">brown9-2</span><span>|</span><a href="#42069502">parent</a><span>|</span><a href="#42071713">prev</a><span>|</span><a href="#42064563">next</a><span>|</span><label class="collapse" for="c-42072284">[-]</label><label class="expand" for="c-42072284">[1 more]</label></div><br/><div class="children"><div class="content">fsmonitor and untrackedCache doesn’t help?</div><br/></div></div></div></div><div id="42064563" class="c"><input type="checkbox" id="c-42064563" checked=""/><div class="controls bullet"><span class="by">xyzzy_plugh</span><span>|</span><a href="#42069502">prev</a><span>|</span><a href="#42071365">next</a><span>|</span><label class="collapse" for="c-42064563">[-]</label><label class="expand" for="c-42064563">[4 more]</label></div><br/><div class="children"><div class="content">Without indicating my personal feelings on monorepo vs polyrepo, or expressing any thoughts about the experience shared here, I would like to point out that open-source projects have different and sometimes conflicting needs compared to proprietary closed-source projects. The best solution for one is sometimes the extreme opposite for the other.<p>In particular many build pipelines involving private sources or artifacts become drastically more complicated than their those of publicly available counterparts.</div><br/><div id="42069098" class="c"><input type="checkbox" id="c-42069098" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#42064563">parent</a><span>|</span><a href="#42071212">next</a><span>|</span><label class="collapse" for="c-42069098">[-]</label><label class="expand" for="c-42069098">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also seen this with branching strategies. IMO the best branching strategy for open source projects is generally the worst one for commercial projects, and vice versa.</div><br/><div id="42074495" class="c"><input type="checkbox" id="c-42074495" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42064563">root</a><span>|</span><a href="#42069098">parent</a><span>|</span><a href="#42071212">next</a><span>|</span><label class="collapse" for="c-42074495">[-]</label><label class="expand" for="c-42074495">[1 more]</label></div><br/><div class="children"><div class="content">Which strategies are you assigning to each?</div><br/></div></div></div></div><div id="42071212" class="c"><input type="checkbox" id="c-42071212" checked=""/><div class="controls bullet"><span class="by">b5hi</span><span>|</span><a href="#42064563">parent</a><span>|</span><a href="#42069098">prev</a><span>|</span><a href="#42071365">next</a><span>|</span><label class="collapse" for="c-42071212">[-]</label><label class="expand" for="c-42071212">[1 more]</label></div><br/><div class="children"><div class="content">this should be the top comment</div><br/></div></div></div></div><div id="42071365" class="c"><input type="checkbox" id="c-42071365" checked=""/><div class="controls bullet"><span class="by">alphazard</span><span>|</span><a href="#42064563">prev</a><span>|</span><a href="#42066976">next</a><span>|</span><label class="collapse" for="c-42071365">[-]</label><label class="expand" for="c-42071365">[1 more]</label></div><br/><div class="children"><div class="content">The classic micro&#x2F;multi repo mistake is reaching for more repos when you really need better tooling and permissions on single repo.  People have probably wasted millions of engineer-hours across the industry with multiple repos, all because GitHub doesn&#x27;t have expressive path-level permissions.</div><br/></div></div><div id="42066976" class="c"><input type="checkbox" id="c-42066976" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#42071365">prev</a><span>|</span><a href="#42073582">next</a><span>|</span><label class="collapse" for="c-42066976">[-]</label><label class="expand" for="c-42066976">[4 more]</label></div><br/><div class="children"><div class="content">Doing modular right is harder than doing monolithic right.<p>But if you do it right, the advantage you get is that you get to pick which versions of your dependencies you use; while quite often you just want to use the latest, being able to pin is also very useful.</div><br/><div id="42067217" class="c"><input type="checkbox" id="c-42067217" checked=""/><div class="controls bullet"><span class="by">lukewink</span><span>|</span><a href="#42066976">parent</a><span>|</span><a href="#42072294">next</a><span>|</span><label class="collapse" for="c-42067217">[-]</label><label class="expand" for="c-42067217">[2 more]</label></div><br/><div class="children"><div class="content">You can still publish packages and pull them down as (pinned) dependencies all within a monorepo.</div><br/><div id="42069615" class="c"><input type="checkbox" id="c-42069615" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#42066976">root</a><span>|</span><a href="#42067217">parent</a><span>|</span><a href="#42072294">next</a><span>|</span><label class="collapse" for="c-42069615">[-]</label><label class="expand" for="c-42069615">[1 more]</label></div><br/><div class="children"><div class="content">that&#x27;s a terrible and arguably broken-by-design workflow which entirely defeats the point of the monorepo, which is to have a unified build of everything together, rather than building things piecemeal in ways that could be incompatible.<p>For C++ in particular, you need to express your dependencies in terms of source versions, and ensure all of the build artifacts you link together were built against the same source version of every transitive dependency and with the same flags. Failure to do that results in undefined behaviour, and indeed I have seen large organizations with unreliable builds as a manner of routine because of that.<p>The best way to achieve that is to just build the whole thing from source, with a content-addressable-store shared with the whole organization to transparently avoid building redundant things. Whether your source is in a single repo or spread over several doesn&#x27;t matter so long as your tooling manages that for you and knows where to get things, but ultimately the right way to do modular is simply to synthesize the equivalent monorepo and build that.
Sometimes there is the requirement that specific sources should have restricted access, which is often a reason why people avoid building from source, but that&#x27;s easy to work around by building on remote agents.<p>Now for some reason there is no good open-source build system for C++, while Rust mostly got it right on the first try.
Maybe it&#x27;s because there are some C++ users still attached to the notion of manually managing ABI.</div><br/></div></div></div></div><div id="42072294" class="c"><input type="checkbox" id="c-42072294" checked=""/><div class="controls bullet"><span class="by">move-on-by</span><span>|</span><a href="#42066976">parent</a><span>|</span><a href="#42067217">prev</a><span>|</span><a href="#42073582">next</a><span>|</span><label class="collapse" for="c-42072294">[-]</label><label class="expand" for="c-42072294">[1 more]</label></div><br/><div class="children"><div class="content">This is something I’ve been preaching at work and it just falls on deaf ears. We aren’t even doing a great job with monolithic, why people think modular is going to _improve_ things is beyond my comprehension. I’ve pretty much decided no one actually cares and they just see it as an opportunity for résumé building. Someone want to enlighten me?</div><br/></div></div></div></div><div id="42073582" class="c"><input type="checkbox" id="c-42073582" checked=""/><div class="controls bullet"><span class="by">LunicLynx</span><span>|</span><a href="#42066976">prev</a><span>|</span><a href="#42067638">next</a><span>|</span><label class="collapse" for="c-42073582">[-]</label><label class="expand" for="c-42073582">[1 more]</label></div><br/><div class="children"><div class="content">There is only one concept of a monorepo. And that is the google approach. This is a project repo and in a project repo things should stay together.<p>Your tooling must be different for it to work.<p>So using git for it will not have a positive result.</div><br/></div></div><div id="42067638" class="c"><input type="checkbox" id="c-42067638" checked=""/><div class="controls bullet"><span class="by">stackskipton</span><span>|</span><a href="#42073582">prev</a><span>|</span><a href="#42073734">next</a><span>|</span><label class="collapse" for="c-42067638">[-]</label><label class="expand" for="c-42067638">[1 more]</label></div><br/><div class="children"><div class="content">As DevOps&#x2F;SRE type person that occasionally gets stuck with builds, Monorepos world well if company will invest in the build process. However, many companies don&#x27;t do well in this area and Monorepo blast radius becomes much bigger so individual repos it is. Also, depending on the language, building private repo is easy enough to keep all common libraries in.</div><br/></div></div><div id="42073734" class="c"><input type="checkbox" id="c-42073734" checked=""/><div class="controls bullet"><span class="by">ofrzeta</span><span>|</span><a href="#42067638">prev</a><span>|</span><a href="#42064553">next</a><span>|</span><label class="collapse" for="c-42073734">[-]</label><label class="expand" for="c-42073734">[1 more]</label></div><br/><div class="children"><div class="content">I am not convinced Git submodules are so bad. Obviously it&#x27;s a bit more work than a monorepo but it actually works quite nice to have the parent repo pin the commits of the submodules. So you can just update, say, the &quot;frontend&quot; when fixing a bug, update the submodule and commit the hash to the parent. lgtm.</div><br/></div></div><div id="42064553" class="c"><input type="checkbox" id="c-42064553" checked=""/><div class="controls bullet"><span class="by">siva7</span><span>|</span><a href="#42073734">prev</a><span>|</span><a href="#42065042">next</a><span>|</span><label class="collapse" for="c-42064553">[-]</label><label class="expand" for="c-42064553">[22 more]</label></div><br/><div class="children"><div class="content">Ok, but the more interesting part - how did you solve the CI&#x2F;CD part and how does it compare to a multirepo?</div><br/><div id="42064903" class="c"><input type="checkbox" id="c-42064903" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42064553">parent</a><span>|</span><a href="#42064722">next</a><span>|</span><label class="collapse" for="c-42064903">[-]</label><label class="expand" for="c-42064903">[8 more]</label></div><br/><div class="children"><div class="content">I don’t think CI&#x2F;CD should really be a big worry as far as mono-repositories go as you can setup different pipelines and different flows with different configurations. Something you’re probably already doing if you have multiple repos.<p>In my experience the article is right when it tells you there isn’t that big of a difference. We have all sorts of repositories, some of which are basically mono-repositories for their business domain. We tend to separate where it “makes sense” which for us means that it’s when what we put into repositories is completely separate from everything else. We used to have a lot of micro-repositories and it wasn’t that different to be honest. We grouped more of them together to make it easier for us to be DORA compliant in terms of the bureaucracy it adds to your documentation burden. Technically I hardly notice.</div><br/><div id="42065239" class="c"><input type="checkbox" id="c-42065239" checked=""/><div class="controls bullet"><span class="by">JamesSwift</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42064903">parent</a><span>|</span><a href="#42064722">next</a><span>|</span><label class="collapse" for="c-42065239">[-]</label><label class="expand" for="c-42065239">[7 more]</label></div><br/><div class="children"><div class="content">In my limited-but-not-nothing experience working with mono vs multi repo of the same projects, CI&#x2F;CD definitely was one of the harder pieces to solve. Its highly dependent on your frameworks and CI provider on just how straightforward it is going to be, and most of them are &quot;not very straightforward&quot;.<p>The basic way most work is to run full CI on every change. This quickly becomes a huge speedbump to deployment velocity until a solution for &quot;only run what is affected&quot; is found.</div><br/><div id="42066299" class="c"><input type="checkbox" id="c-42066299" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42065239">parent</a><span>|</span><a href="#42066138">next</a><span>|</span><label class="collapse" for="c-42066299">[-]</label><label class="expand" for="c-42066299">[3 more]</label></div><br/><div class="children"><div class="content">Which CI&#x2F;CD pipelines have you had issues with? Because that isn’t my experience at all. With both GitHub (also Azure DevOps) and gitlab you can separate your pipelines with configurations like .gitlab-ci.yml. I guess it can be non-trivial to setup proper parallelisation when you have a lot of build stages if this isn’t something you’re familiar with. A lot of other more self-hosted tools like Gradle, RushJS and many others you can setup configurations which does X if Y and make sure only to run things which are necessary.<p>I don’t want to be rude, but a lot of these tools have rather accessible documentation on how to get up and running as well as extensive documentation for more complex challenges available in their official docs. Which is probably the, only, place you’ll find good ways of working with it because a lot of the search engine and LLM “solutions” will range from horrible to outdated.<p>It can be both slower and faster than micro-repositories in my experience, however, you’re right that it can indeed be a Cthulhu level speed bump if you do it wrong.</div><br/><div id="42067086" class="c"><input type="checkbox" id="c-42067086" checked=""/><div class="controls bullet"><span class="by">JamesSwift</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42066299">parent</a><span>|</span><a href="#42066138">next</a><span>|</span><label class="collapse" for="c-42067086">[-]</label><label class="expand" for="c-42067086">[2 more]</label></div><br/><div class="children"><div class="content">I implied but didnt explicitly mention that I&#x27;m talking from the context of moving _from_ existing polyrepo _to_ monorepo. The tooling is out there to walk a more happy-path experience if you jump in on day 1 (or early in the product lifecycle). But its much harder to migrate to it and not have to redo a bunch of CI-related tooling.</div><br/><div id="42074475" class="c"><input type="checkbox" id="c-42074475" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42067086">parent</a><span>|</span><a href="#42066138">next</a><span>|</span><label class="collapse" for="c-42074475">[-]</label><label class="expand" for="c-42074475">[1 more]</label></div><br/><div class="children"><div class="content">Oh, fair enough. It’ll depend on the situation of course. We didn’t have they much of an issue as we already had the CI&#x2F;CD pipelines for the single projects which mean we could merge multiple of them into a single project fairly easily. But as you say that’s us, we could have easily faced a situation where it would be a complete rebuild of everything if we’d used something like the Azure DevOps “drag and drop” configurations in their web gui.</div><br/></div></div></div></div></div></div><div id="42066138" class="c"><input type="checkbox" id="c-42066138" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42065239">parent</a><span>|</span><a href="#42066299">prev</a><span>|</span><a href="#42064722">next</a><span>|</span><label class="collapse" for="c-42066138">[-]</label><label class="expand" for="c-42066138">[3 more]</label></div><br/><div class="children"><div class="content">The problem with &quot;only run what is affected&quot; is it is really easy to have something that is affected but doesn&#x27;t seem like it should be (that is whatever tools you have to detect is it affected say it isn&#x27;t).  So if you have such a system you must have regular rebuild everything jobs as well to verify you didn&#x27;t break something unexpected.<p>I&#x27;m not against only run what is affected, it is a good answer.  It just has failings that you need to be aware of.</div><br/><div id="42067059" class="c"><input type="checkbox" id="c-42067059" checked=""/><div class="controls bullet"><span class="by">JamesSwift</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42066138">parent</a><span>|</span><a href="#42064722">next</a><span>|</span><label class="collapse" for="c-42067059">[-]</label><label class="expand" for="c-42067059">[2 more]</label></div><br/><div class="children"><div class="content">Yeah thats a good point. Especially for an overly-dynamic runtime like ruby&#x2F;rails, theres just not usually a clean way to cordon off sections of code. On the other hand, using nx in an angular project was pretty amazing.</div><br/><div id="42068448" class="c"><input type="checkbox" id="c-42068448" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42067059">parent</a><span>|</span><a href="#42064722">next</a><span>|</span><label class="collapse" for="c-42068448">[-]</label><label class="expand" for="c-42068448">[1 more]</label></div><br/><div class="children"><div class="content">Even in something like C++ you often have configuration, startup scripts (I&#x27;m in embedded, maybe this isn&#x27;t a think elsewhere), database schemas, and other such things that the code depends on but it isn&#x27;t obvious to the build system that the dependency exists.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42064722" class="c"><input type="checkbox" id="c-42064722" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42064553">parent</a><span>|</span><a href="#42064903">prev</a><span>|</span><a href="#42073167">next</a><span>|</span><label class="collapse" for="c-42064722">[-]</label><label class="expand" for="c-42064722">[10 more]</label></div><br/><div class="children"><div class="content">Most CI&#x2F;CD platforms will allow specification of targeted triggers.<p>For example, in GitHub[0]:<p><pre><code>    name: &quot;.NET - PR Unit Test&quot;
    
    on:
      ## Only execute these unit tests when a file in this directory changes.
      pull_request:
        branches: [main]
        paths: [src&#x2F;services&#x2F;publishing&#x2F;**.cs, src&#x2F;tests&#x2F;unit&#x2F;**.cs]
</code></pre>
So we set up different workflows that kick off based on the sets of files that change.<p>[0] <a href="https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;actions&#x2F;writing-workflows&#x2F;workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore" rel="nofollow">https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;actions&#x2F;writing-workflows&#x2F;workflo...</a></div><br/><div id="42065201" class="c"><input type="checkbox" id="c-42065201" checked=""/><div class="controls bullet"><span class="by">victorNicollet</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42064722">parent</a><span>|</span><a href="#42065942">next</a><span>|</span><label class="collapse" for="c-42065201">[-]</label><label class="expand" for="c-42065201">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with GitHub Actions, but we reverted our migration to Bitbucket Pipelines because of a nasty side-effect of conditional execution: if a commit triggers test suite T1 but not T2, and T1 is successful, Bitbucket displays that commit with a green &quot;everything is fine&quot; check mark, regardless of the status of T2 on any ancestors of that commit.<p>That is, the green check mark means &quot;the changes in this commit did not break anything that was not already broken&quot;, as opposed to the more useful &quot;the repository, as of this commit, passes all tests&quot;.</div><br/><div id="42066039" class="c"><input type="checkbox" id="c-42066039" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42065201">parent</a><span>|</span><a href="#42065802">next</a><span>|</span><label class="collapse" for="c-42066039">[-]</label><label class="expand" for="c-42066039">[4 more]</label></div><br/><div class="children"><div class="content">I would find it extremely confusing and unhelpful if tests in the parent commit which weren&#x27;t rerun for a PR because nothing relevant was touched marked the PR as red. Why would you even want that? That&#x27;s not something which is relevant to evaluating the PR and would make you get in the habit of ignoring failures.<p>If you split something into multiple repositories then surely you wouldn&#x27;t mark PRs on one of them as red just because tests are failing in a different one?</div><br/><div id="42069368" class="c"><input type="checkbox" id="c-42069368" checked=""/><div class="controls bullet"><span class="by">victorNicollet</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42066039">parent</a><span>|</span><a href="#42065802">next</a><span>|</span><label class="collapse" for="c-42069368">[-]</label><label class="expand" for="c-42069368">[3 more]</label></div><br/><div class="children"><div class="content">I suppose our development process is a bit unusual.<p>The meaning we give to &quot;the commit is green&quot; is not &quot;this PR can be merged&quot; but &quot;this can be deployed to production&quot;, and it is used for the purpose of selecting a release candidate several times a week. It is a statement about the entire state of the project as of that commit, rather than just the changes introduced in that commit.<p>I can understand the frustration of creating a PR from a red commit on the main branch, and having that PR be red as well as a result. I can&#x27;t say this has happened very often, though: red commits on the main branch are very rare, and new branches tend to be started right after a deployment, so it&#x27;s overwhelmingly likely that the PR will be rooted at a green commit. When it does happen, the time it takes to push a fix (or a revert) to the main branch is usually much shorter than the time for a review of the PR, which means it is possible to rebase the PR on top of a green commit as part of the normal PR acceptance timeline.</div><br/><div id="42069785" class="c"><input type="checkbox" id="c-42069785" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42069368">parent</a><span>|</span><a href="#42065802">next</a><span>|</span><label class="collapse" for="c-42069785">[-]</label><label class="expand" for="c-42069785">[2 more]</label></div><br/><div class="children"><div class="content">Going off the PR status to determine if the end result is deployable is not reliable. A non-FF merge can have both the base commit and the PR be green but the merged result fail. You need to run your full test suite on the merged result at some point before deployment; either via a commit queue or post-merge testing.</div><br/><div id="42070383" class="c"><input type="checkbox" id="c-42070383" checked=""/><div class="controls bullet"><span class="by">victorNicollet</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42069785">parent</a><span>|</span><a href="#42065802">next</a><span>|</span><label class="collapse" for="c-42070383">[-]</label><label class="expand" for="c-42070383">[1 more]</label></div><br/><div class="children"><div class="content">I agree ! We use the commit status instead of the PR status. A non-FF merge commit, being a commit, would have its own status separate from the status of its parents.</div><br/></div></div></div></div></div></div></div></div><div id="42065802" class="c"><input type="checkbox" id="c-42065802" checked=""/><div class="controls bullet"><span class="by">ants_everywhere</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42065201">parent</a><span>|</span><a href="#42066039">prev</a><span>|</span><a href="#42065967">next</a><span>|</span><label class="collapse" for="c-42065802">[-]</label><label class="expand" for="c-42065802">[1 more]</label></div><br/><div class="children"><div class="content">isn&#x27;t that generally what you want? the check mark tells you the commit didn&#x27;t break anything. if something was already broken it should have either blocked the commit that broke it or there&#x27;s a flake somewhere that you can only locate by periodically running tests independent of any PR activity.</div><br/></div></div><div id="42065967" class="c"><input type="checkbox" id="c-42065967" checked=""/><div class="controls bullet"><span class="by">daelon</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42065201">parent</a><span>|</span><a href="#42065802">prev</a><span>|</span><a href="#42065942">next</a><span>|</span><label class="collapse" for="c-42065967">[-]</label><label class="expand" for="c-42065967">[1 more]</label></div><br/><div class="children"><div class="content">Is it a side effect if it&#x27;s also the primary effect?</div><br/></div></div></div></div><div id="42065942" class="c"><input type="checkbox" id="c-42065942" checked=""/><div class="controls bullet"><span class="by">hk1337</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42064722">parent</a><span>|</span><a href="#42065201">prev</a><span>|</span><a href="#42073167">next</a><span>|</span><label class="collapse" for="c-42065942">[-]</label><label class="expand" for="c-42065942">[2 more]</label></div><br/><div class="children"><div class="content">Even AWS CodeBuild (or CodePipeline) allows you to do this now. It didn&#x27;t before but it&#x27;s a fairly recent update.</div><br/><div id="42069779" class="c"><input type="checkbox" id="c-42069779" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42065942">parent</a><span>|</span><a href="#42073167">next</a><span>|</span><label class="collapse" for="c-42069779">[-]</label><label class="expand" for="c-42069779">[1 more]</label></div><br/><div class="children"><div class="content">As a prior user of AWS Code*, I can appreciate that you qualified that with &quot;Even&quot; LMAO</div><br/></div></div></div></div></div></div><div id="42073167" class="c"><input type="checkbox" id="c-42073167" checked=""/><div class="controls bullet"><span class="by">habosa</span><span>|</span><a href="#42064553">parent</a><span>|</span><a href="#42064722">prev</a><span>|</span><a href="#42065313">next</a><span>|</span><label class="collapse" for="c-42073167">[-]</label><label class="expand" for="c-42073167">[1 more]</label></div><br/><div class="children"><div class="content">I think this is one of the big reasons so many companies end up using Bazel as part of scaling their monorepos. It has many faults but one thing it does perfectly is “build and test everything affected by this commit”</div><br/></div></div><div id="42065313" class="c"><input type="checkbox" id="c-42065313" checked=""/><div class="controls bullet"><span class="by">victorNicollet</span><span>|</span><a href="#42064553">parent</a><span>|</span><a href="#42073167">prev</a><span>|</span><a href="#42065042">next</a><span>|</span><label class="collapse" for="c-42065313">[-]</label><label class="expand" for="c-42065313">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t CI be easier with a monorepo ? Testing integration across multiple repositories (triggered by changes in any of them) seems more complex than just adding another test suite to a single repo.</div><br/><div id="42066156" class="c"><input type="checkbox" id="c-42066156" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42064553">root</a><span>|</span><a href="#42065313">parent</a><span>|</span><a href="#42065042">next</a><span>|</span><label class="collapse" for="c-42066156">[-]</label><label class="expand" for="c-42066156">[1 more]</label></div><br/><div class="children"><div class="content">Pros and cons.  Both can be used successfully, but there are different problems to each.  If you have a large project you will have a tool teams to deal with the problems of your solution.</div><br/></div></div></div></div></div></div><div id="42065042" class="c"><input type="checkbox" id="c-42065042" checked=""/><div class="controls bullet"><span class="by">gregmac</span><span>|</span><a href="#42064553">prev</a><span>|</span><a href="#42073561">next</a><span>|</span><label class="collapse" for="c-42065042">[-]</label><label class="expand" for="c-42065042">[10 more]</label></div><br/><div class="children"><div class="content">To me, monorepo vs multi-repo is not about the code organization, but about the deployment strategy. My rule is that there should be a 1:1 relation between a repository and a release&#x2F;deployment.<p>If you do one big monolithic deploy, one big monorepo is ideal. (Also, to be clear, this is separate from microservice vs monolithic app: your monolithic deploy can be made up of as many different applications&#x2F;services&#x2F;lambdas&#x2F;databases as makes sense).  You don&#x27;t have to worry about cross-compatibility between parts of your code, because there&#x27;s never a state where you can deploy something incompatible, because it all deploys at once. A single PR makes all the changes in one shot.<p>The other rule I have is that if you want to have individual repos with individual deployments, they must be both forward- and backwards-compatible for long enough that you never need to do a coordinated deploy (deploying two at once, where everything is broken in between). If you have to do coordinated deploys, you really have a monolith that&#x27;s just masquerading as something more sophisticated, and you&#x27;ve given up the biggest benefits of <i>both</i> models (simplicity of mono, independence of multi).<p>Consider what happens with a monorepo with parts of it being deployed individually. You can&#x27;t checkout any specific commit and mirror what&#x27;s in production. You could make multiple copies of the repo, checkout a different commit on each one, then try to keep in mind which part of which commit is where -- but this is utterly confusing. If you have 5 deployments, you now have 4 copies of any given line of code on your system that are potentially wrong. It becomes very hard to not accidentally break compatibility.<p>TL;DR: Figure out your deployment strategy, then make your repository structure mirror that.</div><br/><div id="42065717" class="c"><input type="checkbox" id="c-42065717" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42065042">parent</a><span>|</span><a href="#42065692">next</a><span>|</span><label class="collapse" for="c-42065717">[-]</label><label class="expand" for="c-42065717">[7 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t have to be that way.<p>You can have a mono-repo and deploy different parts of the repo as different services.<p>You can have a mono-repo with a React SPA and a backend service in Go.  If you fix some UI bug with a button in the React SPA, why would you also deploy the backend?</div><br/><div id="42066182" class="c"><input type="checkbox" id="c-42066182" checked=""/><div class="controls bullet"><span class="by">Falimonda</span><span>|</span><a href="#42065042">root</a><span>|</span><a href="#42065717">parent</a><span>|</span><a href="#42073646">next</a><span>|</span><label class="collapse" for="c-42066182">[-]</label><label class="expand" for="c-42066182">[1 more]</label></div><br/><div class="children"><div class="content">This is spot on. A monorepo can still include a granular and standardized CI configuration across code paths. Nothing about monorepo forces you to perform a singular deployment.<p>The gains provided by moving from polyrepo to monorepo are immense.<p>Developer access control is the only thing I can think to justify polyrepo.<p>I&#x27;m curious if and how others who see the advantages of monorepo have justified polyrepo in spite of that.</div><br/></div></div><div id="42073646" class="c"><input type="checkbox" id="c-42073646" checked=""/><div class="controls bullet"><span class="by">gregmac</span><span>|</span><a href="#42065042">root</a><span>|</span><a href="#42065717">parent</a><span>|</span><a href="#42066182">prev</a><span>|</span><a href="#42066137">next</a><span>|</span><label class="collapse" for="c-42073646">[-]</label><label class="expand" for="c-42073646">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you fix some UI bug with a button in the React SPA, why would you also deploy the backend?<p>Why would you bother to spend the time figuring out whether or not it needs to get deployed? Why would you spend time training other (and new) people to be able to figure that out? Why even take on the risk of someone making a mistake?<p>If you make your deployment fast and seamless, who cares? Deploy everything every time. It eliminates a whole category of potential mistakes and troubleshooting paths, and it exercises the deployment process (so when you need it, you know it works).</div><br/></div></div><div id="42066137" class="c"><input type="checkbox" id="c-42066137" checked=""/><div class="controls bullet"><span class="by">bryanlarsen</span><span>|</span><a href="#42065042">root</a><span>|</span><a href="#42065717">parent</a><span>|</span><a href="#42073646">prev</a><span>|</span><a href="#42066068">next</a><span>|</span><label class="collapse" for="c-42066137">[-]</label><label class="expand" for="c-42066137">[2 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t deploy in tandem, you need to test forwards &amp; backwards compatibility.   That&#x27;s tough with either a monorepo or separate repos, but arguably it&#x27;d be simple with separate repos.</div><br/><div id="42066300" class="c"><input type="checkbox" id="c-42066300" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42065042">root</a><span>|</span><a href="#42066137">parent</a><span>|</span><a href="#42066068">next</a><span>|</span><label class="collapse" for="c-42066300">[-]</label><label class="expand" for="c-42066300">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t have to be that complicated.<p>All you need to know is &quot;does changing this code affect that code&quot;.<p>In the example I&#x27;ve given -- a React SPA and Go backend -- let&#x27;s assume that there&#x27;s a gRPC binding originating from the backend.  How do we know that we also need to deploy the SPA?  Updating the schema would cause generation of a new client + model in the SPA.  Now you know that you need to deploy both and this can be done simply by detecting roots for modified files.<p>You can scale this.  If that gRPC change affected some other web extension project, apply the same basic principle: detect that a file changed under this root -&gt; trigger the workflow that rebuilds, tests, and deploys from this root.</div><br/></div></div></div></div><div id="42066068" class="c"><input type="checkbox" id="c-42066068" checked=""/><div class="controls bullet"><span class="by">oneplane</span><span>|</span><a href="#42065042">root</a><span>|</span><a href="#42065717">parent</a><span>|</span><a href="#42066137">prev</a><span>|</span><a href="#42065692">next</a><span>|</span><label class="collapse" for="c-42066068">[-]</label><label class="expand" for="c-42066068">[2 more]</label></div><br/><div class="children"><div class="content">You wouldn&#x27;t, but making a repo collection into a mono-repo means your mono-deploy needs to be split into a multi-maybe-deploy.<p>As always, complexity merely moves around when squeezed, and making commits&#x2F;PRs easier means something else, somewhere else gets less easy.<p>It is something that can be made better of course, having your CI and CD be a bit smarter and more modular means you can now do selective builds based on what was actually changed, and selective releases based on what you actually want to release (not merely what was in the repo at a commit, or whatever was built).<p>But all of that needs to be constructed too, just merging some repos into one doesn&#x27;t do that.</div><br/><div id="42066336" class="c"><input type="checkbox" id="c-42066336" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#42065042">root</a><span>|</span><a href="#42066068">parent</a><span>|</span><a href="#42065692">next</a><span>|</span><label class="collapse" for="c-42066336">[-]</label><label class="expand" for="c-42066336">[1 more]</label></div><br/><div class="children"><div class="content">This is not very complex at all.<p>I linked an example below.  Most CI&#x2F;CD, like GitHub Actions[0], can easily be configured to trigger on changes for files in a specific path.<p>As a very basic starting point, you only need to set up simple rules to detect which monorepo roots changed.<p>[0] <a href="https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;actions&#x2F;writing-workflows&#x2F;workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore" rel="nofollow">https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;actions&#x2F;writing-workflows&#x2F;workflo...</a></div><br/></div></div></div></div></div></div><div id="42065692" class="c"><input type="checkbox" id="c-42065692" checked=""/><div class="controls bullet"><span class="by">aswerty</span><span>|</span><a href="#42065042">parent</a><span>|</span><a href="#42065717">prev</a><span>|</span><a href="#42073352">next</a><span>|</span><label class="collapse" for="c-42065692">[-]</label><label class="expand" for="c-42065692">[1 more]</label></div><br/><div class="children"><div class="content">This mirrors my own experience in the SaaS world. Anytime things move towards multiple artifacts&#x2F;pipelines in one repo; trying to understand what change existed where and when seems to always become very difficult.<p>Of course the multirepo approach means you do this dance a lot more:
- Create a change with backwards compatibility and tombstones (e.g. logs for when backward compatibility is used)
- Update upstream systems to the new change
- Remove backwards compatibility and pray you don&#x27;t have a low frequency upstream service interaction you didn&#x27;t know about<p>While the dance can be a pain - it does follow a more iterative approach with reduced blast radiuses (albeit many more of them). But, all in all, an acceptable tradeoff.<p>Maybe if I had more familiarity in mature tooling around monorepos I might be more interested in them. But alas not a bridge I have crossed, or am pushed to do so just at the moment.</div><br/></div></div><div id="42073352" class="c"><input type="checkbox" id="c-42073352" checked=""/><div class="controls bullet"><span class="by">jolt42</span><span>|</span><a href="#42065042">parent</a><span>|</span><a href="#42065692">prev</a><span>|</span><a href="#42073561">next</a><span>|</span><label class="collapse" for="c-42073352">[-]</label><label class="expand" for="c-42073352">[1 more]</label></div><br/><div class="children"><div class="content">I couldn&#x27;t disagree more. DevOps probably likes it but from software dev standpoint it&#x27;s not helpful at all. Had to stave that thinking off at my last job (because of devops). It was obvious it was going to be a huge waste of time with a continuing negative payback. It was trivial to essentially put a description file for our repo of 7 or so components.</div><br/></div></div></div></div><div id="42073561" class="c"><input type="checkbox" id="c-42073561" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42065042">prev</a><span>|</span><a href="#42071705">next</a><span>|</span><label class="collapse" for="c-42073561">[-]</label><label class="expand" for="c-42073561">[1 more]</label></div><br/><div class="children"><div class="content">The meta-syndrome here is: one person fixing a problem they have, and thereby making problems other people have worse. Often first person doesn&#x27;t have a good awareness of the full melange of problems and participants.</div><br/></div></div><div id="42071705" class="c"><input type="checkbox" id="c-42071705" checked=""/><div class="controls bullet"><span class="by">drbojingle</span><span>|</span><a href="#42073561">prev</a><span>|</span><a href="#42073142">next</a><span>|</span><label class="collapse" for="c-42071705">[-]</label><label class="expand" for="c-42071705">[2 more]</label></div><br/><div class="children"><div class="content">a lot of comments here seem to think that mono-repo has to mean something about deployment. I just don&#x27;t want to have to run git fetch and 5 different repos to get everything I need and that&#x27;s good enough reason for me to use one.</div><br/><div id="42072683" class="c"><input type="checkbox" id="c-42072683" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#42071705">parent</a><span>|</span><a href="#42073142">next</a><span>|</span><label class="collapse" for="c-42072683">[-]</label><label class="expand" for="c-42072683">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention when you need to make cross repo changes in development, and you have to set up a whole web of local repointing in package manifests. Repo is a hard boundary. Sometimes you need one. But to create a boundary when you don’t have to, on things that are deeply interconnected and have nowhere near a stable api? Utter madness imo.</div><br/></div></div></div></div><div id="42073142" class="c"><input type="checkbox" id="c-42073142" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#42071705">prev</a><span>|</span><a href="#42069823">next</a><span>|</span><label class="collapse" for="c-42073142">[-]</label><label class="expand" for="c-42073142">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Moving to a monorepo didn&#x27;t change much, and what minor changes it made have been positive.<p>It&#x27;s pretty refreshing to see an experience report whose conclusion is &quot;not much has changed&quot;, even though in practice that&#x27;s the most common result for any kind of process change.</div><br/></div></div><div id="42069823" class="c"><input type="checkbox" id="c-42069823" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#42073142">prev</a><span>|</span><a href="#42069443">next</a><span>|</span><label class="collapse" for="c-42069823">[-]</label><label class="expand" for="c-42069823">[2 more]</label></div><br/><div class="children"><div class="content">All the pitfalls of a monorepo can disappear with some good tooling and regular maintenance, so much so that devs may not even realize that they are using one. The actual meat of the discussion is – should you deploy the entire monorepo as one unit or as multiple (micro)services?</div><br/><div id="42071149" class="c"><input type="checkbox" id="c-42071149" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#42069823">parent</a><span>|</span><a href="#42069443">next</a><span>|</span><label class="collapse" for="c-42071149">[-]</label><label class="expand" for="c-42071149">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the thing. All the pitfalls of multi-repos also disappear with good tooling and regular maintenance.<p>Neither one has an actual edge. Yet you can find countless articles from people talking about their experience. Take those as a hint about what kind of tooling you need, not about their comparative qualities.</div><br/></div></div></div></div><div id="42069443" class="c"><input type="checkbox" id="c-42069443" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#42069823">prev</a><span>|</span><a href="#42064514">next</a><span>|</span><label class="collapse" for="c-42069443">[-]</label><label class="expand" for="c-42069443">[2 more]</label></div><br/><div class="children"><div class="content">Monorepos have their advantages, as pointed out, one place to review, one place to merge.<p>But it can also breed instability, as you can upgrade other people&#x27;s stuff without them being aware.<p>There are ways around this, which involve having a local module store, and building with named versions. Very similar to a bunch of disparate repos, but without getting lost in github (github&#x27;s discoverability was always far inferior to gitlab)<p>However it has its draw backs namely that people can hold out on older versions than you want to support.</div><br/><div id="42069723" class="c"><input type="checkbox" id="c-42069723" checked=""/><div class="controls bullet"><span class="by">dkarl</span><span>|</span><a href="#42069443">parent</a><span>|</span><a href="#42064514">next</a><span>|</span><label class="collapse" for="c-42069723">[-]</label><label class="expand" for="c-42069723">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But it can also breed instability, as you can upgrade other people&#x27;s stuff without them being aware<p>This is why Google embraced the principle that if somebody breaks your code without breaking your tests, it&#x27;s your fault for not writing better tests. (This is sometimes known as the Beyonce rule: if you liked it, you should have put a test on it.)<p>You need the ability to upgrade dependencies in a hands-off way even if you don&#x27;t have a monorepo, though, because you need to be able to apply security updates without scheduling dev work every time. You shouldn&#x27;t need a careful informed eye to tell if upgrades broke your code. You should be able to trust your tests.</div><br/></div></div></div></div><div id="42064973" class="c"><input type="checkbox" id="c-42064973" checked=""/><div class="controls bullet"><span class="by">h1fra</span><span>|</span><a href="#42064514">prev</a><span>|</span><a href="#42064625">next</a><span>|</span><label class="collapse" for="c-42064973">[-]</label><label class="expand" for="c-42064973">[6 more]</label></div><br/><div class="children"><div class="content">I think the big issue around monorepo is when a company puts completely different projects together inside a single repo.<p>In this article almost everything makes sense to me (because that&#x27;s what I have been doing most of my career) but they put their OTP app inside which suddenly makes no sense. And you can see the problem in the CI they have dedicated files just for this App and probably very few common code with the rest.<p>IMO you should have one monorepo per project (api, frontend, backend, mobile, etc. as long as it&#x27;s the same project) and if needed a dedicated repo for a shared library.</div><br/><div id="42072735" class="c"><input type="checkbox" id="c-42072735" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#42064973">parent</a><span>|</span><a href="#42065000">next</a><span>|</span><label class="collapse" for="c-42072735">[-]</label><label class="expand" for="c-42072735">[1 more]</label></div><br/><div class="children"><div class="content">&gt; when a company puts completely different projects together inside a single repo.<p>This is google3. It was absolutely loved by the majority of devs. If you change a line of code, all dependencies are type checked and tested and also a bunch of other things. It keeps so many versioning issues out.<p>One of the big reasons why the JS ecosystem is so fragmented compared to Go or even Rust is the leftpad-sized packages with 10 config files that are out of date. Not to mention our friend peerDependencies, who needs no introduction.</div><br/></div></div><div id="42065000" class="c"><input type="checkbox" id="c-42065000" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42064973">parent</a><span>|</span><a href="#42072735">prev</a><span>|</span><a href="#42064625">next</a><span>|</span><label class="collapse" for="c-42065000">[-]</label><label class="expand" for="c-42065000">[4 more]</label></div><br/><div class="children"><div class="content">&gt; you should have one monorepo per project (api, frontend, backend, mobile, etc. as long as it&#x27;s the same project)<p><i>that&#x27;s not a monorepo!</i><p>Unless the singular  &quot;project&quot; is stuff our company ships, the problem you have is of impedance mismatch between the projects, which is the problem that an <i>actual</i> monorepo solves. for swe&#x27;s on individual projects who will never have the problem of having to ship a commit on all the repos at the &quot;same&quot; time, yeah that seems fine, and for them it is. the problem comes as a distributed systems engineer where, for whatever reason, many or all the repos need to be shipped at the ~same time. or worse - A needs to ship before B which needs ship before C but that needs to ship before A, and you have to unwind that before actually being able to ship the change.</div><br/><div id="42070959" class="c"><input type="checkbox" id="c-42070959" checked=""/><div class="controls bullet"><span class="by">h1fra</span><span>|</span><a href="#42064973">root</a><span>|</span><a href="#42065000">parent</a><span>|</span><a href="#42066002">next</a><span>|</span><label class="collapse" for="c-42070959">[-]</label><label class="expand" for="c-42070959">[1 more]</label></div><br/><div class="children"><div class="content">my implicit point was that most people don&#x27;t want monorepo; when they talk about monorepo they talk about consolidating a project together, that can span many different repos and technology.<p>I&#x27;m not convinced that making completely different teams work on the same repo is making things better. In the case of cascading dependencies what usually works better than a convoluted technical solution is communication.</div><br/></div></div><div id="42066002" class="c"><input type="checkbox" id="c-42066002" checked=""/><div class="controls bullet"><span class="by">hk1337</span><span>|</span><a href="#42064973">root</a><span>|</span><a href="#42065000">parent</a><span>|</span><a href="#42070959">prev</a><span>|</span><a href="#42064625">next</a><span>|</span><label class="collapse" for="c-42066002">[-]</label><label class="expand" for="c-42066002">[2 more]</label></div><br/><div class="children"><div class="content">&gt; that&#x27;s not a monorepo!<p>Sure it is! It&#x27;s just not the ideal use case for a monorepo which is why people say they don&#x27;t like monorepos.</div><br/><div id="42067266" class="c"><input type="checkbox" id="c-42067266" checked=""/><div class="controls bullet"><span class="by">vander_elst</span><span>|</span><a href="#42064973">root</a><span>|</span><a href="#42066002">parent</a><span>|</span><a href="#42064625">next</a><span>|</span><label class="collapse" for="c-42067266">[-]</label><label class="expand" for="c-42067266">[1 more]</label></div><br/><div class="children"><div class="content">&quot;one monorepo per project (api, frontend, backend, mobile, etc. as long as it&#x27;s the same project) and if needed a dedicated repo for a shared library.&quot;<p>They are literally saying that multiple repos should be used, also for sharing the code, this is not monorepo, these are different repos.</div><br/></div></div></div></div></div></div></div></div><div id="42064625" class="c"><input type="checkbox" id="c-42064625" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42064973">prev</a><span>|</span><a href="#42064969">next</a><span>|</span><label class="collapse" for="c-42064625">[-]</label><label class="expand" for="c-42064625">[5 more]</label></div><br/><div class="children"><div class="content">We&#x27;re transitioning from a SVN monorepo to Git. We&#x27;ve considered doing a kind of best-of-both-worlds approach.<p>Some core stuff into separate libraries, consumed as nuget packages by other projects. Those libraries and other standalone projects in separate repos.<p>Then a &quot;monorepo&quot; for our main product, where individual projects for integrations etc will reference non-nuget libraries directly.<p>That is, tightly coupled code goes into the monorepo, the rest in separate repos.<p>Haven&#x27;t taken the plunge just yet tho, so not sure how well it&#x27;ll actually work out.</div><br/><div id="42067711" class="c"><input type="checkbox" id="c-42067711" checked=""/><div class="controls bullet"><span class="by">dezgeg</span><span>|</span><a href="#42064625">parent</a><span>|</span><a href="#42074527">next</a><span>|</span><label class="collapse" for="c-42067711">[-]</label><label class="expand" for="c-42067711">[2 more]</label></div><br/><div class="children"><div class="content">In my experience this turns to nightmare when (not if, when) there is need to make changes to the libraries and app at the same time. Especially with libraries it&#x27;s often necessary to create a client for an API at the same time to really know that the interface is any good.</div><br/><div id="42069744" class="c"><input type="checkbox" id="c-42069744" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42064625">root</a><span>|</span><a href="#42067711">parent</a><span>|</span><a href="#42074527">next</a><span>|</span><label class="collapse" for="c-42069744">[-]</label><label class="expand" for="c-42069744">[1 more]</label></div><br/><div class="children"><div class="content">The idea is that the libraries we put in nuget are really non-project-specific. We&#x27;ll use nuget to manage library versions rather than git submodules, so hopefully they can live fine in a separate repo.<p>So updating them at the same time shouldn&#x27;t be a huge deal, we just make the change in the library, publish the nuget package, and then bump the version number in the downstream projects that need the change.<p>Ideally changes to these libraries should be relatively limited.<p>For things that are intertwined, like an API client alongside the API provider and more project-specific libraries, we&#x27;ll keep those together in the same repo.<p>If this is what you&#x27;re thinking of, I&#x27;d be interested in hearing more about your negative experiences with such a setup.</div><br/></div></div></div></div><div id="42074527" class="c"><input type="checkbox" id="c-42074527" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42064625">parent</a><span>|</span><a href="#42067711">prev</a><span>|</span><a href="#42064969">next</a><span>|</span><label class="collapse" for="c-42074527">[-]</label><label class="expand" for="c-42074527">[2 more]</label></div><br/><div class="children"><div class="content">...just curious, what&#x27;s your line of work where you&#x27;re still using SVN?</div><br/><div id="42074888" class="c"><input type="checkbox" id="c-42074888" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42064625">root</a><span>|</span><a href="#42074527">parent</a><span>|</span><a href="#42064969">next</a><span>|</span><label class="collapse" for="c-42074888">[-]</label><label class="expand" for="c-42074888">[1 more]</label></div><br/><div class="children"><div class="content">Company makes B2B software. Our main product is a traditional Win32  application with over 25 year old code in production, though most of it is much more recent.<p>SVN worked well for us, being a relatively small team until recently, so no real need to change until now.<p>The primary driver for the move to Git has been compliance. We just can&#x27;t have on-prem servers with critical things like code anymore, and there&#x27;s effectively just one cloud-based SVN offering that had ISO27001 etc.<p>So incentive to move to Git just got a lot stronger.</div><br/></div></div></div></div></div></div><div id="42064969" class="c"><input type="checkbox" id="c-42064969" checked=""/><div class="controls bullet"><span class="by">memsom</span><span>|</span><a href="#42064625">prev</a><span>|</span><a href="#42070241">next</a><span>|</span><label class="collapse" for="c-42064969">[-]</label><label class="expand" for="c-42064969">[9 more]</label></div><br/><div class="children"><div class="content">monorepos are appropriate for a single project with many sub parts but one or two artifacts on any given release build. But they fall apart when you have multiple products in the monorepo, each with different release schedules.<p>As soon as you add a second separate product that uses a different subset of any code in the repo, you should consider breaking up the monorepo. If the code is &quot;a bunch of libraries&quot; and &quot;one or more end user products&quot; it becomes even more imperative to consider breaking down stuff..<p>Having worked on monorepos where there are 30+ artifacts, multiple ongoing projects that each pull the monorepo in to different incompatible versions, and all of which have their own lifetime and their own release cycle - monorepo is the antithesis of a good idea.</div><br/><div id="42067350" class="c"><input type="checkbox" id="c-42067350" checked=""/><div class="controls bullet"><span class="by">vander_elst</span><span>|</span><a href="#42064969">parent</a><span>|</span><a href="#42065786">next</a><span>|</span><label class="collapse" for="c-42067350">[-]</label><label class="expand" for="c-42067350">[3 more]</label></div><br/><div class="children"><div class="content">Working on a monorepo where we have hundreds (possibly thousands) of projects each with a different version and release schedule. It actually works quite well, the dependencies are always in a good state, it&#x27;s easy to see the ramifications of a change and to reuse common components.</div><br/><div id="42067607" class="c"><input type="checkbox" id="c-42067607" checked=""/><div class="controls bullet"><span class="by">memsom</span><span>|</span><a href="#42064969">root</a><span>|</span><a href="#42067350">parent</a><span>|</span><a href="#42065786">next</a><span>|</span><label class="collapse" for="c-42067607">[-]</label><label class="expand" for="c-42067607">[2 more]</label></div><br/><div class="children"><div class="content">Good for you. For us, because we have multiple projects going on, pulling the code in different ways, code that runs on embedded, code that runs in the cloud, desktop apps (real ones written in C++ and .Net, not glorified web apps), code that is customer facing, code used by third parties for integrating our products, no - it just doesn’t work. The embedded shares a core with other levels, and we support multiple embedded platforms (bare metal) and OS (Windows, Linux, Android, iOS) and also have stuff that runs in Amazon&#x2F;Azure cloud platform. You might be fine, but when you hit critical mass and you have very complicated commercial concerns, it doesn’t work well.</div><br/><div id="42069279" class="c"><input type="checkbox" id="c-42069279" checked=""/><div class="controls bullet"><span class="by">tomtheelder</span><span>|</span><a href="#42064969">root</a><span>|</span><a href="#42067607">parent</a><span>|</span><a href="#42065786">next</a><span>|</span><label class="collapse" for="c-42069279">[-]</label><label class="expand" for="c-42069279">[1 more]</label></div><br/><div class="children"><div class="content">I mean it works for Google. Not saying that&#x27;s a reason to go monorepo, but it at least suggests that it can work for a very large org with very diverse software.<p>I really don&#x27;t see why anything you describe would be an issue at all for a monorepo.</div><br/></div></div></div></div></div></div><div id="42065786" class="c"><input type="checkbox" id="c-42065786" checked=""/><div class="controls bullet"><span class="by">munksbeer</span><span>|</span><a href="#42064969">parent</a><span>|</span><a href="#42067350">prev</a><span>|</span><a href="#42070241">next</a><span>|</span><label class="collapse" for="c-42065786">[-]</label><label class="expand" for="c-42065786">[5 more]</label></div><br/><div class="children"><div class="content">No offense but I think you&#x27;re doing monorepos wrong. We have more than 100 applications living in our monorepo. They share common core code, some common signals, common utility libs, and all of them share the same build.<p>We release everything weekly, and some things much more frequently.<p>If your testing is good enough, I don&#x27;t see what the issue is?</div><br/><div id="42066337" class="c"><input type="checkbox" id="c-42066337" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42064969">root</a><span>|</span><a href="#42065786">parent</a><span>|</span><a href="#42067715">next</a><span>|</span><label class="collapse" for="c-42066337">[-]</label><label class="expand" for="c-42066337">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If your testing is good enough, I don&#x27;t see what the issue is?<p>Your testing isn&#x27;t good enough.  I don&#x27;t know who you are, what you are working on, or how much testing you do, but I will state with confidence it isn&#x27;t good enough.<p>It might be acceptable for your current needs, but you will have bugs that escape testing - often intentional as you can&#x27;t stop forever to fix all known bugs. In turn that means if anything changes in your current needs you will run into issues.<p>&gt; We release everything weekly, and some things much more frequently.<p>This is a negative to users.  When you think you will release again next so who cares about bugs it means your users see more bugs. Sure it is nice that you don&#x27;t have to break open years old code anymore, but if the new stuff doesn&#x27;t have anything the user wants is this really a good thing?</div><br/></div></div><div id="42067715" class="c"><input type="checkbox" id="c-42067715" checked=""/><div class="controls bullet"><span class="by">memsom</span><span>|</span><a href="#42064969">root</a><span>|</span><a href="#42065786">parent</a><span>|</span><a href="#42066337">prev</a><span>|</span><a href="#42070241">next</a><span>|</span><label class="collapse" for="c-42067715">[-]</label><label class="expand" for="c-42067715">[3 more]</label></div><br/><div class="children"><div class="content">No offence, but you might be a little confused by how complex your actual delivery is. That sounds simple. That sounds like it has a clear roadmap. When you don’t, and you have very agile development that pivots quickly and demands a lot of change concurrently for releases that have very different goals, it is not possible to make all your ducks sit in a row. Monorepos suck in that situation. The dependency graph is so complex it will make your head hurt. And all the streams need to converge in to the main dev branch at some point, which causes huge bottlenecks.</div><br/><div id="42069303" class="c"><input type="checkbox" id="c-42069303" checked=""/><div class="controls bullet"><span class="by">tomtheelder</span><span>|</span><a href="#42064969">root</a><span>|</span><a href="#42067715">parent</a><span>|</span><a href="#42070241">next</a><span>|</span><label class="collapse" for="c-42069303">[-]</label><label class="expand" for="c-42069303">[2 more]</label></div><br/><div class="children"><div class="content">The dependency graph is no different for a monorepo vs a polyrepo. It&#x27;s just a question of how those dependencies get resolved.</div><br/><div id="42074947" class="c"><input type="checkbox" id="c-42074947" checked=""/><div class="controls bullet"><span class="by">memsom</span><span>|</span><a href="#42064969">root</a><span>|</span><a href="#42069303">parent</a><span>|</span><a href="#42070241">next</a><span>|</span><label class="collapse" for="c-42074947">[-]</label><label class="expand" for="c-42074947">[1 more]</label></div><br/><div class="children"><div class="content">With multiple repos, we can get a single deliverable for each project requirement, manage convergence and still maintain a main branch for each repo. The artifices can be packaged and consumed by the other dependencies that are changing. It stops monolithic development. It library A needs to branches of change, we don’t need to create 2 branches for the entire product line. You literally only change the parts you are currently working on, and insignificant changes don’t get sucked in by proxy.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42070241" class="c"><input type="checkbox" id="c-42070241" checked=""/><div class="controls bullet"><span class="by">bobim</span><span>|</span><a href="#42064969">prev</a><span>|</span><a href="#42072680">next</a><span>|</span><label class="collapse" for="c-42070241">[-]</label><label class="expand" for="c-42070241">[1 more]</label></div><br/><div class="children"><div class="content">Started to use a monorepo + worktrees to keep related but separated developments all together with different checkouts. Anybody else on the same path?</div><br/></div></div><div id="42072680" class="c"><input type="checkbox" id="c-42072680" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#42070241">prev</a><span>|</span><a href="#42072850">next</a><span>|</span><label class="collapse" for="c-42072680">[-]</label><label class="expand" for="c-42072680">[2 more]</label></div><br/><div class="children"><div class="content">This prompted a shower thought: Isn&#x27;t N separate repos actually strictly worse than a monorepo with N <i>completely independent</i> long-lived branches, where each person checks out all the ones they need to work on under separate folders with `git worktree add`?<p>I can think of only 2 ways that the multiple-branch monorepo is worse:<p>1. If the monorepo is large, everyone has to deal with a fat .git folder even if they have only checked out a branch with a few files.<p>2. Today, everyone expects different branches in a repo to contain &quot;different versions of the same thing&quot;, not &quot;a bunch of different things&quot;. But this is purely convention.<p>The only real benefit that I can see of making a separate repo (over adding a new project directory to a &quot;classic&quot; monorepo) is the lower barrier to <i>getting underway</i> -- you can just immediately start doing whatever you want; the pain of syncing repos comes later. But this is also true when starting work under a new branch in the branch-per-project style monorepo: you can just create a branch from the initial commit, and away you go -- and if you need to atomically make changes across projects, just merge their branches first!<p>What are the downsides I&#x27;m not seeing?</div><br/><div id="42074540" class="c"><input type="checkbox" id="c-42074540" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42072680">parent</a><span>|</span><a href="#42072850">next</a><span>|</span><label class="collapse" for="c-42074540">[-]</label><label class="expand" for="c-42074540">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a monorepo with N completely independent long-lived branches<p>That&#x27;s not a monorepo.</div><br/></div></div></div></div><div id="42072850" class="c"><input type="checkbox" id="c-42072850" checked=""/><div class="controls bullet"><span class="by">oslem</span><span>|</span><a href="#42072680">prev</a><span>|</span><a href="#42067992">next</a><span>|</span><label class="collapse" for="c-42072850">[-]</label><label class="expand" for="c-42072850">[1 more]</label></div><br/><div class="children"><div class="content">Alright everyone, we’ve trained for this. Grab your popcorn and get a good seat. It’s the return of the of great mono&#x2F;poly repo debate.</div><br/></div></div><div id="42067992" class="c"><input type="checkbox" id="c-42067992" checked=""/><div class="controls bullet"><span class="by">stillbourne</span><span>|</span><a href="#42072850">prev</a><span>|</span><a href="#42065208">next</a><span>|</span><label class="collapse" for="c-42067992">[-]</label><label class="expand" for="c-42067992">[1 more]</label></div><br/><div class="children"><div class="content">I like to use the monorepo tools without the monorepo repo. If that makes any god damn sense. I use NX at my job and the monorepo was getting out of hand, 6 hour pipeline builds, 2 hours testing, etc. So I broke the repo into smaller pieces. This wouldn&#x27;t have been possible if I wasn&#x27;t already using the monorepo tools universally through the project but it ended up working well.</div><br/></div></div><div id="42065208" class="c"><input type="checkbox" id="c-42065208" checked=""/><div class="controls bullet"><span class="by">syndicatedjelly</span><span>|</span><a href="#42067992">prev</a><span>|</span><a href="#42074734">next</a><span>|</span><label class="collapse" for="c-42065208">[-]</label><label class="expand" for="c-42065208">[7 more]</label></div><br/><div class="children"><div class="content">Some thoughts:<p>1) Comparing a photo storage app to the Linux kernel doesn&#x27;t make much sense. Just because a much bigger project in an entirely different (and more complex) domain uses monorepos, doesn&#x27;t mean you should too.<p>2) What the hell is a monorepo? I feel dumb for asking the question, and I feel like I missed the boat on understanding it, because no one defines it anymore. Yet I feel like every mention of monorepo is highly dependent on the context the word is used in. Does it just mean a single version-controlled repository of code?<p>3) Can these issues with sync&#x27;ing repos be solved with better use of `git submodule`? It seems to be designed exactly for this purpose. The author says &quot;submodules are irritating&quot; a couple times, but doesn&#x27;t explain what exactly is wrong with them. They seem like a great solution to me, but I also only recently started using them in a side project</div><br/><div id="42066078" class="c"><input type="checkbox" id="c-42066078" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#42065208">parent</a><span>|</span><a href="#42073151">next</a><span>|</span><label class="collapse" for="c-42066078">[-]</label><label class="expand" for="c-42066078">[2 more]</label></div><br/><div class="children"><div class="content">Monorepo is just a single repo. Yup.<p>Git submodules have some places where you can surprisingly lose branches&#x2F;stashed changes.</div><br/><div id="42066168" class="c"><input type="checkbox" id="c-42066168" checked=""/><div class="controls bullet"><span class="by">syndicatedjelly</span><span>|</span><a href="#42065208">root</a><span>|</span><a href="#42066078">parent</a><span>|</span><a href="#42073151">next</a><span>|</span><label class="collapse" for="c-42066168">[-]</label><label class="expand" for="c-42066168">[1 more]</label></div><br/><div class="children"><div class="content">One of my repos has a dependency on another repo (that I also own). I initialized it as a git submodule (e.g. my_org&#x2F;repo1 has a submodule of my_org&#x2F;repo2).<p><pre><code>    Git submodules have some places where you can surprisingly lose branches&#x2F;stashed changes.
</code></pre>
This concerns me, as git generally behaves as a leak-proof abstraction in my experience. Can you elaborate or share where I can learn more about this issue?</div><br/></div></div></div></div><div id="42073151" class="c"><input type="checkbox" id="c-42073151" checked=""/><div class="controls bullet"><span class="by">swisniewski</span><span>|</span><a href="#42065208">parent</a><span>|</span><a href="#42066078">prev</a><span>|</span><a href="#42066192">next</a><span>|</span><label class="collapse" for="c-42073151">[-]</label><label class="expand" for="c-42073151">[1 more]</label></div><br/><div class="children"><div class="content">I would be hard pressed to call the Linux Kernel a mono repo.<p>It’s all one kernel really.<p>The Kernel is a monolith, but that doesn’t make its repo a mono repo.<p>FreeBSD, on the other hand, is a mono-repo. It has the kernel, all the user mode tools, basically everything in a single repo.<p>That is very different from the
Linux ecosystem as whole.<p>Linux is not a mono repo.</div><br/></div></div><div id="42066192" class="c"><input type="checkbox" id="c-42066192" checked=""/><div class="controls bullet"><span class="by">klooney</span><span>|</span><a href="#42065208">parent</a><span>|</span><a href="#42073151">prev</a><span>|</span><a href="#42074734">next</a><span>|</span><label class="collapse" for="c-42066192">[-]</label><label class="expand" for="c-42066192">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  Does it just mean a single version-controlled repository of code?<p>Yeah- they idea is that all of your projects share a common repo. This has advantages and drawbacks. Google is most famous for this approach, although I think they technically have three now- one for Google, one for Android, and one for Chrome.<p>&gt; They seem like a great solution to me<p>They don&#x27;t work in a team context because they&#x27;re extra steps that people don&#x27;t do, basically. And did some reason a lot of people find them confusing.</div><br/><div id="42066829" class="c"><input type="checkbox" id="c-42066829" checked=""/><div class="controls bullet"><span class="by">nonameiguess</span><span>|</span><a href="#42065208">root</a><span>|</span><a href="#42066192">parent</a><span>|</span><a href="#42074734">next</a><span>|</span><label class="collapse" for="c-42066829">[-]</label><label class="expand" for="c-42066829">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;</a> contains 2700+ repositories. I don&#x27;t know necessarily how many of these are read-only clones from an internal monorepo versus how many are separate projects that have actually been open-sourced, but the latter is more than zero.</div><br/><div id="42074572" class="c"><input type="checkbox" id="c-42074572" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42065208">root</a><span>|</span><a href="#42066829">parent</a><span>|</span><a href="#42074734">next</a><span>|</span><label class="collapse" for="c-42074572">[-]</label><label class="expand" for="c-42074572">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never worked for Google. But my understanding is that their deployment code doesn&#x27;t really on any of those 2700+ repositories. I believe it doesn&#x27;t rely on anything that isn&#x27;t checked into the monorepo.<p>If they spin out an open-source project, they either (1) continue development internally and (maybe) do periodic releases by exporting that directory from the monorepo; or (2) allow development to occur externally and periodically import changes when upgrading the version used by the monorepo.<p>Either way, the point is that to build any Google service, you checkout the monorepo and type whatever their equivalent of &#x27;make&#x27; is. No external dependencies.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>