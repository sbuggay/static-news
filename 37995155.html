<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698138085960" as="style"/><link rel="stylesheet" href="styles.css?v=1698138085960"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://matklad.github.io/2023/10/23/unified-vs-split-diff.html">Unified versus Split Diff</a> <span class="domain">(<a href="https://matklad.github.io">matklad.github.io</a>)</span></div><div class="subtext"><span>ingve</span> | <span>46 comments</span></div><br/><div><div id="37995493" class="c"><input type="checkbox" id="c-37995493" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#37996110">next</a><span>|</span><label class="collapse" for="c-37995493">[-]</label><label class="expand" for="c-37995493">[15 more]</label></div><br/><div class="children"><div class="content">&gt; For a large change, I don’t want to do a “diff review”, I want to do a proper code review of a codebase at a particular instant in time, paying specific attention to the recently changed areas,<p>obviously every team and ticket is different, but IMO unless the person doing the review is some sort of principal engineer mostly responsible for the code at large, this does not align with I would personally consider a code review. In my book a general code review is simple sanity check by a second pair of eyes, which can result in suggestions to use different API or use an API slightly differently. If commits in the PR are properly ordered&#x2F;squashed it is relatively easy to review incremental changes in isolation anyway.<p>I guess the complaint author has is really about review <i>types</i>. I do not have terminology ready at hand, but there is run of the mill sanity check review and then there is deep, architectural feature premerge review. The author complains about the latter when most of the code reviews in web tools are of the former variety.</div><br/><div id="37995538" class="c"><input type="checkbox" id="c-37995538" checked=""/><div class="controls bullet"><span class="by">dylukes</span><span>|</span><a href="#37995493">parent</a><span>|</span><a href="#37995774">next</a><span>|</span><label class="collapse" for="c-37995538">[-]</label><label class="expand" for="c-37995538">[12 more]</label></div><br/><div class="children"><div class="content">&gt; In my book a general code review is simple sanity check by a second pair of eyes, which can result in suggestions to use different API or use an API slightly differently.<p>This is an impoverished view of code review. Code review is a principal mechanism for reducing individual code ownership, for propagating conventions, and for skill transfer.<p>A good code review starts with a good PR: one that outlines what its goals were and how it achieved them.<p>First item on a good review then: does the code achieve what it set out to do per the outline?<p>Second: does it contain tests that validate the claimed functionality?<p>Third: does it respect the architectural conventions of the system so far?<p>Fourth: is the style in line with expectations?<p>Fifth, and finally: do you have any suggestions as to better API usage?<p>A code review that is nothing more than a sanity check is useless and could have been done by CI infrastructure. Code review is a human process and should maximally take advantage of the things only humans could do. Leave the rest to machines.<p>An implicit question in several of the above is &quot;will this set a good example for future contributions?&quot;</div><br/><div id="37996033" class="c"><input type="checkbox" id="c-37996033" checked=""/><div class="controls bullet"><span class="by">crdrost</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37995538">parent</a><span>|</span><a href="#37995883">next</a><span>|</span><label class="collapse" for="c-37996033">[-]</label><label class="expand" for="c-37996033">[4 more]</label></div><br/><div class="children"><div class="content">I go back and forth on this.<p>On the one hand, I really like constant deep feedback. I really like the consistency benefits of having another person say “that’s too much, I find that unreadable.”<p>On the other, I have now been at a lot of places where it was very hard to get my code reviewed, latencies of days and sometimes weeks if folks are in a particularly heinous crunchtime... And then when it does get reviewed, the stuff that I worked really hard on to get the right speed or to properly centralize cache invalidation... Suddenly someone is like “I would have done it from this other approach” and you have no idea whether it&#x27;s tractable or not.<p>While I have never been at a place that did this, I have in my head the idea that the code should be an unfolding collective conversation, kind of like when folks are all collaborating on a shared Google Doc, I see that you are editing this section and I throw in a quick comment “don&#x27;t forget to add XYZ” and then jump to a different part that I won&#x27;t be stepping on their toes with. So the basic idea would be to get everybody to merge to `main` like 2 or 3 times a day if possible. In that case code review really is just “make sure this doesn&#x27;t break the build or break prod, everything is behind a feature toggle, if I don&#x27;t like the design I will comment on the code near the design or sketch a proof of concept showing that my approach is superior in clarity or speed or whatever”... Nobody ever takes me up on this culture shift it seems.</div><br/><div id="37996401" class="c"><input type="checkbox" id="c-37996401" checked=""/><div class="controls bullet"><span class="by">bernds74</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37996033">parent</a><span>|</span><a href="#37996139">next</a><span>|</span><label class="collapse" for="c-37996401">[-]</label><label class="expand" for="c-37996401">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I would have done it from this other approach&quot;. I&#x27;ve seen that, and it&#x27;s not good when you get the feeling of &quot;code review is when someone who hasn&#x27;t thought about your problem tells you how you should have solved it&quot;. People sometimes feel they have to add value as a reviewer, and casually discarding other people&#x27;s work is the way to do it. Fortunately it&#x27;s not something I have to deal with at my current job.</div><br/></div></div><div id="37996139" class="c"><input type="checkbox" id="c-37996139" checked=""/><div class="controls bullet"><span class="by">yarekt</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37996033">parent</a><span>|</span><a href="#37996401">prev</a><span>|</span><a href="#37995883">next</a><span>|</span><label class="collapse" for="c-37996139">[-]</label><label class="expand" for="c-37996139">[2 more]</label></div><br/><div class="children"><div class="content">This is called Continuous Integration, and its a shame that the term got nicked to now mean &quot;that thing that builds our PRs somewhere&quot;.
The idea was that everyone pushes to main all the time, which basically reduces integration time to 0, as everyone is doing it every couple of minutes on big teams. After a while you learn how to not step on people&#x27;s toes (Introduce new classes incrementally, use docblocs documenting class&#x27; intent, rather than just current functionality)<p>I too find that its basically impossible to suggest switching to this workflow, given the weight of all our existing tools. They are so easy to setup, and most come for free (Azure Devops&#x2F;Pipelines thing) that going off the track is just unthinkable.</div><br/><div id="37996440" class="c"><input type="checkbox" id="c-37996440" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37996139">parent</a><span>|</span><a href="#37995883">next</a><span>|</span><label class="collapse" for="c-37996440">[-]</label><label class="expand" for="c-37996440">[1 more]</label></div><br/><div class="children"><div class="content">Everyone committing to the main branch all the time sounds like a nightmare to me, to be honest.  I would probably seriously consider quitting if this was forced on me.<p>(Or rather, I would probably just run on my private git copy, and only pull every once in a while, and ignore that the main branch always changes.)<p>When &#x2F; how do you do code review in your suggested workflow?</div><br/></div></div></div></div></div></div><div id="37995883" class="c"><input type="checkbox" id="c-37995883" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37995538">parent</a><span>|</span><a href="#37996033">prev</a><span>|</span><a href="#37995573">next</a><span>|</span><label class="collapse" for="c-37995883">[-]</label><label class="expand" for="c-37995883">[1 more]</label></div><br/><div class="children"><div class="content">Well put. I&#x27;d like to add that individual code ownership must not necessary be lived as a loner sitting on that code. Being an owner means hatching, keeping clean and also knowing when getting help is beneficial. Accepting your bias and asking for a look from a different perspective is not getting rid of or dispersing ownership in my view, it is a central part of it.<p>Often this includes getting feedback if that change can make problems outside the feature implemented or in the future, like introducing dependencies that cost more in total than they help locally.</div><br/></div></div><div id="37995573" class="c"><input type="checkbox" id="c-37995573" checked=""/><div class="controls bullet"><span class="by">phillipcarter</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37995538">parent</a><span>|</span><a href="#37995883">prev</a><span>|</span><a href="#37995630">next</a><span>|</span><label class="collapse" for="c-37995573">[-]</label><label class="expand" for="c-37995573">[4 more]</label></div><br/><div class="children"><div class="content">As a counterpoint, individual code ownership can be a fantastic model too. It lets engineers specialize and takes advantage of social systems that form naturally anyways. I’ve not personally seen group ownership work well, and in practice, it’s still an individual who knows a given area the best.</div><br/><div id="37995716" class="c"><input type="checkbox" id="c-37995716" checked=""/><div class="controls bullet"><span class="by">sam_lowry_</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37995573">parent</a><span>|</span><a href="#37995630">next</a><span>|</span><label class="collapse" for="c-37995716">[-]</label><label class="expand" for="c-37995716">[3 more]</label></div><br/><div class="children"><div class="content">&gt; reducing individual code ownership<p>I am now working in an organization that is set up to reduce code ownership, and they struggle to attract talent, although pay is good and work is fulfilling.<p>How do they do reduce individual code ownership? Horizontal integration. Developers code, analysts design DB structures (at least nominally), project managers set up meetings. Different silos exist for CICD, cloud roles, core teams.<p>There are vetting committees everywhere that have the last say on the libraries used and the nitty-gritty details of REST APIs and naming.<p>It exhilarating to start projects, then see them degrade inevitably into corporate monstrosities.</div><br/><div id="37996211" class="c"><input type="checkbox" id="c-37996211" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37995716">parent</a><span>|</span><a href="#37995630">next</a><span>|</span><label class="collapse" for="c-37996211">[-]</label><label class="expand" for="c-37996211">[2 more]</label></div><br/><div class="children"><div class="content">&gt; an organization that is set up to reduce code ownership, and they struggle to attract talent<p>These might not be related though?<p>&gt; work is fulfilling<p>&gt; It exhilarating to start projects, then see them degrade inevitably into corporate monstrosities.<p>What you describe does not sound pleasant. So it&#x27;s not fulfilling after all?</div><br/><div id="37996379" class="c"><input type="checkbox" id="c-37996379" checked=""/><div class="controls bullet"><span class="by">sam_lowry_</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37996211">parent</a><span>|</span><a href="#37995630">next</a><span>|</span><label class="collapse" for="c-37996379">[-]</label><label class="expand" for="c-37996379">[1 more]</label></div><br/><div class="children"><div class="content">Projects are fulfilling because they have public utility.<p>The no individual code ownership policy is hard to bear for inquisitive minds, though.<p>Thus the talent shortage.</div><br/></div></div></div></div></div></div></div></div><div id="37995630" class="c"><input type="checkbox" id="c-37995630" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37995538">parent</a><span>|</span><a href="#37995573">prev</a><span>|</span><a href="#37995774">next</a><span>|</span><label class="collapse" for="c-37995630">[-]</label><label class="expand" for="c-37995630">[2 more]</label></div><br/><div class="children"><div class="content">As I have said - every team is different :)<p>In response to your first point I guess things really depend on <i>where</i> you store PR metadata and how ephemeral&#x2F;permanent it is. Some teams store that information in the ticket, some fill implementation notes with change request, some add that to the PR, some discuss in their standup (or similar) meeting.<p>Regarding 2-3, you are right, I just lumped them all under umbrella term.<p>Maybe we could use terms like &quot;PR review&quot; and &quot;code review&quot;. The former is a shallow LGTM check, while the latter may involve code checkout, poking around, architectural discussions, pair&#x2F;team programming and so on. In my book they are entirely different beasts and web tools are geared (not without justification) towards the former, where both types of diff <i>should</i> serve the purpose.</div><br/><div id="37996204" class="c"><input type="checkbox" id="c-37996204" checked=""/><div class="controls bullet"><span class="by">yarekt</span><span>|</span><a href="#37995493">root</a><span>|</span><a href="#37995630">parent</a><span>|</span><a href="#37995774">next</a><span>|</span><label class="collapse" for="c-37996204">[-]</label><label class="expand" for="c-37996204">[1 more]</label></div><br/><div class="children"><div class="content">To me this happens naturally, Looking at the diff first, if I know the codebase well might be enough to get a sense of the changes, or at least understand their isolation. However, as soon as I start to feel that I don&#x27;t fully understand the implications, I quickly check the branch out and poke in an editor.<p>OP is right though, if the &quot;check out in editor&quot; workflow was much smoother (than quick web view) I would prefer to always do that</div><br/></div></div></div></div></div></div><div id="37995774" class="c"><input type="checkbox" id="c-37995774" checked=""/><div class="controls bullet"><span class="by">lvncelot</span><span>|</span><a href="#37995493">parent</a><span>|</span><a href="#37995538">prev</a><span>|</span><a href="#37996066">next</a><span>|</span><label class="collapse" for="c-37995774">[-]</label><label class="expand" for="c-37995774">[1 more]</label></div><br/><div class="children"><div class="content">I agree about what to expect from a code review - but for me, certain ways of working need to be in place for this to function properly.<p>A code review is the &quot;last line of defense&quot; (well, disregarding CI), but in the teams I&#x27;ve worked in, that meant that the general idea of what the PR is introducing has been discussed by multiple people at that point. (This could be either a pairing session, an in-depth explanation, or just a coffee chat, depending on the complexity) This way the PR isn&#x27;t about reviewing the general strategy (splitting off a new module, introducing a huge dependency, reworking the API surface), but just about reviewing the tactics used to implement that strategy.<p>Without the communication beforehand, doing only sanity checks on parts of the code in isolation does run the risk of fracturing code ownership. (&quot;What&#x27;s that module doing?&quot; &quot;Beats me, ask bob&quot;)<p>That all notwithstanding, I like the author&#x27;s idea of what a diff view should look like, regardless of the &quot;mode&quot; of reviewing.</div><br/></div></div><div id="37996066" class="c"><input type="checkbox" id="c-37996066" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37995493">parent</a><span>|</span><a href="#37995774">prev</a><span>|</span><a href="#37996110">next</a><span>|</span><label class="collapse" for="c-37996066">[-]</label><label class="expand" for="c-37996066">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that this isn&#x27;t a great way to catch areas of the codebase that should&#x27;ve been updated, but weren&#x27;t.</div><br/></div></div></div></div><div id="37996110" class="c"><input type="checkbox" id="c-37996110" checked=""/><div class="controls bullet"><span class="by">jakub_g</span><span>|</span><a href="#37995493">prev</a><span>|</span><a href="#37995764">next</a><span>|</span><label class="collapse" for="c-37996110">[-]</label><label class="expand" for="c-37996110">[2 more]</label></div><br/><div class="children"><div class="content">FYI if using GitHub, on github.com pull request page, press `.`, or change domain name to github.dev.<p>This will open VSCode in browser, with the pull request in diff view.<p>Advantages:<p>- you see whole files there<p>- diff algo is different than on github.com, sometimes more readable for complex diffs</div><br/><div id="37996273" class="c"><input type="checkbox" id="c-37996273" checked=""/><div class="controls bullet"><span class="by">vasergen</span><span>|</span><a href="#37996110">parent</a><span>|</span><a href="#37995764">next</a><span>|</span><label class="collapse" for="c-37996273">[-]</label><label class="expand" for="c-37996273">[1 more]</label></div><br/><div class="children"><div class="content">thanks for the tip</div><br/></div></div></div></div><div id="37995764" class="c"><input type="checkbox" id="c-37995764" checked=""/><div class="controls bullet"><span class="by">knubie</span><span>|</span><a href="#37996110">prev</a><span>|</span><a href="#37995625">next</a><span>|</span><label class="collapse" for="c-37995764">[-]</label><label class="expand" for="c-37995764">[3 more]</label></div><br/><div class="children"><div class="content">A third (fourth?) option worth mentioning here is difftastic[0], which uses &quot;structural&quot; diffing (as opposed to line diffing) for more granular diff highlighting.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Wilfred&#x2F;difftastic">https:&#x2F;&#x2F;github.com&#x2F;Wilfred&#x2F;difftastic</a></div><br/><div id="37996286" class="c"><input type="checkbox" id="c-37996286" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#37995764">parent</a><span>|</span><a href="#37995797">next</a><span>|</span><label class="collapse" for="c-37996286">[-]</label><label class="expand" for="c-37996286">[1 more]</label></div><br/><div class="children"><div class="content">ediff in emacs does this.  Refine is what highlights the words that are different.</div><br/></div></div><div id="37995797" class="c"><input type="checkbox" id="c-37995797" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#37995764">parent</a><span>|</span><a href="#37996286">prev</a><span>|</span><a href="#37995625">next</a><span>|</span><label class="collapse" for="c-37995797">[-]</label><label class="expand" for="c-37995797">[1 more]</label></div><br/><div class="children"><div class="content">This is a great approach indeed, pity it&#x27;s not integrated widely enough (think it only recently got a proper structured json output other tools could use)</div><br/></div></div></div></div><div id="37995625" class="c"><input type="checkbox" id="c-37995625" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37995764">prev</a><span>|</span><a href="#37996115">next</a><span>|</span><label class="collapse" for="c-37995625">[-]</label><label class="expand" for="c-37995625">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m probably missing something here: author says that the split diff doesn&#x27;t work for him, but doesn&#x27;t say why.<p>His ideal diff is pretty much the same as a split-diff but with redundant context removed (context is only on the left, not on both left and right). What utility does he get out of removing redundant context on the RHS of the pane?</div><br/><div id="37995690" class="c"><input type="checkbox" id="c-37995690" checked=""/><div class="controls bullet"><span class="by">klauserc</span><span>|</span><a href="#37995625">parent</a><span>|</span><a href="#37995665">next</a><span>|</span><label class="collapse" for="c-37995690">[-]</label><label class="expand" for="c-37995690">[4 more]</label></div><br/><div class="children"><div class="content">The author writes<p>&gt; I need to run tests, use goto definition and other editor navigation features, apply local changes to check if some things could have been written differently, look at the wider context to notice things that should have been changed, and in general notice anything that might be not quite right with the codebase, irrespective of the historical path to the current state of the code.<p>The editors&#x2F;IDEs I&#x27;ve used usually only offer rudimentary support in diffs (goto defn, but only in the same file; maybe auto-completion, but usually not for newly added items; no refactoring functionality)</div><br/><div id="37995849" class="c"><input type="checkbox" id="c-37995849" checked=""/><div class="controls bullet"><span class="by">pama</span><span>|</span><a href="#37995625">root</a><span>|</span><a href="#37995690">parent</a><span>|</span><a href="#37995924">next</a><span>|</span><label class="collapse" for="c-37995849">[-]</label><label class="expand" for="c-37995849">[1 more]</label></div><br/><div class="children"><div class="content">Maybe time to try Emacs?  The diff support is great. And magit is native to Emacs.</div><br/></div></div><div id="37995924" class="c"><input type="checkbox" id="c-37995924" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37995625">root</a><span>|</span><a href="#37995690">parent</a><span>|</span><a href="#37995849">prev</a><span>|</span><a href="#37995903">next</a><span>|</span><label class="collapse" for="c-37995924">[-]</label><label class="expand" for="c-37995924">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The editors&#x2F;IDEs I&#x27;ve used usually only offer rudimentary support in diffs (goto defn, but only in the same file; maybe auto-completion, but usually not for newly added items; no refactoring functionality)<p>Sure, but (to me it seems that) that doesn&#x27;t necessitate the display change he is advocating for.<p>A diff program that has nice code navigation (and&#x2F;or other IDE features) would be great, but what does that have to do with whether it is displaying the common split-diff, or his take on the split-diff.</div><br/></div></div><div id="37995903" class="c"><input type="checkbox" id="c-37995903" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#37995625">root</a><span>|</span><a href="#37995690">parent</a><span>|</span><a href="#37995924">prev</a><span>|</span><a href="#37995665">next</a><span>|</span><label class="collapse" for="c-37995903">[-]</label><label class="expand" for="c-37995903">[1 more]</label></div><br/><div class="children"><div class="content">One area where vscode+gitlens plugin beats IntelliJ, the plugin adds in fully featured editable RHS to diff view</div><br/></div></div></div></div><div id="37995665" class="c"><input type="checkbox" id="c-37995665" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#37995625">parent</a><span>|</span><a href="#37995690">prev</a><span>|</span><a href="#37996115">next</a><span>|</span><label class="collapse" for="c-37995665">[-]</label><label class="expand" for="c-37995665">[2 more]</label></div><br/><div class="children"><div class="content">LHS shows current code, without any modifications. By showing full context in one view (with code browsing capabilities!) and changes in the other, the author is able to browse the code and see what changes, if any, are applied in a particular context.<p>In my understanding the author wants to flip the diff around: instead of looking at changes themselves, the author wants to look at code and see if there are any associated changes.<p>The article is light on detail, but my guess would be that author wants to look at code and browse to implementation&#x2F;callsite to check if appropriate changes are there.</div><br/><div id="37995945" class="c"><input type="checkbox" id="c-37995945" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37995625">root</a><span>|</span><a href="#37995665">parent</a><span>|</span><a href="#37996115">next</a><span>|</span><label class="collapse" for="c-37995945">[-]</label><label class="expand" for="c-37995945">[1 more]</label></div><br/><div class="children"><div class="content">&gt; LHS shows current code, without any modifications. By showing full context in one view (with code browsing capabilities!) and <i>changes in the other</i>, the author is able to browse the code and see what changes, if any, are applied in a particular context.<p>That&#x27;s the bit I don&#x27;t understand - how does the &quot;changes in the other&quot; help if displayed only as the unified snippet[1]? To my mind, the magic sauce bit is the full code navigation, and there&#x27;s no reason that the RHS pane has to be limited to a unified diff when it can simply show the whole file with higlighted lines, the way split diff views do on the RHS.<p>[1] Perhaps (and I&#x27;m only guessing here), that the RHS must show the entire unified diff for the entire changeset, and not just the unified diff for the current file. To me, that makes the proposal an upgrade from &quot;either show unified diff, or split-diff, file-by-file&quot;.</div><br/></div></div></div></div></div></div><div id="37996115" class="c"><input type="checkbox" id="c-37996115" checked=""/><div class="controls bullet"><span class="by">JNRowe</span><span>|</span><a href="#37995625">prev</a><span>|</span><a href="#37995634">next</a><span>|</span><label class="collapse" for="c-37996115">[-]</label><label class="expand" for="c-37996115">[1 more]</label></div><br/><div class="children"><div class="content">That kinda feels like how I review with vim.<p>* A little scripting around opening the PR, which basically performs a &quot;vimdiff &lt;(git show <i>baseref</i>:<i>file</i>) <i>file</i>&quot;-style dance on the changes.  Using vim&#x27;s tabs is great for this as they&#x27;re really only views, so you can hold individual buffers open in distinct states at the same time.<p>* Scroll locking still works as expected in the main view, but you can avoid it in a separate tab when needed.<p>* [c and ]c move between hunks from the set of changes as they exist in the PR not in the working directory.<p>* dp and dg allow you to mark hunks as &quot;done&quot; by pushing&#x2F;pulling the hunk in to the read-only diff buffer so that they&#x27;re now hidden from the highlighted changes in the live buffer.<p>* Changes you make in the live buffer are available to commit directly, or push as a comment.<p>* All your regular editor things work as expected in the current state of the tree; go to definition, build integration, popup docs, etc.<p>Working like this means you&#x27;re viewing changes against the PR&#x27;s base, but have a clean working directory.  That, to me, feels like a significant improvement over matklad&#x27;s solution of having the working directory be in an unclean state to view the changes.<p>The environment I work in makes this behaviour super nice as changes will often be added with a --fixup commit, and then the tooling mangles them back together with a git-interpret-trailers call to attribute the fixup commit&#x27;s author to the original commit at merge time.  It also pulls text comments out of the PR and attaches a Reviewed-by trailer where appropriate, or the +1 equivalent to tack an Acked-by trailer on.</div><br/></div></div><div id="37995634" class="c"><input type="checkbox" id="c-37995634" checked=""/><div class="controls bullet"><span class="by">jessekv</span><span>|</span><a href="#37996115">prev</a><span>|</span><a href="#37996175">next</a><span>|</span><label class="collapse" for="c-37995634">[-]</label><label class="expand" for="c-37995634">[3 more]</label></div><br/><div class="children"><div class="content">Meld works pretty well for these use cases.<p><a href="https:&#x2F;&#x2F;meldmerge.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;meldmerge.org&#x2F;</a></div><br/><div id="37995685" class="c"><input type="checkbox" id="c-37995685" checked=""/><div class="controls bullet"><span class="by">ktpsns</span><span>|</span><a href="#37995634">parent</a><span>|</span><a href="#37995779">next</a><span>|</span><label class="collapse" for="c-37995685">[-]</label><label class="expand" for="c-37995685">[1 more]</label></div><br/><div class="children"><div class="content">A honorable mention is also <a href="https:&#x2F;&#x2F;kdiff3.sourceforge.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;kdiff3.sourceforge.net&#x2F;</a> which has a lot of nice views.</div><br/></div></div><div id="37995779" class="c"><input type="checkbox" id="c-37995779" checked=""/><div class="controls bullet"><span class="by">bsimpson</span><span>|</span><a href="#37995634">parent</a><span>|</span><a href="#37995685">prev</a><span>|</span><a href="#37996175">next</a><span>|</span><label class="collapse" for="c-37995779">[-]</label><label class="expand" for="c-37995779">[1 more]</label></div><br/><div class="children"><div class="content">Looks a lot like FileMerge, which comes with the Apple developer tools.</div><br/></div></div></div></div><div id="37996175" class="c"><input type="checkbox" id="c-37996175" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#37995634">prev</a><span>|</span><a href="#37996342">next</a><span>|</span><label class="collapse" for="c-37996175">[-]</label><label class="expand" for="c-37996175">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sadly, this format of review isn’t well supported by the tools — everyone seems to be happy reviewing diffs, rather than the actual code?<p>Maybe us plebs just use the diff viewer (or GitHub or) and the IDE&#x2F;editor&#x2F;terminal as separate applications.</div><br/></div></div><div id="37996342" class="c"><input type="checkbox" id="c-37996342" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#37996175">prev</a><span>|</span><a href="#37995693">next</a><span>|</span><label class="collapse" for="c-37996342">[-]</label><label class="expand" for="c-37996342">[2 more]</label></div><br/><div class="children"><div class="content">How does this work for deleted lines, since these don&#x27;t have a corresponding line in the &quot;current&quot; view.</div><br/><div id="37996403" class="c"><input type="checkbox" id="c-37996403" checked=""/><div class="controls bullet"><span class="by">matklad</span><span>|</span><a href="#37996342">parent</a><span>|</span><a href="#37995693">next</a><span>|</span><label class="collapse" for="c-37996403">[-]</label><label class="expand" for="c-37996403">[1 more]</label></div><br/><div class="children"><div class="content">Like this:<p><a href="https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;1711539&#x2F;277602101-79179583-2c2e-46db-90c6-8acfd4f57b0e.png" rel="nofollow noreferrer">https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;1711539&#x2F;277602101-...</a></div><br/></div></div></div></div><div id="37995693" class="c"><input type="checkbox" id="c-37995693" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#37996342">prev</a><span>|</span><a href="#37995673">next</a><span>|</span><label class="collapse" for="c-37995693">[-]</label><label class="expand" for="c-37995693">[2 more]</label></div><br/><div class="children"><div class="content">I often hear KDiff3 recommended in these cases.  There are many graphical diff visualizers.  I often use the ediff functions in Emacs.</div><br/><div id="37996394" class="c"><input type="checkbox" id="c-37996394" checked=""/><div class="controls bullet"><span class="by">shiroiuma</span><span>|</span><a href="#37995693">parent</a><span>|</span><a href="#37995673">next</a><span>|</span><label class="collapse" for="c-37996394">[-]</label><label class="expand" for="c-37996394">[1 more]</label></div><br/><div class="children"><div class="content">Even though I&#x27;m a KDE fan, I usually use Meld for diffing, especially since I&#x27;ve set it up with a lot of custom filters for certain cases.  However, when I want to compare 3 different files, kdiff3 is my go-to tool.</div><br/></div></div></div></div><div id="37995673" class="c"><input type="checkbox" id="c-37995673" checked=""/><div class="controls bullet"><span class="by">klauserc</span><span>|</span><a href="#37995693">prev</a><span>|</span><a href="#37996017">next</a><span>|</span><label class="collapse" for="c-37995673">[-]</label><label class="expand" for="c-37995673">[1 more]</label></div><br/><div class="children"><div class="content">Ooooh, I need to try this!<p>When working on a PR myself, I frequently avoid doing small, incremental commits because I find the subtle &quot;these lines changed&quot; annotations in IDEs extremely useful. It helps me find the locations in code that are relevant to my work.<p>I wish there was a way to configure e.g., IntelliJ to always show these markers relative to `main` instead of the last commit.</div><br/></div></div><div id="37996017" class="c"><input type="checkbox" id="c-37996017" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#37995673">prev</a><span>|</span><a href="#37995644">next</a><span>|</span><label class="collapse" for="c-37996017">[-]</label><label class="expand" for="c-37996017">[1 more]</label></div><br/><div class="children"><div class="content">This might be a useage thing but author seems to already point out that for a large code review, these two options aren&#x27;t sufficient, but I&#x27;ve never seen these tools offer themselves as a solution to a large review.<p>They&#x27;re a diff tool. The author&#x27;s approach is creative but seems like it&#x27;s the wrong tool for the job.</div><br/></div></div><div id="37995644" class="c"><input type="checkbox" id="c-37995644" checked=""/><div class="controls bullet"><span class="by">nhinck2</span><span>|</span><a href="#37996017">prev</a><span>|</span><a href="#37995602">next</a><span>|</span><label class="collapse" for="c-37995644">[-]</label><label class="expand" for="c-37995644">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s kind of funny that the left view is Word track changes.<p>I do think it&#x27;s better actually, never thought about it. It might even function better if you could explode the changes out by clicking.</div><br/></div></div><div id="37995602" class="c"><input type="checkbox" id="c-37995602" checked=""/><div class="controls bullet"><span class="by">ibizaman</span><span>|</span><a href="#37995644">prev</a><span>|</span><a href="#37996113">next</a><span>|</span><label class="collapse" for="c-37995602">[-]</label><label class="expand" for="c-37995602">[1 more]</label></div><br/><div class="children"><div class="content">I do the same! I checkout the branch of the PR then do a mixed reset to origin&#x2F;main. This way, the git status shows all the changes. It’s really neat indeed.</div><br/></div></div><div id="37996113" class="c"><input type="checkbox" id="c-37996113" checked=""/><div class="controls bullet"><span class="by">altairprime</span><span>|</span><a href="#37995602">prev</a><span>|</span><a href="#37995755">next</a><span>|</span><label class="collapse" for="c-37996113">[-]</label><label class="expand" for="c-37996113">[1 more]</label></div><br/><div class="children"><div class="content">That desired view looks a lot like Kaleidoscope (ksdiff). I thought it was a screenshot of that at first.</div><br/></div></div><div id="37995755" class="c"><input type="checkbox" id="c-37995755" checked=""/><div class="controls bullet"><span class="by">difosfor</span><span>|</span><a href="#37996113">prev</a><span>|</span><a href="#37995574">next</a><span>|</span><label class="collapse" for="c-37995755">[-]</label><label class="expand" for="c-37995755">[2 more]</label></div><br/><div class="children"><div class="content">I’m surprised how we’re all still using line based diffs and even seemingly stupid ones at that. But the tales I hear from across the pond of paid git alternatives which diff based on understanding the programming language seem to be pretty bad as well. Though for other reasons?</div><br/><div id="37995830" class="c"><input type="checkbox" id="c-37995830" checked=""/><div class="controls bullet"><span class="by">guiraldelli</span><span>|</span><a href="#37995755">parent</a><span>|</span><a href="#37995574">next</a><span>|</span><label class="collapse" for="c-37995830">[-]</label><label class="expand" for="c-37995830">[1 more]</label></div><br/><div class="children"><div class="content">It might be because of formatting, but that is exactly what I would have expected them to handle well.<p>Anyway, I have used a FOSS that does that, difftastic [1], and it does a pretty good job at language diff&#x27;ing without the annoyance of formatting as I hypothesised earlier.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;Wilfred&#x2F;difftastic">https:&#x2F;&#x2F;github.com&#x2F;Wilfred&#x2F;difftastic</a></div><br/></div></div></div></div><div id="37995574" class="c"><input type="checkbox" id="c-37995574" checked=""/><div class="controls bullet"><span class="by">juliangmp</span><span>|</span><a href="#37995755">prev</a><span>|</span><a href="#37996156">next</a><span>|</span><label class="collapse" for="c-37995574">[-]</label><label class="expand" for="c-37995574">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t thought about this in detail much before but honestly that &quot;view&quot; the author proposed does look pretty nice.
Though I think that something like difftastic is still a bit better, though I haven&#x27;t properly integrated it into my workflow.</div><br/></div></div><div id="37996156" class="c"><input type="checkbox" id="c-37996156" checked=""/><div class="controls bullet"><span class="by">yawboakye</span><span>|</span><a href="#37995574">prev</a><span>|</span><label class="collapse" for="c-37996156">[-]</label><label class="expand" for="c-37996156">[1 more]</label></div><br/><div class="children"><div class="content">looks like the code review is happening too late. here the post’s author is also trying—hard—to reconstruct the mental states and models of the code author, especially in the large&#x2F;significant update case. i argue that this workflow is a relic of the past, and should be replaced by a two-phase flow where in the beginning the essential ideas of the new changes are proposed, discussed, approved. then lines of code may be added or removed. the update is semantically grouped (perhaps via a commit) to correspond to key decisions made during phase one.<p>that way the problem of encountering new ideas through the darker medium of code and struggling to comprehend is solved, since now the ideas are presented and evaluated in a human language. the subsequent code review confirms that the implementation adheres to the gaveled proposal, and this can be easily done, even by a junior developer.</div><br/></div></div></div></div></div></div></div></body></html>