<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713603652411" as="style"/><link rel="stylesheet" href="styles.css?v=1713603652411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.gamesthatwerent.com/2024/01/the-endless-maze-algorithm/">The Endless Maze algorithm (Atari 2600)</a>Â <span class="domain">(<a href="https://www.gamesthatwerent.com">www.gamesthatwerent.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>4 comments</span></div><br/><div><div id="40095735" class="c"><input type="checkbox" id="c-40095735" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#40095793">next</a><span>|</span><label class="collapse" for="c-40095735">[-]</label><label class="expand" for="c-40095735">[1 more]</label></div><br/><div class="children"><div class="content">My 1988 submission to the International Obfuscated C Code Contest was this maze generator:<p><pre><code>    char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M=&quot;%d&quot;,&amp;C);
    --            E;             J[              E]             =T
    [E   ]=  E)   printf(&quot;._&quot;);  for(;(A-=Z=!Z)  ||  (printf(&quot;\n|&quot;
    )    ,   A    =              39              ,C             --
    )    ;   Z    ||    printf   (M   ))M[Z]=Z[A-(E   =A[J-Z])&amp;&amp;!C
    &amp;    A   ==             T[                                  A]
    |6&lt;&lt;27&lt;rand()||!C&amp;!Z?J[T[E]=T[A]]=E,J[T[A]=A-Z]=A,&quot;_.&quot;:&quot; |&quot;];}
</code></pre>
expecting a number on stdin and then generating a maze of that height line by line. For a negative number it will effectively produce an endless maze. As it turned out I had independently rediscovered Eller&#x27;s algorithm (<a href="https:&#x2F;&#x2F;weblog.jamisbuck.org&#x2F;2010&#x2F;12&#x2F;29&#x2F;maze-generation-eller-s-algorithm" rel="nofollow">https:&#x2F;&#x2F;weblog.jamisbuck.org&#x2F;2010&#x2F;12&#x2F;29&#x2F;maze-generation-elle...</a>).<p>Note that the constant 27 assumes a 31-bit random number generator, and needs to be replaced with 11 if rand() produces 15-bit numbers instead. Modern C compilers don&#x27;t allow constant strings to be overwritten, which can be avoided by changing the first line to<p><pre><code>    char M[3],A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(&quot;%d&quot;,&amp;C);
</code></pre>
The program is explained in detail in <a href="https:&#x2F;&#x2F;tromp.github.io&#x2F;maze.html" rel="nofollow">https:&#x2F;&#x2F;tromp.github.io&#x2F;maze.html</a></div><br/></div></div><div id="40095793" class="c"><input type="checkbox" id="c-40095793" checked=""/><div class="controls bullet"><span class="by">toppy</span><span>|</span><a href="#40095735">prev</a><span>|</span><a href="#40094473">next</a><span>|</span><label class="collapse" for="c-40095793">[-]</label><label class="expand" for="c-40095793">[1 more]</label></div><br/><div class="children"><div class="content">For Commodore there is this classic recipe [1] for infinite maze:<p>10 PRINT CHR$(205.5+RND(1)); : GOTO 10<p>[1] <a href="https:&#x2F;&#x2F;10print.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;10print.org&#x2F;</a></div><br/></div></div><div id="40094473" class="c"><input type="checkbox" id="c-40094473" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40095793">prev</a><span>|</span><label class="collapse" for="c-40094473">[-]</label><label class="expand" for="c-40094473">[1 more]</label></div><br/><div class="children"><div class="content">Looking at the animation, I feel I have a pretty good idea on how to go about implementing an endless scrolling random maze, without reading any paper, studying anyone&#x27;s code.<p>It looks like in every horizontal hallway (run of adjacent empty squares), there is at least one exit in the next row; i.e. at least one empty square.<p>Furthermore, there is definitely an even-odd row alternating pattern. The odd rows have more horizontal passages (runs of empty squares). The even rows have more single-square passages, as if connecting the odd rows. It&#x27;s not entirely consistent across the field. It might be the result of some game-of-life like rules, like when multiple through-passages are clumped close together in the previous row, a connecting hallway will appear.  Or, no, here is the thing. The algorithm avoids consecutive thick walls. So that is to say, if a given row has two or more adjacent walls ### there will be at most wall there in the next row. Nowhere in the maze animation do you see this:<p><pre><code>  ##
  ##
  ###
</code></pre>
(Assume we are scrolling upward, like a terminal, adding new rows at the bottom). You don&#x27;t see consecutive thick walls. Always something like thisL<p><pre><code>  ###
   #
   #
</code></pre>
So for instance say we have this row:<p><pre><code>  #### ##     # #### #    ###
</code></pre>
Firstly, we ensure that all our spaces have at least one exit:<p><pre><code>  #### ##     # #### #    ###
  ###########################  ;; start with a filled row
</code></pre>
Now punch the holes:<p><pre><code>  #### ##     # #### #    ###
  #### #### ########## # ####
</code></pre>
Now, eliminate thick walls, careful not to make any new holes:<p><pre><code>  #### ##     # #### #    ###
  #  # # ## #####  ### # ##  
</code></pre>
Now repeat:<p><pre><code>  #### ##     # #### #    ###  (a)
  #  # # ## #####  ### # ## 
  ###########################

  #### ##     # #### #    ###  (b)
  #  # # ## #####  ### # ## 
  ## # # ## ##### #### # ## #
 
  #### ##     # #### #    ###  (c)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
</code></pre>
Keep going:<p><pre><code>  #### ##     # #### #    ###  (a)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
  ###########################

  #### ##     # #### #    ###  (a)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
  ## # # ## # ## ## ##### # #
</code></pre>
Notice that here we have very little to do for step (c); only one parallel thick wall has occurred:<p><pre><code>  #### ##     # #### #    ###  (c)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
   # # # ## # ## ## ##### # #
</code></pre>
Then:<p><pre><code>  #### ##     # #### #    ###  (a)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
   # # # ## # ## ## ##### # #
  ###########################

  #### ##     # #### #    ###  (b)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
   # # # ## # ## ## ##### # #
  ## # # ## # ## ## ##### # #

  #### ##     # #### #    ###  (c)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
   # # # ## # ## ## ##### # #
  ## # #  # # #   # #     # #


  #### ##     # #### #    ###  (a)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
   # # # ## # ## ## ##### # #
  ## # #  # # #   # #     # #
  ###########################

  #### ##     # #### #    ###  (b)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
   # # # ## # ## ## ##### # #
  ## # #  # # #   # #     # #
  ## # ## # # ### # ##### # #

  #### ##     # #### #    ###  (c)
  #  # # ## #####  ### # ## 
  ## # # #  #     #    #  # #
   # # # ## # ## ## ##### # #
  ## # #  # # #   # #     # #
  #  # ## # # ### # ##### # #
</code></pre>
The trouble is that we have parallel, disjoint passages.<p>We need one more behavior, so that the adjacent passages can merge together. For instance, sometimes if we have _#_ (space hash space), we replace the hash with a space. Or something like that.<p>An important observation is that not only do parallel walls not occur, but parallel passages do not occur. I.e we don&#x27;t see two spaces going to two spaces:<p><pre><code>  ##  ##
  ##  ##
</code></pre>
In a two space hallway, we can carve out at most one exit into the next row. So if we then remove additional walls to make spaces, we have to keep that in mind; don&#x27;t do it in such a way that parallel passages would arise.</div><br/></div></div></div></div></div></div></div></body></html>