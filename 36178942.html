<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685955681113" as="style"/><link rel="stylesheet" href="styles.css?v=1685955681113"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.n16f.net/blog/reduce-vs-fold-in-common-lisp/">Reduce vs. Fold in Common Lisp</a> <span class="domain">(<a href="https://www.n16f.net">www.n16f.net</a>)</span></div><div class="subtext"><span>billiob</span> | <span>22 comments</span></div><br/><div><div id="36190502" class="c"><input type="checkbox" id="c-36190502" checked=""/><div class="controls bullet"><span class="by">ruricolist</span><span>|</span><a href="#36192310">next</a><span>|</span><label class="collapse" for="c-36190502">[-]</label><label class="expand" for="c-36190502">[7 more]</label></div><br/><div class="children"><div class="content">The history here is that Common Lisp gets reduce from APL (<a href="https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;Reduce" rel="nofollow">https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;Reduce</a>). It&#x27;s not an attempt an ML-style fold, but a different formalism from a different lineage.</div><br/><div id="36191611" class="c"><input type="checkbox" id="c-36191611" checked=""/><div class="controls bullet"><span class="by">myco_logic</span><span>|</span><a href="#36190502">parent</a><span>|</span><a href="#36191540">next</a><span>|</span><label class="collapse" for="c-36191611">[-]</label><label class="expand" for="c-36191611">[5 more]</label></div><br/><div class="children"><div class="content">While reading this, I was immediately reminded of the reduce operator, glad to see my intuition wasn&#x27;t far off.<p>The nifty thing about this operator in the array-langs compared to the usual fold function is that they usually define identity elements for all primitive functions, which means that no initial value has to be provided: <a href="https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;Identity_element" rel="nofollow">https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;Identity_element</a><p>The downside of this approach though, is that using reduce with non-primitive functions can result in domain errors (at least in APL). I think BQN&#x27;s version of the operator is a bit nicer, in that it allows you to specify an initial value in this situation: <a href="https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;doc&#x2F;fold.html" rel="nofollow">https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;doc&#x2F;fold.html</a></div><br/><div id="36192126" class="c"><input type="checkbox" id="c-36192126" checked=""/><div class="controls bullet"><span class="by">0x69420</span><span>|</span><a href="#36190502">root</a><span>|</span><a href="#36191611">parent</a><span>|</span><a href="#36191748">next</a><span>|</span><label class="collapse" for="c-36192126">[-]</label><label class="expand" for="c-36192126">[1 more]</label></div><br/><div class="children"><div class="content">&gt; they usually define identity elements for all primitive functions
&gt; using reduce with non-primitive functions can result in domain errors<p>ml-style folds in the presence of ad-hoc polymorphism solve this rather handily -- in haskell for instance monoid is the typeclass that only requires an associative operation and an identity element<p>typeclasses have some clunkiness in this regard; you have to wrap numeric types as &quot;sum&quot; or &quot;product&quot; etc to go &quot;ah yes today i want to say numbers are a monoid under <i>this</i> operation&quot; but at the very least it does enable formal, user-defined associations between identity elements and functions<p>luckily most things programmers deal with are plausibly just one kind of monoid. for instance the eleventy billion different string types haskell programmers love to use all tend to satisfy monoid under concatenation without any wrappers</div><br/></div></div><div id="36191748" class="c"><input type="checkbox" id="c-36191748" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#36190502">root</a><span>|</span><a href="#36191611">parent</a><span>|</span><a href="#36192126">prev</a><span>|</span><a href="#36191540">next</a><span>|</span><label class="collapse" for="c-36191748">[-]</label><label class="expand" for="c-36191748">[3 more]</label></div><br/><div class="children"><div class="content">&gt; downside of this approach though, is that using reduce with non-primitive functions can result in domain errors<p>Yes, that&#x27;s another problem.  There is precedent for associating metadata with user-defined functions (eg inverses); identities seem to have fallen by the wayside, but I am planning to fix that for j.</div><br/><div id="36191922" class="c"><input type="checkbox" id="c-36191922" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#36190502">root</a><span>|</span><a href="#36191748">parent</a><span>|</span><a href="#36191540">next</a><span>|</span><label class="collapse" for="c-36191922">[-]</label><label class="expand" for="c-36191922">[2 more]</label></div><br/><div class="children"><div class="content">Defining a number of related functions seems to be a pattern that comes up elsewhere.   For example, consider functions that compute a hash value, canonicalize, and compute some notion of equality.  It would be useful to associate all of these.</div><br/><div id="36192197" class="c"><input type="checkbox" id="c-36192197" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#36190502">root</a><span>|</span><a href="#36191922">parent</a><span>|</span><a href="#36191540">next</a><span>|</span><label class="collapse" for="c-36192197">[-]</label><label class="expand" for="c-36192197">[1 more]</label></div><br/><div class="children"><div class="content">Haskell calls these &#x27;typeclasses&#x27;; cl calls them &#x27;protocols&#x27;.  Apl style is not to expose sophisticated user-level abstractions, so I think that there it is not inappropriate that the scope of associable objects (say, a monad, a dyad, an inverse, and an identity; perhaps a few others) be fixed by the language.</div><br/></div></div></div></div></div></div></div></div><div id="36191540" class="c"><input type="checkbox" id="c-36191540" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#36190502">parent</a><span>|</span><a href="#36191611">prev</a><span>|</span><a href="#36192310">next</a><span>|</span><label class="collapse" for="c-36191540">[-]</label><label class="expand" for="c-36191540">[1 more]</label></div><br/><div class="children"><div class="content">I never heard of apl&#x27;s allowing for an explicit choice of initial value, nor direction control (&#x27;from-end&#x27;), which mls typically also provide (foldl vs foldr).  On the other hand, the ad-hoc choice of result for an empty input is a flaw common to cl and apl.</div><br/></div></div></div></div><div id="36192310" class="c"><input type="checkbox" id="c-36192310" checked=""/><div class="controls bullet"><span class="by">dreamcompiler</span><span>|</span><a href="#36190502">prev</a><span>|</span><a href="#36190147">next</a><span>|</span><label class="collapse" for="c-36192310">[-]</label><label class="expand" for="c-36192310">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It then applies the function to successive pairs of sequence elements.<p>No. #&#x27;reduce may take the first pair as an optimization step, but from that point on it processes sequence elements one at a time. It passes an accumulated value and the next sequence value to the function.</div><br/></div></div><div id="36190147" class="c"><input type="checkbox" id="c-36190147" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#36192310">prev</a><span>|</span><a href="#36193689">next</a><span>|</span><label class="collapse" for="c-36190147">[-]</label><label class="expand" for="c-36190147">[2 more]</label></div><br/><div class="children"><div class="content"><i>…REDUCE functions can be called with zero, one or two list values.</i><p>No, it&#x27;s either two or zero arguments.</div><br/><div id="36190209" class="c"><input type="checkbox" id="c-36190209" checked=""/><div class="controls bullet"><span class="by">galdor</span><span>|</span><a href="#36190147">parent</a><span>|</span><a href="#36193689">next</a><span>|</span><label class="collapse" for="c-36190209">[-]</label><label class="expand" for="c-36190209">[1 more]</label></div><br/><div class="children"><div class="content">Author here. I double checked the Hyperspec [1] and you&#x27;re quite right. I&#x27;ll fix the article tomorrow, thank you for noticing!<p>[1] <a href="http:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;lw60&#x2F;CLHS&#x2F;Body&#x2F;f_reduce.htm" rel="nofollow">http:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;lw60&#x2F;CLHS&#x2F;Body&#x2F;f_redu...</a></div><br/></div></div></div></div><div id="36193689" class="c"><input type="checkbox" id="c-36193689" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#36190147">prev</a><span>|</span><a href="#36190387">next</a><span>|</span><label class="collapse" for="c-36193689">[-]</label><label class="expand" for="c-36193689">[2 more]</label></div><br/><div class="children"><div class="content">+ is not associative for many types.</div><br/><div id="36193818" class="c"><input type="checkbox" id="c-36193818" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#36193689">parent</a><span>|</span><a href="#36190387">next</a><span>|</span><label class="collapse" for="c-36193818">[-]</label><label class="expand" for="c-36193818">[1 more]</label></div><br/><div class="children"><div class="content">True, which is why Common Lisp accepts a parameter to specify which order the + should be applied - from left to right or vice versa. Left to right is default.</div><br/></div></div></div></div><div id="36190387" class="c"><input type="checkbox" id="c-36190387" checked=""/><div class="controls bullet"><span class="by">somewhereoutth</span><span>|</span><a href="#36193689">prev</a><span>|</span><a href="#36190290">next</a><span>|</span><label class="collapse" for="c-36190387">[-]</label><label class="expand" for="c-36190387">[1 more]</label></div><br/><div class="children"><div class="content">fold is a natural consequence of church lists, probably the most fundamental way of expressing the list abstraction:<p>\f \x (f a0 (f a1 (f a2 x)))<p>So fold is just applying a list (function) to 2 arguments. Or you can be helpful and make something like fold := \f \x \l l f x which is useful for binding the f and the x and applying to multiple lists (everything is Curried of course)<p>LISP is not quite based on lambda calculus, so it should be no surprise it doesn&#x27;t quite get reduce(i.e. fold) right.<p>See also church numerals, which are like lists but without the elements, they also have a &#x27;fold&#x27;:<p>\f \x f (f (f x))) == 3<p>We can make trees! Which again also have a &#x27;fold&#x27;<p>\f \x f a0 (x a1) (f a2 (x a3) (x a4))<p>And many other more exotic folding data structures.</div><br/></div></div><div id="36190290" class="c"><input type="checkbox" id="c-36190290" checked=""/><div class="controls bullet"><span class="by">tangus</span><span>|</span><a href="#36190387">prev</a><span>|</span><a href="#36192605">next</a><span>|</span><label class="collapse" for="c-36190290">[-]</label><label class="expand" for="c-36190290">[3 more]</label></div><br/><div class="children"><div class="content">&gt;Fold is also simpler than REDUCE since it does not have any special case, making it easier to reason about its behaviour.<p>If returning the initial value when the list is empty is considered a special case (or &quot;surprising aspect&quot;) of REDUCE, then it&#x27;s the same for FOLD, no?</div><br/><div id="36190443" class="c"><input type="checkbox" id="c-36190443" checked=""/><div class="controls bullet"><span class="by">thedufer</span><span>|</span><a href="#36190290">parent</a><span>|</span><a href="#36190405">next</a><span>|</span><label class="collapse" for="c-36190443">[-]</label><label class="expand" for="c-36190443">[1 more]</label></div><br/><div class="children"><div class="content">The initial value is optional for `reduce`, but required for `fold`.  If you don&#x27;t pass the initial value to `reduce`, and the sequence argument is empty, then `reduce` calls the function with no arguments, which is unique - in all other cases, it is called with two arguments.  `fold` always calls its function argument with two arguments.<p>This shows up more clearly in statically-typed functional languages, where variadic functions like this are far less common.  In that case, you typically see that `reduce` returns an option type, whereas `fold` does not.  The types would look something like `fold :: (a -&gt; b -&gt; a) -&gt; a -&gt; List b -&gt; a` vs `reduce :: (a -&gt; a -&gt; a) -&gt; List a -&gt; Option a`.</div><br/></div></div><div id="36190405" class="c"><input type="checkbox" id="c-36190405" checked=""/><div class="controls bullet"><span class="by">galdor</span><span>|</span><a href="#36190290">parent</a><span>|</span><a href="#36190443">prev</a><span>|</span><a href="#36192605">next</a><span>|</span><label class="collapse" for="c-36190405">[-]</label><label class="expand" for="c-36190405">[1 more]</label></div><br/><div class="children"><div class="content">The most surprising aspect of REDUCE is the way the callback can be called depending on both the length of the list and the presence of absence of an initial value.</div><br/></div></div></div></div><div id="36192605" class="c"><input type="checkbox" id="c-36192605" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36190290">prev</a><span>|</span><a href="#36192767">next</a><span>|</span><label class="collapse" for="c-36192605">[-]</label><label class="expand" for="c-36192605">[2 more]</label></div><br/><div class="children"><div class="content">so foldl is basically<p><pre><code>  (defun foldl (function value sequence)
    (reduce function sequence :initial-value value))</code></pre></div><br/><div id="36192766" class="c"><input type="checkbox" id="c-36192766" checked=""/><div class="controls bullet"><span class="by">Paul-Craft</span><span>|</span><a href="#36192605">parent</a><span>|</span><a href="#36192767">next</a><span>|</span><label class="collapse" for="c-36192766">[-]</label><label class="expand" for="c-36192766">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;m not seeing what&#x27;s so special either.  Maybe it&#x27;s that you do have to specify that initial value, so your return types are never something you don&#x27;t expect?</div><br/></div></div></div></div><div id="36192767" class="c"><input type="checkbox" id="c-36192767" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#36192605">prev</a><span>|</span><label class="collapse" for="c-36192767">[-]</label><label class="expand" for="c-36192767">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a running image handy, but<p><pre><code>  (+) ; =&gt; 0
  (*) ; =&gt; 1
</code></pre>
and<p><pre><code>  (+ n) ; =&gt; n
  (* n) ; =&gt; n
</code></pre>
which I expect has some bearing on the behavior of reduce in the examples given.<p>It&#x27;s pretty obvious that any other function could either have or be advised to have whatever equivalent semantics are appropriate.<p>Of course<p><pre><code>  (apply #&#x27;+ &#x27;(1 2 3 4 5)) ; =&gt; 15
</code></pre>
So reduce can be obviated by just letting the function take variable args too.</div><br/><div id="36193010" class="c"><input type="checkbox" id="c-36193010" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#36192767">parent</a><span>|</span><label class="collapse" for="c-36193010">[-]</label><label class="expand" for="c-36193010">[2 more]</label></div><br/><div class="children"><div class="content">&gt; So reduce can be obviated by just letting the function take variable args too.<p>In Common Lisp the max number of arguments can be small.<p><pre><code>  $ abcl
  Armed Bear Common Lisp 1.8.0
  Java 11.0.19 Ubuntu
  OpenJDK 64-Bit Server VM
  Low-level initialization completed in 0.304 seconds.
  Startup completed in 1.501 seconds.
  Type &quot;:help&quot; for a list of available commands.

  CL-USER(1): CALL-ARGUMENTS-LIMIT
  50</code></pre></div><br/><div id="36193493" class="c"><input type="checkbox" id="c-36193493" checked=""/><div class="controls bullet"><span class="by">nbernard</span><span>|</span><a href="#36192767">root</a><span>|</span><a href="#36193010">parent</a><span>|</span><label class="collapse" for="c-36193493">[-]</label><label class="expand" for="c-36193493">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. Do you know if that is due to constraints coming from ABCL running on a JVM, or is it an arbitrary choice ? (By contrast, SBCL on a x86_64 laptop returns 4611686018427387903...)</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>