<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694941255658" as="style"/><link rel="stylesheet" href="styles.css?v=1694941255658"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wejn.org/2023/09/running-ones-own-root-certificate-authority-in-2023/">Running one’s own root Certificate Authority in 2023</a> <span class="domain">(<a href="https://wejn.org">wejn.org</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>98 comments</span></div><br/><div><div id="37542794" class="c"><input type="checkbox" id="c-37542794" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#37538495">next</a><span>|</span><label class="collapse" for="c-37542794">[-]</label><label class="expand" for="c-37542794">[1 more]</label></div><br/><div class="children"><div class="content">Looks like step-ca&#x2F;step-cli [1] and mkcert [2] have been mentioned. Another related tool is XCA [3] - a gui tool to manage CAs and server&#x2F;client TLS certificates. It takes off some of the tedium in using openssl cli directly. It also stores the certs and keys in an encrypted  database. It doesn&#x27;t solve the problem of getting the root CA certificate into the system store or of hosting the revocation list. I use XCA to create and store the root CA. Intermediate CAs signed with it are passed to other issuers like vault and step-issuer.<p>[1] <a href="https:&#x2F;&#x2F;smallstep.com&#x2F;docs&#x2F;step-ca&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;smallstep.com&#x2F;docs&#x2F;step-ca&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;FiloSottile&#x2F;mkcert">https:&#x2F;&#x2F;github.com&#x2F;FiloSottile&#x2F;mkcert</a><p>[3] <a href="https:&#x2F;&#x2F;hohnstaedt.de&#x2F;xca&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hohnstaedt.de&#x2F;xca&#x2F;</a></div><br/></div></div><div id="37538495" class="c"><input type="checkbox" id="c-37538495" checked=""/><div class="controls bullet"><span class="by">jordemort</span><span>|</span><a href="#37542794">prev</a><span>|</span><a href="#37542312">next</a><span>|</span><label class="collapse" for="c-37538495">[-]</label><label class="expand" for="c-37538495">[7 more]</label></div><br/><div class="children"><div class="content">I really like step[1] and step-ca[2] for this, it&#x27;s a lot less fiddly than having to drive OpenSSL directly.<p>1. <a href="https:&#x2F;&#x2F;github.com&#x2F;smallstep&#x2F;cli">https:&#x2F;&#x2F;github.com&#x2F;smallstep&#x2F;cli</a><p>2. <a href="https:&#x2F;&#x2F;github.com&#x2F;smallstep&#x2F;certificates">https:&#x2F;&#x2F;github.com&#x2F;smallstep&#x2F;certificates</a></div><br/><div id="37542171" class="c"><input type="checkbox" id="c-37542171" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#37538495">parent</a><span>|</span><a href="#37539267">next</a><span>|</span><label class="collapse" for="c-37542171">[-]</label><label class="expand" for="c-37542171">[3 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t it be nice if LetsEncrypt could issue you a (1) name constrained, (2) 90-day limited intermediate CA with just the (3) DNS-01 challenge? I argue that such an intermediate CA would have no more authority than a wildcard cert which you can get today, so they should be able to issue it. [1] Everything supports name constraints now, which used to be an issue but isn&#x27;t anymore. [2]<p>Then stick it in step-ca and issue all your certificates with internal ACME.<p>This would solve a <i>lot</i> of problems, such as leaking private hostnames in the certificate transparency log, or hitting issuance rate limits on LE servers.<p>[1]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29811552">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29811552</a><p>[2]: <a href="https:&#x2F;&#x2F;bettertls.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;bettertls.com&#x2F;</a></div><br/><div id="37542916" class="c"><input type="checkbox" id="c-37542916" checked=""/><div class="controls bullet"><span class="by">capitol_</span><span>|</span><a href="#37538495">root</a><span>|</span><a href="#37542171">parent</a><span>|</span><a href="#37542516">next</a><span>|</span><label class="collapse" for="c-37542916">[-]</label><label class="expand" for="c-37542916">[1 more]</label></div><br/><div class="children"><div class="content">It would be impossible to enforce that issued certs are submitted to certificate transparency logs and this would break the security model around the ca system.</div><br/></div></div><div id="37542516" class="c"><input type="checkbox" id="c-37542516" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#37538495">root</a><span>|</span><a href="#37542171">parent</a><span>|</span><a href="#37542916">prev</a><span>|</span><a href="#37539267">next</a><span>|</span><label class="collapse" for="c-37542516">[-]</label><label class="expand" for="c-37542516">[1 more]</label></div><br/><div class="children"><div class="content">I don’t necessarily disagree, but to point out: issuing an intermediate CA does change the authority model a bit, insofar as it turns a single trusted issuance into a windowed lease to perform arbitrary issuances.<p>On a practical level, the latter is more logistically complex (and needs to be reconciled with other hard-fought battles, like CT). Given that it’s roughly the same as a wildcard certificate in terms of end-user use, it’s IMO understandable that this isn’t a priority for the CA ecosystem to support.<p>(The use case of circumventing CT is probably a non-starter as well. The Web PKI doesn’t want CT loopholes!)</div><br/></div></div></div></div><div id="37539267" class="c"><input type="checkbox" id="c-37539267" checked=""/><div class="controls bullet"><span class="by">gclawes</span><span>|</span><a href="#37538495">parent</a><span>|</span><a href="#37542171">prev</a><span>|</span><a href="#37538519">next</a><span>|</span><label class="collapse" for="c-37539267">[-]</label><label class="expand" for="c-37539267">[2 more]</label></div><br/><div class="children"><div class="content">And they support ACME.  I&#x27;ve been running a smallstep CA off of a Nitrokey HSM 2[1] w&#x2F; PKCS #11 for my homelab for a few years now<p>1. <a href="https:&#x2F;&#x2F;shop.nitrokey.com&#x2F;shop&#x2F;product&#x2F;nkhs2-nitrokey-hsm-2-7" rel="nofollow noreferrer">https:&#x2F;&#x2F;shop.nitrokey.com&#x2F;shop&#x2F;product&#x2F;nkhs2-nitrokey-hsm-2-...</a></div><br/><div id="37542747" class="c"><input type="checkbox" id="c-37542747" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#37538495">root</a><span>|</span><a href="#37539267">parent</a><span>|</span><a href="#37538519">next</a><span>|</span><label class="collapse" for="c-37542747">[-]</label><label class="expand" for="c-37542747">[1 more]</label></div><br/><div class="children"><div class="content">Nice to see open source hardware token usage in the wild.</div><br/></div></div></div></div><div id="37538519" class="c"><input type="checkbox" id="c-37538519" checked=""/><div class="controls bullet"><span class="by">wejn</span><span>|</span><a href="#37538495">parent</a><span>|</span><a href="#37539267">prev</a><span>|</span><a href="#37542312">next</a><span>|</span><label class="collapse" for="c-37538519">[-]</label><label class="expand" for="c-37538519">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s really neat, thanks for the pointer. ;)</div><br/></div></div></div></div><div id="37542312" class="c"><input type="checkbox" id="c-37542312" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#37538495">prev</a><span>|</span><a href="#37538084">next</a><span>|</span><label class="collapse" for="c-37542312">[-]</label><label class="expand" for="c-37542312">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m building an app whose GUI runs in the browser talking to a local http server.  The app (if and when it is ready) would be distributed as a standalone executable. A bit like Atom&#x2F;Electron I guess.<p>What I haven&#x27;t figured out yet is how the browser-GUI could talk to its local backend-server over https. Can an exe contain its own root-certificate-authority somehow in a way that the app-exe can work without having to update that certificate part ever?</div><br/><div id="37542439" class="c"><input type="checkbox" id="c-37542439" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#37542312">parent</a><span>|</span><a href="#37538084">next</a><span>|</span><label class="collapse" for="c-37542439">[-]</label><label class="expand" for="c-37542439">[1 more]</label></div><br/><div class="children"><div class="content">Why? What&#x27;s the potential attack you&#x27;re preventing by encrypting communication of two local processes?<p>You&#x27;d have to install a shady custom CA system-wide on your users, for a green lock that&#x27;s 100% placebo. Just run firefox&#x2F;chrome in app mode and hide the URL bar.</div><br/></div></div></div></div><div id="37538084" class="c"><input type="checkbox" id="c-37538084" checked=""/><div class="controls bullet"><span class="by">NegativeK</span><span>|</span><a href="#37542312">prev</a><span>|</span><a href="#37539400">next</a><span>|</span><label class="collapse" for="c-37538084">[-]</label><label class="expand" for="c-37538084">[28 more]</label></div><br/><div class="children"><div class="content">I went with DNS based Let&#x27;s Encrypt for internal certificates, since I&#x27;m okay leaking my internal DNS names.<p>&gt; An obvious downside of this is having to guard a bunch of secrets and the need to rotate the host certificates yearly – because Apple says so.<p>The guarding secrets thing makes me too uncomfortable with managing my own CA. I&#x27;m sure it&#x27;d be fine, but since there are other equivalent and safer ways to do it.. Name constraints are a thing in the spec for restricting your CA to specific domains (which is amazing,) but browser&#x2F;etc support was crappy when I looked at it and maybe getting better? I don&#x27;t understand why name constraints aren&#x27;t implemented everywhere. Unless an enterprise environment is doing TLS inspection, name constraints are a way saner implementation.</div><br/><div id="37538266" class="c"><input type="checkbox" id="c-37538266" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#37538084">parent</a><span>|</span><a href="#37538378">next</a><span>|</span><label class="collapse" for="c-37538266">[-]</label><label class="expand" for="c-37538266">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t understand why name constraints aren&#x27;t implemented everywhere.<p>They have weird semantics, especially in scenarios with multiple prospective validation paths: path `EE -&gt; ICA&#x27; -&gt; ICA&#x27;&#x27; -&gt; TA` might result in different name constraints than `EE -&gt; ICA&#x27; -&gt; ICA&#x27;&#x27;&#x27; -&gt; TA`, resulting in hard-to-debug validation errors (or successes) depending on the user&#x27;s trust store state.<p>(I don&#x27;t believe that&#x27;s why Chrome doesn&#x27;t support them, however. Chrome&#x27;s stated reason[1] is that they don&#x27;t support them on user roots because RFC 5280 doesn&#x27;t require them to, which is IMO a correct reading of the spec.)<p>[1]: <a href="https:&#x2F;&#x2F;bugs.chromium.org&#x2F;p&#x2F;chromium&#x2F;issues&#x2F;detail?id=1072083" rel="nofollow noreferrer">https:&#x2F;&#x2F;bugs.chromium.org&#x2F;p&#x2F;chromium&#x2F;issues&#x2F;detail?id=107208...</a></div><br/></div></div><div id="37538378" class="c"><input type="checkbox" id="c-37538378" checked=""/><div class="controls bullet"><span class="by">mirchiseth</span><span>|</span><a href="#37538084">parent</a><span>|</span><a href="#37538266">prev</a><span>|</span><a href="#37538141">next</a><span>|</span><label class="collapse" for="c-37538378">[-]</label><label class="expand" for="c-37538378">[5 more]</label></div><br/><div class="children"><div class="content">I used to have my own local root CA as well but now trying the Let&#x27;s Encrypt with DNS-01. What is the easiest combination of software to try it? I have failed miserably trying Opnsense + ACME client plugin + Cloudflare DNS + HAProxy &#x2F; NGinx.  I would get 100% ssllabs certs but somehow the reverse proxy won&#x27;t forward to internal services. Next I am gonna go caddyserver for reverse proxy as it has SSL with LE inbuilt. Let&#x27;s see.</div><br/><div id="37540052" class="c"><input type="checkbox" id="c-37540052" checked=""/><div class="controls bullet"><span class="by">psd1</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538378">parent</a><span>|</span><a href="#37538417">next</a><span>|</span><label class="collapse" for="c-37540052">[-]</label><label class="expand" for="c-37540052">[1 more]</label></div><br/><div class="children"><div class="content">I found LE + CF DNS trouble-free.<p>Dockerfile:<p>```
FROM certbot&#x2F;certbot
RUN pip3 install certbot-dns-cloudflare cloudflare
```<p>docker-compose.yml:<p>```
    volumes:
      - ${CREDENTIALS_DIRECTORY:-.}&#x2F;cloudflare.ini:&#x2F;cloudflare.ini
      - ${STATE_DIRECTORY:-.&#x2F;certbot}&#x2F;:&#x2F;etc&#x2F;letsencrypt&#x2F;
      - ${LOGS_DIRECTORY:-&#x2F;var&#x2F;log&#x2F;certbot}&#x2F;:&#x2F;var&#x2F;log&#x2F;letsencrypt&#x2F;
    command: &quot; \
      certonly \
      --non-interactive \
      --agree-tos \
      --email postmaster@foo.bar \
      --preferred-challenges dns-01 \
      --dns-cloudflare \
      --dns-cloudflare-credentials &#x2F;cloudflare.ini \
      --dns-cloudflare-propagation-seconds 30 \
      -d foo.bar,*.foo.bar&quot;
```</div><br/></div></div><div id="37538417" class="c"><input type="checkbox" id="c-37538417" checked=""/><div class="controls bullet"><span class="by">wejn</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538378">parent</a><span>|</span><a href="#37540052">prev</a><span>|</span><a href="#37539192">next</a><span>|</span><label class="collapse" for="c-37538417">[-]</label><label class="expand" for="c-37538417">[1 more]</label></div><br/><div class="children"><div class="content">A friend of mine runs dns01 thusly: <a href="https:&#x2F;&#x2F;ipng.ch&#x2F;s&#x2F;articles&#x2F;2023&#x2F;03&#x2F;24&#x2F;lego-dns01.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;ipng.ch&#x2F;s&#x2F;articles&#x2F;2023&#x2F;03&#x2F;24&#x2F;lego-dns01.html</a></div><br/></div></div><div id="37539192" class="c"><input type="checkbox" id="c-37539192" checked=""/><div class="controls bullet"><span class="by">petronio</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538378">parent</a><span>|</span><a href="#37538417">prev</a><span>|</span><a href="#37538450">next</a><span>|</span><label class="collapse" for="c-37539192">[-]</label><label class="expand" for="c-37539192">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had a lot of success with <a href="https:&#x2F;&#x2F;github.com&#x2F;dehydrated-io&#x2F;dehydrated">https:&#x2F;&#x2F;github.com&#x2F;dehydrated-io&#x2F;dehydrated</a> . It exposes the different parts of the process (deploy challenge to DNS, deploy cert to filesystem, etc) as hooks, so it&#x27;s pretty easy to integrate with anything and however you want, if you don&#x27;t mind writing a bit of bash. There&#x27;s a few scripts out there that use Cloudflare that you can use as well.</div><br/></div></div><div id="37538450" class="c"><input type="checkbox" id="c-37538450" checked=""/><div class="controls bullet"><span class="by">taskforcegemini</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538378">parent</a><span>|</span><a href="#37539192">prev</a><span>|</span><a href="#37538141">next</a><span>|</span><label class="collapse" for="c-37538450">[-]</label><label class="expand" for="c-37538450">[1 more]</label></div><br/><div class="children"><div class="content">do you use https&#x2F;have a cert in your webserver as well, or just on the proxy?</div><br/></div></div></div></div><div id="37538141" class="c"><input type="checkbox" id="c-37538141" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#37538084">parent</a><span>|</span><a href="#37538378">prev</a><span>|</span><a href="#37538628">next</a><span>|</span><label class="collapse" for="c-37538141">[-]</label><label class="expand" for="c-37538141">[19 more]</label></div><br/><div class="children"><div class="content">The one thing you can’t do with Let’s Encrypt is generate a certificate with a CN of localhost which, since browsers are getting really picky about mixed HTTP&#x2F;HTTPS content, is a real issue with local development using certain web features.</div><br/><div id="37539217" class="c"><input type="checkbox" id="c-37539217" checked=""/><div class="controls bullet"><span class="by">sneak</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538141">parent</a><span>|</span><a href="#37538804">next</a><span>|</span><label class="collapse" for="c-37539217">[-]</label><label class="expand" for="c-37539217">[7 more]</label></div><br/><div class="children"><div class="content">Why not register a domain, get a cert for it, and point it at 127.0.0.1?  Then nothing can complain.</div><br/><div id="37540374" class="c"><input type="checkbox" id="c-37540374" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37539217">parent</a><span>|</span><a href="#37539599">next</a><span>|</span><label class="collapse" for="c-37540374">[-]</label><label class="expand" for="c-37540374">[1 more]</label></div><br/><div class="children"><div class="content">My router blocks it to protect against DNS rebind.</div><br/></div></div><div id="37539599" class="c"><input type="checkbox" id="c-37539599" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37539217">parent</a><span>|</span><a href="#37540374">prev</a><span>|</span><a href="#37538804">next</a><span>|</span><label class="collapse" for="c-37539599">[-]</label><label class="expand" for="c-37539599">[5 more]</label></div><br/><div class="children"><div class="content">The other advantage of running your own PKI is you can intercept and decrypt arbitrary traffic on the network.</div><br/><div id="37540354" class="c"><input type="checkbox" id="c-37540354" checked=""/><div class="controls bullet"><span class="by">sneak</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37539599">parent</a><span>|</span><a href="#37538804">next</a><span>|</span><label class="collapse" for="c-37540354">[-]</label><label class="expand" for="c-37540354">[4 more]</label></div><br/><div class="children"><div class="content">No. Knowledge of the CA private key does not allow for this.  In all cases you have the webserver&#x27;s private key, whether you issue the cert yourself or if someone else does.<p>If you have the web server&#x27;s private key, you can decrypt the traffic, but only if PFS ciphers are not used.<p>It is a common misconception that knowledge of CA keys allows you to decrypt traffic.  It does not.  It allows you to issue valid certificates.  It&#x27;s only used for signing.<p>It&#x27;s the webserver&#x27;s key that protects the traffic.  The webserver&#x27;s operator has that key regardless of who the CA is.  In the case of PFS cipher suites (eg EDH) an ephemeral key is used for confidentiality and the endpoint keys are just used for integrity and key authentication.  Even with the webserver key you aren&#x27;t decrypting those streams.<p>In no case does the CA private key help you decrypt traffic.</div><br/><div id="37540888" class="c"><input type="checkbox" id="c-37540888" checked=""/><div class="controls bullet"><span class="by">ivlad</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37540354">parent</a><span>|</span><a href="#37538804">next</a><span>|</span><label class="collapse" for="c-37540888">[-]</label><label class="expand" for="c-37540888">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Knowledge of the CA private key does not allow for this<p>Of course it does. You just generate certificates for every TLS handshake you see and MitM them.<p>And yes, it works for PFS too. There is no difference for MitM.<p>&gt; In the case of PFS cipher suites (eg EDH) an ephemeral key is used for confidentiality and the endpoint keys are just used for integrity and key authentication. Even with the webserver key you aren&#x27;t decrypting those streams.<p>You never encrypt data with a key from certificate, even without PFS. That would be too slow. You generate a pre-master key and then use it to generate keys for symmetric algorithms, like AES or Chacha20, that are actually used for data stream encryption. The only difference between PFS and non-PFS is that in the former case pre-master is generated using some form of DH, with promise of keys being destroyed after some time, and in the later case, client just generates a random key, encrypts it with the public key and sends it to the server.</div><br/><div id="37541296" class="c"><input type="checkbox" id="c-37541296" checked=""/><div class="controls bullet"><span class="by">sneak</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37540888">parent</a><span>|</span><a href="#37538804">next</a><span>|</span><label class="collapse" for="c-37541296">[-]</label><label class="expand" for="c-37541296">[2 more]</label></div><br/><div class="children"><div class="content">MitM is not &quot;intercept and decrypt arbitrary traffic on the network&quot; which is what was asserted.  You are describing an active attack, while fiddlerwoaroof was discussing a passive one.</div><br/><div id="37541577" class="c"><input type="checkbox" id="c-37541577" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37541296">parent</a><span>|</span><a href="#37538804">next</a><span>|</span><label class="collapse" for="c-37541577">[-]</label><label class="expand" for="c-37541577">[1 more]</label></div><br/><div class="children"><div class="content">I wasn’t distinguishing the two sorts of attacks.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37538804" class="c"><input type="checkbox" id="c-37538804" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538141">parent</a><span>|</span><a href="#37539217">prev</a><span>|</span><a href="#37538380">next</a><span>|</span><label class="collapse" for="c-37538804">[-]</label><label class="expand" for="c-37538804">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>is a real issue with local development using certain web features.</i><p>Is it? I thought browsers treat localhost&#x2F;127.0.0.* specifically as if it were served over https, even if it isn&#x27;t - otherwise, you could basically forget developing anything locally.<p>Is there any feature which doesn&#x27;t treat localhost as a secure origin?<p>I figure you can always buy a hostname, get a cert using the DNS-01 challenge, then resolve the domain to 127.0.0.1 though - or getting back to the OP and running a custom CA.</div><br/><div id="37538834" class="c"><input type="checkbox" id="c-37538834" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538804">parent</a><span>|</span><a href="#37538380">next</a><span>|</span><label class="collapse" for="c-37538834">[-]</label><label class="expand" for="c-37538834">[2 more]</label></div><br/><div class="children"><div class="content">I have a dashboard I run via nginx on localhost that makes a bunch of requests to various https endpoints. It definitely doesn’t just work unless you have a trusted SSL certificate and run localhost as HTTPS</div><br/><div id="37538921" class="c"><input type="checkbox" id="c-37538921" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538834">parent</a><span>|</span><a href="#37538380">next</a><span>|</span><label class="collapse" for="c-37538921">[-]</label><label class="expand" for="c-37538921">[1 more]</label></div><br/><div class="children"><div class="content">Huh, that&#x27;s odd. Gonna test this as well then.</div><br/></div></div></div></div></div></div><div id="37538380" class="c"><input type="checkbox" id="c-37538380" checked=""/><div class="controls bullet"><span class="by">moondev</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538141">parent</a><span>|</span><a href="#37538804">prev</a><span>|</span><a href="#37538254">next</a><span>|</span><label class="collapse" for="c-37538380">[-]</label><label class="expand" for="c-37538380">[2 more]</label></div><br/><div class="children"><div class="content">You also can&#x27;t generate a cert for a double wildcard, like mydomain . com . * . * Or an entire domain, although I&#x27;m unsure if that is possible with your own CA as well</div><br/><div id="37539379" class="c"><input type="checkbox" id="c-37539379" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538380">parent</a><span>|</span><a href="#37538254">next</a><span>|</span><label class="collapse" for="c-37539379">[-]</label><label class="expand" for="c-37539379">[1 more]</label></div><br/><div class="children"><div class="content">You can generate the certificate but browsers don&#x27;t like multiple wildcards. Any application following the rules set out by RFC 6125 should reject multiple wildcards as far as I can tell.<p>Some browsers (notably Firefox) used to support multiple wildcards, but then again it also trusted domain certificates signed by other domain certificates for years, so that&#x27;s not much to go by. These days, I don&#x27;t think a single browser will accept <i>.</i>.foo.bar.</div><br/></div></div></div></div><div id="37538254" class="c"><input type="checkbox" id="c-37538254" checked=""/><div class="controls bullet"><span class="by">punkybr3wster</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538141">parent</a><span>|</span><a href="#37538380">prev</a><span>|</span><a href="#37538628">next</a><span>|</span><label class="collapse" for="c-37538254">[-]</label><label class="expand" for="c-37538254">[6 more]</label></div><br/><div class="children"><div class="content">I’ve also struggled with this. Is there an elegant solution that you’re aware of? Everything I’ve tried feels really rickety.</div><br/><div id="37538516" class="c"><input type="checkbox" id="c-37538516" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538254">parent</a><span>|</span><a href="#37538311">next</a><span>|</span><label class="collapse" for="c-37538516">[-]</label><label class="expand" for="c-37538516">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using cfssl[1] to generate a root certificate + a localhost certificate and then trusting the root.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;cfssl">https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;cfssl</a></div><br/></div></div><div id="37538311" class="c"><input type="checkbox" id="c-37538311" checked=""/><div class="controls bullet"><span class="by">ceejayoz</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538254">parent</a><span>|</span><a href="#37538516">prev</a><span>|</span><a href="#37538628">next</a><span>|</span><label class="collapse" for="c-37538311">[-]</label><label class="expand" for="c-37538311">[4 more]</label></div><br/><div class="children"><div class="content">For localhost, there’s not much downside to a self-signed cert.</div><br/><div id="37538458" class="c"><input type="checkbox" id="c-37538458" checked=""/><div class="controls bullet"><span class="by">unethical_ban</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538311">parent</a><span>|</span><a href="#37538628">next</a><span>|</span><label class="collapse" for="c-37538458">[-]</label><label class="expand" for="c-37538458">[3 more]</label></div><br/><div class="children"><div class="content">Browsers won&#x27;t offer to save passwords on self signed sites.</div><br/><div id="37538615" class="c"><input type="checkbox" id="c-37538615" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538458">parent</a><span>|</span><a href="#37538628">next</a><span>|</span><label class="collapse" for="c-37538615">[-]</label><label class="expand" for="c-37538615">[2 more]</label></div><br/><div class="children"><div class="content">You might be able to get around this using the Chrome &quot;flags&quot; page, search for unsafely-treat-insecure-origin-as-secure.</div><br/><div id="37538744" class="c"><input type="checkbox" id="c-37538744" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#37538084">root</a><span>|</span><a href="#37538615">parent</a><span>|</span><a href="#37538628">next</a><span>|</span><label class="collapse" for="c-37538744">[-]</label><label class="expand" for="c-37538744">[1 more]</label></div><br/><div class="children"><div class="content">Chrome flags are pretty annoying to use, especially if you use the same browser for regular browsing.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37538628" class="c"><input type="checkbox" id="c-37538628" checked=""/><div class="controls bullet"><span class="by">soraminazuki</span><span>|</span><a href="#37538084">parent</a><span>|</span><a href="#37538141">prev</a><span>|</span><a href="#37538113">next</a><span>|</span><label class="collapse" for="c-37538628">[-]</label><label class="expand" for="c-37538628">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Name constraints are a thing in the spec for restricting your CA to specific domains (which is amazing,) but browser&#x2F;etc support was crappy<p>It&#x27;s well supported now. I use it and it works for OpenSSL, Firefox, and Safari.<p>Personally, I don&#x27;t think there&#x27;s much to gain from using public PKI for internal infrastructure. I already manage secrets on my personal devices and this is no different. Also, being able to issue certs for .home.arpa domains is nice too.</div><br/></div></div><div id="37538113" class="c"><input type="checkbox" id="c-37538113" checked=""/><div class="controls bullet"><span class="by">aberoham</span><span>|</span><a href="#37538084">parent</a><span>|</span><a href="#37538628">prev</a><span>|</span><a href="#37539400">next</a><span>|</span><label class="collapse" for="c-37538113">[-]</label><label class="expand" for="c-37538113">[1 more]</label></div><br/><div class="children"><div class="content">Did you use elliptic curve instead of RSA?</div><br/></div></div></div></div><div id="37539400" class="c"><input type="checkbox" id="c-37539400" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37538084">prev</a><span>|</span><a href="#37538577">next</a><span>|</span><label class="collapse" for="c-37539400">[-]</label><label class="expand" for="c-37539400">[20 more]</label></div><br/><div class="children"><div class="content">“Cultural” technical issues are so frustrating to me. A certificate is fundamentally just a type of credential, like a password, but for historical reasons they’re treated like getting citizenship papers. There’s always this <i>ceremony</i> even in scenarios where it makes zero sense — such as internal-use certificates used for a gRPC API server behind a load balancer.<p>Why - for the love of God why - can’t I just obtain a cert like this <i>directly</i> out of a secret store such as an Azure Key Vault!?<p>These things are already full hardware security modules (HSMs) with all of the capabilities required to run just about anything short of a public Root CA and maybe even that too.<p>But no.<p>NO!<p>Script it yourself. Make a root cert, “upload” it, make a cert, sign it, upload it, link it, renew it, re-configure it, and on and on. Oh… you wanted a CRL too? A 1kb file? Ha-ha! No. Make it and host it yourself!!<p>It’s absurd.<p>So many services depend on a simple CA-&gt;cert setup: VPNs, API auth, load balancer back-ends, clusters, etc…<p>But my mark my words: no cloud will have a trivial turnkey solution this decade.<p>This is because running a CA is <i>culturally accepted to be a hard problem</i>. It is! If you’re DigiCert. It isn’t if you’re building a three-server internal use cluster. But the problem is <i>hard</i>, you see? That accepted fact! Everyone knows it! <i>Ceremony is required</i>. We can’t just <i>hand</i>  your sever a 1kb credential file! That would be… unconventional!<p>It’s just not the way things are done, so stop asking.</div><br/><div id="37540145" class="c"><input type="checkbox" id="c-37540145" checked=""/><div class="controls bullet"><span class="by">gorkish</span><span>|</span><a href="#37539400">parent</a><span>|</span><a href="#37539648">next</a><span>|</span><label class="collapse" for="c-37540145">[-]</label><label class="expand" for="c-37540145">[8 more]</label></div><br/><div class="children"><div class="content">It’s about damn time that we should be able to get intermediate signing certs that are domain limited from a public ca and issue out own “real” certs. This is fully supported in the standards. Anyone offering this product affordably yet?</div><br/><div id="37540509" class="c"><input type="checkbox" id="c-37540509" checked=""/><div class="controls bullet"><span class="by">Dragging-Syrup</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540145">parent</a><span>|</span><a href="#37540608">next</a><span>|</span><label class="collapse" for="c-37540509">[-]</label><label class="expand" for="c-37540509">[2 more]</label></div><br/><div class="children"><div class="content">The other “half” of the issue is getting the os, browsers, and devices to support the standard as well. That’s a whole other can of worms.</div><br/><div id="37540566" class="c"><input type="checkbox" id="c-37540566" checked=""/><div class="controls bullet"><span class="by">3np</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540509">parent</a><span>|</span><a href="#37540608">next</a><span>|</span><label class="collapse" for="c-37540566">[-]</label><label class="expand" for="c-37540566">[1 more]</label></div><br/><div class="children"><div class="content">Like gorkish wrote: No new standards or standard changes affecting any of those necessary. It&#x27;s only a matter of will and culture on part of CAs.</div><br/></div></div></div></div><div id="37540608" class="c"><input type="checkbox" id="c-37540608" checked=""/><div class="controls bullet"><span class="by">c2h5oh</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540145">parent</a><span>|</span><a href="#37540509">prev</a><span>|</span><a href="#37540278">next</a><span>|</span><label class="collapse" for="c-37540608">[-]</label><label class="expand" for="c-37540608">[1 more]</label></div><br/><div class="children"><div class="content">Domain limiting is implemented using x.509 cert nameConstraints, which the last time I&#x27;ve checked were not supported on Apple devices..<p>Edit: has been fixed in osx 10.13.3. Idk about iOS.</div><br/></div></div><div id="37540278" class="c"><input type="checkbox" id="c-37540278" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540145">parent</a><span>|</span><a href="#37540608">prev</a><span>|</span><a href="#37539648">next</a><span>|</span><label class="collapse" for="c-37540278">[-]</label><label class="expand" for="c-37540278">[4 more]</label></div><br/><div class="children"><div class="content">Interesting idea. What use cases would this make easier or even possible? At first, it sounds like more work (you’re now your own CA <i>but</i> without full freedom of a truly self hosted one).</div><br/><div id="37540376" class="c"><input type="checkbox" id="c-37540376" checked=""/><div class="controls bullet"><span class="by">Nextgrid</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540278">parent</a><span>|</span><a href="#37539648">next</a><span>|</span><label class="collapse" for="c-37540376">[-]</label><label class="expand" for="c-37540376">[3 more]</label></div><br/><div class="children"><div class="content">The main advantage is that this CA and all downstream certificates would be globally-trusted (limited to the domain), which is not the case for a custom CA.<p>Security-wise it shouldn&#x27;t be any worse than wildcard certificates which are already a thing. It would actually <i>improve</i> things, because the user can now issue downstream certificates much more granularly without having to interact with the root CA (so you can issue fully offline for an intranet, or issue extremely-short-lived certificates that would otherwise run afoul of root CA&#x27;s rate-limits).</div><br/><div id="37540504" class="c"><input type="checkbox" id="c-37540504" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540376">parent</a><span>|</span><a href="#37539648">next</a><span>|</span><label class="collapse" for="c-37540504">[-]</label><label class="expand" for="c-37540504">[2 more]</label></div><br/><div class="children"><div class="content">It would improve things for everybody but the certificate authorities.<p>They&#x27;re selling something with a marginal cost of zero for $50 each. A wildcard certificate costs more not because it is materially different or &quot;harder&quot; to issue, but because it replaces many $50 certificates. Thus, it &quot;must&quot; cost more, or everybody would just use wildcard certificates everywhere and <i>reduce profits</i> at the large public CAs.<p>It is actually possible to get a domain-specific CA like the one you&#x27;re thinking of. I saw one at a large department of education. It allowed unlimited issuance of certificates such as HTTPS, mail-signing, document-signing, and some other types that could be locked to a DNS domain. However, there was still a cost per certificate and the up-front cost was huge, something like $100K.</div><br/><div id="37540663" class="c"><input type="checkbox" id="c-37540663" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540504">parent</a><span>|</span><a href="#37539648">next</a><span>|</span><label class="collapse" for="c-37540663">[-]</label><label class="expand" for="c-37540663">[1 more]</label></div><br/><div class="children"><div class="content">Hopefully let’s encrypt continues to put the pressure on them so eventually the other cert authorities start offering things worth paying for.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37539648" class="c"><input type="checkbox" id="c-37539648" checked=""/><div class="controls bullet"><span class="by">stanleydrew</span><span>|</span><a href="#37539400">parent</a><span>|</span><a href="#37540145">prev</a><span>|</span><a href="#37540325">next</a><span>|</span><label class="collapse" for="c-37539648">[-]</label><label class="expand" for="c-37539648">[3 more]</label></div><br/><div class="children"><div class="content">This is a decent rant, and I mostly share your frustration.<p>But At least GCP and AWS have certificate authority products which essentially do work the way you want them to:<p><a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;certificate-authority-service" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;certificate-authority-service</a>
<a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;private-ca&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aws.amazon.com&#x2F;private-ca&#x2F;</a><p>Azure may well have one too, I just don&#x27;t use their service.</div><br/><div id="37539956" class="c"><input type="checkbox" id="c-37539956" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37539648">parent</a><span>|</span><a href="#37539671">next</a><span>|</span><label class="collapse" for="c-37539956">[-]</label><label class="expand" for="c-37539956">[1 more]</label></div><br/><div class="children"><div class="content">You just answered a rant about <i>too much ceremony</i> by linking to an entire service that costs a staggering USD 400 &#x2F; month. That’s the cost of an FTE in like half the world… to issue what are essentially “fat passwords”.<p>Imagine with a straight face trying to sell someone a “password generator service” when in reality that’s just a <i>one line script snippet</i>.<p>The disconnect between the physical reality on the ground and how it is treated by industry is just absurd.<p>Ref: <a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;private-ca&#x2F;pricing&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aws.amazon.com&#x2F;private-ca&#x2F;pricing&#x2F;</a><p>Getting a signed cert issued should be a one-liner script referencing an AWS KMS or an Azure KeyVault!</div><br/></div></div><div id="37539671" class="c"><input type="checkbox" id="c-37539671" checked=""/><div class="controls bullet"><span class="by">firesteelrain</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37539648">parent</a><span>|</span><a href="#37539956">prev</a><span>|</span><a href="#37540325">next</a><span>|</span><label class="collapse" for="c-37539671">[-]</label><label class="expand" for="c-37539671">[1 more]</label></div><br/><div class="children"><div class="content">Azure will let you tap into a HSM too</div><br/></div></div></div></div><div id="37540325" class="c"><input type="checkbox" id="c-37540325" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#37539400">parent</a><span>|</span><a href="#37539648">prev</a><span>|</span><a href="#37541396">next</a><span>|</span><label class="collapse" for="c-37540325">[-]</label><label class="expand" for="c-37540325">[7 more]</label></div><br/><div class="children"><div class="content">A password is a secret. A certificate is fully public (it’s useless if not). I don’t see how they’re similar in that dimension. Or how certificates are possible without a third party (a core reason for all the ceremony). Passwords get away with not needing a third party involved because they’re a prearranged process. Certificates aren’t, I need to be able to hit any website at any point, for the first time.</div><br/><div id="37540403" class="c"><input type="checkbox" id="c-37540403" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540325">parent</a><span>|</span><a href="#37540561">next</a><span>|</span><label class="collapse" for="c-37540403">[-]</label><label class="expand" for="c-37540403">[5 more]</label></div><br/><div class="children"><div class="content">The key phrase here is <i>internal use</i>. Think authentication between two micro services, not HTTPS for someblog.com.<p>The third party in this case is <i>just</i> a file: the internal CA key.<p>Try to think of this in the following terms: the issued certs are just <i>signed tokens</i>,  nothing more. They’re also conveniently a public-private key pair, but that’s not the point.<p>The point is that if you used a 1kb random password for service to service auth and someone tried to sell you a $400&#x2F;mo service to generate them, you’d laugh in their face and then have security escort them from the building.<p>Sprinkle a tiny bit of cryptography on top and suddenly people think $4,800 annually is a bargain for 1kb passwords.<p>I can buy a decent used car for that kind of money.</div><br/><div id="37542862" class="c"><input type="checkbox" id="c-37542862" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540403">parent</a><span>|</span><a href="#37540452">next</a><span>|</span><label class="collapse" for="c-37542862">[-]</label><label class="expand" for="c-37542862">[1 more]</label></div><br/><div class="children"><div class="content">There are ways to use internal CA certificates to authenticate microservices, though they&#x27;re mostly based on Kubernetes. Take Istio&#x27;s solution, for example: <a href="https:&#x2F;&#x2F;istio.io&#x2F;latest&#x2F;docs&#x2F;tasks&#x2F;security&#x2F;authentication&#x2F;mtls-migration&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;istio.io&#x2F;latest&#x2F;docs&#x2F;tasks&#x2F;security&#x2F;authentication&#x2F;m...</a><p>Very few people still use TLS client authentication, but it does work. You can definitely get it up and running for less than 400 dollars per month. The magical keyword for Google here is &quot;mutual TLS&quot;<p>If you&#x27;re using a Windows based system, you can do this stuff automatically through Active Directory: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;security&#x2F;operating-system-security&#x2F;network-security&#x2F;windows-firewall&#x2F;configure-group-policy-to-autoenroll-and-deploy-certificates" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;security&#x2F;operating...</a><p>The thing is, credential management is very difficult, and people are willing to pay up to solve very difficult tasks. If you build a (non-Kubernetes} certificate management solution, you&#x27;ll probably want to sell it for big bucks as well. Generating certificates is just an openssl command line on a timer, the difficulty is getting those certificates deployed in the right places automatically. It&#x27;s all possible through some basic scripting, but to do it right you need to solve more than just the certificate part.</div><br/></div></div><div id="37540452" class="c"><input type="checkbox" id="c-37540452" checked=""/><div class="controls bullet"><span class="by">matthewaveryusa</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540403">parent</a><span>|</span><a href="#37542862">prev</a><span>|</span><a href="#37541345">next</a><span>|</span><label class="collapse" for="c-37540452">[-]</label><label class="expand" for="c-37540452">[2 more]</label></div><br/><div class="children"><div class="content">PKI can provide non-repudiation while signed tokens and API keys cannot. There&#x27;s a big difference transmitting a bearer token vs establishing a TLS connection.</div><br/><div id="37540557" class="c"><input type="checkbox" id="c-37540557" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540452">parent</a><span>|</span><a href="#37541345">next</a><span>|</span><label class="collapse" for="c-37540557">[-]</label><label class="expand" for="c-37540557">[1 more]</label></div><br/><div class="children"><div class="content">I get that you don&#x27;t get it... that&#x27;s my point.<p>A public-private key pair is clever cryptography, yes, but <i>INTERNALLY</i> within a network they&#x27;re not Magic(tm) that requires a multi-billion dollar market cap company to issue with some Indian call centre verifying my identity papers.<p>The same cryptographic <i>algorithm</i> has two wildly different uses: one that is $0.0000001 in value, and one that requires a third party organisation that needs to pay their employees and can maybe justify asking for tens of dollars. (Narrator: Let&#x27;s Encrypt showed that they can&#x27;t justify this either.)<p>People conflate the two and then try to charge $50 for the $0.0000001 use-case, which is a markup of <i>five million percent</i>. That&#x27;s what&#x27;s upsetting. It&#x27;s just so absurd, and people blink slowly and then start suggesting $40 options <i>as-if</i> that discount somehow makes it okay. Or they start talking about &quot;all the things you get&quot; for that $50, when it just doesn&#x27;t apply.<p>There should be a trivial set of commands along the lines of:<p><pre><code>    New-AzKeyVaultRootCertificate -VaultName &#x27;xyzinternal&#x27; -Name &#x27;ContosoAPIServiceRoot&#x27;

    New-AzKeyVaultSignedCertificate -VaultName &#x27;xyzinternal&#x27; -RootCertificateName &#x27;ContosoAPIServiceRoot&#x27; -DnsName &#x27;apisvc1352.internal.cloud&#x27;
</code></pre>
You can emulate the above with a 20-line script now, but it&#x27;s fiddly, and doesn&#x27;t cooperate with Bicep deployment templates. Similarly, there ought to be a built-in renewal mechanism (which is JUST &#x27;cron&#x27; for the love of God!), but instead requires Azure Functions, layers of complex authorisations, and who knows what else...</div><br/></div></div></div></div><div id="37541345" class="c"><input type="checkbox" id="c-37541345" checked=""/><div class="controls bullet"><span class="by">mdekkers</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540403">parent</a><span>|</span><a href="#37540452">prev</a><span>|</span><a href="#37540561">next</a><span>|</span><label class="collapse" for="c-37541345">[-]</label><label class="expand" for="c-37541345">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The point is that if you used a 1kb random password for service to service auth and someone tried to sell you a $400&#x2F;mo service to generate them, you’d laugh in their face and then have security escort them from the building.<p>Go ahead, run an internal secret store that issues properly trustworthy internal certificates. It isn’t hard, but neither is it cheap not. You oversimplify and gloss over a few _really_ important aspects of why and how certificates work. A certificate _acting like a password_ in some cases doesn’t mean it actually _is_ a password, and if you don’t really need the additional functionality to the point where the cost outweighs the delivered value, you are using the wrong tool for the job.<p>Running a CA is not at a technical challenge. Running a _trustworthy_ (there is that word again) CA is process heavy and it involves quite a few people doing work on a regular basis, and without those processes you may as well just something else - like an untrusted CA, or some kind of token issuing service (which, shockingly, also costs money to run properly).<p>A few really good options around DIY CAs were mentioned in this discussion, smallstep is pretty good for example. Nothing (except possibly your $org’s security policies) prevents you from throwing that up somewhere and start vending certs.<p>The fact that it is an internal CA to be used for internal purposes makes no difference, unless you believe that “everything internal is trusted because it is internal” in which case many other discussions on a very wide variety of subjects is due.</div><br/></div></div></div></div><div id="37540561" class="c"><input type="checkbox" id="c-37540561" checked=""/><div class="controls bullet"><span class="by">gregmac</span><span>|</span><a href="#37539400">root</a><span>|</span><a href="#37540325">parent</a><span>|</span><a href="#37540403">prev</a><span>|</span><a href="#37541396">next</a><span>|</span><label class="collapse" for="c-37540561">[-]</label><label class="expand" for="c-37540561">[1 more]</label></div><br/><div class="children"><div class="content">A certificate is a key pair with both a public and private part. The private key is needed to sign data, while the public key can only validate that signature.<p>You can think of the private key as equivalent to a password, in the context the parent is talking about.</div><br/></div></div></div></div><div id="37541396" class="c"><input type="checkbox" id="c-37541396" checked=""/><div class="controls bullet"><span class="by">mdekkers</span><span>|</span><a href="#37539400">parent</a><span>|</span><a href="#37540325">prev</a><span>|</span><a href="#37538577">next</a><span>|</span><label class="collapse" for="c-37541396">[-]</label><label class="expand" for="c-37541396">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ceremony is required.<p>Ceremony, as in “a well established, rigorously implemented, meticulously documented, and diligently audited process” is required to establish and maintain trust. A CA promises that folks showing up bearing their certificate _are who they say they are_ - this doesn’t mean it is perfect (there are plenty of cases where public CAs went wrong) and some random person can place their trust in that assertion.<p>The whole _point_ of a PKI is trust, and why would this be any different for internal systems?</div><br/></div></div></div></div><div id="37538577" class="c"><input type="checkbox" id="c-37538577" checked=""/><div class="controls bullet"><span class="by">obnauticus</span><span>|</span><a href="#37539400">prev</a><span>|</span><a href="#37538434">next</a><span>|</span><label class="collapse" for="c-37538577">[-]</label><label class="expand" for="c-37538577">[4 more]</label></div><br/><div class="children"><div class="content">I eventually need to publish an article about how to run an HSM backed root CA on the cheap with m of n auth.<p>Using nitrokey and some glue scripts you can get the cost below $500. If anyone is interested, let me know.</div><br/><div id="37539018" class="c"><input type="checkbox" id="c-37539018" checked=""/><div class="controls bullet"><span class="by">dmayle</span><span>|</span><a href="#37538577">parent</a><span>|</span><a href="#37538785">next</a><span>|</span><label class="collapse" for="c-37539018">[-]</label><label class="expand" for="c-37539018">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve just started down that route.  I&#x27;ve got the nitro key hsm2 in the mail, have heard the advice on using two levels (first root in the Key, and intermediary on the Device for easier revoking).  I mainly want to issue client certificates so that I can expose internal sites on the public Internet via proxy without having to require a VPN for all of my users, though I&#x27;m also interested in certificate based SSH</div><br/></div></div><div id="37538785" class="c"><input type="checkbox" id="c-37538785" checked=""/><div class="controls bullet"><span class="by">n0n</span><span>|</span><a href="#37538577">parent</a><span>|</span><a href="#37539018">prev</a><span>|</span><a href="#37539525">next</a><span>|</span><label class="collapse" for="c-37538785">[-]</label><label class="expand" for="c-37538785">[1 more]</label></div><br/><div class="children"><div class="content">Yes, please! I would be interested. Currently i&#x27;m fiddling around with vault as an ICA, so this sounds like a good next step</div><br/></div></div><div id="37539525" class="c"><input type="checkbox" id="c-37539525" checked=""/><div class="controls bullet"><span class="by">processunknown</span><span>|</span><a href="#37538577">parent</a><span>|</span><a href="#37538785">prev</a><span>|</span><a href="#37538434">next</a><span>|</span><label class="collapse" for="c-37539525">[-]</label><label class="expand" for="c-37539525">[1 more]</label></div><br/><div class="children"><div class="content">Please do</div><br/></div></div></div></div><div id="37538434" class="c"><input type="checkbox" id="c-37538434" checked=""/><div class="controls bullet"><span class="by">c0l0</span><span>|</span><a href="#37538577">prev</a><span>|</span><a href="#37539172">next</a><span>|</span><label class="collapse" for="c-37538434">[-]</label><label class="expand" for="c-37538434">[1 more]</label></div><br/><div class="children"><div class="content">Actually running a CA, even if only for private purposes, without certain regret down the road involves more than creating an OpenSSL cnf file, creating a root cert&#x2F;key, and running with it. That said, it&#x27;s a starting point. If you&#x27;re looking to use more modern (i.e., faster) crypto than RSA keys, maybe check out my sping on a CSR generator wrapping `openssl`, available at <a href="https:&#x2F;&#x2F;johannes.truschnigg.info&#x2F;code&#x2F;tls_req_gen" rel="nofollow noreferrer">https:&#x2F;&#x2F;johannes.truschnigg.info&#x2F;code&#x2F;tls_req_gen</a><p>If you need a self-signed cert instead, maybe try <a href="https:&#x2F;&#x2F;johannes.truschnigg.info&#x2F;code&#x2F;tls_cert_gen" rel="nofollow noreferrer">https:&#x2F;&#x2F;johannes.truschnigg.info&#x2F;code&#x2F;tls_cert_gen</a></div><br/></div></div><div id="37539172" class="c"><input type="checkbox" id="c-37539172" checked=""/><div class="controls bullet"><span class="by">andrewstuart2</span><span>|</span><a href="#37538434">prev</a><span>|</span><a href="#37542042">next</a><span>|</span><label class="collapse" for="c-37539172">[-]</label><label class="expand" for="c-37539172">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done similar for something like 8 years with vault as my intermediate issuer, almost exclusively using cert-manager once that was mature enough, and my own little utility before that. It&#x27;s so nice getting certs for side projects or self hosting in an instant and with an encrypted (pgp) offline (flash drive in a safe) CA I&#x27;m never really worried about having to reroll. Installing the CA is pretty trivial on most devices and means I don&#x27;t have to worry about CTLs or rate limits, which is especially helpful when I&#x27;m hacking on a saas side project that ends up requesting 10+ certificates every test run.</div><br/></div></div><div id="37542042" class="c"><input type="checkbox" id="c-37542042" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#37539172">prev</a><span>|</span><a href="#37538529">next</a><span>|</span><label class="collapse" for="c-37542042">[-]</label><label class="expand" for="c-37542042">[3 more]</label></div><br/><div class="children"><div class="content">Trivia question: What is the limit, if any, for how many DNS names (SANs) one can include in a single self-signed certificate.  It is common to see TLS proxies that will generate certificates on the fly as SNI in clientHell is received.  Is this due to a limit on how many SANs one can include in a single certificate.<p>(Maybe the performance degradation of generating a certificate on the fly is less than using a certificate that includes 100s of SANs.)</div><br/><div id="37542396" class="c"><input type="checkbox" id="c-37542396" checked=""/><div class="controls bullet"><span class="by">entuno</span><span>|</span><a href="#37542042">parent</a><span>|</span><a href="#37542140">next</a><span>|</span><label class="collapse" for="c-37542396">[-]</label><label class="expand" for="c-37542396">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure sure about a hard limit in the x509 standard (would need to dig into the RFCs) - but the BadSSL site has two test domains that have certificates with 1,000 and 10,000 SANs respectively:<p><a href="https:&#x2F;&#x2F;1000-sans.badssl.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;1000-sans.badssl.com</a><p><a href="https:&#x2F;&#x2F;10000-sans.badssl.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;10000-sans.badssl.com</a><p>1,000 works in Firefox and Chromium, but 10,000 gives `SSL_ERROR_RX_MALFORMED_HANDSHAKE` in Firefox, and `ERR_SSL_PROTOCOL_ERROR` in Chromium. OpenSSL won&#x27;t connect to it either - it gives `read_state_machine:excessive message size:ssl&#x2F;statem&#x2F;statem.c:610`<p>So in practical terms, the answer seems to be somewhere between the 1,000 and 10,000.</div><br/></div></div><div id="37542140" class="c"><input type="checkbox" id="c-37542140" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#37542042">parent</a><span>|</span><a href="#37542396">prev</a><span>|</span><a href="#37538529">next</a><span>|</span><label class="collapse" for="c-37542140">[-]</label><label class="expand" for="c-37542140">[1 more]</label></div><br/><div class="children"><div class="content">I think user-perceptible performance degradation might set a lower practical ceiling than purely technical limitations would. I&#x27;ve seen as many as ~200 SANs on a single cert -- but I&#x27;m not claiming any special expertise or insights.</div><br/></div></div></div></div><div id="37538529" class="c"><input type="checkbox" id="c-37538529" checked=""/><div class="controls bullet"><span class="by">JackGreyhat</span><span>|</span><a href="#37542042">prev</a><span>|</span><a href="#37538429">next</a><span>|</span><label class="collapse" for="c-37538529">[-]</label><label class="expand" for="c-37538529">[1 more]</label></div><br/><div class="children"><div class="content">Easy-rsa to the rescue. Been using it for a while, works great and makes life easier :)<p>Link: <a href="https:&#x2F;&#x2F;github.com&#x2F;OpenVPN&#x2F;easy-rsa">https:&#x2F;&#x2F;github.com&#x2F;OpenVPN&#x2F;easy-rsa</a><p>Summary from that page:<p>easy-rsa is a CLI utility to build and manage a PKI CA. In laymen&#x27;s terms, this means to create a root certificate authority, and request and sign certificates, including intermediate CAs and certificate revocation lists (CRL).</div><br/></div></div><div id="37538429" class="c"><input type="checkbox" id="c-37538429" checked=""/><div class="controls bullet"><span class="by">morpheuskafka</span><span>|</span><a href="#37538529">prev</a><span>|</span><a href="#37542123">next</a><span>|</span><label class="collapse" for="c-37538429">[-]</label><label class="expand" for="c-37538429">[3 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t the first Apple link specifically say the 398-day limit doesn&#x27;t apply to self-signed CAs?<p>&gt; This change will affect only TLS server certificates issued from the Root CAs preinstalled with iOS, iPadOS, macOS, watchOS, and tvOS.<p>&gt; This change will not affect certificates issued from user-added or administrator-added Root CAs.<p>The second link about the other restrictions (including &lt;=825 days validity) does appear to apply to all CAs.</div><br/><div id="37538447" class="c"><input type="checkbox" id="c-37538447" checked=""/><div class="controls bullet"><span class="by">wejn</span><span>|</span><a href="#37538429">parent</a><span>|</span><a href="#37538540">next</a><span>|</span><label class="collapse" for="c-37538447">[-]</label><label class="expand" for="c-37538447">[1 more]</label></div><br/><div class="children"><div class="content">And yet, my homegrown root CA cert with 3650 days of validity hums along just fine...<p>[edited: but since I also want to have host certs that are on various internal servers, the short validity applies to them]</div><br/></div></div><div id="37538540" class="c"><input type="checkbox" id="c-37538540" checked=""/><div class="controls bullet"><span class="by">pxeboot</span><span>|</span><a href="#37538429">parent</a><span>|</span><a href="#37538447">prev</a><span>|</span><a href="#37542123">next</a><span>|</span><label class="collapse" for="c-37538540">[-]</label><label class="expand" for="c-37538540">[1 more]</label></div><br/><div class="children"><div class="content">I am not sure if the same rules apply to 802.1x authentication, but we use self signed certs with 2 year validity for EAP-TLS and have never had any issues on iOS devices</div><br/></div></div></div></div><div id="37542123" class="c"><input type="checkbox" id="c-37542123" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#37538429">prev</a><span>|</span><a href="#37538510">next</a><span>|</span><label class="collapse" for="c-37542123">[-]</label><label class="expand" for="c-37542123">[2 more]</label></div><br/><div class="children"><div class="content">I tend to treat service TLS certificates more like shared keys than PKI. Too many pieces of software don&#x27;t handle revocation, it&#x27;s easier to regenerate the CA and the entire set of certificates when you change your setup.</div><br/><div id="37542809" class="c"><input type="checkbox" id="c-37542809" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#37542123">parent</a><span>|</span><a href="#37538510">next</a><span>|</span><label class="collapse" for="c-37542809">[-]</label><label class="expand" for="c-37542809">[1 more]</label></div><br/><div class="children"><div class="content">The better solution is to do what vault does. Use only ephemeral certificates for servers and clients. It wouldn&#x27;t be too hard to change them every week or so using the ACME protocol.</div><br/></div></div></div></div><div id="37538510" class="c"><input type="checkbox" id="c-37538510" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37542123">prev</a><span>|</span><a href="#37542145">next</a><span>|</span><label class="collapse" for="c-37538510">[-]</label><label class="expand" for="c-37538510">[5 more]</label></div><br/><div class="children"><div class="content">I run a squid proxy with TLS intercept on a raspberry pi, with my own CA.<p>I have things set up so that the RPi connects to a WiFi, and then a cable from the RPi goes to another WiFi router.<p>I connect my MacBook Pro to that other router.<p>This way the MacBook Pro cannot reach the internet.<p>Then I set the http and https proxy configs in Firefox so that it goes via the squid on the RPi. And I have the root CA from the RPi trusted in Firefox.<p>Additionally I have set some env variables and added my root CA cert to some cert storages on the computer, so that git can clone via squid, and I can install and update things with brew etc.<p>It works great :D<p>But then I tried to set up my iPhone to also connect to that WiFi. I think I managed to trust my root CA on the phone. But I couldn’t manage to set up the http&#x2F;https proxy on the iPhone and so for now only the MacBook Pro can use it, and not the iPhone</div><br/><div id="37538641" class="c"><input type="checkbox" id="c-37538641" checked=""/><div class="controls bullet"><span class="by">lini</span><span>|</span><a href="#37538510">parent</a><span>|</span><a href="#37538553">next</a><span>|</span><label class="collapse" for="c-37538641">[-]</label><label class="expand" for="c-37538641">[2 more]</label></div><br/><div class="children"><div class="content">macOS uses certificate pinning for some <i>.apple.com</i> and <i>.itunes.com</i> sites. If you pass all your traffic through the proxy, some stuff like the app store will not work. Do you bypass the proxy for those or just let them fail?</div><br/><div id="37538987" class="c"><input type="checkbox" id="c-37538987" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#37538510">root</a><span>|</span><a href="#37538641">parent</a><span>|</span><a href="#37538553">next</a><span>|</span><label class="collapse" for="c-37538987">[-]</label><label class="expand" for="c-37538987">[1 more]</label></div><br/><div class="children"><div class="content">I do that on purpose. I don’t want macOS itself to reach the internet. Only Firefox, brew, etc</div><br/></div></div></div></div><div id="37538553" class="c"><input type="checkbox" id="c-37538553" checked=""/><div class="controls bullet"><span class="by">alexeldeib</span><span>|</span><a href="#37538510">parent</a><span>|</span><a href="#37538641">prev</a><span>|</span><a href="#37538891">next</a><span>|</span><label class="collapse" for="c-37538553">[-]</label><label class="expand" for="c-37538553">[1 more]</label></div><br/><div class="children"><div class="content">I think iOS has http proxy settings in the wifi configuration for a given network? Haven’t tried recently.</div><br/></div></div><div id="37538891" class="c"><input type="checkbox" id="c-37538891" checked=""/><div class="controls bullet"><span class="by">denysvitali</span><span>|</span><a href="#37538510">parent</a><span>|</span><a href="#37538553">prev</a><span>|</span><a href="#37542145">next</a><span>|</span><label class="collapse" for="c-37538891">[-]</label><label class="expand" for="c-37538891">[1 more]</label></div><br/><div class="children"><div class="content">You can use a transparent proxy to avoid this</div><br/></div></div></div></div><div id="37542145" class="c"><input type="checkbox" id="c-37542145" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#37538510">prev</a><span>|</span><a href="#37538422">next</a><span>|</span><label class="collapse" for="c-37542145">[-]</label><label class="expand" for="c-37542145">[3 more]</label></div><br/><div class="children"><div class="content">Is there an Open Source program I could just run on the command-line, to have my own Certificate Authority? Or just to create a certificate?<p>Or do I need to know all the gory details myself?</div><br/><div id="37542830" class="c"><input type="checkbox" id="c-37542830" checked=""/><div class="controls bullet"><span class="by">goku12</span><span>|</span><a href="#37542145">parent</a><span>|</span><a href="#37542153">next</a><span>|</span><label class="collapse" for="c-37542830">[-]</label><label class="expand" for="c-37542830">[1 more]</label></div><br/><div class="children"><div class="content">mkcert if you need only on one system - usually for development. step-ca&#x2F;step-cli if you need a CA at residential or office domain. XCA if you don&#x27;t mind a GUI and know how to get the root CA certificate into the system&#x2F;browser trust stores.<p>links in this comment: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37542794">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37542794</a></div><br/></div></div><div id="37542153" class="c"><input type="checkbox" id="c-37542153" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#37542145">parent</a><span>|</span><a href="#37542830">prev</a><span>|</span><a href="#37538422">next</a><span>|</span><label class="collapse" for="c-37542153">[-]</label><label class="expand" for="c-37542153">[1 more]</label></div><br/><div class="children"><div class="content">mkcert is the easiest</div><br/></div></div></div></div><div id="37538422" class="c"><input type="checkbox" id="c-37538422" checked=""/><div class="controls bullet"><span class="by">nemo</span><span>|</span><a href="#37542145">prev</a><span>|</span><a href="#37539932">next</a><span>|</span><label class="collapse" for="c-37538422">[-]</label><label class="expand" for="c-37538422">[3 more]</label></div><br/><div class="children"><div class="content">This is not really an Apple thing, it&#x27;s an industry trend (and a good one IMO). Apple&#x27;s generally applying the same criteria Chrome is:
<a href="https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromium&#x2F;src&#x2F;+&#x2F;HEAD&#x2F;net&#x2F;docs&#x2F;certificate_lifetimes.md#:~:text=Google%20Chrome%20will%20reject%20such,existing%20validity%2Dperiod%20based%20enforcement" rel="nofollow noreferrer">https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromium&#x2F;src&#x2F;+&#x2F;HEAD&#x2F;net&#x2F;do...</a></div><br/><div id="37538756" class="c"><input type="checkbox" id="c-37538756" checked=""/><div class="controls bullet"><span class="by">xg15</span><span>|</span><a href="#37538422">parent</a><span>|</span><a href="#37539932">next</a><span>|</span><label class="collapse" for="c-37538756">[-]</label><label class="expand" for="c-37538756">[2 more]</label></div><br/><div class="children"><div class="content">Seems Chrome is specifically making an exception for custom root CAs though:<p>&gt; <i>This will only apply to TLS server certificates from CAs that are trusted in a default installation of Google Chrome, commonly known as “publicly trusted CAs”, and will not apply to locally-operated CAs that have been manually configured.</i></div><br/><div id="37539602" class="c"><input type="checkbox" id="c-37539602" checked=""/><div class="controls bullet"><span class="by">nemo</span><span>|</span><a href="#37538422">root</a><span>|</span><a href="#37538756">parent</a><span>|</span><a href="#37539932">next</a><span>|</span><label class="collapse" for="c-37539602">[-]</label><label class="expand" for="c-37539602">[1 more]</label></div><br/><div class="children"><div class="content">Looking into it further, that&#x27;s actually Apple&#x27;s policy as well.</div><br/></div></div></div></div></div></div><div id="37539932" class="c"><input type="checkbox" id="c-37539932" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#37538422">prev</a><span>|</span><a href="#37540592">next</a><span>|</span><label class="collapse" for="c-37539932">[-]</label><label class="expand" for="c-37539932">[1 more]</label></div><br/><div class="children"><div class="content">Yahoo&#x27;s in-house CA for doing this at scale:<p><a href="https:&#x2F;&#x2F;www.athenz.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.athenz.io&#x2F;</a></div><br/></div></div><div id="37540592" class="c"><input type="checkbox" id="c-37540592" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#37539932">prev</a><span>|</span><a href="#37539674">next</a><span>|</span><label class="collapse" for="c-37540592">[-]</label><label class="expand" for="c-37540592">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Only&quot; missing how to safely distribute, trust and revoke&#x2F;renew the root cert - and how to enforce&#x2F;distribute revocation lists for certs...</div><br/><div id="37542098" class="c"><input type="checkbox" id="c-37542098" checked=""/><div class="controls bullet"><span class="by">wejn</span><span>|</span><a href="#37540592">parent</a><span>|</span><a href="#37539674">next</a><span>|</span><label class="collapse" for="c-37542098">[-]</label><label class="expand" for="c-37542098">[1 more]</label></div><br/><div class="children"><div class="content">&quot;only&quot; out of scope.<p>But based on the comments here, I guess you could use the smallstep CA with Nitrokey HSM if that&#x27;s your jam...</div><br/></div></div></div></div><div id="37539674" class="c"><input type="checkbox" id="c-37539674" checked=""/><div class="controls bullet"><span class="by">firesteelrain</span><span>|</span><a href="#37540592">prev</a><span>|</span><a href="#37540965">next</a><span>|</span><label class="collapse" for="c-37539674">[-]</label><label class="expand" for="c-37539674">[4 more]</label></div><br/><div class="children"><div class="content">HashiCorp Vault supports being an ACME server. Why not use that?</div><br/><div id="37542085" class="c"><input type="checkbox" id="c-37542085" checked=""/><div class="controls bullet"><span class="by">wejn</span><span>|</span><a href="#37539674">parent</a><span>|</span><a href="#37539955">next</a><span>|</span><label class="collapse" for="c-37542085">[-]</label><label class="expand" for="c-37542085">[1 more]</label></div><br/><div class="children"><div class="content">Because:<p>1. ACME is a dumpster fire prone to mitm attacks.<p>2. without HSM (an additional investment) it&#x27;s super bad idea to host your root CA signing key somewhere.</div><br/></div></div><div id="37539955" class="c"><input type="checkbox" id="c-37539955" checked=""/><div class="controls bullet"><span class="by">rigrassm</span><span>|</span><a href="#37539674">parent</a><span>|</span><a href="#37542085">prev</a><span>|</span><a href="#37540965">next</a><span>|</span><label class="collapse" for="c-37539955">[-]</label><label class="expand" for="c-37539955">[2 more]</label></div><br/><div class="children"><div class="content">To be fair, this was only introduced in the most recent major version release not too long ago.<p>But I agree, it&#x27;s a great feature and worked as advertised after following their guide. Doesn&#x27;t sound like a ringing endorsement  but in my experience it&#x27;s rare for custom CA tooling to Just Work and until now none of them resulted in a fully functional ACME provider to serve up your certs.</div><br/><div id="37540045" class="c"><input type="checkbox" id="c-37540045" checked=""/><div class="controls bullet"><span class="by">firesteelrain</span><span>|</span><a href="#37539674">root</a><span>|</span><a href="#37539955">parent</a><span>|</span><a href="#37540965">next</a><span>|</span><label class="collapse" for="c-37540045">[-]</label><label class="expand" for="c-37540045">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I just set it up the other day in a container. It’s going to be our ACME provider. It is stupid easy</div><br/></div></div></div></div></div></div><div id="37540965" class="c"><input type="checkbox" id="c-37540965" checked=""/><div class="controls bullet"><span class="by">unethical_ban</span><span>|</span><a href="#37539674">prev</a><span>|</span><a href="#37539804">next</a><span>|</span><label class="collapse" for="c-37540965">[-]</label><label class="expand" for="c-37540965">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;hohnstaedt.de&#x2F;xca&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hohnstaedt.de&#x2F;xca&#x2F;</a><p>This doesn&#x27;t cover deployment of the CAs to clients, but it&#x27;s easy free desktop software.</div><br/></div></div><div id="37539804" class="c"><input type="checkbox" id="c-37539804" checked=""/><div class="controls bullet"><span class="by">sacnoradhq</span><span>|</span><a href="#37540965">prev</a><span>|</span><a href="#37540941">next</a><span>|</span><label class="collapse" for="c-37539804">[-]</label><label class="expand" for="c-37539804">[1 more]</label></div><br/><div class="children"><div class="content">OPNsense has built-in easy CA&#x2F;PKI management.</div><br/></div></div><div id="37540941" class="c"><input type="checkbox" id="c-37540941" checked=""/><div class="controls bullet"><span class="by">ivlad</span><span>|</span><a href="#37539804">prev</a><span>|</span><a href="#37539107">next</a><span>|</span><label class="collapse" for="c-37540941">[-]</label><label class="expand" for="c-37540941">[3 more]</label></div><br/><div class="children"><div class="content">Using RSA in 2023 for a CA that is expected to be around for an extended period of time is just silly.<p>ECDSA 384 or longer depending on the expected CA lifetime and security margins (see <a href="https:&#x2F;&#x2F;www.keylength.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.keylength.com&#x2F;</a>) is a saner choice.<p>Also, <a href="https:&#x2F;&#x2F;blog.trailofbits.com&#x2F;2019&#x2F;07&#x2F;08&#x2F;fuck-rsa&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.trailofbits.com&#x2F;2019&#x2F;07&#x2F;08&#x2F;fuck-rsa&#x2F;</a></div><br/><div id="37542018" class="c"><input type="checkbox" id="c-37542018" checked=""/><div class="controls bullet"><span class="by">m1keil</span><span>|</span><a href="#37540941">parent</a><span>|</span><a href="#37541471">next</a><span>|</span><label class="collapse" for="c-37542018">[-]</label><label class="expand" for="c-37542018">[1 more]</label></div><br/><div class="children"><div class="content">Makes no difference in his setup as he can rotate the CA and the rest of the infrastructure quickly.</div><br/></div></div></div></div></div></div></div></div></div></body></html>