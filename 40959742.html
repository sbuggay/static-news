<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721034065349" as="style"/><link rel="stylesheet" href="styles.css?v=1721034065349"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://thasso.xyz/2024/07/13/setting-up-an-x86-cpu.html">Writing a BIOS bootloader for 64-bit mode from scratch</a> <span class="domain">(<a href="https://thasso.xyz">thasso.xyz</a>)</span></div><div class="subtext"><span>D4ckard</span> | <span>55 comments</span></div><br/><div><div id="40960107" class="c"><input type="checkbox" id="c-40960107" checked=""/><div class="controls bullet"><span class="by">5-</span><span>|</span><a href="#40960683">next</a><span>|</span><label class="collapse" for="c-40960107">[-]</label><label class="expand" for="c-40960107">[12 more]</label></div><br/><div class="children"><div class="content">note that you can switch to long mode directly, without going into protected mode first, with way less code:<p><a href="https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Entering_Long_Mode_Directly" rel="nofollow">https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Entering_Long_Mode_Directly</a><p>i&#x27;ve had a bootloader for a small 64-bit kernel based on this that fit comfortably into the bootsector, including loading the kernel from disk and setting up vesa modes, no stage2 required.</div><br/><div id="40966244" class="c"><input type="checkbox" id="c-40966244" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#40960107">parent</a><span>|</span><a href="#40965285">next</a><span>|</span><label class="collapse" for="c-40966244">[-]</label><label class="expand" for="c-40966244">[1 more]</label></div><br/><div class="children"><div class="content">you are right. Though with the partition table in there so u can support a &#x27;modern&#x27; AHCI controller and SATA it will shrink your bootloader further and require some optimizations.... - you don&#x27;t have 510 bytes for the loader in this case but a bunch less. if you want to populate the table with valid entries then it becomes even more tricky (can&#x27;t use any bytes inside of the table...)<p>If you want to use an actual modern harddisk, you might want to look at GPT rather than MBR, as it won&#x27;t overflow partition table stuff and allow for very large disks (2TB+?) (uefi gets rid of all of that and allows u to use a proper disk layout without any additional difficulty!)<p>there is no need for protected mode if you want to launch into 64-bit mode. I would say though, DO NOT USE BIOS. It&#x27;s a piece of rubbish which will just make things more tedious.<p>Using UEFI via EDK2 or GnuEFI is the way to go, and both methods are really easy and a blessin to implement. It&#x27;s a bit hard to get around the initial idea of UEFI, but if you view some other people&#x27;s example projects on github you can find easily how it works. EDK is a bit shitty with .dec and .inf files etc, and GnuEFI is just reading headerfiles to discover what is there, but it&#x27;s inifnitely better than the unspecified bios interface.  You can litterally not even assume the int 0x10, int 0x15 etc. are there properly if you start running on real hardware. On UEFI systems, you can assume a stable minimal basis, and easily enumerate other things (hardware&#x2F;platform capabilities etc.) in a sane way.<p>Also UEFI sets up the platform a long way already, so you don&#x27;t need to do any initialization for your os-loader component (stage2 or 3). You can simply start loading your os right away. or drivers or whatever kind of design your kernel is. get memory map, get some access to efi file system, start pulling in and loading stuff.</div><br/></div></div><div id="40965285" class="c"><input type="checkbox" id="c-40965285" checked=""/><div class="controls bullet"><span class="by">ChickeNES</span><span>|</span><a href="#40960107">parent</a><span>|</span><a href="#40966244">prev</a><span>|</span><a href="#40960294">next</a><span>|</span><label class="collapse" for="c-40965285">[-]</label><label class="expand" for="c-40965285">[2 more]</label></div><br/><div class="children"><div class="content">Or just use <a href="https:&#x2F;&#x2F;limine-bootloader.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;limine-bootloader.org&#x2F;</a>, which greatly simplifies everything. No messing around in real mode (even when doing SMP), automatically loads your kernel using a higher-half mapping, and also works on aarch64 and riscv64.</div><br/><div id="40965639" class="c"><input type="checkbox" id="c-40965639" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40960107">root</a><span>|</span><a href="#40965285">parent</a><span>|</span><a href="#40960294">next</a><span>|</span><label class="collapse" for="c-40965639">[-]</label><label class="expand" for="c-40965639">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, writing a bootloader is an interesting and educational project in its own right. But yes, for most people interested in osdev they should just use an existing bootloader. It gets you to the part that interests most people (writing the kernel) faster, and without having to worry if you are going to run into gnarly bugs because the bootloader is buggy and you never realized.</div><br/></div></div></div></div><div id="40960294" class="c"><input type="checkbox" id="c-40960294" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#40960107">parent</a><span>|</span><a href="#40965285">prev</a><span>|</span><a href="#40965654">next</a><span>|</span><label class="collapse" for="c-40960294">[-]</label><label class="expand" for="c-40960294">[6 more]</label></div><br/><div class="children"><div class="content">&gt; i&#x27;ve had a bootloader for a small 64-bit kernel based on this that fit comfortably into the bootsector, including loading the kernel from disk and setting up vesa modes, no stage2 required.<p>How in the world do you fit all that in 512 bytes? I&#x27;m guessing you don&#x27;t have a real-world filesystem (that allows the kernel to be anywhere on the disk just as a normal file)? Because just dealing with file fragmentation should bump you way over 512 bytes I would imagine.</div><br/><div id="40964337" class="c"><input type="checkbox" id="c-40964337" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40960107">root</a><span>|</span><a href="#40960294">parent</a><span>|</span><a href="#40961722">next</a><span>|</span><label class="collapse" for="c-40964337">[-]</label><label class="expand" for="c-40964337">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because just dealing with file fragmentation should bump you way over 512 bytes I would imagine.<p>Historically, many filesystems have had a special file type or attribute for contiguous files - a file guaranteed to not be fragmented on disk. Most commonly used for boot loaders, OS kernels, or other essential system files - although historically some people used them for database files for a performance boost (which is likely rather marginal with contemporary systems, but decades ago could be much more significant).<p>Some systems required certain system files to be contiguous without having any special file metadata to mark them as such - for example, MS-DOS required IO.SYS and MSDOS.SYS to be contiguous on disk, but didn’t have any file attribute to mark them as contiguous. Unlike an operating system with proper support for contiguous files, DOS won’t do anything to stop you fragmenting IO.SYS or MSDOS.SYS, it is just the system will fail to start if you do. (Some might interpret the System attribute as implying Contiguous, but officially speaking it doesn’t.)</div><br/></div></div><div id="40961722" class="c"><input type="checkbox" id="c-40961722" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40960107">root</a><span>|</span><a href="#40960294">parent</a><span>|</span><a href="#40964337">prev</a><span>|</span><a href="#40960397">next</a><span>|</span><label class="collapse" for="c-40961722">[-]</label><label class="expand" for="c-40961722">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been thinking about how to structure a filesystem such that code complexity - in the boot loader and elsewhere - can be minimized. You&#x27;d want something similar to NTFS, except that it should be possible to refer to a file (MFT entry) directly by starting sector number. So they would either need to always remain at a fixed position, or have a link pointing back to any reference so it can be updated.<p>Somewhere in the first sector (aligned to a 64 bit boundary), there would be a small structure that just contains a unique signature (not ASCII but some random value; 64 bits seems like more than enough as opposed to a GUID), and a pointer to the &quot;FS info block&quot;. Leaving all remaining space in the sector available for boot code or possibly another &quot;overlayed&quot; filesystem.<p>That info block in turn would point to the MFT entry for the stage 2 boot code. An MFT entry would contain at a minimum an easy to locate list of (start sector,count) extents. Maybe there could be a flag that tells the OS that a certain file should never be fragmented?<p>File names would be entirely optional and for human consumption; for direct links within a filesystem, sector numbers would be used, and some kind of unique numeric identifier for anything &quot;higher-level&quot;.<p>I&#x27;m genuinely wondering if some expert here sees any problem with this scheme, other than it not conforming to how mainstream OSes do things?</div><br/><div id="40962577" class="c"><input type="checkbox" id="c-40962577" checked=""/><div class="controls bullet"><span class="by">RiverCrochet</span><span>|</span><a href="#40960107">root</a><span>|</span><a href="#40961722">parent</a><span>|</span><a href="#40962375">next</a><span>|</span><label class="collapse" for="c-40962577">[-]</label><label class="expand" for="c-40962577">[1 more]</label></div><br/><div class="children"><div class="content">&gt; File names would be entirely optional and for human consumption; for direct links within a filesystem, sector numbers would be used, and some kind of unique numeric identifier for anything &quot;higher-level&quot;.<p>Each file has index number (&quot;Inode&quot;?) in the MFT.  The first 24 (0-23) are reserved, and 11 of them contain metadata about the volume .  <a href="https:&#x2F;&#x2F;flatcap.github.io&#x2F;linux-ntfs&#x2F;ntfs&#x2F;files&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flatcap.github.io&#x2F;linux-ntfs&#x2F;ntfs&#x2F;files&#x2F;</a> - somewhere in the Windows API is something that allows opening a file by &quot;Inode&quot; number.  This link and info may be really old so it could be more of the reserved inodes are used now.<p>So, if 23 isn&#x27;t being used yet, you could use that to put your 2BL - create a file there and name it $2BL or something.  Would be funny to see what future Windows update that does use it does to it, if that ever happens (and of course maybe it is used).<p>&gt; Maybe there could be a flag that tells the OS that a certain file should never be fragmented?<p>Haven&#x27;t looked but I recall from an old book I read that small files are stored right in the MFT and I think existing data + the cluster size is the limit there.</div><br/></div></div></div></div><div id="40960397" class="c"><input type="checkbox" id="c-40960397" checked=""/><div class="controls bullet"><span class="by">5-</span><span>|</span><a href="#40960107">root</a><span>|</span><a href="#40960294">parent</a><span>|</span><a href="#40961722">prev</a><span>|</span><a href="#40965654">next</a><span>|</span><label class="collapse" for="c-40960397">[-]</label><label class="expand" for="c-40960397">[1 more]</label></div><br/><div class="children"><div class="content">yes, the kernel was in a known location on disk (directly after the bootsector).<p>the whole boot disk image was generated during build, which is common for small systems.</div><br/></div></div></div></div><div id="40965654" class="c"><input type="checkbox" id="c-40965654" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#40960107">parent</a><span>|</span><a href="#40960294">prev</a><span>|</span><a href="#40960148">next</a><span>|</span><label class="collapse" for="c-40965654">[-]</label><label class="expand" for="c-40965654">[1 more]</label></div><br/><div class="children"><div class="content">Oh, cool. I never knew that was possible. Showing my ignorance here, but assuming we&#x27;re just trying to get to long mode, why would we tour through protected mode at all?</div><br/></div></div><div id="40960148" class="c"><input type="checkbox" id="c-40960148" checked=""/><div class="controls bullet"><span class="by">D4ckard</span><span>|</span><a href="#40960107">parent</a><span>|</span><a href="#40965654">prev</a><span>|</span><a href="#40960683">next</a><span>|</span><label class="collapse" for="c-40960148">[-]</label><label class="expand" for="c-40960148">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you can do that too</div><br/></div></div></div></div><div id="40960683" class="c"><input type="checkbox" id="c-40960683" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#40960107">prev</a><span>|</span><a href="#40960224">next</a><span>|</span><label class="collapse" for="c-40960683">[-]</label><label class="expand" for="c-40960683">[5 more]</label></div><br/><div class="children"><div class="content">The 80286 has the Machine Status Word (MSW), a 16 bit register.  The 80386 expands this to CR0, a 32 bits register.  Then 64 bit long mode adds the EFER MSR and expands CR0 to 64 bits. But even today  only 11 bits of CR0 are in use and EFER has 8 active bits.   I wonder why intel&#x2F;AMD did not simply use the free bits of the existing register, and made that decision twice?<p><a href="https:&#x2F;&#x2F;wiki.osdev.org&#x2F;CPU_Registers_x86-64#CR0" rel="nofollow">https:&#x2F;&#x2F;wiki.osdev.org&#x2F;CPU_Registers_x86-64#CR0</a>.</div><br/><div id="40965154" class="c"><input type="checkbox" id="c-40965154" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40960683">parent</a><span>|</span><a href="#40961011">next</a><span>|</span><label class="collapse" for="c-40965154">[-]</label><label class="expand" for="c-40965154">[1 more]</label></div><br/><div class="children"><div class="content">The one-word answer is probably &quot;bureaucracy&quot;. Large groups of people just don&#x27;t tend to make particularly good decisions overall, and a lot of nonsensical choices arise from that.<p>Ditto for why CR1 and 5-7 are still &quot;reserved&quot; and CR8 came into existence.</div><br/></div></div><div id="40961011" class="c"><input type="checkbox" id="c-40961011" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#40960683">parent</a><span>|</span><a href="#40965154">prev</a><span>|</span><a href="#40960224">next</a><span>|</span><label class="collapse" for="c-40961011">[-]</label><label class="expand" for="c-40961011">[3 more]</label></div><br/><div class="children"><div class="content">Probably for more robust backwards compatibility with software that might assume a given value for or write to the reserved bits. The assignment of bits to registers like this in the hardware is pretty arbitrary, there&#x27;s not really any cost to using the higher bits</div><br/><div id="40961288" class="c"><input type="checkbox" id="c-40961288" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40960683">root</a><span>|</span><a href="#40961011">parent</a><span>|</span><a href="#40961230">next</a><span>|</span><label class="collapse" for="c-40961288">[-]</label><label class="expand" for="c-40961288">[1 more]</label></div><br/><div class="children"><div class="content">The flag register layout is another case of extreme backwards compatibility - its lower bits have the same definitions they had on the 8-bit 8080, even the same fixed values:<p>Sign : Zero : always &#x27;0&#x27; : AuxCarry : always &#x27;0&#x27; : Parity : always &#x27;1&#x27; : Carry<p>(the parity flag came all the way from the 8008 &#x2F; Datapoint 2200[1], and is the inverted XOR of the result&#x27;s lower 8 bits; aux carry is the carry out of bit 3, used for BCD arithmetic)<p>Flag bit 15 has also stayed reserved, except at one time it was used by the NEC Vxx chips for their 8080 compatibility mode. That feature had to be first unlocked by executing a special instruction, because there is code out there that loads the entire (16 bit) flag register with 0000 or FFFF. With the mode bit unlocked, that would inadvertently switch the CPU to running a completely different set of opcodes!<p>[1] <a href="https:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;08&#x2F;datapoint-to-8086.html" rel="nofollow">https:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;08&#x2F;datapoint-to-8086.html</a></div><br/></div></div><div id="40961230" class="c"><input type="checkbox" id="c-40961230" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#40960683">root</a><span>|</span><a href="#40961011">parent</a><span>|</span><a href="#40961288">prev</a><span>|</span><a href="#40960224">next</a><span>|</span><label class="collapse" for="c-40961230">[-]</label><label class="expand" for="c-40961230">[1 more]</label></div><br/><div class="children"><div class="content">Particularly AMD made the 64 bit extension without any real input from Intel and didn&#x27;t want to use any bits that would later conflict with a bit Intel might use in CR0.  So a brand new register was in order.</div><br/></div></div></div></div></div></div><div id="40960224" class="c"><input type="checkbox" id="c-40960224" checked=""/><div class="controls bullet"><span class="by">blankx32</span><span>|</span><a href="#40960683">prev</a><span>|</span><a href="#40961400">next</a><span>|</span><label class="collapse" for="c-40960224">[-]</label><label class="expand" for="c-40960224">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;wiki.osdev.org&#x2F;A20_Line" rel="nofollow">https:&#x2F;&#x2F;wiki.osdev.org&#x2F;A20_Line</a></div><br/></div></div><div id="40961400" class="c"><input type="checkbox" id="c-40961400" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40960224">prev</a><span>|</span><a href="#40960615">next</a><span>|</span><label class="collapse" for="c-40961400">[-]</label><label class="expand" for="c-40961400">[2 more]</label></div><br/><div class="children"><div class="content">The most unnecessarily complicated thing in this article to me is the Makefile and linker script. NASM supports generating flat binary output, but apparently using it would be too &quot;hacky&quot;?</div><br/><div id="40961430" class="c"><input type="checkbox" id="c-40961430" checked=""/><div class="controls bullet"><span class="by">darby_nine</span><span>|</span><a href="#40961400">parent</a><span>|</span><a href="#40960615">next</a><span>|</span><label class="collapse" for="c-40961430">[-]</label><label class="expand" for="c-40961430">[1 more]</label></div><br/><div class="children"><div class="content">I find linker scripts much easier to read and reason about than flat nasm but that&#x27;s just me. Especially with multiple source files.</div><br/></div></div></div></div><div id="40960615" class="c"><input type="checkbox" id="c-40960615" checked=""/><div class="controls bullet"><span class="by">ThinkBeat</span><span>|</span><a href="#40961400">prev</a><span>|</span><a href="#40961453">next</a><span>|</span><label class="collapse" for="c-40960615">[-]</label><label class="expand" for="c-40960615">[13 more]</label></div><br/><div class="children"><div class="content">All to me entirely unnecessary steps required to get the CPU into the correct
mode is astounding.<p>They all seem to be steps needed for backwards compatibility.<p>Could Intel just provide a flag, command, to start in the right mode
from the beginning.<p>Or just remove all the backwards compatibility.<p>I think I remember doing some research and ARM64 has some of the 
same issues.<p>Are there any CPUs that are designed from scratch as 64 bit 
it will not have any need for backwards compatibility and 
would enter the required state by default?<p>I guess sthat was the goal &#x2F; design of  Itanium?<p>are made to start in the desired 64 bit state
from th</div><br/><div id="40960665" class="c"><input type="checkbox" id="c-40960665" checked=""/><div class="controls bullet"><span class="by">nullindividual</span><span>|</span><a href="#40960615">parent</a><span>|</span><a href="#40965162">next</a><span>|</span><label class="collapse" for="c-40960665">[-]</label><label class="expand" for="c-40960665">[1 more]</label></div><br/><div class="children"><div class="content">This is what Intel&#x27;s proposed X86S [0] is designed for.<p>&gt; X86S is a legacy-reduced-OS ISA that removes outdated execution modes and operating system
ISA.<p>&gt; The presence of the X86S ISA is enumerated by a single, main CPUID feature
LEGACY_REDUCED_ISA in CPUID 7.1.ECX[2] which implies all the ISA removals described in this document. A new, 64-bit “start-up” interprocessor interrupt (SIPI) has a separate CPUID feature flag.<p>[0] <a href="https:&#x2F;&#x2F;cdrdv2.intel.com&#x2F;v1&#x2F;dl&#x2F;getContent&#x2F;776648" rel="nofollow">https:&#x2F;&#x2F;cdrdv2.intel.com&#x2F;v1&#x2F;dl&#x2F;getContent&#x2F;776648</a> [pdf warning]</div><br/></div></div><div id="40965162" class="c"><input type="checkbox" id="c-40965162" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40960615">parent</a><span>|</span><a href="#40960665">prev</a><span>|</span><a href="#40960660">next</a><span>|</span><label class="collapse" for="c-40965162">[-]</label><label class="expand" for="c-40965162">[2 more]</label></div><br/><div class="children"><div class="content">Intel tried that with the 80376 and it did not go well: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_80376" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_80376</a><p>Neither did the Itanium (Itanic).<p>Backwards compatibility is the whole reason for choosing x86 over ARM, MIPS, RISC-V, etc. Sadly it seems some people at Intel and AMD don&#x27;t realise this.</div><br/><div id="40965648" class="c"><input type="checkbox" id="c-40965648" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#40960615">root</a><span>|</span><a href="#40965162">parent</a><span>|</span><a href="#40960660">next</a><span>|</span><label class="collapse" for="c-40965648">[-]</label><label class="expand" for="c-40965648">[1 more]</label></div><br/><div class="children"><div class="content">Backwards compatibility is good and necessary. But I don&#x27;t think backwards compatibility going all the way back to the 8086 is. If someone has software written for the 8086 at this point, they would be far better served by running it in dosbox or something than on bare metal.</div><br/></div></div></div></div><div id="40960660" class="c"><input type="checkbox" id="c-40960660" checked=""/><div class="controls bullet"><span class="by">LiamPowell</span><span>|</span><a href="#40960615">parent</a><span>|</span><a href="#40965162">prev</a><span>|</span><a href="#40965290">next</a><span>|</span><label class="collapse" for="c-40960660">[-]</label><label class="expand" for="c-40960660">[8 more]</label></div><br/><div class="children"><div class="content">UEFI exists. You just put a Windows-like binary in a folder on a partition and it runs in a hosted environment in 64-bit mode. And of course there&#x27;s countless bootloaders that can take care of all this for you too.</div><br/><div id="40961902" class="c"><input type="checkbox" id="c-40961902" checked=""/><div class="controls bullet"><span class="by">leeter</span><span>|</span><a href="#40960615">root</a><span>|</span><a href="#40960660">parent</a><span>|</span><a href="#40961351">next</a><span>|</span><label class="collapse" for="c-40961902">[-]</label><label class="expand" for="c-40961902">[3 more]</label></div><br/><div class="children"><div class="content">This is fine if you&#x27;re only running on a single core, however if you&#x27;re a multiprocessor OS you still need to deal with legacy when bringing up the other cores. Intel and AMD should consider a mode that disables that and brings up the other cores using a 64bit SIPI. While I applaud Intel on the X86S idea... I think there is room for bits of that without throwing out all the backwards compat. An X86SC which drops real mode and only supports 16bit &#x27;real mode&#x27; in virtualization.<p>Yes, I see the argument that if you go to that point you might as well just use emulation. However running mixed 32bit&#x2F;16bit code (Windows 98&#x2F;95) becomes problematic just because of performance reasons. DosBox does well, but good luck supporting games for the Pentium 3 era that still used 16bit libraries because of course they did. (16bit Installshield was so common going into 64bit that MS just has code to replace it so 32bit applications can still be installed despite having a 16bit installer)</div><br/><div id="40963553" class="c"><input type="checkbox" id="c-40963553" checked=""/><div class="controls bullet"><span class="by">LiamPowell</span><span>|</span><a href="#40960615">root</a><span>|</span><a href="#40961902">parent</a><span>|</span><a href="#40961351">next</a><span>|</span><label class="collapse" for="c-40963553">[-]</label><label class="expand" for="c-40963553">[2 more]</label></div><br/><div class="children"><div class="content">I vaguely recall there being some multicore stuff in UEFI, but it&#x27;s been years since I looked at it.</div><br/><div id="40963876" class="c"><input type="checkbox" id="c-40963876" checked=""/><div class="controls bullet"><span class="by">leeter</span><span>|</span><a href="#40960615">root</a><span>|</span><a href="#40963553">parent</a><span>|</span><a href="#40961351">next</a><span>|</span><label class="collapse" for="c-40963876">[-]</label><label class="expand" for="c-40963876">[1 more]</label></div><br/><div class="children"><div class="content">Intel did a prototype of a multiprocessor UEFI application that would start up cores and UEFI itself does support synchronization on the assumption that applications&#x2F;bootloaders will start other cores before calling ExitBootServices. However, there are no protocols as of 2.10 (the current spec[1]) that I can find that would bring up another processor. That said searching it can be a bit arcane.<p>[1] <a href="https:&#x2F;&#x2F;uefi.org&#x2F;specs&#x2F;UEFI&#x2F;2.10&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;uefi.org&#x2F;specs&#x2F;UEFI&#x2F;2.10&#x2F;index.html</a></div><br/></div></div></div></div></div></div><div id="40961351" class="c"><input type="checkbox" id="c-40961351" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40960615">root</a><span>|</span><a href="#40960660">parent</a><span>|</span><a href="#40961902">prev</a><span>|</span><a href="#40965290">next</a><span>|</span><label class="collapse" for="c-40961351">[-]</label><label class="expand" for="c-40961351">[4 more]</label></div><br/><div class="children"><div class="content">And then you&#x27;re free from dealing with the somewhat convoluted processor init stuff, but instead depend on the Windows PE format, FAT filesystem, and an overcomplicated API.<p>Seems like a bad tradeoff, and part of a slippery slope towards a completely locked down system, where writing your own code and getting it to run on the &#x27;bare metal&#x27; is flat out impossible.</div><br/><div id="40961398" class="c"><input type="checkbox" id="c-40961398" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40960615">root</a><span>|</span><a href="#40961351">parent</a><span>|</span><a href="#40965290">next</a><span>|</span><label class="collapse" for="c-40961398">[-]</label><label class="expand" for="c-40961398">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s wrong with depending on the Windows PE format, FAT filesystem and UEFI? You&#x27;re always going to have <i>some</i> dependencies. FAT32 is better than having the first sector load some magic reserved sectors. Windows PE is better than a fixed memory address.</div><br/><div id="40961481" class="c"><input type="checkbox" id="c-40961481" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40960615">root</a><span>|</span><a href="#40961398">parent</a><span>|</span><a href="#40965290">next</a><span>|</span><label class="collapse" for="c-40961481">[-]</label><label class="expand" for="c-40961481">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s adding pointless complexity, and baking assumptions about how an OS should work into the firmware. Loading a sector at a fixed memory address and jumping to it (with some function provided so that your code can go on to load other sectors) is both easier to understand, and doesn&#x27;t require you to use some multi-megabyte toolchain.</div><br/><div id="40962347" class="c"><input type="checkbox" id="c-40962347" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40960615">root</a><span>|</span><a href="#40961481">parent</a><span>|</span><a href="#40965290">next</a><span>|</span><label class="collapse" for="c-40962347">[-]</label><label class="expand" for="c-40962347">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t it be better to use a header to specify to load multiple sectors at multiple memory addresses?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40965290" class="c"><input type="checkbox" id="c-40965290" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40960615">parent</a><span>|</span><a href="#40960660">prev</a><span>|</span><a href="#40961453">next</a><span>|</span><label class="collapse" for="c-40965290">[-]</label><label class="expand" for="c-40965290">[1 more]</label></div><br/><div class="children"><div class="content">What’s wrong with arm64?</div><br/></div></div></div></div><div id="40961453" class="c"><input type="checkbox" id="c-40961453" checked=""/><div class="controls bullet"><span class="by">cf100clunk</span><span>|</span><a href="#40960615">prev</a><span>|</span><a href="#40960027">next</a><span>|</span><label class="collapse" for="c-40961453">[-]</label><label class="expand" for="c-40961453">[1 more]</label></div><br/><div class="children"><div class="content">A laudable project. UEFI proponents here wondering why the person bothered to create a new bootloader approach might be missing the point of why people undertake such tasks as this. As the writer ends:<p>&gt; Cool if you actually came along this far.<p>Cool indeed.</div><br/></div></div><div id="40960027" class="c"><input type="checkbox" id="c-40960027" checked=""/><div class="controls bullet"><span class="by">AstralStorm</span><span>|</span><a href="#40961453">prev</a><span>|</span><a href="#40960475">next</a><span>|</span><label class="collapse" for="c-40960027">[-]</label><label class="expand" for="c-40960027">[12 more]</label></div><br/><div class="children"><div class="content">How old is UEFI now? Pity nobody deprecated BIOS alongside long mode.</div><br/><div id="40960087" class="c"><input type="checkbox" id="c-40960087" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#40960027">parent</a><span>|</span><a href="#40960475">next</a><span>|</span><label class="collapse" for="c-40960087">[-]</label><label class="expand" for="c-40960087">[11 more]</label></div><br/><div class="children"><div class="content">BIOS <i>is</i> deprecated. All of its functionality on new motherboards is basically emulated via the UEFI; and it&#x27;s certainly not being extended upon.<p>Deprecated doesn&#x27;t mean deleted, it just means &quot;no longer updated&#x2F;developed with a <i>goal</i> towards removal&quot;.</div><br/><div id="40960500" class="c"><input type="checkbox" id="c-40960500" checked=""/><div class="controls bullet"><span class="by">livrem</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40960087">parent</a><span>|</span><a href="#40960475">next</a><span>|</span><label class="collapse" for="c-40960500">[-]</label><label class="expand" for="c-40960500">[10 more]</label></div><br/><div class="children"><div class="content">This killed FreeDOS (and presumably all the other *DOS as well) on modern hardware unfortunately. It was fun as long as it lasted. I do not know what the next-best single-user, single-process, non-bloated OS would be to run on modern hardware that still has some reasonably modern software and can be used for distraction-free (hobby) development the way FreeDOS could.</div><br/><div id="40960934" class="c"><input type="checkbox" id="c-40960934" checked=""/><div class="controls bullet"><span class="by">jasaldivara</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40960500">parent</a><span>|</span><a href="#40960952">next</a><span>|</span><label class="collapse" for="c-40960934">[-]</label><label class="expand" for="c-40960934">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I do not know what the next-best single-user, single-process, non-bloated OS would be to run on modern hardware that still has some reasonably modern software and can be used for distraction-free (hobby) development the way FreeDOS could.<p>Not sure why would you want a single-process OS on modern hardware, but there are some alternatives that run much less things on the background than regular Linux: Haiku, FreeBSD, NetBSD, OpenBSD, or some lightweight non-glibc, non-systemd Linux-based like Adelie or Alpine.</div><br/></div></div><div id="40960952" class="c"><input type="checkbox" id="c-40960952" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40960500">parent</a><span>|</span><a href="#40960934">prev</a><span>|</span><a href="#40960523">next</a><span>|</span><label class="collapse" for="c-40960952">[-]</label><label class="expand" for="c-40960952">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the reason why FreeDOS can&#x27;t use the CSM (the BIOS compatibility mode of UEFI)?</div><br/><div id="40960986" class="c"><input type="checkbox" id="c-40960986" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40960952">parent</a><span>|</span><a href="#40960523">next</a><span>|</span><label class="collapse" for="c-40960986">[-]</label><label class="expand" for="c-40960986">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK it can. I believe some UEFI implementations don&#x27;t have CSM.</div><br/></div></div></div></div><div id="40960523" class="c"><input type="checkbox" id="c-40960523" checked=""/><div class="controls bullet"><span class="by">trueismywork</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40960500">parent</a><span>|</span><a href="#40960952">prev</a><span>|</span><a href="#40960475">next</a><span>|</span><label class="collapse" for="c-40960523">[-]</label><label class="expand" for="c-40960523">[6 more]</label></div><br/><div class="children"><div class="content">Linux in single user mode</div><br/><div id="40960667" class="c"><input type="checkbox" id="c-40960667" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40960523">parent</a><span>|</span><a href="#40960475">next</a><span>|</span><label class="collapse" for="c-40960667">[-]</label><label class="expand" for="c-40960667">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s still multi-process though, there&#x27;s an awful lot of background tasks running in pretty much every non-fossil kernel version, not to mention userspace daemons (udev, dbus, dhcp) without which most normal userspace stuff doesn&#x27;t even work.</div><br/><div id="40960876" class="c"><input type="checkbox" id="c-40960876" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40960667">parent</a><span>|</span><a href="#40960475">next</a><span>|</span><label class="collapse" for="c-40960876">[-]</label><label class="expand" for="c-40960876">[4 more]</label></div><br/><div class="children"><div class="content">None of that exists in single user. When you say init=&#x2F;bin&#x2F;foo,  then that&#x27;s it, the only process is &#x2F;bin&#x2F;foo.</div><br/><div id="40960927" class="c"><input type="checkbox" id="c-40960927" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40960876">parent</a><span>|</span><a href="#40960475">next</a><span>|</span><label class="collapse" for="c-40960927">[-]</label><label class="expand" for="c-40960927">[3 more]</label></div><br/><div class="children"><div class="content">&#x2F;bin&#x2F;foo is the initial process. It can fork and&#x2F;or exec other processes, right?</div><br/><div id="40961847" class="c"><input type="checkbox" id="c-40961847" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40960927">parent</a><span>|</span><a href="#40960475">next</a><span>|</span><label class="collapse" for="c-40961847">[-]</label><label class="expand" for="c-40961847">[2 more]</label></div><br/><div class="children"><div class="content">Sure the <i>facility</i> to fork still exists. So what? Observing that the kernel still provides fork() is like observing that the cpu still provides JMP.<p>It won&#x27;t fork random processes you don&#x27;t explicitly tell it to. I thought it was obvious that if you don&#x27;t want unsolicited processes, then don&#x27;t specify &#x2F;bin&#x2F;init as &#x2F;bin&#x2F;foo. The practical example is &#x2F;bin&#x2F;sh, but it could be any other executable.<p>Up to you to specify a binary that does what you want, and doesn&#x27;t require a bunch of other processes like gdbus to function itself.<p>init=&#x2F;bin&#x2F;sh is more or less like ms-dos loading command.com</div><br/><div id="40962601" class="c"><input type="checkbox" id="c-40962601" checked=""/><div class="controls bullet"><span class="by">gtirloni</span><span>|</span><a href="#40960027">root</a><span>|</span><a href="#40961847">parent</a><span>|</span><a href="#40960475">next</a><span>|</span><label class="collapse" for="c-40962601">[-]</label><label class="expand" for="c-40962601">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s obvious but many people here seem to be confusing the Linux kernel with kernel+systemd and complaining Linux has many processes like it&#x27;s not customizable.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40960475" class="c"><input type="checkbox" id="c-40960475" checked=""/><div class="controls bullet"><span class="by">ruslan</span><span>|</span><a href="#40960027">prev</a><span>|</span><a href="#40960514">next</a><span>|</span><label class="collapse" for="c-40960475">[-]</label><label class="expand" for="c-40960475">[4 more]</label></div><br/><div class="children"><div class="content">Does this boot procedure work with EFI&#x2F;UEFI ? If so, does UEFI supervisor emulate swithing real&#x2F;protected&#x2F;long modes or does it go in real hardware ?</div><br/><div id="40960567" class="c"><input type="checkbox" id="c-40960567" checked=""/><div class="controls bullet"><span class="by">khaledh</span><span>|</span><a href="#40960475">parent</a><span>|</span><a href="#40960514">next</a><span>|</span><label class="collapse" for="c-40960567">[-]</label><label class="expand" for="c-40960567">[3 more]</label></div><br/><div class="children"><div class="content">No. UEFI firmware creates a completely different environment for a UEFI bootloader than the legacy BIOS environment (real-address mode). The UEFI firmware enters 64-bit long mode directly on modern systems, and sets up a flat memory model GDT, as well as identity-mapped paging.<p>I&#x27;ve written about creating a UEFI bootloader (for my hobby OS) here: <a href="https:&#x2F;&#x2F;0xc0ffee.netlify.app&#x2F;osdev&#x2F;05-bootloader-p1.html" rel="nofollow">https:&#x2F;&#x2F;0xc0ffee.netlify.app&#x2F;osdev&#x2F;05-bootloader-p1.html</a></div><br/><div id="40961010" class="c"><input type="checkbox" id="c-40961010" checked=""/><div class="controls bullet"><span class="by">surajrmal</span><span>|</span><a href="#40960475">root</a><span>|</span><a href="#40960567">parent</a><span>|</span><a href="#40960514">next</a><span>|</span><label class="collapse" for="c-40961010">[-]</label><label class="expand" for="c-40961010">[2 more]</label></div><br/><div class="children"><div class="content">I thought many UEFI implementations support legacy bios mode as well. Or well they used to.</div><br/><div id="40961084" class="c"><input type="checkbox" id="c-40961084" checked=""/><div class="controls bullet"><span class="by">the_panopticon</span><span>|</span><a href="#40960475">root</a><span>|</span><a href="#40961010">parent</a><span>|</span><a href="#40960514">next</a><span>|</span><label class="collapse" for="c-40961084">[-]</label><label class="expand" for="c-40961084">[1 more]</label></div><br/><div class="children"><div class="content">There is still support for CSM in the open source <a href="https:&#x2F;&#x2F;github.com&#x2F;tianocore&#x2F;tianocore.github.io&#x2F;wiki&#x2F;Compatibility-Support-Module">https:&#x2F;&#x2F;github.com&#x2F;tianocore&#x2F;tianocore.github.io&#x2F;wiki&#x2F;Compat...</a> and even nice projects like <a href="https:&#x2F;&#x2F;github.com&#x2F;coreboot&#x2F;seabiosto">https:&#x2F;&#x2F;github.com&#x2F;coreboot&#x2F;seabiosto</a> fabricate the CSM16 binary, but many vendors have stopped validating this path, including production of legacy BIOS option roms for adapters (net, gfx, etc) <a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Intel-Legacy-BIOS-EOL-2020" rel="nofollow">https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Intel-Legacy-BIOS-EOL-2020</a>. I still believe CSP&#x27;s maintain some of this support in their hypervisors&#x27; guest firmware for legacy OS binaries&#x2F;ISO boot support? Also since Windows requires UEFI Secure boot enabled by default and CSM has to be disabled for the UEFI secure boot path, this is another reason legacy BIOS boot isn&#x27;t exercised so much these days. 
We could have added legacy oroms hashes to UEFI Secure boot implementations <a href="https:&#x2F;&#x2F;patents.google.com&#x2F;patent&#x2F;US8694761B2&#x2F;en" rel="nofollow">https:&#x2F;&#x2F;patents.google.com&#x2F;patent&#x2F;US8694761B2&#x2F;en</a>, too, but again folks pushed back in their zeal to remove legacy BIOS overall.  
We didn&#x27;t add the CSM spec <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;reference-guides&#x2F;efi-compatibility-support-module-specification-v098.pdf" rel="nofollow">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents...</a> to the PI <a href="https:&#x2F;&#x2F;uefi.org&#x2F;specs&#x2F;PI&#x2F;1.8A&#x2F;" rel="nofollow">https:&#x2F;&#x2F;uefi.org&#x2F;specs&#x2F;PI&#x2F;1.8A&#x2F;</a> since folks were hoping UEFI would remove the need for CSM. I still remember being challenged in the early 2000&#x27;s by a long-time BIOS mgr at Intel &quot;Is removing legacy a good idea with EFI?  You know, we&#x27;re really at legacy.&quot;</div><br/></div></div></div></div></div></div></div></div><div id="40960514" class="c"><input type="checkbox" id="c-40960514" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40960475">prev</a><span>|</span><label class="collapse" for="c-40960514">[-]</label><label class="expand" for="c-40960514">[4 more]</label></div><br/><div class="children"><div class="content">Is this any simpler on ARM?</div><br/><div id="40960956" class="c"><input type="checkbox" id="c-40960956" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40960514">parent</a><span>|</span><a href="#40961014">next</a><span>|</span><label class="collapse" for="c-40960956">[-]</label><label class="expand" for="c-40960956">[1 more]</label></div><br/><div class="children"><div class="content">Only in the sense that every board vendor does their own random thing, which makes it simpler for the board vendors and horribly complicated for everyone else.</div><br/></div></div><div id="40961014" class="c"><input type="checkbox" id="c-40961014" checked=""/><div class="controls bullet"><span class="by">surajrmal</span><span>|</span><a href="#40960514">parent</a><span>|</span><a href="#40960956">prev</a><span>|</span><a href="#40962608">next</a><span>|</span><label class="collapse" for="c-40961014">[-]</label><label class="expand" for="c-40961014">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Bootloaders are still complex, but there is less legacy setup that is required. That said, if you&#x27;re targeting UEFI instead of BIOS, it&#x27;s a great deal simpler on x86 as well.</div><br/></div></div><div id="40962608" class="c"><input type="checkbox" id="c-40962608" checked=""/><div class="controls bullet"><span class="by">gtirloni</span><span>|</span><a href="#40960514">parent</a><span>|</span><a href="#40961014">prev</a><span>|</span><label class="collapse" for="c-40962608">[-]</label><label class="expand" for="c-40962608">[1 more]</label></div><br/><div class="children"><div class="content">Not sure, I wouldn&#x27;t count on it. Currently deep in RISC-V and it seems there&#x27;s hope.</div><br/></div></div></div></div></div></div></div></div></div></body></html>