<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722416514608" as="style"/><link rel="stylesheet" href="styles.css?v=1722416514608"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.darpa.mil/program/translating-all-c-to-rust">Translating All C to Rust (TRACTOR)</a> <span class="domain">(<a href="https://www.darpa.mil">www.darpa.mil</a>)</span></div><div class="subtext"><span>steveklabnik</span> | <span>186 comments</span></div><br/><div><div id="41110276" class="c"><input type="checkbox" id="c-41110276" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41110693">next</a><span>|</span><label class="collapse" for="c-41110276">[-]</label><label class="expand" for="c-41110276">[2 more]</label></div><br/><div class="children"><div class="content">See also <a href="https:&#x2F;&#x2F;sam.gov&#x2F;opp&#x2F;1e45d648886b4e9ca91890285af77eb7&#x2F;view" rel="nofollow">https:&#x2F;&#x2F;sam.gov&#x2F;opp&#x2F;1e45d648886b4e9ca91890285af77eb7&#x2F;view</a></div><br/><div id="41110616" class="c"><input type="checkbox" id="c-41110616" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#41110276">parent</a><span>|</span><a href="#41110693">next</a><span>|</span><label class="collapse" for="c-41110616">[-]</label><label class="expand" for="c-41110616">[1 more]</label></div><br/><div class="children"><div class="content">Direct link to Proposer&#x27;s Day info [PDF]:  <a href="https:&#x2F;&#x2F;sam.gov&#x2F;api&#x2F;prod&#x2F;opps&#x2F;v3&#x2F;opportunities&#x2F;resources&#x2F;files&#x2F;3f5caa5af9da4785b335c37c16e2beda&#x2F;download?&amp;token=" rel="nofollow">https:&#x2F;&#x2F;sam.gov&#x2F;api&#x2F;prod&#x2F;opps&#x2F;v3&#x2F;opportunities&#x2F;resources&#x2F;fil...</a><p>&quot;The purpose of this event is to provide information on the TRACTOR technical goals and challenges, address questions from potential proposers, and provide an opportunity for potential proposers to consider how their research may align with the TRACTOR program objectives.&quot;</div><br/></div></div></div></div><div id="41110693" class="c"><input type="checkbox" id="c-41110693" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41110276">prev</a><span>|</span><a href="#41112200">next</a><span>|</span><label class="collapse" for="c-41110693">[-]</label><label class="expand" for="c-41110693">[80 more]</label></div><br/><div class="children"><div class="content">That sounds ... hard. Especially as idiomatic Rust as written by skilled programmers looks nothing like C, and most interesting code is written in C++ anyway.<p>Isn&#x27;t it equivalent to statically determining the lifetimes of all allocations in the C program, including those that are implemented using custom allocators or which cross into proprietary libraries? There&#x27;s been a lot of research into this sort of thing over the years without much success. C&#x2F;C++ programs can do things like tie allocation lifetimes to what buttons a user clicks, without ref counting or other mechanisms to ensure safety. It&#x27;s not a good idea, but, they can do it.<p>The other obvious problem with trying to write such a static analysis is that the programs you&#x27;re analyzing are by definition buggy and the lifetimes might not make sense (if they did, they wouldn&#x27;t have memory safety holes and wouldn&#x27;t need to be replaced). The only research I&#x27;ve seen on this problem of statically detecting what lifetimes should be does assume the code being analyzed is actually correct to begin with. I guess you could try and aim for a program that detects where lifetimes can&#x27;t be worked out and asks the developer for help though.</div><br/><div id="41110862" class="c"><input type="checkbox" id="c-41110862" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41111122">next</a><span>|</span><label class="collapse" for="c-41110862">[-]</label><label class="expand" for="c-41110862">[18 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very hard; DARPA likes to fund hard things[1] :-).<p>This isn&#x27;t, however, DARPA&#x27;s first foray into automatic program translation, or even automatic translation into Rust[2].<p>[1]: <a href="https:&#x2F;&#x2F;www.urbandictionary.com&#x2F;define.php?term=DARPA%20hard" rel="nofollow">https:&#x2F;&#x2F;www.urbandictionary.com&#x2F;define.php?term=DARPA%20hard</a><p>[2]: <a href="https:&#x2F;&#x2F;c2rust.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;c2rust.com&#x2F;</a></div><br/><div id="41111383" class="c"><input type="checkbox" id="c-41111383" checked=""/><div class="controls bullet"><span class="by">the_snooze</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41110862">parent</a><span>|</span><a href="#41113477">next</a><span>|</span><label class="collapse" for="c-41111383">[-]</label><label class="expand" for="c-41111383">[8 more]</label></div><br/><div class="children"><div class="content">DARPA is basically a state-sponsored VC that optimizes for completely different things. Instead of looking for 100x financial returns, they want technical advantages for the United States. The &quot;moat&quot; is the hardness of developing and operationalizing those technologies first.</div><br/><div id="41113582" class="c"><input type="checkbox" id="c-41113582" checked=""/><div class="controls bullet"><span class="by">mburns</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111383">parent</a><span>|</span><a href="#41111437">next</a><span>|</span><label class="collapse" for="c-41113582">[-]</label><label class="expand" for="c-41113582">[2 more]</label></div><br/><div class="children"><div class="content">To be pedantic, In-q-tel is the literal state-sponsored VC.<p>DARPA is a step closer to traditional research labs but there is obviously some overlap.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;In-Q-Tel" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;In-Q-Tel</a></div><br/><div id="41113826" class="c"><input type="checkbox" id="c-41113826" checked=""/><div class="controls bullet"><span class="by">throwup238</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113582">parent</a><span>|</span><a href="#41111437">next</a><span>|</span><label class="collapse" for="c-41113826">[-]</label><label class="expand" for="c-41113826">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; DARPA is a step closer to traditional research labs but there is obviously some overlap.</i><p>It&#x27;s more like the NSF but focused on commercial grantees with project management thrown on top to orchestrate everything.<p>The really unique part is how much independence each program manager has and the term limits that prevent empire building.</div><br/></div></div></div></div><div id="41111437" class="c"><input type="checkbox" id="c-41111437" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111383">parent</a><span>|</span><a href="#41113582">prev</a><span>|</span><a href="#41113546">next</a><span>|</span><label class="collapse" for="c-41111437">[-]</label><label class="expand" for="c-41111437">[4 more]</label></div><br/><div class="children"><div class="content">DARPA&#x27;s commercialization track record is decidedly mixed, so the VC comparison is unexpectedly apt :-)<p>(But yes: DARPA&#x27;s mandate is explicitly to discover and develop the next generation of emerging technologies for military use.)</div><br/><div id="41113856" class="c"><input type="checkbox" id="c-41113856" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111437">parent</a><span>|</span><a href="#41114036">next</a><span>|</span><label class="collapse" for="c-41113856">[-]</label><label class="expand" for="c-41113856">[1 more]</label></div><br/><div class="children"><div class="content">Decades ago, as my father explained to me, ARPA (no &quot;D&quot; at that time) was happy if 1% of their projects went all the way through to successful deployment.  If they had a higher success rate it would mean they weren&#x27;t aiming high enough.</div><br/></div></div><div id="41114036" class="c"><input type="checkbox" id="c-41114036" checked=""/><div class="controls bullet"><span class="by">VikingCoder</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111437">parent</a><span>|</span><a href="#41113856">prev</a><span>|</span><a href="#41113546">next</a><span>|</span><label class="collapse" for="c-41114036">[-]</label><label class="expand" for="c-41114036">[2 more]</label></div><br/><div class="children"><div class="content">&gt; DARPA&#x27;s commercialization track record is decidedly mixed...<p>If you count my number of attempts, sure.<p>If you count by impact, it&#x27;s hard to come up with many things more impactful than the Internet...?</div><br/><div id="41114099" class="c"><input type="checkbox" id="c-41114099" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114036">parent</a><span>|</span><a href="#41113546">next</a><span>|</span><label class="collapse" for="c-41114099">[-]</label><label class="expand" for="c-41114099">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I meant by number. But also: ARPA didn&#x27;t commercialize the Internet! They explicitly refused to commercialize it; commercialization only happened after an Act of Congress induced interconnections between NSFNET and commercial networks.</div><br/></div></div></div></div></div></div></div></div><div id="41113477" class="c"><input type="checkbox" id="c-41113477" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41110862">parent</a><span>|</span><a href="#41111383">prev</a><span>|</span><a href="#41111122">next</a><span>|</span><label class="collapse" for="c-41113477">[-]</label><label class="expand" for="c-41113477">[9 more]</label></div><br/><div class="children"><div class="content">in this case it seems to me the hard task that DARPA has chosen is to get me to forget how much they spent on pushing Ada.</div><br/><div id="41113516" class="c"><input type="checkbox" id="c-41113516" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113477">parent</a><span>|</span><a href="#41114076">next</a><span>|</span><label class="collapse" for="c-41113516">[-]</label><label class="expand" for="c-41113516">[3 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t find any clear references to DARPA (or ARPA) being involved in Ada&#x27;s development. It was a DoD program but, well, the DoD is notoriously large and multi-headed.<p>(But even if DARPA was involved in Ada: I think it&#x27;s clear, at this point, that Ada has been a resounding success in a <i>small</i> number of domains without successfully breaking into general-purpose adoption. I don&#x27;t have a particular value judgment associated with that, but from a strategic perspective it makes a <i>lot</i> of sense for DARPA to focus program analysis research on popular general-purpose languages -- there&#x27;s just more labor and talent available.)</div><br/><div id="41116486" class="c"><input type="checkbox" id="c-41116486" checked=""/><div class="controls bullet"><span class="by">indolering</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113516">parent</a><span>|</span><a href="#41114076">next</a><span>|</span><label class="collapse" for="c-41116486">[-]</label><label class="expand" for="c-41116486">[2 more]</label></div><br/><div class="children"><div class="content">Too lazy to look it up, but I&#x27;m pretty sure DARPA was involved and certain that DoD contracta prioritized ADA for a long time.</div><br/><div id="41117138" class="c"><input type="checkbox" id="c-41117138" checked=""/><div class="controls bullet"><span class="by">rerdavies</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41116486">parent</a><span>|</span><a href="#41114076">next</a><span>|</span><label class="collapse" for="c-41117138">[-]</label><label class="expand" for="c-41117138">[1 more]</label></div><br/><div class="children"><div class="content">Too bored to pass up a challenge to refute somebody who is too lazy to look it up.<p>I looked it up. DARPA was not involved.</div><br/></div></div></div></div></div></div><div id="41114076" class="c"><input type="checkbox" id="c-41114076" checked=""/><div class="controls bullet"><span class="by">9659</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113477">parent</a><span>|</span><a href="#41113516">prev</a><span>|</span><a href="#41114021">next</a><span>|</span><label class="collapse" for="c-41114076">[-]</label><label class="expand" for="c-41114076">[2 more]</label></div><br/><div class="children"><div class="content">ada does not require &#x27;pushing&#x27;.<p>once the maturity of the users advances to a sufficient point, then ada is the only solution.<p>&quot;ada. used in creating reliable software since 1983&quot;<p>when i first saw ada, i didn&#x27;t understand the why.  now i understand the why, but ada is effectively gone.<p>-- old fortran &#x2F; C &#x2F; Assembly programmer</div><br/><div id="41116840" class="c"><input type="checkbox" id="c-41116840" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114076">parent</a><span>|</span><a href="#41114021">next</a><span>|</span><label class="collapse" for="c-41116840">[-]</label><label class="expand" for="c-41116840">[1 more]</label></div><br/><div class="children"><div class="content">Ada is still around, at a big enough level to keep 7 commercial vendors selling compilers.<p>Something unheard of, paying for software tools in 2024, who would imagine that.</div><br/></div></div></div></div><div id="41114021" class="c"><input type="checkbox" id="c-41114021" checked=""/><div class="controls bullet"><span class="by">reaperducer</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113477">parent</a><span>|</span><a href="#41114076">prev</a><span>|</span><a href="#41111122">next</a><span>|</span><label class="collapse" for="c-41114021">[-]</label><label class="expand" for="c-41114021">[3 more]</label></div><br/><div class="children"><div class="content"><i>in this case it seems to me the hard task that DARPA has chosen is to get me to forget how much they spent on pushing Ada.</i><p>You hate jumbo jets, high-speed trains, air traffic control, and satellites?</div><br/><div id="41114084" class="c"><input type="checkbox" id="c-41114084" checked=""/><div class="controls bullet"><span class="by">9659</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114021">parent</a><span>|</span><a href="#41111122">next</a><span>|</span><label class="collapse" for="c-41114084">[-]</label><label class="expand" for="c-41114084">[2 more]</label></div><br/><div class="children"><div class="content">Do you know what fear is?  Getting in an airplane where the flight controls use NPM.</div><br/><div id="41114190" class="c"><input type="checkbox" id="c-41114190" checked=""/><div class="controls bullet"><span class="by">warkdarrior</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114084">parent</a><span>|</span><a href="#41111122">next</a><span>|</span><label class="collapse" for="c-41114190">[-]</label><label class="expand" for="c-41114190">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   npm ERR! install Couldn&#x27;t read dependencies
   npm ERR! package.json ENOENT, open &#x27;&#x2F;boeing&#x2F;787-9&#x2F;flaps-up.json&#x27;
   npm ERR! package.json This is most likely not a problem with npm itself.
   npm ERR! package.json npm can&#x27;t find a package.json file in your current directory.</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41111122" class="c"><input type="checkbox" id="c-41111122" checked=""/><div class="controls bullet"><span class="by">sam0x17</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41110862">prev</a><span>|</span><a href="#41113429">next</a><span>|</span><label class="collapse" for="c-41111122">[-]</label><label class="expand" for="c-41111122">[4 more]</label></div><br/><div class="children"><div class="content">speaking of hard, the DOE actually funds a project that has been around for 20+ years now (ROSE) that involves (among other things) doing static analysis on and automatically translating between C&#x2F;C++&#x2F;Cuda and even high level languages like Python as well as HPC variants of C&#x2F;C++. They have a combined AST that supports all of those languages with the same set of node types essentially. Quite cool. I got to work on it when I was an intern at Livermore, summer of 2014.<p>and it&#x27;s open source as well! <a href="http:&#x2F;&#x2F;rosecompiler.org&#x2F;ROSE_HTML_Reference&#x2F;index.html" rel="nofollow">http:&#x2F;&#x2F;rosecompiler.org&#x2F;ROSE_HTML_Reference&#x2F;index.html</a></div><br/><div id="41117087" class="c"><input type="checkbox" id="c-41117087" checked=""/><div class="controls bullet"><span class="by">seren</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111122">parent</a><span>|</span><a href="#41116237">next</a><span>|</span><label class="collapse" for="c-41117087">[-]</label><label class="expand" for="c-41117087">[1 more]</label></div><br/><div class="children"><div class="content">I have already seen legacy projects that were designed using Rational Rose, but for some reason I thought it was only a commercial name, not an actual system. Thanks, I learned something today !</div><br/></div></div><div id="41116237" class="c"><input type="checkbox" id="c-41116237" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111122">parent</a><span>|</span><a href="#41117087">prev</a><span>|</span><a href="#41113429">next</a><span>|</span><label class="collapse" for="c-41116237">[-]</label><label class="expand" for="c-41116237">[2 more]</label></div><br/><div class="children"><div class="content">&gt; a combined AST that supports all of those languages with the same set of node types essentially.<p>I can&#x27;t believe that works at all. I&#x27;ll take a look for sure.</div><br/><div id="41116508" class="c"><input type="checkbox" id="c-41116508" checked=""/><div class="controls bullet"><span class="by">sam0x17</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41116237">parent</a><span>|</span><a href="#41113429">next</a><span>|</span><label class="collapse" for="c-41116508">[-]</label><label class="expand" for="c-41116508">[1 more]</label></div><br/><div class="children"><div class="content">Most of what they use it for is static analysis, but the funding comes from its ability to translate old simulation code to HPC-ready code. I think they even support fortran IIRC</div><br/></div></div></div></div></div></div><div id="41113429" class="c"><input type="checkbox" id="c-41113429" checked=""/><div class="controls bullet"><span class="by">rectang</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41111122">prev</a><span>|</span><a href="#41110845">next</a><span>|</span><label class="collapse" for="c-41113429">[-]</label><label class="expand" for="c-41113429">[14 more]</label></div><br/><div class="children"><div class="content">I have to imagine that in the general case it will be a translation to unsafe Rust, with occasional isolated leaf nodes being translated to safe Rust.<p>If you think it&#x27;s hard wrestling with the borrow checker, just imagine how much harder it is to write automatic translation to borrow-checker-approved code that accounts for all the possible program space of C and all it&#x27;s celebrated undefined behavior.  A classic problem of writing compilers is that the space of valid programs is much larger than the space of programs which will compile.<p>A quick web search reveals some other efforts, such as c2rust [1].  I wonder how TRACTOR differs.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;immunant&#x2F;c2rust">https:&#x2F;&#x2F;github.com&#x2F;immunant&#x2F;c2rust</a></div><br/><div id="41113940" class="c"><input type="checkbox" id="c-41113940" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113429">parent</a><span>|</span><a href="#41110845">next</a><span>|</span><label class="collapse" for="c-41113940">[-]</label><label class="expand" for="c-41113940">[13 more]</label></div><br/><div class="children"><div class="content">&gt; have to imagine that in the general case it will be a translation to unsafe Rust, with occasional isolated leaf nodes being translated to safe Rust.<p>That’s not what they are aiming for. FTA: <i>“The goal is to achieve the same quality and style that a skilled Rust developer would produce”</i><p>&gt; just imagine how much harder it is to write automatic translation to borrow-checker-approved code that accounts for all the possible program space of C and all it&#x27;s celebrated undefined behavior<p>Nitpick: undefined behavior gives the compiler leeway in deciding what a program does, so the more undefined behavior a C program invokes, the easier it is to translate its code to rust.<p>(Doing that translation in such a way that the behavior remains what gcc, clang or “most C compilers” do may be harder, but I’m not sure of that)</div><br/><div id="41114205" class="c"><input type="checkbox" id="c-41114205" checked=""/><div class="controls bullet"><span class="by">rectang</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113940">parent</a><span>|</span><a href="#41114363">next</a><span>|</span><label class="collapse" for="c-41114205">[-]</label><label class="expand" for="c-41114205">[9 more]</label></div><br/><div class="children"><div class="content">&gt; <i>undefined behavior gives the compiler leeway in deciding what a program does, so the more undefined behavior a C program invokes, the easier it is to translate its code to rust.</i><p>That&#x27;s the kind of language lawyer approach that caused a rebellion in the last decade amongst C programmers against irresponsible compiler optimizations.  &quot;Who cares if your program actually works as intended? My optimization is legal according to the standard, it&#x27;s <i>your</i> program that&#x27;s written to exploit loopholes&quot;.<p>I don&#x27;t see any evidence that that&#x27;s the attitude being taken by TRACTOR — I sure hope it isn&#x27;t.  But hell, even if the result is unreliable in practice, I suppose that if somebody gets to claim &quot;it works&quot; then the incentives are aligned to produce garbage.</div><br/><div id="41114321" class="c"><input type="checkbox" id="c-41114321" checked=""/><div class="controls bullet"><span class="by">atiedebee</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114205">parent</a><span>|</span><a href="#41114363">next</a><span>|</span><label class="collapse" for="c-41114321">[-]</label><label class="expand" for="c-41114321">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Who cares if your program actually works as intended? My optimization is legal according to the standard, it&#x27;s your program that&#x27;s relying written to exploit loopholes&quot;.<p>If your program invokes undefined behaviour, it&#x27;s invalid and non-portable. Out of bounds array accesses are UB, yet a program containing them may just happen to work.
It won&#x27;t be portable even between different compiler versions.<p>The C standard is a 2 way contract: the programmer doesn&#x27;t produce code that invokes undefined behaviour, and the compiler returns a standard conforming executable</div><br/><div id="41114416" class="c"><input type="checkbox" id="c-41114416" checked=""/><div class="controls bullet"><span class="by">rectang</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114321">parent</a><span>|</span><a href="#41115101">next</a><span>|</span><label class="collapse" for="c-41114416">[-]</label><label class="expand" for="c-41114416">[2 more]</label></div><br/><div class="children"><div class="content">The C standard with its extensive undefined behavior causes programmers and compiler writers to be at odds.  In a sane world, &quot;undefined behavior&quot; wouldn&#x27;t be assumed to mean &quot;the programmer must have meant for me to optimize this whole section of code away&quot;.  We aren&#x27;t on the same team, even if I believe that all parties are acting with the best of intentions.<p>I don&#x27;t feel that the Rust language situation incentivizes such awful conflict, and it&#x27;s one of many reasons I now try <i>really</i> hard to avoid C and use Rust instead.</div><br/><div id="41115755" class="c"><input type="checkbox" id="c-41115755" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114416">parent</a><span>|</span><a href="#41115101">next</a><span>|</span><label class="collapse" for="c-41115755">[-]</label><label class="expand" for="c-41115755">[1 more]</label></div><br/><div class="children"><div class="content">A funny thing about this problem is that it gets worse the more formally correct your implementation is. Undefined behavior is undefined, so it&#x27;s outside the model, and if your program is a 100% correct implementation of a model then how can it know what to do about something outside it?<p>But I don&#x27;t think defining all behavior helps. The defined behavior could be &#x2F;wrong&#x2F;, and now you can&#x27;t find it because the program using it is valid, so it can&#x27;t be detected with UBSan.</div><br/></div></div></div></div><div id="41115101" class="c"><input type="checkbox" id="c-41115101" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114321">parent</a><span>|</span><a href="#41114416">prev</a><span>|</span><a href="#41114484">next</a><span>|</span><label class="collapse" for="c-41115101">[-]</label><label class="expand" for="c-41115101">[4 more]</label></div><br/><div class="children"><div class="content">If undefined behavior is invalid, then reject the program instead of &quot;optimizing&quot; it. This &quot;oh look undefined behavior I&#x27;m gonna turn the entire function into a no-op&quot; nonsense is completely unacceptable. It&#x27;s adversarial and borders on malicious. Null pointer check deletion can turn bugs into exploitable vulnerabilities.</div><br/><div id="41115901" class="c"><input type="checkbox" id="c-41115901" checked=""/><div class="controls bullet"><span class="by">zajio1am</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41115101">parent</a><span>|</span><a href="#41114484">next</a><span>|</span><label class="collapse" for="c-41115901">[-]</label><label class="expand" for="c-41115901">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If undefined behavior is invalid, then reject the program instead of &quot;optimizing&quot; it.<p>Undefined behavior is usually a result of runtime situation, it is usually not obvious from just the code whether it could or could not happen, so the compiler cannot reject the program.<p>The &#x27;UB-based&#x27; optimization is just assumption that the code is correct and therefore UB-situation could not happen in runtime.</div><br/><div id="41117185" class="c"><input type="checkbox" id="c-41117185" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41115901">parent</a><span>|</span><a href="#41114484">next</a><span>|</span><label class="collapse" for="c-41117185">[-]</label><label class="expand" for="c-41117185">[2 more]</label></div><br/><div class="children"><div class="content">Usually but not always. For example, the removal of an empty effect free infinite loop. This should be an error.</div><br/><div id="41117304" class="c"><input type="checkbox" id="c-41117304" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41117185">parent</a><span>|</span><a href="#41114484">next</a><span>|</span><label class="collapse" for="c-41117304">[-]</label><label class="expand" for="c-41117304">[1 more]</label></div><br/><div class="children"><div class="content">The C++ forward progress guarantee enables more optimizations since it allows the compiler to reason more easily about loops:<p>&gt; The standards added the forward progress guarantees to change an optimization problem from &quot;solve the halting problem&quot; to &quot;there will be observable side effects in the forms of termination, I&#x2F;O, volatile, and&#x2F;or atomic synchronization, any other operation can be reordered&quot;. The former is generally impossible to solve, whereas the latter is eminently tractable.<p>But yeah, that&#x27;s one of the more foot-gunny UB rules that Rust does not have. But it does mean it doesn&#x27;t mark functions as `mustprogress` in LLVM IR which means it misses out on whatever optimizations that enables.</div><br/></div></div></div></div></div></div></div></div><div id="41114484" class="c"><input type="checkbox" id="c-41114484" checked=""/><div class="controls bullet"><span class="by">Asooka</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114321">parent</a><span>|</span><a href="#41115101">prev</a><span>|</span><a href="#41114363">next</a><span>|</span><label class="collapse" for="c-41114484">[-]</label><label class="expand" for="c-41114484">[1 more]</label></div><br/><div class="children"><div class="content">Doing one funny thing on platform A and a different funny thing on platform B when an edge case arises is way better than completely deleting the code on all platforms with no warning.</div><br/></div></div></div></div></div></div><div id="41114363" class="c"><input type="checkbox" id="c-41114363" checked=""/><div class="controls bullet"><span class="by">derdi</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113940">parent</a><span>|</span><a href="#41114205">prev</a><span>|</span><a href="#41110845">next</a><span>|</span><label class="collapse" for="c-41114363">[-]</label><label class="expand" for="c-41114363">[3 more]</label></div><br/><div class="children"><div class="content">&gt; undefined behavior gives the compiler leeway in deciding what a program does, so the more undefined behavior a C program invokes, the easier it is to translate its code to rust.<p>You assume that the compiler can determine what behavior is undefined. It can&#x27;t. C compilers don&#x27;t just look at some individual line of the program and say &quot;oh, that&#x27;s undefined, unleash the nasal demons&quot;. C compilers look at code, reason that <i>if</i> such-and-such variable has a certain value (say, a null or invalid pointer), then such-and-such operation is undefined (say, dereferencing that variable), and <i>therefore</i> on the next line that variable can be assumed not to have that bad value. Despite all the FUD, this is a very limited power. C compilers don&#x27;t usually know the actual values in question, all they do is exclude some invalid ones.</div><br/><div id="41115029" class="c"><input type="checkbox" id="c-41115029" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114363">parent</a><span>|</span><a href="#41110845">next</a><span>|</span><label class="collapse" for="c-41115029">[-]</label><label class="expand" for="c-41115029">[2 more]</label></div><br/><div class="children"><div class="content">I (not the person you are replying to) do understand that&#x27;s how compilers interact with UB. However, a wealth of experience has shown us that the assumption &quot;UB doesn&#x27;t occur&quot; <i>is completely false</i>. It is, in my opinion, quite irresponsible for compiler writers to continue to use a known-false assumption when building the optimizer. I don&#x27;t really care how much speed it costs, we need to stop building software on a shaky foundation like that.</div><br/><div id="41115765" class="c"><input type="checkbox" id="c-41115765" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41115029">parent</a><span>|</span><a href="#41110845">next</a><span>|</span><label class="collapse" for="c-41115765">[-]</label><label class="expand" for="c-41115765">[1 more]</label></div><br/><div class="children"><div class="content">Soon (or actually, already) we&#x27;ll have MTE and CHERI, and then that C undefined behavior will be giving you security improvements as well as speed improvements.<p>Can&#x27;t design a system that 100% crashes on invalid behavior if you&#x27;ve declared that behavior is valid, because then someone is relying on it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41110845" class="c"><input type="checkbox" id="c-41110845" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41113429">prev</a><span>|</span><a href="#41113508">next</a><span>|</span><label class="collapse" for="c-41110845">[-]</label><label class="expand" for="c-41110845">[1 more]</label></div><br/><div class="children"><div class="content">Projects are termed DARPA-hard for a reason.</div><br/></div></div><div id="41113508" class="c"><input type="checkbox" id="c-41113508" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41110845">prev</a><span>|</span><a href="#41113036">next</a><span>|</span><label class="collapse" for="c-41113508">[-]</label><label class="expand" for="c-41113508">[3 more]</label></div><br/><div class="children"><div class="content">presumably dan wouldn&#x27;t have gotten darpa funding if it were obviously feasible, and success wouldn&#x27;t give him anything publishable academically</div><br/><div id="41114423" class="c"><input type="checkbox" id="c-41114423" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113508">parent</a><span>|</span><a href="#41113036">next</a><span>|</span><label class="collapse" for="c-41114423">[-]</label><label class="expand" for="c-41114423">[2 more]</label></div><br/><div class="children"><div class="content">Just to be clear to others, Dan is the darpa PM on this - he convinced darpa internally it was worth funding other people to do the work, so he himself &#x2F; his research group won&#x27;t be doing this work. He&#x27;s on leave from Rice for a few years to be a PM at DARPA&#x27;s I2O.<p>And while DARPA doesn&#x27;t directly care about research publications as an outcome, there&#x27;s certainly a publishable research component to this, as well as a lot of lower papers-per-$ engineering and validation work. A lot of the contracts they hand out end up going to some kind of contractor prime (BBN, Raytheon, that kind of company) with one or more academic subs. The academic subs publish.</div><br/><div id="41114614" class="c"><input type="checkbox" id="c-41114614" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114423">parent</a><span>|</span><a href="#41113036">next</a><span>|</span><label class="collapse" for="c-41114614">[-]</label><label class="expand" for="c-41114614">[1 more]</label></div><br/><div class="children"><div class="content">thank you for the correction; I didn&#x27;t realize he was the darpa pm<p>what you describe is exactly my experience as a darpa performer (on a program which dan is apparently now the pm for!)</div><br/></div></div></div></div></div></div><div id="41113036" class="c"><input type="checkbox" id="c-41113036" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41113508">prev</a><span>|</span><a href="#41111593">next</a><span>|</span><label class="collapse" for="c-41113036">[-]</label><label class="expand" for="c-41113036">[4 more]</label></div><br/><div class="children"><div class="content">Write tests for your C code. Run c2rust (mechanical translation), including the tests. Let a LLM&#x2F;MCTS&#x2F;verifier loop go to town. Verifier here means it passes compiler checks, tests, santiziers and miri.<p>Additional training data can be generated by running mrustc or by inlining unsafe code (from std&#x2F;core&#x2F;leaf crates) into safe code and running semantics-preserving mechanical refactorings on the code.<p>This can be closer to AlphaProof than ChatGPT</div><br/><div id="41115768" class="c"><input type="checkbox" id="c-41115768" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113036">parent</a><span>|</span><a href="#41116481">next</a><span>|</span><label class="collapse" for="c-41115768">[-]</label><label class="expand" for="c-41115768">[2 more]</label></div><br/><div class="children"><div class="content">You could already use ASAN + UBSan, or Frama-C.</div><br/><div id="41117275" class="c"><input type="checkbox" id="c-41117275" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41115768">parent</a><span>|</span><a href="#41116481">next</a><span>|</span><label class="collapse" for="c-41117275">[-]</label><label class="expand" for="c-41117275">[1 more]</label></div><br/><div class="children"><div class="content">I did mention using sanitizers in the verification step of the optimization loop. The optimization goal here would be reducing the lines of `unsafe` while preserving program semantics.</div><br/></div></div></div></div><div id="41116481" class="c"><input type="checkbox" id="c-41116481" checked=""/><div class="controls bullet"><span class="by">TestingWithEdd</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113036">parent</a><span>|</span><a href="#41115768">prev</a><span>|</span><a href="#41111593">next</a><span>|</span><label class="collapse" for="c-41116481">[-]</label><label class="expand" for="c-41116481">[1 more]</label></div><br/><div class="children"><div class="content">Essentially neural program synthesis</div><br/></div></div></div></div><div id="41111593" class="c"><input type="checkbox" id="c-41111593" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41113036">prev</a><span>|</span><a href="#41116200">next</a><span>|</span><label class="collapse" for="c-41111593">[-]</label><label class="expand" for="c-41111593">[2 more]</label></div><br/><div class="children"><div class="content">I have to think the approach will be something like &quot;AI summarizes the features of the program into some kind of technical language, then the AI synthesizes Rust code that covers the same feature set&quot;.<p>It would be most interesting if the approach was not to feed the program the original program but rather the manual for the program.  That said it&#x27;s rare that a manual captures all of the nuances of the program so a view into the source code is probably necessary, at least for getting the ground truth.</div><br/><div id="41111742" class="c"><input type="checkbox" id="c-41111742" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111593">parent</a><span>|</span><a href="#41116200">next</a><span>|</span><label class="collapse" for="c-41111742">[-]</label><label class="expand" for="c-41111742">[1 more]</label></div><br/><div class="children"><div class="content">More like:<p>&quot;AI more or less sort of summarizes the features of the program into some approximate kind of technical language, then the AI synthesizes something not too far from Rust code that hopefully covers aspirationally the same feature set&quot;.</div><br/></div></div></div></div><div id="41116200" class="c"><input type="checkbox" id="c-41116200" checked=""/><div class="controls bullet"><span class="by">elromulous</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41111593">prev</a><span>|</span><a href="#41110876">next</a><span>|</span><label class="collapse" for="c-41116200">[-]</label><label class="expand" for="c-41116200">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and most interesting code is written in C++ anyway.<p>You&#x27;re just asking for people to bring out their pitchforks :P</div><br/></div></div><div id="41110876" class="c"><input type="checkbox" id="c-41110876" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41116200">prev</a><span>|</span><a href="#41111773">next</a><span>|</span><label class="collapse" for="c-41110876">[-]</label><label class="expand" for="c-41110876">[3 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t most c++ be machine-lowered to C?</div><br/><div id="41110974" class="c"><input type="checkbox" id="c-41110974" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41110876">parent</a><span>|</span><a href="#41116844">next</a><span>|</span><label class="collapse" for="c-41110974">[-]</label><label class="expand" for="c-41110974">[1 more]</label></div><br/><div class="children"><div class="content"><i>Lowering</i> is typically easier than <i>lifting</i> (or brightening). When you lower, you can erase higher-level semantics that aren&#x27;t relevant; when you lift, you generally <i>want</i> to compose lower-level program behaviors into their idiomatic (and typically safer) equivalent.</div><br/></div></div><div id="41116844" class="c"><input type="checkbox" id="c-41116844" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41110876">parent</a><span>|</span><a href="#41110974">prev</a><span>|</span><a href="#41111773">next</a><span>|</span><label class="collapse" for="c-41116844">[-]</label><label class="expand" for="c-41116844">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that is after all how C++ started.<p>How good the resulting performance would be like, that is another matter.</div><br/></div></div></div></div><div id="41111773" class="c"><input type="checkbox" id="c-41111773" checked=""/><div class="controls bullet"><span class="by">downrightmike</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41110876">prev</a><span>|</span><a href="#41110923">next</a><span>|</span><label class="collapse" for="c-41111773">[-]</label><label class="expand" for="c-41111773">[3 more]</label></div><br/><div class="children"><div class="content">If the IRS could have more timely funding, all their Cobol would be translated to Java by now</div><br/><div id="41114407" class="c"><input type="checkbox" id="c-41114407" checked=""/><div class="controls bullet"><span class="by">psunavy03</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111773">parent</a><span>|</span><a href="#41110923">next</a><span>|</span><label class="collapse" for="c-41114407">[-]</label><label class="expand" for="c-41114407">[2 more]</label></div><br/><div class="children"><div class="content">COBOL migrations are tar pits of replicating 40+ years of undocumented niche business logic for a given field, edge cases included, that was &quot;commonly understood&quot; by people who are now retired or dead.  Don&#x27;t get your hopes up.</div><br/><div id="41116855" class="c"><input type="checkbox" id="c-41116855" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41114407">parent</a><span>|</span><a href="#41110923">next</a><span>|</span><label class="collapse" for="c-41116855">[-]</label><label class="expand" for="c-41116855">[1 more]</label></div><br/><div class="children"><div class="content">MicroFocus has COBOL compilers for Java and .NET, as do other COBOL vendors still in business.<p>Usually the biggest issue, is that most of the porting attempts don&#x27;t start there, rather they go for the rewritte from scratch, and lets not pay the licenses for those cross-compilers.</div><br/></div></div></div></div></div></div><div id="41110923" class="c"><input type="checkbox" id="c-41110923" checked=""/><div class="controls bullet"><span class="by">childintime</span><span>|</span><a href="#41110693">parent</a><span>|</span><a href="#41111773">prev</a><span>|</span><a href="#41112200">next</a><span>|</span><label class="collapse" for="c-41110923">[-]</label><label class="expand" for="c-41110923">[26 more]</label></div><br/><div class="children"><div class="content">Hard for humans. But it&#x27;s DARPA, is it hard for AI? Image classification used to be hard also, today cars drive themselves.<p>I&#x27;d say it&#x27;s good timing.</div><br/><div id="41111091" class="c"><input type="checkbox" id="c-41111091" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41110923">parent</a><span>|</span><a href="#41111030">next</a><span>|</span><label class="collapse" for="c-41111091">[-]</label><label class="expand" for="c-41111091">[14 more]</label></div><br/><div class="children"><div class="content">&gt; today cars drive themselves<p>You can attach about a hundred asterisks to that.<p>If anything, I think self the failure to hit L5 driving after billions of dollars and millions of man hours invested is probably reflective of how automatic C to Rust translation will go. We&#x27;ll cruise 90% of the way, but the last 10% will prove insurmountable with current technology.<p>Think about the number of C programs in the wild that rely on compiler-specific or libc-specific or platform-specific behavior, or even undefined behavior plus the dumb luck of a certain brittle combination of {compiler version} ∩ {libc version} ∩ {linker version} ∩ {build flags} emitting workable machine code. There&#x27;s a huge chunk of C software where there&#x27;s not enough context within the source itself (or even source plus build scripts) to understand the behavior. It&#x27;s not even clear that this is a solvable problem in the abstract.<p>None of that is to say that DARPA shouldn&#x27;t fund this. Research isn&#x27;t always about finding an industrial strength end product; the knowledge and expertise gained along the way is important too.</div><br/><div id="41113682" class="c"><input type="checkbox" id="c-41113682" checked=""/><div class="controls bullet"><span class="by">sqeaky</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111091">parent</a><span>|</span><a href="#41111474">next</a><span>|</span><label class="collapse" for="c-41113682">[-]</label><label class="expand" for="c-41113682">[3 more]</label></div><br/><div class="children"><div class="content">This is the exact formulation of the argument before computers beat humans at chess, or drew pictures, or represented color correctly, or... Self driving cars will be solved. There is at least one general purpose computer that can solve it already (a human brain), so of a purpose built computer can also be made to solve it.<p>In 10 (or 2 or 50 or X) years when Chevy, Ford, and others are rolling out cheap self driving this argument stops working. The important thing is that this argument stops working with no change in how hard C to Rust conversion is.<p>We really should be looking at the specifics of both problems. What makes computer language translation hard? Why is driving hard? One needs to be correct while inferring intent and possibly reformulating code to meet new restrictions. The other needs to be able to make snap judgments and in realtime avoid hitting things even if it just means stopping to prefer safety over motion. One problem can be solved piecewise without significant regard to time and the other solved in realtime as it happens without producing unsafe output.<p>These problems really aren&#x27;t analogous.<p>I think you picked self driving cars just because it is a big and only partially solved problem. One could just as easily pick a big solved problem or a big unstarted problem and formulate equally bad arguments.<p>I am not saying this problem is easy, just that it seems solvable with sufficient effort.</div><br/><div id="41114078" class="c"><input type="checkbox" id="c-41114078" checked=""/><div class="controls bullet"><span class="by">mywittyname</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113682">parent</a><span>|</span><a href="#41115708">next</a><span>|</span><label class="collapse" for="c-41114078">[-]</label><label class="expand" for="c-41114078">[1 more]</label></div><br/><div class="children"><div class="content">&gt; These problems really aren&#x27;t analogous.<p>I&#x27;d put money on the solutions to said problems looking largely the same though - big ass machine learning models.<p>My prediction is that a tool like copilot (but specialized to this domain) will do the bulk of source code conversions, with a really smart human coming behind to validate.</div><br/></div></div><div id="41115708" class="c"><input type="checkbox" id="c-41115708" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113682">parent</a><span>|</span><a href="#41114078">prev</a><span>|</span><a href="#41111474">next</a><span>|</span><label class="collapse" for="c-41115708">[-]</label><label class="expand" for="c-41115708">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is the exact formulation of the argument before computers beat humans at chess, or drew pictures, or represented color correctly, or...<p>Which are things that took 20 or 50 years longer than expected in some cases.<p>&gt; I think you picked self driving cars just because it is a big and only partially solved problem. One could just as easily pick a big solved problem or a big unstarted problem and formulate equally bad arguments.<p>But C to Rust translation <i>is</i> a big and only partially solved problem.</div><br/></div></div></div></div><div id="41111474" class="c"><input type="checkbox" id="c-41111474" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111091">parent</a><span>|</span><a href="#41113682">prev</a><span>|</span><a href="#41111826">next</a><span>|</span><label class="collapse" for="c-41111474">[-]</label><label class="expand" for="c-41111474">[2 more]</label></div><br/><div class="children"><div class="content">Ok, but if it&#x27;s like 90% of small projects can use it as direct no pain bridge, that can be a huge win.<p>Even if it&#x27;s &quot;can handle well 90%&quot; of the transition for any project, this is still interesting. Unlike cars on the road, most code transition project out there doesn&#x27;t need to be 100% fine to provide some useful value.</div><br/><div id="41112133" class="c"><input type="checkbox" id="c-41112133" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111474">parent</a><span>|</span><a href="#41111826">next</a><span>|</span><label class="collapse" for="c-41112133">[-]</label><label class="expand" for="c-41112133">[1 more]</label></div><br/><div class="children"><div class="content">Even if every project can only be 90% done, that’s a huge win. Best would be if it could just wrap the C equivalent code into an unsafe block which would be automatically triaged for human review.<p>Just getting something vaguely Rust shaped which can compile is the first step in overcoming the inertia to leave the program in its current language.</div><br/></div></div></div></div><div id="41111826" class="c"><input type="checkbox" id="c-41111826" checked=""/><div class="controls bullet"><span class="by">D-Coder</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111091">parent</a><span>|</span><a href="#41111474">prev</a><span>|</span><a href="#41111565">next</a><span>|</span><label class="collapse" for="c-41111826">[-]</label><label class="expand" for="c-41111826">[1 more]</label></div><br/><div class="children"><div class="content">In addition to the other replies, this is a one-time project. After everything (or almost everything) has been translated, you&#x27;re done, you won&#x27;t be running into new edge cases.</div><br/></div></div><div id="41111565" class="c"><input type="checkbox" id="c-41111565" checked=""/><div class="controls bullet"><span class="by">programd</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111091">parent</a><span>|</span><a href="#41111826">prev</a><span>|</span><a href="#41111030">next</a><span>|</span><label class="collapse" for="c-41111565">[-]</label><label class="expand" for="c-41111565">[7 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; today cars drive themselves<p>&gt; You can attach about a hundred asterisks to that.<p>Not in San Francisco. There are about 300 Waymo cars safely driving in one of the most difficult urban environments around (think steep hills, fog, construction, crazy traffic, crazy drivers, crazier pedestrians). Five years ago this was &quot;someday&quot; science-fiction. Frankly I trust them much more then human drivers and envision a future utopia where human drivers are banned from urban centers.<p>To get back on topic, I don&#x27;t think automatic programming language translation is nearly as hard, especially since we have a deterministic model of the machines it runs on. I can see a possible approach where AI systems take the assembler code of a C++ program, then translate that into Rust, or anything else. Can they get 100% accuracy and bit-for-bit compatibility on output? I would not bet against it.</div><br/><div id="41113542" class="c"><input type="checkbox" id="c-41113542" checked=""/><div class="controls bullet"><span class="by">creata</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111565">parent</a><span>|</span><a href="#41116498">next</a><span>|</span><label class="collapse" for="c-41113542">[-]</label><label class="expand" for="c-41113542">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t 100% accuracy (relatively) easy?  c2rust already does that, or at least comes close, as far as I know.<p>Getting identical outputs on safe executions, catching any unsafe behavior (at translation-time or run-time), and producing efficient, maintainable code all at once is a million times harder.</div><br/></div></div><div id="41116498" class="c"><input type="checkbox" id="c-41116498" checked=""/><div class="controls bullet"><span class="by">TestingWithEdd</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111565">parent</a><span>|</span><a href="#41113542">prev</a><span>|</span><a href="#41113564">next</a><span>|</span><label class="collapse" for="c-41116498">[-]</label><label class="expand" for="c-41116498">[1 more]</label></div><br/><div class="children"><div class="content">Limited to specific areas during specific hours, and have caused crashes (at least when I lived there till last summer).</div><br/></div></div><div id="41113564" class="c"><input type="checkbox" id="c-41113564" checked=""/><div class="controls bullet"><span class="by">m0llusk</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111565">parent</a><span>|</span><a href="#41116498">prev</a><span>|</span><a href="#41114173">next</a><span>|</span><label class="collapse" for="c-41113564">[-]</label><label class="expand" for="c-41113564">[3 more]</label></div><br/><div class="children"><div class="content">Opinions about automated driving systems vary. Just from my own experience doing business all around San Francisco I have seen at least a half dozen instances of Waymo vehicles making unsafe maneuvers. Responders have told me and local government officials that Waymo vehicles frequently fail to acknowledge emergency situations or respond to driving instructions. Driving is a social exercise which requires understanding of a number of abstractions.</div><br/><div id="41116440" class="c"><input type="checkbox" id="c-41116440" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113564">parent</a><span>|</span><a href="#41114173">next</a><span>|</span><label class="collapse" for="c-41116440">[-]</label><label class="expand" for="c-41116440">[2 more]</label></div><br/><div class="children"><div class="content">they&#x27;re not perfect, sure, but they&#x27;re out there, just driving around all autonomously and all, contrary to GGP&#x27;s assertion that they don&#x27;t exist.</div><br/><div id="41116658" class="c"><input type="checkbox" id="c-41116658" checked=""/><div class="controls bullet"><span class="by">cuu508</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41116440">parent</a><span>|</span><a href="#41114173">next</a><span>|</span><label class="collapse" for="c-41116658">[-]</label><label class="expand" for="c-41116658">[1 more]</label></div><br/><div class="children"><div class="content">GGGP talked about L5 self-driving, isn&#x27;t Waymo L4?</div><br/></div></div></div></div></div></div><div id="41114173" class="c"><input type="checkbox" id="c-41114173" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111565">parent</a><span>|</span><a href="#41113564">prev</a><span>|</span><a href="#41111030">next</a><span>|</span><label class="collapse" for="c-41114173">[-]</label><label class="expand" for="c-41114173">[1 more]</label></div><br/><div class="children"><div class="content">San Francisco, for all its challenges, mostly has traffic laws that people follow. This is not true throughout the world.</div><br/></div></div></div></div></div></div><div id="41111030" class="c"><input type="checkbox" id="c-41111030" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41110923">parent</a><span>|</span><a href="#41111091">prev</a><span>|</span><a href="#41111808">next</a><span>|</span><label class="collapse" for="c-41111030">[-]</label><label class="expand" for="c-41111030">[10 more]</label></div><br/><div class="children"><div class="content">Well, Claude 3.5 can do translation from one language to another in a fairly competent manner if the languages are close enough. I&#x27;ve used it for that task myself with success (Java -&gt; JavaScript).<p>But, this isn&#x27;t just about rewriting code from one language to another. It&#x27;s about reverse engineering complex information out of the code, which may not be immediately visible in it, and then finding a way to make it &quot;safe&quot; according to Rust&#x27;s type system. Where&#x27;s the training data for that? It&#x27;d be really hard even for skilled humans.<p>Personally I think the most pragmatic way to make C&#x2F;C++ memory safe quicker is one of two approaches:<p>1. Incrementally. Make std::vector[] properly bounds checked (still not done even in chrome!), convert allocations to allocations that know their own size and do bounds checking e.g. <a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40285824" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40285824</a><p>2. Or, go the whole hog and use runtime techniques like garbage collection and runtime bounds checks.<p>A good example of approach (2) is Managed Sulong, which extends the JVM to execute LLVM bitcode directly whilst exposing to the C&#x2F;C++&#x2F;FORTRAN a virtualized Linux syscall interface. The whole piece of code can be sandboxed with permissions, and memory safety errors are caught at runtime. The compiler tries to optimize out as many bounds checks as possible. The interesting thing about this approach is it doesn&#x27;t require big changes to the source code (as long as it&#x27;s already been ported to Linux), which means the work of making something safe can be done by teams independent of the original authors. In practice &quot;rewrite it in Rust&quot; will usually mean a fork, which introduces lots of complicated technical, cultural and economic issues.<p>Managed Sulong is also a research project and has a bunch of problems to solve, for instance it needs to lose the JITC dependency and go fully AOT compiled (doable, there&#x27;s no theoretical issue with it and much of the needed infra already exists). And performance&#x2F;memory usage can always be improved of course, it regresses vs the original C. But those are &quot;just&quot; systems engineering problems, not rewrite-the-world and solve-static-analysis problems.<p>Disclosure: I do work part time at Oracle Labs which developed Managed Sulong, but I don&#x27;t work on it.</div><br/><div id="41113805" class="c"><input type="checkbox" id="c-41113805" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111030">parent</a><span>|</span><a href="#41116866">next</a><span>|</span><label class="collapse" for="c-41113805">[-]</label><label class="expand" for="c-41113805">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But, this isn&#x27;t just about rewriting code from one language to another. It&#x27;s about reverse engineering complex information out of the code, which may not be immediately visible in it, and then finding a way to make it &quot;safe&quot; according to Rust&#x27;s type system. Where&#x27;s the training data for that? It&#x27;d be really hard even for skilled humans.<p>That might not be too bad.<p>A combination of a formal system and an LLM might work here. Suppose we see a C function<p><pre><code>   void somefn(char* buf, int n);
</code></pre>
First question: is &quot;buf&quot; a pointer to an array, or a pointer to a single char? That can be answered by looking at what the function does with &quot;buf&quot;, and what callers pass to it.<p>If it&#x27;s an array, how big is it? We don&#x27;t have enough info to know that yet. But a reasonable guess, and one than an LLM might make, is that the length of buf is &quot;n&quot;.<p>Following that assumption, it&#x27;s reasonable to translate this to Rust as<p><pre><code>   fn somefn(buf: &amp;[u8])
</code></pre>
and, if n is needed within the function, use<p><pre><code>   buf.len()
</code></pre>
The next step is to validate that guess. The run-time approach is to write all calls to &quot;somefn&quot; with<p><pre><code>   assert!(buf.len() == n);
   somefn(buf, n);
</code></pre>
Maybe formal methods can prove the assert true, and we can take it out. Or if a SAT solver or a fuzz tester
can generate a counterexample, we know that the guess was wrong and this has to be done the hard way, as<p><pre><code>   fn somefn(buf: &amp;[u8], int n)
</code></pre>
implying more subscript checks inside &quot;somefn&quot;.<p>The idea is to recognize common C idioms and do clean translations to Rust for them. This should handle a high percentage of cases.</div><br/><div id="41117199" class="c"><input type="checkbox" id="c-41117199" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41113805">parent</a><span>|</span><a href="#41116866">next</a><span>|</span><label class="collapse" for="c-41117199">[-]</label><label class="expand" for="c-41117199">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is similar to what IntelliJ does for Java-&gt;Kotlin. Do a first pass that&#x27;s extremely non-idiomatic and mechanical, then do lots of automated refactoring to bring it closer to idiomatic.<p>But if you&#x27;re going to do it that way, the right place to start is probably to a safer form of C++ not Rust. That way code can be ported file-at-a-time or even function-at-a-time, and so you&#x27;ll have a chance to run the assertions in the context of the original code. Which of course may not have good test coverage, as C codebases often don&#x27;t, so you&#x27;ll have to be testing your assertions in production.</div><br/></div></div></div></div><div id="41116866" class="c"><input type="checkbox" id="c-41116866" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111030">parent</a><span>|</span><a href="#41113805">prev</a><span>|</span><a href="#41111088">next</a><span>|</span><label class="collapse" for="c-41116866">[-]</label><label class="expand" for="c-41116866">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Make std::vector[] properly bounds checked<p>Most compilers do have flags to turn this on, which I use all the time.<p>The issue is the <i>&quot;performance trumps safety&quot;</i> culture that pushes back against using them.</div><br/></div></div><div id="41111088" class="c"><input type="checkbox" id="c-41111088" checked=""/><div class="controls bullet"><span class="by">TinkersW</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111030">parent</a><span>|</span><a href="#41116866">prev</a><span>|</span><a href="#41111808">next</a><span>|</span><label class="collapse" for="c-41111088">[-]</label><label class="expand" for="c-41111088">[6 more]</label></div><br/><div class="children"><div class="content">std::vector [] has had bounds checking since forever if you set the correct compiler flag. Since they aren&#x27;t using it this is a choice, presumably they prefer the speed gain.</div><br/><div id="41111167" class="c"><input type="checkbox" id="c-41111167" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111088">parent</a><span>|</span><a href="#41111293">next</a><span>|</span><label class="collapse" for="c-41111167">[-]</label><label class="expand" for="c-41111167">[3 more]</label></div><br/><div class="children"><div class="content">You mean _GLIBCXX_DEBUG? It&#x27;s got some issues. Linux only, it doesn&#x27;t always work [1] and it&#x27;s all or nothing. What&#x27;s really needed is the ability to selectively opt-out on a per-instantiation level so very hot paths can keep the needed performance whilst all the rest gets opted into safety checks.<p>Microsoft has this:<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;standard-library&#x2F;safe-libraries-cpp-standard-library?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;standard-library&#x2F;safe-...</a><p>but it doesn&#x27;t seem to actually make std::vector[] safe.<p>It&#x27;s frustrating that low hanging fruit like this doesn&#x27;t get harvested.<p>[1] &quot;although there are precondition checks for some string operations, e.g. operator[], they will not always be run when using the char and wchar_t specializations (std::string and std::wstring).&quot;</div><br/><div id="41115471" class="c"><input type="checkbox" id="c-41115471" checked=""/><div class="controls bullet"><span class="by">TinkersW</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111167">parent</a><span>|</span><a href="#41111293">next</a><span>|</span><label class="collapse" for="c-41115471">[-]</label><label class="expand" for="c-41115471">[2 more]</label></div><br/><div class="children"><div class="content">With MSVC you can use _CONTAINER_DEBUG_LEVEL=1 to get a fast bounds check that can be used in release builds. Or just use it in development to catch errors.</div><br/><div id="41117205" class="c"><input type="checkbox" id="c-41117205" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41115471">parent</a><span>|</span><a href="#41111293">next</a><span>|</span><label class="collapse" for="c-41117205">[-]</label><label class="expand" for="c-41117205">[1 more]</label></div><br/><div class="children"><div class="content">Interesting thanks. Seems the reason I couldn&#x27;t find anything on that is because it&#x27;s internal only and not a feature you&#x27;re actually meant to use?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;STL&#x2F;issues&#x2F;586">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;STL&#x2F;issues&#x2F;586</a><p><i>&gt; We talked about this at the weekly maintainer meeting and decided that we&#x27;re not comfortable enough with the (lack of) design of this feature to begin documenting it for wide usage.</i></div><br/></div></div></div></div></div></div><div id="41111293" class="c"><input type="checkbox" id="c-41111293" checked=""/><div class="controls bullet"><span class="by">Calavar</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111088">parent</a><span>|</span><a href="#41111167">prev</a><span>|</span><a href="#41111808">next</a><span>|</span><label class="collapse" for="c-41111293">[-]</label><label class="expand" for="c-41111293">[2 more]</label></div><br/><div class="children"><div class="content">As far as I am aware, the standard doesn&#x27;t mandate bounds checking for std::vector::operator[] and probably never will for backwards compatibility reasons. Most standard library implementations have opt-out std::vector[] bounds checking in unoptimized builds, but not in optimized builds.<p>I tried a toy example with GCC [1], Clang [2], and MSVC  [3], and none of them emit bounds checks with basic optimization flags.<p>[1] <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;W5e3n5oWM" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;W5e3n5oWM</a><p>[2] <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;Pe8nPPvEd" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;Pe8nPPvEd</a><p>[3] <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;YTdv3nabn" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;YTdv3nabn</a></div><br/><div id="41115482" class="c"><input type="checkbox" id="c-41115482" checked=""/><div class="controls bullet"><span class="by">TinkersW</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41111293">parent</a><span>|</span><a href="#41111808">next</a><span>|</span><label class="collapse" for="c-41115482">[-]</label><label class="expand" for="c-41115482">[1 more]</label></div><br/><div class="children"><div class="content">As I said you need the correct flag set.. MSVC use _CONTAINER_DEBUG_LEVEL=1 and it can be used in release. They have had this feature since 2010 or so, though the flag name has changed.</div><br/></div></div></div></div></div></div></div></div><div id="41111808" class="c"><input type="checkbox" id="c-41111808" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#41110693">root</a><span>|</span><a href="#41110923">parent</a><span>|</span><a href="#41111030">prev</a><span>|</span><a href="#41112200">next</a><span>|</span><label class="collapse" for="c-41111808">[-]</label><label class="expand" for="c-41111808">[1 more]</label></div><br/><div class="children"><div class="content">As a reminder, DARPA funded self-driving car research since at least the 1980s with the Autonomous Land driven Vehicle (ALV) project, plus the DARPA Grand Challenges, and more.</div><br/></div></div></div></div></div></div><div id="41112200" class="c"><input type="checkbox" id="c-41112200" checked=""/><div class="controls bullet"><span class="by">sans-seraph</span><span>|</span><a href="#41110693">prev</a><span>|</span><a href="#41110871">next</a><span>|</span><label class="collapse" for="c-41112200">[-]</label><label class="expand" for="c-41112200">[4 more]</label></div><br/><div class="children"><div class="content">I have been aware of this proposed initiative for some time and I find it interesting that it is now becoming public. It is a very ambitious proposal and I agree that this level of ambition is appropriate for DARPA&#x27;s mission and I wish them well.<p>As a Rust advocate in this domain I have attempted to temper the expectations of those driving this proposal with due respect to the feasibility of automatic translation from C to Rust. The fundamental obstacle that I foresee remains that C source code contains less information than Rust source code. In order to translate C code to Rust code that missing information must be produced by someone or something. It is easy to prove that it is impossible to infallibly generate this missing information for the same reason that scaling an image to make it larger cannot infallibly produce bits of information that were not captured by the original image. Instead we must extrapolate (invent) the missing information from the existing source code. To extrapolate correctly we must exercise judgement and this is a fallible process especially when exercised in large quantities by unsupervised language models. I have proposed solutions that I believe would go some way towards addressing these problems but I will decline to go into detail.<p>Ultimately I will say that I believe that it is possible for this project to achieve a measure of success, although it must be undertaken with caution and with measured expectations. At the same time it should be emphasized it is also possible that no public result will come of this project and so I caution those here against reading too much into this at this time. In particular I would remind everyone that the government is not a singular entity and so I would not interpret this project as a blanket denouncement against C or vice versa as a blanket blessing of Rust. Each agency will set its own direction and timelines for the adoption of memory-safe technologies. For example NIST recommends Rust as well as Ada SPARK in addition to various hardened dialects of C&#x2F;C++.</div><br/><div id="41117400" class="c"><input type="checkbox" id="c-41117400" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#41112200">parent</a><span>|</span><a href="#41112251">next</a><span>|</span><label class="collapse" for="c-41117400">[-]</label><label class="expand" for="c-41117400">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In order to translate C code to Rust code that missing information must be produced by someone or something.<p>If you don&#x27;t go for preserving the formal semantics of C code and instead only require the test-suite to still pass after translation that can provide a lot of wiggle room for the translation. This is how oxidation projects often work in practice.
Fuzzers can also help with generating additional test data to get good branch coverage.</div><br/></div></div><div id="41112251" class="c"><input type="checkbox" id="c-41112251" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41112200">parent</a><span>|</span><a href="#41117400">prev</a><span>|</span><a href="#41113927">next</a><span>|</span><label class="collapse" for="c-41112251">[-]</label><label class="expand" for="c-41112251">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As a Rust advocate in this domain I have attempted to temper the expectations of those driving this proposal<p>Thank you!</div><br/></div></div><div id="41113927" class="c"><input type="checkbox" id="c-41113927" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#41112200">parent</a><span>|</span><a href="#41112251">prev</a><span>|</span><a href="#41110871">next</a><span>|</span><label class="collapse" for="c-41113927">[-]</label><label class="expand" for="c-41113927">[1 more]</label></div><br/><div class="children"><div class="content">How does it relate to the CRAM effort at Grammatech?<p><a href="https:&#x2F;&#x2F;cpp-rust-assisted-migration.gitlab.io&#x2F;blog&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cpp-rust-assisted-migration.gitlab.io&#x2F;blog&#x2F;</a></div><br/></div></div></div></div><div id="41110871" class="c"><input type="checkbox" id="c-41110871" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41112200">prev</a><span>|</span><a href="#41111128">next</a><span>|</span><label class="collapse" for="c-41110871">[-]</label><label class="expand" for="c-41110871">[31 more]</label></div><br/><div class="children"><div class="content">I&#x27;m personally not a fan of &quot;rewrite the world in Rust&quot; mentality, but that being said, if one is planning to port a project to a new language or platform, mechanical translation is a poor means of doing so. Spend the time planning better architecture and designing a better software system, and find a way to replace it piece by piece. Don&#x27;t build a castle in the sky, because it will never reach the ground. If you&#x27;ve decided to use Rust for this system, that&#x27;s fine. But, write Rust. Don&#x27;t try to back-port C into Rust.<p>I think a far better and more mature process is to update C to modern C and use a model checker such as CBMC to verify memory, resource, and integer math safety. One gets the same safety as a gradual Rust rewrite, but the code base, knowledge base, and developers can be maintained.</div><br/><div id="41116874" class="c"><input type="checkbox" id="c-41116874" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41110871">parent</a><span>|</span><a href="#41113096">next</a><span>|</span><label class="collapse" for="c-41116874">[-]</label><label class="expand" for="c-41116874">[3 more]</label></div><br/><div class="children"><div class="content">Modern C still has the same security exploits in arrays and strings as Classical C, nothing changed in 50 years.</div><br/><div id="41117324" class="c"><input type="checkbox" id="c-41117324" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41116874">parent</a><span>|</span><a href="#41113096">next</a><span>|</span><label class="collapse" for="c-41117324">[-]</label><label class="expand" for="c-41117324">[2 more]</label></div><br/><div class="children"><div class="content">The programmers have changed, the machines have changed, the literature has changed, the compilers have changed a lot. You can still write and run the old insecure code, but you&#x27;ll get warnings and hit stack canaries and your colleagues will gasp at you and your merge requests will be rejected.</div><br/><div id="41117481" class="c"><input type="checkbox" id="c-41117481" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41117324">parent</a><span>|</span><a href="#41113096">next</a><span>|</span><label class="collapse" for="c-41117481">[-]</label><label class="expand" for="c-41117481">[1 more]</label></div><br/><div class="children"><div class="content">Meaningless changes, as proven by the CVE database, or the kernel corruption by a bad pointer caused by Crowdstrike.</div><br/></div></div></div></div></div></div><div id="41113096" class="c"><input type="checkbox" id="c-41113096" checked=""/><div class="controls bullet"><span class="by">Apofis</span><span>|</span><a href="#41110871">parent</a><span>|</span><a href="#41116874">prev</a><span>|</span><a href="#41111027">next</a><span>|</span><label class="collapse" for="c-41113096">[-]</label><label class="expand" for="c-41113096">[1 more]</label></div><br/><div class="children"><div class="content">This is definitely a pie-in-the-sky DARPA challenge that would be great to have around as we migrate away from legacy systems, however, even taking your functions&#x2F;methods in one language and giving them to ChatGPT and asking it to translate your method to a different language generally doesn&#x27;t work. Asking ChatGPT the initial problem you&#x27;re trying to solve, works more frequently, but still generally doesn&#x27;t work. You still need to do a lot of tinkering and thinking to get even basic things to work that it outputs.</div><br/></div></div><div id="41111027" class="c"><input type="checkbox" id="c-41111027" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41110871">parent</a><span>|</span><a href="#41113096">prev</a><span>|</span><a href="#41113387">next</a><span>|</span><label class="collapse" for="c-41111027">[-]</label><label class="expand" for="c-41111027">[6 more]</label></div><br/><div class="children"><div class="content">&gt; I think a far better and more mature process is to update C to modern C and use a model checker such as CBMC to verify memory, resource, and integer math safety.<p>No chance. CBMC is amazing, but have you actually tried formally verifying a &quot;real&quot; program?<p>I agree replacing with a hand-architected Rust version is clearly the better solution but also more expensive. I think they&#x27;re going for an RLBox style &quot;improve security significantly with little-to-no effort&quot; type product here. That doesn&#x27;t mean you shouldn&#x27;t do a full manual rewrite if you have the resources, but it&#x27;s better than nothing if you haven&#x27;t.</div><br/><div id="41113491" class="c"><input type="checkbox" id="c-41113491" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41111027">parent</a><span>|</span><a href="#41113387">next</a><span>|</span><label class="collapse" for="c-41113491">[-]</label><label class="expand" for="c-41113491">[5 more]</label></div><br/><div class="children"><div class="content">&gt; No chance. CBMC is amazing, but have you actually tried formally verifying a &quot;real&quot; program?<p>Yes. Every day. It&#x27;s actually quite easy to do. Write shadow methods covering the resources and function contracts of called functions, then verify the function. Repeat all of the way up and down the stack. It adds about 30% overhead over just TDD development.</div><br/><div id="41114007" class="c"><input type="checkbox" id="c-41114007" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41113491">parent</a><span>|</span><a href="#41113387">next</a><span>|</span><label class="collapse" for="c-41114007">[-]</label><label class="expand" for="c-41114007">[4 more]</label></div><br/><div class="children"><div class="content">Last time I tried CBMC, it ended up running out of memory for relatively small programs, do you encounter any resource usage issues with it? I&#x27;m learning Frama-C and I find it more predictable, although the non-determinism of solvers shocked me when I first tried to prove non-trivial programs. I guess ideally I would like something even more explicit than Frama-C.</div><br/><div id="41114126" class="c"><input type="checkbox" id="c-41114126" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41114007">parent</a><span>|</span><a href="#41113387">next</a><span>|</span><label class="collapse" for="c-41114126">[-]</label><label class="expand" for="c-41114126">[3 more]</label></div><br/><div class="children"><div class="content">CBMC works best on functions, not programs. You want to isolate an individual function, then provide shadows of the functions it calls. The shadows should have nondeterministic behavior (cover every possible error condition) and otherwise follow the same memory and resource rules as the original function. For instance, if shadowing a function that reads a buffer, the shadow should ensure full buffer access as part of its assertions.<p>The biggest issue you will run into with bounded model checking is recursion and looping. In these cases, you want to refactor the code to make it easier to formally verify outside of the loop. Capture and assert on loop variants &#x2F; invariants, and feed these forward in assertions on code.<p>There&#x27;s no way I can capture all of this in an HN comment, but to get CBMC to work, you need to break down your code.</div><br/><div id="41114197" class="c"><input type="checkbox" id="c-41114197" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41114126">parent</a><span>|</span><a href="#41113387">next</a><span>|</span><label class="collapse" for="c-41114197">[-]</label><label class="expand" for="c-41114197">[2 more]</label></div><br/><div class="children"><div class="content">Thanks, that was really helpful. Relying on getting shadow functions right does seem icky, but I guess the improved productivity of CBMC should make up for it. Definitely going to give it another chance!</div><br/><div id="41114285" class="c"><input type="checkbox" id="c-41114285" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41114197">parent</a><span>|</span><a href="#41113387">next</a><span>|</span><label class="collapse" for="c-41114285">[-]</label><label class="expand" for="c-41114285">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re welcome. I&#x27;ve been meaning to write a blog article on the subject, because it is a subtle thing to get working.<p>Think of shadow functions as the specifications that you are building. Unlike proof assistants or Frama-C, you write specifications in C itself, and they work similarly to code. Often, the same contracts you write in these specifications can be shared by both the shadow functions and the real functions they shadow.<p>I take a bottom-up approach to model checking. I&#x27;ll start by model checking the lowest level code, then I&#x27;ll shadow this code to model check code that depends on it. In this way, I can increase the level of abstraction for model checking, focusing just on the side effects and contracts of functions I shadow, and move up the stack toward more and more general code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41113387" class="c"><input type="checkbox" id="c-41113387" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#41110871">parent</a><span>|</span><a href="#41111027">prev</a><span>|</span><a href="#41110997">next</a><span>|</span><label class="collapse" for="c-41113387">[-]</label><label class="expand" for="c-41113387">[3 more]</label></div><br/><div class="children"><div class="content"><i>If</i> you have dormant code, as in running everywhere but not getting worked on anywhere, a &quot;translate to shitty rust before ever touching again&quot; has a certain appeal. Not the appeal of an obviously good idea: chances are the &quot;shitty rust&quot; created through translation would be so much worse to work on than C with some level of background noise of bugs (that would also be present in the &quot;shitty rust&quot; thanks to faithful translation). In C, people have an idea about how to deal with the problems. In &quot;shitty rust&quot;, it&#x27;s, well, shitty, because rust people are not used to that stuff.<p>But there&#x27;s a non-zero chance that someone could develop a skillset for iteratively cleaning up into something tolerable.<p>And then there are non-goal things that could grow out of the project, e.g. some form of linter feedback &quot;can&#x27;t translate into tolerable rust because of x, y and z&quot;. C people could look into that, and once the code is translatable into good rust, why translate.<p><i>If</i> that was an outcome of the project, some people might find it easier to describe their solution in runnable C and let the &quot;translator&#x2F;linter&quot; guide them to a non-broken approach.<p>I&#x27;d certainly consider all these positive outcomes quite unlikely, but isn&#x27;t it pretty much the job description of DARPA to do the occasional dark horse bet?</div><br/><div id="41114432" class="c"><input type="checkbox" id="c-41114432" checked=""/><div class="controls bullet"><span class="by">suprjami</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41113387">parent</a><span>|</span><a href="#41110997">next</a><span>|</span><label class="collapse" for="c-41114432">[-]</label><label class="expand" for="c-41114432">[2 more]</label></div><br/><div class="children"><div class="content">In my experience (supporting a machine-translated codebase which resulted in shitty Java) your theory doesn&#x27;t play out.<p>If you give developers a shitty codebase then those developers will leave to work somewhere else.<p>After a few years of working on this codebase we had 88% turnover. 1 in 10 developers remembered the original project&#x27;s design philosophy and intention.<p>It wasn&#x27;t a good situation.</div><br/><div id="41115112" class="c"><input type="checkbox" id="c-41115112" checked=""/><div class="controls bullet"><span class="by">dcsommer</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41114432">parent</a><span>|</span><a href="#41110997">next</a><span>|</span><label class="collapse" for="c-41115112">[-]</label><label class="expand" for="c-41115112">[1 more]</label></div><br/><div class="children"><div class="content">GP was proposing a different situation where the source code is not changing or changing very rarely. If you have a high churn codebase, obviously the maintenance experience will worsen dramatically after machine translation (at least with many current tools), so your experience is not unexpected.</div><br/></div></div></div></div></div></div><div id="41110997" class="c"><input type="checkbox" id="c-41110997" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41110871">parent</a><span>|</span><a href="#41113387">prev</a><span>|</span><a href="#41111128">next</a><span>|</span><label class="collapse" for="c-41110997">[-]</label><label class="expand" for="c-41110997">[17 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I&#x27;m personally not a fan of &quot;rewrite the world in Rust&quot; mentality</i><p>There is no such mentality anywhere. There is a ton of software that&#x27;s much better off left alone in a dynamic language, or a statically typed language with a garbage collector (like Golang). Good engineers understand the idea of using the right tool for the job.<p>The push is to start reducing those memory safety CVEs because they have been proven to be a real problem, many times over.<p>&gt; <i>mechanical translation is a poor means of doing so</i><p>Agreed. If we could automatically and reliably translate C&#x2F;C++ to Rust it would have been done already.<p>&gt; <i>Spend the time planning better architecture and designing a better software system, and find a way to replace it piece by piece.</i><p>OK, I am just saying that somewhere along that process people might get a bout of confidence and tell themselves &quot;oh, we&#x27;re doing C much better now, we no longer write memory safety bugs, can&#x27;t we stop here?&quot; and they absolutely will. Cue another hilarious buffer overflow CVE 6 months later.<p>&gt; <i>I think a far better and more mature process is to update C to modern C and use a model checker such as CBMC to verify memory, resource, and integer math safety.</i><p>A huge investment. If you are going to do that then you might as well just move to Rust.<p>&gt; <i>One gets the same safety as a gradual Rust rewrite</i><p>Maybe, but that sounds fairly uncertain or far from a clear takeaway to me.</div><br/><div id="41113632" class="c"><input type="checkbox" id="c-41113632" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41110997">parent</a><span>|</span><a href="#41115151">next</a><span>|</span><label class="collapse" for="c-41113632">[-]</label><label class="expand" for="c-41113632">[10 more]</label></div><br/><div class="children"><div class="content">Rewriting is rarely a good idea in general. Rust proponents like to pretend that it is impossible to avoid safety issues in C while it is automatically given in Rust. But this is not so simply in reality.</div><br/><div id="41113728" class="c"><input type="checkbox" id="c-41113728" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41113632">parent</a><span>|</span><a href="#41115151">next</a><span>|</span><label class="collapse" for="c-41113728">[-]</label><label class="expand" for="c-41113728">[9 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like generalizations... in in general. :D  (Addressing your &quot;rewrites are rarely a good idea in general&quot; here.)<p>My experience tells me that if a tech stack supports certain safety guarantees by default that this leads to measurable reduction of those safety problems when you switch to the stack. People love convenient defaults, that&#x27;s a fact of life.<p>The apparently inconvenient truth is that most programmers are quite average and you can&#x27;t rely on them going above and beyond to reduce memory safety errors.<p>So I don&#x27;t buy the good old argument of &quot;just hire better C programmers&quot;. We still have a ton of buffer overflow CVEs regardless.<p>And I never &quot;pretended it&#x27;s impossible to avoid safety issues in C&quot;. I&#x27;ll appreciate if you don&#x27;t clump me in some imaginary group of &quot;Rust proponents&quot;.<p>What I&#x27;m saying is this: <i>use the right tool for the job</i>. The C devs have been given <i>decades</i> and yet memory safety CVEs are still prevalent.<p>What conclusion would you arrive at if you were in my place -- i.e. not coding C for a living for like 18 years now but still witnessing it periodically crapping the bed?<p>I&#x27;m curious of your take on this. Again, what other conclusion would you arrive at?</div><br/><div id="41114677" class="c"><input type="checkbox" id="c-41114677" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41113728">parent</a><span>|</span><a href="#41115151">next</a><span>|</span><label class="collapse" for="c-41114677">[-]</label><label class="expand" for="c-41114677">[8 more]</label></div><br/><div class="children"><div class="content">I am complaining about the usual phrases which are part of the Rust marketing, like the  &quot;just hire better C programmer did not work&quot; or the &quot;why are there still CVEs&quot; pseudo arguments, etc.<p>For example, let&#x27;s look at the &quot;hire better C programmers does not work&quot; argument. Like every good propaganda it starts with a truism: In this case that even highly skilled C&#x2F;C++ programmers will make mistakes that could lead to exploitable memory safety issues. The problem comes from exaggerating this to the idea that &quot;all hope is lost and nothing can be done&quot;.   In reality one can obviously  do a lot of things to improve safety in C&#x2F;C++. And even one short look at CVEs should make it clear that there is often huge room for improvements even with relatively simple measures. For example, a lot of memory safety bugs in C&#x2F;C++ come from open-coded string or buffer manipulation. But it is not exactly rocket science to abstract this away behind a safer interface. But once this is understood, the obvious conclusion is that addressing some of these low-hanging fruits would be far more effective in improving safety than wasting a lot of time and effort in rewriting in Rust.</div><br/><div id="41115269" class="c"><input type="checkbox" id="c-41115269" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41114677">parent</a><span>|</span><a href="#41115151">next</a><span>|</span><label class="collapse" for="c-41115269">[-]</label><label class="expand" for="c-41115269">[7 more]</label></div><br/><div class="children"><div class="content">&gt; <i>In reality one can obviously do a lot of things to improve safety in C&#x2F;C++.</i><p>That&#x27;s not &quot;in reality&quot;, that&#x27;s &quot;in theory&quot;. Because in actual reality, people still write the good old buffer overflow bugs to this day.<p>I don&#x27;t think anyone reasonable is disputing that we indeed can improve C&#x2F;C++ programming. The argument of myself and many others like myself is: &quot;a lot can be done but for one reason or another it is STILL NOT being done&quot;. Likely the classic cost cutting but there are likely other factors at play as well.<p>&gt; <i>But once this is understood, the obvious conclusion is that addressing some of these low-hanging fruits would be far more effective in improving safety than wasting a lot of time and effort in rewriting in Rust.</i><p>Explain why this has not been done yet. Explain why Microsoft, Google and various intelligence agencies attribute memory safety bugs to between 60% to 75% of all CVEs and demonstrable exploits that they are aware of.<p>Please do, I am listening. Why has almost nothing been done yet?<p>Secondly, &quot;wasting a lot of time and effort in rewriting in Rust&quot; is an empty claim. To demonstrate why, I ask you this: at which point the continued cost of investing in endlessly patching C&#x2F;C++ and all its glorious foot-guns becomes bigger than the cost a rewrite?<p>Surely at one point just endlessly throwing money at something that gives you a 1% return of investment (in terms of getting more stable and less dangerously buggy) does indeed get more expensive than starting over?<p>I have no clear answer because it depends on the organization, the tenure of C&#x2F;C++ and the devs in the org, and many others. It&#x27;s strange that you pretend to have the answer.</div><br/><div id="41115470" class="c"><input type="checkbox" id="c-41115470" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41115269">parent</a><span>|</span><a href="#41115151">next</a><span>|</span><label class="collapse" for="c-41115470">[-]</label><label class="expand" for="c-41115470">[6 more]</label></div><br/><div class="children"><div class="content">&gt; That&#x27;s not &quot;in reality&quot;, that&#x27;s &quot;in theory&quot;. Because in actual reality, people still write the good old buffer overflow bugs to this day.<p>That&#x27;s because while the technology exists, it is not widely communicated. That&#x27;s not a fault of C, and that&#x27;s not something that any language can solve.<p>&gt; Explain why this has not been done yet.<p>See above.<p>The technology to make C and C++ safer is not yet widely used. But, it exists and it <i>is</i> being used. I use it on every firmware and OS project that I currently work on. The code we produce is free of memory errors, integer errors, API misuse errors, resource management errors, cryptography errors, confused deputization errors, and a host of other errors that our specifications are designed to catch. That goes well beyond what Rust or any other language can provide on its own. But, to be fair, Rust developers can do this using similar tooling.<p>It&#x27;s laudable that you wish to rid the world of memory errors. I want to normalize going three or four steps further. Rust by itself won&#x27;t get us there.</div><br/><div id="41116697" class="c"><input type="checkbox" id="c-41116697" checked=""/><div class="controls bullet"><span class="by">roca</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41115470">parent</a><span>|</span><a href="#41115571">next</a><span>|</span><label class="collapse" for="c-41116697">[-]</label><label class="expand" for="c-41116697">[1 more]</label></div><br/><div class="children"><div class="content">Bounded model checking is not a silver bullet. If you want to prove it is, verify a Web browser and blog about it.</div><br/></div></div><div id="41115571" class="c"><input type="checkbox" id="c-41115571" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41115470">parent</a><span>|</span><a href="#41116697">prev</a><span>|</span><a href="#41115151">next</a><span>|</span><label class="collapse" for="c-41115571">[-]</label><label class="expand" for="c-41115571">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>That&#x27;s not a fault of C, and that&#x27;s not something that any language can solve.</i><p>If you say so. Rust clearly does, and before you go saying &quot;but `unsafe` exists!&quot; I&#x27;ll have to remind you that (1) scarcely any Rust devs reaches for that and (2) it still keeps quite a lot of guarantees and only relaxes <i>some</i>. Some, not all. Not even most.<p>&gt; <i>It&#x27;s laudable that you wish to rid the world of memory errors. I want to normalize going three or four steps further. Rust by itself won&#x27;t get us there.</i><p>Well now we are on the same page. I never said &quot;ONLY Rust will save us&quot;, I am saying that Rust clearly can get us further than we are right now. If there&#x27;s something even more accessible, less verbose, and with not such a cobbled together Frankenstein async implementation like Rust, I&#x27;ll start using it tomorrow.</div><br/><div id="41115666" class="c"><input type="checkbox" id="c-41115666" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41115571">parent</a><span>|</span><a href="#41115151">next</a><span>|</span><label class="collapse" for="c-41115666">[-]</label><label class="expand" for="c-41115666">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Rust clearly does</i><p>Until it exists at the kernel layer, the firmware layer, the runtime library layer, and the application layer, these issues still exist. CVEs come out weekly for memory errors in Linux, in firmware, in operating system libraries, and in application libraries. We need to think beyond rewriting code in one language or platform, and instead think about technologies that we can apply to all languages and platforms, including C and Rust.<p>&gt; <i>I am saying that Rust clearly can get us further than we are right now.</i><p>As can bounded model checking, without having to teach developers a new language with new idioms.<p>&gt; <i>If there&#x27;s something even more accessible, less verbose, and with not such a cobbled together Frankenstein async implementation...</i><p>Indeed there is. Reach for the bounded model checker that works with your existing language or platform. Pour over the manual, and look at existing practical examples.<p>If you like Rust, feel free to use it. But, if you prefer C&#x2F;C++, Pascal, Ada, Python, C#, Java, or Modula2, that&#x27;s fine. Either use an existing bounded model checker for that language or port CProver &#x2F; GOTO to that platform. Rust developers ported CProver to Rust via Kani, because they also recognize that writing safer code can&#x27;t be done by language alone.<p>I don&#x27;t think it&#x27;s necessary to push people to use different languages or platforms to write safer code. They just need to use or port existing tooling and learn safer coding practices. If I come at firmware developers or old school OS developers with &quot;we need to use Rust&quot;, the conversation is immediately shut down and I&#x27;m considered a fool. If, instead, I show them tooling that allows them to maintain their existing code base and make it safer, I get much further.</div><br/><div id="41116112" class="c"><input type="checkbox" id="c-41116112" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41115666">parent</a><span>|</span><a href="#41115151">next</a><span>|</span><label class="collapse" for="c-41116112">[-]</label><label class="expand" for="c-41116112">[2 more]</label></div><br/><div class="children"><div class="content">bounded model checking is a new language with new idioms</div><br/><div id="41116221" class="c"><input type="checkbox" id="c-41116221" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41116112">parent</a><span>|</span><a href="#41115151">next</a><span>|</span><label class="collapse" for="c-41116221">[-]</label><label class="expand" for="c-41116221">[1 more]</label></div><br/><div class="children"><div class="content">Respectfully, that&#x27;s a rather extraordinary claim. There are model checkers that use separate specification languages, but there are also model checkers embedded in the host language.<p>CBMC translates C -- the same language -- to an SMT solver. A different <i>target</i> but the same language.<p>It is true that new idioms will often be discovered along the way of converting existing C to pass the bounded model checker in every branch condition and in every case. However, software that is already relatively safe will require very little modification. I&#x27;ve seen it go both ways. Simpler code bases can pass model checks relatively unscathed. More complex code bases require refactoring to pass model checking.<p>To my point, the code base can remain in C, and can be model checked gradually. It doesn&#x27;t have to be ported to a different language or platform. But, it will require added assertions and some refactoring to make the execution of code more clear. It&#x27;s still in C. The specifications are specified in C using regular assertions. The only thing that changes is that one will often use shadow methods -- still written in C but simpler than the functions they are shadowing -- in order to model check other functions.<p>Other bounded model checkers like JBMC, Kani, or PolySpace work in similar ways.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41115151" class="c"><input type="checkbox" id="c-41115151" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41110997">parent</a><span>|</span><a href="#41113632">prev</a><span>|</span><a href="#41113502">next</a><span>|</span><label class="collapse" for="c-41115151">[-]</label><label class="expand" for="c-41115151">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There is no such mentality anywhere.<p>There definitely is. Mainstream and official Rust community material is generally sane, but the meme did not come from nowhere. The rewrite-everything people are out there.</div><br/><div id="41115215" class="c"><input type="checkbox" id="c-41115215" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41115151">parent</a><span>|</span><a href="#41113502">next</a><span>|</span><label class="collapse" for="c-41115215">[-]</label><label class="expand" for="c-41115215">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The rewrite-everything people are out there.</i><p>Meh, there are zealots in every community -- we&#x27;re not even talking programming language communities only. Not even programming either. Everywhere.<p>No idea why people over-reacted so much to one particular 0.1% fanatics. It&#x27;s a pretty normal state of affairs. Point me at your hobby group and even if it is only 20 people I can bet my balls at least 1 of them is a fanatic.</div><br/><div id="41115956" class="c"><input type="checkbox" id="c-41115956" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41115215">parent</a><span>|</span><a href="#41113502">next</a><span>|</span><label class="collapse" for="c-41115956">[-]</label><label class="expand" for="c-41115956">[1 more]</label></div><br/><div class="children"><div class="content">Overreacting to fanatics is also a normal state of affairs, so don&#x27;t act surprised. :) By their nature fanatics almost always make a disproportionate amount of noise, and if you&#x27;re outside the community you often can&#x27;t tell the difference: don&#x27;t know which if any of the loudmouths members pay attention to, etc. And even more broadly, a small number of people can cause a lot of damage.</div><br/></div></div></div></div></div></div><div id="41113502" class="c"><input type="checkbox" id="c-41113502" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41110997">parent</a><span>|</span><a href="#41115151">prev</a><span>|</span><a href="#41111128">next</a><span>|</span><label class="collapse" for="c-41113502">[-]</label><label class="expand" for="c-41113502">[3 more]</label></div><br/><div class="children"><div class="content">&gt; A huge investment. If you are going to do that then you might as well just move to Rust.<p>People say that, but the people who say this rarely have any practical experience using CBMC. It&#x27;s very straight-forward to use. I could teach a developer to use it reliably, on practical software, in a month.</div><br/><div id="41113531" class="c"><input type="checkbox" id="c-41113531" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41113502">parent</a><span>|</span><a href="#41111128">next</a><span>|</span><label class="collapse" for="c-41113531">[-]</label><label class="expand" for="c-41113531">[2 more]</label></div><br/><div class="children"><div class="content">I am not denying it, nor am I claiming that &quot;just move to Rust&quot; is an universal escape hatch.<p>What I am saying is that if it were as simple as &quot;just learn CBMC&quot; then maybe Microsoft and Google would have not published their studies demonstrating that 60% - 75% of all CVEs are memory safety errors like buffer under-&#x2F;over-flows.</div><br/><div id="41113579" class="c"><input type="checkbox" id="c-41113579" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41110871">root</a><span>|</span><a href="#41113531">parent</a><span>|</span><a href="#41111128">next</a><span>|</span><label class="collapse" for="c-41113579">[-]</label><label class="expand" for="c-41113579">[1 more]</label></div><br/><div class="children"><div class="content">These studies aren&#x27;t wrong. But, that&#x27;s <i>also</i> because neither Microsoft nor Google make use of practical formal methods in practice. Both have research teams and pie-in-the-sky projects, not dissimilar to this DARPA project. But, when it comes down to the nitty-gritty development cycle, both companies use decades old software development practices.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41111128" class="c"><input type="checkbox" id="c-41111128" checked=""/><div class="controls bullet"><span class="by">commodoreboxer</span><span>|</span><a href="#41110871">prev</a><span>|</span><a href="#41117284">next</a><span>|</span><label class="collapse" for="c-41111128">[-]</label><label class="expand" for="c-41111128">[8 more]</label></div><br/><div class="children"><div class="content">A lot of people are reading this as a call or demand to translate all C and C++ code to Rust, but (despite the catchy project name), I don&#x27;t read the abstract in that way.  There are two related but separate paragraphs.<p>1. C and C++ just aren&#x27;t safe enough at large. Even with careful programming and good tooling, so many vulnerabilities are caused by their unsafe by default designs. Therefore, as much code as possible should be translated to or written in &quot;safe&quot; languages (especially ones that guarantee memory safety).<p>2. We are funding and calling for software to translate existing C code into Rust.<p>It&#x27;s not a consensus to rewrite the world in Rust. It&#x27;s a consensus to migrate to safe languages, which Rust is an example of, and a program that targets Rust in such migration.</div><br/><div id="41113723" class="c"><input type="checkbox" id="c-41113723" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41111128">parent</a><span>|</span><a href="#41117284">next</a><span>|</span><label class="collapse" for="c-41113723">[-]</label><label class="expand" for="c-41113723">[7 more]</label></div><br/><div class="children"><div class="content">&gt; or written in &quot;safe&quot; languages<p>So when those languages have &#x27;unsafe&#x27; constructs what are the rules going to be around using those?  Without a defining set of rules to use here you&#x27;re just going to end up right back where you started.<p>&gt; to migrate to safe languages, which Rust is an example of<p>Rust has a safe mode.  It is _not_ a safe language.  To do anything interesting you will require unsafe blocks.  This will not get you very much.<p>Meanwhile you have tons of garbage collected languages that don&#x27;t even let the programmer touch pointers.  Why aren&#x27;t those considered?  The reason is performance.  And because Rust programmers &quot;care&quot; so much about performance you&#x27;re not ever going to solve the fundamental problem with that language.<p>Do you want performance or safety?  You can&#x27;t have both.</div><br/><div id="41114788" class="c"><input type="checkbox" id="c-41114788" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#41111128">root</a><span>|</span><a href="#41113723">parent</a><span>|</span><a href="#41113818">next</a><span>|</span><label class="collapse" for="c-41114788">[-]</label><label class="expand" for="c-41114788">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust has a safe mode. It is _not_ a safe language. To do anything interesting you will require unsafe blocks. This will not get you very much.<p>1. There are plenty of interesting programs which don&#x27;t require unsafe.<p>2. Even if your program does require unsafe, Rust still limits where the unsafety is. This lets you focus your scrutiny on the small section of the program which is critical for safety guarantees to hold. That is still a win.</div><br/></div></div><div id="41113818" class="c"><input type="checkbox" id="c-41113818" checked=""/><div class="controls bullet"><span class="by">timeon</span><span>|</span><a href="#41111128">root</a><span>|</span><a href="#41113723">parent</a><span>|</span><a href="#41114788">prev</a><span>|</span><a href="#41116222">next</a><span>|</span><label class="collapse" for="c-41113818">[-]</label><label class="expand" for="c-41113818">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  To do anything interesting you will require unsafe blocks. This will not get you very much.<p>This is not true.</div><br/><div id="41113934" class="c"><input type="checkbox" id="c-41113934" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41111128">root</a><span>|</span><a href="#41113818">parent</a><span>|</span><a href="#41116222">next</a><span>|</span><label class="collapse" for="c-41113934">[-]</label><label class="expand" for="c-41113934">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This is not true.<p>Burying unsafe blocks in unevaluated cargo modules does not make this true.  You&#x27;re just taking the original problem and sweeping it under the rug.</div><br/><div id="41115573" class="c"><input type="checkbox" id="c-41115573" checked=""/><div class="controls bullet"><span class="by">commodoreboxer</span><span>|</span><a href="#41111128">root</a><span>|</span><a href="#41113934">parent</a><span>|</span><a href="#41116222">next</a><span>|</span><label class="collapse" for="c-41115573">[-]</label><label class="expand" for="c-41115573">[2 more]</label></div><br/><div class="children"><div class="content">You can do tons of stuff with purely safe Rust. The main things that you can&#x27;t do are FFI, making self-referential structures, and dereferencing raw pointers.<p>And unsafe isn&#x27;t a problem. It&#x27;s a point of potential danger to be heavily audited, tested, and understood. Having the entire language unsafe by default is an obviously worse situation. This is throwing the baby out with the bathwater, like rallying against seat belts because you can still die while wearing one. An improvement is still an improvement. I don&#x27;t understand why people criticizing Rust tend so heavily to let perfect be the enemy of good.</div><br/><div id="41116955" class="c"><input type="checkbox" id="c-41116955" checked=""/><div class="controls bullet"><span class="by">techbrovanguard</span><span>|</span><a href="#41111128">root</a><span>|</span><a href="#41115573">parent</a><span>|</span><a href="#41116222">next</a><span>|</span><label class="collapse" for="c-41116955">[-]</label><label class="expand" for="c-41116955">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t understand why people criticizing Rust tend so heavily to let perfect be the enemy of good.<p>if you&#x27;ve convinced yourself that you&#x27;re special and all problems with c are solved by trying harder, clearly everyone else is just lazy. with that line of logic, there&#x27;s nothing to fix with c. rust is not just redundant, but also aggravating, since its popularity causes the cognitive dissonance to start creeping in.<p>maybe i can make mistakes? should we improve tooling somewhat? no, it&#x27;s the children who are wrong.</div><br/></div></div></div></div></div></div></div></div><div id="41116222" class="c"><input type="checkbox" id="c-41116222" checked=""/><div class="controls bullet"><span class="by">techbrovanguard</span><span>|</span><a href="#41111128">root</a><span>|</span><a href="#41113723">parent</a><span>|</span><a href="#41113818">prev</a><span>|</span><a href="#41117284">next</a><span>|</span><label class="collapse" for="c-41116222">[-]</label><label class="expand" for="c-41116222">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To do anything interesting you will require unsafe blocks<p>this is just flagrantly false, have you no shame?</div><br/></div></div></div></div></div></div><div id="41117284" class="c"><input type="checkbox" id="c-41117284" checked=""/><div class="controls bullet"><span class="by">Aissen</span><span>|</span><a href="#41111128">prev</a><span>|</span><a href="#41110851">next</a><span>|</span><label class="collapse" for="c-41117284">[-]</label><label class="expand" for="c-41117284">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t weird that they don&#x27;t mention the already-existing open-source project they funded, c2rust? And no mention of the company behind it, Immunant, either.</div><br/></div></div><div id="41110851" class="c"><input type="checkbox" id="c-41110851" checked=""/><div class="controls bullet"><span class="by">niemandhier</span><span>|</span><a href="#41117284">prev</a><span>|</span><a href="#41113923">next</a><span>|</span><label class="collapse" for="c-41110851">[-]</label><label class="expand" for="c-41110851">[2 more]</label></div><br/><div class="children"><div class="content">Is this supposed to be automatic ? And if so wouldn’t any Programm that can automatically port c to rust, by necessity contain all the functionality to make the c code itself safe?</div><br/><div id="41111329" class="c"><input type="checkbox" id="c-41111329" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#41110851">parent</a><span>|</span><a href="#41113923">next</a><span>|</span><label class="collapse" for="c-41111329">[-]</label><label class="expand" for="c-41111329">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think a reasonable reading of the statement implies &quot;fully automated&quot;, at which point the answer to the question is no.<p>Obviously some C code isn&#x27;t just &quot;not verifiable correct&quot; but &quot;actually wrong in a memory unsafe way&quot;. That code isn&#x27;t going to be automatically translated without human intervention because, how could it be, there is no correct equivalent code. The tooling is going to have to have an escape hatch where it says &quot;I don&#x27;t know what this code is <i>meant</i> to do, and I know it isn&#x27;t meant to do what it does do (violate promises to the compiler), help me human&quot;.<p>On a theoretical level it&#x27;s not <i>possible</i> for that escape hatch to only be used when undefined behaviour <i>does</i> occur (rices theorem). On a practical level it&#x27;s probably not even desirable to try because obtuse enough code shouldn&#x27;t just be blindly translated.<p>So what I imagine the tooling ends up looking like is an interactive tool that does the vast majority of the work for you, but is guided by a human, and ultimately as a result of that human guidance doesn&#x27;t end up with <i>exactly</i> equivalent code, just code that serves the same purpose.</div><br/></div></div></div></div><div id="41113923" class="c"><input type="checkbox" id="c-41113923" checked=""/><div class="controls bullet"><span class="by">plasticeagle</span><span>|</span><a href="#41110851">prev</a><span>|</span><a href="#41116419">next</a><span>|</span><label class="collapse" for="c-41113923">[-]</label><label class="expand" for="c-41113923">[2 more]</label></div><br/><div class="children"><div class="content">If<p>1) Rust contains no memory bugs 
2) C can be automatically translated to it<p>Then all memory bugs can be fixed automatically, which is almost certainly untrue. This task is very likely completely impossible in the general case.</div><br/><div id="41114230" class="c"><input type="checkbox" id="c-41114230" checked=""/><div class="controls bullet"><span class="by">warkdarrior</span><span>|</span><a href="#41113923">parent</a><span>|</span><a href="#41116419">next</a><span>|</span><label class="collapse" for="c-41114230">[-]</label><label class="expand" for="c-41114230">[1 more]</label></div><br/><div class="children"><div class="content">Since you did not specify that you wish to preserve all behaviors of the C code, there are trivial solutions to this problem. For example, one could replace all dynamic memory allocations with fixed buffers (set at translation time), and reject all inputs that do not fit in those buffers.</div><br/></div></div></div></div><div id="41116419" class="c"><input type="checkbox" id="c-41116419" checked=""/><div class="controls bullet"><span class="by">Thro4l31</span><span>|</span><a href="#41113923">prev</a><span>|</span><a href="#41112140">next</a><span>|</span><label class="collapse" for="c-41116419">[-]</label><label class="expand" for="c-41116419">[1 more]</label></div><br/><div class="children"><div class="content">The problems come with maintaining the translated code bases:<p>1. A code base written in C and a team of C engineers that have a good mental model of the code base to be able to maintain it.<p>2. An automatically translated Rust code base. Potentially (I&#x27;d say probably, but that is just my gut feeling) harder to read and understand than the original one.<p>3. Now you need a team of Rust engineers that have a good mental model of the code base that was generated.<p>If you already have that team of Rust engineers, I&#x27;d rather let them rewrite the code manually as they can improve it and have the correct mental model from the start.</div><br/></div></div><div id="41112140" class="c"><input type="checkbox" id="c-41112140" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41116419">prev</a><span>|</span><a href="#41111641">next</a><span>|</span><label class="collapse" for="c-41112140">[-]</label><label class="expand" for="c-41112140">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s good to see DARPA pushing on this. It&#x27;s a hard problem, but by no means impossible. Translating to <i>safe</i> Rust, though, is going to be really tough. There&#x27;s a C to Rust translator now, but what comes out is horrible Rust, which just rewrites C pointer manipulation as unsafe Rust struct manipulation. The result is less maintainable than the original.<p>So what would it take to actually do this right? The two big problems are 1) array sizes, and 2) non-affine pointer usage. Pointer arithmetic is also hard, but rare. Most pointer arithmetic can be expressed as slices.<p>Every array in C has a size. It&#x27;s just that the compiler doesn&#x27;t know what it is.<p>Where is this being discussed in detail?</div><br/><div id="41113257" class="c"><input type="checkbox" id="c-41113257" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41112140">parent</a><span>|</span><a href="#41114798">next</a><span>|</span><label class="collapse" for="c-41113257">[-]</label><label class="expand" for="c-41113257">[3 more]</label></div><br/><div class="children"><div class="content">I once tried to use c2rust as a starting point for rustification of code and... it&#x27;s not even good at that. The code is just too freakishly literal to the original C semantics that you can&#x27;t even take the non-pointery bits and strip off the unsafe block and use that as a basis.<p>(To give you a sense, it translates something like a + 1 to a.unwrapped_add(1i32), and my recollection is that for (int i = 0; i &lt; 10; i++) gets helpfully turned into a while loop instead of a for loop).<p>In general, the various challenges that all need to be solved that aren&#x27;t solved yet are:<p>a) when is integer overflow intentional in the original code so that you know when to use wrapping_op instead of regular Rust operators?<p>b) how to convert unions into Rust enums<p>c) when pointers are slices, and what corresponds to the length of the slice<p>d) convert pointers to references, and know when they&#x27;re mutable or const references<p>e) work out lifetime annotations where necessary<p>f) know when to add interior mutability to structs<p>g) wrap things in Mutex&#x2F;RwLock&#x2F;etc. for multithreaded access<p>We&#x27;re a very long way from having full-application conversion workable, and that might be sufficiently difficult that it&#x27;s impossible.</div><br/><div id="41114028" class="c"><input type="checkbox" id="c-41114028" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41112140">root</a><span>|</span><a href="#41113257">parent</a><span>|</span><a href="#41114798">next</a><span>|</span><label class="collapse" for="c-41114028">[-]</label><label class="expand" for="c-41114028">[2 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t mention the affine type problem. Rust references are restricted to single ownership. If A has a reference to B, B can&#x27;t have a reference to A. Bi-directional references are not only a common idiom in C, they&#x27;re an inherent part of C++ objects.<p>Rust has to use reference counts in such situations. You have an Rc wrapped around structs, sometimes a RefCell, and .borrow() calls that panic when you have a conflict. C code translates badly into that kind of structure.<p>Static analysis might help find .borrow() and .borrow_mut() calls that will panic, or which won&#x27;t panic. It&#x27;s very similar to finding lock deadlocks of the type where one thread locks the same lock twice.<p>(If static analysis shows that no .borrow() or .borrow_mut() for an RwLock will panic, you don&#x27;t really need the RwLock. That&#x27;s worth pursuing as a way to allow Rust to have back references.)</div><br/><div id="41114165" class="c"><input type="checkbox" id="c-41114165" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41112140">root</a><span>|</span><a href="#41114028">parent</a><span>|</span><a href="#41114798">next</a><span>|</span><label class="collapse" for="c-41114165">[-]</label><label class="expand" for="c-41114165">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d lump that analysis somewhere in the d-g, because you have to remember that &amp;mut is also noalias and work out downstream implications of that. It&#x27;s probably presumptive of me to assume a particular workflow for reconstructing the ownership model to express in Rust, and dividing that into the steps I did isn&#x27;t the only way to do it.<p>In any case, it&#x27;s the difficulty of that reconstruction step that leaves me thinking that automated conversion of whole-application to Rust is a near-impossibility. Conversion of an individual function that works on plain-old-data structures is probably doable, if somewhat challenging.<p>An off-the-cuff idea I just had is to implement a semi-automated transformation, where the user has to input what a final conversion of a struct type should look like (including all Cell&#x2F;Rc&#x2F;whatever wrappers as needed), and the tool can use that to work out the rest of the translation. There&#x27;s probably a lot of ways that can go horribly wrong, but it seems more feasible than trying to figure out all of the wrappers need to be.</div><br/></div></div></div></div></div></div><div id="41114798" class="c"><input type="checkbox" id="c-41114798" checked=""/><div class="controls bullet"><span class="by">clintfred</span><span>|</span><a href="#41112140">parent</a><span>|</span><a href="#41113257">prev</a><span>|</span><a href="#41112201">next</a><span>|</span><label class="collapse" for="c-41114798">[-]</label><label class="expand" for="c-41114798">[1 more]</label></div><br/><div class="children"><div class="content">Even if just all the unsafe areas were marked, wouldn&#x27;t that be valuable? At least it would focus review efforts on the parts with the most risk?</div><br/></div></div><div id="41112201" class="c"><input type="checkbox" id="c-41112201" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41112140">parent</a><span>|</span><a href="#41114798">prev</a><span>|</span><a href="#41111641">next</a><span>|</span><label class="collapse" for="c-41112201">[-]</label><label class="expand" for="c-41112201">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Where is this being discussed in detail?<p>In my understanding, this is a call for proposals to do the work, there is no detailed discussion yet. That will come when there&#x27;s actual responses to this call.</div><br/><div id="41112516" class="c"><input type="checkbox" id="c-41112516" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41112140">root</a><span>|</span><a href="#41112201">parent</a><span>|</span><a href="#41111641">next</a><span>|</span><label class="collapse" for="c-41112516">[-]</label><label class="expand" for="c-41112516">[1 more]</label></div><br/><div class="children"><div class="content">Right, there&#x27;s a call, and a project day with an in-person meeting coming up.</div><br/></div></div></div></div></div></div><div id="41111641" class="c"><input type="checkbox" id="c-41111641" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#41112140">prev</a><span>|</span><a href="#41116362">next</a><span>|</span><label class="collapse" for="c-41111641">[-]</label><label class="expand" for="c-41111641">[10 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t some &quot;pie in the sky&quot; thing, Immunant has a working C to Rust transpiler and it&#x27;s really interesting: <a href="https:&#x2F;&#x2F;github.com&#x2F;immunant&#x2F;c2rust">https:&#x2F;&#x2F;github.com&#x2F;immunant&#x2F;c2rust</a></div><br/><div id="41115448" class="c"><input type="checkbox" id="c-41115448" checked=""/><div class="controls bullet"><span class="by">bubberducky</span><span>|</span><a href="#41111641">parent</a><span>|</span><a href="#41111837">next</a><span>|</span><label class="collapse" for="c-41115448">[-]</label><label class="expand" for="c-41115448">[1 more]</label></div><br/><div class="children"><div class="content">It seems easy (relatively speaking) to directly translate C to Rust if you&#x27;re allowed to use unsafe and don&#x27;t make an effort to actually verify the soundness of the code.
But if you need to verify the soundness and fix bugs while translating it? That&#x27;s really hard, and that&#x27;s what it sounds like what TRACTOR wants to do.<p>Using &quot;unsafe&quot; doesn&#x27;t automatically make Rust useless, of course, but the example on the c2rust website itself doesn&#x27;t make any effort to verify its usage of unsafe (you can easily read memory out of bounds just by changing &quot;n&quot; to &quot;n + 1&quot; in the example loop). Sadly, that is a much, much harder problem to solve even for fairly basic C programs.</div><br/></div></div><div id="41111837" class="c"><input type="checkbox" id="c-41111837" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41111641">parent</a><span>|</span><a href="#41115448">prev</a><span>|</span><a href="#41112919">next</a><span>|</span><label class="collapse" for="c-41111837">[-]</label><label class="expand" for="c-41111837">[1 more]</label></div><br/><div class="children"><div class="content">Their work was also previously sponsored by DARPA, though I do not know if it was under this program or something else.</div><br/></div></div><div id="41112919" class="c"><input type="checkbox" id="c-41112919" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41111641">parent</a><span>|</span><a href="#41111837">prev</a><span>|</span><a href="#41113299">next</a><span>|</span><label class="collapse" for="c-41112919">[-]</label><label class="expand" for="c-41112919">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried that thing. The Rust that comes out is terrible. It converts C into a set of Rust function calls which explicitly emulate C semantics by manipulating raw pointers. It doesn&#x27;t even convert C arrays to a Vec.  It&#x27;s a brute-force transliteration, not a translation.<p>I and someone else ran this on a JPEG 2000 decoder that sometimes crashed with a bad memory reference. The Rust version crashed with the same bad memory reference. It&#x27;s bug-compatible.<p>What comes out is totally unreadable and much bigger than the original C code. Manual &quot;refactoring&quot; of that output is hopeless.</div><br/><div id="41115355" class="c"><input type="checkbox" id="c-41115355" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41111641">root</a><span>|</span><a href="#41112919">parent</a><span>|</span><a href="#41113445">next</a><span>|</span><label class="collapse" for="c-41115355">[-]</label><label class="expand" for="c-41115355">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t make sense to convert a C array to a Vec, the Vec type is a growable array but the C array isn&#x27;t growable. It makes sense to convert to Rust&#x27;s array type, which has a fixed size, and we realise there&#x27;s a problem at API boundaries because C&#x27;s arrays decay to pointers, so the moment we touch an API boundary all safety is destroyed.</div><br/><div id="41116777" class="c"><input type="checkbox" id="c-41116777" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41111641">root</a><span>|</span><a href="#41115355">parent</a><span>|</span><a href="#41113445">next</a><span>|</span><label class="collapse" for="c-41116777">[-]</label><label class="expand" for="c-41116777">[1 more]</label></div><br/><div class="children"><div class="content">Depends on how the array is created. If it comes from &quot;malloc&quot; or C++ &quot;new&quot;, it may need to be created as a &quot;Vec&quot;.</div><br/></div></div></div></div><div id="41113445" class="c"><input type="checkbox" id="c-41113445" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41111641">root</a><span>|</span><a href="#41112919">parent</a><span>|</span><a href="#41115355">prev</a><span>|</span><a href="#41115063">next</a><span>|</span><label class="collapse" for="c-41113445">[-]</label><label class="expand" for="c-41113445">[2 more]</label></div><br/><div class="children"><div class="content">Any automatic translation is bug-compatible with the original. Did you expect it to divine some requirements?<p>It still leave you with Rust code that you can improve piecewise. The only question is if something like it is better than FFI calling the C code.</div><br/><div id="41113594" class="c"><input type="checkbox" id="c-41113594" checked=""/><div class="controls bullet"><span class="by">bornfreddy</span><span>|</span><a href="#41111641">root</a><span>|</span><a href="#41113445">parent</a><span>|</span><a href="#41115063">next</a><span>|</span><label class="collapse" for="c-41113594">[-]</label><label class="expand" for="c-41113594">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Any automatic translation is bug-compatible with the original. Did you expect it to divine some requirements?<p>That would be useless when translating C to Rust. Yes, I would expect the tool to point out the flaws in the original memory handling and only translate the corrected code. This is far from easy, since some information (intent) is missing, but a good coder could do it on decent codebases. The question is, can an automated tool do it too? We&#x27;ll see.</div><br/></div></div></div></div><div id="41115063" class="c"><input type="checkbox" id="c-41115063" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#41111641">root</a><span>|</span><a href="#41112919">parent</a><span>|</span><a href="#41113445">prev</a><span>|</span><a href="#41113299">next</a><span>|</span><label class="collapse" for="c-41115063">[-]</label><label class="expand" for="c-41115063">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I ran this on a JPEG 2000 decoder that sometimes crashed with a bad memory reference. The Rust version crashed with the same bad memory reference. It&#x27;s bug-compatible.<p>Of course it is. The README says it generates unsafe rust in the first paragraph, what did you expect?<p>I think it&#x27;s a really fascinating experiment, and IMHO it&#x27;s pretty remarkable what it can do. This is an incredibly difficult problem after all...</div><br/></div></div></div></div><div id="41113299" class="c"><input type="checkbox" id="c-41113299" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41111641">parent</a><span>|</span><a href="#41112919">prev</a><span>|</span><a href="#41116362">next</a><span>|</span><label class="collapse" for="c-41113299">[-]</label><label class="expand" for="c-41113299">[1 more]</label></div><br/><div class="children"><div class="content">As I mentioned elsewhere (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41113257">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41113257</a>), that tool is pretty much useless unless you have some checkbox that says &quot;no C code allowed anywhere&quot;. It&#x27;s not even a feasible starting point for refactoring because the code is so far from idiomatic Rust.</div><br/></div></div></div></div><div id="41116362" class="c"><input type="checkbox" id="c-41116362" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#41111641">prev</a><span>|</span><a href="#41113891">next</a><span>|</span><label class="collapse" for="c-41116362">[-]</label><label class="expand" for="c-41116362">[1 more]</label></div><br/><div class="children"><div class="content">Would be nice if they could first hire all the smart engineers (that Mozilla laid off) to continue working on the language itself.<p>Async is still a half finished mess even for people that use it every day. And that is my main annoyance but there are many (trait specialization, orphan rule limits, HKT, etc.)</div><br/></div></div><div id="41114836" class="c"><input type="checkbox" id="c-41114836" checked=""/><div class="controls bullet"><span class="by">luke-stanley</span><span>|</span><a href="#41113891">prev</a><span>|</span><a href="#41111206">next</a><span>|</span><label class="collapse" for="c-41114836">[-]</label><label class="expand" for="c-41114836">[1 more]</label></div><br/><div class="children"><div class="content">Surely this could be better pitched to researchers as just another AI benchmark, a bit like ARC Prize? ;)
There could be some exiting C projects that are already public, with tests for feedback during development iteration and some holdout tests, and some holdout projects too with a leaderboard and prizes.
For preferences about converted code quality, both automated assesment and human preferences could be ranked with Elo? Kaggle is made for this sort of thing I think?
I&#x27;m sure Google Deepmind and others have some MCTS agents that could do a great job with a bit of effort.</div><br/></div></div><div id="41111206" class="c"><input type="checkbox" id="c-41111206" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#41114836">prev</a><span>|</span><a href="#41113161">next</a><span>|</span><label class="collapse" for="c-41111206">[-]</label><label class="expand" for="c-41111206">[10 more]</label></div><br/><div class="children"><div class="content">Every tool has its own specific quirks. Over many years of using a tool, &quot;expertise&quot; is the intimate knowledge of those quirks and how to use that tool most effectively. Changing tools requires you to gain expertise again. You&#x27;re going to be less proficient in the new tool for a long time, and make a lot of mistakes.<p>Considering we already know how to make C&#x2F;C++ programs memory safe, it&#x27;s bizarre that people would ditch all of their expertise, and the years and years of perfecting the operation of those programs, and throw all that out the window because they can&#x27;t be bothered to use a particular set of functions [that enforce memory safety].<p>If you&#x27;re going to go to all of the trouble to gain expertise in an entirely new tool, plus porting a legacy program to the new tool, I think you need a better rationale than &quot;it does memory safety now&quot;. You should have more to show for your efforts than just that, and take advantage of the situation to add more value.</div><br/><div id="41111617" class="c"><input type="checkbox" id="c-41111617" checked=""/><div class="controls bullet"><span class="by">wffurr</span><span>|</span><a href="#41111206">parent</a><span>|</span><a href="#41115070">next</a><span>|</span><label class="collapse" for="c-41111617">[-]</label><label class="expand" for="c-41111617">[8 more]</label></div><br/><div class="children"><div class="content">But even proficient C and C++ programmers continue to produce code with memory safety issues leading to remote code execution exploits.  This argument doesn’t hold up to the actual experience of large C and C++ projects.</div><br/><div id="41114289" class="c"><input type="checkbox" id="c-41114289" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#41111206">root</a><span>|</span><a href="#41111617">parent</a><span>|</span><a href="#41112371">next</a><span>|</span><label class="collapse" for="c-41114289">[-]</label><label class="expand" for="c-41114289">[6 more]</label></div><br/><div class="children"><div class="content">They aren&#x27;t trying to prevent them. It&#x27;s trivial to prevent them if you actually put effort into it; if you don&#x27;t, it&#x27;s going to be vulnerable. This is true of all security concerns.</div><br/><div id="41114523" class="c"><input type="checkbox" id="c-41114523" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41111206">root</a><span>|</span><a href="#41114289">parent</a><span>|</span><a href="#41115732">next</a><span>|</span><label class="collapse" for="c-41114523">[-]</label><label class="expand" for="c-41114523">[3 more]</label></div><br/><div class="children"><div class="content">&quot;You aren&#x27;t trying hard enough&quot; isn&#x27;t a serious approach to security: if it was, we wouldn&#x27;t require seatbelts in cars or health inspections in restaurants.<p>(It&#x27;s also not clear that they <i>aren&#x27;t</i> trying hard enough: Google, Apple, etc. have billions of dollars riding on the safety of their products, but still largely fail to produce memory-safe C and C++ codebases.)</div><br/><div id="41116094" class="c"><input type="checkbox" id="c-41116094" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#41111206">root</a><span>|</span><a href="#41114523">parent</a><span>|</span><a href="#41115732">next</a><span>|</span><label class="collapse" for="c-41116094">[-]</label><label class="expand" for="c-41116094">[2 more]</label></div><br/><div class="children"><div class="content">In the case of OpenSSL, Big Tech clearly neglected proper support until after the Heartbleed vulnerability. Prior to Heartbleed, the OpenSSL Software Foundation only received about $2K annually in donations and employed just one full-time employee [1]. Given the projects critical role in internet security, Big Techs neglect raises concerns about their quality assurance practices for less critical projects.<p>The OpenSSL Foundation is not exempt from criticism despite inadequate funding. Heartbleed was discovered by security researches using fuzz testing, but proactive fuzz testing should have been a standard practice from the start.<p>[1] <a href="https:&#x2F;&#x2F;arstechnica.com&#x2F;information-technology&#x2F;2014&#x2F;04&#x2F;tech-giants-chastened-by-heartbleed-finally-agree-to-fund-openssl&#x2F;" rel="nofollow">https:&#x2F;&#x2F;arstechnica.com&#x2F;information-technology&#x2F;2014&#x2F;04&#x2F;tech-...</a></div><br/><div id="41116317" class="c"><input type="checkbox" id="c-41116317" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41111206">root</a><span>|</span><a href="#41116094">parent</a><span>|</span><a href="#41115732">next</a><span>|</span><label class="collapse" for="c-41116317">[-]</label><label class="expand" for="c-41116317">[1 more]</label></div><br/><div class="children"><div class="content">OpenSSL is not a great example, either before or after funding — it’s a notoriously poorly architected codebase with multiple layers of flawed abstractions. I meant things more like Chromium, WebKit, etc.: these have dozens to hundreds of professional top-bracket C and C++ developers working on them, and they still can’t avoid memory corruption bugs.</div><br/></div></div></div></div></div></div><div id="41115732" class="c"><input type="checkbox" id="c-41115732" checked=""/><div class="controls bullet"><span class="by">wffurr</span><span>|</span><a href="#41111206">root</a><span>|</span><a href="#41114289">parent</a><span>|</span><a href="#41114523">prev</a><span>|</span><a href="#41112371">next</a><span>|</span><label class="collapse" for="c-41115732">[-]</label><label class="expand" for="c-41115732">[2 more]</label></div><br/><div class="children"><div class="content">No True C Programmer writes code with buffer overflows in it.  It&#x27;s pretty clear this is not a serious take.</div><br/><div id="41115771" class="c"><input type="checkbox" id="c-41115771" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#41111206">root</a><span>|</span><a href="#41115732">parent</a><span>|</span><a href="#41112371">next</a><span>|</span><label class="collapse" for="c-41115771">[-]</label><label class="expand" for="c-41115771">[1 more]</label></div><br/><div class="children"><div class="content">FWiW &quot;True C Programmers&quot; delibrately coded &quot;buffer overflows&quot; all the time back in the day.<p>The practice of using variable sized structures that began with type and size info and ended with a char[1] was commonplace.<p><a href="https:&#x2F;&#x2F;hex-rays.com&#x2F;blog&#x2F;igors-tip-of-the-week-94-variable-sized-structures&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hex-rays.com&#x2F;blog&#x2F;igors-tip-of-the-week-94-variable-...</a><p>Good True C Programmers had guard rails | canary bytes | etc. to detect and avoid <i>actual</i> buffer overflow (into unallocated memory) rather than technical buffer overflow (reading|writing past the end of a char|byte array).</div><br/></div></div></div></div></div></div></div></div><div id="41115070" class="c"><input type="checkbox" id="c-41115070" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#41111206">parent</a><span>|</span><a href="#41111617">prev</a><span>|</span><a href="#41113161">next</a><span>|</span><label class="collapse" for="c-41115070">[-]</label><label class="expand" for="c-41115070">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Considering we already know how to make C&#x2F;C++ programs memory safe...<p>I think that the legion of memory bugs which still occur in C&#x2F;C++ programs are proof of one of two things:<p>1. We (the industry as a whole) do not actually know how to make these programs memory safe, or<p>2. Knowing how to make programs memory safe in C&#x2F;C++ is not sufficient to prevent memory safety issues.<p>Either way, it seems clear that <i>something</i> needs to be done and that the status quo in C&#x2F;C++ programming is not enough. I&#x27;m not saying Rust will be the right answer in the end (I do like it, but there&#x27;s a ton of hype and hype makes me distrustful), but I can&#x27;t fault people for wanting to try something new.</div><br/></div></div></div></div><div id="41113161" class="c"><input type="checkbox" id="c-41113161" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#41111206">prev</a><span>|</span><a href="#41111654">next</a><span>|</span><label class="collapse" for="c-41113161">[-]</label><label class="expand" for="c-41113161">[1 more]</label></div><br/><div class="children"><div class="content">i like the idea but i struggle to see how one can go about doing &#x27;safe&#x27; disk reads, having &#x27;safe&#x27; ways to manage global resources in kernel land (page tables, descriptor tables etc) and a lot of other stuff. perhaps if those devices also have rust in their firmware they can reply safely?? genuinely curious because i went back to C from rust in my OS. i could not figure it out (maybe i am not a darpa level engineer but i did work at a similar place doing similar things).<p>id be excited if this gets solved. rust is a lot more comfy for higher level kernel stuff.</div><br/></div></div><div id="41111654" class="c"><input type="checkbox" id="c-41111654" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#41113161">prev</a><span>|</span><a href="#41110707">next</a><span>|</span><label class="collapse" for="c-41111654">[-]</label><label class="expand" for="c-41111654">[1 more]</label></div><br/><div class="children"><div class="content">Difficult: most C programs I know would convert to one single large &quot;unsafe&quot; block...<p>One might argue that re-writing from scratch is the safer option; and a re-write is also an opportunity to do things differently (read: improve the architecture by using what one has learned), despite the much-feared &quot;second system&quot; syndrome.<p>But nothing wrong with spending some research dollars towards tooling for &quot;assisted legacy rewrites&quot;. DARPA and her sister IARPA fund step innovation (high risk, high reward), and this is an area where good things can come potentially come from.</div><br/></div></div><div id="41115398" class="c"><input type="checkbox" id="c-41115398" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#41110707">prev</a><span>|</span><a href="#41116319">next</a><span>|</span><label class="collapse" for="c-41115398">[-]</label><label class="expand" for="c-41115398">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m reminded of Darpa&#x27;s old plans for Ada. I expect we&#x27;ll see the same issues come up as the last time they tried this.</div><br/></div></div><div id="41116319" class="c"><input type="checkbox" id="c-41116319" checked=""/><div class="controls bullet"><span class="by">b20000</span><span>|</span><a href="#41115398">prev</a><span>|</span><a href="#41114328">next</a><span>|</span><label class="collapse" for="c-41116319">[-]</label><label class="expand" for="c-41116319">[2 more]</label></div><br/><div class="children"><div class="content">“ the software engineering community has reached a consensus” … hahaha no sorry, I don’t think so<p>Your priority should be to learn how to build better software and not force a new language onto people.<p>do you remember the age old saying about nature and fools?</div><br/><div id="41116968" class="c"><input type="checkbox" id="c-41116968" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#41116319">parent</a><span>|</span><a href="#41114328">next</a><span>|</span><label class="collapse" for="c-41116968">[-]</label><label class="expand" for="c-41116968">[1 more]</label></div><br/><div class="children"><div class="content">I guess it is a consensus like `goto considered harmful` or `numbering should start at zero`, which is not a perfect consensus, but as much of a consensus as you can reach for such a disparate community.</div><br/></div></div></div></div><div id="41114328" class="c"><input type="checkbox" id="c-41114328" checked=""/><div class="controls bullet"><span class="by">ristos</span><span>|</span><a href="#41116319">prev</a><span>|</span><a href="#41114178">next</a><span>|</span><label class="collapse" for="c-41114328">[-]</label><label class="expand" for="c-41114328">[1 more]</label></div><br/><div class="children"><div class="content">I get the idea of moving to more memory safety, but the whole &quot;rewrite everything in Rust&quot; trend feels really misguided, because if you&#x27;re talking about being able to trust code and code safety:<p>- Rust&#x27;s compiler is 1.8 million lines of recursively compiled code, how can you or anyone know that what was written is actually trustworthy? Also memory safety is just a very small part of being able to actually trust code.<p>- C compiles down to straightforward assembly, almost like a direct translation, so you can at least verify that smaller programs that you write in C actually do compile down to assembly you expect, and compose those smaller programs into larger ones.<p>- C has valgrind and ASAN so it&#x27;s at least possible to write safe code with code coding discipline, and plenty of software has been able to do this for decades.<p>- A lot of (almost all) higher level programming languages are written in C, which means that those languages just need to make sure they get the compiler and GC right, and then those languages can be used for general purpose, scripting, &quot;low level&quot; high level code like Go or OCaml, etc.<p>- There are many C compilers and only one Rust compiler, and it&#x27;s unclear whether it&#x27;ll really be feasible to have more than one Rust compiler due to the complexity of the language. So you&#x27;re putting a lot of trust into a small group of people, and even if they&#x27;re the most amazing, most ethical people, surely if a lot of critical infra is based on Rust they&#x27;ll get targeted in some way.<p>- Something being open source doesn&#x27;t mean it&#x27;s been fully audited. We&#x27;ve seen all sorts of security vulnerabilities cause a world a hurt for a lot of people that came from all open source code, and often very small libraries that could actually be much easier to audit than lines with millions of lines of code.<p>- Similarly, Rust does not translate to straightforward assembly, and again would seem to be impossible to do given the complexity of the language.<p>- There was an interesting project I came across called CompCert, which aims to have a C compiler that&#x27;s formally verified (in Coq) to translate into the assembly you expect. Something like a recursively compiled CompCert C -&gt; OCaml -&gt; Coq -&gt; CompCert would be an interesting undertaking, which would make OCaml and Coq themselves built on formally verified code, but I&#x27;m not sure if that&#x27;ll really work and I suspect it&#x27;s too complicated.<p>- I think Rust might be able to solve some of these problems if they have a fully formally verified thing, and the formally verified thing is itself formally verified, and the compiler was verified by that thing, and then you know that you can trust the whole thing. Still, the level of complexity and the inability to at least manually audit the core of it makes me suspect it&#x27;s too complicated and would still be based on trust of some sort.<p>- I still think that static analysis and building higher level languages on top of C is a better approach, and working on formal verification from there, because there are really small C compilers like tinycc that are ~50k LOCs, which can be hand verified. You can compile chibi-scheme with tinycc, for example, which is also about ~50k LOCs of C, and so you get a higher level language from about 100k LOCs (tcc and chibi), which is feasible for an ordinary but motivated dev to manually audit to know that it&#x27;s producing sound assembly and not something wonky or sketchy. Ideally we should be building compilers and larger systems that are formally verified, but I think the core of whatever the formally verified system is has to be hand verifiable in some way in order to be trustworthy, so that you can by induction trust whatever gets built up from that, and I think that would need to require a straightforward translation into assembly, with ideally open source ISA and hardware, and a small enough codebase to be manually audited like the tinycc and chibi-scheme example I gave.<p>- Worst case everyone kind of shrugs it all off and just trusts all of these layers of complexity, which can be like C -&gt; recursively compiled higher level lang -&gt; coffeescript-like layer on top -&gt; framework, which is apparently a thing now, and just hope that all of these layers of millions of lines of code of complexity don&#x27;t explode in some weird way, intentionally or unintentionally.<p>- Best case of the worst case is that all of our appliances are now &quot;smart&quot; appliances, and then one day they just transform into robots that start chasing you around the house, all the while the Transformers cartoon theme is playing in the background while, which would match up nicely with the current trend of everything being both terrifying and hilarious in a really bizarre way.</div><br/></div></div><div id="41114178" class="c"><input type="checkbox" id="c-41114178" checked=""/><div class="controls bullet"><span class="by">ksp-atlas</span><span>|</span><a href="#41114328">prev</a><span>|</span><a href="#41111015">next</a><span>|</span><label class="collapse" for="c-41114178">[-]</label><label class="expand" for="c-41114178">[2 more]</label></div><br/><div class="children"><div class="content">Technically, Zig has this functionality built in via translate-c, but it&#x27;s designed for reading by a C compiler, not a human</div><br/><div id="41115080" class="c"><input type="checkbox" id="c-41115080" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#41114178">parent</a><span>|</span><a href="#41111015">next</a><span>|</span><label class="collapse" for="c-41115080">[-]</label><label class="expand" for="c-41115080">[1 more]</label></div><br/><div class="children"><div class="content">Well, the main idea is memory-safety. Zig is certainly better, but not as memory-safe.<p>PS: Java or even JavaScript are memory-safe :)</div><br/></div></div></div></div><div id="41111015" class="c"><input type="checkbox" id="c-41111015" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#41114178">prev</a><span>|</span><a href="#41114162">next</a><span>|</span><label class="collapse" for="c-41111015">[-]</label><label class="expand" for="c-41111015">[7 more]</label></div><br/><div class="children"><div class="content">They didn&#x27;t explain why they&#x27;ve chosen Rust. There are a lot of memory-safe languages besides Rust, especially in application-level area (not systems-level like Rust).</div><br/><div id="41111072" class="c"><input type="checkbox" id="c-41111072" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41111015">parent</a><span>|</span><a href="#41112327">next</a><span>|</span><label class="collapse" for="c-41111072">[-]</label><label class="expand" for="c-41111072">[3 more]</label></div><br/><div class="children"><div class="content">There are a lot of memory safe languages; there are fewer that have (1) marginal runtime requirements, (2) transparent interop&#x2F;FFI with existing C codebases, (3) enable both spatial and temporal memory safety without GC, and (4) have significant development momentum behind them. Rust doesn&#x27;t <i>have</i> to be unique among these qualifications, but it&#x27;s currently preeminent.</div><br/><div id="41111588" class="c"><input type="checkbox" id="c-41111588" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#41111015">root</a><span>|</span><a href="#41111072">parent</a><span>|</span><a href="#41112327">next</a><span>|</span><label class="collapse" for="c-41111588">[-]</label><label class="expand" for="c-41111588">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but you assume all their projects need all 4 of these. I like Rust, but it&#x27;s a bad choice for many areas (e.g. aforementioned application-level code). I&#x27;d expect serious decisions to at least take that into account.</div><br/><div id="41111650" class="c"><input type="checkbox" id="c-41111650" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41111015">root</a><span>|</span><a href="#41111588">parent</a><span>|</span><a href="#41112327">next</a><span>|</span><label class="collapse" for="c-41111650">[-]</label><label class="expand" for="c-41111650">[1 more]</label></div><br/><div class="children"><div class="content">I’m not assuming anything of the sort. These are just properties that make Rust a nice target for automatic translation of C programs; there are myriad factors that <i>guarantee</i> that nowhere close to 100% of programs (C, application level, or otherwise) won’t be suitable for translation.</div><br/></div></div></div></div></div></div><div id="41112327" class="c"><input type="checkbox" id="c-41112327" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#41111015">parent</a><span>|</span><a href="#41111072">prev</a><span>|</span><a href="#41111108">next</a><span>|</span><label class="collapse" for="c-41112327">[-]</label><label class="expand" for="c-41112327">[2 more]</label></div><br/><div class="children"><div class="content">Apart from runtime&#x2F;embedded requirements, there&#x27;s the big question of how you represent what C is doing in other languages that don&#x27;t have interior pointers and pointer casting. For example, in C I might have a `struct foo*` that aliases the 7th element of a `struct foo[]` array. How do you represent that in Java or Python? I don&#x27;t think you can use regular objects or regular arrays&#x2F;lists from either of those languages, because you need <i>assignments through the pointer</i> (of the whole `struct foo`, not just individual field writes) to affect the array. Even worse, in C I might have a `const char*` that aliases the same element and expects every write to affect its <i>bytes</i>. To model all this you&#x27;d need some Frankenstein, technically-Turing-complete, giant-bytestring-that-represents-all-of-memory thing that wouldn&#x27;t really be Java or Python in any meaningful sense, wouldn&#x27;t be remotely readable or maintainable, and wouldn&#x27;t be able to interoperate with any existing libraries.<p>In Rust you presumably do all of that with raw pointers, which leaves you with a big unsafe mess to clean up over time, and I imagine a lot of the hard work of this project is trying to minimize that mess. But at least the mess that you have is recognizably Rust, and incremental cleanup is possible.</div><br/><div id="41115989" class="c"><input type="checkbox" id="c-41115989" checked=""/><div class="controls bullet"><span class="by">wolfspider</span><span>|</span><a href="#41111015">root</a><span>|</span><a href="#41112327">parent</a><span>|</span><a href="#41111108">next</a><span>|</span><label class="collapse" for="c-41115989">[-]</label><label class="expand" for="c-41115989">[1 more]</label></div><br/><div class="children"><div class="content">I’ve spent the past few months translating a C library heavy in pointer arithmetic to TypeScript. Concessions have to be made here and there but ended up making utility classes to capture some of the functionality. Structs can be represented as types since they are able to also to be expressed as unions similar to structs. These const types can have fields updated in place and inherit properties from other variables similar to passing by reference which JS can do (pass by sharing) or use a deep clone to copy. As far as affecting the underlying bytes as a type I’ve come up with something I call byte type reflection which is a union type which does self-inference on the object properties in order to flatten itself into a bytearray so that the usual object indexing and length properties automatically only apply to the byte array as it has been expressed (the underlying object remains as well). C automatically does this so there is some overhead for this that cannot be removed. Pointer arithmetic can be applied with an iterator class which keeps track of the underlying data object but sadly does count as another copy. Array splicing can substitute creating a view of a pointer array which is not optimal but there are some Kotlin-esque utilities that create array views which can be used. Surprisingly, the floating point values which I expected to be way off and can only express as a number type are close enough. I use Deno FFI so plenty of room to go back to unmanaged code for optimizations and WASM can be tapped into easily. For me those values are what is important and it does the job adequately. The code is also way more resilient to runtime errors as opposed to the C library which has a tendency to just blow up. TLDR; Don’t let it stop you until you try because you might just be surprised at how it turns out. If the function calls of a library are only 2-3 levels deep how much “performance” are you really gaining by keeping it that way? Marshalling code is the usual answer and Deno FFI does an amazing job at that.</div><br/></div></div></div></div><div id="41111108" class="c"><input type="checkbox" id="c-41111108" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#41111015">parent</a><span>|</span><a href="#41112327">prev</a><span>|</span><a href="#41114162">next</a><span>|</span><label class="collapse" for="c-41111108">[-]</label><label class="expand" for="c-41111108">[1 more]</label></div><br/><div class="children"><div class="content">If you have your cross hair on c, then you want a language that can do whatever c does. That makes the list of memory safe languages a lot shorter.</div><br/></div></div></div></div><div id="41114802" class="c"><input type="checkbox" id="c-41114802" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41110929">prev</a><span>|</span><a href="#41113208">next</a><span>|</span><label class="collapse" for="c-41114802">[-]</label><label class="expand" for="c-41114802">[1 more]</label></div><br/><div class="children"><div class="content">Or you could just use Fil-C.</div><br/></div></div><div id="41113208" class="c"><input type="checkbox" id="c-41113208" checked=""/><div class="controls bullet"><span class="by">rpoisel</span><span>|</span><a href="#41114802">prev</a><span>|</span><a href="#41115282">next</a><span>|</span><label class="collapse" for="c-41113208">[-]</label><label class="expand" for="c-41113208">[1 more]</label></div><br/><div class="children"><div class="content">I think we have to take that literally: They only translate C code to Rust. Not C++.</div><br/></div></div><div id="41115282" class="c"><input type="checkbox" id="c-41115282" checked=""/><div class="controls bullet"><span class="by">29athrowaway</span><span>|</span><a href="#41113208">prev</a><span>|</span><a href="#41112595">next</a><span>|</span><label class="collapse" for="c-41115282">[-]</label><label class="expand" for="c-41115282">[1 more]</label></div><br/><div class="children"><div class="content">Why not Ada or Zig?</div><br/></div></div><div id="41112595" class="c"><input type="checkbox" id="c-41112595" checked=""/><div class="controls bullet"><span class="by">simon_void</span><span>|</span><a href="#41115282">prev</a><span>|</span><a href="#41114372">next</a><span>|</span><label class="collapse" for="c-41112595">[-]</label><label class="expand" for="c-41112595">[2 more]</label></div><br/><div class="children"><div class="content">a) if every C program could be translated into an equivalent safe Rust program, that would mean that each C program is as safe as the safe Rust equivalent.
b) since there are C programs that are open to memory currption in a way safe Rust isn&#x27;t, this corruptability would need to be translated into partially unsafe Rust. Congrats, you now have a corruptible Rust program, what&#x27;s the point again??
c) so DARPA must be trying to fix&#x2F;change what the program is doing when switching to Rust. So how to discern what behaviour is intended and which is not? Doesn&#x27;t this run directly into the undecidability&#x2F;uncomputability of the halting problem!?!</div><br/><div id="41114394" class="c"><input type="checkbox" id="c-41114394" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#41112595">parent</a><span>|</span><a href="#41114372">next</a><span>|</span><label class="collapse" for="c-41114394">[-]</label><label class="expand" for="c-41114394">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Doesn&#x27;t this run directly into the undecidability&#x2F;uncomputability of the halting problem!?!<p>The programmer gets to decide. DARPA does not expect the translator program to autonomously output a perfect Rust program. It just wants a &quot;<i>high degree</i> of automation towards translating legacy C to Rust&quot; (from the sam.gov link in the submission, emphasis mine).</div><br/></div></div></div></div><div id="41114372" class="c"><input type="checkbox" id="c-41114372" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#41112595">prev</a><span>|</span><label class="collapse" for="c-41114372">[-]</label><label class="expand" for="c-41114372">[1 more]</label></div><br/><div class="children"><div class="content">I think this is indirectly a great argument for automated, test generation or equivalence checking. The reason is that these translations might change the function of the code. Automated testing would show whether or not that happened. It also reveals many bugs.<p>So, they should solve total, automated testing first. Maybe in parallel. Then, use it for equivalence checks.</div><br/></div></div></div></div></div></div></div></body></html>