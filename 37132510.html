<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692262859981" as="style"/><link rel="stylesheet" href="styles.css?v=1692262859981"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mathspp.com/blog/what-learning-apl-taught-me-about-python">What learning APL taught me about Python</a> <span class="domain">(<a href="https://mathspp.com">mathspp.com</a>)</span></div><div class="subtext"><span>RojerGS</span> | <span>77 comments</span></div><br/><div><div id="37158877" class="c"><input type="checkbox" id="c-37158877" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#37158475">next</a><span>|</span><label class="collapse" for="c-37158877">[-]</label><label class="expand" for="c-37158877">[1 more]</label></div><br/><div class="children"><div class="content">As a beginner I definitely thought list comprehensions were easier than apply&#x2F;filter style of operations.<p>They amount to the same, but the explicit loop was much easier for me to understand (and I’m still not sure if one applies a function to a value or a value to a function, so I never remember if the function or the values go first in an apply filter call)</div><br/></div></div><div id="37158475" class="c"><input type="checkbox" id="c-37158475" checked=""/><div class="controls bullet"><span class="by">tlocke</span><span>|</span><a href="#37158877">prev</a><span>|</span><a href="#37154253">next</a><span>|</span><label class="collapse" for="c-37158475">[-]</label><label class="expand" for="c-37158475">[4 more]</label></div><br/><div class="children"><div class="content">Someone else has mentioned it, but I would have gone with:<p><pre><code>  sum(1 for age in ages if age &gt; 17)
</code></pre>
with the other method you&#x27;re treating a boolean as an int. Weak typing.</div><br/><div id="37158951" class="c"><input type="checkbox" id="c-37158951" checked=""/><div class="controls bullet"><span class="by">palotasb</span><span>|</span><a href="#37158475">parent</a><span>|</span><a href="#37158982">next</a><span>|</span><label class="collapse" for="c-37158951">[-]</label><label class="expand" for="c-37158951">[1 more]</label></div><br/><div class="children"><div class="content"><i>bool</i> is explicitly documented to be a subclass of <i>int</i> [1][2], so while it might be an obscure feature, or subjectively not someone&#x27;s preferred style, I don&#x27;t see any typing related issue. In general I don&#x27;t think that treating an object as if it were an instance of one of its base classes is weak typing.<p>[1]: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;functions.html?highlight=subclass#bool" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;functions.html?highlight=s...</a><p>[2]: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;stdtypes.html#boolean-values" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;stdtypes.html#boolean-valu...</a></div><br/></div></div><div id="37158982" class="c"><input type="checkbox" id="c-37158982" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37158475">parent</a><span>|</span><a href="#37158951">prev</a><span>|</span><a href="#37158908">next</a><span>|</span><label class="collapse" for="c-37158982">[-]</label><label class="expand" for="c-37158982">[1 more]</label></div><br/><div class="children"><div class="content">Its not weak typeing, bools are ints.<p>“I don’t know the type hierarchy used in language X” is not the same thing as “language X is weakly typed”.<p><pre><code>  Python 3.11.4 (tags&#x2F;v3.11.4:d2340ef, Jun  7 2023, 05:45:37) [MSC v.1934 64 bit 
  (AMD64)] on win32
  Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
  &gt;&gt;&gt; isinstance(True, int)
  True
  &gt;&gt;&gt; isinstance(False, int)
  True
  &gt;&gt;&gt; issubclass(bool, int)
  True</code></pre></div><br/></div></div><div id="37158908" class="c"><input type="checkbox" id="c-37158908" checked=""/><div class="controls bullet"><span class="by">psd1</span><span>|</span><a href="#37158475">parent</a><span>|</span><a href="#37158982">prev</a><span>|</span><a href="#37154253">next</a><span>|</span><label class="collapse" for="c-37158908">[-]</label><label class="expand" for="c-37158908">[1 more]</label></div><br/><div class="children"><div class="content">I agree with the improvement in readability but still like the bool&#x2F;int equivalence:<p><pre><code>    sum(int(age &gt; 17) for age in ages)
</code></pre>
Every nanosecond is vital!</div><br/></div></div></div></div><div id="37154253" class="c"><input type="checkbox" id="c-37154253" checked=""/><div class="controls bullet"><span class="by">tcoff91</span><span>|</span><a href="#37158475">prev</a><span>|</span><a href="#37154722">next</a><span>|</span><label class="collapse" for="c-37154253">[-]</label><label class="expand" for="c-37154253">[20 more]</label></div><br/><div class="children"><div class="content">I feel like this kind of operation on a list feels more naturally expressed by filtering the list and taking the length of the filtered list.<p>Like this line of JS feels so much easier to read than that line of python:<p><pre><code>    ages.filter(age =&gt; age &gt; 17).length
</code></pre>
Directly translating this approach to python:<p><pre><code>    len(list(filter(lambda age: (age &gt; 17), ages)))
</code></pre>
Although a better way to write this in python I guess would be using list comprehensions:<p><pre><code>    len([age for age in ages if age &gt; 17])
</code></pre>
which I feel is more readable (but less efficient) than the APL inspired approach. Overall, none of these python versions seem as readable to me as my JS one liner. Obviously if the function is on a hot path iterating and summing with a number is far more efficient versus filtering. In that case i&#x27;d probably still use something like reduce instead of summing booleans because the code would be more similar to other instances where you need to process a list to produce a scalar value but need to do something more complex than simply adding.</div><br/><div id="37158934" class="c"><input type="checkbox" id="c-37158934" checked=""/><div class="controls bullet"><span class="by">alanbernstein</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37158065">next</a><span>|</span><label class="collapse" for="c-37158934">[-]</label><label class="expand" for="c-37158934">[1 more]</label></div><br/><div class="children"><div class="content">I feel like the numpy version is most concise, most readable, and most array-ish:<p>np.sum(age&gt;17)<p>(Assumes age is a np.array)</div><br/></div></div><div id="37158065" class="c"><input type="checkbox" id="c-37158065" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37158934">prev</a><span>|</span><a href="#37158714">next</a><span>|</span><label class="collapse" for="c-37158065">[-]</label><label class="expand" for="c-37158065">[1 more]</label></div><br/><div class="children"><div class="content">Doing @WalterBright&#x27;s job for a second to let you know that in the D language, given a function that is defined as taking, say, a list as the first argument, it can be called either<p><pre><code>    myfun(list)
</code></pre>
or<p><pre><code>    list.myfun()
</code></pre>
and this applies without exception. This means a lot of C-library code gets easier to read when used from D:<p><pre><code>    Vector3 vec = (Vector3){ 1, 2, 3};
    Vector3 result = Vector3Add(vec, vec2);
</code></pre>
becomes<p><pre><code>    auto vec = Vector3(1, 2, 3);
    auto result = vec.Vector3Add(vec2);
</code></pre>
I know its slightly off topic, but I want more people to use D, I really prefer it to C, C++ and Rust.</div><br/></div></div><div id="37158714" class="c"><input type="checkbox" id="c-37158714" checked=""/><div class="controls bullet"><span class="by">marko-lev</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37158065">prev</a><span>|</span><a href="#37158978">next</a><span>|</span><label class="collapse" for="c-37158714">[-]</label><label class="expand" for="c-37158714">[1 more]</label></div><br/><div class="children"><div class="content">I like to leverage some FP to bring readability to python<p><pre><code>  from toolz import curried, pipe

  pipe(ages,
       curried.filter(lambda age: age &gt; 17),
       list,
       len)
</code></pre>
This way you can follow - vertically - what happens, where, and why.<p>You can make your own pipe function to avoid 3rd party dependencies<p><pre><code>  import functools
  pipe = lambda *args: functools.reduce(lambda acc, el: el(acc), args)</code></pre></div><br/></div></div><div id="37158978" class="c"><input type="checkbox" id="c-37158978" checked=""/><div class="controls bullet"><span class="by">drcongo</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37158714">prev</a><span>|</span><a href="#37155584">next</a><span>|</span><label class="collapse" for="c-37158978">[-]</label><label class="expand" for="c-37158978">[1 more]</label></div><br/><div class="children"><div class="content">Your list comprehension is how I would naturally write this, and to me seems the most readable - it&#x27;s almost like an English language sentence. The sum example in the article would probably be my second choice.</div><br/></div></div><div id="37155584" class="c"><input type="checkbox" id="c-37155584" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37158978">prev</a><span>|</span><a href="#37154880">next</a><span>|</span><label class="collapse" for="c-37155584">[-]</label><label class="expand" for="c-37155584">[2 more]</label></div><br/><div class="children"><div class="content">The blog starts out with mentioning other reduce operations in Python: &#x27;prod from the math module; min; max; any; all; and &quot;&quot;.join&#x27;. In APL those are:<p><pre><code>    ×&#x2F; product reduce
    ⌊&#x2F; min reduce
    ⌈&#x2F; max reduce
    ∨&#x2F; logical OR reduce (any bool set)
    ∧&#x2F; logical AND reduce (all bools set)
    ,&#x2F;  catenate reduce (join without spaces)
</code></pre>
These all show a pattern of connection clearly where the Python names don&#x27;t, that they are related operations; that suggests that you could put any function on the left or any kind of array on the right and see what happens. And they work over multidimensional arrays - and you can swap &#x2F; for ⌿ to reduce down columns instead of accross the rows.<p>Your rewritten Python and JS, by showing the operation as length instead of sum, and making a shorter filtered list, hide the connection even further instead of helping to reveal and clarify it.<p>&gt; &quot;<i>which I feel is more readable (but less efficient) than the APL inspired approach</i>&quot;<p>I know how to read it, but just look at:<p><pre><code>    age age ages age

    len age for age in ages if age
</code></pre>
what&#x27;s readable about so much repetition, what&#x27;s readable bout having to spot the single character plural change in the middle of 8 short words?<p><pre><code>    ([&gt;])
</code></pre>
that&#x27;s more symbols than the APL one has, the language people reject because of the heavy use of symbols(!). Why does the [] indicate loopy-listy code but so does &#x27;for&#x27;? In PowerShell arrays have a property .Count to use instead of Length - what&#x27;s readable about <i>counting</i> the number of ages by indirectly looking at the <i>length</i> of something? Is this &quot;it&#x27;s readable because I&#x27;m familiar with it&quot; rather than &quot;because it&#x27;s objectively readable&quot;?</div><br/><div id="37158698" class="c"><input type="checkbox" id="c-37158698" checked=""/><div class="controls bullet"><span class="by">kwertzzz</span><span>|</span><a href="#37154253">root</a><span>|</span><a href="#37155584">parent</a><span>|</span><a href="#37154880">next</a><span>|</span><label class="collapse" for="c-37158698">[-]</label><label class="expand" for="c-37158698">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly most (if not all) python examples also work in julia.
Instead of using sum one can also use count, which might be more readable:<p>julia&gt; count(age &gt; 17 for age in ages)<p>Or even shorter:<p>julia&gt; count(ages .&gt; 17)<p>Under the hood many of the functions are implemented using the reduce function (similar to &#x2F; in APL):<p>julia&gt; reduce(+,ages .&gt; 17)<p>I think many languages in data science have been influenced by APL. But sometimes this influence come from an intermediate language like matlab.</div><br/></div></div></div></div><div id="37154880" class="c"><input type="checkbox" id="c-37154880" checked=""/><div class="controls bullet"><span class="by">jph00</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37155584">prev</a><span>|</span><a href="#37158338">next</a><span>|</span><label class="collapse" for="c-37154880">[-]</label><label class="expand" for="c-37154880">[1 more]</label></div><br/><div class="children"><div class="content">It feels more natural to you because of familiarity. However, if you&#x27;ve learned Iverson Bracket notation in math (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Iverson_bracket" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Iverson_bracket</a>) then the APL approach will probably feel more natural, because it&#x27;s a more direct expression of the mathematical foundations. Of course, the actual APL version is by far the most natural once you&#x27;re familiar with the core ideas: +&#x2F;ages&gt;17</div><br/></div></div><div id="37155266" class="c"><input type="checkbox" id="c-37155266" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37158338">prev</a><span>|</span><a href="#37155408">next</a><span>|</span><label class="collapse" for="c-37155266">[-]</label><label class="expand" for="c-37155266">[1 more]</label></div><br/><div class="children"><div class="content">I felt the same way about Rust&#x27;s .await and .?; I think we&#x27;re gradually converging on the idea that postfix operators are the right way to do 1-argument functions. I&#x27;m not remotely convinced that RPN is a readable idea in general, but when we have a pipeline rather than a tree, writing it left-to-right is the winner.</div><br/></div></div><div id="37155408" class="c"><input type="checkbox" id="c-37155408" checked=""/><div class="controls bullet"><span class="by">veber-alex</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37155266">prev</a><span>|</span><a href="#37154783">next</a><span>|</span><label class="collapse" for="c-37155408">[-]</label><label class="expand" for="c-37155408">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Obviously if the function is on a hot path iterating and summing with a number is far more efficient versus filtering.<p>I got curious and checked this in Rust, the generated assembly is the same!<p><a href="https:&#x2F;&#x2F;rust.godbolt.org&#x2F;z&#x2F;jhGWdYPz1" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust.godbolt.org&#x2F;z&#x2F;jhGWdYPz1</a></div><br/><div id="37158283" class="c"><input type="checkbox" id="c-37158283" checked=""/><div class="controls bullet"><span class="by">proto_lambda</span><span>|</span><a href="#37154253">root</a><span>|</span><a href="#37155408">parent</a><span>|</span><a href="#37154783">next</a><span>|</span><label class="collapse" for="c-37158283">[-]</label><label class="expand" for="c-37158283">[1 more]</label></div><br/><div class="children"><div class="content">Because you&#x27;re not actually creating a filtered list, you&#x27;re just filtering an iterator.</div><br/></div></div></div></div><div id="37154783" class="c"><input type="checkbox" id="c-37154783" checked=""/><div class="controls bullet"><span class="by">adalacelove</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37155408">prev</a><span>|</span><a href="#37154596">next</a><span>|</span><label class="collapse" for="c-37154783">[-]</label><label class="expand" for="c-37154783">[4 more]</label></div><br/><div class="children"><div class="content">If ages is a numpy array instead of a list:<p><pre><code>    (ages &gt; 17).sum()</code></pre></div><br/><div id="37154922" class="c"><input type="checkbox" id="c-37154922" checked=""/><div class="controls bullet"><span class="by">dTal</span><span>|</span><a href="#37154253">root</a><span>|</span><a href="#37154783">parent</a><span>|</span><a href="#37154596">next</a><span>|</span><label class="collapse" for="c-37154922">[-]</label><label class="expand" for="c-37154922">[3 more]</label></div><br/><div class="children"><div class="content">Numpy is something close to APL semantics with Python syntax. There&#x27;s no doubt it was heavily inspired by APL. One could argue that numpy&#x27;s popularity vindicates the array model pioneered by APL, while driving a nail in the coffin of &quot;notation as a tool of thought&quot;, or APL&#x27;s version of it at any rate. Array programming has never been more popular but there&#x27;s no demand for APL syntax.</div><br/><div id="37157837" class="c"><input type="checkbox" id="c-37157837" checked=""/><div class="controls bullet"><span class="by">adalacelove</span><span>|</span><a href="#37154253">root</a><span>|</span><a href="#37154922">parent</a><span>|</span><a href="#37154596">next</a><span>|</span><label class="collapse" for="c-37157837">[-]</label><label class="expand" for="c-37157837">[2 more]</label></div><br/><div class="children"><div class="content">I think the key to array programming success was due to the possibility of having fast interpreted languages for numerical computing. I&#x27;m very used to programming in array languages (Matlab, Python, Julia and even Mathematica has lot of vectorized ops) and still I think a lot in terms of for loops.</div><br/><div id="37157994" class="c"><input type="checkbox" id="c-37157994" checked=""/><div class="controls bullet"><span class="by">sideshowb</span><span>|</span><a href="#37154253">root</a><span>|</span><a href="#37157837">parent</a><span>|</span><a href="#37154596">next</a><span>|</span><label class="collapse" for="c-37157994">[-]</label><label class="expand" for="c-37157994">[1 more]</label></div><br/><div class="children"><div class="content">This. Ideally we&#x27;d have jitted python loops be efficient. I love array syntax for simple examples but for more complex ops a loop is often clearer.</div><br/></div></div></div></div></div></div></div></div><div id="37154742" class="c"><input type="checkbox" id="c-37154742" checked=""/><div class="controls bullet"><span class="by">WhiteRice</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37154596">prev</a><span>|</span><a href="#37155367">next</a><span>|</span><label class="collapse" for="c-37154742">[-]</label><label class="expand" for="c-37154742">[2 more]</label></div><br/><div class="children"><div class="content">I didn’t see it in the article so I thought I would add,<p>The actual apl implementation:
+&#x2F;age&gt;17<p>Apl implementation of taking the length(shape) of the filtered list:
⍴(age&gt;17)&#x2F;age</div><br/><div id="37154765" class="c"><input type="checkbox" id="c-37154765" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37154253">root</a><span>|</span><a href="#37154742">parent</a><span>|</span><a href="#37155367">next</a><span>|</span><label class="collapse" for="c-37154765">[-]</label><label class="expand" for="c-37154765">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in there but near the end (80% or so of the way down the page). The article would benefit from moving that to the top and drawing the comparison to the APL code earlier.</div><br/></div></div></div></div><div id="37155367" class="c"><input type="checkbox" id="c-37155367" checked=""/><div class="controls bullet"><span class="by">Bostonian</span><span>|</span><a href="#37154253">parent</a><span>|</span><a href="#37154742">prev</a><span>|</span><a href="#37154722">next</a><span>|</span><label class="collapse" for="c-37155367">[-]</label><label class="expand" for="c-37155367">[1 more]</label></div><br/><div class="children"><div class="content">In Fortran it&#x27;s<p><pre><code>   count(ages &gt; 17)
</code></pre>
and storing the ages &gt; 17 is done with<p><pre><code>   is_adult = pack(ages, ages &gt; 17)</code></pre></div><br/></div></div></div></div><div id="37154722" class="c"><input type="checkbox" id="c-37154722" checked=""/><div class="controls bullet"><span class="by">max_</span><span>|</span><a href="#37154253">prev</a><span>|</span><a href="#37158097">next</a><span>|</span><label class="collapse" for="c-37154722">[-]</label><label class="expand" for="c-37154722">[2 more]</label></div><br/><div class="children"><div class="content">Kenneth E Iverson, the inventor of APL was truly a genius and his primary mission was about how to bridge the world of computing and mathematics.<p>To do this  he invented the APL notation.<p>If you find the article interesting, you might enjoy my curation of his work &quot;Math For The Layman&quot;  [0] where he introduces several math topics using this &quot;Iversonian&quot; thinking.<p>[1] Look this up to install the J interpreter.<p>[0]: <a href="https:&#x2F;&#x2F;asindu.xyz&#x2F;math-for-the-lay-man&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;asindu.xyz&#x2F;math-for-the-lay-man&#x2F;</a><p>[1]: <a href="https:&#x2F;&#x2F;code.jsoftware.com&#x2F;wiki&#x2F;System&#x2F;Installation&#x2F;J9.4&#x2F;Zips" rel="nofollow noreferrer">https:&#x2F;&#x2F;code.jsoftware.com&#x2F;wiki&#x2F;System&#x2F;Installation&#x2F;J9.4&#x2F;Zip...</a></div><br/><div id="37156544" class="c"><input type="checkbox" id="c-37156544" checked=""/><div class="controls bullet"><span class="by">gtani</span><span>|</span><a href="#37154722">parent</a><span>|</span><a href="#37158097">next</a><span>|</span><label class="collapse" for="c-37156544">[-]</label><label class="expand" for="c-37156544">[1 more]</label></div><br/><div class="children"><div class="content">Thanks ex-APL2 coder here, will look up For Layman site later.  My favorite APL story was somebody from morning yoga practice who grew up close to Yorktown Heights, in high school, his parents got him a job writing code for Iverson, which he described as a lot of fun.<p>It could have been a good career choice at one point, given how many FTE&#x27;s were devoted to the language at Merrill Lynch, Morgan Stanley, Lehman etc but I took the other fork</div><br/></div></div></div></div><div id="37158097" class="c"><input type="checkbox" id="c-37158097" checked=""/><div class="controls bullet"><span class="by">noobermin</span><span>|</span><a href="#37154722">prev</a><span>|</span><a href="#37155125">next</a><span>|</span><label class="collapse" for="c-37158097">[-]</label><label class="expand" for="c-37158097">[1 more]</label></div><br/><div class="children"><div class="content">I guess I&#x27;m a real computational scientist, because that first line to me wasn&#x27;t special, that&#x27;s how I&#x27;ve always written python.</div><br/></div></div><div id="37155125" class="c"><input type="checkbox" id="c-37155125" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37158097">prev</a><span>|</span><a href="#37154438">next</a><span>|</span><label class="collapse" for="c-37155125">[-]</label><label class="expand" for="c-37155125">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Another big thing that APL made me realise is that the Boolean values True&#x2F;False and the integers 1&#x2F;0 are tightly connected</i><p>Amen! It&#x27;s of course also a C language tenet, and a great one. Life is so much simpler and more flexible when true and false are 1 and 0. It drives me crazy when I need to use a language where the logical operators only work on bools and the arithmetic only on ints, or some coercions work and others don&#x27;t. When I incorporate somebody else&#x27;s code into mine, first thing I get rid of is anything called &quot;bool&quot;, a completely useless type. (as a nice side effect, that frees up the bool keyword for Boolean sets, which are quite useful)<p>a disappointment with unix is that process retval has this a bit backward, 0 is success, nonzero is failure (probably because errno does want for more bits than a singleton) but it&#x27;s easily enough remedied with a !<p>I did love everything else about APL for the brief time I used it long ago (except the difficulty of entering the symbols)</div><br/><div id="37158493" class="c"><input type="checkbox" id="c-37158493" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37155125">parent</a><span>|</span><a href="#37157851">next</a><span>|</span><label class="collapse" for="c-37158493">[-]</label><label class="expand" for="c-37158493">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Another big thing that APL made me realise is that the Boolean values True&#x2F;False and the integers 1&#x2F;0 are tightly connected<p>Not that tightly. Which is why C and Python, which both started out with boolean values just being integers, eventually retrofitted booleans to the language. Conversions come back to bite you.</div><br/></div></div><div id="37157851" class="c"><input type="checkbox" id="c-37157851" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#37155125">parent</a><span>|</span><a href="#37158493">prev</a><span>|</span><a href="#37155543">next</a><span>|</span><label class="collapse" for="c-37157851">[-]</label><label class="expand" for="c-37157851">[1 more]</label></div><br/><div class="children"><div class="content">(replying to myself to add) I do use hungarian, and I do use a bool-like abstract type, and it is indicated in my type calculus, but semantically my implementation allows for mixing true=1 and false=0 with other ints and arithmetic operators. I eschew implementations that do not have the convenient semantics which I feel introduces no confusion, only convenience</div><br/></div></div><div id="37155543" class="c"><input type="checkbox" id="c-37155543" checked=""/><div class="controls bullet"><span class="by">cirex-web</span><span>|</span><a href="#37155125">parent</a><span>|</span><a href="#37157851">prev</a><span>|</span><a href="#37154438">next</a><span>|</span><label class="collapse" for="c-37155543">[-]</label><label class="expand" for="c-37155543">[1 more]</label></div><br/><div class="children"><div class="content">* This statement is supported by the competitive programming community.</div><br/></div></div></div></div><div id="37154438" class="c"><input type="checkbox" id="c-37154438" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#37155125">prev</a><span>|</span><a href="#37158611">next</a><span>|</span><label class="collapse" for="c-37154438">[-]</label><label class="expand" for="c-37154438">[1 more]</label></div><br/><div class="children"><div class="content">Years ago I stumbled across <a href="http:&#x2F;&#x2F;nsl.com&#x2F;papers&#x2F;kisntlisp.htm" rel="nofollow noreferrer">http:&#x2F;&#x2F;nsl.com&#x2F;papers&#x2F;kisntlisp.htm</a> which is similar in sentiment.<p>I think APL&#x27;s ability to lift loop patterns into tensor patterns is interesting. It certainly results in a lot less syntax related to binding single values in an inner loop.</div><br/></div></div><div id="37158611" class="c"><input type="checkbox" id="c-37158611" checked=""/><div class="controls bullet"><span class="by">nmlhavw</span><span>|</span><a href="#37154438">prev</a><span>|</span><a href="#37157937">next</a><span>|</span><label class="collapse" for="c-37158611">[-]</label><label class="expand" for="c-37158611">[1 more]</label></div><br/><div class="children"><div class="content">What is it about Python? A pretty trivial feature that has been known for 30 years (and is present in NumPy) is made into a whole blog post, linked to APL to sound more interesting and is on the front page for a day.<p>If the allegedly &quot;most popular language&quot; (confirmed by Gartner and Netcraft) needs that much proselytizing, perhaps it is artificially popular? Or has voting rings?</div><br/></div></div><div id="37157937" class="c"><input type="checkbox" id="c-37157937" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#37158611">prev</a><span>|</span><a href="#37153890">next</a><span>|</span><label class="collapse" for="c-37157937">[-]</label><label class="expand" for="c-37157937">[1 more]</label></div><br/><div class="children"><div class="content">And hence the numpy API.</div><br/></div></div><div id="37153890" class="c"><input type="checkbox" id="c-37153890" checked=""/><div class="controls bullet"><span class="by">aynyc</span><span>|</span><a href="#37157937">prev</a><span>|</span><a href="#37153856">next</a><span>|</span><label class="collapse" for="c-37153890">[-]</label><label class="expand" for="c-37153890">[10 more]</label></div><br/><div class="children"><div class="content">I know nothing about APL. But I think I would write it the same way as the OP. I also think use len is better to convey counting operation:<p><i>len(age for age in ages if age &gt; 17)</i></div><br/><div id="37154024" class="c"><input type="checkbox" id="c-37154024" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37153890">parent</a><span>|</span><a href="#37154767">next</a><span>|</span><label class="collapse" for="c-37154024">[-]</label><label class="expand" for="c-37154024">[7 more]</label></div><br/><div class="children"><div class="content">I don’t think you can do that with a generator expression. You would have to write:<p><pre><code>  sum(1 for age in ages if age &gt; 17)</code></pre></div><br/><div id="37154635" class="c"><input type="checkbox" id="c-37154635" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#37153890">root</a><span>|</span><a href="#37154024">parent</a><span>|</span><a href="#37154139">next</a><span>|</span><label class="collapse" for="c-37154635">[-]</label><label class="expand" for="c-37154635">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re going to go that route, I think this makes more sense:<p><pre><code>    count_over_17 = [age &gt; 17 for age in ages].count(True)</code></pre></div><br/><div id="37154919" class="c"><input type="checkbox" id="c-37154919" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37153890">root</a><span>|</span><a href="#37154635">parent</a><span>|</span><a href="#37154139">next</a><span>|</span><label class="collapse" for="c-37154919">[-]</label><label class="expand" for="c-37154919">[1 more]</label></div><br/><div class="children"><div class="content">For a very large sequence traversing it to build a list and then traversing the list to do something you could do in one traversal without creating a list may be undesirable.</div><br/></div></div></div></div><div id="37154116" class="c"><input type="checkbox" id="c-37154116" checked=""/><div class="controls bullet"><span class="by">Nihilartikel</span><span>|</span><a href="#37153890">root</a><span>|</span><a href="#37154024">parent</a><span>|</span><a href="#37154139">prev</a><span>|</span><a href="#37154123">next</a><span>|</span><label class="collapse" for="c-37154116">[-]</label><label class="expand" for="c-37154116">[1 more]</label></div><br/><div class="children"><div class="content">It would eat ram at scale but you could wrap the gen expression with [] for a list comprehension and that would work.</div><br/></div></div><div id="37154614" class="c"><input type="checkbox" id="c-37154614" checked=""/><div class="controls bullet"><span class="by">aynyc</span><span>|</span><a href="#37153890">root</a><span>|</span><a href="#37154024">parent</a><span>|</span><a href="#37154123">prev</a><span>|</span><a href="#37154767">next</a><span>|</span><label class="collapse" for="c-37154614">[-]</label><label class="expand" for="c-37154614">[1 more]</label></div><br/><div class="children"><div class="content">ah, yes, of course, forgot the generator.</div><br/></div></div></div></div><div id="37154767" class="c"><input type="checkbox" id="c-37154767" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37153890">parent</a><span>|</span><a href="#37154024">prev</a><span>|</span><a href="#37153967">next</a><span>|</span><label class="collapse" for="c-37154767">[-]</label><label class="expand" for="c-37154767">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t call len on a gen exp, though you could define a count function. For an unsafe variant:<p><pre><code>  def count(it):
    return sum(1 for _ in it)
</code></pre>
Which is basically just putting a friendly name on the approach from the article.<p>For a safe version, you probably want to wrap it in another generator that bails with an exception at a specified size so you don’t risk an infinite loop.<p><pre><code>  def safe_count(it, limit=100):
    # returns None if actual length &gt; limit
    nit = zip(range(limit+1), it)
    if (l := sum(1 for _ in nit)) &lt;= limit:
      return l
</code></pre>
Of course, you can just convert to a list and return the length, but sometimes you don’t want to build a list in memory.</div><br/></div></div></div></div><div id="37153856" class="c"><input type="checkbox" id="c-37153856" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#37153890">prev</a><span>|</span><a href="#37154790">next</a><span>|</span><label class="collapse" for="c-37153856">[-]</label><label class="expand" for="c-37153856">[9 more]</label></div><br/><div class="children"><div class="content">The only thing this does for me is ask why its not named count instead of sum.</div><br/><div id="37154262" class="c"><input type="checkbox" id="c-37154262" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37153856">parent</a><span>|</span><a href="#37154591">next</a><span>|</span><label class="collapse" for="c-37154262">[-]</label><label class="expand" for="c-37154262">[2 more]</label></div><br/><div class="children"><div class="content">It is summing but being used for counting (in imitation of the same style from APL) via punning on True&#x2F;False as 1&#x2F;0.<p>Not what actually happens but conceptually:<p><pre><code>  ages = [17, 13, 18, 30, 12]
  sum(age &gt; 17 for age in ages)
  =&gt; sum([False, False, True, True, False])
  =&gt; sum([0, 0, 1, 1, 0])
  =&gt; 2 # via conventional summing
</code></pre>
Since True and False are 1 and 0 for arithmetic in Python, this is just a regular sum which also happens to produce a count.</div><br/><div id="37154913" class="c"><input type="checkbox" id="c-37154913" checked=""/><div class="controls bullet"><span class="by">naijaboiler</span><span>|</span><a href="#37153856">root</a><span>|</span><a href="#37154262">parent</a><span>|</span><a href="#37154591">next</a><span>|</span><label class="collapse" for="c-37154913">[-]</label><label class="expand" for="c-37154913">[1 more]</label></div><br/><div class="children"><div class="content">yeah if i ready the line using &quot;sum&quot;,  I would be expecting the result 48 (18+30) not 2</div><br/></div></div></div></div><div id="37154591" class="c"><input type="checkbox" id="c-37154591" checked=""/><div class="controls bullet"><span class="by">pavon</span><span>|</span><a href="#37153856">parent</a><span>|</span><a href="#37154262">prev</a><span>|</span><a href="#37154198">next</a><span>|</span><label class="collapse" for="c-37154591">[-]</label><label class="expand" for="c-37154591">[2 more]</label></div><br/><div class="children"><div class="content">numpy (which is inspired by Matlab which is inspired by APL) does indeed have a count_nonzero function, which is intended to be used in situations like this. Unfortunately, it (like most of numpy) doesn&#x27;t work with generators, just array-like objects (aka numpy arrays and python lists), so it has the same memory performance issues as filtering and using len.<p>If your input was a numpy array to begin with you could skip the array comprehension, and shorten it to numpy.count_nonzero(ages &gt; 17), since numpy automatically broadcasts the comparison operation to each element of the array.</div><br/><div id="37158868" class="c"><input type="checkbox" id="c-37158868" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#37153856">root</a><span>|</span><a href="#37154591">parent</a><span>|</span><a href="#37154198">next</a><span>|</span><label class="collapse" for="c-37158868">[-]</label><label class="expand" for="c-37158868">[1 more]</label></div><br/><div class="children"><div class="content">Here, is &quot;broadcasts&quot; like apply or map of functional programming?</div><br/></div></div></div></div><div id="37154198" class="c"><input type="checkbox" id="c-37154198" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37153856">parent</a><span>|</span><a href="#37154591">prev</a><span>|</span><a href="#37154606">next</a><span>|</span><label class="collapse" for="c-37154198">[-]</label><label class="expand" for="c-37154198">[1 more]</label></div><br/><div class="children"><div class="content">because sum([1, 2]) is 3 and not 2</div><br/></div></div><div id="37154606" class="c"><input type="checkbox" id="c-37154606" checked=""/><div class="controls bullet"><span class="by">heavyset_go</span><span>|</span><a href="#37153856">parent</a><span>|</span><a href="#37154198">prev</a><span>|</span><a href="#37153929">next</a><span>|</span><label class="collapse" for="c-37154606">[-]</label><label class="expand" for="c-37154606">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    from collections import Counter

    total = Counter(range(10)).total()
    assert total == 10</code></pre></div><br/></div></div><div id="37153929" class="c"><input type="checkbox" id="c-37153929" checked=""/><div class="controls bullet"><span class="by">scherlock</span><span>|</span><a href="#37153856">parent</a><span>|</span><a href="#37154606">prev</a><span>|</span><a href="#37153901">next</a><span>|</span><label class="collapse" for="c-37153929">[-]</label><label class="expand" for="c-37153929">[1 more]</label></div><br/><div class="children"><div class="content">Because what is happening I the list of ages is being transformed into a list of booleans where it&#x27;s true if the age is greater than 17.  This list of booleans is then turned into a list of integers where it&#x27;s 1 if true, 0 if false.  This list of integers is then being summed.</div><br/></div></div><div id="37153901" class="c"><input type="checkbox" id="c-37153901" checked=""/><div class="controls bullet"><span class="by">ok_dad</span><span>|</span><a href="#37153856">parent</a><span>|</span><a href="#37153929">prev</a><span>|</span><a href="#37154790">next</a><span>|</span><label class="collapse" for="c-37153901">[-]</label><label class="expand" for="c-37153901">[1 more]</label></div><br/><div class="children"><div class="content">In Python a Boolean true and false are often used in mathematical formulas, so they will often implicitly be coerced into the integers 1 and 0. Sum is the sum function, you can sum a sequence of numbers, but in this case it’s summing a bunch of Boolean values which are coerced to 1 and 0.</div><br/></div></div></div></div><div id="37154790" class="c"><input type="checkbox" id="c-37154790" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#37153856">prev</a><span>|</span><a href="#37153926">next</a><span>|</span><label class="collapse" for="c-37154790">[-]</label><label class="expand" for="c-37154790">[1 more]</label></div><br/><div class="children"><div class="content">This is completely off topic (though possibly still on the topic of maximal readability) but the correct way to express this logic is as follows:<p><pre><code>  age &gt;= 18
</code></pre>
If your code is specifically about the magical age of adulthood then it ought to include that age as a literal, somewhere.<p>It becomes more obvious when you consider replacing the inline literal with a named constant:<p><pre><code>  CHILD_UPTO = 17  # awkward
</code></pre>
compared with:<p><pre><code>  ADULT = 18  # oh the clarity
</code></pre>
My fellow turd polishers and I would probably also add a tiny type:<p><pre><code>  Age = int
  ADULT: Age = 18  # mwah!
</code></pre>
(The article was a good read, btw.)</div><br/></div></div><div id="37153926" class="c"><input type="checkbox" id="c-37153926" checked=""/><div class="controls bullet"><span class="by">ok_dad</span><span>|</span><a href="#37154790">prev</a><span>|</span><a href="#37154766">next</a><span>|</span><label class="collapse" for="c-37153926">[-]</label><label class="expand" for="c-37153926">[16 more]</label></div><br/><div class="children"><div class="content">I find that the more language you learn the better you can utilize all of them.<p>Also,  Python is a wonderful functional language when used functionally.</div><br/><div id="37154574" class="c"><input type="checkbox" id="c-37154574" checked=""/><div class="controls bullet"><span class="by">heavyset_go</span><span>|</span><a href="#37153926">parent</a><span>|</span><a href="#37154054">next</a><span>|</span><label class="collapse" for="c-37154574">[-]</label><label class="expand" for="c-37154574">[7 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s lack of multi-line anonymous functions is a hindrance to using it as a functional language, IMO.</div><br/><div id="37154956" class="c"><input type="checkbox" id="c-37154956" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37154574">parent</a><span>|</span><a href="#37154610">next</a><span>|</span><label class="collapse" for="c-37154956">[-]</label><label class="expand" for="c-37154956">[4 more]</label></div><br/><div class="children"><div class="content">Multi-line lambdas are fine: Python will accept newlines in certain parts of an expression, and you can use &#x27;\&#x27; for others; e.g.<p><pre><code>  f = lambda x: [
      x + y
      for y in range(x)
      if y % 2 == 0
  ]

  &gt;&gt;&gt; f(5)
  [5, 7, 9]
</code></pre>
Lambdas which perform multiple sequential steps are fine, since we can use tuples to evaluate expressions in order; e.g.<p><pre><code>  from sys import stdout
  g = lambda x: (
      stdout.write(&quot;Given {0}\n&quot;.format(repr(x))),
      x.append(42),
      stdout.write(&quot;Mutated to {0}\n&quot;.format(repr(x))),
      len(x)
  )[-1]

  &gt;&gt;&gt; my_list = [1, 2, 3]
  &gt;&gt;&gt; new_len = g(my_list)
  Given [1, 2, 3]
  Mutated to [1, 2, 3, 42]
  &gt;&gt;&gt; new_len
  4
  &gt;&gt;&gt; my_list
  [1, 2, 3, 42]
</code></pre>
The problem is that many things in Python require statements, and lambdas cannot contain <i>any</i>; not even one. For example, all of the following are single lines:<p><pre><code>  &gt;&gt;&gt; throw = lambda e: raise e
    File &quot;&lt;stdin&gt;&quot;, line 1
      throw = lambda e: raise e
                        ^^^^^
  SyntaxError: invalid syntax
  &gt;&gt;&gt; identity = lambda x: return x
    File &quot;&lt;stdin&gt;&quot;, line 1
      identity = lambda x: return x
                           ^^^^^^
  SyntaxError: invalid syntax
  &gt;&gt;&gt; abs = lambda n: -1 * (n if n &lt; 0 else return n)
    File &quot;&lt;stdin&gt;&quot;, line 1
      abs = lambda n: -1 * (n if n &lt; 0 else return n)
                                            ^^^^^^
  SyntaxError: invalid syntax
  &gt;&gt;&gt; repeat = lambda f, n: for _ in range(n): f()
    File &quot;&lt;stdin&gt;&quot;, line 1
      repeat = lambda f, n: for _ in range(n): f()
                            ^^^
  SyntaxError: invalid syntax
  &gt;&gt;&gt; set_key = lambda d, k, v: d[k] = v
    File &quot;&lt;stdin&gt;&quot;, line 1
      set_key = lambda d, k, v: d[k] = v
                ^^^^^^^^^^^^^^^^^^^^
  SyntaxError: cannot assign to lambda
  &gt;&gt;&gt; set_key = lambda d, k, v: (d[k] = v)
    File &quot;&lt;stdin&gt;&quot;, line 1
      set_key = lambda d, k, v: (d[k] = v)
                                 ^^^^
  SyntaxError: cannot assign to subscript here. Maybe you meant &#x27;==&#x27; instead of &#x27;=&#x27;?</code></pre></div><br/><div id="37155354" class="c"><input type="checkbox" id="c-37155354" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37154956">parent</a><span>|</span><a href="#37154610">next</a><span>|</span><label class="collapse" for="c-37155354">[-]</label><label class="expand" for="c-37155354">[3 more]</label></div><br/><div class="children"><div class="content">Neat.  I tried it with print(), works fine.<p>Don&#x27;t need return in a lambda.  Assignment now has the walrus.  Leaves raise and few other odds and ends.<p>Do believe you&#x27;ve cracked it!  Don&#x27;t think I&#x27;ll use it much, but you never know... in a pinch.</div><br/><div id="37155888" class="c"><input type="checkbox" id="c-37155888" checked=""/><div class="controls bullet"><span class="by">chriswarbo</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37155354">parent</a><span>|</span><a href="#37154610">next</a><span>|</span><label class="collapse" for="c-37155888">[-]</label><label class="expand" for="c-37155888">[2 more]</label></div><br/><div class="children"><div class="content">Ah yes, I&#x27;ve been doing this with stdout.write since Python 2; it didn&#x27;t occur to me that when Python 3 turned print into a function that would make it usable in lambdas!<p>You&#x27;re right that the walrus makes assignment more usable; we can also call methods like .__setitem__ to get similar effects. Unfortunately the walrus seems to suffer the same broken&#x2F;ambiguous scoping as assignment statements, e.g.<p><pre><code>  &gt;&gt;&gt; a = 1
  &gt;&gt;&gt; b = lambda: (print(a), a := 2)
  &gt;&gt;&gt; b()
  Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;lambda&gt;
  UnboundLocalError: cannot access local variable &#x27;a&#x27; where it is not associated with a value
</code></pre>
&gt; Don&#x27;t need return in a lambda<p>`return` <i>is</i> needed for early returns. Notice that my `abs` example is trying to do that with `return n` (to skip the `-1 *` operation, since `n` is non-negative in that case).<p>&gt; Leaves raise and a few other odds and ends<p>Off the top of my head: yield, match, def, import, class, with, for, while, assert, try, except, async, await.</div><br/><div id="37156243" class="c"><input type="checkbox" id="c-37156243" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37155888">parent</a><span>|</span><a href="#37154610">next</a><span>|</span><label class="collapse" for="c-37156243">[-]</label><label class="expand" for="c-37156243">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    b = lambda: (a := 2, print(a))
</code></pre>
Hmm, need to put the assignment before.  Can&#x27;t access nonlocals unless you only read the the var and don&#x27;t write to it.  That&#x27;s the way functions in python work as well.</div><br/></div></div></div></div></div></div></div></div><div id="37154610" class="c"><input type="checkbox" id="c-37154610" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37154574">parent</a><span>|</span><a href="#37154956">prev</a><span>|</span><a href="#37154657">next</a><span>|</span><label class="collapse" for="c-37154610">[-]</label><label class="expand" for="c-37154610">[1 more]</label></div><br/><div class="children"><div class="content">Most functional languages don&#x27;t have statements at all, and Python&#x27;s anonymous functions can, as most, handle any single expression, regardless of complexity or size.<p>Python having a statement heavy syntax and making complex expressions (while possible) awkward is the problem with its anonymous functions, not the fact that its anonymous functions are limited to a single expression.</div><br/></div></div><div id="37154657" class="c"><input type="checkbox" id="c-37154657" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37154574">parent</a><span>|</span><a href="#37154610">prev</a><span>|</span><a href="#37154054">next</a><span>|</span><label class="collapse" for="c-37154657">[-]</label><label class="expand" for="c-37154657">[1 more]</label></div><br/><div class="children"><div class="content">I take the Beyonce approach to functions: if you like it you should have put a name on it.</div><br/></div></div></div></div><div id="37154054" class="c"><input type="checkbox" id="c-37154054" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#37153926">parent</a><span>|</span><a href="#37154574">prev</a><span>|</span><a href="#37154810">next</a><span>|</span><label class="collapse" for="c-37154054">[-]</label><label class="expand" for="c-37154054">[1 more]</label></div><br/><div class="children"><div class="content">It really is a strong lesson. Every language will shift and twist your mind and expand your horizon. You might hate your colleagues then though.</div><br/></div></div><div id="37154810" class="c"><input type="checkbox" id="c-37154810" checked=""/><div class="controls bullet"><span class="by">nbelaf</span><span>|</span><a href="#37153926">parent</a><span>|</span><a href="#37154054">prev</a><span>|</span><a href="#37154766">next</a><span>|</span><label class="collapse" for="c-37154810">[-]</label><label class="expand" for="c-37154810">[7 more]</label></div><br/><div class="children"><div class="content">It is a poor functional language. List comprehensions (from Haskell) are nice, but the rest is garbage.<p>Crippled lambdas, no currying, &quot;match&quot; is a clumsy statement, weird name spaces and a rigid whitespace syntax. No real immutability.</div><br/><div id="37155467" class="c"><input type="checkbox" id="c-37155467" checked=""/><div class="controls bullet"><span class="by">bloaf</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37154810">parent</a><span>|</span><a href="#37158523">next</a><span>|</span><label class="collapse" for="c-37155467">[-]</label><label class="expand" for="c-37155467">[1 more]</label></div><br/><div class="children"><div class="content">I use the toolz package for currying and a few other conveniences.<p>That plus named tuples and a little discipline gets me 80+% of the benefits of pure functional.<p>The biggest thing to me wasn&#x27;t in your list: lack of tail call optimization means you have to be a bit careful about where you use recursion.<p>I personally think long anonymous functions are an anti-pattern, naming your functionality is great for readability. I learned this from Wolfram language which makes heavy use of anonymous functions, I would often find myself returning from lunch to find my code which was perfectly clear that morning had become unintelligible.  Today I try to limit anonymous functions to re-ordering arguments or &quot;picking&quot; functions that pull simple values out of more complicated data structures.</div><br/></div></div><div id="37158523" class="c"><input type="checkbox" id="c-37158523" checked=""/><div class="controls bullet"><span class="by">yakshaving_jgt</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37154810">parent</a><span>|</span><a href="#37155467">prev</a><span>|</span><a href="#37154835">next</a><span>|</span><label class="collapse" for="c-37158523">[-]</label><label class="expand" for="c-37158523">[2 more]</label></div><br/><div class="children"><div class="content">IIRC, Haskell’s list comprehensions are lifted from Erlang.</div><br/><div id="37158989" class="c"><input type="checkbox" id="c-37158989" checked=""/><div class="controls bullet"><span class="by">pedrow</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37158523">parent</a><span>|</span><a href="#37154835">next</a><span>|</span><label class="collapse" for="c-37158989">[-]</label><label class="expand" for="c-37158989">[1 more]</label></div><br/><div class="children"><div class="content">I believe they were based on Miranda[0] (1985) but they have a longer history than that, maybe under a different name.<p>[0]:<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Miranda_(programming_language)#Overview" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Miranda_(programming_language)...</a></div><br/></div></div></div></div><div id="37154835" class="c"><input type="checkbox" id="c-37154835" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37154810">parent</a><span>|</span><a href="#37158523">prev</a><span>|</span><a href="#37154766">next</a><span>|</span><label class="collapse" for="c-37154835">[-]</label><label class="expand" for="c-37154835">[3 more]</label></div><br/><div class="children"><div class="content">functools.partial is currying, right?</div><br/><div id="37154930" class="c"><input type="checkbox" id="c-37154930" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37154835">parent</a><span>|</span><a href="#37154766">next</a><span>|</span><label class="collapse" for="c-37154930">[-]</label><label class="expand" for="c-37154930">[2 more]</label></div><br/><div class="children"><div class="content">No, it’s partial application. Currying is when a 1-arity function either returns another 1-arity function or the result.</div><br/><div id="37154988" class="c"><input type="checkbox" id="c-37154988" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#37153926">root</a><span>|</span><a href="#37154930">parent</a><span>|</span><a href="#37154766">next</a><span>|</span><label class="collapse" for="c-37154988">[-]</label><label class="expand" for="c-37154988">[1 more]</label></div><br/><div class="children"><div class="content">hmm... that just sounds like a specific case of recursive application of partial functions?  At least that&#x27;s how I interepret the wikipedia explanation:<p>&quot;As such, curry is more suitably defined as an operation which, in many theoretical cases, is often applied recursively, but which is theoretically indistinguishable (when considered as an operation) from a partial application.&quot;<p>(while I see partial as having value, I&#x27;m struggling to see if currying would really be a useful addition to a scripting language)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37154890" class="c"><input type="checkbox" id="c-37154890" checked=""/><div class="controls bullet"><span class="by">narrator</span><span>|</span><a href="#37154766">prev</a><span>|</span><label class="collapse" for="c-37154890">[-]</label><label class="expand" for="c-37154890">[4 more]</label></div><br/><div class="children"><div class="content">APL makes a lot of sense in the era of 110 baud teletypes in which it was invented.  Brevity was of extreme importance in that era.</div><br/><div id="37157035" class="c"><input type="checkbox" id="c-37157035" checked=""/><div class="controls bullet"><span class="by">DougMerritt</span><span>|</span><a href="#37154890">parent</a><span>|</span><a href="#37155775">next</a><span>|</span><label class="collapse" for="c-37157035">[-]</label><label class="expand" for="c-37157035">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re saying that brevity for typing on 110 baud teletypes was the primary reason for the density of APL operators, but that&#x27;s not historically true. For one thing Iverson and pretty much everyone else high profile in the APL community has said that the conciseness was itself a major part of the power of APL.<p>Further proof of that: APL began as a mathematical notation on chalkboards, and only later was it decided to implement as a programming language.<p>As an aside, Unix also began in the era of 110 baud teletypes, which motivated brevity of many of its common commands (ls, cat, etc), and those brief names have been criticized a lot -- but people still use Unix&#x2F;Linux; the brevity is a side issue, not a deciding point. As usual with most things.</div><br/></div></div><div id="37155775" class="c"><input type="checkbox" id="c-37155775" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#37154890">parent</a><span>|</span><a href="#37157035">prev</a><span>|</span><label class="collapse" for="c-37155775">[-]</label><label class="expand" for="c-37155775">[2 more]</label></div><br/><div class="children"><div class="content">And how many Baud do you type at today?</div><br/><div id="37156297" class="c"><input type="checkbox" id="c-37156297" checked=""/><div class="controls bullet"><span class="by">narrator</span><span>|</span><a href="#37154890">root</a><span>|</span><a href="#37155775">parent</a><span>|</span><label class="collapse" for="c-37156297">[-]</label><label class="expand" for="c-37156297">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve gotten paid for working with APL code. Math professors who aren&#x27;t great at typing love that stuff, but code has to be maintained and some mild verbosity, as python has, is a very reasonable price to pay for that maintainability.<p>If this was punch card input, or 110 baud teletypes, where program listings come back at a snails pace and use paper, then APL is great for that.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>