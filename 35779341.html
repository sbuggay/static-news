<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683018043545" as="style"/><link rel="stylesheet" href="styles.css?v=1683018043545"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://htmx.org/essays/two-approaches-to-decoupling/">Two Approaches to Decoupling</a> <span class="domain">(<a href="https://htmx.org">htmx.org</a>)</span></div><div class="subtext"><span>telotortium</span> | <span>34 comments</span></div><br/><div><div id="35783210" class="c"><input type="checkbox" id="c-35783210" checked=""/><div class="controls bullet"><span class="by">mathgladiator</span><span>|</span><a href="#35784765">next</a><span>|</span><label class="collapse" for="c-35783210">[-]</label><label class="expand" for="c-35783210">[9 more]</label></div><br/><div class="children"><div class="content">Another approach (which I&#x27;d love to see others pick up on) is treating the client as a dumb proxy to the server. This is the philosophy I&#x27;m embracing, and it&#x27;s wonderful!<p>If you buy into the philosophy that the UI is a deterministic function of server state and ephemeral view state (ui = f(state, viewstate)), then the core question is medium.<p>With browser, embracing HTML is the only sane choice for business. As such, the function at hand needs to convert those two state objects into a blob of HTML. This is the classic HTML template problem.<p>However, if you treat the state(s) as streams, then you&#x27;ll be where I am at in building a differential HTML engine. I&#x27;m calling this first (big) version: RxHTML ( <a href="https:&#x2F;&#x2F;book.adama-platform.com&#x2F;rxhtml&#x2F;ref.html" rel="nofollow">https:&#x2F;&#x2F;book.adama-platform.com&#x2F;rxhtml&#x2F;ref.html</a> ) and it uses my modified JSON delta format ( <a href="https:&#x2F;&#x2F;book.adama-platform.com&#x2F;reference&#x2F;deltas.html" rel="nofollow">https:&#x2F;&#x2F;book.adama-platform.com&#x2F;reference&#x2F;deltas.html</a> ).<p>The spiritual design question is what minimal things does HTML need with reactive data binding.<p>It&#x27;s pretty awesome to be able to debug a user experience by having 4 views up at once, and then see a real-time update on all 4 views at once.<p>The tech at this time is beta quality, but I&#x27;m working through this as I build a real SaaS for everyday people. I&#x27;m having a bunch of fun especially as tailwind dramatically simplifies the styling.</div><br/><div id="35783677" class="c"><input type="checkbox" id="c-35783677" checked=""/><div class="controls bullet"><span class="by">bullfightonmars</span><span>|</span><a href="#35783210">parent</a><span>|</span><a href="#35783622">next</a><span>|</span><label class="collapse" for="c-35783677">[-]</label><label class="expand" for="c-35783677">[2 more]</label></div><br/><div class="children"><div class="content">This sounds similar to what the Phoenix team has done with LiveView. Is it a flavor of the same idea or are there other concepts I am missing. Can this also be rendered&#x2F;hydrated by the server?</div><br/><div id="35784419" class="c"><input type="checkbox" id="c-35784419" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#35783210">root</a><span>|</span><a href="#35783677">parent</a><span>|</span><a href="#35783622">next</a><span>|</span><label class="collapse" for="c-35784419">[-]</label><label class="expand" for="c-35784419">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this was my first thought as well. <a href="https:&#x2F;&#x2F;www.phoenixframework.org" rel="nofollow">https:&#x2F;&#x2F;www.phoenixframework.org</a></div><br/></div></div></div></div><div id="35783622" class="c"><input type="checkbox" id="c-35783622" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#35783210">parent</a><span>|</span><a href="#35783677">prev</a><span>|</span><a href="#35783329">next</a><span>|</span><label class="collapse" for="c-35783622">[-]</label><label class="expand" for="c-35783622">[2 more]</label></div><br/><div class="children"><div class="content">This approach is very old indeed, pioneered by first video terminals (as opposed to teletypes).<p>It assumes always-online, synchronous operation.<p>How do you in your model implement an auto-completion list? Do you allow it to re-generate not on each keystroke?</div><br/><div id="35784296" class="c"><input type="checkbox" id="c-35784296" checked=""/><div class="controls bullet"><span class="by">mathgladiator</span><span>|</span><a href="#35783210">root</a><span>|</span><a href="#35783622">parent</a><span>|</span><a href="#35783329">next</a><span>|</span><label class="collapse" for="c-35784296">[-]</label><label class="expand" for="c-35784296">[1 more]</label></div><br/><div class="children"><div class="content">Auto-completion would update the view state which is gossiped back to the server, and the server can regenerate the list.</div><br/></div></div></div></div><div id="35783329" class="c"><input type="checkbox" id="c-35783329" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#35783210">parent</a><span>|</span><a href="#35783622">prev</a><span>|</span><a href="#35784765">next</a><span>|</span><label class="collapse" for="c-35783329">[-]</label><label class="expand" for="c-35783329">[4 more]</label></div><br/><div class="children"><div class="content">Your philosophy is nothing new. It’s called REST. Yes, REST must be hypermedia-driven and if your server and client “speak” the same media type, your client doesn’t have to keep state. Add HTTP caching to the mix and the result is beautiful. Of course, it’s easier to concatenate strings and write stores on the client. Or is it?</div><br/><div id="35783345" class="c"><input type="checkbox" id="c-35783345" checked=""/><div class="controls bullet"><span class="by">mathgladiator</span><span>|</span><a href="#35783210">root</a><span>|</span><a href="#35783329">parent</a><span>|</span><a href="#35784765">next</a><span>|</span><label class="collapse" for="c-35783345">[-]</label><label class="expand" for="c-35783345">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the old world, and the world I want has limited JavaScript yet fully interactive products.</div><br/><div id="35783861" class="c"><input type="checkbox" id="c-35783861" checked=""/><div class="controls bullet"><span class="by">danparsonson</span><span>|</span><a href="#35783210">root</a><span>|</span><a href="#35783345">parent</a><span>|</span><a href="#35784765">next</a><span>|</span><label class="collapse" for="c-35783861">[-]</label><label class="expand" for="c-35783861">[2 more]</label></div><br/><div class="children"><div class="content">REST with JQuery ;-)</div><br/><div id="35784330" class="c"><input type="checkbox" id="c-35784330" checked=""/><div class="controls bullet"><span class="by">mathgladiator</span><span>|</span><a href="#35783210">root</a><span>|</span><a href="#35783861">parent</a><span>|</span><a href="#35784765">next</a><span>|</span><label class="collapse" for="c-35784330">[-]</label><label class="expand" for="c-35784330">[1 more]</label></div><br/><div class="children"><div class="content">JQuery doesn&#x27;t solve reactive data, and it&#x27;s like building an interactive product in assembly.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35784765" class="c"><input type="checkbox" id="c-35784765" checked=""/><div class="controls bullet"><span class="by">000ooo000</span><span>|</span><a href="#35783210">prev</a><span>|</span><a href="#35784738">next</a><span>|</span><label class="collapse" for="c-35784765">[-]</label><label class="expand" for="c-35784765">[1 more]</label></div><br/><div class="children"><div class="content">Am I stupid? Is the crux of the article that HTML&#x2F;hypermedia has built-in representations for API items such as links to other resources (i.e. as in the examples of the article), but JSON (for e.g.) doesn&#x27;t. Therefore, using this &#x27;standard&#x27; schema decouples your application components because one (e.g. the frontend) doesn&#x27;t need to understand a particular, custom schema (re)implemented in nonhypermedia?</div><br/></div></div><div id="35784738" class="c"><input type="checkbox" id="c-35784738" checked=""/><div class="controls bullet"><span class="by">ChicagoDave</span><span>|</span><a href="#35784765">prev</a><span>|</span><a href="#35783781">next</a><span>|</span><label class="collapse" for="c-35784738">[-]</label><label class="expand" for="c-35784738">[1 more]</label></div><br/><div class="children"><div class="content">Two apis: a write interface and a read model interface. Read models are easy to maintain and there is no coupling. The ui asks for a bunch of data and we don’t care what that model looks like. We use events to update and cache read models.<p>We do care about commands that add and change state. Those are simple apis that have strict property requirements.<p>Also GraphQL is a horrible invention for quick and dirty work with no regard for long term maintenance. You’d be begging for an eventual big ball of mud.</div><br/></div></div><div id="35783781" class="c"><input type="checkbox" id="c-35783781" checked=""/><div class="controls bullet"><span class="by">dafelst</span><span>|</span><a href="#35784738">prev</a><span>|</span><a href="#35784237">next</a><span>|</span><label class="collapse" for="c-35783781">[-]</label><label class="expand" for="c-35783781">[1 more]</label></div><br/><div class="children"><div class="content">It is bizarre to see people rediscovering the same stuff that we were doing during the early days of the dynamic web and the web application (probably circa 2000-2003 ish?) with partial rendering via API endpoints.<p>What is old is new again and all that.</div><br/></div></div><div id="35784237" class="c"><input type="checkbox" id="c-35784237" checked=""/><div class="controls bullet"><span class="by">nologic01</span><span>|</span><a href="#35783781">prev</a><span>|</span><a href="#35783072">next</a><span>|</span><label class="collapse" for="c-35784237">[-]</label><label class="expand" for="c-35784237">[2 more]</label></div><br/><div class="children"><div class="content">&gt;It would be cumbersome and error-prone to try to download this HTML, parse it and try to extract information from it<p>This is the crux of the problem. Also the reason XML fell out of favor and lead to a massive and still incomplete reinvention of the wheel in the form of JSON schema etc.<p>Imagine a client side programming language for which a valid html snippet is simply the serialization of an object. And vice versa. No parsing required.<p>The point is that much of the web has been shaped by the adoption of javascript as the exclusive browser side programming language.</div><br/><div id="35784669" class="c"><input type="checkbox" id="c-35784669" checked=""/><div class="controls bullet"><span class="by">evnix</span><span>|</span><a href="#35784237">parent</a><span>|</span><a href="#35783072">next</a><span>|</span><label class="collapse" for="c-35784669">[-]</label><label class="expand" for="c-35784669">[1 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s interesting how XML&#x2F;XHTML was both data and presentation, we completely gave that up for a much inferior JSON format.<p>Most of this was due to the overuse of XML, but it seems we are heading in that direction with either JSON or YAML everywhere these days.<p>The usual complaint is XML is bloated, but it is really how you write it,<p>{ &quot;Name&quot;:&quot;John&quot;, &quot;age&quot;:20}<p>Vs<p>&lt;name=&quot;John&quot; age=&quot;20&quot; &#x2F;&gt;<p>and XML gives you both types and presentation with DTD and XSLT</div><br/></div></div></div></div><div id="35783072" class="c"><input type="checkbox" id="c-35783072" checked=""/><div class="controls bullet"><span class="by">hakunin</span><span>|</span><a href="#35784237">prev</a><span>|</span><a href="#35784107">next</a><span>|</span><label class="collapse" for="c-35783072">[-]</label><label class="expand" for="c-35783072">[1 more]</label></div><br/><div class="children"><div class="content">One advantage of the &quot;Another Solution&quot; brought up in the article is that the code you write to create JSON for your web pages can be in large part reused for your mobile API. Certainly mobile screens are shaped differently, but not entirely. The trick is to abstract JSON-rendering logic in a way that lets you reshuffle bits and pieces for your mobile.<p>Disclaimer: I wrote the linked article for that solution.</div><br/></div></div><div id="35784107" class="c"><input type="checkbox" id="c-35784107" checked=""/><div class="controls bullet"><span class="by">iddan</span><span>|</span><a href="#35783072">prev</a><span>|</span><a href="#35783882">next</a><span>|</span><label class="collapse" for="c-35784107">[-]</label><label class="expand" for="c-35784107">[1 more]</label></div><br/><div class="children"><div class="content">The argument against GraphQL in this article (and the article is linked to) is hand-wavy. It just says GraphQL is not secure without going into why and the example is: exposing a field on a record that you shouldn’t - which can happen in REST too! Especially  if you are implementing something like JSON API includes[0]. After building frontend for 8 years GraphQL seems like the most scalable solution if you have a large dynamic frontend app. The approach of coupled server (whether it’s htmx or Remix or Rails for that matter) works as well but as the article mentions it makes you build another API for any other client.<p>0: <a href="https:&#x2F;&#x2F;jsonapi.org&#x2F;format&#x2F;#fetching-includes" rel="nofollow">https:&#x2F;&#x2F;jsonapi.org&#x2F;format&#x2F;#fetching-includes</a></div><br/></div></div><div id="35783882" class="c"><input type="checkbox" id="c-35783882" checked=""/><div class="controls bullet"><span class="by">whacked_new</span><span>|</span><a href="#35784107">prev</a><span>|</span><a href="#35784049">next</a><span>|</span><label class="collapse" for="c-35783882">[-]</label><label class="expand" for="c-35783882">[1 more]</label></div><br/><div class="children"><div class="content">Most of the discussions about approaches are about shifting the locus of &quot;common language&quot; at a particular point between the producer and the consumer. The common language is basically a codified description of the data that is highly (ideally always) predictable, so that the producer and consumer both speak that language at all times at the boundary of information exchange between the 2 systems.<p>Something like RPC nudges towards the producer (or backend); graphql moves it to the consumer (or frontend).<p>A different way is to not look at this as a line of information flow between 2 points, by introducing a 3rd party, an impartial standards body. Maybe it&#x27;s just a semantic or procedural difference, but when the locus is defined at the meta-architecture level there&#x27;s no more room for discussion about exactly where you place the locus. Pay the vendor before you ship, or pay the courier when you receive? Neither: introduce an escrow.</div><br/></div></div><div id="35784049" class="c"><input type="checkbox" id="c-35784049" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#35783882">prev</a><span>|</span><a href="#35782950">next</a><span>|</span><label class="collapse" for="c-35784049">[-]</label><label class="expand" for="c-35784049">[1 more]</label></div><br/><div class="children"><div class="content">This article is so hard to parse. What exactly are the requirements of their desired api solution, both functional and non-functional and how exactly does each approach solve them?<p>Instead, it’s a meandering journey to their already chosen solution.<p>I can’t tell what their objection to graphql is and why hypermedia API’s are less of a security concern.<p>And their example with json API’s and close coupling doesn’t address the fact that adding a field doesn’t break backwards compatibility, and even if you do need to spin up a new api, any competent architecture will separate rendering an api from the business logic to generate its data, so standing up a new api variation won’t be a huge amount of work.</div><br/></div></div><div id="35782950" class="c"><input type="checkbox" id="c-35782950" checked=""/><div class="controls bullet"><span class="by">dack</span><span>|</span><a href="#35784049">prev</a><span>|</span><a href="#35783569">next</a><span>|</span><label class="collapse" for="c-35782950">[-]</label><label class="expand" for="c-35782950">[4 more]</label></div><br/><div class="children"><div class="content">I am probably misunderstanding the article, but as far as I can tell, the two ways discussed are &quot;JSON API like almost everybody does&quot; and &quot;do server-side rendering and call it the API&quot;.<p>Not to say it&#x27;s wrong to do server-side rendering of the frontend, but I got the impression that the article wanted to make a distinction that I&#x27;m not seeing.</div><br/><div id="35782991" class="c"><input type="checkbox" id="c-35782991" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#35782950">parent</a><span>|</span><a href="#35783569">next</a><span>|</span><label class="collapse" for="c-35782991">[-]</label><label class="expand" for="c-35782991">[3 more]</label></div><br/><div class="children"><div class="content">server side rendering (that is, returning HTML) <i>is</i> an API, it&#x27;s just that it&#x27;s a hypermedia API (poor hypermedia, can&#x27;t get no respect) rather than a data API, intended to be consumed by a hypermedia client (e.g. a web browser) and revealing&#x2F;affording further API navigation via hypermedia controls (e.g. links)<p>hypermedia APIs have not proven to be good data APIs, but they have proven to be excellent at surviving change within a larger hypermedia system (like the web)<p>in this article I&#x27;m trying to show why, despite the promise of decoupling that comes with a generic JSON Data API, it is hypermedia APIs (with tight server&#x2F;front end coupling) that survive change better, due to the uniform interface of REST</div><br/><div id="35783527" class="c"><input type="checkbox" id="c-35783527" checked=""/><div class="controls bullet"><span class="by">wpietri</span><span>|</span><a href="#35782950">root</a><span>|</span><a href="#35782991">parent</a><span>|</span><a href="#35783437">next</a><span>|</span><label class="collapse" for="c-35783527">[-]</label><label class="expand" for="c-35783527">[1 more]</label></div><br/><div class="children"><div class="content">Thanks so much for this article. I have something that I want to try out HTMX on and this really clarified some things for me.<p>I particularly liked the bit about the way that the JSON approach, decoupled in theory, often ends up being tightly coupled in practice, such that you keep having to change both at once. And many places are structured such that you need two people or even two teams to make a single change. That doesn&#x27;t sound decoupled at all!<p>I&#x27;m excited to see how it is to give on that in-practice-imaginary decoupling and try for HATOEAS at the fractions-of-a-page level that HTMX looks to enable.</div><br/></div></div><div id="35783437" class="c"><input type="checkbox" id="c-35783437" checked=""/><div class="controls bullet"><span class="by">jsyolo</span><span>|</span><a href="#35782950">root</a><span>|</span><a href="#35782991">parent</a><span>|</span><a href="#35783527">prev</a><span>|</span><a href="#35783569">next</a><span>|</span><label class="collapse" for="c-35783437">[-]</label><label class="expand" for="c-35783437">[1 more]</label></div><br/><div class="children"><div class="content"><i>and revealing&#x2F;affording further API navigation via hypermedia controls (e.g. links)</i><p>I haven&#x27;t a hard time understanding the utility of this, the article gives an example (removing ability of transfers), but why would a webpage need those hypermedia controls in the response if they are already encoded in the API of the business logic? for ex: The business logic tells the presentation layer, &quot;if X field is true, disable transfers button&quot;.</div><br/></div></div></div></div></div></div><div id="35783569" class="c"><input type="checkbox" id="c-35783569" checked=""/><div class="controls bullet"><span class="by">imjonse</span><span>|</span><a href="#35782950">prev</a><span>|</span><a href="#35782922">next</a><span>|</span><label class="collapse" for="c-35783569">[-]</label><label class="expand" for="c-35783569">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Well, let’s say that we wish to remove the ability to transfer money from our bank to other banks as well as the ability to close accounts.[...] You can see that in this response, links for those two actions have been removed from the HTML.&quot;<p>This makes me think about server functionality that is not exposed in the web app but it&#x27;s still there, with potential security implications. An instance of the more generic case of client functionality not being in sync with server functionality of which client-only form validation is another scenario.</div><br/></div></div><div id="35782922" class="c"><input type="checkbox" id="c-35782922" checked=""/><div class="controls bullet"><span class="by">JerryWebb</span><span>|</span><a href="#35783569">prev</a><span>|</span><a href="#35783416">next</a><span>|</span><label class="collapse" for="c-35782922">[-]</label><label class="expand" for="c-35782922">[5 more]</label></div><br/><div class="children"><div class="content">Interesting idea! However it will be very expensive to store all of this on a CDN.<p>The problem is users will interact with a majority of (get) APIs through a CDN and as developers we should reduce unnecessary data sitting in the CDN because it costs quite alot of money to serve.<p>For example if a CDN is returning JSON data {name: “Bart”} were only paying for 50 bytes or so of data transfer. BUT if instead we convert this to HTML and serve it, we would be 10x (or more)the data stored on the CDN to serve that data.<p>I don’t see a strong argument for paying 10x more to serve data as HTML.</div><br/><div id="35782996" class="c"><input type="checkbox" id="c-35782996" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#35782922">parent</a><span>|</span><a href="#35783243">next</a><span>|</span><label class="collapse" for="c-35782996">[-]</label><label class="expand" for="c-35782996">[1 more]</label></div><br/><div class="children"><div class="content">hypermedia apis are not good data apis, as I say in the article:<p><a href="https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;two-approaches-to-decoupling&#x2F;#but-that-s-a-terrible-data-api" rel="nofollow">https:&#x2F;&#x2F;htmx.org&#x2F;essays&#x2F;two-approaches-to-decoupling&#x2F;#but-th...</a><p>&gt; Many people would object that, sure, this hypermedia API may be flexible for our web application, but it makes for a terrible general purpose API.<p>&gt; This is quite true. This hypermedia API is tuned for a specific web application. It would be cumbersome and error-prone to try to download this HTML, parse it and try to extract information from it. This hypermedia API only makes sense as part of a larger hypermedia system, being consumed by a proper hypermedia client.</div><br/></div></div><div id="35783243" class="c"><input type="checkbox" id="c-35783243" checked=""/><div class="controls bullet"><span class="by">latortuga</span><span>|</span><a href="#35782922">parent</a><span>|</span><a href="#35782996">prev</a><span>|</span><a href="#35783192">next</a><span>|</span><label class="collapse" for="c-35783243">[-]</label><label class="expand" for="c-35783243">[1 more]</label></div><br/><div class="children"><div class="content">I get what you&#x27;re saying but you have to follow that logically to the end. 10x or more of what? What does 50 bytes cost over the wire and what is 10x that? Is this really the thing we are worrying about? Is the best argument that HATEOS costs slightly more fractions of a penny than a json API?</div><br/></div></div><div id="35783192" class="c"><input type="checkbox" id="c-35783192" checked=""/><div class="controls bullet"><span class="by">rozap</span><span>|</span><a href="#35782922">parent</a><span>|</span><a href="#35783243">prev</a><span>|</span><a href="#35783330">next</a><span>|</span><label class="collapse" for="c-35783192">[-]</label><label class="expand" for="c-35783192">[1 more]</label></div><br/><div class="children"><div class="content">You might not need a CDN</div><br/></div></div><div id="35783330" class="c"><input type="checkbox" id="c-35783330" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#35782922">parent</a><span>|</span><a href="#35783192">prev</a><span>|</span><a href="#35783416">next</a><span>|</span><label class="collapse" for="c-35783330">[-]</label><label class="expand" for="c-35783330">[1 more]</label></div><br/><div class="children"><div class="content">Is a JSON response smaller here? With HTMX I can return the text `Bart` to be swapped into the innerHTML of the appropriate element. With JSON, the actual text is longer, and I need `Content-Type: application&#x2F;json` and possibly other headers. My initial page load also requires less bandwidth by not loading React. What do you think? Maybe I should just test it.</div><br/></div></div></div></div><div id="35783416" class="c"><input type="checkbox" id="c-35783416" checked=""/><div class="controls bullet"><span class="by">killthebuddha</span><span>|</span><a href="#35782922">prev</a><span>|</span><a href="#35784120">next</a><span>|</span><label class="collapse" for="c-35783416">[-]</label><label class="expand" for="c-35783416">[4 more]</label></div><br/><div class="children"><div class="content">I could be misunderstanding of course, but IMO this article is basically misleading or incorrect. If everything else is the same, a JSON API is strictly more flexible than the corresponding HTML API because JSON is a strictly more flexible serialization format than HTML. You have a database on one side of a network and clients on the other side. If you bind your data to a specific client on the database side of the network, your system is less flexible.<p>N.B. I am not making any claims about whether any particular HTTP API should serve JSON or HTML, I’m just saying that JSON is a strictly more flexible option.</div><br/><div id="35783531" class="c"><input type="checkbox" id="c-35783531" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#35783416">parent</a><span>|</span><a href="#35783556">next</a><span>|</span><label class="collapse" for="c-35783531">[-]</label><label class="expand" for="c-35783531">[1 more]</label></div><br/><div class="children"><div class="content">Yes and no.<p>What I&#x27;m reading [1] is that they&#x27;re advocating for side-by-side decoupling.<p>In other words, humans and computers need different interfaces. Rather than try and build one, which is bad for both [2] build 2, one for the humans (however you prefer) and one for the computers (REST API).<p>Perhaps I&#x27;m reading it this way because I&#x27;m prejudiced, (I&#x27;ve written our systems this way) and it seems to be working well.<p>[1] this whole article is both well formatted, and seems to make a good post, but equally seems to feel like you&#x27;re not sure what it&#x27;s trying to say. Perhaps it makes more sense in context,rather than as a stand-alone article.<p>[2] the computer-client team has different needs to the human-client team. One wants a very stable API, the other wants regular changes. One is content driven, the other process driven. Ultimately they want different things  making two interfaces makes both teams happier with less conflict between them that you have to umpire.</div><br/></div></div><div id="35783556" class="c"><input type="checkbox" id="c-35783556" checked=""/><div class="controls bullet"><span class="by">vlz</span><span>|</span><a href="#35783416">parent</a><span>|</span><a href="#35783531">prev</a><span>|</span><a href="#35784120">next</a><span>|</span><label class="collapse" for="c-35783556">[-]</label><label class="expand" for="c-35783556">[2 more]</label></div><br/><div class="children"><div class="content">True, the JSON API itself is more flexible, in the sense of being multi-purpose and more easily consumable by different clients. But how easy is it to change each API? I think the article uses &quot;flexibility&quot; as our flexibility to change the API, not as the flexibility of the data.</div><br/><div id="35783858" class="c"><input type="checkbox" id="c-35783858" checked=""/><div class="controls bullet"><span class="by">killthebuddha</span><span>|</span><a href="#35783416">root</a><span>|</span><a href="#35783556">parent</a><span>|</span><a href="#35784120">next</a><span>|</span><label class="collapse" for="c-35783858">[-]</label><label class="expand" for="c-35783858">[1 more]</label></div><br/><div class="children"><div class="content">I think this makes sense and my initial comment may have been incorrect. I guess the idea is something like:<p>- a general purpose API is insufficient for any particular application, each application will require a special-purpose API alongside the general API<p>- assuming that you are going to have an application-specific API, it makes sense that the application-specific API should serve data specifically-tailored to that application (in this case hypermedia)<p>That said, it seems like the most interesting discussion would be about the tradeoffs between the two-JSON-API solution that they reference and the one-JSON-API + one-HTML-API solution that they suggest.</div><br/></div></div></div></div></div></div><div id="35784120" class="c"><input type="checkbox" id="c-35784120" checked=""/><div class="controls bullet"><span class="by">drewcoo</span><span>|</span><a href="#35783416">prev</a><span>|</span><label class="collapse" for="c-35784120">[-]</label><label class="expand" for="c-35784120">[1 more]</label></div><br/><div class="children"><div class="content">Well . . . any time someone offers me two options . . . I know there&#x27;s at least one lie involved. How many dichotomies are not false dichotomies, after all?<p>&gt; The central feature that distinguishes the REST architectural style from other network-based styles is its emphasis on a uniform interface between components.<p>Well, no. What distinguishes REST is that it uses HTTP verbs on resources.<p>And then it talks about Fielding mostly-not-implemented stuff and . . . no. Just no.<p>Before we&#x27;ve even gotten to the end of the para about coupling, it&#x27;s clearly a bunch of crap.<p>Which is too bad, because personally I think REST is garbage, but CRUD garbage meant to replace SOAP &quot;what is that thing?&quot; garbage.</div><br/></div></div></div></div></div></div></div></body></html>