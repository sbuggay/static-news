<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733302858227" as="style"/><link rel="stylesheet" href="styles.css?v=1733302858227"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/keyvank/30cc">Show HN: My C compiler compiled itself</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>keyvank</span> | <span>47 comments</span></div><br/><div><div id="42313135" class="c"><input type="checkbox" id="c-42313135" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#42313181">next</a><span>|</span><label class="collapse" for="c-42313135">[-]</label><label class="expand" for="c-42313135">[24 more]</label></div><br/><div class="children"><div class="content">&gt; Then run .&#x2F;build.py. This will use the bootstrapped 30cc-compiler to compile 30cc itself. It then again uses the 30cc-compiled compiler to compile 30cc once again. The final compiler is then stored as .&#x2F;30cc.<p>Why isn&#x27;t that also done by the Makefile? The only catch I could see is that you&#x27;d need to have it build to different output names, but that seems fine for what it is?<p>---<p>Also, I&#x27;m curious - did you find yourself having to constrain your use of C in order to make sure that the compiler could compile itself? Or does it implement everything you would use naturally anyways?<p>(And of course, congrats&#x2F;bravo; super impressive:])</div><br/><div id="42313508" class="c"><input type="checkbox" id="c-42313508" checked=""/><div class="controls bullet"><span class="by">dbcurtis</span><span>|</span><a href="#42313135">parent</a><span>|</span><a href="#42313409">next</a><span>|</span><label class="collapse" for="c-42313508">[-]</label><label class="expand" for="c-42313508">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, I&#x27;m curious - did you find yourself having to constrain your use of C in order to make sure that the compiler could compile itself? Or does it implement everything you would use naturally anyways?<p>That would be the &quot;bootstrapping&quot; process.  Nearly a half-century ago I took a compiler lab class where we were given a working, but slightly lame, compiler, and were tasked with adding new, less lame, language features by bootstrapping.  That is: 1) implement new feature without using the new feature, 2) using the compiler that results from step 1, re-implement the feature using the new feature, and compile again. 3) Repeat with more features until end of semester for best grade.<p>Oh, and to the OP, well done!</div><br/></div></div><div id="42313409" class="c"><input type="checkbox" id="c-42313409" checked=""/><div class="controls bullet"><span class="by">__alexander</span><span>|</span><a href="#42313135">parent</a><span>|</span><a href="#42313508">prev</a><span>|</span><a href="#42313181">next</a><span>|</span><label class="collapse" for="c-42313409">[-]</label><label class="expand" for="c-42313409">[22 more]</label></div><br/><div class="children"><div class="content">&gt; Why isn&#x27;t that also done by the Makefile?<p>My guess is that some people would rather write Python code than dig into Make’s documentation. That said, ChatGPT is excellent at creating valid make files.</div><br/><div id="42313608" class="c"><input type="checkbox" id="c-42313608" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42313409">parent</a><span>|</span><a href="#42314143">next</a><span>|</span><label class="collapse" for="c-42313608">[-]</label><label class="expand" for="c-42313608">[20 more]</label></div><br/><div class="children"><div class="content">Or just take a few moments to learn the basics about Makefiles.<p>The thing about Makefiles is that simples ones at least are <i>really</i> easy to write, and read. Much simpler and quicker than a cumbersome python script, that will most likely do less with much more boilerplate code (e.g. dependencies), and be much harder to read.<p>Of course, you may hit a point where you stretch your Makefile so much beyond its common capabilities that that no longer becomes true, but in my experience that point is pretty far away.</div><br/><div id="42314018" class="c"><input type="checkbox" id="c-42314018" checked=""/><div class="controls bullet"><span class="by">unclad5968</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42313608">parent</a><span>|</span><a href="#42315062">next</a><span>|</span><label class="collapse" for="c-42314018">[-]</label><label class="expand" for="c-42314018">[13 more]</label></div><br/><div class="children"><div class="content">As someone that learned C# and python before C and C++, to this day I couldn&#x27;t explain to you how make rules work. Make is so unlike build tools from other languages that it doesn&#x27;t surprise me someone would rather use python to bootstrap their compiler.</div><br/><div id="42314086" class="c"><input type="checkbox" id="c-42314086" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314018">parent</a><span>|</span><a href="#42314729">next</a><span>|</span><label class="collapse" for="c-42314086">[-]</label><label class="expand" for="c-42314086">[11 more]</label></div><br/><div class="children"><div class="content">It is so trivial, it takes you 10 minutes to learn.<p>Less even, here is an attempt:<p><pre><code>    foo.o: foo.c
        clang -c -o foo.o foo.c
</code></pre>
This builds a file called foo.o, if foo.c is newer than foo.o. Imagine that there is an identical bar.o as well, that builds it from bar.c.<p><pre><code>    fooexec: foo.o bar.o
        clang -o fooexec foo.o bar.o
</code></pre>
This links together foo.o and bar.o into a file called fooexec, if at least one of foo.o or bar.o is newer (which in turn means that any of <i>its</i> respective dependencies changed; e.g. change bar.c, and bar.o and then fooexec will rebuild).<p>Now type this into the shell:<p><pre><code>    make fooexec
</code></pre>
Congratulations! You have a fully built fooexec. Now change bar.c, type it again, and like magic, you have a rebuilt bar.o and fooexec. foo.o will stay put, it’s up to date!<p>But of course all the .c -&gt; .o rules look the same, so instead of writing a new one for every file, you&#x27;d use simple wildcards, and now the whole, entire Makefile is just:<p><pre><code>    %.o: %.c
        clang -c -o $@ $&lt;

    fooexec: foo.o bar.o
        clang -o fooexec foo.o bar.o
</code></pre>
Do $@ and $&lt; look arcane at first glance? Yes. Is what they do simple, though? Also yes. (If your complaint is that you don&#x27;t know what those &quot;clang&quot; lines do, then you don&#x27;t know how to use the C compiler, and will have the same problem when writing a python script.)<p>It pains me if that is not immediately obvious. And it pains me even more that someone would want to write a boilerplate heavy, complex python program, that rebuilds everything all the time, instead of just learning this very simple concept.</div><br/><div id="42314414" class="c"><input type="checkbox" id="c-42314414" checked=""/><div class="controls bullet"><span class="by">IgorPartola</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314086">parent</a><span>|</span><a href="#42314672">next</a><span>|</span><label class="collapse" for="c-42314414">[-]</label><label class="expand" for="c-42314414">[1 more]</label></div><br/><div class="children"><div class="content">This is an excellent explanation of make! The only thing I will add is the slightly more abstract thought that make is meant to build files out of other files based on timestamps of the source files. And the target files can themselves become source files, which means that you can build dependency graphs. Lastly, it has “caching” built in: if bar.o is newer than bar.c, don’t rebuild it. If it doesn’t exist or is older, do rebuild it. So when you change one file, you don’t recompile the entire damn tree.<p>It also has “phony” targets that aren’t files. The canonical example of this is “clean” which basically just does something like <i>rm -rf *.o fooexec</i><p>This is what the JavaScript tooling people have been chasing for the past 15 years and can’t seem to grasp. Someone actually did build a make-based JS build system I believe but it never got popular because it wasn’t written in JavaScript.</div><br/></div></div><div id="42314672" class="c"><input type="checkbox" id="c-42314672" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314086">parent</a><span>|</span><a href="#42314414">prev</a><span>|</span><a href="#42315189">next</a><span>|</span><label class="collapse" for="c-42314672">[-]</label><label class="expand" for="c-42314672">[7 more]</label></div><br/><div class="children"><div class="content">Saying this is an &#x27;incremental makefile&#x27; isn&#x27;t really correct, as changes to header files aren&#x27;t going to lead to rebuilding.<p>So, either you need to manually keep references to which .h files you include in your Makefiles up to date, or start worrying about M &#x2F; MM &#x2F; MG &#x2F; MP, and of course you&#x27;d like those to be re-run when you change your files, and suddenly your Makefile is an awful lot less simple.<p>This is the main reason I stopped teaching Makefiles in intro to C courses -- students often lost entire afternoons to forgetting this stuff, and failing to realise their mistake. It really shouldn&#x27;t be any person&#x27;s job to keep this up to date, when the computer knows it.</div><br/><div id="42314785" class="c"><input type="checkbox" id="c-42314785" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314672">parent</a><span>|</span><a href="#42314760">next</a><span>|</span><label class="collapse" for="c-42314785">[-]</label><label class="expand" for="c-42314785">[2 more]</label></div><br/><div class="children"><div class="content">It is correct to call it an incremental Makefile, it merely doesn’t name the dependencies for you. A Makefile has exactly the dependencies you specify. It’s that simple.<p>That is not necessarily the most <i>useful</i>. Especially as your project gets larger, you probably will not want to specify every header file as a manual dependency, or alternatively rebuild everything every time you change a header file. (Though for me personally, either approach often works for surprisingly long.)<p>Then you can do things like letting the C preprocessor create the dependencies that get included in your Makefile (yes, common C compilers can create Makefile fragments). Or do something more complicated.  Or switch to another build system, if your project really outgrew, or really mismatches, make.<p>But at its core, Makefiles follow a simple concept, are entirely language agnostic, and even with just the simpler concepts they remain useful for a long time.</div><br/><div id="42315670" class="c"><input type="checkbox" id="c-42315670" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314785">parent</a><span>|</span><a href="#42314760">next</a><span>|</span><label class="collapse" for="c-42315670">[-]</label><label class="expand" for="c-42315670">[1 more]</label></div><br/><div class="children"><div class="content">Having &#x27;incrementality&#x27;, when it isn&#x27;t actually going to incrementally rebuild things when files change, is (in my experience), worse that having no incrementality at all. Having to remember when I have to manually disable to incrementality is an annoying overhead, and easy to forget.<p>If you can remember exactly when you need to manually skip the incremental build, that&#x27;s great for you, but I find Make has enough of these kinds of footguns I don&#x27;t recommend it to people any more.</div><br/></div></div></div></div><div id="42314760" class="c"><input type="checkbox" id="c-42314760" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314672">parent</a><span>|</span><a href="#42314785">prev</a><span>|</span><a href="#42315189">next</a><span>|</span><label class="collapse" for="c-42314760">[-]</label><label class="expand" for="c-42314760">[4 more]</label></div><br/><div class="children"><div class="content">Yes, this is quite important for C projects as it leads to subtle bugs. I also long for a way to let make detect a change of $CC (new build of the compiler itself) in the context of debugging a compiler against third party makefile projects.</div><br/><div id="42314800" class="c"><input type="checkbox" id="c-42314800" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314760">parent</a><span>|</span><a href="#42315061">next</a><span>|</span><label class="collapse" for="c-42314800">[-]</label><label class="expand" for="c-42314800">[2 more]</label></div><br/><div class="children"><div class="content">Have a step that takes the SHA256 or similar of $CC, make that a dependency. You’d need slightly more advanced make features if you want to make it “pretty” (and not just, say, touch a file through some shell code comparison), but this is a slightly more advanced request.<p>Or potentially just specify the path to $CC itself as dependency? Presumably, if the C compiler changes, the timestamp of its executable does too. (Bad if it goes backwards, though.)</div><br/><div id="42314982" class="c"><input type="checkbox" id="c-42314982" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314800">parent</a><span>|</span><a href="#42315061">next</a><span>|</span><label class="collapse" for="c-42314982">[-]</label><label class="expand" for="c-42314982">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Have a step that takes the SHA256 or similar of $CC, make that a dependency.<p>Careful, one more step and we&#x27;ll start recreating nix in Makefiles;)<p>(Wait, <i>could</i> we? Should we?)</div><br/></div></div></div></div><div id="42315061" class="c"><input type="checkbox" id="c-42315061" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314760">parent</a><span>|</span><a href="#42314800">prev</a><span>|</span><a href="#42315189">next</a><span>|</span><label class="collapse" for="c-42315061">[-]</label><label class="expand" for="c-42315061">[1 more]</label></div><br/><div class="children"><div class="content">I often use a Python program called &#x27;fabricate&#x27;, which basically checks every file a command opens, and re-runs the command if any touched file changes.<p>I love it, and I hoped this would become the future of how build-systems are built -- you could automatically parallelise, rebuild, make clean, everything, just by tracking which files are read, and written.<p>It does add a bit of overhead, but I&#x27;d be willing to pay that for simplicity. Unfortunately, it doesn&#x27;t seem to have caught on.</div><br/></div></div></div></div></div></div><div id="42315189" class="c"><input type="checkbox" id="c-42315189" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314086">parent</a><span>|</span><a href="#42314672">prev</a><span>|</span><a href="#42314729">next</a><span>|</span><label class="collapse" for="c-42315189">[-]</label><label class="expand" for="c-42315189">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Do $@ and $&lt; look arcane at first glance? Yes. Is what they do simple, though?<p>And yet, I still don&#x27;t actually know what `$@` and `$&lt;` actually mean outside of your example. I only can assume that somehow that substitutes in `foo.o` and `foo.c` because you literally put the non-magic versions right below it (and above it a few paragraphs above as well), but I&#x27;m honestly not even positive that I&#x27;d run `make foo.o` rather than `make foo` with your example, and I feel fairly confident in guessing that this would _not_ compile into a binary called `fooexec` like the target you defined above. I don&#x27;t have an idea whatsoever what I&#x27;d need to put in the target to be able to substitute in something like that because the fact that the first `%` somehow becomes `$@` and the second becomes `$&lt;` doesn&#x27;t follow any obvious pattern I can use to figure out what the third symbol would be, or even if there is one.<p>The problem is that &quot;simple&quot; is not the same as &quot;intuitive&quot; or &quot;discoverable&quot;. Yes, I could probably put in the effort to go and find out these things, but why would you expect someone to be motivated to do that by someone telling you that it&#x27;s &quot;trivial&quot; and it &quot;pains&quot; them as they explain things in a way that doesn&#x27;t actually clarify things in a way that helps me? If you actually want to try to make a strong case that this is something worth learning for people, repeatedly referring to it in ways like &quot;very simple&quot; and &quot;so trivial&quot; and &quot;immediately obvious&quot; is counterproductive.<p>As an aside, I think it&#x27;s also a bit of leap to assume that they&#x27;re &quot;rebuilding everything all the time&quot;. It looks to me like the build.py script is only needed a single time to bootstrap from the original compiler to this one, and rebuilding every single C file in the new compiler rather than using the artifacts built with the original one is kind of the whole point. After that&#x27;s done once, I don&#x27;t see why the new compiler couldn&#x27;t be used via the Makefile. If you&#x27;re complaining about Python build scripts in general rather than this specific one, I don&#x27;t know why you assume they can&#x27;t be written to check the timestamps on the files to see if a rebuild is necessary before doing so. That&#x27;s exactly what `make` does, and hey, it&#x27;s a very simple concept!</div><br/><div id="42315587" class="c"><input type="checkbox" id="c-42315587" checked=""/><div class="controls bullet"><span class="by">mturmon</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42315189">parent</a><span>|</span><a href="#42314729">next</a><span>|</span><label class="collapse" for="c-42315587">[-]</label><label class="expand" for="c-42315587">[1 more]</label></div><br/><div class="children"><div class="content">Since you’re asking, $@ is the “target” of the build, that is, what you are aiming to build (left of the colon in the rule). This is why it looks like a bullseye.<p>And $&lt; is of course the thing the target depends on. It’s the input, like standard Unix notation for stdin.<p>Hopefully this helps?</div><br/></div></div></div></div></div></div><div id="42314729" class="c"><input type="checkbox" id="c-42314729" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42314018">parent</a><span>|</span><a href="#42314086">prev</a><span>|</span><a href="#42315062">next</a><span>|</span><label class="collapse" for="c-42314729">[-]</label><label class="expand" for="c-42314729">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    output: dependencies
        &lt;command(s) that use dependencies to create output&gt;
</code></pre>
If any &quot;dependencies&quot; are newer than &quot;output&quot; or if &quot;output&quot; does not exist the commands run.  Otherwise they don&#x27;t.</div><br/></div></div></div></div><div id="42315062" class="c"><input type="checkbox" id="c-42315062" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42313608">parent</a><span>|</span><a href="#42314018">prev</a><span>|</span><a href="#42313807">next</a><span>|</span><label class="collapse" for="c-42315062">[-]</label><label class="expand" for="c-42315062">[1 more]</label></div><br/><div class="children"><div class="content">On the other hand, I&#x27;d argue that the point where you&#x27;ve stretched it so far that it&#x27;s more trouble than it&#x27;s worth is basically impossible to see until you&#x27;ve gone beyond it.</div><br/></div></div><div id="42313807" class="c"><input type="checkbox" id="c-42313807" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42313608">parent</a><span>|</span><a href="#42315062">prev</a><span>|</span><a href="#42314143">next</a><span>|</span><label class="collapse" for="c-42313807">[-]</label><label class="expand" for="c-42313807">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The thing about Makefiles is that simples ones at least are <i>really</i> easy to write, and read. Much simpler and quicker than a cumbersome python script, that will most likely do less with much more boilerplate code (e.g. dependencies), and be much harder to read.<p>Whether this is true or not depends a lot on from which programming culture&#x2F;background you come.</div><br/><div id="42315583" class="c"><input type="checkbox" id="c-42315583" checked=""/><div class="controls bullet"><span class="by">Tor3</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42313807">parent</a><span>|</span><a href="#42313855">next</a><span>|</span><label class="collapse" for="c-42315583">[-]</label><label class="expand" for="c-42315583">[1 more]</label></div><br/><div class="children"><div class="content">A Makefile dependency:<p><pre><code>  Left : right
</code></pre>
Left depends on the right. I don&#x27;t think the ability to learn that concept is related to programming culture&#x2F;background.
What follows below that is what happens.<p><pre><code>  Left : right
         cp right Left
         echo and so on. Left is now updated.
</code></pre>
The only tricky part of the above, and something I guess nobody has found any good reason for, is that the whitespace in front of the statements (&#x27;cp&#x27; in this case) has to be an actual tab, just spaces won&#x27;t do.<p>When it comes to the more &quot;advanced&quot; concepts (wildcards etc) there are slight differences between Make versions. And to bother with that is to get into the mindset which created the (argh) Automake and Autoconf systems (to begin with), so back in the day our company simply decided that we&#x27;ll use GNU Make on every single system (we supported lots of various UNIX systems) and not bother with any of that (no SYSV Make, no BSD Make or anything), because GNU Make was and is available on anything and everything. Made life very simple back then.</div><br/></div></div><div id="42313855" class="c"><input type="checkbox" id="c-42313855" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42313807">parent</a><span>|</span><a href="#42315583">prev</a><span>|</span><a href="#42315041">next</a><span>|</span><label class="collapse" for="c-42313855">[-]</label><label class="expand" for="c-42313855">[1 more]</label></div><br/><div class="children"><div class="content">I honestly don&#x27;t think so, and I think this is here is a prime example for proving that.<p>For example, a Makefile that does the same job as the build.py script in this project would be significantly smaller, simpler, and easier to read in several metrics that I&#x27;d reasonably call &quot;objective&quot; to a certain degree.<p>In fact, contrast the Makefile in that project: <a href="https:&#x2F;&#x2F;github.com&#x2F;keyvank&#x2F;30cc&#x2F;blob&#x2F;main&#x2F;Makefile">https:&#x2F;&#x2F;github.com&#x2F;keyvank&#x2F;30cc&#x2F;blob&#x2F;main&#x2F;Makefile</a><p>With the build.py script:
<a href="https:&#x2F;&#x2F;github.com&#x2F;keyvank&#x2F;30cc&#x2F;blob&#x2F;main&#x2F;build.py">https:&#x2F;&#x2F;github.com&#x2F;keyvank&#x2F;30cc&#x2F;blob&#x2F;main&#x2F;build.py</a><p>You need to know <i>very little</i> about Makefiles to make immediate sense of what that Makefile is doing, whereas you need to know <i>much more</i> about python to still not immediately see what the build.py script is doing. In fact, you will probably just &quot;guess&quot; that the python script is supposed to do a similar job only from its name before that.<p>And then the python script still does not do incremental builds at all!<p>Again, if it gets more complex that can change, but this is far away from that. It takes 10 or so minutes to learn enough about Makefiles to be productive with them, from scratch.</div><br/></div></div><div id="42315041" class="c"><input type="checkbox" id="c-42315041" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42313807">parent</a><span>|</span><a href="#42313855">prev</a><span>|</span><a href="#42314143">next</a><span>|</span><label class="collapse" for="c-42315041">[-]</label><label class="expand" for="c-42315041">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s is absolutely objectively true. Whether you already know it or not depends on your background</div><br/></div></div></div></div></div></div><div id="42314143" class="c"><input type="checkbox" id="c-42314143" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42313135">root</a><span>|</span><a href="#42313409">parent</a><span>|</span><a href="#42313608">prev</a><span>|</span><a href="#42313181">next</a><span>|</span><label class="collapse" for="c-42314143">[-]</label><label class="expand" for="c-42314143">[1 more]</label></div><br/><div class="children"><div class="content">If make is too hard, ninja is simpler. Less powerful but in ways that rarely matter. I&#x27;ve written both by hand both are a little weird but not hard. Normally I use cmake these days (an aweful language but it works for hard problems)</div><br/></div></div></div></div></div></div><div id="42313181" class="c"><input type="checkbox" id="c-42313181" checked=""/><div class="controls bullet"><span class="by">michael-online</span><span>|</span><a href="#42313135">prev</a><span>|</span><a href="#42315280">next</a><span>|</span><label class="collapse" for="c-42313181">[-]</label><label class="expand" for="c-42313181">[1 more]</label></div><br/><div class="children"><div class="content">What a fun project, thanks for sharing. I&#x27;ve dreamed of projects like this. What did you expect to learn from this project? Did you learn anything unexpected?</div><br/></div></div><div id="42315280" class="c"><input type="checkbox" id="c-42315280" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42313181">prev</a><span>|</span><a href="#42312634">next</a><span>|</span><label class="collapse" for="c-42315280">[-]</label><label class="expand" for="c-42315280">[2 more]</label></div><br/><div class="children"><div class="content">Nice job!<p>But why 3 steps of compilation?<p>The first step merely shows that you wrote valid C code that gcc can compile. It doesn&#x27;t prove that the program actually does what promised. For example, if you missed to implement &#x27;for&#x27; loops, this step would still produce a compiler, which could still work for a subset of C.<p>Here comes the second step: it proves that it implements enough features to at least recompile itself. Now, this is still not a guarantee that all C constructs and features work, but we can reason that even if it only implements a subset of C, it&#x27;s a large enough subset to build such a substantial app as a compiler. How likely is it that a compiler doesn&#x27;t use a &#x27;for&#x27; loop, not even once?<p>But what is the reason for the third step? It doesn&#x27;t add anything, it doesn&#x27;t trigger any code path that was excluded in the first one. After all, if you did miss &#x27;for&#x27; loops, and the 2nd step hasn&#x27;t detected it, it must be because there are no &#x27;for&#x27; loops in the source, so you will never detect it this way, no matter how many steps of recompilation you run.</div><br/><div id="42315313" class="c"><input type="checkbox" id="c-42315313" checked=""/><div class="controls bullet"><span class="by">keyvank</span><span>|</span><a href="#42315280">parent</a><span>|</span><a href="#42312634">next</a><span>|</span><label class="collapse" for="c-42315313">[-]</label><label class="expand" for="c-42315313">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!
The third step proves that the assembly code generated by the second-step compiler is valid even when compiling a big C project.</div><br/></div></div></div></div><div id="42312634" class="c"><input type="checkbox" id="c-42312634" checked=""/><div class="controls bullet"><span class="by">pjdkoch</span><span>|</span><a href="#42315280">prev</a><span>|</span><a href="#42313124">next</a><span>|</span><label class="collapse" for="c-42312634">[-]</label><label class="expand" for="c-42312634">[2 more]</label></div><br/><div class="children"><div class="content">&#x2F;me claps and cheers</div><br/><div id="42312757" class="c"><input type="checkbox" id="c-42312757" checked=""/><div class="controls bullet"><span class="by">keyvank</span><span>|</span><a href="#42312634">parent</a><span>|</span><a href="#42313124">next</a><span>|</span><label class="collapse" for="c-42312757">[-]</label><label class="expand" for="c-42312757">[1 more]</label></div><br/><div class="children"><div class="content">tnx!</div><br/></div></div></div></div><div id="42313124" class="c"><input type="checkbox" id="c-42313124" checked=""/><div class="controls bullet"><span class="by">disqard</span><span>|</span><a href="#42312634">prev</a><span>|</span><a href="#42313625">next</a><span>|</span><label class="collapse" for="c-42313124">[-]</label><label class="expand" for="c-42313124">[1 more]</label></div><br/><div class="children"><div class="content">Thank You For Making And Sharing!</div><br/></div></div><div id="42313625" class="c"><input type="checkbox" id="c-42313625" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313124">prev</a><span>|</span><a href="#42312633">next</a><span>|</span><label class="collapse" for="c-42313625">[-]</label><label class="expand" for="c-42313625">[1 more]</label></div><br/><div class="children"><div class="content">Congratulations! That&#x27;s no small feat.</div><br/></div></div><div id="42312633" class="c"><input type="checkbox" id="c-42312633" checked=""/><div class="controls bullet"><span class="by">jesse__</span><span>|</span><a href="#42313625">prev</a><span>|</span><a href="#42313034">next</a><span>|</span><label class="collapse" for="c-42312633">[-]</label><label class="expand" for="c-42312633">[2 more]</label></div><br/><div class="children"><div class="content">Congratulations!</div><br/><div id="42312758" class="c"><input type="checkbox" id="c-42312758" checked=""/><div class="controls bullet"><span class="by">keyvank</span><span>|</span><a href="#42312633">parent</a><span>|</span><a href="#42313034">next</a><span>|</span><label class="collapse" for="c-42312758">[-]</label><label class="expand" for="c-42312758">[1 more]</label></div><br/><div class="children"><div class="content">tnx!</div><br/></div></div></div></div><div id="42313034" class="c"><input type="checkbox" id="c-42313034" checked=""/><div class="controls bullet"><span class="by">ajxs</span><span>|</span><a href="#42312633">prev</a><span>|</span><a href="#42313165">next</a><span>|</span><label class="collapse" for="c-42313034">[-]</label><label class="expand" for="c-42313034">[1 more]</label></div><br/><div class="children"><div class="content">Awesome work!</div><br/></div></div><div id="42313165" class="c"><input type="checkbox" id="c-42313165" checked=""/><div class="controls bullet"><span class="by">hasheddan</span><span>|</span><a href="#42313034">prev</a><span>|</span><a href="#42313449">next</a><span>|</span><label class="collapse" for="c-42313165">[-]</label><label class="expand" for="c-42313165">[1 more]</label></div><br/><div class="children"><div class="content">awesome! keep up the great work!</div><br/></div></div><div id="42313449" class="c"><input type="checkbox" id="c-42313449" checked=""/><div class="controls bullet"><span class="by">jheriko</span><span>|</span><a href="#42313165">prev</a><span>|</span><a href="#42313587">next</a><span>|</span><label class="collapse" for="c-42313449">[-]</label><label class="expand" for="c-42313449">[7 more]</label></div><br/><div class="children"><div class="content">nice work.<p>if you want more of a challenge try a compiler compiler that can compile itself... :)<p>i got pretty far with this myself, although it doesn&#x27;t work for weirdo languages like Python that need an exceptional lexer. i keep meaning to revisit this problem, since the tools in this space are pretty much non-existent or trash quality.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;semiessessi&#x2F;cp2">https:&#x2F;&#x2F;github.com&#x2F;semiessessi&#x2F;cp2</a></div><br/><div id="42313620" class="c"><input type="checkbox" id="c-42313620" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313449">parent</a><span>|</span><a href="#42313587">next</a><span>|</span><label class="collapse" for="c-42313620">[-]</label><label class="expand" for="c-42313620">[6 more]</label></div><br/><div class="children"><div class="content">&gt; if you want more of a challenge try a compiler compiler that can compile itself... :)<p>Is that not what OP did?</div><br/><div id="42314013" class="c"><input type="checkbox" id="c-42314013" checked=""/><div class="controls bullet"><span class="by">Koshkin</span><span>|</span><a href="#42313449">root</a><span>|</span><a href="#42313620">parent</a><span>|</span><a href="#42313587">next</a><span>|</span><label class="collapse" for="c-42314013">[-]</label><label class="expand" for="c-42314013">[5 more]</label></div><br/><div class="children"><div class="content">No (if the parent really meant ‘compiler compiler’ which, I think, would be what yacc&#x2F;bison is).</div><br/><div id="42314027" class="c"><input type="checkbox" id="c-42314027" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313449">root</a><span>|</span><a href="#42314013">parent</a><span>|</span><a href="#42314952">next</a><span>|</span><label class="collapse" for="c-42314027">[-]</label><label class="expand" for="c-42314027">[3 more]</label></div><br/><div class="children"><div class="content">Ah, thanks. My brain actually did not see that second &quot;compiler&quot; when reading, now it makes sense.</div><br/><div id="42314682" class="c"><input type="checkbox" id="c-42314682" checked=""/><div class="controls bullet"><span class="by">downboots</span><span>|</span><a href="#42313449">root</a><span>|</span><a href="#42314027">parent</a><span>|</span><a href="#42314952">next</a><span>|</span><label class="collapse" for="c-42314682">[-]</label><label class="expand" for="c-42314682">[2 more]</label></div><br/><div class="children"><div class="content">How could you tell the difference between missing it and your brain filtering it out?</div><br/><div id="42314838" class="c"><input type="checkbox" id="c-42314838" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313449">root</a><span>|</span><a href="#42314682">parent</a><span>|</span><a href="#42314952">next</a><span>|</span><label class="collapse" for="c-42314838">[-]</label><label class="expand" for="c-42314838">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t <i>that</i> the same now?<p>By the way, I dislike the term “compiler compiler”, because that’s not really what it does. I like “parser generator” for tax&#x2F;bison, and “lexer generator” for flex.</div><br/></div></div></div></div></div></div><div id="42314952" class="c"><input type="checkbox" id="c-42314952" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42313449">root</a><span>|</span><a href="#42314013">parent</a><span>|</span><a href="#42314027">prev</a><span>|</span><a href="#42313587">next</a><span>|</span><label class="collapse" for="c-42314952">[-]</label><label class="expand" for="c-42314952">[1 more]</label></div><br/><div class="children"><div class="content">yacc calls it&#x27;s a compiler compiler, but it&#x27;s a parser compiler.</div><br/></div></div></div></div></div></div></div></div><div id="42313587" class="c"><input type="checkbox" id="c-42313587" checked=""/><div class="controls bullet"><span class="by">DrNosferatu</span><span>|</span><a href="#42313449">prev</a><span>|</span><label class="collapse" for="c-42313587">[-]</label><label class="expand" for="c-42313587">[4 more]</label></div><br/><div class="children"><div class="content">Why not use WASM to bootstrap your compiler?</div><br/><div id="42313945" class="c"><input type="checkbox" id="c-42313945" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#42313587">parent</a><span>|</span><a href="#42313596">next</a><span>|</span><label class="collapse" for="c-42313945">[-]</label><label class="expand" for="c-42313945">[2 more]</label></div><br/><div class="children"><div class="content">Unlike any real machine (and most virtual ones), WASM is impossible to target with a simple single-pass C compiler. The reducible control flow requirement means you <i>have</i> to build a full control-flow graph and do graph algorithms to it before you can start emitting code. So IMO it makes for a bad starting point.</div><br/><div id="42314021" class="c"><input type="checkbox" id="c-42314021" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313587">root</a><span>|</span><a href="#42313945">parent</a><span>|</span><a href="#42313596">next</a><span>|</span><label class="collapse" for="c-42314021">[-]</label><label class="expand" for="c-42314021">[1 more]</label></div><br/><div class="children"><div class="content">If you want to have &quot;fun&quot;, generate code in a WASM-representation of Hoare&#x27;s WHILE language, i.e. a program that only consists of a single outer while loop (in WASM a &quot;loop&quot; block), and conditionally decide for every single instruction in the loop whether it should be executed during a given pass.<p>I <i>think</i> that could be done with a single-pass C compiler. In a very trivial (and terrible) case, you could keep a running &quot;line_counter&quot; variable that every statement in the loop is predicated with, which either gets incremented at the end of the loop, or set to an arbitrary value for representing branches.<p>It would of course be a horrible (but very amusing) mess, and rather enforces your actual point.</div><br/></div></div></div></div><div id="42313596" class="c"><input type="checkbox" id="c-42313596" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#42313587">parent</a><span>|</span><a href="#42313945">prev</a><span>|</span><label class="collapse" for="c-42313596">[-]</label><label class="expand" for="c-42313596">[1 more]</label></div><br/><div class="children"><div class="content">Elaborate, why use WASM?</div><br/></div></div></div></div></div></div></div></div></div></body></html>