<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719997253630" as="style"/><link rel="stylesheet" href="styles.css?v=1719997253630"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.quantamagazine.org/amateur-mathematicians-find-fifth-busy-beaver-turing-machine-20240702/">With fifth busy beaver, researchers approach computation&#x27;s limits</a> <span class="domain">(<a href="https://www.quantamagazine.org">www.quantamagazine.org</a>)</span></div><div class="subtext"><span>LegionMammal978</span> | <span>127 comments</span></div><br/><div><div id="40858009" class="c"><input type="checkbox" id="c-40858009" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#40858293">next</a><span>|</span><label class="collapse" for="c-40858009">[-]</label><label class="expand" for="c-40858009">[6 more]</label></div><br/><div class="children"><div class="content">Some comments on this result by Scott Aaronson <a href="https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=8088" rel="nofollow">https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=8088</a><p>And for leisure-class beavers, some big related threads from earlier this year:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40453221">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40453221</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38113792">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38113792</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37910297">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37910297</a></div><br/><div id="40860073" class="c"><input type="checkbox" id="c-40860073" checked=""/><div class="controls bullet"><span class="by">inhumantsar</span><span>|</span><a href="#40858009">parent</a><span>|</span><a href="#40860909">next</a><span>|</span><label class="collapse" for="c-40860073">[-]</label><label class="expand" for="c-40860073">[4 more]</label></div><br/><div class="children"><div class="content">&gt; leisure-class beavers<p>I can&#x27;t not find this phrase funny. out of context it reads like something out of Terry Pratchett or Douglas Adams.</div><br/><div id="40863949" class="c"><input type="checkbox" id="c-40863949" checked=""/><div class="controls bullet"><span class="by">max-ibel</span><span>|</span><a href="#40858009">root</a><span>|</span><a href="#40860073">parent</a><span>|</span><a href="#40861764">next</a><span>|</span><label class="collapse" for="c-40863949">[-]</label><label class="expand" for="c-40863949">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Those are also not funny at all.</div><br/></div></div><div id="40861764" class="c"><input type="checkbox" id="c-40861764" checked=""/><div class="controls bullet"><span class="by">IIAOPSW</span><span>|</span><a href="#40858009">root</a><span>|</span><a href="#40860073">parent</a><span>|</span><a href="#40863949">prev</a><span>|</span><a href="#40860909">next</a><span>|</span><label class="collapse" for="c-40861764">[-]</label><label class="expand" for="c-40861764">[2 more]</label></div><br/><div class="children"><div class="content">frankly, leisure beaver sounds like a raunchy innuendo</div><br/><div id="40863092" class="c"><input type="checkbox" id="c-40863092" checked=""/><div class="controls bullet"><span class="by">labster</span><span>|</span><a href="#40858009">root</a><span>|</span><a href="#40861764">parent</a><span>|</span><a href="#40860909">next</a><span>|</span><label class="collapse" for="c-40863092">[-]</label><label class="expand" for="c-40863092">[1 more]</label></div><br/><div class="children"><div class="content">So classist. Don’t you wanna C-suite beaver?</div><br/></div></div></div></div></div></div></div></div><div id="40858293" class="c"><input type="checkbox" id="c-40858293" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#40858009">prev</a><span>|</span><a href="#40858336">next</a><span>|</span><label class="collapse" for="c-40858293">[-]</label><label class="expand" for="c-40858293">[5 more]</label></div><br/><div class="children"><div class="content">&gt; There are many variants of the original busy beaver problem, and some Busy Beaver Challenge contributors plan to keep working on these.<p>One such variant is a functional busy beaver defined in terms of the lambda calculus [1]. Since it measures program size in bits rather than states, it allows many more values to be determined (37 so far versus only 6 for TMs), and the gap between the largest known value and values beyond Graham&#x27;s Number is a mere 13 program bits. A closely related variant [2] can be directly expressed in terms of Kolmogorov complexity, which Mikhail Andreev argues [3] is crucial for applications in Information Theory.<p>[1] <a href="https:&#x2F;&#x2F;oeis.org&#x2F;A333479" rel="nofollow">https:&#x2F;&#x2F;oeis.org&#x2F;A333479</a><p>[2] <a href="https:&#x2F;&#x2F;oeis.org&#x2F;A361211" rel="nofollow">https:&#x2F;&#x2F;oeis.org&#x2F;A361211</a><p>[3] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1703.05170" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1703.05170</a></div><br/><div id="40862605" class="c"><input type="checkbox" id="c-40862605" checked=""/><div class="controls bullet"><span class="by">anandijain</span><span>|</span><a href="#40858293">parent</a><span>|</span><a href="#40859568">next</a><span>|</span><label class="collapse" for="c-40862605">[-]</label><label class="expand" for="c-40862605">[2 more]</label></div><br/><div class="children"><div class="content">A bit unrelated but you posted oeis so hoping you know.
In the article they mention there are 17 trillion possible 5-2 turing machines. I tried finding the sequence for this but couldn&#x27;t.<p>I found this <a href="https:&#x2F;&#x2F;oeis.org&#x2F;A141475" rel="nofollow">https:&#x2F;&#x2F;oeis.org&#x2F;A141475</a>, but it gives 27 trillion for 5.</div><br/><div id="40863569" class="c"><input type="checkbox" id="c-40863569" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#40858293">root</a><span>|</span><a href="#40862605">parent</a><span>|</span><a href="#40859568">next</a><span>|</span><label class="collapse" for="c-40863569">[-]</label><label class="expand" for="c-40863569">[1 more]</label></div><br/><div class="children"><div class="content">While the official formula [1] is (4(n+1))^(2n)
, if one ignores the symbol written and head movement for transitions to halt, then this becomes (4n+1)^(2n), which is ~ 17 trillion for n=5.<p>[1] <a href="https:&#x2F;&#x2F;oeis.org&#x2F;A052200" rel="nofollow">https:&#x2F;&#x2F;oeis.org&#x2F;A052200</a></div><br/></div></div></div></div><div id="40859568" class="c"><input type="checkbox" id="c-40859568" checked=""/><div class="controls bullet"><span class="by">passion__desire</span><span>|</span><a href="#40858293">parent</a><span>|</span><a href="#40862605">prev</a><span>|</span><a href="#40858336">next</a><span>|</span><label class="collapse" for="c-40859568">[-]</label><label class="expand" for="c-40859568">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t there another formulation of BB where we count shifts (from left to right, and from right to left) a TM makes instead of strings of contiguous 1s. I remember seeing a video about this definition.</div><br/><div id="40859637" class="c"><input type="checkbox" id="c-40859637" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40858293">root</a><span>|</span><a href="#40859568">parent</a><span>|</span><a href="#40858336">next</a><span>|</span><label class="collapse" for="c-40859637">[-]</label><label class="expand" for="c-40859637">[1 more]</label></div><br/><div class="children"><div class="content">The variant of BB discussed in the article is counting steps, not 1s.  (I guess &quot;shifts&quot; is equivalent to steps, although that seems like a more roundabout way of specifying it.)  Also, I don&#x27;t think anyone counts strings of <i>contiguous</i> 1s, although of course one could define such a thing.</div><br/></div></div></div></div></div></div><div id="40858336" class="c"><input type="checkbox" id="c-40858336" checked=""/><div class="controls bullet"><span class="by">titanomachy</span><span>|</span><a href="#40858293">prev</a><span>|</span><a href="#40858734">next</a><span>|</span><label class="collapse" for="c-40858336">[-]</label><label class="expand" for="c-40858336">[26 more]</label></div><br/><div class="children"><div class="content">I worked for a couple years with a formidable and incomprehensibly smart engineer who ascended the IC ranks faster than anyone I’ve seen at an elite tech company. He quit the job a few years ago, and when I asked him his plans he told me he was going to work on the busy beaver problem. I can’t help but wonder if he is mxdys, the pseudonymous contributor mentioned in the article who wrapped up the formal proof of BB(5). I’ll probably never know.</div><br/><div id="40858558" class="c"><input type="checkbox" id="c-40858558" checked=""/><div class="controls bullet"><span class="by">jebarker</span><span>|</span><a href="#40858336">parent</a><span>|</span><a href="#40860378">next</a><span>|</span><label class="collapse" for="c-40858558">[-]</label><label class="expand" for="c-40858558">[7 more]</label></div><br/><div class="children"><div class="content">If it were them would you be surprised that they wanted to remain anonymous?</div><br/><div id="40863439" class="c"><input type="checkbox" id="c-40863439" checked=""/><div class="controls bullet"><span class="by">titanomachy</span><span>|</span><a href="#40858336">root</a><span>|</span><a href="#40858558">parent</a><span>|</span><a href="#40861770">next</a><span>|</span><label class="collapse" for="c-40863439">[-]</label><label class="expand" for="c-40863439">[1 more]</label></div><br/><div class="children"><div class="content">I didn’t know him that well, but could see him being the kind of person who wants to avoid attention. He was happy to spend some time explaining the problem to me and why it was interesting and difficult.</div><br/></div></div><div id="40861770" class="c"><input type="checkbox" id="c-40861770" checked=""/><div class="controls bullet"><span class="by">someplaceguy</span><span>|</span><a href="#40858336">root</a><span>|</span><a href="#40858558">parent</a><span>|</span><a href="#40863439">prev</a><span>|</span><a href="#40860378">next</a><span>|</span><label class="collapse" for="c-40861770">[-]</label><label class="expand" for="c-40861770">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry, I don&#x27;t get it. What are you suggesting to be the motivation to remain anonymous in this case?</div><br/><div id="40862036" class="c"><input type="checkbox" id="c-40862036" checked=""/><div class="controls bullet"><span class="by">jebarker</span><span>|</span><a href="#40858336">root</a><span>|</span><a href="#40861770">parent</a><span>|</span><a href="#40861892">next</a><span>|</span><label class="collapse" for="c-40862036">[-]</label><label class="expand" for="c-40862036">[2 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t mean to suggest anything. I was just interested in whether they thought that remaining anonymous was in keeping with their ex-colleagues character. Written communication is hard!</div><br/></div></div><div id="40861892" class="c"><input type="checkbox" id="c-40861892" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#40858336">root</a><span>|</span><a href="#40861770">parent</a><span>|</span><a href="#40862036">prev</a><span>|</span><a href="#40860378">next</a><span>|</span><label class="collapse" for="c-40861892">[-]</label><label class="expand" for="c-40861892">[2 more]</label></div><br/><div class="children"><div class="content">Prevents embarrassment if it turns out one’s idea is wrong, I suppose.</div><br/><div id="40862085" class="c"><input type="checkbox" id="c-40862085" checked=""/><div class="controls bullet"><span class="by">someplaceguy</span><span>|</span><a href="#40858336">root</a><span>|</span><a href="#40861892">parent</a><span>|</span><a href="#40860378">next</a><span>|</span><label class="collapse" for="c-40862085">[-]</label><label class="expand" for="c-40862085">[1 more]</label></div><br/><div class="children"><div class="content">The person in question formalized the entire proof in Coq, which certifies its correctness.<p>To me, that makes your conjecture very unlikely to be true...</div><br/></div></div></div></div></div></div></div></div><div id="40860378" class="c"><input type="checkbox" id="c-40860378" checked=""/><div class="controls bullet"><span class="by">danavar</span><span>|</span><a href="#40858336">parent</a><span>|</span><a href="#40858558">prev</a><span>|</span><a href="#40859559">next</a><span>|</span><label class="collapse" for="c-40860378">[-]</label><label class="expand" for="c-40860378">[1 more]</label></div><br/><div class="children"><div class="content">A message on LinkedIn or email never hurt!</div><br/></div></div></div></div><div id="40858734" class="c"><input type="checkbox" id="c-40858734" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#40858336">prev</a><span>|</span><a href="#40857949">next</a><span>|</span><label class="collapse" for="c-40858734">[-]</label><label class="expand" for="c-40858734">[1 more]</label></div><br/><div class="children"><div class="content">The original Busy Beaver paper by Tibor Radó (&quot;On Non-Computable Functions&quot;) is actually quite easy and fun to read.<p>For a modern version of the paper with some additional notes, see <a href="https:&#x2F;&#x2F;data.jigsaw.nl&#x2F;Rado_1962_OnNonComputableFunctions_Remastered.pdf" rel="nofollow">https:&#x2F;&#x2F;data.jigsaw.nl&#x2F;Rado_1962_OnNonComputableFunctions_Re...</a></div><br/></div></div><div id="40857949" class="c"><input type="checkbox" id="c-40857949" checked=""/><div class="controls bullet"><span class="by">kryptiskt</span><span>|</span><a href="#40858734">prev</a><span>|</span><a href="#40858783">next</a><span>|</span><label class="collapse" for="c-40857949">[-]</label><label class="expand" for="c-40857949">[10 more]</label></div><br/><div class="children"><div class="content">One notable thing here is that the proof is a Coq proof. I wonder if it is the first significant proof that starts out implemented in  a theorem prover, instead of being a known proof translated to such a system.<p>Note that there have been computer-assisted proofs before (four-color theorem, Kepler&#x27;s conjecture), but those were not done in a formally verified setting until later.</div><br/><div id="40858058" class="c"><input type="checkbox" id="c-40858058" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40857949">parent</a><span>|</span><a href="#40858816">next</a><span>|</span><label class="collapse" for="c-40858058">[-]</label><label class="expand" for="c-40858058">[1 more]</label></div><br/><div class="children"><div class="content">As far as I am aware, all of the proofs and techniques for each machine were present before mxdys managed to get the whole theorem into Coq: the main problem was that the deciders and manual proofs were disorganized and somewhat suspect. The worst offenders here were Skelet #1, which needed a bespoke program to accelerate it to its ultimate pattern [0], and Skelet #17, which took Xu seven pages&#x27; worth of dense reasoning to prove non-halting [1]. The full Coq proof put a much-needed degree of confidence into these results.<p>[0] <a href="https:&#x2F;&#x2F;www.sligocki.com&#x2F;2023&#x2F;03&#x2F;13&#x2F;skelet-1-infinite.html" rel="nofollow">https:&#x2F;&#x2F;www.sligocki.com&#x2F;2023&#x2F;03&#x2F;13&#x2F;skelet-1-infinite.html</a><p>[1] <a href="https:&#x2F;&#x2F;discuss.bbchallenge.org&#x2F;t&#x2F;skelet-17-does-not-halt&#x2F;184" rel="nofollow">https:&#x2F;&#x2F;discuss.bbchallenge.org&#x2F;t&#x2F;skelet-17-does-not-halt&#x2F;18...</a></div><br/></div></div><div id="40858816" class="c"><input type="checkbox" id="c-40858816" checked=""/><div class="controls bullet"><span class="by">ks2048</span><span>|</span><a href="#40857949">parent</a><span>|</span><a href="#40858058">prev</a><span>|</span><a href="#40858692">next</a><span>|</span><label class="collapse" for="c-40858816">[-]</label><label class="expand" for="c-40858816">[1 more]</label></div><br/><div class="children"><div class="content">Apparently, this is the proof in 19,000 lines of Coq:
<a href="https:&#x2F;&#x2F;github.com&#x2F;ccz181078&#x2F;Coq-BB5&#x2F;blob&#x2F;main&#x2F;BB52Theorem.v">https:&#x2F;&#x2F;github.com&#x2F;ccz181078&#x2F;Coq-BB5&#x2F;blob&#x2F;main&#x2F;BB52Theorem.v</a></div><br/></div></div><div id="40858692" class="c"><input type="checkbox" id="c-40858692" checked=""/><div class="controls bullet"><span class="by">poikroequ</span><span>|</span><a href="#40857949">parent</a><span>|</span><a href="#40858816">prev</a><span>|</span><a href="#40862530">next</a><span>|</span><label class="collapse" for="c-40858692">[-]</label><label class="expand" for="c-40858692">[6 more]</label></div><br/><div class="children"><div class="content">&gt; [The four color theorem] was the first major theorem to be proved using a computer.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Four_color_theorem" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Four_color_theorem</a><p>I guess maybe I don&#x27;t understand what you mean by &quot;formally verified setting&quot;, but I believe the four color theorem was first proven using a computer.<p>&gt; Although flawed, Kempe&#x27;s original purported proof of the four color theorem provided some of the basic tools later used to prove it.<p>It sounds like Kempe laid some of the groundwork, but then the theorem was ultimately proved using a computer.<p>I could be wrong though, I&#x27;m not an expert in this area.</div><br/><div id="40859135" class="c"><input type="checkbox" id="c-40859135" checked=""/><div class="controls bullet"><span class="by">nyssos</span><span>|</span><a href="#40857949">root</a><span>|</span><a href="#40858692">parent</a><span>|</span><a href="#40860418">next</a><span>|</span><label class="collapse" for="c-40859135">[-]</label><label class="expand" for="c-40859135">[4 more]</label></div><br/><div class="children"><div class="content">The original four color theorem proof used a computer as a computational aid for some nasty casework: the procedure for checking each case and the list of cases that needed to be checked were found by hand.<p>Proving something in a theorem prover means the proof itself is an object constructed in the prover&#x27;s language.</div><br/><div id="40860369" class="c"><input type="checkbox" id="c-40860369" checked=""/><div class="controls bullet"><span class="by">Almondsetat</span><span>|</span><a href="#40857949">root</a><span>|</span><a href="#40859135">parent</a><span>|</span><a href="#40860418">next</a><span>|</span><label class="collapse" for="c-40860369">[-]</label><label class="expand" for="c-40860369">[3 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s a bit too harsh. An entire complicated proof concocted solely looking at a computer screen in Coq? Every mathematician will have plenty of hand written sketches, ideas and parts of proofs. Does that mean it was &quot;ported&quot; to Coq?</div><br/><div id="40860429" class="c"><input type="checkbox" id="c-40860429" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40857949">root</a><span>|</span><a href="#40860369">parent</a><span>|</span><a href="#40862583">next</a><span>|</span><label class="collapse" for="c-40860429">[-]</label><label class="expand" for="c-40860429">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think that&#x27;s a bit too harsh. An entire complicated proof concocted solely looking at a computer screen in Coq?<p>Nobody is suggesting this, and in this case, it was indeed &quot;ported&quot; to Coq from existing sketches.<p>The distinction here isn&#x27;t between on-paper-first vs computer-first.  The distinction here is between using a custom computer program to perform computations for a mostly-paper proof, versus taking an existing general-purpose theorem-checker (Coq, in this case) and writing down the entire proof in its language so it can check it.</div><br/></div></div><div id="40862583" class="c"><input type="checkbox" id="c-40862583" checked=""/><div class="controls bullet"><span class="by">vilhelm_s</span><span>|</span><a href="#40857949">root</a><span>|</span><a href="#40860369">parent</a><span>|</span><a href="#40860429">prev</a><span>|</span><a href="#40860418">next</a><span>|</span><label class="collapse" for="c-40862583">[-]</label><label class="expand" for="c-40862583">[1 more]</label></div><br/><div class="children"><div class="content">No, the point is that the proof itself should be written in the Coq language. The original 4-color proof in 1976 was written in English. They used computer programs to do certain computations, but the proof that those programs were correct and that they were computing the right thing was written in English and checked by humans.</div><br/></div></div></div></div></div></div><div id="40860418" class="c"><input type="checkbox" id="c-40860418" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#40857949">root</a><span>|</span><a href="#40858692">parent</a><span>|</span><a href="#40859135">prev</a><span>|</span><a href="#40862530">next</a><span>|</span><label class="collapse" for="c-40860418">[-]</label><label class="expand" for="c-40860418">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m no expert either, but it&#x27;s interesting to note that the original computer-aided proof was erroneous. ctrl-f for <i>Schmidt</i> on the Wikipedia page.</div><br/></div></div></div></div><div id="40862530" class="c"><input type="checkbox" id="c-40862530" checked=""/><div class="controls bullet"><span class="by">nwallin</span><span>|</span><a href="#40857949">parent</a><span>|</span><a href="#40858692">prev</a><span>|</span><a href="#40858783">next</a><span>|</span><label class="collapse" for="c-40862530">[-]</label><label class="expand" for="c-40862530">[1 more]</label></div><br/><div class="children"><div class="content">Attempts to prove BB(5) would have begun long before theorem provers were around. This BB was discovered in 1990, and all machines of size 5 would have been enumerated not long after.</div><br/></div></div></div></div><div id="40858783" class="c"><input type="checkbox" id="c-40858783" checked=""/><div class="controls bullet"><span class="by">nickdrozd</span><span>|</span><a href="#40857949">prev</a><span>|</span><a href="#40858272">next</a><span>|</span><label class="collapse" for="c-40858783">[-]</label><label class="expand" for="c-40858783">[16 more]</label></div><br/><div class="children"><div class="content">Congratulations to the team! So the (blank tape) halting problem is solved for 5-state 2-color Turing machine programs. Has anyone tried applying these same techniques to the 2-state 4-color case? That seems like it would probably be tractable, although generally speaking colors are more powerful than states, so there might be some surprises there. (6-state 2-color and 2-state 5-color both seem intractable, perhaps even provably so.)<p>By the way, there is an extremely stupid but disturbingly widespread idea that humans are able to just intuit solutions to the halting problem, using the mind&#x27;s eye or quantum mechanics in the brain or whatever. Needless to say, this did not factor into the proof.</div><br/><div id="40858913" class="c"><input type="checkbox" id="c-40858913" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40858783">parent</a><span>|</span><a href="#40859278">next</a><span>|</span><label class="collapse" for="c-40858913">[-]</label><label class="expand" for="c-40858913">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Has anyone tried applying these same techniques to the 2-color 4-state case?<p>I assume you mean the 4-color case. As I understand it, the deciders currently in use are sufficient to prove all the 2×4 holdouts non-halting. So the current champion gives us Σ(2,4) = 2,050 and S(2,4) = 3,932,964, barring some big errors in the decider design. The result just hasn&#x27;t been organized in one place.<p>&gt; (6-state 2-color and 2-state 5-color both seem intractable, perhaps even provably so.)<p>Yes, 2×5 has the Hydra, and 6×2 has the Antihydra, which compute the same iteration, but with different starting points and halting conditions. The standard conjecture (related to Mahler&#x27;s 3&#x2F;2 problem) is that this iteration is uniformly distributed mod 2, and a proof of that conjecture would very likely prove both machines non-halting, by yielding suprema and infima on the cumulative ratio of 0s to 1s. But of course there is no known method of proof.</div><br/></div></div><div id="40859278" class="c"><input type="checkbox" id="c-40859278" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40858783">parent</a><span>|</span><a href="#40858913">prev</a><span>|</span><a href="#40859430">next</a><span>|</span><label class="collapse" for="c-40859278">[-]</label><label class="expand" for="c-40859278">[11 more]</label></div><br/><div class="children"><div class="content">&gt; By the way, there is an extremely stupid but disturbingly widespread idea that humans are able to just intuit solutions to the halting problem, using the mind&#x27;s eye or quantum mechanics in the brain or whatever. Needless to say, this did not factor into the proof.<p>The year is 52,000 CE and humans have solved BB(18) in the sense of exhaustively categorizing halting vs non-halting 19-state no-input programs. They have used a proof generator based on a logical theory called Aleph*, and at that time it had been known for 1.5k years that ZFC is incapable of establishing BB(18).<p>Compared to the year 2024 CE, considerable millennia before Aleph* came into use, it is clear that no program written at that point in history was capable of even using brute force proof checking to solve BB(18) in theory (like how we can enumerate and check ZFC proofs today to solve BB(??) in theory).<p>That&#x27;s what is meant by the &quot;humans intuit solutions to the halting problem&quot; position. AFAIK, there&#x27;s no known hard, theoretical reason why the above laid out future history cannot take place. And due to BB being incomputable, humans had to develop new theory to be able to construct the programs required. <i>Something</i> has to be accredited for the results, and it can&#x27;t be computation since the programs did not exist.</div><br/><div id="40859388" class="c"><input type="checkbox" id="c-40859388" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40859278">parent</a><span>|</span><a href="#40859897">next</a><span>|</span><label class="collapse" for="c-40859388">[-]</label><label class="expand" for="c-40859388">[8 more]</label></div><br/><div class="children"><div class="content">&gt; AFAIK, there&#x27;s no known hard, theoretical reason why the above laid out future history cannot take place.<p>Probably the biggest issue is that they&#x27;d have no method to establish that Aleph* is consistent. To continue this BB chain indefinitely, you must invent further and further first-order theories, each of which might not be consistent, let alone Σ₁-sound. And with an Σ₁-unsound theory, any halting proof might not hold up in the standard model of the integers. You&#x27;d effectively have to postulate an indefinite amount of oracular knowledge.<p>Also, another physical issue: you can show that within any consistent, recursively axiomatizable theory, the length of the shortest proof of &quot;the longest-running <i>n</i>-state machine is M&quot; must grow at an uncomputable rate in terms of <i>n</i>. Ditto for the shortest proof of &quot;machine M halts&quot;, where M is factually the longest-running <i>n</i>-state machine. Otherwise, a machine could use a computable bound on the proof length to solve the halting problem. Therefore, the proof should very quickly become too large to fit within our light cone.<p>In any case, the BB-related evidence for that position rested on BB(5) being determinable by extending the techniques used for BB(4). But in fact, it turns out that similar extensions don&#x27;t even get you to BB(6). So there isn&#x27;t anything to support the position, other than the pure speculation that anything is physically achievable given enough time.</div><br/><div id="40859634" class="c"><input type="checkbox" id="c-40859634" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40859388">parent</a><span>|</span><a href="#40859897">next</a><span>|</span><label class="collapse" for="c-40859634">[-]</label><label class="expand" for="c-40859634">[7 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing interesting info!<p>How do we know that there would be consistency issues or Σ₁-soundness issues?<p>Your claim about proof size categorizing n-state machine halting status is new to me. Do you have any links to read more about this?<p>The argument doesn&#x27;t make sense to me. Rather it seems like more of a consequence of BB being incomputable in the first place. The proof sizes for each BB(n) aren&#x27;t expected to be computable at all. There is necessarily a different theory for each n (or intervals of n where each theory applies with limits on each).<p>&gt; So there isn&#x27;t anything to support the position, other than the pure speculation that anything is physically achievable given enough time.<p>Something something burden of proof something. It would be extremely fascinating to have a conclusive argument that large BB numbers cannot be solved.</div><br/><div id="40859820" class="c"><input type="checkbox" id="c-40859820" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40859634">parent</a><span>|</span><a href="#40859897">next</a><span>|</span><label class="collapse" for="c-40859820">[-]</label><label class="expand" for="c-40859820">[6 more]</label></div><br/><div class="children"><div class="content">&gt; How do we know that there would be consistency issues or Σ₁-soundness issues?<p>From Gödel&#x27;s second incompleteness theorem, no consistent first-order recursively-axiomatizable theory (i.e., a theory that can have its proofs validated by a Turing machine) can prove its own consistency. Thus, to prove that your current theory (e.g., ZFC) is consistent, you must move to a stronger one (e.g., Aleph*). But then you can&#x27;t prove the consistency of that without an even stronger theory, and so on. Thus, you end up with an infinite regression, and you can&#x27;t ultimately prove the consistency of any of these theories.<p>&gt; Your claim about proof size categorizing n-state machine halting status is new to me. Do you have any links to read more about this?<p>Not really, other than some of my own ramblings on the bbchallenge Discord server. But it&#x27;s not that long:<p>Suppose that the longest-running <i>n</i>-state machine M can always be proven to halt using a proof of under f(<i>n</i>) symbols, where f(<i>n</i>) is some fixed computable function. Then, you could construct a TM that, given <i>n</i>, enumerates every valid proof of length less than f(<i>n</i>) symbols, and checks whether it shows that a particular <i>n</i>-state machine halts. The TM then simulates all of the proven halters to see how long they run. By assumption, the longest-running machine M is included in this list. So this TM can compute BB(<i>n</i>), which is an impossibility. Therefore, the function f(<i>n</i>) cannot exist.<p>As a corollary, since it&#x27;s &quot;uncomputably difficult&quot; to prove that the longest-running machine halts at all, it&#x27;s no less difficult to fully establish the value of BB(<i>n</i>).</div><br/><div id="40860774" class="c"><input type="checkbox" id="c-40860774" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40859820">parent</a><span>|</span><a href="#40859897">next</a><span>|</span><label class="collapse" for="c-40860774">[-]</label><label class="expand" for="c-40860774">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Thus, you end up with an infinite regression, and you can&#x27;t ultimately prove the consistency of any of these theories.<p>There is similar issue with even ZFC and PA. It’s not really a dealbreaker imo.<p>&gt; Suppose that the longest-running n-state machine M can always be proven to halt using a proof of under f(n) symbols, where f(n) is some fixed computable function. Then, you could construct a TM that, given n, enumerates every valid proof of length less than f(n) symbols<p>The issue with that argument is that the TM which enumerates every valid proof can’t exist in the first place.<p>If you fix an axiomatic theory, it’s already known that the theory has a limit.[1]<p>If every theory has a limit, you need countably infinitely many axiomatic theories together to prove BB(n) for all n. So there’s no TM which can even enumerate all the proofs, since a TM must have finite states, and thus can’t enumerate infinitely many proof systems.<p>(In fact for similar reasons I believe a Halt program, which has infinite states but which works for all TMs with finite states, platonically exists. It’s an emulator and an infinitely long busy beaver number lookup table. The diagonalization argument doesn’t apply, since the infinite Halt doesn’t accept itself as input.<p>This Halt would have countably many states since each busy beaver number is finitely calculated and there’s only countably many of them.)<p>So it’s not clear that f(n) is uncomputable. If f(n) is the symbol count and not the binary encoded length of the symbols, it even seems that it’s trivially bounded by some constant for all n. The proof could be one symbol the meaning of which is encoded in the theory.<p>It is a fascinating question though. I’m sure there is some function of axiomatic theory proof checker TM size and binary encoded proof length which does grow with n. It’s unclear if it would be uncomputable though.<p>The consequence of it being uncomputable is that the universe doesn’t have the resources to even encode the theory and&#x2F;or represent it’s proofs.<p>In fact I suppose even as long as it grows at all, there would be a limit to BB(n) which can be possibly determined. Very fascinating<p>[1]: page 5 <a href="https:&#x2F;&#x2F;www.scottaaronson.com&#x2F;papers&#x2F;bb.pdf" rel="nofollow">https:&#x2F;&#x2F;www.scottaaronson.com&#x2F;papers&#x2F;bb.pdf</a></div><br/><div id="40861265" class="c"><input type="checkbox" id="c-40861265" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40860774">parent</a><span>|</span><a href="#40862921">next</a><span>|</span><label class="collapse" for="c-40861265">[-]</label><label class="expand" for="c-40861265">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There is similar issue with even ZFC and PA. It’s not really a dealbreaker imo.<p>We obtain PA from our basic intuitions about how the standard integers work, derived from empirical evidence. Everything past that involves increasing levels of intuition. So to continue it indefinitely, you must postulate an infinite amount of <i>correct</i> intuition, in some magical fashion that can never be captured in a computer. You can claim unlimited ingenuity all you want, but there&#x27;s no a priori reason that it should indefinitely yield <i>the truth</i>, especially when it goes far, far past what our finite empiricism can provide.<p>We just haven&#x27;t hit these limits yet, since very weak inductive theories are still sufficient for proving BB(5): we don&#x27;t even need the full power of PA yet for our non-halting proofs. Thus why it looks like it should be so easy.<p>&gt; If you fix an axiomatic theory, it’s already known that the theory has a limit.[1]<p>Not quite. Fix some consistent axiomatic theory T which proves PA. Then there will be infinitely many TMs which do not halt (in the standard model), but T cannot prove that they cannot halt, due to incompleteness. (Therefore T cannot settle the BB(<i>n</i>) question past a certain point, as Aaronson correctly says.)<p>But for every TM that <i>does</i> halt (in the standard model), T <i>can</i> prove that it halts, and the proof is to list out a trace of the TM&#x27;s execution. Thus, every halting machine of every length has a halting proof in T.<p>The only benefit of a more powerful theory T is that it can &quot;compress&quot; this maximal BB(<i>n</i>)-sized proof into something more physically managable. But once we fix a certain T, we find (by my earlier argument) that it can only compress the proof so far, and the compressed size still must be an uncomputable function.<p>We can also see this by a forward argument, instead of by contradiction. Suppose that we&#x27;ll accept any halting proof in a theory T. Then we can write a TM that lists through all proofs in T that are smaller than some bound <i>N</i>. (Notice that this is a finite set, since I&#x27;ve put an upper bound on it!) Then, for every proof that is a valid halting proof, the TM runs the corresponding machine. Then, the TM will halt, and its halting time will be greater than the halting time of any machine that can be proven to halt in T within <i>N</i> symbols. Set <i>N</i> to Graham&#x27;s number (which is easily definable), and now the halting proof of the TM in T will not fit in our light cone.<p>(Notice how our TM clearly halts if T is Σ₁-sound! But since T cannot prove its own Σ₁-soundness, it doesn&#x27;t have any way to prove our TM halting other than by the brute-force method.)<p>&gt; In fact for similar reasons I believe a Halt program, which has infinite states but which works for all TMs with finite states, platonically exists. It’s an emulator and an infinitely long busy beaver number lookup table. The diagonalization argument doesn’t apply, since the infinite Halt doesn’t accept itself as input.<p>In that case, you just end up with the well-known oracle halting problem, where you equip a TM with access to this &quot;infinite-state&quot; machine. Then the problem is that you have a more powerful model of computation, but still with no way of solving <i>its own</i> halting problem. Much like how a consistent theory can only prove the consistency of weaker theories, not its own consistency.<p>&gt; So it’s not clear that f(n) is uncomputable. If f(n) is the symbol count and not the binary encoded length of the symbols, it even seems that it’s trivially bounded by some constant for all n. The proof could be one symbol the meaning of which is encoded in the theory.<p>Of course I&#x27;m fixing a particular theory and a particular alphabet of constant size, the alternative would be absurd. The important part is about the ultimate behavior as <i>n</i> varies.</div><br/><div id="40861771" class="c"><input type="checkbox" id="c-40861771" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40861265">parent</a><span>|</span><a href="#40862921">next</a><span>|</span><label class="collapse" for="c-40861771">[-]</label><label class="expand" for="c-40861771">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for typing all that out. It is very fascinating.<p>I’m just not convinced that fixing a theory and disallowing soundness axioms is any practical impairment for discovering busy beaver numbers.<p>Of course things get out of hand, but then why not collect evidence for soundness and let proofs avoid including an actual execution of the TM?<p>We don’t need a printout of grahams number computation to know a TM which computes it halts. why impose that here?<p>Has anybody done a compilation of such a PA proof generating&#x2F;checking and simulating TM? It must have an enormous number of states and almost certainly wouldn’t be the BB of its cohort. Not including how it should be a similar thing where to prove it’s step count we shouldn’t need to emulate it.</div><br/><div id="40862111" class="c"><input type="checkbox" id="c-40862111" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40861771">parent</a><span>|</span><a href="#40862921">next</a><span>|</span><label class="collapse" for="c-40862111">[-]</label><label class="expand" for="c-40862111">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We don’t need a printout of grahams number computation to know a TM which computes it halts. why impose that here?<p>Of course, the TM which &quot;computes Graham&#x27;s number&quot; can trivially be proven to halt, without running it fully.<p>But it is much harder to show that the TM (let&#x27;s call it M) which &quot;computes Graham&#x27;s number, then plugs it into a big halting-proof generator (in a fixed theory T) as an upper bound on the number of symbols, then executes each proven-halting TM in order&quot; also halts.<p>The problem is, just because a theory T gives a halting proof for a machine, doesn&#x27;t necessarily mean that it halts. (That is, T isn&#x27;t necessarily Σ₁-sound.) And if that doesn&#x27;t hold, then M might run into a &quot;fake halter&quot; that can be proven halting in T, but doesn&#x27;t truly halt in the standard model. Thus, the only ways to show that M halts are to either establish that T is Σ₁-sound, which can only be done by appealing to a stronger theory, or to run through each of the Graham&#x27;s number of proofs, which takes astronomically long.<p>This is similar to an instance of the Berry paradox: if you could easily prove that M halts, then it would have a relatively short halting proof within T. But then it would find its own halting proof, and simulate itself. But then it would simulate itself simulating itself, etc., etc., and never actually halt. So T wouldn&#x27;t be Σ₁-sound, since M doesn&#x27;t halt even though you proved that it halts. The only way out of this trap is if M <i>doesn&#x27;t</i> simulate itself, i.e., it takes more than Graham&#x27;s number of symbols in its own halting proof in T.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40859897" class="c"><input type="checkbox" id="c-40859897" checked=""/><div class="controls bullet"><span class="by">nickdrozd</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40859278">parent</a><span>|</span><a href="#40859388">prev</a><span>|</span><a href="#40859430">next</a><span>|</span><label class="collapse" for="c-40859897">[-]</label><label class="expand" for="c-40859897">[2 more]</label></div><br/><div class="children"><div class="content">&gt; They have used a proof generator based on a logical theory...<p>I don&#x27;t understand your scenario. If they&#x27;re using a proof generator, that sounds like the opposite of intuiting or using the human mind. Maybe they used &quot;intuition&quot; to come up with new axioms for a logical theory, but that is not the same as determining of some particular concrete TM program whether or not it halts.</div><br/><div id="40860589" class="c"><input type="checkbox" id="c-40860589" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40859897">parent</a><span>|</span><a href="#40859430">next</a><span>|</span><label class="collapse" for="c-40860589">[-]</label><label class="expand" for="c-40860589">[1 more]</label></div><br/><div class="children"><div class="content">You got it - the creative developments of a stronger theory. This allows the creation of tools which can categorize TMs, tools which wouldn’t exist otherwise.<p>It’s fascinating that the entire space of finite amounts of random gibberish contains every such stronger theory.<p>As a thought experiment it does well. Interestingly the Church-Turing thesis seems to exclude ingenuity. That is, it doesn’t try to say there aren’t functions on natural numbers which are uncomputable but can be calculated with ingenuity. Seems that a ton of people conflate those things.</div><br/></div></div></div></div></div></div><div id="40859430" class="c"><input type="checkbox" id="c-40859430" checked=""/><div class="controls bullet"><span class="by">ganzuul</span><span>|</span><a href="#40858783">parent</a><span>|</span><a href="#40859278">prev</a><span>|</span><a href="#40858892">next</a><span>|</span><label class="collapse" for="c-40859430">[-]</label><label class="expand" for="c-40859430">[1 more]</label></div><br/><div class="children"><div class="content">&gt; extremely stupid<p>This is simply a test for if consciousness has infinite computational resources.</div><br/></div></div><div id="40858892" class="c"><input type="checkbox" id="c-40858892" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#40858783">parent</a><span>|</span><a href="#40859430">prev</a><span>|</span><a href="#40858272">next</a><span>|</span><label class="collapse" for="c-40858892">[-]</label><label class="expand" for="c-40858892">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the 2-color 4-state case?<p>You mean the 2-state 4-color case...</div><br/><div id="40858963" class="c"><input type="checkbox" id="c-40858963" checked=""/><div class="controls bullet"><span class="by">nickdrozd</span><span>|</span><a href="#40858783">root</a><span>|</span><a href="#40858892">parent</a><span>|</span><a href="#40858272">next</a><span>|</span><label class="collapse" for="c-40858963">[-]</label><label class="expand" for="c-40858963">[1 more]</label></div><br/><div class="children"><div class="content">Fixed, thanks</div><br/></div></div></div></div></div></div><div id="40858272" class="c"><input type="checkbox" id="c-40858272" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#40858783">prev</a><span>|</span><a href="#40858161">next</a><span>|</span><label class="collapse" for="c-40858272">[-]</label><label class="expand" for="c-40858272">[19 more]</label></div><br/><div class="children"><div class="content">So we were just lucky that all non-halting programs of length 5 just happened to be provably non-halting?</div><br/><div id="40858368" class="c"><input type="checkbox" id="c-40858368" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40858272">parent</a><span>|</span><a href="#40860499">next</a><span>|</span><label class="collapse" for="c-40858368">[-]</label><label class="expand" for="c-40858368">[1 more]</label></div><br/><div class="children"><div class="content">Yes. In fact, Allen Brady feared as early as 1988 that there would be a totally intractable machine with 5 states [0]:<p>&gt; <i>Prediction 5.</i> It will never be proved that Σ(5) = 1,915 and <i>S</i>(5) = 2,358,064. (Or, if any larger lower bounds are ever found, the new values may be substituted into the prediction.)<p>&gt; Reason: Nature has probably embedded among the five-state holdout machines one or more problems as illusive as the <i>Goldbach Conjecture</i>. Or, in other terms, there will likely be nonstopping recursive patterns which are beyond our powers of recognition.<p>Luckily, this prediction did not come to pass, but only by a margin of one extra state.<p>[0] Allen Brady, &quot;The Busy Beaver Game and the Meaning of Life&quot;, in Rolf Herken (ed.), <i>The Universal Turing Machine: A Half-Century Survey</i>, Oxford University Press, 1988, pp. 259–277. This chapter can also be found in the 2nd ed., Springer, 1995, pp. 237–254.</div><br/></div></div><div id="40860499" class="c"><input type="checkbox" id="c-40860499" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40858272">parent</a><span>|</span><a href="#40858368">prev</a><span>|</span><a href="#40858328">next</a><span>|</span><label class="collapse" for="c-40860499">[-]</label><label class="expand" for="c-40860499">[11 more]</label></div><br/><div class="children"><div class="content">When you say &quot;provably&quot;, do you mean that in the mathematical sense or in a practical sense?<p>For the practical sense, other commenters have already replied.<p>For the mathematical sense, I would say it would be pretty surprising to me if BB(5) had been undecidable -- 5 states and 2 symbols is just so few with which to try to encode undecidable behavior.<p>However, it&#x27;s worth noting that as a consequence of the incompleteness theorem, there must be <i>some</i> n such that standard mathematics cannot prove the value of BB(n).  And in recent years various people have been working on finding such n and seeing how low they can get the number.  The current record[0] is 745.<p>I expect that record can be probably be brought lower (more easily than the record for computing BB can be brought higher!), but even so, that&#x27;s a lot of distance between 5 (the highest we know) and 745 (the lowest we know to be unknowable).<p>[0]This is the current record both for ZFC and for PA, in case you&#x27;re wondering what I mean by &quot;standard mathematics&quot;... so it at least ought to be possible to bring it down further for PA!  I think so far nobody&#x27;s found a way to do better for PA than for ZFC, even though, like, that has to be possible, right?</div><br/><div id="40862860" class="c"><input type="checkbox" id="c-40862860" checked=""/><div class="controls bullet"><span class="by">6nf</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40860499">parent</a><span>|</span><a href="#40862624">next</a><span>|</span><label class="collapse" for="c-40862860">[-]</label><label class="expand" for="c-40862860">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 5 states and 2 symbols is just so few with which to try to encode undecidable behavior.<p>Would you be brave enough to say the same thing about BB(6) or BB(7)?</div><br/><div id="40863508" class="c"><input type="checkbox" id="c-40863508" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40862860">parent</a><span>|</span><a href="#40862624">next</a><span>|</span><label class="collapse" for="c-40863508">[-]</label><label class="expand" for="c-40863508">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that would definitely surprise me.</div><br/></div></div></div></div><div id="40862624" class="c"><input type="checkbox" id="c-40862624" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40860499">parent</a><span>|</span><a href="#40862860">prev</a><span>|</span><a href="#40860931">next</a><span>|</span><label class="collapse" for="c-40862624">[-]</label><label class="expand" for="c-40862624">[2 more]</label></div><br/><div class="children"><div class="content">So I know we can prove that we cannot solve the halting problem for all TM.<p>But for any given TM, can we decide whether it is provable or not? Or will we meet some that we will never know if we can solve or not?</div><br/><div id="40862760" class="c"><input type="checkbox" id="c-40862760" checked=""/><div class="controls bullet"><span class="by">UncombedCoconut</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40862624">parent</a><span>|</span><a href="#40860931">next</a><span>|</span><label class="collapse" for="c-40862760">[-]</label><label class="expand" for="c-40862760">[1 more]</label></div><br/><div class="children"><div class="content">Sadly, we can&#x27;t, for such a test would already be enough to solve the halting problem: if a TM&#x27;s status is provable, enumerate possible proofs (of halting and non-halting) until we find one and know the result; if the status is not provable, then the machine certainly cannot halt.</div><br/></div></div></div></div><div id="40860931" class="c"><input type="checkbox" id="c-40860931" checked=""/><div class="controls bullet"><span class="by">ko27</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40860499">parent</a><span>|</span><a href="#40862624">prev</a><span>|</span><a href="#40862071">next</a><span>|</span><label class="collapse" for="c-40860931">[-]</label><label class="expand" for="c-40860931">[4 more]</label></div><br/><div class="children"><div class="content">Are there any interesting mathematical problems that can be encoded with 5 states and 2 symbols, which now we can prove using BB(5)?</div><br/><div id="40861192" class="c"><input type="checkbox" id="c-40861192" checked=""/><div class="controls bullet"><span class="by">UncombedCoconut</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40860931">parent</a><span>|</span><a href="#40861095">next</a><span>|</span><label class="collapse" for="c-40861192">[-]</label><label class="expand" for="c-40861192">[2 more]</label></div><br/><div class="children"><div class="content">Mostly no: we did find some non-halting TMs that required new proofs, but none of those had the flavor of new math, per se.
Indeed, we found that all but 30 of them could be proved by finite automata methods, meaning the TM&#x27;s state&#x2F;tape at any step could be reduced to one of finitely many states and we&#x27;d still know all we needed to know about future steps. I would argue that such a non-halting proof can&#x27;t have much mathematical content. (Maybe a bit, in about the same way that an integer equation is sometimes proved unsolvable by considering it modulo n and checking every case.)
Also, I learned some math I wasn&#x27;t personally familiar with from the analysis of a particular machine: <a href="https:&#x2F;&#x2F;www.sligocki.com&#x2F;2023&#x2F;03&#x2F;14&#x2F;skelet-10.html" rel="nofollow">https:&#x2F;&#x2F;www.sligocki.com&#x2F;2023&#x2F;03&#x2F;14&#x2F;skelet-10.html</a> (Zeckendorf&#x27;s Theorem).</div><br/><div id="40861339" class="c"><input type="checkbox" id="c-40861339" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40861192">parent</a><span>|</span><a href="#40861095">next</a><span>|</span><label class="collapse" for="c-40861339">[-]</label><label class="expand" for="c-40861339">[1 more]</label></div><br/><div class="children"><div class="content">Tangential, but fun fact about Zeckendorf: In addition to Zeckendorf representation, there&#x27;s also <i>dual</i> Zeckendorf (sometimes also called lazy Fibonacci), where instead of requiring no two consecutive ones, you require no two consecutive <i>zeroes</i>.  (Not counting the implicit zeroes at the big end, of course.)  It was surprising to me that this also works, but it does!<p>Actually, just as you can do bijective base-b [0], you can also do bijective Zeckendorf (using 1 and 2 with no two consecutive 1s).  Although, as happens with bijective binary, bijective Zeckendorf is closely tied to ordinary Zeckendorf, so it doesn&#x27;t offer much new.  But bijective <i>dual</i> Zeckendorf doesn&#x27;t work -- lots of numbers can&#x27;t be represented!<p>One more fun fact about Zeckendorf and dual Zeckendorf: Write n&gt;0 in Zeckendorf, and count how many zeroes it ends in.  This will be even if the <i>dual</i> Zeckendorf representation of n ends in a 1, and odd if it ends in a 0.  Similarly, if you write n in dual Zeckendorf and count how many 1s it ends in, this will be even if the (ordinary) Zeckendorf representation ends in a 0 and odd if it ends in a 1.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bijective_numeration" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bijective_numeration</a></div><br/></div></div></div></div><div id="40861095" class="c"><input type="checkbox" id="c-40861095" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40860931">parent</a><span>|</span><a href="#40861192">prev</a><span>|</span><a href="#40862071">next</a><span>|</span><label class="collapse" for="c-40861095">[-]</label><label class="expand" for="c-40861095">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe so.  But even if there were, unfortunately, these things basically work the other way around.<p>If you can encode a problem in n states, and you know BB(n), then, as you say, you could use that to solve the problem.  Trouble is, how do you know BB(n)?  In reality, the only way to determine BB(n) is to go and solve all such problems; there isn&#x27;t any other easier method that you can apply that would then let you get answers for these problems as a consequence.<p>So, the value of BB(n) will always be a summation of &quot;we did all the hard work of solving all the n-state problems&quot;, not something you do separately to get those answers out.</div><br/></div></div></div></div><div id="40862071" class="c"><input type="checkbox" id="c-40862071" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40860499">parent</a><span>|</span><a href="#40860931">prev</a><span>|</span><a href="#40858328">next</a><span>|</span><label class="collapse" for="c-40862071">[-]</label><label class="expand" for="c-40862071">[2 more]</label></div><br/><div class="children"><div class="content">BB(745) being independent of ZFC isn’t due to incompleteness theorems. It encodes a different theorem which is also independent of ZFC.<p><a href="https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=2725" rel="nofollow">https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=2725</a></div><br/><div id="40862143" class="c"><input type="checkbox" id="c-40862143" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40862071">parent</a><span>|</span><a href="#40858328">next</a><span>|</span><label class="collapse" for="c-40862143">[-]</label><label class="expand" for="c-40862143">[1 more]</label></div><br/><div class="children"><div class="content">Well, that post is about 8000, not 745; but yes, in general, you are not going to use a Gödel sentence when trying to drive down the record.<p>This isn&#x27;t disagreeing with what I was saying, though; I said incompleteness requires there is some such n, and then also said what we know about the record, I didn&#x27;t say the record comes from a Gödel sentence.</div><br/></div></div></div></div></div></div><div id="40858328" class="c"><input type="checkbox" id="c-40858328" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#40858272">parent</a><span>|</span><a href="#40860499">prev</a><span>|</span><a href="#40858161">next</a><span>|</span><label class="collapse" for="c-40858328">[-]</label><label class="expand" for="c-40858328">[6 more]</label></div><br/><div class="children"><div class="content">The article touches on that:<p>&gt; But just four days ago, mxdys and another contributor known as Racheline discovered a barrier for BB(6) that seems insurmountable: a six-rule machine whose halting problem resembles a famously intractable math problem called the Collatz conjecture. Connections between Turing machines and the Collatz conjecture date back to a 1993 paper by the mathematician Pascal Michel, but the newly discovered machine, dubbed “Antihydra,” is the smallest one that appears unsolvable without a conceptual breakthrough in mathematics.</div><br/><div id="40859838" class="c"><input type="checkbox" id="c-40859838" checked=""/><div class="controls bullet"><span class="by">dwh452</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40858328">parent</a><span>|</span><a href="#40858161">next</a><span>|</span><label class="collapse" for="c-40859838">[-]</label><label class="expand" for="c-40859838">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious how the Turing machines can resemble problems which take input? BB(n) is defined as a n-state Turing machine that starts off with an empty tape. Collatz(n) is how many steps are taken before it terminates when starting with input &#x27;n&#x27;.<p>Does this mean a BB(6) machine which resembles Collatz is testing all possible values as part of it program and not part of anything on the tape (since the tape start out empty)?</div><br/><div id="40859966" class="c"><input type="checkbox" id="c-40859966" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40859838">parent</a><span>|</span><a href="#40862089">next</a><span>|</span><label class="collapse" for="c-40859966">[-]</label><label class="expand" for="c-40859966">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not testing all values, but one particular starting point. In all likelyhood, it will never reach its stopping condition from this starting point, but proving this even for a single value is currently intractable. Compare with the &quot;5<i>x</i> + 1&quot; variant of the Collatz cojecture, where many values are believed (but not proven) to run off to infinity, never to return.</div><br/></div></div><div id="40862089" class="c"><input type="checkbox" id="c-40862089" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40859838">parent</a><span>|</span><a href="#40859966">prev</a><span>|</span><a href="#40858161">next</a><span>|</span><label class="collapse" for="c-40862089">[-]</label><label class="expand" for="c-40862089">[3 more]</label></div><br/><div class="children"><div class="content">Edit:nvm see thread<p>For collatz, the empty input machine loops over all natural numbers and halts if it finds one which doesn’t eventually reach 1.<p>To prove that it never halts, you’d have to prove the collatz conjecture. Otherwise you’d have to find the smallest counter example of the collatz conjecture.</div><br/><div id="40862167" class="c"><input type="checkbox" id="c-40862167" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40862089">parent</a><span>|</span><a href="#40858161">next</a><span>|</span><label class="collapse" for="c-40862167">[-]</label><label class="expand" for="c-40862167">[2 more]</label></div><br/><div class="children"><div class="content">Suppose that there exists a natural number that diverges to infinity under the Collatz map. Then the Collatz conjecture would be false, but your machine would still run forever on that diverging number. As far as I am aware, there is no known machine that halts iff the Collatz conjecture is false.</div><br/><div id="40862478" class="c"><input type="checkbox" id="c-40862478" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40858272">root</a><span>|</span><a href="#40862167">parent</a><span>|</span><a href="#40858161">next</a><span>|</span><label class="collapse" for="c-40862478">[-]</label><label class="expand" for="c-40862478">[1 more]</label></div><br/><div class="children"><div class="content">You are correct, thank you</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40858161" class="c"><input type="checkbox" id="c-40858161" checked=""/><div class="controls bullet"><span class="by">phaedrus</span><span>|</span><a href="#40858272">prev</a><span>|</span><a href="#40858475">next</a><span>|</span><label class="collapse" for="c-40858161">[-]</label><label class="expand" for="c-40858161">[1 more]</label></div><br/><div class="children"><div class="content">I wrote program to solve the cutting stock problem (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cutting_stock_problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cutting_stock_problem</a>) for a personal project.  I couldn&#x27;t (or didn&#x27;t want to) use any existing program for it because my stock involved cutting pieces shaped like either &#x2F;---&#x2F;, &#x2F;---|, or |---| and I didn&#x27;t want to waste material on the 45 cut.<p>I find it interesting that the description of Brady&#x27;s program to optimize search for BB(4) by cutting out search subtrees whose differences don&#x27;t matter is fairly close to a description of what I did to make my program fast.</div><br/></div></div><div id="40858475" class="c"><input type="checkbox" id="c-40858475" checked=""/><div class="controls bullet"><span class="by">ks2048</span><span>|</span><a href="#40858161">prev</a><span>|</span><a href="#40863235">next</a><span>|</span><label class="collapse" for="c-40858475">[-]</label><label class="expand" for="c-40858475">[3 more]</label></div><br/><div class="children"><div class="content">According to Scott Aaronson&#x27;s blog post on this, there are 16,679,880,978,201 5-state Turing machines. I wonder if we know what percentage of them halt?<p>Edit: number of TM for n states: (4n + 1)^(2n). Found this (for smaller n), which is the kind of analysis I was curious about: <a href="https:&#x2F;&#x2F;github.com&#x2F;LukasKalbertodt&#x2F;beaver">https:&#x2F;&#x2F;github.com&#x2F;LukasKalbertodt&#x2F;beaver</a></div><br/><div id="40862130" class="c"><input type="checkbox" id="c-40862130" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40858475">parent</a><span>|</span><a href="#40863235">next</a><span>|</span><label class="collapse" for="c-40862130">[-]</label><label class="expand" for="c-40862130">[2 more]</label></div><br/><div class="children"><div class="content">We must know the percentage which halt! I can’t find it in the bbchallenge.org site, but every machine is categorized.</div><br/><div id="40862372" class="c"><input type="checkbox" id="c-40862372" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40858475">root</a><span>|</span><a href="#40862130">parent</a><span>|</span><a href="#40863235">next</a><span>|</span><label class="collapse" for="c-40862372">[-]</label><label class="expand" for="c-40862372">[1 more]</label></div><br/><div class="children"><div class="content">Not necessarily. The seed database only contains TMs in tree normal form (TNF), which already contains several reductions. To convert the percentage of TNF halters to the percentage of total halters, you&#x27;d have to account for the multiplicity of each TNF machine, which is a bunch of fiddly combinatorics. Also, you&#x27;d have to add the machines that have no TNF form due to never writing a 1 to the tape.</div><br/></div></div></div></div></div></div><div id="40863235" class="c"><input type="checkbox" id="c-40863235" checked=""/><div class="controls bullet"><span class="by">Jean-Papoulos</span><span>|</span><a href="#40858475">prev</a><span>|</span><a href="#40862285">next</a><span>|</span><label class="collapse" for="c-40863235">[-]</label><label class="expand" for="c-40863235">[3 more]</label></div><br/><div class="children"><div class="content">Can someone explain how there can a finite number of rules ?
Could the rule &quot;If it&#x27;s a 0, change it to 1 and move 3 squares to the left&quot; produce a different result than when moving 4 squares, or is that not the case ?</div><br/><div id="40863739" class="c"><input type="checkbox" id="c-40863739" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40863235">parent</a><span>|</span><a href="#40863267">next</a><span>|</span><label class="collapse" for="c-40863739">[-]</label><label class="expand" for="c-40863739">[1 more]</label></div><br/><div class="children"><div class="content">A turing machine rule can only:<p>- set the current cell’s value<p>- move by one cell<p>- switch to the next rule (or halt)<p>(A TM rule has one sub-rule for each valid value &#x2F; symbol)<p>Turing machines are characterised by the number of values (or symbols) and the number of rules (or states) (and technically the number of directions but TMs are generally one-dimensional). The Busy Beaver game fixes the number of symbols to 2, and only varies the number of states e.g. BB(3) is played on 3-states 2-symbols turing machines.<p>Thus the number of possible rules in BB(n) (n-states 2 symbols turing machine) is necessarily limited, to (4n + 4)^2n.</div><br/></div></div><div id="40863267" class="c"><input type="checkbox" id="c-40863267" checked=""/><div class="controls bullet"><span class="by">hmry</span><span>|</span><a href="#40863235">parent</a><span>|</span><a href="#40863739">prev</a><span>|</span><a href="#40862285">next</a><span>|</span><label class="collapse" for="c-40863267">[-]</label><label class="expand" for="c-40863267">[1 more]</label></div><br/><div class="children"><div class="content">You can only ever move one step to the left or right. If you want to move multiple steps, you need multiple states to use as a counter, or set up the tape a specific way ahead of time so you know when to stop moving.</div><br/></div></div></div></div><div id="40862285" class="c"><input type="checkbox" id="c-40862285" checked=""/><div class="controls bullet"><span class="by">DowsingSpoon</span><span>|</span><a href="#40863235">prev</a><span>|</span><a href="#40862719">next</a><span>|</span><label class="collapse" for="c-40862285">[-]</label><label class="expand" for="c-40862285">[6 more]</label></div><br/><div class="children"><div class="content">Maybe I’m just an unsophisticated code monkey, but I read a little about Busy Beaver from time to time and I just don’t get it. Why is this an interesting problem? What do we hope to learn from it?</div><br/><div id="40862998" class="c"><input type="checkbox" id="c-40862998" checked=""/><div class="controls bullet"><span class="by">MrCheeze</span><span>|</span><a href="#40862285">parent</a><span>|</span><a href="#40862774">next</a><span>|</span><label class="collapse" for="c-40862998">[-]</label><label class="expand" for="c-40862998">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.scottaaronson.com&#x2F;writings&#x2F;bignumbers.html" rel="nofollow">https:&#x2F;&#x2F;www.scottaaronson.com&#x2F;writings&#x2F;bignumbers.html</a></div><br/></div></div><div id="40862774" class="c"><input type="checkbox" id="c-40862774" checked=""/><div class="controls bullet"><span class="by">lkuty</span><span>|</span><a href="#40862285">parent</a><span>|</span><a href="#40862998">prev</a><span>|</span><a href="#40862719">next</a><span>|</span><label class="collapse" for="c-40862774">[-]</label><label class="expand" for="c-40862774">[4 more]</label></div><br/><div class="children"><div class="content">IMO, because it gives you a way to know if a program will terminate or not. If it consists of 5 states and goes beyond 47176870 steps of execution, then it will never halt. However, we are currently limited to 1 to 5 states Turing programs. And you can make correspondance between some Turing machines and some theorems in Mathematics thus it gives you a way to prove them I guess.</div><br/><div id="40863153" class="c"><input type="checkbox" id="c-40863153" checked=""/><div class="controls bullet"><span class="by">suzzer99</span><span>|</span><a href="#40862285">root</a><span>|</span><a href="#40862774">parent</a><span>|</span><a href="#40862934">next</a><span>|</span><label class="collapse" for="c-40863153">[-]</label><label class="expand" for="c-40863153">[2 more]</label></div><br/><div class="children"><div class="content">The one thing I didn&#x27;t understand is the distribution 1s and 0s on the tape. Does each Turing machine have to be solved for all possible combinations of 1s and 0s?</div><br/><div id="40863466" class="c"><input type="checkbox" id="c-40863466" checked=""/><div class="controls bullet"><span class="by">ropejumper</span><span>|</span><a href="#40862285">root</a><span>|</span><a href="#40863153">parent</a><span>|</span><a href="#40862934">next</a><span>|</span><label class="collapse" for="c-40863466">[-]</label><label class="expand" for="c-40863466">[1 more]</label></div><br/><div class="children"><div class="content">The game is defined to start with an infinite all-zeroes tape.</div><br/></div></div></div></div><div id="40862934" class="c"><input type="checkbox" id="c-40862934" checked=""/><div class="controls bullet"><span class="by">DowsingSpoon</span><span>|</span><a href="#40862285">root</a><span>|</span><a href="#40862774">parent</a><span>|</span><a href="#40863153">prev</a><span>|</span><a href="#40862719">next</a><span>|</span><label class="collapse" for="c-40862934">[-]</label><label class="expand" for="c-40862934">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! I’m trying to read up on it now also because this is definitely not something I know much about.</div><br/></div></div></div></div></div></div><div id="40862719" class="c"><input type="checkbox" id="c-40862719" checked=""/><div class="controls bullet"><span class="by">seeknotfind</span><span>|</span><a href="#40862285">prev</a><span>|</span><a href="#40857473">next</a><span>|</span><label class="collapse" for="c-40862719">[-]</label><label class="expand" for="c-40862719">[1 more]</label></div><br/><div class="children"><div class="content">Who else thinks mxdys is an AI program gone rogue? Thank you sweet mxdys!</div><br/></div></div><div id="40857473" class="c"><input type="checkbox" id="c-40857473" checked=""/><div class="controls bullet"><span class="by">jl6</span><span>|</span><a href="#40862719">prev</a><span>|</span><a href="#40859587">next</a><span>|</span><label class="collapse" for="c-40857473">[-]</label><label class="expand" for="c-40857473">[17 more]</label></div><br/><div class="children"><div class="content">BB(0) = 0<p>BB(1) = 1<p>BB(2) = 4<p>BB(3) = 6<p>BB(4) = 13<p>They just proved that BB(5) = 47,176,870.<p>It is known that BB(6) must be at least 10^10^...^10 (a tower of exponents fifteen levels high).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Busy_beaver#Known_values_for_%CE%A3_and_S" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Busy_beaver#Known_values_for_%...</a></div><br/><div id="40857702" class="c"><input type="checkbox" id="c-40857702" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#40857473">parent</a><span>|</span><a href="#40857653">next</a><span>|</span><label class="collapse" for="c-40857702">[-]</label><label class="expand" for="c-40857702">[9 more]</label></div><br/><div class="children"><div class="content">The definitions of the &quot;BB&quot; function don&#x27;t all appear to be the same. The article referenced in this overall discussion says BB(2) = 6. In the notation of the Wikipedia article you reference, this would be S(2) = 6; S is the number of steps. What has now been proved is that S(5) = 47,176,870.<p>However, your BB values for 0, 1, 2, 3, and 4 match the Wikipedia article&#x27;s notation for Sigma; Sigma is the number of 1s written on the tape at halting. In that notation, what has now been proved is Sigma(5) = 4098.</div><br/><div id="40857907" class="c"><input type="checkbox" id="c-40857907" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40857702">parent</a><span>|</span><a href="#40857653">next</a><span>|</span><label class="collapse" for="c-40857907">[-]</label><label class="expand" for="c-40857907">[8 more]</label></div><br/><div class="children"><div class="content">Yeah, this is a bit confusing, and the subject of repeated internal controversy. Most of the twentieth-century authors focused on the number of 1s, Σ(<i>n</i>), following Radó&#x27;s original practice of treating σ(M) as the score of a machine M in the &quot;Busy Beaver game&quot;. But when Aaronson re-popularized it in 2020 [0], he used BB(<i>n</i>) to denote the number of steps (which Radó called S(<i>n</i>)), and the bbchallenge project has been using this latter convention for publicity. Pascal Michel&#x27;s website [1] has all the Σ(<i>n</i>) and S(<i>n</i>) bounds up to <i>n</i> = 7.<p>Personally, I think both functions have their strengths and weaknesses. Σ(<i>n</i>) is easier to calculate for machines that run too long to be simulated directly (e.g., Skelet #1 from the article) but leave a known pattern on the tape, and it also has historical priority. But S(<i>n</i>) has a simpler argument for being undecidable, since it provides a trivial filter for testing if a candidate machine cannot halt. Also, σ(M) is a bit weird in that it has no lower bound in terms of s(M), since an adversarial machine could do a colossal amount of work before wiping its tape at the end.<p>Regardless, past BB(3), there isn&#x27;t any known size where the champion machines for Σ(<i>n</i>) and S(<i>n</i>) are different. (At least, the <i>sets</i> of champion machines aren&#x27;t disjoint: Σ(5) = 4098 is shared by both the S(5) champion and another machine that runs a quarter as long.) The score of a machine is dominated by googological strength rather than technicalities in the definition.<p>[0] <a href="https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=4916" rel="nofollow">https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=4916</a><p>[1] <a href="https:&#x2F;&#x2F;bbchallenge.org&#x2F;~pascal.michel&#x2F;ha" rel="nofollow">https:&#x2F;&#x2F;bbchallenge.org&#x2F;~pascal.michel&#x2F;ha</a></div><br/><div id="40858879" class="c"><input type="checkbox" id="c-40858879" checked=""/><div class="controls bullet"><span class="by">nickdrozd</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40857907">parent</a><span>|</span><a href="#40858027">next</a><span>|</span><label class="collapse" for="c-40858879">[-]</label><label class="expand" for="c-40858879">[5 more]</label></div><br/><div class="children"><div class="content">&gt; past BB(3), there isn&#x27;t any known size where the champion machines for Σ(n) and S(n) are different.<p>My feeling is that this trend cannot continue forever, and for infinitely many N they are different. If they are always the same, then you could find the steps champion just by finding the marks champion. This would be convenient, because as you pointed out, steps are more logically important, while marks are more practically important. But this feels too good to be true, and so it probably isn&#x27;t.</div><br/><div id="40858940" class="c"><input type="checkbox" id="c-40858940" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40858879">parent</a><span>|</span><a href="#40861864">next</a><span>|</span><label class="collapse" for="c-40858940">[-]</label><label class="expand" for="c-40858940">[2 more]</label></div><br/><div class="children"><div class="content">Hmm, around <i>n</i> = 2 or <i>k</i> = 2, there are only 2 added transitions for a machine to do &quot;the next big thing&quot; googologically, so that doesn&#x27;t leave much slack for many different machines at the same level. But maybe that could happen closer to the <i>n</i> = <i>k</i> line, where each increment adds many new transitions. Or to the contrary, maybe each increment just does several &quot;next big things&quot;.</div><br/><div id="40863419" class="c"><input type="checkbox" id="c-40863419" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40858940">parent</a><span>|</span><a href="#40861864">next</a><span>|</span><label class="collapse" for="c-40863419">[-]</label><label class="expand" for="c-40863419">[1 more]</label></div><br/><div class="children"><div class="content">Or the next big things were implementable at n-3, but finally pay off at n+1?</div><br/></div></div></div></div><div id="40861864" class="c"><input type="checkbox" id="c-40861864" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40858879">parent</a><span>|</span><a href="#40858940">prev</a><span>|</span><a href="#40858027">next</a><span>|</span><label class="collapse" for="c-40861864">[-]</label><label class="expand" for="c-40861864">[2 more]</label></div><br/><div class="children"><div class="content">What does &quot;practically&quot; mean here?</div><br/><div id="40862520" class="c"><input type="checkbox" id="c-40862520" checked=""/><div class="controls bullet"><span class="by">nickdrozd</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40861864">parent</a><span>|</span><a href="#40858027">next</a><span>|</span><label class="collapse" for="c-40862520">[-]</label><label class="expand" for="c-40862520">[1 more]</label></div><br/><div class="children"><div class="content">Busy Beaver champion programs are said to run for super-exponentially many steps. But nobody has actually run their simulators for that many steps. Instead, simulators can prove tape fast-forwarding rules. Basically, you look for repeating tape patterns. If you can prove the pattern is correct, then you can apply that transformation again if some tape circumstance shows up again.<p>For example (using run-length encoding),
  1^n 0 1^m
might become
  1^(n-1) 0 1^(m+2)<p>When the rule is applied, the transformation is applied directly to the tape, generally by manipulating some count variables.<p>Now, how many machine steps does it take to apply this transformation? Well, TBH I&#x27;m not really sure. It seems kinda complicated, especially when the rules get more elaborate. If you are trying to run your simulator as fast as possible, you probably don&#x27;t want to bother calculating it at all anyway, since you can always rerun the analysis at a more leisurely pace later.<p>So when I say that marks are &quot;more practically important&quot;, I mean that marks are central to the operation of advanced simulators, whereas steps are a derived afterthought value.<p>Logically, the steps are more important, since they give you an easy method for solving the halting problem for the state&#x2F;color class.<p>So far, the markiest programs are also the steppiest. My conjecture is that they will turn out to be different in infinitely many classes. If they were always the same, you would be able to get the logical primacy of steps just from working with marks. And that sounds too good to be true.</div><br/></div></div></div></div></div></div><div id="40858027" class="c"><input type="checkbox" id="c-40858027" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40857907">parent</a><span>|</span><a href="#40858879">prev</a><span>|</span><a href="#40857653">next</a><span>|</span><label class="collapse" for="c-40858027">[-]</label><label class="expand" for="c-40858027">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for this information, it&#x27;s very helpful! Also I had no idea that &quot;googological strength&quot; was a thing. :-)</div><br/><div id="40858279" class="c"><input type="checkbox" id="c-40858279" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40858027">parent</a><span>|</span><a href="#40857653">next</a><span>|</span><label class="collapse" for="c-40858279">[-]</label><label class="expand" for="c-40858279">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll just leave this here: <a href="https:&#x2F;&#x2F;googology.fandom.com&#x2F;wiki&#x2F;Googology_Wiki" rel="nofollow">https:&#x2F;&#x2F;googology.fandom.com&#x2F;wiki&#x2F;Googology_Wiki</a></div><br/></div></div></div></div></div></div></div></div><div id="40858148" class="c"><input type="checkbox" id="c-40858148" checked=""/><div class="controls bullet"><span class="by">Natsu</span><span>|</span><a href="#40857473">parent</a><span>|</span><a href="#40857653">prev</a><span>|</span><a href="#40857578">next</a><span>|</span><label class="collapse" for="c-40858148">[-]</label><label class="expand" for="c-40858148">[5 more]</label></div><br/><div class="children"><div class="content">Looking at the pictures on Wikipedia regarding those programs, it&#x27;s interesting how they seem to result in fractals.</div><br/><div id="40858278" class="c"><input type="checkbox" id="c-40858278" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40858148">parent</a><span>|</span><a href="#40859613">next</a><span>|</span><label class="collapse" for="c-40858278">[-]</label><label class="expand" for="c-40858278">[1 more]</label></div><br/><div class="children"><div class="content">This mainly has to do with the BB(5) champion having &quot;bouncing&quot; behavior: it moves from the left side of the current pattern to the right side and back again, each time extending it slightly. Since the time it takes to grow the pattern is strictly proportional to its current size, you end up with a bunch of parabolas that appear self-similar.</div><br/></div></div><div id="40859613" class="c"><input type="checkbox" id="c-40859613" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40858148">parent</a><span>|</span><a href="#40858278">prev</a><span>|</span><a href="#40861311">next</a><span>|</span><label class="collapse" for="c-40859613">[-]</label><label class="expand" for="c-40859613">[2 more]</label></div><br/><div class="children"><div class="content">That is because these are small. Small machines can not help but still have those sorts of patterns in them. See all the simple 1-D automata of interest, for instance: <a href="https:&#x2F;&#x2F;atlas.wolfram.com&#x2F;01&#x2F;01&#x2F;" rel="nofollow">https:&#x2F;&#x2F;atlas.wolfram.com&#x2F;01&#x2F;01&#x2F;</a><p>As you step up I am fairly confident you&#x27;ll see the winners get noisier and noisier. They&#x27;ll have some sort of pattern, just ones you won&#x27;t be able to comprehend. For some suitable definition of &quot;noisier&quot; this might even be a provable claim.</div><br/><div id="40860473" class="c"><input type="checkbox" id="c-40860473" checked=""/><div class="controls bullet"><span class="by">Natsu</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40859613">parent</a><span>|</span><a href="#40861311">next</a><span>|</span><label class="collapse" for="c-40860473">[-]</label><label class="expand" for="c-40860473">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t it make more sense for the longest running ones to be fractal in a sense given that the self-similarity is sort of compressible?  I guess we&#x27;ll probably never know, because it&#x27;s not clear that we&#x27;ll ever find another BB winner.</div><br/></div></div></div></div><div id="40861311" class="c"><input type="checkbox" id="c-40861311" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40857473">root</a><span>|</span><a href="#40858148">parent</a><span>|</span><a href="#40859613">prev</a><span>|</span><a href="#40857578">next</a><span>|</span><label class="collapse" for="c-40861311">[-]</label><label class="expand" for="c-40861311">[1 more]</label></div><br/><div class="children"><div class="content">Fractals or fractal-like things seem to be the main way you get &quot;interesting&quot; behaviour out of very simple rules. Procedurally generated art&#x2F;content tends to use them a lot (look at e.g. demoscene programs).</div><br/></div></div></div></div></div></div><div id="40859587" class="c"><input type="checkbox" id="c-40859587" checked=""/><div class="controls bullet"><span class="by">wayeq</span><span>|</span><a href="#40857473">prev</a><span>|</span><a href="#40858006">next</a><span>|</span><label class="collapse" for="c-40859587">[-]</label><label class="expand" for="c-40859587">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;After decades of uncertainty, a motley team of programmers has proved precisely how complicated simple computer programs can get.&quot;<p>my team has also proved this via our production codebase</div><br/><div id="40859606" class="c"><input type="checkbox" id="c-40859606" checked=""/><div class="controls bullet"><span class="by">kaptainscarlet</span><span>|</span><a href="#40859587">parent</a><span>|</span><a href="#40859650">next</a><span>|</span><label class="collapse" for="c-40859606">[-]</label><label class="expand" for="c-40859606">[1 more]</label></div><br/><div class="children"><div class="content">These researchers clearly haven&#x27;t looked at our NodeJS ERP system.</div><br/></div></div></div></div><div id="40858006" class="c"><input type="checkbox" id="c-40858006" checked=""/><div class="controls bullet"><span class="by">bryan0</span><span>|</span><a href="#40859587">prev</a><span>|</span><a href="#40863449">next</a><span>|</span><label class="collapse" for="c-40858006">[-]</label><label class="expand" for="c-40858006">[2 more]</label></div><br/><div class="children"><div class="content">Aaronson’s post on BB(5): <a href="https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=8088" rel="nofollow">https:&#x2F;&#x2F;scottaaronson.blog&#x2F;?p=8088</a></div><br/></div></div><div id="40858629" class="c"><input type="checkbox" id="c-40858629" checked=""/><div class="controls bullet"><span class="by">nayuki</span><span>|</span><a href="#40858049">prev</a><span>|</span><label class="collapse" for="c-40858629">[-]</label><label class="expand" for="c-40858629">[2 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; To distill the essence of the halting problem into a simpler form, Radó imagined sorting Turing machines into groups based on how many rules they had — one group for all one-rule Turing machines, another for all two-rule machines, and so on. Sure, that leaves infinitely many such groups, since a Turing machine can have any number of rules. But the number of distinct machines in every group is finite, since there are only so many possible combinations of rules.<p>&gt; With two rules, there are already over 6,000 distinct Turing machines to consider; that number swells to millions with three rules, and to billions with four.<p>I&#x27;m pretty sure the standard terminology is &quot;states&quot;, not &quot;rules&quot;. This deviation made it harder to understand.<p>Each state produces 2 transition rules, depending on the symbol at the tape head.</div><br/></div></div></div></div></div></div></div></body></html>