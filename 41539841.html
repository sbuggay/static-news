<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726736465026" as="style"/><link rel="stylesheet" href="styles.css?v=1726736465026"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://lists.landley.net/pipermail/toybox-landley.net/2024-January/029957.html">A overview of binaries, ELF, and NoMMU on Linux</a>Â <span class="domain">(<a href="http://lists.landley.net">lists.landley.net</a>)</span></div><div class="subtext"><span>oliverkwebb</span> | <span>4 comments</span></div><br/><div><div id="41588041" class="c"><input type="checkbox" id="c-41588041" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#41588571">next</a><span>|</span><label class="collapse" for="c-41588041">[-]</label><label class="expand" for="c-41588041">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a <i>lot</i> of information in a single email! Really nice, especially the history, virtual memory and nommu stuff. I recently implemented an ELF I&#x2F;O library and was forced to learn a not insignificant fraction of all that from the specification and scattered resources... An email like this would have made things so much easier.</div><br/></div></div><div id="41588571" class="c"><input type="checkbox" id="c-41588571" checked=""/><div class="controls bullet"><span class="by">melchizedek6809</span><span>|</span><a href="#41588041">prev</a><span>|</span><label class="collapse" for="c-41588571">[-]</label><label class="expand" for="c-41588571">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Some old processors had page fault handling in hardware. This sucked rocks, and
Linus yelled at the PowerPC guys somewhat extensively about this 20 years ago.<p>Wait, wasn&#x27;t it the other way around? I might be mistaken but wasn&#x27;t one of the problems with PowerPC that it only really had a TLB and the kernel had to walk the page tables in software?<p>Afaik on x86 the page fault handler is only called when a page isn&#x27;t marked present, so that one can allocate a new page&#x2F;load the page from mass storage, but apart from that walking the page tables is done in hardware.<p>Has been a while since I&#x27;ve only really dabbled in 32-bit protected mode a decade or so ago so I might be misremembering.</div><br/><div id="41588877" class="c"><input type="checkbox" id="c-41588877" checked=""/><div class="controls bullet"><span class="by">kijiki</span><span>|</span><a href="#41588571">parent</a><span>|</span><label class="collapse" for="c-41588877">[-]</label><label class="expand" for="c-41588877">[1 more]</label></div><br/><div class="children"><div class="content">MIPS had a fully classic RISC MMU, TLB only. TLB miss resulted in a fault which the OS handled to walk whatever data structure they chose for memory mapping. They had the KSEG regions which let the (virtual mapped) kernel easily access physical mapped memory for the walk. Not sure if this changed with MIPS64, though KSEGs would have been much less costly in terms of address space there.<p>PPC (at least Book-E variants) had a more complicated setup where TLB misses did a hash table lookup in HW. If that missed as well, it faulted to the kernel to do the full walk. The trick PPC used was that the page fault handler ran with paging disabled entirely, so it could access physical memory directly while handling the miss, no KSEGs necessary.<p>No idea how SPARC handled this, but x86&#x2F;x86-64&#x2F;ARM all do this entirely in hardware, though in practice it is really microcode.</div><br/></div></div></div></div></div></div></div></div></div></body></html>