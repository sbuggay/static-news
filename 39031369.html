<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705654852974" as="style"/><link rel="stylesheet" href="styles.css?v=1705654852974"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blogsystem5.substack.com/p/from-0-to-1-mb-in-dos">How DOS was able to use most of the 1 MB address space of the 8086</a> <span class="domain">(<a href="https://blogsystem5.substack.com">blogsystem5.substack.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>45 comments</span></div><br/><div><div id="39039367" class="c"><input type="checkbox" id="c-39039367" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#39050924">next</a><span>|</span><label class="collapse" for="c-39039367">[-]</label><label class="expand" for="c-39039367">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a miracle emm386 managed to squeeze out more memory as UMBs than it needed to do its job.<p>Consider: It scans for holes in the memory map.  It switches to protected mode, then v86 mode, sets up page tables, and is basically more of an OS than DOS, if you look at the CPU.  It monitors IO ports and rewrites DMA access from random programs to translate the UMBs to their physical addresses.  It implements VCPI to cooperate with e.g. windows and dos4gw.  It switches A20 on and off when translation needs to happen.<p>And all that to gain memory from segments C000,D000,E000, if nothing else sits there. So 192K max.<p>Looking back, it&#x27;s insane what contortions we went to, just to keep dos alive.</div><br/><div id="39050453" class="c"><input type="checkbox" id="c-39050453" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39039367">parent</a><span>|</span><a href="#39050924">next</a><span>|</span><label class="collapse" for="c-39050453">[-]</label><label class="expand" for="c-39050453">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more like a hypervisor than a true OS, and VM86 mode was the first hardware virtualisation feature of the x86 line.<p>Windows&#x2F;386 and the DOS-based Windows up to Me were similarly hypervisors for DOS.</div><br/><div id="39050860" class="c"><input type="checkbox" id="c-39050860" checked=""/><div class="controls bullet"><span class="by">EvanAnderson</span><span>|</span><a href="#39039367">root</a><span>|</span><a href="#39050453">parent</a><span>|</span><a href="#39050924">next</a><span>|</span><label class="collapse" for="c-39050860">[-]</label><label class="expand" for="c-39050860">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a shame that VM86 mode wasn&#x27;t able to be nested. I don&#x27;t remember the specifics, but as I recall there are instructions that don&#x27;t trap and prevent nesting VM86 within itself. I know Intel rectified this in later CPUs-- I believe that&#x27;s the VT extensions.</div><br/><div id="39051640" class="c"><input type="checkbox" id="c-39051640" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39039367">root</a><span>|</span><a href="#39050860">parent</a><span>|</span><a href="#39050924">next</a><span>|</span><label class="collapse" for="c-39051640">[-]</label><label class="expand" for="c-39051640">[1 more]</label></div><br/><div class="children"><div class="content">The VT extensions also unfortunately didn&#x27;t &quot;fit in&quot; with the VM86 model either, needing their own special instructions and data structures (and AMD and Intel also did slightly different things, further complicating the situation.)</div><br/></div></div></div></div></div></div></div></div><div id="39050924" class="c"><input type="checkbox" id="c-39050924" checked=""/><div class="controls bullet"><span class="by">jhallenworld</span><span>|</span><a href="#39039367">prev</a><span>|</span><a href="#39050329">next</a><span>|</span><label class="collapse" for="c-39050924">[-]</label><label class="expand" for="c-39050924">[1 more]</label></div><br/><div class="children"><div class="content">The big achievement of DOS and the 8088 was relocation during loading.  For .COM files, this was easy: the program was segment register relative, you pretty much had virtual memory.  For .EXE files, MS-DOS relinks all of the absolute segment addresses during the load process.<p>So this means you could have multiple programs loaded at once: often done with TSRs (terminate and stay resident programs), but it also allowed things like shell windows in Lugaru Emacs (Epsilon) to exist.  Languages like Turbo-C had system().<p>Also the OS was well decoupled from the application programs (it could be independently updated). This was not true for many of the other home computers of the time, but some pulled it off: all CP&#x2F;M systems and TRS-80. I think the main exception to this was the video system- many programs made assumptions about the address of the screen buffer.</div><br/></div></div><div id="39050329" class="c"><input type="checkbox" id="c-39050329" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#39050924">prev</a><span>|</span><a href="#39050401">next</a><span>|</span><label class="collapse" for="c-39050329">[-]</label><label class="expand" for="c-39050329">[9 more]</label></div><br/><div class="children"><div class="content">To be precise, <i>most</i> computers had only a monochrome or a color card, but nothing prevented you from having (and using) both.<p>I remember a debugger that gave you dual screen on a 8086 by using the monochrome for text&#x2F;debugging whilst the color screen was for the program.</div><br/><div id="39052461" class="c"><input type="checkbox" id="c-39052461" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#39050329">parent</a><span>|</span><a href="#39050390">next</a><span>|</span><label class="collapse" for="c-39052461">[-]</label><label class="expand" for="c-39052461">[1 more]</label></div><br/><div class="children"><div class="content">I did that with Turbo Pascal in the 90s. Having your app on the color monitor, while the debugger was on the Hercules one was amazing.</div><br/></div></div><div id="39050390" class="c"><input type="checkbox" id="c-39050390" checked=""/><div class="controls bullet"><span class="by">stevenwoo</span><span>|</span><a href="#39050329">parent</a><span>|</span><a href="#39052461">prev</a><span>|</span><a href="#39051806">next</a><span>|</span><label class="collapse" for="c-39050390">[-]</label><label class="expand" for="c-39050390">[5 more]</label></div><br/><div class="children"><div class="content">SoftICE was amazing at the time.</div><br/><div id="39052484" class="c"><input type="checkbox" id="c-39052484" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#39050329">root</a><span>|</span><a href="#39050390">parent</a><span>|</span><a href="#39051263">next</a><span>|</span><label class="collapse" for="c-39052484">[-]</label><label class="expand" for="c-39052484">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely. I still remember the disbelief when I realized that you could observe Windows 95 booting. It hooked into system before the OS.</div><br/></div></div><div id="39051263" class="c"><input type="checkbox" id="c-39051263" checked=""/><div class="controls bullet"><span class="by">hnthrowaway0328</span><span>|</span><a href="#39050329">root</a><span>|</span><a href="#39050390">parent</a><span>|</span><a href="#39052484">prev</a><span>|</span><a href="#39051806">next</a><span>|</span><label class="collapse" for="c-39051263">[-]</label><label class="expand" for="c-39051263">[3 more]</label></div><br/><div class="children"><div class="content">I heard modern OS protection mechanisms prevent debuggers do things like SoftICE did. Is it true? Where can I grab more information?</div><br/><div id="39053229" class="c"><input type="checkbox" id="c-39053229" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39050329">root</a><span>|</span><a href="#39051263">parent</a><span>|</span><a href="#39052253">next</a><span>|</span><label class="collapse" for="c-39053229">[-]</label><label class="expand" for="c-39053229">[1 more]</label></div><br/><div class="children"><div class="content">Designing a debugger like SoftICE is unnecessary now: modern processors support virtualization, which means you can run the entire OS inside a VM and debug it from your hypervisor.</div><br/></div></div><div id="39052253" class="c"><input type="checkbox" id="c-39052253" checked=""/><div class="controls bullet"><span class="by">stevenwoo</span><span>|</span><a href="#39050329">root</a><span>|</span><a href="#39051263">parent</a><span>|</span><a href="#39053229">prev</a><span>|</span><a href="#39051806">next</a><span>|</span><label class="collapse" for="c-39052253">[-]</label><label class="expand" for="c-39052253">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know about that sorry. It did let you suspend Windows totally, not sure how different that is than today. I had to take over responsibility for a device driver in windows 95&#x2F;98 era and SoftICE offered a better debugger than microsoft for the task under Windows at that time.</div><br/></div></div></div></div></div></div><div id="39051806" class="c"><input type="checkbox" id="c-39051806" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39050329">parent</a><span>|</span><a href="#39050390">prev</a><span>|</span><a href="#39050540">next</a><span>|</span><label class="collapse" for="c-39051806">[-]</label><label class="expand" for="c-39051806">[1 more]</label></div><br/><div class="children"><div class="content">I have always strongly suspected that this is how print debugging got cemented into the ethos.<p>You had developers using it as a power feature.</div><br/></div></div><div id="39050540" class="c"><input type="checkbox" id="c-39050540" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#39050329">parent</a><span>|</span><a href="#39051806">prev</a><span>|</span><a href="#39050401">next</a><span>|</span><label class="collapse" for="c-39050540">[-]</label><label class="expand" for="c-39050540">[1 more]</label></div><br/><div class="children"><div class="content">the microsoft debugger back then allowed the use of dual screens</div><br/></div></div></div></div><div id="39050401" class="c"><input type="checkbox" id="c-39050401" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39050329">prev</a><span>|</span><a href="#39040260">next</a><span>|</span><label class="collapse" for="c-39050401">[-]</label><label class="expand" for="c-39050401">[1 more]</label></div><br/><div class="children"><div class="content">Zortech C++ had a special &quot;handle&quot; pointer type that enabled access to expanded memory, where the work was done by the compiler:<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;ctg&#x2F;handle-pointers.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;ctg&#x2F;handle-pointers.html</a><p>There was also a VCM system that swapped code to&#x2F;from disk in a manner that was very much like virtual paging.<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;ctg&#x2F;vcm.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;ctg&#x2F;vcm.html</a></div><br/></div></div><div id="39040260" class="c"><input type="checkbox" id="c-39040260" checked=""/><div class="controls bullet"><span class="by">euroderf</span><span>|</span><a href="#39050401">prev</a><span>|</span><a href="#39035386">next</a><span>|</span><label class="collapse" for="c-39040260">[-]</label><label class="expand" for="c-39040260">[4 more]</label></div><br/><div class="children"><div class="content">The whole confused and confusing epoch of &quot;expanded&quot; memory versus &quot;extended&quot; memory proved that Intel processors were designed by the Devil himself.</div><br/><div id="39050760" class="c"><input type="checkbox" id="c-39050760" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#39040260">parent</a><span>|</span><a href="#39035386">next</a><span>|</span><label class="collapse" for="c-39050760">[-]</label><label class="expand" for="c-39050760">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>were designed by the Devil himself</i><p>a.k.a. Intel, who also designed USB &quot;Full Speed&quot; vs &quot;High Speed&quot;<p>(&quot;Full Speed&quot; was the maximum speed of USB 1.0, 12 Mb&#x2F;s, which also had &quot;Low Speed&quot;, 1.5 Mb&#x2F;s which is used by keyboards and mice. &quot;High Speed&quot; was introduced in USB 2.0, and is 480 Mb&#x2F;s)<p>Joke&#x27;s aside, I have empathy for the pain of naming in protocols and systems that get extended and remain backwards compatible. Intel was the king at this.</div><br/><div id="39052519" class="c"><input type="checkbox" id="c-39052519" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#39040260">root</a><span>|</span><a href="#39050760">parent</a><span>|</span><a href="#39035386">next</a><span>|</span><label class="collapse" for="c-39052519">[-]</label><label class="expand" for="c-39052519">[2 more]</label></div><br/><div class="children"><div class="content">They should have called it <i>Ludicrous Speed</i>.</div><br/><div id="39052916" class="c"><input type="checkbox" id="c-39052916" checked=""/><div class="controls bullet"><span class="by">olivermuty</span><span>|</span><a href="#39040260">root</a><span>|</span><a href="#39052519">parent</a><span>|</span><a href="#39035386">next</a><span>|</span><label class="collapse" for="c-39052916">[-]</label><label class="expand" for="c-39052916">[1 more]</label></div><br/><div class="children"><div class="content">Cant wait for plaid speed usb in a couple of years</div><br/></div></div></div></div></div></div></div></div><div id="39035386" class="c"><input type="checkbox" id="c-39035386" checked=""/><div class="controls bullet"><span class="by">mrlonglong</span><span>|</span><a href="#39040260">prev</a><span>|</span><a href="#39050808">next</a><span>|</span><label class="collapse" for="c-39035386">[-]</label><label class="expand" for="c-39035386">[16 more]</label></div><br/><div class="children"><div class="content">I suggest you take a look at DOS extenders at some point. They were brilliant and the best was DOS&#x2F;4GW.</div><br/><div id="39035400" class="c"><input type="checkbox" id="c-39035400" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#39035386">parent</a><span>|</span><a href="#39038774">next</a><span>|</span><label class="collapse" for="c-39035400">[-]</label><label class="expand" for="c-39035400">[6 more]</label></div><br/><div class="children"><div class="content">The article mentions those at the bottom: &quot;And that’s it for today folks. I intentionally did not touch on DPMI—the technology that truly allowed DOS applications to break free from the 1 MB memory limitation—because I’m saving that for the next article. So, make sure to come back for more!&quot;</div><br/><div id="39037445" class="c"><input type="checkbox" id="c-39037445" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#39035386">root</a><span>|</span><a href="#39035400">parent</a><span>|</span><a href="#39038774">next</a><span>|</span><label class="collapse" for="c-39037445">[-]</label><label class="expand" for="c-39037445">[5 more]</label></div><br/><div class="children"><div class="content">[Original author here.] Exactly! That (DPMI) is the thing I originally wanted to talk about but I realized I had to clarify many more thoughts first! And I still have to do the research on DPMI to be able to talk about it :)</div><br/><div id="39050281" class="c"><input type="checkbox" id="c-39050281" checked=""/><div class="controls bullet"><span class="by">jesuslop</span><span>|</span><a href="#39035386">root</a><span>|</span><a href="#39037445">parent</a><span>|</span><a href="#39050342">next</a><span>|</span><label class="collapse" for="c-39050281">[-]</label><label class="expand" for="c-39050281">[2 more]</label></div><br/><div class="children"><div class="content">I was almost amazed when instead of launching windows 3.1 running win.com one could run Borland DPMI host (that they used in their own 32-bit compiler toolchain), that stayed resident offering its API, and then one could run windows&#x27; KRNL386.EXE, that hooked with the DPMI host and booted windows.</div><br/><div id="39052097" class="c"><input type="checkbox" id="c-39052097" checked=""/><div class="controls bullet"><span class="by">TMWNN</span><span>|</span><a href="#39035386">root</a><span>|</span><a href="#39050281">parent</a><span>|</span><a href="#39050342">next</a><span>|</span><label class="collapse" for="c-39052097">[-]</label><label class="expand" for="c-39052097">[1 more]</label></div><br/><div class="children"><div class="content">What benefit comes from this?</div><br/></div></div></div></div><div id="39050342" class="c"><input type="checkbox" id="c-39050342" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#39035386">root</a><span>|</span><a href="#39037445">parent</a><span>|</span><a href="#39050281">prev</a><span>|</span><a href="#39038779">next</a><span>|</span><label class="collapse" for="c-39050342">[-]</label><label class="expand" for="c-39050342">[1 more]</label></div><br/><div class="children"><div class="content">Zortech shipped with a compact and fast 32 bit DOS extender called DOSX. It worked like a champ.<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;ctg&#x2F;dos32.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;ctg&#x2F;dos32.html</a><p>And supported the 286 DOS extender from Rational Systems.</div><br/></div></div><div id="39038779" class="c"><input type="checkbox" id="c-39038779" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39035386">root</a><span>|</span><a href="#39037445">parent</a><span>|</span><a href="#39050342">prev</a><span>|</span><a href="#39038774">next</a><span>|</span><label class="collapse" for="c-39038779">[-]</label><label class="expand" for="c-39038779">[1 more]</label></div><br/><div class="children"><div class="content">It would be interesting to understand the Quarterdeck products and how they fit together: the separation between QEMM and QDPMI, and how DESQview worked to enhance DOS with multitasking.</div><br/></div></div></div></div></div></div><div id="39038774" class="c"><input type="checkbox" id="c-39038774" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39035386">parent</a><span>|</span><a href="#39035400">prev</a><span>|</span><a href="#39044614">next</a><span>|</span><label class="collapse" for="c-39038774">[-]</label><label class="expand" for="c-39038774">[4 more]</label></div><br/><div class="children"><div class="content">There were many of these.<p>An impressive suite was the stuff from QuarterDeck. Their DOS extender was called QDPMI, and used the QEMM memory manager.<p>Quarterdeck DESQview, built on QEMM, truly extended DOS by turning it into a kind of multi-tasking system, allowing users to be more productive.<p>It was known for its high application compatibility.<p>I used DJGPP in the early 1990&#x27;s, and the GO32.EXE extender, which did the job.</div><br/><div id="39050890" class="c"><input type="checkbox" id="c-39050890" checked=""/><div class="controls bullet"><span class="by">aeyes</span><span>|</span><a href="#39035386">root</a><span>|</span><a href="#39038774">parent</a><span>|</span><a href="#39041997">next</a><span>|</span><label class="collapse" for="c-39050890">[-]</label><label class="expand" for="c-39050890">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone know how QEMM worked exactly? I thought all the tricks would be known by now but no other implementation comes close to it.</div><br/></div></div><div id="39041997" class="c"><input type="checkbox" id="c-39041997" checked=""/><div class="controls bullet"><span class="by">mdip</span><span>|</span><a href="#39035386">root</a><span>|</span><a href="#39038774">parent</a><span>|</span><a href="#39050890">prev</a><span>|</span><a href="#39050542">next</a><span>|</span><label class="collapse" for="c-39041997">[-]</label><label class="expand" for="c-39041997">[1 more]</label></div><br/><div class="children"><div class="content">My 1990s multi-node BBS ran via DESQView&#x2F;x<p>That company produced a number of excellent DOS survival tools.  QEMM memory manager was an absolute <i>must</i> to get games working.</div><br/></div></div><div id="39050542" class="c"><input type="checkbox" id="c-39050542" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#39035386">root</a><span>|</span><a href="#39038774">parent</a><span>|</span><a href="#39041997">prev</a><span>|</span><a href="#39044614">next</a><span>|</span><label class="collapse" for="c-39050542">[-]</label><label class="expand" for="c-39050542">[1 more]</label></div><br/><div class="children"><div class="content">DESQView was my daily driver for a number of years. I even ran Windows 3.1 in a DESQView window.</div><br/></div></div></div></div><div id="39044614" class="c"><input type="checkbox" id="c-39044614" checked=""/><div class="controls bullet"><span class="by">ok123456</span><span>|</span><a href="#39035386">parent</a><span>|</span><a href="#39038774">prev</a><span>|</span><a href="#39052223">next</a><span>|</span><label class="collapse" for="c-39044614">[-]</label><label class="expand" for="c-39044614">[2 more]</label></div><br/><div class="children"><div class="content">DOS&#x2F;4GW was memorable because it advertised itself while loading games made with it, usually late 386&#x2F;486 era 32-bit games from before gaming on Windows had its act together.<p>Phar Lap was more ubiquitous throughout the 286 and 386 DOS days. Microsoft distributed a light version of it with their compiler for a while.</div><br/><div id="39048542" class="c"><input type="checkbox" id="c-39048542" checked=""/><div class="controls bullet"><span class="by">scruffyherder</span><span>|</span><a href="#39035386">root</a><span>|</span><a href="#39044614">parent</a><span>|</span><a href="#39052223">next</a><span>|</span><label class="collapse" for="c-39048542">[-]</label><label class="expand" for="c-39048542">[1 more]</label></div><br/><div class="children"><div class="content">Pharlap 386 is mentioned on Links386, although its flies on by, and special-&gt;about</div><br/></div></div></div></div><div id="39052223" class="c"><input type="checkbox" id="c-39052223" checked=""/><div class="controls bullet"><span class="by">nnevatie</span><span>|</span><a href="#39035386">parent</a><span>|</span><a href="#39044614">prev</a><span>|</span><a href="#39051004">next</a><span>|</span><label class="collapse" for="c-39052223">[-]</label><label class="expand" for="c-39052223">[1 more]</label></div><br/><div class="children"><div class="content">DOS extenders and Watcom C&#x2F;C++ were heaven-sent after spending years targeting real-mode with its segments and offsets.</div><br/></div></div><div id="39051004" class="c"><input type="checkbox" id="c-39051004" checked=""/><div class="controls bullet"><span class="by">skipkey</span><span>|</span><a href="#39035386">parent</a><span>|</span><a href="#39052223">prev</a><span>|</span><a href="#39048529">next</a><span>|</span><label class="collapse" for="c-39051004">[-]</label><label class="expand" for="c-39051004">[1 more]</label></div><br/><div class="children"><div class="content">They also had DOS&#x2F;16M which targeted 286 protected mode.  The company I worked for used it when moving the Clipper programming language to protected mode.</div><br/></div></div><div id="39048529" class="c"><input type="checkbox" id="c-39048529" checked=""/><div class="controls bullet"><span class="by">scruffyherder</span><span>|</span><a href="#39035386">parent</a><span>|</span><a href="#39051004">prev</a><span>|</span><a href="#39050808">next</a><span>|</span><label class="collapse" for="c-39048529">[-]</label><label class="expand" for="c-39048529">[1 more]</label></div><br/><div class="children"><div class="content">Pharlap&#x27;s TNT was way more exciting to be honest.<p>I&#x27;m still trying to find the first early extenders though from 1987&#x2F;88 no leads though.</div><br/></div></div></div></div><div id="39050808" class="c"><input type="checkbox" id="c-39050808" checked=""/><div class="controls bullet"><span class="by">yukkuri</span><span>|</span><a href="#39035386">prev</a><span>|</span><a href="#39041974">next</a><span>|</span><label class="collapse" for="c-39050808">[-]</label><label class="expand" for="c-39050808">[2 more]</label></div><br/><div class="children"><div class="content">I feel old because I still remember the memory management game very clearly</div><br/><div id="39051285" class="c"><input type="checkbox" id="c-39051285" checked=""/><div class="controls bullet"><span class="by">hnthrowaway0328</span><span>|</span><a href="#39050808">parent</a><span>|</span><a href="#39041974">next</a><span>|</span><label class="collapse" for="c-39051285">[-]</label><label class="expand" for="c-39051285">[1 more]</label></div><br/><div class="children"><div class="content">Yes. I still remember back in the day we used PC Tools to modify hot game data and bought pirated games from corners of alleys.</div><br/></div></div></div></div><div id="39041974" class="c"><input type="checkbox" id="c-39041974" checked=""/><div class="controls bullet"><span class="by">mdip</span><span>|</span><a href="#39050808">prev</a><span>|</span><a href="#39039555">next</a><span>|</span><label class="collapse" for="c-39041974">[-]</label><label class="expand" for="c-39041974">[6 more]</label></div><br/><div class="children"><div class="content">If memory serves, I had a neighbor who bought that 4MB Emulex card.<p>It was for an 80286 clone that had a 10MB HDD.  His rational for buying this card was &quot;I can make a big RAM drive out of it and run everything from memory&quot;<p>I can&#x27;t recall the price of the thing, but I want to say it ran in the thousands.  Couldn&#x27;t run most games on it because of copy protection so we never got to take advantage of it.  In fact, I don&#x27;t think the extra memory was usable at <i>all</i> in most software -- I recall we couldn&#x27;t run a game on his machine due to having 512MB of onboard memory, but it had no issue in my ancient 8088 with 640K installed (in bizarre CGA colors).</div><br/><div id="39050472" class="c"><input type="checkbox" id="c-39050472" checked=""/><div class="controls bullet"><span class="by">StressedDev</span><span>|</span><a href="#39041974">parent</a><span>|</span><a href="#39039555">next</a><span>|</span><label class="collapse" for="c-39050472">[-]</label><label class="expand" for="c-39050472">[5 more]</label></div><br/><div class="children"><div class="content">CGA was the worst.  EGA and VGA were huge improvements because CGA only had 4 ugly colors, while EGA had 16 (good), and VGA had 256 (much better).  VGA also supported pallets I think (a way of allowing an application to use 256 colors out of 16 million supported colors).</div><br/><div id="39050687" class="c"><input type="checkbox" id="c-39050687" checked=""/><div class="controls bullet"><span class="by">moefh</span><span>|</span><a href="#39041974">root</a><span>|</span><a href="#39050472">parent</a><span>|</span><a href="#39052068">next</a><span>|</span><label class="collapse" for="c-39050687">[-]</label><label class="expand" for="c-39050687">[1 more]</label></div><br/><div class="children"><div class="content">Nitpick: the VGA DAC has 6 bits per RGB component (18 bits total), so each of the 256 colors is chosen out of 2^18 = 262,144 colors, not 16 million.</div><br/></div></div><div id="39052068" class="c"><input type="checkbox" id="c-39052068" checked=""/><div class="controls bullet"><span class="by">glandium</span><span>|</span><a href="#39041974">root</a><span>|</span><a href="#39050472">parent</a><span>|</span><a href="#39050687">prev</a><span>|</span><a href="#39051544">next</a><span>|</span><label class="collapse" for="c-39052068">[-]</label><label class="expand" for="c-39052068">[1 more]</label></div><br/><div class="children"><div class="content">And yet... <a href="https:&#x2F;&#x2F;int10h.org&#x2F;blog&#x2F;2015&#x2F;04&#x2F;cga-in-1024-colors-new-mode-illustrated&#x2F;" rel="nofollow">https:&#x2F;&#x2F;int10h.org&#x2F;blog&#x2F;2015&#x2F;04&#x2F;cga-in-1024-colors-new-mode-...</a> (this was resubmitted here a few days ago)</div><br/></div></div><div id="39051544" class="c"><input type="checkbox" id="c-39051544" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#39041974">root</a><span>|</span><a href="#39050472">parent</a><span>|</span><a href="#39052068">prev</a><span>|</span><a href="#39039555">next</a><span>|</span><label class="collapse" for="c-39051544">[-]</label><label class="expand" for="c-39051544">[2 more]</label></div><br/><div class="children"><div class="content">&gt; CGA only had 4 ugly colors<p>16 colors, technically. But only four at a time, and three of those were selected from two preset palettes, both of which were hideous (one green&#x2F;red&#x2F;brown, one cyan&#x2F;magenta&#x2F;white).</div><br/><div id="39052511" class="c"><input type="checkbox" id="c-39052511" checked=""/><div class="controls bullet"><span class="by">rzzzt</span><span>|</span><a href="#39041974">root</a><span>|</span><a href="#39051544">parent</a><span>|</span><a href="#39039555">next</a><span>|</span><label class="collapse" for="c-39052511">[-]</label><label class="expand" for="c-39052511">[1 more]</label></div><br/><div class="children"><div class="content">And EGA had 64, because while its display output pins where still TTL, there was no longer a single intensity bit (RGBI) like in CGA but individual intensity bits wired for each color component (rRgGbB)</div><br/></div></div></div></div></div></div></div></div><div id="39039555" class="c"><input type="checkbox" id="c-39039555" checked=""/><div class="controls bullet"><span class="by">roytam87</span><span>|</span><a href="#39041974">prev</a><span>|</span><label class="collapse" for="c-39039555">[-]</label><label class="expand" for="c-39039555">[1 more]</label></div><br/><div class="children"><div class="content">Helix Netroom[1] is missed in the article. Hope it will be in next part of series.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Helix_Netroom" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Helix_Netroom</a></div><br/></div></div></div></div></div></div></div></body></html>