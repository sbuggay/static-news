<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702371683181" as="style"/><link rel="stylesheet" href="styles.css?v=1702371683181"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2312.00638">What if an SQL statement returned a database?</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>matt_d</span> | <span>96 comments</span></div><br/><div><div id="38610762" class="c"><input type="checkbox" id="c-38610762" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#38606699">next</a><span>|</span><label class="collapse" for="c-38610762">[-]</label><label class="expand" for="c-38610762">[1 more]</label></div><br/><div class="children"><div class="content">The purpose of this is to support the annoying limitation that results must be a rectangular matrix. I tweeted this Oct 28th so clearly it solves a problem practitioners already agree with <a href="https:&#x2F;&#x2F;x.com&#x2F;tomlarkworthy&#x2F;status&#x2F;1718329733274824783?s=20" rel="nofollow noreferrer">https:&#x2F;&#x2F;x.com&#x2F;tomlarkworthy&#x2F;status&#x2F;1718329733274824783?s=20</a><p>Many useful result sets are not rectangular, trees, graphs etc. There is no way to efficiently transfer these results sets in a single query. You either do multiple round trips or pad the leaves with repeated information which eats network bandwidth.<p>So I am hugely in favour of this work.</div><br/></div></div><div id="38606699" class="c"><input type="checkbox" id="c-38606699" checked=""/><div class="controls bullet"><span class="by">slowmovintarget</span><span>|</span><a href="#38610762">prev</a><span>|</span><a href="#38606480">next</a><span>|</span><label class="collapse" for="c-38606699">[-]</label><label class="expand" for="c-38606699">[6 more]</label></div><br/><div class="children"><div class="content">So... Like Datomic?<p>Sometimes the result of function call in Datomic is a copy of the database with the updates applied. It allows you to preview how your transaction will affect the data, were that choice to be made. Datalog allows for this kind of return.<p>Were Postgres to add something like this (and if I&#x27;m not inferring too much from the title and commentary here) it wouldn&#x27;t the first time that the industry took a lesson from Rich Hickey&#x27;s resurrection of older tech (Datalog).</div><br/><div id="38607272" class="c"><input type="checkbox" id="c-38607272" checked=""/><div class="controls bullet"><span class="by">shrimpx</span><span>|</span><a href="#38606699">parent</a><span>|</span><a href="#38607545">next</a><span>|</span><label class="collapse" for="c-38607272">[-]</label><label class="expand" for="c-38607272">[4 more]</label></div><br/><div class="children"><div class="content">No. This paper is not about returning a copy of the database with the updates applied. It is about a &quot;normalized join&quot; query type.<p>Edit: clarification.</div><br/><div id="38607382" class="c"><input type="checkbox" id="c-38607382" checked=""/><div class="controls bullet"><span class="by">erichocean</span><span>|</span><a href="#38606699">root</a><span>|</span><a href="#38607272">parent</a><span>|</span><a href="#38607372">next</a><span>|</span><label class="collapse" for="c-38607382">[-]</label><label class="expand" for="c-38607382">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>No. It does not return a copy of the database with the updates applied.</i><p>At first I thought you were talking about Datomic (which does, indeed, &quot;return a copy of the database with updates applied&quot;). But you are talking about the paper, which is about something else apparently.<p>Carry on…</div><br/><div id="38607442" class="c"><input type="checkbox" id="c-38607442" checked=""/><div class="controls bullet"><span class="by">shrimpx</span><span>|</span><a href="#38606699">root</a><span>|</span><a href="#38607382">parent</a><span>|</span><a href="#38607372">next</a><span>|</span><label class="collapse" for="c-38607442">[-]</label><label class="expand" for="c-38607442">[1 more]</label></div><br/><div class="children"><div class="content">Thanks I updated to clarify.</div><br/></div></div></div></div></div></div><div id="38607545" class="c"><input type="checkbox" id="c-38607545" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#38606699">parent</a><span>|</span><a href="#38607272">prev</a><span>|</span><a href="#38606480">next</a><span>|</span><label class="collapse" for="c-38607545">[-]</label><label class="expand" for="c-38607545">[1 more]</label></div><br/><div class="children"><div class="content">well Postgres does not need to do anything you can start a transaction and you have exactly that.</div><br/></div></div></div></div><div id="38606480" class="c"><input type="checkbox" id="c-38606480" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#38606699">prev</a><span>|</span><a href="#38606935">next</a><span>|</span><label class="collapse" for="c-38606480">[-]</label><label class="expand" for="c-38606480">[28 more]</label></div><br/><div class="children"><div class="content">I&#x27;m struggling to understand the purpose of this.<p>If I understand it correctly, for a query with joins, then instead of returning a single combined set of results with the information you need, it returns multiple sets of results based on each separate table.<p>But I don&#x27;t understand why that would ever be desirable.<p>I always write my queries to return the information I need, per whatever &quot;key&quot; I need, in each row. Splitting that up in multiple sets of results is not helpful.<p>Or if I really need multiple sets of data, I write multiple queries.<p>So I really don&#x27;t get what this is for. It&#x27;s like it takes one of the biggest features of databases -- joins -- and removes it? Why?</div><br/><div id="38606968" class="c"><input type="checkbox" id="c-38606968" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#38606480">parent</a><span>|</span><a href="#38610654">next</a><span>|</span><label class="collapse" for="c-38606968">[-]</label><label class="expand" for="c-38606968">[10 more]</label></div><br/><div class="children"><div class="content">First the authors show that for certain use cases, a single query is not ideal. Either the result set will be larger than it needs to be, or it will have to use something like ARRAY_AGG which &quot;discard[s] all schema and relational information on the way.&quot; So let&#x27;s assume that we are in a situation where a single query is not desirable.<p>Then the authors show ways to use multiple queries (in section 3, &quot;SQL-BASED REWRITE METHODS&quot;). Each method has its drawbacks. If you&#x27;ve done enough SQL, these patterns will look familiar to you. Compare the syntax needed here vs the proposed &quot;SELECT RESULTDB&quot; syntax in Listing 3 and you should see that their proposal is easier to write. Then in section 4, the authors &quot;present an algorithm that can be integrated into a DBMS to efficiently compute the result set of our SELECT RESULTDB queries.&quot; Presumably this would be more efficient than any of the alternatives from section 3.</div><br/><div id="38607743" class="c"><input type="checkbox" id="c-38607743" checked=""/><div class="controls bullet"><span class="by">crazygringo</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606968">parent</a><span>|</span><a href="#38608298">next</a><span>|</span><label class="collapse" for="c-38607743">[-]</label><label class="expand" for="c-38607743">[7 more]</label></div><br/><div class="children"><div class="content">&gt; <i>First the authors show that for certain use cases, a single query is not ideal.</i><p>Reading it closely, this is what I already disagree with. You do a good job of summarizing their two main arguments, so allow me to rebut:<p>&gt; <i>Either the result set will be larger than it needs to be</i><p>Yes, they&#x27;re using the example of repeating information (denormalization), such as multiple courses taught by the same professor. But it&#x27;s genuinely hard to see this as a drawback -- that&#x27;s a feature. Data should be <i>stored</i> as normalized as possible, but queries are <i>supposed</i> to denormalize to present information in the <i>desired format</i>.<p>(And if you&#x27;re dealing with what would be an overly-large amount of repeated values, you just run multiple queries yourself instead of one. And if round-trip latency is some kind of issue with running queries sequentially, you can always issue queries in parallel instead.)<p>&gt; <i>which &quot;discard[s] all schema and relational information on the way.&quot;</i><p>Again, this is a feature. You&#x27;re not <i>supposed</i> to retrieve all possible relational information in query results. You write your query to retrieve and differentiate precisely what you need and no more. Discarding irrelevant information is a feature, not a bug. More than that -- you <i>want</i> your query to define and adhere to its output format <i>regardless of the underlying database structure</i>, precisely so you can refactor things in the database and rewrite the query but <i>not need to rewrite the code that uses the query results</i>.<p>I guess my overall bafflement is that the things they describe as &quot;not ideal&quot; seem to me like features rather than problems, and these features have been highly <i>beneficial</i> in my practical experience of writing a lot of database-driven apps.</div><br/><div id="38609778" class="c"><input type="checkbox" id="c-38609778" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38607743">parent</a><span>|</span><a href="#38610461">next</a><span>|</span><label class="collapse" for="c-38609778">[-]</label><label class="expand" for="c-38609778">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    but queries are supposed to denormalize
</code></pre>
Well, that&#x27;s how they&#x27;ve always worked, yes.<p>Might there be a better way for some use cases?<p><pre><code>    denormalize to present information in the desired format
</code></pre>
What if my &quot;desired format&quot; <i>is</i> a structure that maintains the relationships specified in the database?<p>This is an incredibly common pattern, particularly with ORMs.<p><pre><code>    # psuedocode
    for each recipe in Recipe.joins(Ingredient).select_all() do 
       for each ingredient in recipe.ingredients do 
          print(f&quot;{recipe.name} requires {ingredient.name}&quot;)
</code></pre>
Depending on the ORM and the query options specified, this results in one of the following:<p>1. Everything getting denormalized into a single, wasteful result table and then teased back out into Recipes and Ingredients by the ORM<p>2. Two SQL queries. One to fetch the recipes, and then one to fetch the ingredients once we know the id&#x27;s of the recipies.<p>3. A big ol&#x27; N+1 situation with 1 query to fetch recipes and then N additional queries to fetch the ingredients.<p>They all have various inefficiencies. What if we just returned the relational structures directly?</div><br/><div id="38610005" class="c"><input type="checkbox" id="c-38610005" checked=""/><div class="controls bullet"><span class="by">lsh123</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38609778">parent</a><span>|</span><a href="#38610461">next</a><span>|</span><label class="collapse" for="c-38610005">[-]</label><label class="expand" for="c-38610005">[1 more]</label></div><br/><div class="children"><div class="content">Don’t use ORM for performance critical DB operations and write SQL by hand might be another answer. Case in point: I recently improved performance of my email app by about 250x by replacing SwiftData with native SQLite database (and manual sql queries). The message data is under 1M rows range plus a lot of blobs&#x2F;attachments (under 10MB each).</div><br/></div></div></div></div><div id="38610461" class="c"><input type="checkbox" id="c-38610461" checked=""/><div class="controls bullet"><span class="by">bradley13</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38607743">parent</a><span>|</span><a href="#38609778">prev</a><span>|</span><a href="#38609016">next</a><span>|</span><label class="collapse" for="c-38610461">[-]</label><label class="expand" for="c-38610461">[1 more]</label></div><br/><div class="children"><div class="content">This. If your query returns a database rather than denormalized information? Guess what, you now get to query that returned database.<p>Honestly, it sounds like they haven&#x27;t really grasped the purpose of relational databases.</div><br/></div></div><div id="38609016" class="c"><input type="checkbox" id="c-38609016" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38607743">parent</a><span>|</span><a href="#38610461">prev</a><span>|</span><a href="#38608634">next</a><span>|</span><label class="collapse" for="c-38609016">[-]</label><label class="expand" for="c-38609016">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Data should be stored as normalized as possible, but queries are supposed to denormalize to present information in the desired format.<p>But the desired format usually isn&#x27;t a square, flat table. Usually the data has structure and you want to preserve that structure when you&#x27;re displaying, not just having it hidden in the database. E.g. you might want to show a heading for each professor and then a list of classes taught by that professor. Getting back a flat table with n duplicate copies of the professor&#x27;s information is a step backwards.</div><br/></div></div><div id="38608634" class="c"><input type="checkbox" id="c-38608634" checked=""/><div class="controls bullet"><span class="by">jrumbut</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38607743">parent</a><span>|</span><a href="#38609016">prev</a><span>|</span><a href="#38608669">next</a><span>|</span><label class="collapse" for="c-38608634">[-]</label><label class="expand" for="c-38608634">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Data should be stored as normalized as possible, but queries are supposed to denormalize to present information in the desired format.<p>The desired format depends on the application.<p>At this point a substantial portion of all SQL queries are generated by (and the results consumed by) ORMs.<p>For that use case having results that include Products and Categories separately (so you can instantiate Product and Category objects) is more useful than a single table.</div><br/></div></div><div id="38608669" class="c"><input type="checkbox" id="c-38608669" checked=""/><div class="controls bullet"><span class="by">hrdwdmrbl</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38607743">parent</a><span>|</span><a href="#38608634">prev</a><span>|</span><a href="#38608298">next</a><span>|</span><label class="collapse" for="c-38608669">[-]</label><label class="expand" for="c-38608669">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And if you&#x27;re dealing with what would be an overly-large amount of repeated values, you just run multiple queries yourself instead of one.<p>It is a bit annoying to do this though. It would be nice if it was done for me automatically be some db driver.<p>&gt; And if round-trip latency is some kind of issue with running queries sequentially, you can always issue queries in parallel instead.<p>Some languages or frameworks don’t provide great parallel ization features though.<p>I guess at the end of the day if it’s an extension to SQL that you can optionally use, then I would have some situations where I would use it.</div><br/></div></div></div></div><div id="38608298" class="c"><input type="checkbox" id="c-38608298" checked=""/><div class="controls bullet"><span class="by">mamcx</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606968">parent</a><span>|</span><a href="#38607743">prev</a><span>|</span><a href="#38610654">next</a><span>|</span><label class="collapse" for="c-38608298">[-]</label><label class="expand" for="c-38608298">[2 more]</label></div><br/><div class="children"><div class="content">This in fact shows one of the artificial limitations of SQL (and not of the relational model):<p>It does not have a `GROUP BY` functionality!<p>What `sql` calls `GROUP BY` is `SUMMARIZE`.</div><br/><div id="38608666" class="c"><input type="checkbox" id="c-38608666" checked=""/><div class="controls bullet"><span class="by">fipar</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38608298">parent</a><span>|</span><a href="#38610654">next</a><span>|</span><label class="collapse" for="c-38608666">[-]</label><label class="expand" for="c-38608666">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is exactly what this shows.<p>I think the authors&#x27; work is interesting but they shouldn&#x27;t have said &#x27;relational database&#x27; in the paper, just &#x27;sql database&#x27; instead (&quot;We keep an SQL database storing information about professors ...&quot; and so on).<p>In &quot;industry&quot;, I don&#x27;t argue with people saying Oracle&#x2F;MySQL&#x2F;PostgreSQL are relational databases because that would make me an insufferable colleague and would hardly add any value to the discussion, but for an academic paper on databases, I would prefer more accurate language.</div><br/></div></div></div></div></div></div><div id="38610654" class="c"><input type="checkbox" id="c-38610654" checked=""/><div class="controls bullet"><span class="by">nhinck2</span><span>|</span><a href="#38606480">parent</a><span>|</span><a href="#38606968">prev</a><span>|</span><a href="#38606612">next</a><span>|</span><label class="collapse" for="c-38610654">[-]</label><label class="expand" for="c-38610654">[1 more]</label></div><br/><div class="children"><div class="content">If I wanted to get some patients who had either condition x y or z and likely they had more one of those conditions, this would be a useful way to return the data.<p>The list of patients remains distinct but which of the conditions they had would still be referencable.<p>It&#x27;s a nice shortcut but not world changing.</div><br/></div></div><div id="38606612" class="c"><input type="checkbox" id="c-38606612" checked=""/><div class="controls bullet"><span class="by">oleg_antonyan</span><span>|</span><a href="#38606480">parent</a><span>|</span><a href="#38610654">prev</a><span>|</span><a href="#38606714">next</a><span>|</span><label class="collapse" for="c-38606612">[-]</label><label class="expand" for="c-38606612">[4 more]</label></div><br/><div class="children"><div class="content">It could be useful with ORM. For example, in Rails ActiveRecord instantiates the class for each row. But when you need to write complex query with many joins and instantiate AR models tree from it becomes either cumbersome or leads to n+1 queries. Still pretty niche usecase, but looks interesting</div><br/><div id="38606774" class="c"><input type="checkbox" id="c-38606774" checked=""/><div class="controls bullet"><span class="by">julian37</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606612">parent</a><span>|</span><a href="#38606714">next</a><span>|</span><label class="collapse" for="c-38606774">[-]</label><label class="expand" for="c-38606774">[3 more]</label></div><br/><div class="children"><div class="content">Right, but fetching rows along with a bunch of related rows from other tables isn&#x27;t niche, it&#x27;s literally the _raison d&#x27;etre_ of GraphQL (simplifying a bit because GraphQL types don&#x27;t necessarily map onto db tables.)<p>It&#x27;s something lots of apps need all the time.</div><br/><div id="38610262" class="c"><input type="checkbox" id="c-38610262" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606774">parent</a><span>|</span><a href="#38609987">next</a><span>|</span><label class="collapse" for="c-38610262">[-]</label><label class="expand" for="c-38610262">[1 more]</label></div><br/><div class="children"><div class="content">You can do that in Postgres, either return nested json structures, or nested arrays.<p>For an example see: <a href="https:&#x2F;&#x2F;shusson.info&#x2F;post&#x2F;building-nested-json-objects-with-postgres" rel="nofollow noreferrer">https:&#x2F;&#x2F;shusson.info&#x2F;post&#x2F;building-nested-json-objects-with-...</a></div><br/></div></div><div id="38609987" class="c"><input type="checkbox" id="c-38609987" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606774">parent</a><span>|</span><a href="#38610262">prev</a><span>|</span><a href="#38606714">next</a><span>|</span><label class="collapse" for="c-38609987">[-]</label><label class="expand" for="c-38609987">[1 more]</label></div><br/><div class="children"><div class="content">Static-language clients need to create a class (or collection of classes) for each GraphQL query, or forgo type safety (typically just null-safety, but I suppose you could treat each result as a dictionary type). Creating just the schema-level types, with relationships modeled separately, does throw out some of the benefits (&quot;just the data you need&quot;) but simplifies the client, moreso if the client may perform multiple complex queries on the same data.</div><br/></div></div></div></div></div></div><div id="38606714" class="c"><input type="checkbox" id="c-38606714" checked=""/><div class="controls bullet"><span class="by">keithnz</span><span>|</span><a href="#38606480">parent</a><span>|</span><a href="#38606612">prev</a><span>|</span><a href="#38607359">next</a><span>|</span><label class="collapse" for="c-38606714">[-]</label><label class="expand" for="c-38606714">[1 more]</label></div><br/><div class="children"><div class="content">so, if you want to join two things, a parent and children, you get duplication  of parent details<p>eg,  select P.name, C.* from Parent P inner join Child C on C.Parent_id = P.Id where P.Id = 1234<p>so from what I can tell is this idea would have a result set of a Parent table and child tables based on the join and projection with no duplication?   At least that&#x27;s what I understand it to be.  That seems useful.</div><br/></div></div><div id="38607359" class="c"><input type="checkbox" id="c-38607359" checked=""/><div class="controls bullet"><span class="by">shrimpx</span><span>|</span><a href="#38606480">parent</a><span>|</span><a href="#38606714">prev</a><span>|</span><a href="#38607211">next</a><span>|</span><label class="collapse" for="c-38607359">[-]</label><label class="expand" for="c-38607359">[1 more]</label></div><br/><div class="children"><div class="content">I guess it&#x27;s kind of like doing all the things a join query would do, like mapping rows together, filtering, sorting, and grouping, but the final output is denormalized into several &quot;tables&quot; without duplication. From what I gather, the main &quot;win&quot; is the size reduction in the result set, which can impact network and memory usage. Yes you can do this yourself by running multiple queries, one on each table. Presumably by paying the latency of multiple round trips.</div><br/></div></div><div id="38607211" class="c"><input type="checkbox" id="c-38607211" checked=""/><div class="controls bullet"><span class="by">jtriangle</span><span>|</span><a href="#38606480">parent</a><span>|</span><a href="#38607359">prev</a><span>|</span><a href="#38606809">next</a><span>|</span><label class="collapse" for="c-38607211">[-]</label><label class="expand" for="c-38607211">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you just want the data to do with as you please and don&#x27;t want to bother dealing with relational database overhead (and instead prefer to deal with that overhead yourself).<p>Not really a new idea, just new to SQL databases. Usually if you find yourself needing to dump a whole ton of data, you don&#x27;t use SQL, you use any number of other database solutions that are better suited to that model. So I suppose this is really meant to give you a little bit of that for when you need it.</div><br/></div></div><div id="38606809" class="c"><input type="checkbox" id="c-38606809" checked=""/><div class="controls bullet"><span class="by">ianburrell</span><span>|</span><a href="#38606480">parent</a><span>|</span><a href="#38607211">prev</a><span>|</span><a href="#38606580">next</a><span>|</span><label class="collapse" for="c-38606809">[-]</label><label class="expand" for="c-38606809">[1 more]</label></div><br/><div class="children"><div class="content">Also, it is possible to manipulate the joined data. What does this do with a SUM or MAX? Or calculation that involves both tables?</div><br/></div></div><div id="38606580" class="c"><input type="checkbox" id="c-38606580" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38606480">parent</a><span>|</span><a href="#38606809">prev</a><span>|</span><a href="#38606520">next</a><span>|</span><label class="collapse" for="c-38606580">[-]</label><label class="expand" for="c-38606580">[5 more]</label></div><br/><div class="children"><div class="content">Reading the abstract... it feels to me like the author doesn&#x27;t know what a relational database <i>is</i>.<p>Chris Date does discuss the concept of nested tuples &#x2F; relation-valued tuples of some kind in his books as an extension to the relational model. But that&#x27;s something else entirely.</div><br/><div id="38606731" class="c"><input type="checkbox" id="c-38606731" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606580">parent</a><span>|</span><a href="#38606693">next</a><span>|</span><label class="collapse" for="c-38606731">[-]</label><label class="expand" for="c-38606731">[3 more]</label></div><br/><div class="children"><div class="content">My interpretation is to enable a query to return many relations in order to overcome the high latency associated with most RDBMBes that often prevent using relational databases in a &quot;theoretically pure&quot; way. It&#x27;s a hack, but possibly a better hack than the hacks we currently resort to.</div><br/><div id="38606789" class="c"><input type="checkbox" id="c-38606789" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606731">parent</a><span>|</span><a href="#38606693">next</a><span>|</span><label class="collapse" for="c-38606789">[-]</label><label class="expand" for="c-38606789">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s already a way to return tuples from multiple relations from a single query.<p>Multiple ways in fact.  Both unions and joins.</div><br/><div id="38607206" class="c"><input type="checkbox" id="c-38607206" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606789">parent</a><span>|</span><a href="#38606693">next</a><span>|</span><label class="collapse" for="c-38607206">[-]</label><label class="expand" for="c-38607206">[1 more]</label></div><br/><div class="children"><div class="content">This is to have multiple relations returned. Traditional unions and joins only see one relation returned.<p>You can pack multiple relations into one relation using unions&#x2F;joins and then unpack it again in the client to ultimately achieve the same effect, which is a workaround that some utilize, but that is <i>really</i> hacky (to be clear, unions and joins are not hacks when used for their intended purpose, but the data packing is).<p>The proposed would be much less hacky - although still far from an ideal database that has no latency constraints that force deviation from what is &quot;pure&quot;. But that’s engineering for you.</div><br/></div></div></div></div></div></div><div id="38606693" class="c"><input type="checkbox" id="c-38606693" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606580">parent</a><span>|</span><a href="#38606731">prev</a><span>|</span><a href="#38606520">next</a><span>|</span><label class="collapse" for="c-38606693">[-]</label><label class="expand" for="c-38606693">[1 more]</label></div><br/><div class="children"><div class="content">Method(s) for turning dbms into a replacement for OS might be applicable here.</div><br/></div></div></div></div><div id="38606520" class="c"><input type="checkbox" id="c-38606520" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38606480">parent</a><span>|</span><a href="#38606580">prev</a><span>|</span><a href="#38606935">next</a><span>|</span><label class="collapse" for="c-38606520">[-]</label><label class="expand" for="c-38606520">[3 more]</label></div><br/><div class="children"><div class="content">(humor) if system not set up appropriately, expanded long form version of shell fork bomb[0] that drains bank account per pay per amount of resources used.<p>[0] <a href="https:&#x2F;&#x2F;www.cyberciti.biz&#x2F;faq&#x2F;understanding-bash-fork-bomb&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cyberciti.biz&#x2F;faq&#x2F;understanding-bash-fork-bomb&#x2F;</a></div><br/><div id="38606583" class="c"><input type="checkbox" id="c-38606583" checked=""/><div class="controls bullet"><span class="by">irrational</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606520">parent</a><span>|</span><a href="#38606935">next</a><span>|</span><label class="collapse" for="c-38606583">[-]</label><label class="expand" for="c-38606583">[2 more]</label></div><br/><div class="children"><div class="content">Jokes on them. My bank account is already empty.</div><br/><div id="38606963" class="c"><input type="checkbox" id="c-38606963" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38606480">root</a><span>|</span><a href="#38606583">parent</a><span>|</span><a href="#38606935">next</a><span>|</span><label class="collapse" for="c-38606963">[-]</label><label class="expand" for="c-38606963">[1 more]</label></div><br/><div class="children"><div class="content">Not if switch to using boolean logic.  It&#x27;s at max capacity then.</div><br/></div></div></div></div></div></div></div></div><div id="38606935" class="c"><input type="checkbox" id="c-38606935" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#38606480">prev</a><span>|</span><a href="#38610337">next</a><span>|</span><label class="collapse" for="c-38606935">[-]</label><label class="expand" for="c-38606935">[5 more]</label></div><br/><div class="children"><div class="content">When I think of SQL, I think of relational databases where they were created and most commonly used. What queries return are not tables, but a relation that can be composed of data from one or more tables.<p>What this paper is then saying is &quot;What if SQL returned something other than a relation?&quot; That question is being answered by all non-relational DBs being made. An example of one might be a graphdb that could return a graph with nodes, edges and properties thereof.<p>If we want to stay within relational dbs, then we&#x27;re saying that we want a single statement to return multiple relations. That sounds something like GraphQL query to me which is stitching of the relational parts.</div><br/><div id="38610322" class="c"><input type="checkbox" id="c-38610322" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#38606935">parent</a><span>|</span><a href="#38608940">next</a><span>|</span><label class="collapse" for="c-38610322">[-]</label><label class="expand" for="c-38610322">[1 more]</label></div><br/><div class="children"><div class="content">You don’t need graphql for that, modern sql databases that support json documents already support something like this.<p>In Postgres, either return nested json structures, or nested arrays. For an example see: <a href="https:&#x2F;&#x2F;shusson.info&#x2F;post&#x2F;building-nested-json-objects-with-postgres" rel="nofollow noreferrer">https:&#x2F;&#x2F;shusson.info&#x2F;post&#x2F;building-nested-json-objects-with-...</a><p>Also supported by some ORMs like JOOQ: <a href="https:&#x2F;&#x2F;blog.jooq.org&#x2F;nesting-collections-with-jooq-3-14s-sql-xml-or-sql-json-support&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.jooq.org&#x2F;nesting-collections-with-jooq-3-14s-sq...</a></div><br/></div></div><div id="38608940" class="c"><input type="checkbox" id="c-38608940" checked=""/><div class="controls bullet"><span class="by">da_chicken</span><span>|</span><a href="#38606935">parent</a><span>|</span><a href="#38610322">prev</a><span>|</span><a href="#38607024">next</a><span>|</span><label class="collapse" for="c-38608940">[-]</label><label class="expand" for="c-38608940">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What this paper is then saying is &quot;What if SQL returned something other than a relation?&quot;<p>No, I think it&#x27;s closer to &quot;hey guys, remember that idea that domains don&#x27;t need to be primitive data types?&quot;</div><br/></div></div><div id="38607024" class="c"><input type="checkbox" id="c-38607024" checked=""/><div class="controls bullet"><span class="by">fyrn_</span><span>|</span><a href="#38606935">parent</a><span>|</span><a href="#38608940">prev</a><span>|</span><a href="#38610337">next</a><span>|</span><label class="collapse" for="c-38607024">[-]</label><label class="expand" for="c-38607024">[2 more]</label></div><br/><div class="children"><div class="content">SQL queries return data from tables.
The abstract does mention that one downside of this is that the result of the query has to be constructed in memory, resulting in a lot of copying.
This is particularly apparent for joins, where some join types can produce much more data than all their input tables combined.<p>I don&#x27;t see how this is &quot;return something other than a relation&quot; they are pretty specific about what they mean and what benefits it can bring</div><br/><div id="38608288" class="c"><input type="checkbox" id="c-38608288" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#38606935">root</a><span>|</span><a href="#38607024">parent</a><span>|</span><a href="#38610337">next</a><span>|</span><label class="collapse" for="c-38608288">[-]</label><label class="expand" for="c-38608288">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Our approach has clear semantics, i.e. our extended SQL returns subsets of all tables with only those tuples that would be part of the traditional (single-table) query result set, however without performing any denormalization through joins.<p>Yes, that sounds just like a GraphQL connection result with associated nested connections. I believe that there&#x27;s link deduplication for GraphQL which can also be enabled to avoid the copies.<p>The main difference is avoiding multiple round-trips--one for each table--which within a datacenter network doesn&#x27;t add a whole lot of latency compared to the time serving those queries and some can also be done in parallel.</div><br/></div></div></div></div></div></div><div id="38610337" class="c"><input type="checkbox" id="c-38610337" checked=""/><div class="controls bullet"><span class="by">gfody</span><span>|</span><a href="#38606935">prev</a><span>|</span><a href="#38606465">next</a><span>|</span><label class="collapse" for="c-38610337">[-]</label><label class="expand" for="c-38610337">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also be aware that if one of the inputs to ARRAY_AGG is NULL, the entire output will be NULL and thus none of the non-NULL attribute values will be shown in the output! So extra logic is re-quired to avoid these cases. Good luck with that one!<p>that&#x27;s how null works in 3VL, use isnull or coalesce accordingly.<p>&gt; We present a backward compatible SQL extension (SELECT RESULTDB) to allow SQL SELECT statements to return a clearly defined subset of a database rather than just a single table.<p>just use sql&#x2F;json it&#x27;s standardized and supported. you guys are way out of touch from modern sql. please go and read modern-sql.com</div><br/></div></div><div id="38606465" class="c"><input type="checkbox" id="c-38606465" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#38610337">prev</a><span>|</span><a href="#38606592">next</a><span>|</span><label class="collapse" for="c-38606465">[-]</label><label class="expand" for="c-38606465">[1 more]</label></div><br/><div class="children"><div class="content">IIRC this (returning a full database with a schema as a result of a query) has been proposed before in categorical databases, see <a href="https:&#x2F;&#x2F;www.categoricaldata.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.categoricaldata.net&#x2F;</a></div><br/></div></div><div id="38606592" class="c"><input type="checkbox" id="c-38606592" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38606465">prev</a><span>|</span><a href="#38610350">next</a><span>|</span><label class="collapse" for="c-38606592">[-]</label><label class="expand" for="c-38606592">[2 more]</label></div><br/><div class="children"><div class="content">I feel like we could build something like this with SQLite, application defined functions and in-memory DB pretty quickly.<p>But then I ask myself... Why would I want to do any of this? If I do Database=&gt;sql command=&gt;Database... Don&#x27;t I have to write yet-more-SQL (or something approximating SQL) to get at my final items? I can&#x27;t write a foreach loop over pile-o-tables. Virtually all programming abstractions expect some serial flow and enumerations of types.<p>At some point, you are going to have to map A to B, and I&#x27;d argue adding another database in the middle probably isn&#x27;t strictly headed in the right direction.<p>If you want to select 2 different result shapes, just write 2 different queries. Use some lateral concepts in your programming environment to make the SQL part not suck. If you stand on some weird &quot;one query only&quot; principle every time you have to populate a practical view, you are going to have a super rough time with life.</div><br/><div id="38607006" class="c"><input type="checkbox" id="c-38607006" checked=""/><div class="controls bullet"><span class="by">freeqaz</span><span>|</span><a href="#38606592">parent</a><span>|</span><a href="#38610350">next</a><span>|</span><label class="collapse" for="c-38607006">[-]</label><label class="expand" for="c-38607006">[1 more]</label></div><br/><div class="children"><div class="content">Maybe if the client did the JOINs and other logic that were in the query, it would shed load from the upstream DB? That would be helpful for RDBMS which tend to be harder to scale when they are CPU bound.<p>I have seen a lot of services move to microservices and do client-side joins to help distribute load. Maybe there is a way for a DB built around this approach to run each table on a dedicated instance and have each stream the data back async? That would reduce cross-talk between the DBs serving the query and effectively create a client-side JOIN again, but be transparent to the client (if it were handled by the DB driver instead).<p>An interesting thought!</div><br/></div></div></div></div><div id="38610350" class="c"><input type="checkbox" id="c-38610350" checked=""/><div class="controls bullet"><span class="by">tiku</span><span>|</span><a href="#38606592">prev</a><span>|</span><a href="#38607184">next</a><span>|</span><label class="collapse" for="c-38610350">[-]</label><label class="expand" for="c-38610350">[1 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t see the need for it. Perhaps export tools could use it. For the rest of you have correct tables and joins you can get all the data you need in one query.<p>You could already use multiple subqueries if you wanted.</div><br/></div></div><div id="38607184" class="c"><input type="checkbox" id="c-38607184" checked=""/><div class="controls bullet"><span class="by">BeefWellington</span><span>|</span><a href="#38610350">prev</a><span>|</span><a href="#38606989">next</a><span>|</span><label class="collapse" for="c-38607184">[-]</label><label class="expand" for="c-38607184">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just going off the abstract in my reply here.<p>I&#x27;d wager that any performance gains achieved by returning a database file instead of a (well-known, long-established, well-understood) resultset is going to be negated by literally the rest of the owl.<p>By that I mean, you then need to instrument loading the database file that is returned, applying specific local security and performance considerations that come with that choice, and then querying the normalized data within that returned file.<p>Could that be fast? Maybe. The best bet would be scenarios where the wire speed &#x2F; bandwidth &#x2F; system memory of the consuming device are very very limited. In those situations there&#x27;s already an established way of handling it though: cursors.<p>A resultset is, for the most part, highly compressible already (barring scenarios where you&#x27;re just returning blobs, which incidentally this is doing as well), so it&#x27;s not clear to me this is even saving you that much in terms of the &quot;data duplication&quot; they&#x27;re discussing.</div><br/><div id="38607252" class="c"><input type="checkbox" id="c-38607252" checked=""/><div class="controls bullet"><span class="by">shrimpx</span><span>|</span><a href="#38607184">parent</a><span>|</span><a href="#38606989">next</a><span>|</span><label class="collapse" for="c-38607252">[-]</label><label class="expand" for="c-38607252">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s talking about returning a database per se. Their contribution seems to be a new type of query that, instead of using joins to join together results from many tables into a single denormalized output &quot;table,&quot; it actually returns multiple output &quot;tables&quot; whose rows you can associate together in your code. It&#x27;s kind of a &quot;normalized join,&quot; if you will.</div><br/><div id="38608011" class="c"><input type="checkbox" id="c-38608011" checked=""/><div class="controls bullet"><span class="by">leblancfg</span><span>|</span><a href="#38607184">root</a><span>|</span><a href="#38607252">parent</a><span>|</span><a href="#38606989">next</a><span>|</span><label class="collapse" for="c-38608011">[-]</label><label class="expand" for="c-38608011">[3 more]</label></div><br/><div class="children"><div class="content">Yeah. I&#x27;m imagining e.g. a full database schema at my disposal in the ORM layer, but with only the handful of rows relevant to the logged-in user.<p>Could be useful in many read-heavy scenarios, and would make a default way that skips DB fetches.</div><br/><div id="38609632" class="c"><input type="checkbox" id="c-38609632" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#38607184">root</a><span>|</span><a href="#38608011">parent</a><span>|</span><a href="#38608440">next</a><span>|</span><label class="collapse" for="c-38609632">[-]</label><label class="expand" for="c-38609632">[1 more]</label></div><br/><div class="children"><div class="content">One thing to note is that with a row-level security implementation like Postgres you can pretty much do this already. For example, if you have a table `users` with appropriate RLS policies, `SELECT * FROM users` will only return the rows that whoever&#x27;s doing the selecting is allowed to see.</div><br/></div></div><div id="38608440" class="c"><input type="checkbox" id="c-38608440" checked=""/><div class="controls bullet"><span class="by">shrimpx</span><span>|</span><a href="#38607184">root</a><span>|</span><a href="#38608011">parent</a><span>|</span><a href="#38609632">prev</a><span>|</span><a href="#38606989">next</a><span>|</span><label class="collapse" for="c-38608440">[-]</label><label class="expand" for="c-38608440">[1 more]</label></div><br/><div class="children"><div class="content">That’s kind of cool. Also related to local-first, maybe.</div><br/></div></div></div></div></div></div></div></div><div id="38606989" class="c"><input type="checkbox" id="c-38606989" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#38607184">prev</a><span>|</span><a href="#38608164">next</a><span>|</span><label class="collapse" for="c-38606989">[-]</label><label class="expand" for="c-38606989">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised they didn&#x27;t mention SQL Server&#x27;s &quot;FOR JSON&quot;, which doesn&#x27;t solve the problem they&#x27;re solving entirely (n:n cannot be deduplicated AFAIK) but it can get you 90% of the way<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;json&#x2F;format-query-results-as-json-with-for-json-sql-server?view=sql-server-ver16&amp;tabs=json-path" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;j...</a><p>(I can&#x27;t help but wonder if this whole thing would be a lot better if SQL had a more first-class concept of sum types...)</div><br/></div></div><div id="38608164" class="c"><input type="checkbox" id="c-38608164" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#38606989">prev</a><span>|</span><a href="#38606512">next</a><span>|</span><label class="collapse" for="c-38608164">[-]</label><label class="expand" for="c-38608164">[1 more]</label></div><br/><div class="children"><div class="content">FWIW Google Cloud Datastore had similar functionality over a decade ago. They are called kindless queries: <a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;datastore&#x2F;docs&#x2F;samples&#x2F;datastore-kindless-query" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;datastore&#x2F;docs&#x2F;samples&#x2F;datastore-ki...</a><p>Essentially it allows for querying over all kinds (aka collection&#x2F;table).<p>One usecase where these can be useful to implement account wipeout. If all entities (aka document&#x2F;row) have a commonly named field like “owner” which is an account ID you can delete all their records in a single query. I mean for deletes you can do a similar use case with cascading deletes and foreign keys, but those don’t always scale well because they have too all happen in one transaction (but then it’s not transparent to the application)</div><br/></div></div><div id="38606512" class="c"><input type="checkbox" id="c-38606512" checked=""/><div class="controls bullet"><span class="by">mjhay</span><span>|</span><a href="#38608164">prev</a><span>|</span><a href="#38607511">next</a><span>|</span><label class="collapse" for="c-38606512">[-]</label><label class="expand" for="c-38606512">[1 more]</label></div><br/><div class="children"><div class="content">This is pretty cool given the potential backward compatibility - which makes widespread adoption much more realistic.<p>There is some prior art of queries as morphisms between DBs (or schemas) in the category theory community.<p>e.g.,<p><a href="https:&#x2F;&#x2F;www.categoricaldata.net&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.categoricaldata.net&#x2F;</a><p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;0904.2012.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;0904.2012.pdf</a></div><br/></div></div><div id="38607511" class="c"><input type="checkbox" id="c-38607511" checked=""/><div class="controls bullet"><span class="by">amichal</span><span>|</span><a href="#38606512">prev</a><span>|</span><a href="#38606413">next</a><span>|</span><label class="collapse" for="c-38607511">[-]</label><label class="expand" for="c-38607511">[1 more]</label></div><br/><div class="children"><div class="content">I suspect the article is about returning the contributing tables in a join as multiple relations... while not possible in SQL proper this is possible with stored procedures (at least in T-SQL)<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40013747&#x2F;return-multiple-datasets-from-sql-server-stored-procedure" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;40013747&#x2F;return-multiple...</a></div><br/></div></div><div id="38606413" class="c"><input type="checkbox" id="c-38606413" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38607511">prev</a><span>|</span><a href="#38607818">next</a><span>|</span><label class="collapse" for="c-38606413">[-]</label><label class="expand" for="c-38606413">[13 more]</label></div><br/><div class="children"><div class="content">Rant: we should avoid the term &quot;database&quot; in contexts like this. The standard terms are &quot;schema&quot; (for the definition of &quot;database&quot; that sqlite and mysql use) and &quot;catalog&quot; (for the definition of &quot;database&quot; that postgresql uses). It&#x27;s further overloaded to sometimes mean DBMS (database management system, i.e. an implementation), and sometimes also &quot;cluster&quot; or &quot;daemon instance&quot; (which sometimes overlap with one of the previous senses, but in different ways per implementation).</div><br/><div id="38606484" class="c"><input type="checkbox" id="c-38606484" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#38606413">parent</a><span>|</span><a href="#38606871">next</a><span>|</span><label class="collapse" for="c-38606484">[-]</label><label class="expand" for="c-38606484">[7 more]</label></div><br/><div class="children"><div class="content">The word schema is the format that the data must adhere to, not the data itself, at least in the rest of computing, and the literal meaning is very close to that. So that is a bad word to use for a bunch of data, whereas database is clearly means a bunch of data.</div><br/><div id="38606521" class="c"><input type="checkbox" id="c-38606521" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38606413">root</a><span>|</span><a href="#38606484">parent</a><span>|</span><a href="#38606640">next</a><span>|</span><label class="collapse" for="c-38606521">[-]</label><label class="expand" for="c-38606521">[2 more]</label></div><br/><div class="children"><div class="content">I think “multiple tables” would be clearest for the submission. Or if it is the case “all tables in the database schema” or “all tables in all schemas of the database the user can access”<p>The overloading horse has bolted so might as well aim for clarity for the intended audience.<p>When I see just the word “Database” my brain treats it as a wildcard could be many things (like State could be a country or a state of a country)</div><br/><div id="38606800" class="c"><input type="checkbox" id="c-38606800" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#38606413">root</a><span>|</span><a href="#38606521">parent</a><span>|</span><a href="#38606640">next</a><span>|</span><label class="collapse" for="c-38606800">[-]</label><label class="expand" for="c-38606800">[1 more]</label></div><br/><div class="children"><div class="content">A schema is not just tables, though - there are also views, types, functions and other stuff that lives in a schema too.</div><br/></div></div></div></div><div id="38606640" class="c"><input type="checkbox" id="c-38606640" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38606413">root</a><span>|</span><a href="#38606484">parent</a><span>|</span><a href="#38606521">prev</a><span>|</span><a href="#38606977">next</a><span>|</span><label class="collapse" for="c-38606640">[-]</label><label class="expand" for="c-38606640">[3 more]</label></div><br/><div class="children"><div class="content">Schema covers the definition of a bunch of related tables.<p>A database can run as many schemas at it wants, for as many applications as it wants. I might not be able to see them all.<p>&quot;My database&quot; doesn&#x27;t mean anything in an enterprise environment. It might not even be &#x27;mine&#x27; for any of several competing definitions.<p>Also there are several ways I could break &quot;my database&quot; which would result in every single employee at the company being pissed off, at the same time.  Even if they&#x27;ve never heard of my project.</div><br/><div id="38606763" class="c"><input type="checkbox" id="c-38606763" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#38606413">root</a><span>|</span><a href="#38606640">parent</a><span>|</span><a href="#38606977">next</a><span>|</span><label class="collapse" for="c-38606763">[-]</label><label class="expand" for="c-38606763">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Schema covers the definition of a bunch of related tables.<p>&gt; A database can run as many schemas at it wants, for as many applications as it wants.<p>Even in the scope of a single application, the word “schema” can be ambiguous. For example, I have a Spring Boot application, which stores its data in Postgres. Inside the JAR there is a collection of SQL files which are executed by Flyway at startup, and we call those files “the schema”. At the same time, we have a configuration option to tell the application which Postgres schema to use within its database, and we actually use that so multiple QA environments can all share the same database. [0] So even in this single app the word “schema” is being used in two different (albeit related) ways. Maybe we just need to accept that language is like that, many words have multiple meanings (sometimes even related meanings) and the context determines which of those meanings applies in any particular case.<p>[0] maybe should have put them in separate catalogs, but ended up going with separate schemas in the same catalog because that was the simplest configuration that met the need</div><br/><div id="38607008" class="c"><input type="checkbox" id="c-38607008" checked=""/><div class="controls bullet"><span class="by">layoric</span><span>|</span><a href="#38606413">root</a><span>|</span><a href="#38606763">parent</a><span>|</span><a href="#38606977">next</a><span>|</span><label class="collapse" for="c-38607008">[-]</label><label class="expand" for="c-38607008">[1 more]</label></div><br/><div class="children"><div class="content">Abstractions are just technical terms for analogies, and they commonly break down as you go deeper down the stack ;).</div><br/></div></div></div></div></div></div><div id="38606977" class="c"><input type="checkbox" id="c-38606977" checked=""/><div class="controls bullet"><span class="by">zer0c00ler</span><span>|</span><a href="#38606413">root</a><span>|</span><a href="#38606484">parent</a><span>|</span><a href="#38606640">prev</a><span>|</span><a href="#38606871">next</a><span>|</span><label class="collapse" for="c-38606977">[-]</label><label class="expand" for="c-38606977">[1 more]</label></div><br/><div class="children"><div class="content">Multiple resultsets is a common term. Where a resultset is a table basically.<p>SQL Server (since 2005) can actually even have multiple active resultsets on a single connection. Assume same is true for most other database servers.</div><br/></div></div></div></div><div id="38606871" class="c"><input type="checkbox" id="c-38606871" checked=""/><div class="controls bullet"><span class="by">F-W-M</span><span>|</span><a href="#38606413">parent</a><span>|</span><a href="#38606484">prev</a><span>|</span><a href="#38606872">next</a><span>|</span><label class="collapse" for="c-38606871">[-]</label><label class="expand" for="c-38606871">[1 more]</label></div><br/><div class="children"><div class="content">Long time ago I learned that a database is any kind of structured, machine readable data. A database management system is the software that manages these databases and databases + database management system = database system. Dunno if recalled correctly.<p>Directly afterwards I got told that no one ever uses these words correctly, but the professor felt obliged to at least tell us the academic definition once.<p>Since this was a German lecture, some time was spent on the correct plural of schema (german: Schema). The options presented were Schema, Schemas, Schemata and everything was allowed as long as it is not Schemen (multiple shadowy figures).<p>Dunno why I remember this. It&#x27;s the only part of the lecture I really remember.</div><br/></div></div><div id="38606872" class="c"><input type="checkbox" id="c-38606872" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#38606413">parent</a><span>|</span><a href="#38606871">prev</a><span>|</span><a href="#38606494">next</a><span>|</span><label class="collapse" for="c-38606872">[-]</label><label class="expand" for="c-38606872">[1 more]</label></div><br/><div class="children"><div class="content">IMO the title is actually pretty great. Yes its not very precise, but on the positive side its catchy and gets the point across quick.</div><br/></div></div><div id="38606494" class="c"><input type="checkbox" id="c-38606494" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38606413">parent</a><span>|</span><a href="#38606872">prev</a><span>|</span><a href="#38606621">next</a><span>|</span><label class="collapse" for="c-38606494">[-]</label><label class="expand" for="c-38606494">[1 more]</label></div><br/><div class="children"><div class="content">so, other than having sql abstraction, 
don&#x27;t see how&#x27;s that&#x27;s any different from dbms system call to create ram disk, copy current database over to virtual disk, delete irrelevant data, and fork process to use the database in ram disk.</div><br/></div></div><div id="38606621" class="c"><input type="checkbox" id="c-38606621" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38606413">parent</a><span>|</span><a href="#38606494">prev</a><span>|</span><a href="#38607818">next</a><span>|</span><label class="collapse" for="c-38606621">[-]</label><label class="expand" for="c-38606621">[2 more]</label></div><br/><div class="children"><div class="content">I think what the author is awkwardly groping at here is a concept of returning multiple relations (&quot;tables&quot;) from a single query.<p>Which, well, this person needs to go back and read Codd&#x27;s original paper. They don&#x27;t understand the domain they&#x27;re attempting to muck around in.</div><br/><div id="38606892" class="c"><input type="checkbox" id="c-38606892" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#38606413">root</a><span>|</span><a href="#38606621">parent</a><span>|</span><a href="#38607818">next</a><span>|</span><label class="collapse" for="c-38606892">[-]</label><label class="expand" for="c-38606892">[1 more]</label></div><br/><div class="children"><div class="content">What are you refering to, more specifically, from Codd&#x27;s original paper?</div><br/></div></div></div></div></div></div><div id="38607818" class="c"><input type="checkbox" id="c-38607818" checked=""/><div class="controls bullet"><span class="by">bunabhucan</span><span>|</span><a href="#38606413">prev</a><span>|</span><a href="#38606673">next</a><span>|</span><label class="collapse" for="c-38607818">[-]</label><label class="expand" for="c-38607818">[1 more]</label></div><br/><div class="children"><div class="content">This is going to age me but a client CEO drank the CORBA kool-aid aid and insisted on a CORBA interface with a vendor famous for lock-in and their underlying database not being open. The implementation essentially returned the entire DB in its byzantine format without a decoder ring.</div><br/></div></div><div id="38606673" class="c"><input type="checkbox" id="c-38606673" checked=""/><div class="controls bullet"><span class="by">ilikehurdles</span><span>|</span><a href="#38607818">prev</a><span>|</span><a href="#38606370">next</a><span>|</span><label class="collapse" for="c-38606673">[-]</label><label class="expand" for="c-38606673">[3 more]</label></div><br/><div class="children"><div class="content">Isn’t this what datomic does?  It’s incredibly useful to be able to reference the full state of the database as of some fixed point in time.</div><br/><div id="38606718" class="c"><input type="checkbox" id="c-38606718" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38606673">parent</a><span>|</span><a href="#38606370">next</a><span>|</span><label class="collapse" for="c-38606718">[-]</label><label class="expand" for="c-38606718">[2 more]</label></div><br/><div class="children"><div class="content">Duplicating complete database not so helpful if need to grant access to specific subset of data in database (note: database incorporates multiple tables).</div><br/><div id="38609539" class="c"><input type="checkbox" id="c-38609539" checked=""/><div class="controls bullet"><span class="by">1659447091</span><span>|</span><a href="#38606673">root</a><span>|</span><a href="#38606718">parent</a><span>|</span><a href="#38606370">next</a><span>|</span><label class="collapse" for="c-38609539">[-]</label><label class="expand" for="c-38609539">[1 more]</label></div><br/><div class="children"><div class="content">If I understand correctly, Datomic has filters[1] for that; to remove some data from the db before returning it for use.<p>[1] <a href="https:&#x2F;&#x2F;docs.datomic.com&#x2F;pro&#x2F;time&#x2F;filters.html#filtering-for-security" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.datomic.com&#x2F;pro&#x2F;time&#x2F;filters.html#filtering-for...</a></div><br/></div></div></div></div></div></div><div id="38606370" class="c"><input type="checkbox" id="c-38606370" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#38606673">prev</a><span>|</span><a href="#38607716">next</a><span>|</span><label class="collapse" for="c-38606370">[-]</label><label class="expand" for="c-38606370">[1 more]</label></div><br/><div class="children"><div class="content">I like this.<p>It is like a CTE but you can take a subset of a database that satisfies the join condition. I could see this being used in a select for update scenario.</div><br/></div></div><div id="38607716" class="c"><input type="checkbox" id="c-38607716" checked=""/><div class="controls bullet"><span class="by">netcraft</span><span>|</span><a href="#38606370">prev</a><span>|</span><a href="#38606914">next</a><span>|</span><label class="collapse" for="c-38607716">[-]</label><label class="expand" for="c-38607716">[1 more]</label></div><br/><div class="children"><div class="content">I want to read the paper further, but I have done similar things in the past using JSONB. Multiple CTEs to pull the individual parts, convert to JSON and then combine into objects keys of arrays.</div><br/></div></div><div id="38606914" class="c"><input type="checkbox" id="c-38606914" checked=""/><div class="controls bullet"><span class="by">moribvndvs</span><span>|</span><a href="#38607716">prev</a><span>|</span><a href="#38606799">next</a><span>|</span><label class="collapse" for="c-38606914">[-]</label><label class="expand" for="c-38606914">[3 more]</label></div><br/><div class="children"><div class="content">A sql statement can return a database… if you serialize your database entities w&#x2F; lazy loaded relationships straight from an ORM to your API response</div><br/><div id="38608010" class="c"><input type="checkbox" id="c-38608010" checked=""/><div class="controls bullet"><span class="by">jerrygenser</span><span>|</span><a href="#38606914">parent</a><span>|</span><a href="#38606799">next</a><span>|</span><label class="collapse" for="c-38608010">[-]</label><label class="expand" for="c-38608010">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t lazy loaded relationships mean that every time you access one of the entities it lazily loads, leading to n+1 fetching behavior?</div><br/><div id="38608264" class="c"><input type="checkbox" id="c-38608264" checked=""/><div class="controls bullet"><span class="by">moribvndvs</span><span>|</span><a href="#38606914">root</a><span>|</span><a href="#38608010">parent</a><span>|</span><a href="#38606799">next</a><span>|</span><label class="collapse" for="c-38608264">[-]</label><label class="expand" for="c-38608264">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Sorry, I was being sarcastic. Was thinking of the time a junior dev json serialized an NHibernate entity and it was essentially serializing the entire database.</div><br/></div></div></div></div></div></div><div id="38609974" class="c"><input type="checkbox" id="c-38609974" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#38606799">prev</a><span>|</span><a href="#38609828">next</a><span>|</span><label class="collapse" for="c-38609974">[-]</label><label class="expand" for="c-38609974">[1 more]</label></div><br/><div class="children"><div class="content">then fonts are programs, like type faces</div><br/></div></div><div id="38609828" class="c"><input type="checkbox" id="c-38609828" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#38609974">prev</a><span>|</span><a href="#38606223">next</a><span>|</span><label class="collapse" for="c-38609828">[-]</label><label class="expand" for="c-38609828">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;d be like returning executable code?</div><br/></div></div><div id="38606223" class="c"><input type="checkbox" id="c-38606223" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38609828">prev</a><span>|</span><a href="#38606538">next</a><span>|</span><label class="collapse" for="c-38606223">[-]</label><label class="expand" for="c-38606223">[1 more]</label></div><br/><div class="children"><div class="content">sql RBAC views?
Needs a corresponding &#x27;lasso&#x27; command to merge old&#x2F;new databases.</div><br/></div></div><div id="38606538" class="c"><input type="checkbox" id="c-38606538" checked=""/><div class="controls bullet"><span class="by">paulsutter</span><span>|</span><a href="#38606223">prev</a><span>|</span><a href="#38606601">next</a><span>|</span><label class="collapse" for="c-38606538">[-]</label><label class="expand" for="c-38606538">[1 more]</label></div><br/><div class="children"><div class="content">This is way better than views</div><br/></div></div><div id="38606601" class="c"><input type="checkbox" id="c-38606601" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38606538">prev</a><span>|</span><a href="#38608676">next</a><span>|</span><label class="collapse" for="c-38606601">[-]</label><label class="expand" for="c-38606601">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get why it is a paper? Just make multiple requests SELECT ... FROM TABLE. You can batch them if you like, or just send out multiple requests in parallel.<p>Infact this is what some shitty ORMs do when you <i>don&#x27;t</i> want them to do this and you actually wanted a join. (Grrrr!). Sometimes you want the opposite. The complaint is more that ORMs do silly things and there is less control.<p>I am guessing the paper is really about some nice sugar for doing this?</div><br/><div id="38609475" class="c"><input type="checkbox" id="c-38609475" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38606601">parent</a><span>|</span><a href="#38608906">next</a><span>|</span><label class="collapse" for="c-38609475">[-]</label><label class="expand" for="c-38609475">[1 more]</label></div><br/><div class="children"><div class="content">The main application for this is where you have detail data for parent records in a snowflake pattern. In that case SQL tends to require a ridiculous number of queries, where common formats like JSON and XML are capable of transferring hierarchical data like that in a single response. That is a major weakness of SQL and the common inability to return a hierarchical set of relations in one response in particular.<p>Also, running a ridiculous number of queries in parallel is not practical on many databases due to per connection overhead, a problem that is so severe that many databases have internal many-to-one connection demultiplexers already, i.e. they have N execution engines for M connections.  That should sound familiar to those who are familiar with threading models.</div><br/></div></div><div id="38608906" class="c"><input type="checkbox" id="c-38608906" checked=""/><div class="controls bullet"><span class="by">da_chicken</span><span>|</span><a href="#38606601">parent</a><span>|</span><a href="#38609475">prev</a><span>|</span><a href="#38606650">next</a><span>|</span><label class="collapse" for="c-38608906">[-]</label><label class="expand" for="c-38608906">[1 more]</label></div><br/><div class="children"><div class="content">Multiple selections have to transfer possibly redundant data. By returning the data once and querying it clientside, you avoid having to do that.</div><br/></div></div><div id="38606650" class="c"><input type="checkbox" id="c-38606650" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38606601">parent</a><span>|</span><a href="#38608906">prev</a><span>|</span><a href="#38608676">next</a><span>|</span><label class="collapse" for="c-38606650">[-]</label><label class="expand" for="c-38606650">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s either &#x27;select groups of tables in database and make a new database&#x27; or api for behind the scenes &#x27;duplicate the database and remove data not interested in&#x27;</div><br/></div></div></div></div><div id="38608676" class="c"><input type="checkbox" id="c-38608676" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#38606601">prev</a><span>|</span><a href="#38606954">next</a><span>|</span><label class="collapse" for="c-38608676">[-]</label><label class="expand" for="c-38608676">[2 more]</label></div><br/><div class="children"><div class="content">How do you query that database?<p>With SQL?</div><br/><div id="38609665" class="c"><input type="checkbox" id="c-38609665" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38608676">parent</a><span>|</span><a href="#38606954">next</a><span>|</span><label class="collapse" for="c-38609665">[-]</label><label class="expand" for="c-38609665">[1 more]</label></div><br/><div class="children"><div class="content">That would be convenient, and some programming environments have support for that kind of thing already. A hierarchical object valued expression would also be convenient in a different way.</div><br/></div></div></div></div><div id="38606954" class="c"><input type="checkbox" id="c-38606954" checked=""/><div class="controls bullet"><span class="by">zzzeek</span><span>|</span><a href="#38608676">prev</a><span>|</span><a href="#38608041">next</a><span>|</span><label class="collapse" for="c-38606954">[-]</label><label class="expand" for="c-38606954">[1 more]</label></div><br/><div class="children"><div class="content">I did some contract work for a company called Akiban, which was bought by FoundationDB, which was bought by Apple that took the whole product off the market at the time.   What Akiban offered was SQL with an extra datatype called a &quot;nested result set&quot;, the idea here seems similar if not more generalized; you didn&#x27;t need a traditional join anymore and your ORM-like library could build up hierarchical models from a single SELECT statement that included nested queries.    there is still logic in SQLAlchemy to accommodate this concept.</div><br/></div></div><div id="38608041" class="c"><input type="checkbox" id="c-38608041" checked=""/><div class="controls bullet"><span class="by">claytongulick</span><span>|</span><a href="#38606954">prev</a><span>|</span><a href="#38606751">next</a><span>|</span><label class="collapse" for="c-38608041">[-]</label><label class="expand" for="c-38608041">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of the old Microsoft DAO dynaset multi-table record set back in the VB days [1].<p>You used to be able to treat that as a mini-database, it was queryable and updateable and you could sync changes back to the db.<p>What&#x27;s old is new again...<p>[1] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;office&#x2F;client-developer&#x2F;access&#x2F;desktop-database-reference&#x2F;recordset-object-dao" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;office&#x2F;client-developer&#x2F;ac...</a></div><br/></div></div><div id="38606751" class="c"><input type="checkbox" id="c-38606751" checked=""/><div class="controls bullet"><span class="by">catchnear4321</span><span>|</span><a href="#38608041">prev</a><span>|</span><a href="#38606351">next</a><span>|</span><label class="collapse" for="c-38606751">[-]</label><label class="expand" for="c-38606751">[4 more]</label></div><br/><div class="children"><div class="content">this was not the anticipated answer to orm hate.<p>let’s just call it drm, have an ai figure out the interface and do the plumbing, and throw some decoupled compute and storage at the problem, behind a serverless veneer.<p>adam sandler sang it best.</div><br/><div id="38606992" class="c"><input type="checkbox" id="c-38606992" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38606751">parent</a><span>|</span><a href="#38606351">next</a><span>|</span><label class="collapse" for="c-38606992">[-]</label><label class="expand" for="c-38606992">[3 more]</label></div><br/><div class="children"><div class="content">what about taylor swift song &#x27;shake it off&#x27;?</div><br/><div id="38607092" class="c"><input type="checkbox" id="c-38607092" checked=""/><div class="controls bullet"><span class="by">catchnear4321</span><span>|</span><a href="#38606751">root</a><span>|</span><a href="#38606992">parent</a><span>|</span><a href="#38606351">next</a><span>|</span><label class="collapse" for="c-38607092">[-]</label><label class="expand" for="c-38607092">[2 more]</label></div><br/><div class="children"><div class="content">my god they’re everywhere…</div><br/><div id="38608183" class="c"><input type="checkbox" id="c-38608183" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38606751">root</a><span>|</span><a href="#38607092">parent</a><span>|</span><a href="#38606351">next</a><span>|</span><label class="collapse" for="c-38608183">[-]</label><label class="expand" for="c-38608183">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, blame it on Jaccard[0] needing a new tailor and auto correct swiftly recommended Taylor because of looming ticket issues.<p>[0] : <a href="https:&#x2F;&#x2F;www.computerhistory.org&#x2F;storageengine&#x2F;punched-cards-control-jacquard-loom&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.computerhistory.org&#x2F;storageengine&#x2F;punched-cards-...</a></div><br/></div></div></div></div></div></div></div></div><div id="38606351" class="c"><input type="checkbox" id="c-38606351" checked=""/><div class="controls bullet"><span class="by">liotier</span><span>|</span><a href="#38606751">prev</a><span>|</span><label class="collapse" for="c-38606351">[-]</label><label class="expand" for="c-38606351">[2 more]</label></div><br/><div class="children"><div class="content">Is this question a JSON joke ?</div><br/><div id="38606377" class="c"><input type="checkbox" id="c-38606377" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38606351">parent</a><span>|</span><label class="collapse" for="c-38606377">[-]</label><label class="expand" for="c-38606377">[1 more]</label></div><br/><div class="children"><div class="content">think it&#x27;s an api wrapper for old school NP complete&#x2F;unbounded delimited query aka (system(&quot;dump all database tables in delimited format, grep for results, create new database with grep&#x27;d results while keeping original datatypes&#x2F;functions&#x2F;etc)).  Hopefully with full 8&#x2F;16&#x2F;32&#x2F;64 utf suport.<p>Perhaps sql take on &#x27;view to a kill&#x27; aka create view &#x2F; kill -9 database view</div><br/></div></div></div></div></div></div></div></div></div></body></html>