<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718960454039" as="style"/><link rel="stylesheet" href="styles.css?v=1718960454039"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/robertdavidgraham/wc2">Wc2: Investigates optimizing &#x27;wc&#x27;, the Unix word count program</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>127 comments</span></div><br/><div><div id="40739475" class="c"><input type="checkbox" id="c-40739475" checked=""/><div class="controls bullet"><span class="by">jmholla</span><span>|</span><a href="#40739280">next</a><span>|</span><label class="collapse" for="c-40739475">[-]</label><label class="expand" for="c-40739475">[26 more]</label></div><br/><div class="children"><div class="content">&gt; No, you aren&#x27;t suppose to be able to see how the word-count works by looking at this code. The complexity happens elsewhere, setting up the state-machine.<p>This is like most of the reason I opened this article. I wish they&#x27;d spend more time talking about this. In fact, most of the README covers details that are important, but, irrelevant to their algorithmic improvements.<p>Maybe they expect you to open up the code, but even there the comments are largely describing what things do and not why, so I feel you need to have some understanding of the algorithm in question. For example, the parts where the state table gets constructed rather unhelpful comments to the uninformed:<p><pre><code>    &#x2F;**
     * Build an ASCII row. This configures low-order 7-bits, which should
     * be roughly the same for all states
     *&#x2F;
    static void
    build_basic(unsigned char *row, unsigned char default_state, unsigned char ubase)
    
    ...
    
    &#x2F;**
     * This function compiles a DFA-style state-machine for parsing UTF-8
     * variable-length byte sequences.
     *&#x2F;
    static void
    compile_utf8_statemachine(int is_multibyte)
</code></pre>
Even `wc2o.c` doesn&#x27;t delve into the magic numbers it has chosen. I was hoping this repo would be more educational and explain how the state table works and why it&#x27;s constructed the way it is.<p>Does anyone have a good resource for learning more about asynchronous state-machine parsers, that also could hopefully help explain why this is better than just iterating over characters? I&#x27;m guessing maybe it&#x27;s the lack of branching?</div><br/><div id="40740212" class="c"><input type="checkbox" id="c-40740212" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#40739475">parent</a><span>|</span><a href="#40746758">next</a><span>|</span><label class="collapse" for="c-40740212">[-]</label><label class="expand" for="c-40740212">[11 more]</label></div><br/><div class="children"><div class="content">You can figure it out by just looking at the table and output. It prints the number of lines, then words, then characters. Since the lines count is counts[1], you can conclude that when a newline is encountered, the machine will transition to state 1, hence why the newline is the only 2 entry in the character table and all 2 entries in the state machine point to state 1. From the character table, we can see that characters are split between classes 0, 1, 2 which are word, space, and newline characters.<p>To get the definitions of all other states, by working back from the fact that state 2 is the word count, it must be entered when a word character (class 0) is hit after some space&#x2F;newline characters. Hence state 0 represents the machine being in the middle of a sequence of whitespace, state 1 is when the machine is in a sequences of newlines, state 2 is the first letter of a word, and state 3 is any subsequent letter of a word. You can then verify that the machine transitions to the correct state from those by checking what it does in case of a word, space, or newline character. But I&#x27;m not sure why the table is 4×4. The fourth transition from every state is unreachable since the symbols are all in [0, 2].<p>As for why the approach is better, I think it&#x27;s because it avoids branching. If you think about the length of a word, it&#x27;s quite short compared to a CPU pipeline, so on a branching version of this you&#x27;re going to be stuck spending most of your execution time on branch miss-prediction.</div><br/><div id="40740967" class="c"><input type="checkbox" id="c-40740967" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740212">parent</a><span>|</span><a href="#40740945">next</a><span>|</span><label class="collapse" for="c-40740967">[-]</label><label class="expand" for="c-40740967">[2 more]</label></div><br/><div class="children"><div class="content">There are fewer branches but there is now a data dependency between loop iterations which makes each iteration slightly slower (maybe 1-2 cycles additional latency per iteration).<p>Because newlines are relatively common and unpredictable a state machine is likely better. But on a long file with no new lines and no spaces the branching one should be slightly faster. (All reasoning from first principles; I have not done any benchmarking!)</div><br/><div id="40742768" class="c"><input type="checkbox" id="c-40742768" checked=""/><div class="controls bullet"><span class="by">anamexis</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740967">parent</a><span>|</span><a href="#40740945">next</a><span>|</span><label class="collapse" for="c-40742768">[-]</label><label class="expand" for="c-40742768">[1 more]</label></div><br/><div class="children"><div class="content">The README covers the exact case you describe - the `word.txt` benchmark is just a file with 93MB of the char `x`. The state machine is still faster in this case.</div><br/></div></div></div></div><div id="40740945" class="c"><input type="checkbox" id="c-40740945" checked=""/><div class="controls bullet"><span class="by">Vvector</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740212">parent</a><span>|</span><a href="#40740967">prev</a><span>|</span><a href="#40741796">next</a><span>|</span><label class="collapse" for="c-40740945">[-]</label><label class="expand" for="c-40740945">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve read recently (here on HN) that branch predictors are right 99% if the time.  Is that inaccurate?</div><br/><div id="40743336" class="c"><input type="checkbox" id="c-40743336" checked=""/><div class="controls bullet"><span class="by">drchickensalad</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740945">parent</a><span>|</span><a href="#40741539">next</a><span>|</span><label class="collapse" for="c-40743336">[-]</label><label class="expand" for="c-40743336">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re like me, you need to stop thinking of it as &quot;99% of call sites&quot; and start thinking of it as &quot;99% of iteration loops&quot;.  I know it&#x27;s super obvious on the face of it, but the implications is that most call sites can repeatedly fail but are totally overshadowed by insanely high frequency hot loops that it almost always predicts right (it&#x27;s skewed, just like avg vs median)</div><br/></div></div><div id="40741539" class="c"><input type="checkbox" id="c-40741539" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740945">parent</a><span>|</span><a href="#40743336">prev</a><span>|</span><a href="#40746652">next</a><span>|</span><label class="collapse" for="c-40741539">[-]</label><label class="expand" for="c-40741539">[1 more]</label></div><br/><div class="children"><div class="content">This is the 1% of cases. As I understand it, most branches take the same path most of the time. Think of a loop for instance. With purely statistical prediction (go whichever direction the branch takes more often), loops will be predicted with extreme accuracy and the result is a huge number of correct branches. Then think about error handling code which isn&#x27;t triggered most of the time due to input being valid. Between these two easy cases, I think you cover the majority of branches is programs which is why so many of them are predictable.</div><br/></div></div><div id="40746652" class="c"><input type="checkbox" id="c-40746652" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740945">parent</a><span>|</span><a href="#40741539">prev</a><span>|</span><a href="#40741324">next</a><span>|</span><label class="collapse" for="c-40746652">[-]</label><label class="expand" for="c-40746652">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an over-generalization.<p>Only branches that capture exceptional events, e.g. error checks, show 99% hit rate.<p>Branches that are part of an algorithm are driven by the data you feed to them. For example in a classical binary search, the prediction is right only 50% of the time.</div><br/></div></div><div id="40741324" class="c"><input type="checkbox" id="c-40741324" checked=""/><div class="controls bullet"><span class="by">kardos</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740945">parent</a><span>|</span><a href="#40746652">prev</a><span>|</span><a href="#40745521">next</a><span>|</span><label class="collapse" for="c-40741324">[-]</label><label class="expand" for="c-40741324">[1 more]</label></div><br/><div class="children"><div class="content">It may be true in some cases, but not in general. I think of it as an observation that for large swathes of code the branch is predictable. Eg, we usually don&#x27;t go down the error checking codepath. Faced with flow control that depends on random data, such as &quot;is this random number even&quot;, the branch predictor will have a hard time doing better than 50%.</div><br/></div></div><div id="40745521" class="c"><input type="checkbox" id="c-40745521" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740945">parent</a><span>|</span><a href="#40741324">prev</a><span>|</span><a href="#40741796">next</a><span>|</span><label class="collapse" for="c-40745521">[-]</label><label class="expand" for="c-40745521">[1 more]</label></div><br/><div class="children"><div class="content">Run a profiler on your code sometime and see how many branches it reports taking. You can easily get <i>millions</i> of branches per second, so 1% events happen hundreds of thousands of times.<p>See for example this quick investigation and look at the number of branches for what&#x27;s not a very big program <a href="https:&#x2F;&#x2F;bnikolic.co.uk&#x2F;blog&#x2F;hpc-perf-branchprediction" rel="nofollow">https:&#x2F;&#x2F;bnikolic.co.uk&#x2F;blog&#x2F;hpc-perf-branchprediction</a></div><br/></div></div></div></div><div id="40741796" class="c"><input type="checkbox" id="c-40741796" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740212">parent</a><span>|</span><a href="#40740945">prev</a><span>|</span><a href="#40746758">next</a><span>|</span><label class="collapse" for="c-40741796">[-]</label><label class="expand" for="c-40741796">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>But I&#x27;m not sure why the table is 4×4. The fourth transition from every state is unreachable since the symbols are all in [0, 2].</i><p>I think the fourth transition represents illegal Unicode.  From there it stays in the illegal state until it hits legal UTF-8, then goes back to counting.</div><br/><div id="40742994" class="c"><input type="checkbox" id="c-40742994" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40741796">parent</a><span>|</span><a href="#40746758">next</a><span>|</span><label class="collapse" for="c-40742994">[-]</label><label class="expand" for="c-40742994">[1 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t relevant in the ASCII example, and the UTF-8 one uses a 256×256 table.</div><br/></div></div></div></div></div></div><div id="40746758" class="c"><input type="checkbox" id="c-40746758" checked=""/><div class="controls bullet"><span class="by">casey2</span><span>|</span><a href="#40739475">parent</a><span>|</span><a href="#40740212">prev</a><span>|</span><a href="#40739687">next</a><span>|</span><label class="collapse" for="c-40746758">[-]</label><label class="expand" for="c-40746758">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s how the table is made<p>For starters you need to know what the states the values represent (you should remember this from k&amp;r)<p>0 we are out of a word, but not via newline (lets call this character type &quot;a one&quot;).<p>1 we are out of a word, via a newline (&quot;a two&quot; or &quot;a newline&quot;).<p>2 we entered a word (&quot;a zero&quot;).<p>3 we are in a word (&quot;a zero&quot;).<p>So we know we need 4 rows in the table<p>{} {} {} {}<p>lets fill the 0th row first, we aren&#x27;t in a word so the only states we can enter are 0,1 and 2. That&#x27;s helpful cause we can fill out the 1st element<p>{,0,} {} {} {} (a one sends us to the first row)<p>{[12],0,[12]} {} {} {}(we know 3 isn&#x27;t a possible destination as we are out of a word)<p>{1,0,2} {} {} {} (actually we have a choice of {1,0,2} or {2,0,1} I&#x27;ll show 1,0,2 but this swaps the first 2 args of print at the end)<p>{1,0,2} {} {1,0,2} {} (since newline is also out of a word we have the same options)<p>{1,0,2} {3,0,2} {1,0,2} {} (now 3 is a possible destination if we get zero. A one will take us to state 0 and a newline to state 2 as before)<p>{1,0,2} {3,0,2} {1,0,2} {3,0,2} (now 0,2, and 3 are our only possible states)<p>As you can see, there is nothing magic about it.</div><br/><div id="40747166" class="c"><input type="checkbox" id="c-40747166" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40746758">parent</a><span>|</span><a href="#40739687">next</a><span>|</span><label class="collapse" for="c-40747166">[-]</label><label class="expand" for="c-40747166">[1 more]</label></div><br/><div class="children"><div class="content">&quot;As you can see, there is nothing magic about it.&quot;<p>The parent seems to be using the term &quot;magic numbers&quot; incorrectly.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Magic_number_(programming)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Magic_number_(programming)</a></div><br/></div></div></div></div><div id="40739687" class="c"><input type="checkbox" id="c-40739687" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#40739475">parent</a><span>|</span><a href="#40746758">prev</a><span>|</span><a href="#40739881">next</a><span>|</span><label class="collapse" for="c-40739687">[-]</label><label class="expand" for="c-40739687">[1 more]</label></div><br/><div class="children"><div class="content">I’m with you. It appears to be a fairly bog-standard DFA, but divining that from 4x4 `int`s and a 256 `char` array feels like I’d just be doing all of the heavy lifting, intellectually. However… it does look like it’s trying to detect spaces (that’s the array of 256 `char`, as `char` is self-indexing). I can’t be bothered to remember how `wc` works, but my guess is that the state-machine has transition states for `sp-&gt;sp`, `sp-&gt;wd`, `wd-&gt;wd`, and `wd-sp`. It’d also need error modes. I suppose it doesn’t contain states for escapes?</div><br/></div></div><div id="40739881" class="c"><input type="checkbox" id="c-40739881" checked=""/><div class="controls bullet"><span class="by">zadokshi</span><span>|</span><a href="#40739475">parent</a><span>|</span><a href="#40739687">prev</a><span>|</span><a href="#40744134">next</a><span>|</span><label class="collapse" for="c-40739881">[-]</label><label class="expand" for="c-40739881">[5 more]</label></div><br/><div class="children"><div class="content">&gt; why this is better than just iterating over characters?<p>The explanation it provides regarding Apache vs Ngnix seemed to me to imply that Apache requires memory allocation to read headers into buffers and Ngnix uses a state machine to avoid memory allocation.  Memory allocation is slower than most people realise.</div><br/><div id="40740230" class="c"><input type="checkbox" id="c-40740230" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40739881">parent</a><span>|</span><a href="#40744134">next</a><span>|</span><label class="collapse" for="c-40740230">[-]</label><label class="expand" for="c-40740230">[4 more]</label></div><br/><div class="children"><div class="content">Why is this better for wc, though?  wc is not doing memory allocation in the hot loop.</div><br/><div id="40741981" class="c"><input type="checkbox" id="c-40741981" checked=""/><div class="controls bullet"><span class="by">detourdog</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740230">parent</a><span>|</span><a href="#40742399">next</a><span>|</span><label class="collapse" for="c-40741981">[-]</label><label class="expand" for="c-40741981">[1 more]</label></div><br/><div class="children"><div class="content">I think it keeps wc simple if an algorithm is introduced not directly related to count words it becomes more complicated to debug. I see this a an example of the Unix philosophy of do one thing well.</div><br/></div></div><div id="40742399" class="c"><input type="checkbox" id="c-40742399" checked=""/><div class="controls bullet"><span class="by">jxndnxu</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40740230">parent</a><span>|</span><a href="#40741981">prev</a><span>|</span><a href="#40744134">next</a><span>|</span><label class="collapse" for="c-40742399">[-]</label><label class="expand" for="c-40742399">[2 more]</label></div><br/><div class="children"><div class="content">Because classic wc is not iterating over every byte once, but multiple times.<p>It&#x27;s especially obvious in the Unicode case where it first takes 1-4 bytes to get a Unicode character and then checks this character with another function to see if it&#x27;s whitespace<p>But even with with naive ASCII approach, if you don&#x27;t hand roll a state machine you are checking multiple conditions on each byte (is it a space and am I leaving a word etc)<p>Using a dfa has fixed compute per byte</div><br/><div id="40743868" class="c"><input type="checkbox" id="c-40743868" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40742399">parent</a><span>|</span><a href="#40744134">next</a><span>|</span><label class="collapse" for="c-40743868">[-]</label><label class="expand" for="c-40743868">[1 more]</label></div><br/><div class="children"><div class="content">Those 1-4 bytes are sitting in a register the entire time and thus basically free to read as often as you want, though.<p>An actual sampled profile showing the two approaches would be interesting. Naively it seems like it&#x27;s just because it has faster UTF8 handling and nothing to do with being a state machine exactly</div><br/></div></div></div></div></div></div></div></div><div id="40744134" class="c"><input type="checkbox" id="c-40744134" checked=""/><div class="controls bullet"><span class="by">joe_the_user</span><span>|</span><a href="#40739475">parent</a><span>|</span><a href="#40739881">prev</a><span>|</span><a href="#40745369">next</a><span>|</span><label class="collapse" for="c-40744134">[-]</label><label class="expand" for="c-40744134">[2 more]</label></div><br/><div class="children"><div class="content">Hmm,<p>A project with all code working with special magic reminds me of another project that some attention a while back (XZ lib - supposed improvements with packages containing clever system back doors).<p>Edit: The code is likely harmless but the more opaqueness is in a system, the easier it is for malevolent opaqueness to hide.</div><br/><div id="40746286" class="c"><input type="checkbox" id="c-40746286" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#40739475">root</a><span>|</span><a href="#40744134">parent</a><span>|</span><a href="#40745369">next</a><span>|</span><label class="collapse" for="c-40746286">[-]</label><label class="expand" for="c-40746286">[1 more]</label></div><br/><div class="children"><div class="content">That is not what they mean by “magic”. The “magic” in xz is the complexity in the build system. Here, the “magic” are seemingly arbitrary numbers that improve performance. The reason they’re magic is because we don’t know why they were chosen. The code itself is obvious and not magic.</div><br/></div></div></div></div><div id="40745369" class="c"><input type="checkbox" id="c-40745369" checked=""/><div class="controls bullet"><span class="by">tkhattra</span><span>|</span><a href="#40739475">parent</a><span>|</span><a href="#40744134">prev</a><span>|</span><a href="#40739573">next</a><span>|</span><label class="collapse" for="c-40745369">[-]</label><label class="expand" for="c-40745369">[1 more]</label></div><br/><div class="children"><div class="content">rob graham wrote an article on this wc program in the humorously titled PoC||GTFO journal - see [1]. he also tweeted about it a few years ago [2].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;angea&#x2F;pocorgtfo&#x2F;blob&#x2F;master&#x2F;contents&#x2F;articles&#x2F;21-14.pdf">https:&#x2F;&#x2F;github.com&#x2F;angea&#x2F;pocorgtfo&#x2F;blob&#x2F;master&#x2F;contents&#x2F;arti...</a>
[2] <a href="https:&#x2F;&#x2F;twitter.com&#x2F;ErrataRob&#x2F;status&#x2F;1494009849427992576" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;ErrataRob&#x2F;status&#x2F;1494009849427992576</a></div><br/></div></div><div id="40739573" class="c"><input type="checkbox" id="c-40739573" checked=""/><div class="controls bullet"><span class="by">VMG</span><span>|</span><a href="#40739475">parent</a><span>|</span><a href="#40745369">prev</a><span>|</span><a href="#40740491">next</a><span>|</span><label class="collapse" for="c-40739573">[-]</label><label class="expand" for="c-40739573">[1 more]</label></div><br/><div class="children"><div class="content">I think the documentation might be stale, `build_basic` clearly has code for non-ASCII characters</div><br/></div></div><div id="40740491" class="c"><input type="checkbox" id="c-40740491" checked=""/><div class="controls bullet"><span class="by">sebastianmestre</span><span>|</span><a href="#40739475">parent</a><span>|</span><a href="#40739573">prev</a><span>|</span><a href="#40740122">next</a><span>|</span><label class="collapse" for="c-40740491">[-]</label><label class="expand" for="c-40740491">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Sean Barrett has a good writeup about them and optimizing them for branch-prediction, etc<p>It&#x27;s framed in the context of programming-language tokenization, but the principles are the same.<p><a href="https:&#x2F;&#x2F;nothings.org&#x2F;computer&#x2F;lexing.html" rel="nofollow">https:&#x2F;&#x2F;nothings.org&#x2F;computer&#x2F;lexing.html</a></div><br/></div></div><div id="40740122" class="c"><input type="checkbox" id="c-40740122" checked=""/><div class="controls bullet"><span class="by">worewood</span><span>|</span><a href="#40739475">parent</a><span>|</span><a href="#40740491">prev</a><span>|</span><a href="#40739280">next</a><span>|</span><label class="collapse" for="c-40740122">[-]</label><label class="expand" for="c-40740122">[1 more]</label></div><br/><div class="children"><div class="content">Writing text and writing code are two distinct abilities. It is very rare the professional that possesses both.</div><br/></div></div></div></div><div id="40739280" class="c"><input type="checkbox" id="c-40739280" checked=""/><div class="controls bullet"><span class="by">lesuorac</span><span>|</span><a href="#40739475">prev</a><span>|</span><a href="#40741381">next</a><span>|</span><label class="collapse" for="c-40739280">[-]</label><label class="expand" for="c-40739280">[8 more]</label></div><br/><div class="children"><div class="content">State machines are an underrated approached.<p>Just remember, if you&#x27;re ever debugging something and some values in a Class&#x2F;Object&#x2F;Group of them are set and others are unset the state machine avoids that issue. When you go to transition between states check that the future state will be valid and if-not go to an error state with that information. The amount of time I&#x27;ve seen spent debugging where spurious `null`s came from completely dwarfs the time it would&#x27;ve taken just to write that class&#x2F;algorithm as a state machine.<p>Kinda surprised WC wasn&#x27;t a state machine to beginning with. Isn&#x27;t it effectively a special characters counter where if you see a charactered followed by a space bump up the word count? I&#x27;m judging by the repos comment of &quot;The real programs spend most of their time in functions like mbrtowc() to parse multi-byte characters and iswspace() to test if they are spaces -- which re-implementations of wc skip.&quot; that the big improvement is removing unnecessary work of those methods. mbrtowc [1] appears to re-create the provided substring which isn&#x27;t necessary to count.<p>[1]: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;string&#x2F;multibyte&#x2F;mbrtowc" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;string&#x2F;multibyte&#x2F;mbrtowc</a></div><br/><div id="40740221" class="c"><input type="checkbox" id="c-40740221" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#40739280">parent</a><span>|</span><a href="#40745246">next</a><span>|</span><label class="collapse" for="c-40740221">[-]</label><label class="expand" for="c-40740221">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Just remember, if you&#x27;re ever debugging something and some values in a Class&#x2F;Object&#x2F;Group of them are set and others are unset the state machine avoids that issue.<p>Better yet, switch to a language that supports discriminated unions to avoid invalid state without having to write a low-level state machine. Each case in the union represents one of the valid states of the type. This is one of the many benefits of functional programming.</div><br/><div id="40740492" class="c"><input type="checkbox" id="c-40740492" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40739280">root</a><span>|</span><a href="#40740221">parent</a><span>|</span><a href="#40745246">next</a><span>|</span><label class="collapse" for="c-40740492">[-]</label><label class="expand" for="c-40740492">[5 more]</label></div><br/><div class="children"><div class="content">This comes down to &quot;Make Invalid States Unrepresentable&quot;<p>Notably Go&#x27;s choice here is instead &quot;Make Representable States Valid&quot;. So for example in Go it&#x27;s not possible for a type not to have a default value - every type must have a value you get by default, you could name this unwanted default value FUCK_OFF or DO_NOT_USE if you like, but in a larger system (where Go is supposed to thrive) you can be certain you&#x27;ll find FUCK_OFF and DO_NOT_USE values in the wild.<p>This is one of the few things the C++ type system almost gets right. You really can say for your C++ type no, it doesn&#x27;t have a default. Unfortunately exception safety means we can easily end up in a place where too bad it&#x27;s in <i>some</i> state anyway, but if we turn off exceptions or discount them we can live without nonsensical defaults.</div><br/><div id="40742242" class="c"><input type="checkbox" id="c-40742242" checked=""/><div class="controls bullet"><span class="by">ekidd</span><span>|</span><a href="#40739280">root</a><span>|</span><a href="#40740492">parent</a><span>|</span><a href="#40745805">next</a><span>|</span><label class="collapse" for="c-40742242">[-]</label><label class="expand" for="c-40742242">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>This is one of the few things the C++ type system almost gets right. You really can say for your C++ type no, it doesn&#x27;t have a default.</i><p>Rust does even better here, I think, for fairly subtle reasons:<p>- Exceptions are replaced by Result, with explicitly-marked return points. They&#x27;re far less magic. (&quot;panic!&quot; is still magic, but it&#x27;s allowed to be a call to &quot;abort&quot;, so you only use it when the world is burning.)<p>- &quot;Move semantics&quot; by default makes a lot of edge cases cleaner. If you move out of an object by default, it gets consumed, not set to a default value. Similarly, moving values into a newly-constructed object can&#x27;t fail, because it&#x27;s just memmove.<p>- Object construction is atomic from the programmer&#x27;s perspective.<p>- Default initialization only works if you implement &quot;Default&quot;. Which is actually just a normal trait with no magic.<p>- If you discover that you have a state machine, you can switch to discriminated unions (&quot;enum&quot;) to make your states mutually exclusive and clearly represented.<p>This whole area is one of the better parts of Rust&#x27;s design.</div><br/><div id="40745819" class="c"><input type="checkbox" id="c-40745819" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40739280">root</a><span>|</span><a href="#40742242">parent</a><span>|</span><a href="#40745805">next</a><span>|</span><label class="collapse" for="c-40745819">[-]</label><label class="expand" for="c-40745819">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Default initialization only works if you implement &quot;Default&quot;.</i><p>And -- and I think this is important -- even then, you have to explicitly assign the default value[0].  You won&#x27;t just somehow magically get a default value.<p>[0] E.g.:<p><pre><code>    let foo: SomeType = Default::default();</code></pre></div><br/></div></div></div></div><div id="40740850" class="c"><input type="checkbox" id="c-40740850" checked=""/><div class="controls bullet"><span class="by">typon</span><span>|</span><a href="#40739280">root</a><span>|</span><a href="#40740492">parent</a><span>|</span><a href="#40745805">prev</a><span>|</span><a href="#40745246">next</a><span>|</span><label class="collapse" for="c-40740850">[-]</label><label class="expand" for="c-40740850">[1 more]</label></div><br/><div class="children"><div class="content">Maybe something like CppFront can allow metaprogramming such that the default constructor is deleted by default on all types and becomes opt-in.</div><br/></div></div></div></div></div></div><div id="40745246" class="c"><input type="checkbox" id="c-40745246" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40739280">parent</a><span>|</span><a href="#40740221">prev</a><span>|</span><a href="#40741381">next</a><span>|</span><label class="collapse" for="c-40745246">[-]</label><label class="expand" for="c-40745246">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just remember, if you&#x27;re ever debugging something and some values in a Class&#x2F;Object&#x2F;Group of them are set and others are unset the state machine avoids that issue.<p>You don&#x27;t want a state machine for that, you want sum types. Using state machines give you the worse problem of not being able to tell how you got into to a given state, not being able to take meaningful stack traces, which is generally an even worse problem.</div><br/></div></div></div></div><div id="40741381" class="c"><input type="checkbox" id="c-40741381" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#40739280">prev</a><span>|</span><a href="#40741869">next</a><span>|</span><label class="collapse" for="c-40741381">[-]</label><label class="expand" for="c-40741381">[3 more]</label></div><br/><div class="children"><div class="content">State machines are great for complex situations, but when it comes to performance, it&#x27;s not at all clear to me that they&#x27;re the most scalable approach with modern systems.<p>The data dependency between a loop iteration for each character <i>might</i> be pipelined really well when executed, and we can assume large enough L1&#x2F;L2 cache for our lookup tables. But we&#x27;re still using at least one lookup per character.<p>Projects like <a href="https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson?tab=readme-ov-file#about-simdjson">https:&#x2F;&#x2F;github.com&#x2F;simdjson&#x2F;simdjson?tab=readme-ov-file#abou...</a> are truly fascinating, because they&#x27;re based on SIMD instructions that can process 64 or more bytes with a single instruction. Very much worth checking out the papers at that link.</div><br/><div id="40746002" class="c"><input type="checkbox" id="c-40746002" checked=""/><div class="controls bullet"><span class="by">ashvardanian</span><span>|</span><a href="#40741381">parent</a><span>|</span><a href="#40742436">next</a><span>|</span><label class="collapse" for="c-40746002">[-]</label><label class="expand" for="c-40746002">[1 more]</label></div><br/><div class="children"><div class="content">In the context of State Machines and Automatas - Intel HyperScan might be a better reference point. But the idea is the same. With a trivial PoC using Python wrappers over SIMD libraries one can get a 3x boost over the native `wc` CLI on a modern CPU, memory-mapping a very average SSD: <a href="https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;StringZilla&#x2F;tree&#x2F;main&#x2F;cli">https:&#x2F;&#x2F;github.com&#x2F;ashvardanian&#x2F;StringZilla&#x2F;tree&#x2F;main&#x2F;cli</a></div><br/></div></div><div id="40742436" class="c"><input type="checkbox" id="c-40742436" checked=""/><div class="controls bullet"><span class="by">jxndnxu</span><span>|</span><a href="#40741381">parent</a><span>|</span><a href="#40746002">prev</a><span>|</span><a href="#40741869">next</a><span>|</span><label class="collapse" for="c-40742436">[-]</label><label class="expand" for="c-40742436">[1 more]</label></div><br/><div class="children"><div class="content">My understanding of the article&#x27;s use of scalable was &quot;fixed overhead more or less regardless of the complexity of the state machine and input&quot; not &quot;fastest implementation available&quot;</div><br/></div></div></div></div><div id="40741869" class="c"><input type="checkbox" id="c-40741869" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#40741381">prev</a><span>|</span><a href="#40740290">next</a><span>|</span><label class="collapse" for="c-40741869">[-]</label><label class="expand" for="c-40741869">[5 more]</label></div><br/><div class="children"><div class="content">The primary reason their code is faster as they&#x27;ve made incorrect code that assumes you always have a UTF-8 locale. The normal isspace does not assume this:<p>&gt; The real programs spend most of their time in functions like mbrtowc() to parse multi-byte characters and iswspace() to test if they are spaces<p>This will produce bad results in the real world. People have previously posted about bugs related to this on Hacker News: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36216389">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36216389</a></div><br/><div id="40742837" class="c"><input type="checkbox" id="c-40742837" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#40741869">parent</a><span>|</span><a href="#40743140">next</a><span>|</span><label class="collapse" for="c-40742837">[-]</label><label class="expand" for="c-40742837">[2 more]</label></div><br/><div class="children"><div class="content">Are we looking at the same thread? Folks there seem to be complaining the old interfaces are anything from outdated to confusing to simply wrong, and I agree.<p>I think it&#x27;s totally reasonable for a program designed in 2024 to say it only supports ASCII and UTF-8 encodings. Whether&#x2F;how it should support the full spectrum of Unicode definitions of characters&#x2F;graphemes&#x2F;... is more interesting. For a lot of backend code (processing text-based network protocols, for example), focusing on ASCII is arguably best (e.g. functions like isspace and isdigit only returning true for ASCII characters). For more user-focused stuff, most of the world would say they&#x27;d like their native language supported well. Programs written with both use cases in mind should probably have a switch. (Or parallel APIs: e.g. Rust has {u8,char}::is_ascii_digit vs. char::is_numeric, which makes much more sense there than having one that switches behaviors based on an environment variable, as the correct behavior really depends on the call site.)<p>Of course &quot;say it only supports ASCII and UTF-8 encodings&quot; is mutually exclusive with claiming to be a drop-in replacement for a utility that is specified as having POSIX locale support. This project does not make that claim, or even that it&#x27;s intended to be actually used rather than illustrative of a performance technique.</div><br/><div id="40746065" class="c"><input type="checkbox" id="c-40746065" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#40741869">root</a><span>|</span><a href="#40742837">parent</a><span>|</span><a href="#40743140">next</a><span>|</span><label class="collapse" for="c-40746065">[-]</label><label class="expand" for="c-40746065">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think it&#x27;s totally reasonable for a program designed in 2024 to say it only supports ASCII and UTF-8 encodings.<p>I think that it should depends on the program; that might be reasonable for some programs but in a lot of cases I think that it won&#x27;t be reasonable. (Your explanation includes some of the examples, although not all of them.)<p>Sometimes, it is most helpful to support only ASCII (although non-ASCII bytes might still be supported, even without needing special processing to handle them; in some cases this may effectively allow other ASCII-compatible encodings as well such as EUC-JP).<p>Sometimes, a program should not need to deal with character encoding at all.<p>Sometimes, it makes sense to deal with whatever character encodings are used in the file formats the program is designed to handle.<p>Sometimes, it makes sense to support multiple character encodings, with or without conversion (depending on what is being done with them).<p>Even if a program does only support ASCII and UTF-8 encodings, then depending on what it does with them, mentioning ASCII might be unnecessary since UTF-8 is a superset of ASCII anyways.<p>But unfortunately many programs use UTF-8 (or other encodings, but mostly UTF-8) where it is inappropriate to do so, which can result in many problems including inefficiency.</div><br/></div></div></div></div><div id="40743140" class="c"><input type="checkbox" id="c-40743140" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#40741869">parent</a><span>|</span><a href="#40742837">prev</a><span>|</span><a href="#40740290">next</a><span>|</span><label class="collapse" for="c-40743140">[-]</label><label class="expand" for="c-40743140">[2 more]</label></div><br/><div class="children"><div class="content">It would be just as fast if it detected the locale correctly, and used the UTF8 state machine for the UTF8 locale only. Other locales could have their own state machines or just fall back to a generic implementation.</div><br/><div id="40745915" class="c"><input type="checkbox" id="c-40745915" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#40741869">root</a><span>|</span><a href="#40743140">parent</a><span>|</span><a href="#40740290">next</a><span>|</span><label class="collapse" for="c-40745915">[-]</label><label class="expand" for="c-40745915">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m wondering if you could easily build the state machine quickly at startup time. Unless it is a multi byte encoding it should be trivial.</div><br/></div></div></div></div></div></div><div id="40740290" class="c"><input type="checkbox" id="c-40740290" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40741869">prev</a><span>|</span><a href="#40739723">next</a><span>|</span><label class="collapse" for="c-40740290">[-]</label><label class="expand" for="c-40740290">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The algorithm is known as an &quot;asynchronous state-machine parser&quot;. It&#x27;s a technique for parsing that you don&#x27;t learn in college.<p>The mapping from regular and context free languages to state machines and their table-based implementations was covered in depth in the Compilers course I took. A table based state machine is literally the textbook algorithm for parsing these classes of languages, and implementing them has been almost entirely automated by tools like Flex and Bison since the 80s.</div><br/><div id="40743428" class="c"><input type="checkbox" id="c-40743428" checked=""/><div class="controls bullet"><span class="by">mywittyname</span><span>|</span><a href="#40740290">parent</a><span>|</span><a href="#40742058">next</a><span>|</span><label class="collapse" for="c-40743428">[-]</label><label class="expand" for="c-40743428">[1 more]</label></div><br/><div class="children"><div class="content">Compilers was a graduate course at my school.<p>CS as a field has grown quite a lot over the years, and it seems that colleges are responding by pushing the more theoretical classes into grad school to make room for the more applied classes.</div><br/></div></div><div id="40742058" class="c"><input type="checkbox" id="c-40742058" checked=""/><div class="controls bullet"><span class="by">mcguire</span><span>|</span><a href="#40740290">parent</a><span>|</span><a href="#40743428">prev</a><span>|</span><a href="#40739723">next</a><span>|</span><label class="collapse" for="c-40742058">[-]</label><label class="expand" for="c-40742058">[1 more]</label></div><br/><div class="children"><div class="content">For example, see Chapter 3 of the Dragon Book, <i>Compilers: Principles, Techniques, and Tools</i> by Aho, Ullman, et al. Or probably any other compilers text book.</div><br/></div></div></div></div><div id="40739723" class="c"><input type="checkbox" id="c-40739723" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40740290">prev</a><span>|</span><a href="#40740123">next</a><span>|</span><label class="collapse" for="c-40739723">[-]</label><label class="expand" for="c-40739723">[7 more]</label></div><br/><div class="children"><div class="content">&gt; This is analogous to NFA and DFA regular-expressions. If you use the NFA approach, you need to buffer the entire chunk of data, so that the regex can backtrack. Using the DFA approach, input can be provided as a stream<p>Sorry, no, this is completely wrong. There are other reasons NFAs or DFAs might be preferable, and there are other performance considerations as far as backtracking is concerned, but NFA implementations do not backtrack. I mean, they could, but they don’t, and in common usage a “NFA regex implementation” means a non-backtracking one (that goes through all input once with a bag of states in hand and advances each one of them on each step), whereas a “backtracking regex implementation” means one that doesn’t use automata at all (and is usually worst-case exponential in the input).<p>What this is actually talking about is a streaming parser. Just call it like it is, it’s an OK term that sees plenty of usage.<p>[What you <i>could</i> mention here is PEG parsers, because even linear PEG implementations may need to keep O(input) state and thus are essentially incapable of streaming, unlike LL or LR ones; and GLR et al. can be even worse, for what it’s worth. But this is a much more obscure topic.]</div><br/><div id="40740007" class="c"><input type="checkbox" id="c-40740007" checked=""/><div class="controls bullet"><span class="by">veltas</span><span>|</span><a href="#40739723">parent</a><span>|</span><a href="#40740123">next</a><span>|</span><label class="collapse" for="c-40740007">[-]</label><label class="expand" for="c-40740007">[6 more]</label></div><br/><div class="children"><div class="content">How do you implement a non-backtracking NFA other than converting it to a DFA?</div><br/><div id="40740463" class="c"><input type="checkbox" id="c-40740463" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40739723">root</a><span>|</span><a href="#40740007">parent</a><span>|</span><a href="#40740247">next</a><span>|</span><label class="collapse" for="c-40740463">[-]</label><label class="expand" for="c-40740463">[1 more]</label></div><br/><div class="children"><div class="content">Assuming each state transition consumes a character (“epsilon-free NFA”), just follow the definition. Before each step, you have a list of NFA states you might be in, initially containing only the start state. During each step, go through each state on that list and enter any acceptable successors into a new one. Deduplicate and repeat.<p>This is (potentially super)linear in the number of states, but that doesn’t preclude it from being linear in the input length. In particular, even though it’s essentially a bad lazy implementation of standard NFA-to-DFA conversion, you’re avoiding the exponential state blowup you get in the eager version. (I say it’s a bad lazy implementation because a proper one would memoize; that, however, would bring the worst-case blowup back.) I think that, in addition to the fact that people do actually do this kind of thing in production implementations, qualifies it as a separate approach.<p>If your NFA does have epsilon-transitions—like, say, the NFAs obtained from the textbook Thompson regexp-to-NFA construction—you can either use a different (Glushkov) regexp-to-NFA construction[1], eliminate those transitions as a separate pass[2], or adjust the algorithm above to eliminate duplicate NFA states on the fly[3].<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Glushkov%27s_construction_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Glushkov%27s_construction_algo...</a><p>[2]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19272990">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19272990</a><p>[3]: <a href="https:&#x2F;&#x2F;swtch.com&#x2F;~rsc&#x2F;regexp&#x2F;regexp2.html" rel="nofollow">https:&#x2F;&#x2F;swtch.com&#x2F;~rsc&#x2F;regexp&#x2F;regexp2.html</a></div><br/></div></div><div id="40740247" class="c"><input type="checkbox" id="c-40740247" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#40739723">root</a><span>|</span><a href="#40740007">parent</a><span>|</span><a href="#40740463">prev</a><span>|</span><a href="#40740268">next</a><span>|</span><label class="collapse" for="c-40740247">[-]</label><label class="expand" for="c-40740247">[3 more]</label></div><br/><div class="children"><div class="content">At search time, the principle difference between an NFA and a DFA is that, in an NFA, you can be in more than one state at the same time. There&#x27;s no problem with implementing your transition function to advance all states you are in simultaneously for each character of input. You&#x27;ll get `O(m * n)` time, where `m` is proportional to the number of states in the NFA and `n` is proportional to the length of the input.<p>The GP is remarking on a confusable term, &quot;NFA algorithm,&quot; that has come to mean something different from its underlying theory. The PCRE2 documentation itself, for example[1], remarks about how it uses the &quot;NFA algorithm&quot; as its standard approach to matching. But of course, PCRE2 supports <i>way</i> more than the theoretical model of non-deterministic finite automata (NFA) actually supports. PCRE2 is much more expressive. Yet, the implementation approach is still called &quot;NFA algorithm.&quot; Presumably the reason for this is that an NFA <i>can</i> be simulated by doing backtracking, but if you don&#x27;t keep track of where you&#x27;ve visited, the worst case runtime of this is superlinear, possibly catastrophically so[2]. The problem is that the backtracking regex engines have evolved well beyond what an NFA actually supports. But the name stuck.<p>To make things even more confusing, as I mentioned above, an NFA can be used to execute a search in O(m * n) time. (We typically call that &quot;linear in the size of the input&quot; since the NFA itself can usually, but not always, be regarded as a constant factor. i.e., A literal regex string in your program source code.) So when you say something like, &quot;a finite automata regex engine uses NFAs to guarantee linear time,&quot; you might be <i>really</i> confused if your background is in backtracking engines which... also use an &quot;NFA,&quot; but of course cannot guarantee linear search time.<p>So what we have is ambiguous terminology, not unlike &quot;regex&quot; itself, which could perhaps mean a real theoretical &quot;regular expression&quot; (in the case of Hyperscan, RE2, Go&#x27;s regexp package and Rust&#x27;s regex crate) or it could mean &quot;a very expressive DSL for pattern matching that supports more than what regular languages can describe&quot; (in the case of PCRE2, ECMAScript&#x27;s regex engine, Ruby&#x27;s Oniguruma, Python&#x27;s `re` module, and more). I&#x27;ve made my peace with &quot;regex&quot; being ambiguous, but the fact that &quot;NFA algorithm&quot; is itself ambiguous despite &quot;non-deterministic finite automata&quot; being a somewhat baroque and specific technical term, is very unfortunate.<p>To make things even worse---and I shit you not, I am not joking---the backtracking people seem to have taken to calling a linear time NFA search the &quot;DFA algorithm.&quot;[3] (At least the PCRE2 docs mention it&#x27;s not a &quot;traditional&quot; finite state machine...) But... it&#x27;s not a DFA. The backtracking folks have effectively elevated the terms &quot;NFA&quot; and &quot;DFA&quot; to mean something very different from their theoretical underpinnings.<p>So when you have people that are only aware of one meaning of &quot;NFA algorithm&quot; talking to other people only aware of the other meaning of &quot;NFA algorithm,&quot; chaos ensues.<p>[1]: <a href="https:&#x2F;&#x2F;www.pcre.org&#x2F;current&#x2F;doc&#x2F;html&#x2F;pcre2matching.html" rel="nofollow">https:&#x2F;&#x2F;www.pcre.org&#x2F;current&#x2F;doc&#x2F;html&#x2F;pcre2matching.html</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar?tab=readme-ov-file#cloud-flare-redos">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;rebar?tab=readme-ov-file#cloud...</a><p>[3]: <a href="https:&#x2F;&#x2F;www.pcre.org&#x2F;current&#x2F;doc&#x2F;html&#x2F;pcre2matching.html#TOC1" rel="nofollow">https:&#x2F;&#x2F;www.pcre.org&#x2F;current&#x2F;doc&#x2F;html&#x2F;pcre2matching.html#TOC...</a></div><br/><div id="40741925" class="c"><input type="checkbox" id="c-40741925" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40739723">root</a><span>|</span><a href="#40740247">parent</a><span>|</span><a href="#40740268">next</a><span>|</span><label class="collapse" for="c-40741925">[-]</label><label class="expand" for="c-40741925">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, it’s vexing. This backtracking &#x2F; NFA &#x2F; DFA confusion originally came from Jeffrey Friedl’s book “mastering regular expressions” (O’Reilly, 1997) — at least, that’s the first place I saw the mistake in print. Philip Hazel relied a lot on Friedl’s book when writing PCRE, which is why the PCRE docs get it wrong. (I spoke to Philip about this many years ago when we worked together.)</div><br/><div id="40743082" class="c"><input type="checkbox" id="c-40743082" checked=""/><div class="controls bullet"><span class="by">burntsushi</span><span>|</span><a href="#40739723">root</a><span>|</span><a href="#40741925">parent</a><span>|</span><a href="#40740268">next</a><span>|</span><label class="collapse" for="c-40743082">[-]</label><label class="expand" for="c-40743082">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I didn&#x27;t mention Friedl because I&#x27;ve dumped on him in the past, and didn&#x27;t want to belabor it. But Friedl definitely didn&#x27;t start this. According to him, he was just using what was common vernacular even back then: <a href="http:&#x2F;&#x2F;regex.info&#x2F;blog&#x2F;2006-09-15&#x2F;248" rel="nofollow">http:&#x2F;&#x2F;regex.info&#x2F;blog&#x2F;2006-09-15&#x2F;248</a> (Note that blog is from 2006, but he&#x27;s actually quoting himself from ~10 years prior to that in 1997.)<p>But... he is the one who ultimately installed this ambiguity into a classic book that is still read to this day. So I think he can at least be blamed for popularizing the confusion. And especially since the entire book is framed around &quot;NFA&quot; and &quot;DFA&quot; regex engines. It&#x27;s not like it was just some one-off mention. The mix-up is baked into the conceptual fabric of the book. The landscape also looked different back then. It predated RE2 for example, and RE2 is, I think, principally responsible for bringing &quot;backtracking semantics&quot; to finite automata oriented engines. So Friedl&#x27;s book is forever stuck in a false dichotomy that only <i>happened</i> to exist back when he wrote it.</div><br/></div></div></div></div></div></div><div id="40740268" class="c"><input type="checkbox" id="c-40740268" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40739723">root</a><span>|</span><a href="#40740007">parent</a><span>|</span><a href="#40740247">prev</a><span>|</span><a href="#40740123">next</a><span>|</span><label class="collapse" for="c-40740268">[-]</label><label class="expand" for="c-40740268">[1 more]</label></div><br/><div class="children"><div class="content">As GP said, you can keep a bag of current states.</div><br/></div></div></div></div></div></div><div id="40740123" class="c"><input type="checkbox" id="c-40740123" checked=""/><div class="controls bullet"><span class="by">moody__</span><span>|</span><a href="#40739723">prev</a><span>|</span><a href="#40739380">next</a><span>|</span><label class="collapse" for="c-40740123">[-]</label><label class="expand" for="c-40740123">[8 more]</label></div><br/><div class="children"><div class="content">The &quot;asynchronous state machine&quot; name here is a bit strange, when searching for this term used elsewhere I couldn&#x27;t find any formal definition what it is. Reading further in the README it looks like the author implies that it really just means a DFA? Not entirely sure.<p>I&#x27;d also like to add the Plan 9 implementation[0], which also uses the properties of utf8 as part of its state machine and anecdotally has been quite performant when I&#x27;ve used it.<p>[0] <a href="http:&#x2F;&#x2F;git.9front.org&#x2F;plan9front&#x2F;plan9front&#x2F;107a7ba9717429ae34294d9afa804b5271157ab0&#x2F;sys&#x2F;src&#x2F;cmd&#x2F;wc.c&#x2F;f.html" rel="nofollow">http:&#x2F;&#x2F;git.9front.org&#x2F;plan9front&#x2F;plan9front&#x2F;107a7ba9717429ae...</a></div><br/><div id="40741311" class="c"><input type="checkbox" id="c-40741311" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#40740123">parent</a><span>|</span><a href="#40739380">next</a><span>|</span><label class="collapse" for="c-40741311">[-]</label><label class="expand" for="c-40741311">[7 more]</label></div><br/><div class="children"><div class="content">&quot;Asynchronous&quot; isn&#x27;t part of the name of some really cool state machine :-)   Its just an adjective and means the same as when you put it in front of any other noun.<p>A <i>synchronous</i> state machine is one where the incoming stream of events is always &quot;in sync&quot; with the state transitions, in the following sense:<p>1.  When an event happens, the state machine can transition to the next state and perform any necessary actions <i>before</i> the next event happens<p>2.  After the the state machine has transitioned and performed any necessary actions, the program must wait for the next event to happen.   It can&#x27;t do anything else until it does.<p>An <i>asynchronous</i> state machine doesn&#x27;t make the main program wait until the next event happens.  It can go on and do other things in the meantime. It doesn&#x27;t have to wait for then next event to arrive.<p>When the next event <i>does</i> arrive, the program pauses whatever else it is doing, and hands control back to the state machine, which process the event, and then hands control back over to the main program.</div><br/><div id="40741633" class="c"><input type="checkbox" id="c-40741633" checked=""/><div class="controls bullet"><span class="by">moody__</span><span>|</span><a href="#40740123">root</a><span>|</span><a href="#40741311">parent</a><span>|</span><a href="#40747222">next</a><span>|</span><label class="collapse" for="c-40741633">[-]</label><label class="expand" for="c-40741633">[3 more]</label></div><br/><div class="children"><div class="content">I was not treating &quot;asynchronous state machine&quot; as a noun, even if taken as a generic adjective it doesn&#x27;t make sense in this context. What &quot;other things&quot; is this wc2.c doing while the state machine is churning? There is no multi threading or multi processing going on here. So I find it hard to believe that this use of &quot;asynchronous&quot; is inside of what I would generally see it used as. As such I thought perhaps it referred to a specific methodology for designing the code, something akin to how the &quot;lock free&quot; adjective implies a certain design sensibility.</div><br/><div id="40744038" class="c"><input type="checkbox" id="c-40744038" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#40740123">root</a><span>|</span><a href="#40741633">parent</a><span>|</span><a href="#40747222">next</a><span>|</span><label class="collapse" for="c-40744038">[-]</label><label class="expand" for="c-40744038">[2 more]</label></div><br/><div class="children"><div class="content">&#x2F;&#x2F; What &quot;other things&quot; is this wc2.c doing...<p>AFAICT, wc2.c isn&#x27;t written to be an asynchronous state machine.  It doesn&#x27;t ever seem to transfer the control to any other place.<p>&#x2F;&#x2F; So I find it hard to believe that this use of &quot;asynchronous&quot; is inside of what I would generally see it used as<p>Yeah, you are legitimately confused.  The post talks about asynchronous state machines, but w2c.c isn&#x27;t an example of that.  I&#x27;m sure this gave you a severe case of WTF?!??<p>&#x2F;&#x2F;  thought perhaps it referred to a specific methodology for designing the code<p>It does---that&#x27;s exactly what it is, a programming methodolog, or perhaps better put, a design pattern.   But w2c.c isn&#x27;t an example of code written using that methodology.  Again, you are legitimately confused here, because the post talks about something and w2c.c isn&#x27;t that.<p>Do you know python?  If you google for &quot;asynchronous programming in python&quot; you&#x27;ll get all kinds of blog posts and youtube videos which explain the technique.</div><br/><div id="40746466" class="c"><input type="checkbox" id="c-40746466" checked=""/><div class="controls bullet"><span class="by">moody__</span><span>|</span><a href="#40740123">root</a><span>|</span><a href="#40744038">parent</a><span>|</span><a href="#40747222">next</a><span>|</span><label class="collapse" for="c-40746466">[-]</label><label class="expand" for="c-40746466">[1 more]</label></div><br/><div class="children"><div class="content">Why would the author of this repository make &quot;wc2 - asynchronous state machine parsing&quot; his header of his README if indeed wc2 was not by his own definition an &quot;asynchronous state machine&quot;? I ask you to consider what is more likely: that your blanket definition of asynchronous is incorrect as applied here or the author is just fucking with us by adding random words as the description of his project.</div><br/></div></div></div></div></div></div><div id="40747222" class="c"><input type="checkbox" id="c-40747222" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#40740123">root</a><span>|</span><a href="#40741311">parent</a><span>|</span><a href="#40741633">prev</a><span>|</span><a href="#40741486">next</a><span>|</span><label class="collapse" for="c-40747222">[-]</label><label class="expand" for="c-40747222">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Parallel&quot; seems to be a more popular term in the literature.</div><br/></div></div><div id="40741486" class="c"><input type="checkbox" id="c-40741486" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40740123">root</a><span>|</span><a href="#40741311">parent</a><span>|</span><a href="#40747222">prev</a><span>|</span><a href="#40739380">next</a><span>|</span><label class="collapse" for="c-40741486">[-]</label><label class="expand" for="c-40741486">[2 more]</label></div><br/><div class="children"><div class="content">As I see it, state machines are particularly good for expressing logic in asynchronous systems.  For instance in the late 1980s I wrote assembly language XMODEM implementations for the 6809 and the 80286 and since that kind of code is interrupt drive it is efficient to make a state machine that processes one character at a time.  Today when you use async&#x2F;await the compiler converts your code, loops and all, into a state machine.</div><br/><div id="40743921" class="c"><input type="checkbox" id="c-40743921" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#40740123">root</a><span>|</span><a href="#40741486">parent</a><span>|</span><a href="#40739380">next</a><span>|</span><label class="collapse" for="c-40743921">[-]</label><label class="expand" for="c-40743921">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;&#x2F; 6809<p>The good old days :-)</div><br/></div></div></div></div></div></div></div></div><div id="40739380" class="c"><input type="checkbox" id="c-40739380" checked=""/><div class="controls bullet"><span class="by">YesThatTom2</span><span>|</span><a href="#40740123">prev</a><span>|</span><a href="#40739741">next</a><span>|</span><label class="collapse" for="c-40739380">[-]</label><label class="expand" for="c-40739380">[7 more]</label></div><br/><div class="children"><div class="content">I love state machines and every time I use one my workers think I invented it because they’ve never seen them before.<p>The data for state machine in this article might be best prepared by generating it from a program.  That generator  program doesn’t need to care (too much) about performance since it is run during the build process.   I like the idea of doing a lot of work now to save time in the future.</div><br/><div id="40740256" class="c"><input type="checkbox" id="c-40740256" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#40739380">parent</a><span>|</span><a href="#40740193">next</a><span>|</span><label class="collapse" for="c-40740256">[-]</label><label class="expand" for="c-40740256">[1 more]</label></div><br/><div class="children"><div class="content">I agree, and I raised an eyebrow at the &quot;The algorithm is known as an &quot;asynchronous state-machine parser&quot;. It&#x27;s a technique for parsing that you don&#x27;t learn in college.&quot;<p>I certainly learned about state machines in college. Not sure we ever studied this particular algorithm but the concept was definitely covered.<p>And I also agree that when you are dealing with a known, finite set of values, pre-computing lookup or index tables for techniques like this can be a big win.</div><br/></div></div><div id="40740193" class="c"><input type="checkbox" id="c-40740193" checked=""/><div class="controls bullet"><span class="by">pletnes</span><span>|</span><a href="#40739380">parent</a><span>|</span><a href="#40740256">prev</a><span>|</span><a href="#40743983">next</a><span>|</span><label class="collapse" for="c-40740193">[-]</label><label class="expand" for="c-40740193">[4 more]</label></div><br/><div class="children"><div class="content">Do you have any accessible references on state machines? I’ve just read about them a bit but never coded one in a project. Seems like a useful concept for testable, reliable code.</div><br/><div id="40740604" class="c"><input type="checkbox" id="c-40740604" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40739380">root</a><span>|</span><a href="#40740193">parent</a><span>|</span><a href="#40742373">next</a><span>|</span><label class="collapse" for="c-40740604">[-]</label><label class="expand" for="c-40740604">[2 more]</label></div><br/><div class="children"><div class="content">The video <i>Finite State Machines explained</i> by Abelardo Pardo[1] seems like a good introduction (I&#x27;m not familiar with the author; I just searched Finite State machine on youtube and found the first result which wasn&#x27;t a jumbled mess of abstract or misused jargon).<p>It may seem simple, but that&#x27;s truely all there is to finite state machines, a set of finite states and a set of events which cause transitions between states. Their specific applications to various domains is a much larger topic, but with a basic understanding, any application should be clear whenever it comes up. There&#x27;s no one way to implement a state machine, and you&#x27;ve probably used them all the time, even if you haven&#x27;t thought about them formally. For example, a simple but common 2-state machine takes the form:<p><pre><code>   running = true
   while running:
       …
       if &lt;some condition&gt;:
           running = false
</code></pre>
[1]: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hJIST1cEf6A" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hJIST1cEf6A</a></div><br/><div id="40742835" class="c"><input type="checkbox" id="c-40742835" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#40739380">root</a><span>|</span><a href="#40740604">parent</a><span>|</span><a href="#40742373">next</a><span>|</span><label class="collapse" for="c-40742835">[-]</label><label class="expand" for="c-40742835">[1 more]</label></div><br/><div class="children"><div class="content">It could be written as:<p><pre><code>    while True:
        ...
        if &lt;exit condition&gt;:
            break</code></pre></div><br/></div></div></div></div><div id="40742373" class="c"><input type="checkbox" id="c-40742373" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40739380">root</a><span>|</span><a href="#40740193">parent</a><span>|</span><a href="#40740604">prev</a><span>|</span><a href="#40743983">next</a><span>|</span><label class="collapse" for="c-40742373">[-]</label><label class="expand" for="c-40742373">[1 more]</label></div><br/><div class="children"><div class="content">A finite state machine has a set of input symbols, a set of states, and a transition function, which maps the current state and current input to the next state (and, when programming it, it doesn&#x27;t have to be a literal function; for example, it could be a 2D array). It also has a start state, and a set of accept states.<p>It&#x27;s also common for state machines to have some sort of output; otherwise, all an FSM can do is recognize whether an input string is &quot;good.&quot; So, there&#x27;s also an output function, so that the FSM actually does something while processing the input string. There are two types of FSMs: a Mealy Machine, and a Moore machine. In a Mealy machine, the output function maps the current state and the current input to an output; so, one state could be associated with multiple outputs. In a Moore machine, the output is <i>purely</i> a function of the current state, no matter the input. Usually, a Moore machine has more states than the equivalent Mealy machine. In practice, Moore machines are a lot rarer than Mealy machines.<p>You can model FSMs in a variety of ways. You could use the state pattern [0]. You could have a table-based state machine; examples in C here [1] [2]. It&#x27;s also common to model them using a loop and a switch statement with integers to represent the current state - or just use &quot;goto&quot; to go to the next state, if it&#x27;s available in your language.<p>Also, this is tangential, but something nice about coroutines is that they save can you from writing an explicit state machine, as the state is implicit in your code. One example of this is how it&#x27;s easier to write iterators as coroutines that yield results as they run, rather than as structures that update themselves based on their current state, transition to the next state, and yield a result.<p>So far, what I&#x27;ve covered is basically a deterministic finite automaton (DFA). There are also non-deterministic finite automata (NDFAs), which are used to implement regular expressions (at least when regular expressions aren&#x27;t extended to require more powerful recognizers) [3], as well as pushdown automata (PDAs), which are basically finite automata with a stack, and can parse e.g. programming languages. Finally, there are Turing machines.<p>For theory on that, I&#x27;d recommend reading Sipser&#x27;s <i>Introduction to the Theory of Computation.</i> If you look up the book on Google, it&#x27;s not difficult to find a PDF of it.<p>[0]: <a href="https:&#x2F;&#x2F;refactoring.guru&#x2F;design-patterns&#x2F;state" rel="nofollow">https:&#x2F;&#x2F;refactoring.guru&#x2F;design-patterns&#x2F;state</a><p>[1]: <a href="https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2020&#x2F;12&#x2F;31" rel="nofollow">https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2020&#x2F;12&#x2F;31</a><p>[2]: <a href="https:&#x2F;&#x2F;ideone.com&#x2F;94U6aJ" rel="nofollow">https:&#x2F;&#x2F;ideone.com&#x2F;94U6aJ</a> (this one removes C-style comments from source code - I didn&#x27;t make it)<p>[3]: <a href="https:&#x2F;&#x2F;swtch.com&#x2F;~rsc&#x2F;regexp&#x2F;regexp1.html" rel="nofollow">https:&#x2F;&#x2F;swtch.com&#x2F;~rsc&#x2F;regexp&#x2F;regexp1.html</a></div><br/></div></div></div></div><div id="40743983" class="c"><input type="checkbox" id="c-40743983" checked=""/><div class="controls bullet"><span class="by">FroshKiller</span><span>|</span><a href="#40739380">parent</a><span>|</span><a href="#40740193">prev</a><span>|</span><a href="#40739741">next</a><span>|</span><label class="collapse" for="c-40743983">[-]</label><label class="expand" for="c-40743983">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a little surprised to hear this. Writing a state machine to simulate an alarm clock used to be an introductory project for first-year computer science undergraduates.</div><br/></div></div></div></div><div id="40739741" class="c"><input type="checkbox" id="c-40739741" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#40739380">prev</a><span>|</span><a href="#40740213">next</a><span>|</span><label class="collapse" for="c-40739741">[-]</label><label class="expand" for="c-40739741">[4 more]</label></div><br/><div class="children"><div class="content">What about this is &quot;asynchronous&quot;?</div><br/><div id="40745965" class="c"><input type="checkbox" id="c-40745965" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#40739741">parent</a><span>|</span><a href="#40740184">next</a><span>|</span><label class="collapse" for="c-40745965">[-]</label><label class="expand" for="c-40745965">[1 more]</label></div><br/><div class="children"><div class="content">I guess since state is fully encoded inside a single state variable and of course the output counts, it would be trivially simple to switch between multiple input streams and incrementally count words in each of them as new data arrives.</div><br/></div></div><div id="40740184" class="c"><input type="checkbox" id="c-40740184" checked=""/><div class="controls bullet"><span class="by">roelschroeven</span><span>|</span><a href="#40739741">parent</a><span>|</span><a href="#40745965">prev</a><span>|</span><a href="#40740213">next</a><span>|</span><label class="collapse" for="c-40740184">[-]</label><label class="expand" for="c-40740184">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get that either.<p>It feels like they compare the asynchronous-ness of their algorithm to Nginx being asynchronous (&quot;asynchronous web-servers like Nginx use a state-machine parser. They parse the bytes as they arrive, and discard them.&quot;), but I don&#x27;t see how that relates. The way web-servers handle requests (multiple threads vs multiple processes vs asynchronous event-driven in one thread) is completely orthogonal to how they parse headers.<p>The impression I have is that their algorithm works in a streaming way, without having to allocate memory buffers, and that they call that asynchronous (wrongly, as far as I can see).<p>I also don&#x27;t really see what they mean by their algorithm being more scalable.</div><br/><div id="40740469" class="c"><input type="checkbox" id="c-40740469" checked=""/><div class="controls bullet"><span class="by">laurent_du</span><span>|</span><a href="#40739741">root</a><span>|</span><a href="#40740184">parent</a><span>|</span><a href="#40740213">next</a><span>|</span><label class="collapse" for="c-40740469">[-]</label><label class="expand" for="c-40740469">[1 more]</label></div><br/><div class="children"><div class="content">My understanding was that scalability came from the removal of memory buffers.</div><br/></div></div></div></div></div></div><div id="40740213" class="c"><input type="checkbox" id="c-40740213" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40739741">prev</a><span>|</span><a href="#40740876">next</a><span>|</span><label class="collapse" for="c-40740213">[-]</label><label class="expand" for="c-40740213">[1 more]</label></div><br/><div class="children"><div class="content">Recognising that wc is a lexer problem and implementing it using re2c would be my first choice here. That&#x27;ll be building a similar state machine to what is done by hand here, especially since the hand rolled one is still byte at a time (the main drawback to re2c&#x27;s generated output).</div><br/></div></div><div id="40740876" class="c"><input type="checkbox" id="c-40740876" checked=""/><div class="controls bullet"><span class="by">JackSlateur</span><span>|</span><a href="#40740213">prev</a><span>|</span><a href="#40740734">next</a><span>|</span><label class="collapse" for="c-40740876">[-]</label><label class="expand" for="c-40740876">[4 more]</label></div><br/><div class="children"><div class="content">Reading the code to help me understand how things are<p>I got the wc_lines from coreutils: <a href="https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;src&#x2F;wc.c#L248">https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;src&#x2F;wc.c#...</a><p>And I thought &quot;damn, I understand nothing about the state-machine stuff, how did they made this faster ?&quot;<p>Truth is: they did not
Of course, this is just the &quot;count line&quot; part. Other parts are indeed faster.<p>Coreutils 9.4:<p><pre><code>  0.67 [jack:&#x2F;tmp] &#x2F;usr&#x2F;bin&#x2F;time -v wc -l debian-12.2.0-amd64-netinst.iso 
  2524855 debian-12.2.0-amd64-netinst.iso
   Command being timed: &quot;wc -l debian-12.2.0-amd64-netinst.iso&quot;
 User time (seconds): 0.00
 System time (seconds): 0.07
 Percent of CPU this job got: 98%
 Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.07
 Average shared text size (kbytes): 0
 Average unshared data size (kbytes): 0
 Average stack size (kbytes): 0
 Average total size (kbytes): 0
 Maximum resident set size (kbytes): 2176
 Average resident set size (kbytes): 0
 Major (requiring I&#x2F;O) page faults: 0
 Minor (reclaiming a frame) page faults: 99
 Voluntary context switches: 1
 Involuntary context switches: 0
 Swaps: 0
 File system inputs: 0
 File system outputs: 0
 Socket messages sent: 0
 Socket messages received: 0
 Signals delivered: 0
 Page size (bytes): 4096
 Exit status: 0
</code></pre>
And wc2 (from gcc -O3 -o wc2 wc2.c):<p><pre><code>  0.47 [jack:&#x2F;tmp] &#x2F;usr&#x2F;bin&#x2F;time -v .&#x2F;wc2 -l debian-12.2.0-amd64-netinst.iso 
  2524855 debian-12.2.0-amd64-netinst.iso
 Command being timed: &quot;.&#x2F;wc2 -l debian-12.2.0-amd64- netinst.iso&quot;
 User time (seconds): 0.97
 System time (seconds): 0.05
 Percent of CPU this job got: 99%
 Elapsed (wall clock) time (h:mm:ss or m:ss): 0:01.03
 Average shared text size (kbytes): 0
 Average unshared data size (kbytes): 0
 Average stack size (kbytes): 0
 Average total size (kbytes): 0
 Maximum resident set size (kbytes): 2176
 Average resident set size (kbytes): 0
 Major (requiring I&#x2F;O) page faults: 0
 Minor (reclaiming a frame) page faults: 146
 Voluntary context switches: 1
 Involuntary context switches: 1
 Swaps: 0
 File system inputs: 0
 File system outputs: 0
 Socket messages sent: 0
 Socket messages received: 0
 Signals delivered: 0
 Page size (bytes): 4096
 Exit status: 0
</code></pre>
Gotta keep reading</div><br/><div id="40744066" class="c"><input type="checkbox" id="c-40744066" checked=""/><div class="controls bullet"><span class="by">roetlich</span><span>|</span><a href="#40740876">parent</a><span>|</span><a href="#40741399">next</a><span>|</span><label class="collapse" for="c-40744066">[-]</label><label class="expand" for="c-40744066">[1 more]</label></div><br/><div class="children"><div class="content">From looking at the code, the clever bit is how this is doing word count. (and word &amp; line count at the same time). So yeah, it makes -l isn&#x27;t better.</div><br/></div></div><div id="40741399" class="c"><input type="checkbox" id="c-40741399" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#40740876">parent</a><span>|</span><a href="#40744066">prev</a><span>|</span><a href="#40740734">next</a><span>|</span><label class="collapse" for="c-40741399">[-]</label><label class="expand" for="c-40741399">[2 more]</label></div><br/><div class="children"><div class="content">Any notable difference if you pipe the file in, rather than read from disk?<p>IO caches are a thing as well, don’t use the first measurement.</div><br/><div id="40743565" class="c"><input type="checkbox" id="c-40743565" checked=""/><div class="controls bullet"><span class="by">JackSlateur</span><span>|</span><a href="#40740876">root</a><span>|</span><a href="#40741399">parent</a><span>|</span><a href="#40740734">next</a><span>|</span><label class="collapse" for="c-40743565">[-]</label><label class="expand" for="c-40743565">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve accounted for IO cache, the test is running from an in-memory dataset<p>After checking a bit more, wc2 is indeed faster than wc in a specific use case: counting characters. That is, transforming a sequence of one or multiple bytes into meaningful character (wc --chars somefile).<p>In wc, the related code is here: <a href="https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;src&#x2F;wc.c#L444">https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;src&#x2F;wc.c#...</a><p>So in the end, wc uses the function while wc2 does not: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;string&#x2F;multibyte&#x2F;mbrtoc32" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;string&#x2F;multibyte&#x2F;mbrtoc32</a><p>Now, what I cannot tell : is wc2&#x27;s code really comparable versus mbrtoc32 ? From a couple of tests, it works against ascii and utf8 dataset, but is that all ? Or are there edgecases cleverly handled by mbrtoc32 (with a performance cost) ?</div><br/></div></div></div></div></div></div><div id="40740734" class="c"><input type="checkbox" id="c-40740734" checked=""/><div class="controls bullet"><span class="by">throwaway55533</span><span>|</span><a href="#40740876">prev</a><span>|</span><a href="#40744381">next</a><span>|</span><label class="collapse" for="c-40740734">[-]</label><label class="expand" for="c-40740734">[5 more]</label></div><br/><div class="children"><div class="content">From reading the article, how is this more efficient? Doesn&#x27;t any word counting algorithm have to iterate through all the characters and count spaces?<p>What makes this better than the standard algorithm of<p><pre><code>    wc = 0
    prev = null
    for ch in charStream:
        if !isSpace(ch) and isSpace(prev):
           wc += 1
        prev = ch</code></pre></div><br/><div id="40740868" class="c"><input type="checkbox" id="c-40740868" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40740734">parent</a><span>|</span><a href="#40742477">next</a><span>|</span><label class="collapse" for="c-40740868">[-]</label><label class="expand" for="c-40740868">[3 more]</label></div><br/><div class="children"><div class="content">Basically, it&#x27;s just a lookup table for isSpace, rather than whatever logic is in the original function (which probably has conditional branches).<p>There&#x27;s a little bit of a complication in the fact that a state machine can implicitly share parts of the computation for utf-8 encoded codepoints with shared prefixes, so instead of a 2^32-element lookup table, you only need 4 2^8-element lookup tables (and instead of 1 state, parsing codepoint, you have 4, parsing first byte, parsing second byte, etc.).</div><br/><div id="40741161" class="c"><input type="checkbox" id="c-40741161" checked=""/><div class="controls bullet"><span class="by">throwaway55533</span><span>|</span><a href="#40740734">root</a><span>|</span><a href="#40740868">parent</a><span>|</span><a href="#40742477">next</a><span>|</span><label class="collapse" for="c-40741161">[-]</label><label class="expand" for="c-40741161">[2 more]</label></div><br/><div class="children"><div class="content">Ah. Is 8 bits really optimal? I don&#x27;t know how many UTF space characters there are, I thought there were only a few. Why not a 16-bit lookup?</div><br/><div id="40743338" class="c"><input type="checkbox" id="c-40743338" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40740734">root</a><span>|</span><a href="#40741161">parent</a><span>|</span><a href="#40742477">next</a><span>|</span><label class="collapse" for="c-40743338">[-]</label><label class="expand" for="c-40743338">[1 more]</label></div><br/><div class="children"><div class="content">UTF-8 encoded codepoints can have an odd number of bytes, so processing a file 2 bytes at a time would be a little more complicated. Processing the file one codepoint at a time works because you can decode the UTF-8 stream into a stream of 32-bit codepoints before passing the codepoints to the lookup table. I suppose you could also transform from UTF-8 to UTF-16 before passing values to the lookup table.<p>Processing byte by byte isn&#x27;t necessarily faster than processing codepoint by codepoint, or any other size. You&#x27;d need to measure performance empirically, and it probably depends on caches sizes and other factors. In theory, you could also process bit by bit — then you&#x27;d only need 32 2-element lookup tables — but that&#x27;s unlikely to be efficient, since you&#x27;d need to do a lot of bit manipulation.<p>Edit: Upon inspection, the method I described doesn&#x27;t appear to be the method used by the featured program. It still basically uses a lookup table for detecting space characters, byte by byte, but the states are not how I described. Instead of the states representing which byte of a UTF-8 encoded codepoint is being processed, and the word count being incremented upon certain transitions — a Mealy machine — the state represent the class of the codepoint last fully processed, and the count is always increased based on the current state (often by zero) — a Moore machine.</div><br/></div></div></div></div></div></div><div id="40742477" class="c"><input type="checkbox" id="c-40742477" checked=""/><div class="controls bullet"><span class="by">jxndnxu</span><span>|</span><a href="#40740734">parent</a><span>|</span><a href="#40740868">prev</a><span>|</span><a href="#40744381">next</a><span>|</span><label class="collapse" for="c-40742477">[-]</label><label class="expand" for="c-40742477">[1 more]</label></div><br/><div class="children"><div class="content">You have answered your question yourself: your algorithm looks at each byte twice, not once<p>It&#x27;s even more obvious in the UTF case where the classic implementation first looks at 1-4 byte to parse a character and only then checks if it&#x27;s a space</div><br/></div></div></div></div><div id="40744381" class="c"><input type="checkbox" id="c-40744381" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#40740734">prev</a><span>|</span><a href="#40745122">next</a><span>|</span><label class="collapse" for="c-40744381">[-]</label><label class="expand" for="c-40744381">[2 more]</label></div><br/><div class="children"><div class="content">&quot;The wc program included with macOS and Linux are completely different. Therefore, the following table shows them benchmarked against each other on the same hardware.&quot;<p>Appears BSD wc (&quot;the macOS program&quot;) is much faster than the GNU coreutils wc (&quot;the Linux program&quot;).<p>It certainly illustrates a point about people rewriting wc in newer languages to demonstrate alleged speed against C.<p>Which wc are they using for comparison.<p>Pehaps they should use wc2 or wc2o.</div><br/><div id="40744838" class="c"><input type="checkbox" id="c-40744838" checked=""/><div class="controls bullet"><span class="by">mytec</span><span>|</span><a href="#40744381">parent</a><span>|</span><a href="#40745122">next</a><span>|</span><label class="collapse" for="c-40744838">[-]</label><label class="expand" for="c-40744838">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a really good point. I&#x27;m using macOS and I tested -w option against a CSV file that is about 430MB in size and has about 18,000,000 words in it. The time was 0.989. When I ran wc2 on the same file, it clocked in at 0.943.<p>I wondered what I was doing wrong and came back to the comments section and found your comment. Ah.<p>Edit: interestingly, the newline count time was 0.458 with the macOS version and 0.943 with wc2.</div><br/></div></div></div></div><div id="40745122" class="c"><input type="checkbox" id="c-40745122" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40744381">prev</a><span>|</span><a href="#40739837">next</a><span>|</span><label class="collapse" for="c-40745122">[-]</label><label class="expand" for="c-40745122">[6 more]</label></div><br/><div class="children"><div class="content">In the bringing a tank to a knife fight kind of way, could this be optimized to run on a GPU? Load the contents then do an &quot;and&quot; across the whole contents in parallel, and then sum the whitespaces?</div><br/><div id="40745390" class="c"><input type="checkbox" id="c-40745390" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40745122">parent</a><span>|</span><a href="#40739837">next</a><span>|</span><label class="collapse" for="c-40745390">[-]</label><label class="expand" for="c-40745390">[5 more]</label></div><br/><div class="children"><div class="content">These benchmarks are on 92 million byte files so we&#x27;re into the range where bringing a tank is fair (and worth the startup cost).</div><br/><div id="40746864" class="c"><input type="checkbox" id="c-40746864" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40745122">root</a><span>|</span><a href="#40745390">parent</a><span>|</span><a href="#40745982">next</a><span>|</span><label class="collapse" for="c-40746864">[-]</label><label class="expand" for="c-40746864">[1 more]</label></div><br/><div class="children"><div class="content">I got nerd sniped into doing it. <a href="https:&#x2F;&#x2F;github.com&#x2F;fragmede&#x2F;wc-gpu">https:&#x2F;&#x2F;github.com&#x2F;fragmede&#x2F;wc-gpu</a></div><br/></div></div><div id="40745982" class="c"><input type="checkbox" id="c-40745982" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#40745122">root</a><span>|</span><a href="#40745390">parent</a><span>|</span><a href="#40746864">prev</a><span>|</span><a href="#40739837">next</a><span>|</span><label class="collapse" for="c-40745982">[-]</label><label class="expand" for="c-40745982">[3 more]</label></div><br/><div class="children"><div class="content">I doubt that you can make it faster on the GPU than on CPU when utilizing SIMD, reason being that you are actually doing something close to trivial upon looking at each byte in sequence. So you transfer it from CPU memory to GPU memory in order to do almost nothing with it.</div><br/><div id="40746535" class="c"><input type="checkbox" id="c-40746535" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#40745122">root</a><span>|</span><a href="#40745982">parent</a><span>|</span><a href="#40746169">next</a><span>|</span><label class="collapse" for="c-40746535">[-]</label><label class="expand" for="c-40746535">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got it working on a T4 via Google Colab. The PDF takes 178 milliseconds to the 206 listed in the readme for the C version, so 15%?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;fragmede&#x2F;wc-gpu&#x2F;blob&#x2F;main&#x2F;wc_gpu.ipynb">https:&#x2F;&#x2F;github.com&#x2F;fragmede&#x2F;wc-gpu&#x2F;blob&#x2F;main&#x2F;wc_gpu.ipynb</a></div><br/></div></div><div id="40746169" class="c"><input type="checkbox" id="c-40746169" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40745122">root</a><span>|</span><a href="#40745982">parent</a><span>|</span><a href="#40746535">prev</a><span>|</span><a href="#40739837">next</a><span>|</span><label class="collapse" for="c-40746169">[-]</label><label class="expand" for="c-40746169">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only at a limit like that if you don&#x27;t parallelize.  And sure you could use more cores, but you can go a lot faster on 20% of a GPU than on 20% of your CPU cores.</div><br/></div></div></div></div></div></div></div></div><div id="40739837" class="c"><input type="checkbox" id="c-40739837" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#40745122">prev</a><span>|</span><a href="#40739315">next</a><span>|</span><label class="collapse" for="c-40739837">[-]</label><label class="expand" for="c-40739837">[3 more]</label></div><br/><div class="children"><div class="content">I was a bit surprised by the macos&#x2F;linux speed differential here:<p>&gt; The difference in macOS and Linux speed is actually the difference in clang and gcc speed. The LLVM clang compiler is doing better optimizations for x86 processors here.<p>I know GCC has been getting much, much more aggressive as of late, but there have been some complaints that it is now much, much less safe (checks intended for security getting optimized away, e.g.).<p>I wonder if you were to go back to 5 years ago, if you&#x27;d see the linux code was generally safer than the speedy osx llvm code...</div><br/><div id="40740012" class="c"><input type="checkbox" id="c-40740012" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40739837">parent</a><span>|</span><a href="#40739315">next</a><span>|</span><label class="collapse" for="c-40740012">[-]</label><label class="expand" for="c-40740012">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d assume the difference between Linux&#x27;s GNU and macOS&#x27;s BSD implementations would be much more significant.</div><br/><div id="40742197" class="c"><input type="checkbox" id="c-40742197" checked=""/><div class="controls bullet"><span class="by">pjdesno</span><span>|</span><a href="#40739837">root</a><span>|</span><a href="#40740012">parent</a><span>|</span><a href="#40739315">next</a><span>|</span><label class="collapse" for="c-40742197">[-]</label><label class="expand" for="c-40742197">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. MacOS (really BSD) grep sucks, 5-10x slower than GNU Grep for simple searches on the same hardware, but MacOS&#x2F;BSD wc is fast.</div><br/></div></div></div></div></div></div><div id="40739315" class="c"><input type="checkbox" id="c-40739315" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40739837">prev</a><span>|</span><a href="#40739562">next</a><span>|</span><label class="collapse" for="c-40739315">[-]</label><label class="expand" for="c-40739315">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised there is no mention of simd. Like I&#x27;m sure this is &quot;fast enough&quot; but if you want to make a really fast wc for fun wouldn&#x27;t that be a natural direction?</div><br/><div id="40739473" class="c"><input type="checkbox" id="c-40739473" checked=""/><div class="controls bullet"><span class="by">thequux</span><span>|</span><a href="#40739315">parent</a><span>|</span><a href="#40739504">next</a><span>|</span><label class="collapse" for="c-40739473">[-]</label><label class="expand" for="c-40739473">[4 more]</label></div><br/><div class="children"><div class="content">A hand-written SIMD wc is likely to be even faster than a state machine, but at the cost of orders of magnitude more work. The huge advantage of state machines are that they are a relatively generic approach that provides massive speedups nearly every time. A SIMD wc algorithm is a significant effort that can&#x27;t be generalized, and is only likely to provide a 4x speedup or so: rarely worth it except in cases where the task is a performance hotspot for a <i>lot</i> of applications.</div><br/><div id="40741372" class="c"><input type="checkbox" id="c-40741372" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40739315">root</a><span>|</span><a href="#40739473">parent</a><span>|</span><a href="#40740357">next</a><span>|</span><label class="collapse" for="c-40741372">[-]</label><label class="expand" for="c-40741372">[2 more]</label></div><br/><div class="children"><div class="content">An ASCII SIMD wc would likely be much more than 4× faster. The 320 MB&#x2F;s is speed TFA quotes is good for a byte-at-a-time solution, but pitiful as far as the capabilities of modern machines are concerned. A decent SSD is an order of magnitude faster than that. Around 1 GB&#x2F;s (i.e. ~100 cycles&#x2F;fetch) is table stakes for a task of this complexity.<p>(TFA almost nerd-sniped me into writing a SIMD implementation already, and you finished the job. End result: on an aging 2.5 GHz Broadwell, I’m seeing 300 MB&#x2F;s for TFA’s C implementation and 3200 MB&#x2F;s for my first attempt at an x86-64-v3 one. So more like a 10× speedup, and its highly likely one can do better. Admittedly I did spend around an hour on these 50 lines, and would need to spend more in reality to check for CPU features at runtime and so on.)<p>However, TFA calls going ASCII-only “cheating”, and I can see its point. I don’t know how difficult a Unicode SIMD wc would be or if it’s even possible to do well. (Bonus points: do you want to define a word boundary as a space&#x2F;nonspace boundary the way[1] POSIX tells you to, or the more complex way[2] Unicode tells you to?)<p>[1] <a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;wc.html" rel="nofollow">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;w...</a><p>[2] <a href="https:&#x2F;&#x2F;www.unicode.org&#x2F;reports&#x2F;tr29&#x2F;#Word_Boundaries" rel="nofollow">https:&#x2F;&#x2F;www.unicode.org&#x2F;reports&#x2F;tr29&#x2F;#Word_Boundaries</a></div><br/><div id="40741432" class="c"><input type="checkbox" id="c-40741432" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40739315">root</a><span>|</span><a href="#40741372">parent</a><span>|</span><a href="#40740357">next</a><span>|</span><label class="collapse" for="c-40741432">[-]</label><label class="expand" for="c-40741432">[1 more]</label></div><br/><div class="children"><div class="content">The (cheating, ASCII-only) SIMD implementation for reference:<p><pre><code>  #if 0 &#x2F;* shell polyglot *&#x2F;
  exec ${CC:-cc} $CPPFLAGS -g -O2 -march=x86-64-v3 $CFLAGS -o &quot;${0%.c}&quot; &quot;$0&quot; || exit $?
  #endif
  &#x2F;* SPDX-License-Identifier: CC0-1.0 *&#x2F;
  
  #include &lt;immintrin.h&gt;
  #include &lt;stdint.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;unistd.h&gt;
  
  int main(int argc, char **argv) {
      const char *const progname = argc ? argv[0] : &quot;&lt;unknown&gt;&quot;;
      unsigned long long bytes = 0, words = 0, lines = 0;
      uint32_t prev = -1;
      for (;;) {
          static __m256i buf[1024 * 1024];
          ssize_t k, n = 0;
          do {
              k = read(STDIN_FILENO, (char *)buf + n, sizeof buf - n);
          } while (k &gt; 0 &amp;&amp; (n += k) &lt; sizeof buf);
          if (k &lt; 0) { perror(progname); return 1; }
          if (!n) break;
          bytes += n;
  
          while (n % sizeof *buf) ((char *)buf)[n++] = &#x27; &#x27;;
          n &#x2F;= sizeof *buf;
  
          for (size_t i = 0; i &lt; n; i++) {
              __m256i x = _mm256_load_si256(&amp;buf[i]);
  
              __m256i nl = _mm256_cmpeq_epi8(x, _mm256_set1_epi8(&#x27;\n&#x27;));
              lines += _mm_popcnt_u32(_mm256_movemask_epi8(nl));
  
              const __m256i table = _mm256_broadcastsi128_si256(_mm_setr_epi8(
                  &#x2F;* 0 *&#x2F; &#x27; &#x27;, 0,    0,    0,    0,    0,    0, 0,
                  &#x2F;* 8 *&#x2F; 0,   &#x27;\t&#x27;, &#x27;\n&#x27;, &#x27;\v&#x27;, &#x27;\f&#x27;, &#x27;\r&#x27;, 0, 0));
              __m256i ws = _mm256_cmpeq_epi8(x, _mm256_shuffle_epi8(table,
                  _mm256_and_si256(x, _mm256_set1_epi8(0x0F))));
              uint64_t mask = _mm256_movemask_epi8(ws);
              words += _mm_popcnt_u32(mask ^ (mask &lt;&lt; 32 | prev) &gt;&gt; 31);
              prev = mask;
          }
      }
      words += !(prev &gt;&gt; 31);
      printf(&quot;%llu %llu %llu\n&quot;, lines, words &#x2F; 2, bytes);
      return 0;
  }</code></pre></div><br/></div></div></div></div><div id="40740357" class="c"><input type="checkbox" id="c-40740357" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40739315">root</a><span>|</span><a href="#40739473">parent</a><span>|</span><a href="#40741372">prev</a><span>|</span><a href="#40739504">next</a><span>|</span><label class="collapse" for="c-40740357">[-]</label><label class="expand" for="c-40740357">[1 more]</label></div><br/><div class="children"><div class="content">SIMD-based reimplementations of wc already exist, e.g. this [0] one, and it&#x27;s rather straightforward.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;expr-fi&#x2F;fastlwc">https:&#x2F;&#x2F;github.com&#x2F;expr-fi&#x2F;fastlwc</a></div><br/></div></div></div></div><div id="40739504" class="c"><input type="checkbox" id="c-40739504" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#40739315">parent</a><span>|</span><a href="#40739473">prev</a><span>|</span><a href="#40739562">next</a><span>|</span><label class="collapse" for="c-40739504">[-]</label><label class="expand" for="c-40739504">[1 more]</label></div><br/><div class="children"><div class="content">I think this is but a detail in the context of the article.<p>Yes, you can implement your state machine on SIMD sized states, but there are also millions of other optimizations you can do like that, aligning your reads, prefetching the file, parallelizing, etc.<p>Doesn&#x27;t change the core concept</div><br/></div></div></div></div><div id="40739562" class="c"><input type="checkbox" id="c-40739562" checked=""/><div class="controls bullet"><span class="by">rakoo</span><span>|</span><a href="#40739315">prev</a><span>|</span><a href="#40739871">next</a><span>|</span><label class="collapse" for="c-40739562">[-]</label><label class="expand" for="c-40739562">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This state machine approach always results in the same speed, regardless of input.<p>This is strange to me, shouldn&#x27;t it be O(N) with the size of the input ? Or maybe in this benchmark the inputs are small enough that the difference isn&#x27;t measurable ?</div><br/><div id="40739693" class="c"><input type="checkbox" id="c-40739693" checked=""/><div class="controls bullet"><span class="by">sebastianmestre</span><span>|</span><a href="#40739562">parent</a><span>|</span><a href="#40739583">next</a><span>|</span><label class="collapse" for="c-40739693">[-]</label><label class="expand" for="c-40739693">[1 more]</label></div><br/><div class="children"><div class="content">They meant that different characters don&#x27;t change the performance, unlike the Linux and MacOS versions, where different characters go through different code paths.<p>But yes, a bigger file does take longer to process.</div><br/></div></div><div id="40739583" class="c"><input type="checkbox" id="c-40739583" checked=""/><div class="controls bullet"><span class="by">VMG</span><span>|</span><a href="#40739562">parent</a><span>|</span><a href="#40739693">prev</a><span>|</span><a href="#40740134">next</a><span>|</span><label class="collapse" for="c-40739583">[-]</label><label class="expand" for="c-40739583">[1 more]</label></div><br/><div class="children"><div class="content">he is talking in context of same-sized files (counted in bytes)</div><br/></div></div><div id="40740134" class="c"><input type="checkbox" id="c-40740134" checked=""/><div class="controls bullet"><span class="by">roywiggins</span><span>|</span><a href="#40739562">parent</a><span>|</span><a href="#40739583">prev</a><span>|</span><a href="#40739871">next</a><span>|</span><label class="collapse" for="c-40740134">[-]</label><label class="expand" for="c-40740134">[1 more]</label></div><br/><div class="children"><div class="content">Speed as in bytes per second, regardless of which bytes you give it.</div><br/></div></div></div></div><div id="40739871" class="c"><input type="checkbox" id="c-40739871" checked=""/><div class="controls bullet"><span class="by">aftbit</span><span>|</span><a href="#40739562">prev</a><span>|</span><a href="#40739344">next</a><span>|</span><label class="collapse" for="c-40739871">[-]</label><label class="expand" for="c-40739871">[2 more]</label></div><br/><div class="children"><div class="content">It would have been nice for the author to label the states and explain how and why they chose the states that they did. Otherwise, it&#x27;s hard to understand how to apply this sort of thing to larger problems.</div><br/><div id="40742509" class="c"><input type="checkbox" id="c-40742509" checked=""/><div class="controls bullet"><span class="by">jxndnxu</span><span>|</span><a href="#40739871">parent</a><span>|</span><a href="#40739344">next</a><span>|</span><label class="collapse" for="c-40742509">[-]</label><label class="expand" for="c-40742509">[1 more]</label></div><br/><div class="children"><div class="content">How would if have helped? You either design a DFA by hand or use a compiled from a regular language</div><br/></div></div></div></div><div id="40739344" class="c"><input type="checkbox" id="c-40739344" checked=""/><div class="controls bullet"><span class="by">mjamil</span><span>|</span><a href="#40739871">prev</a><span>|</span><a href="#40739346">next</a><span>|</span><label class="collapse" for="c-40739344">[-]</label><label class="expand" for="c-40739344">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Many programmers think pointer-arithmetic is faster.&quot; Don&#x27;t modern compilers make this statement false (i.e., both approaches are implemented via the same machine instructions)?</div><br/><div id="40742726" class="c"><input type="checkbox" id="c-40742726" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40739344">parent</a><span>|</span><a href="#40741471">next</a><span>|</span><label class="collapse" for="c-40742726">[-]</label><label class="expand" for="c-40742726">[1 more]</label></div><br/><div class="children"><div class="content">Something funny is that GCC may compile your code that uses pointer arithmetic into one that uses an index register, and compile your code that uses an index into an array as pointer arithmetic.<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;9KPnnM7Po" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;9KPnnM7Po</a></div><br/></div></div><div id="40741471" class="c"><input type="checkbox" id="c-40741471" checked=""/><div class="controls bullet"><span class="by">jimbobthrowawy</span><span>|</span><a href="#40739344">parent</a><span>|</span><a href="#40742726">prev</a><span>|</span><a href="#40739745">next</a><span>|</span><label class="collapse" for="c-40741471">[-]</label><label class="expand" for="c-40741471">[1 more]</label></div><br/><div class="children"><div class="content">I checked using godbolt, and when compiling with -O2 (like his makefile) only the parse_chunk_pp version is in the emitted assembly and is called regardless of the -P option. I think compilers have done this where applicable for a long time.<p>Compiling without any arguments leads to two lines differing in the assembly for the functions.</div><br/></div></div><div id="40739745" class="c"><input type="checkbox" id="c-40739745" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40739344">parent</a><span>|</span><a href="#40741471">prev</a><span>|</span><a href="#40739346">next</a><span>|</span><label class="collapse" for="c-40739745">[-]</label><label class="expand" for="c-40739745">[1 more]</label></div><br/><div class="children"><div class="content">They definitely do in simple cases (e.g. a simple for loop). In more complex cases, especially when the index&#x2F;pointer escapes a function then the code will be different.</div><br/></div></div></div></div><div id="40739346" class="c"><input type="checkbox" id="c-40739346" checked=""/><div class="controls bullet"><span class="by">markstos</span><span>|</span><a href="#40739344">prev</a><span>|</span><a href="#40745103">next</a><span>|</span><label class="collapse" for="c-40739346">[-]</label><label class="expand" for="c-40739346">[3 more]</label></div><br/><div class="children"><div class="content">Was this ever submitted an update to the `wc` shipped on systems?</div><br/><div id="40740400" class="c"><input type="checkbox" id="c-40740400" checked=""/><div class="controls bullet"><span class="by">canucker2016</span><span>|</span><a href="#40739346">parent</a><span>|</span><a href="#40745103">next</a><span>|</span><label class="collapse" for="c-40740400">[-]</label><label class="expand" for="c-40740400">[2 more]</label></div><br/><div class="children"><div class="content">I doubt it - from the project&#x27;s readme page:<p>&quot;...Now the real wc works with a lot more character-sets, and we don&#x27;t do that. But by implementing UTF-8, we&#x27;ve shown that it&#x27;s possible, and that the speed for any character-set is the same.&quot;<p>Looking at the command line options for wc2.c and comparing to the FSF wc man page, it looks like there are some missing&#x2F;unsupported options in wc2.c as well.</div><br/><div id="40740477" class="c"><input type="checkbox" id="c-40740477" checked=""/><div class="controls bullet"><span class="by">anon1040</span><span>|</span><a href="#40739346">root</a><span>|</span><a href="#40740400">parent</a><span>|</span><a href="#40745103">next</a><span>|</span><label class="collapse" for="c-40740477">[-]</label><label class="expand" for="c-40740477">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ...the real wc works with a lot more character-sets...<p>This should read: the real wc works with a lot more character _encodings_</div><br/></div></div></div></div></div></div><div id="40745103" class="c"><input type="checkbox" id="c-40745103" checked=""/><div class="controls bullet"><span class="by">kristianpaul</span><span>|</span><a href="#40739346">prev</a><span>|</span><a href="#40741546">next</a><span>|</span><label class="collapse" for="c-40745103">[-]</label><label class="expand" for="c-40745103">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t fedora working on improving some gnu tools?</div><br/></div></div><div id="40741546" class="c"><input type="checkbox" id="c-40741546" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#40745103">prev</a><span>|</span><a href="#40741107">next</a><span>|</span><label class="collapse" for="c-40741546">[-]</label><label class="expand" for="c-40741546">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t know you were allowed to use a language other than Rust for something like this.</div><br/></div></div><div id="40741107" class="c"><input type="checkbox" id="c-40741107" checked=""/><div class="controls bullet"><span class="by">NunoSempere</span><span>|</span><a href="#40741546">prev</a><span>|</span><a href="#40740059">next</a><span>|</span><label class="collapse" for="c-40741107">[-]</label><label class="expand" for="c-40741107">[2 more]</label></div><br/><div class="children"><div class="content">From a previous project: <a href="https:&#x2F;&#x2F;nunosempere.com&#x2F;blog&#x2F;2023&#x2F;09&#x2F;15&#x2F;wc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nunosempere.com&#x2F;blog&#x2F;2023&#x2F;09&#x2F;15&#x2F;wc&#x2F;</a> that was looking not at speed, but at simplicity, here is a comparison of different historical versions of wc:<p>---<p>The [version of wc.c](<a href="https:&#x2F;&#x2F;git.nunosempere.com&#x2F;personal&#x2F;wc&#x2F;src&#x2F;branch&#x2F;master&#x2F;src&#x2F;wc.c" rel="nofollow">https:&#x2F;&#x2F;git.nunosempere.com&#x2F;personal&#x2F;wc&#x2F;src&#x2F;branch&#x2F;master&#x2F;sr...</a>) in this repository sits at 44 lines. It decides to read from stdin if the number of arguments fed to it is otherwise zero, and uses the standard C function getc to read character by character. It doesn&#x27;t have flags, instead, there are further utilities in the src&#x2F;extra&#x2F; folder for counting characters and lines, sitting at 32 and 35 lines of code, respectively. This version also has little error checking.<p>[Here](<a href="https:&#x2F;&#x2F;github.com&#x2F;dspinellis&#x2F;unix-history-repo&#x2F;blob&#x2F;Research-V7-Snapshot-Development&#x2F;usr&#x2F;src&#x2F;cmd&#x2F;wc.c">https:&#x2F;&#x2F;github.com&#x2F;dspinellis&#x2F;unix-history-repo&#x2F;blob&#x2F;Researc...</a>) is a version of wc from UNIX V7, at 86 lines. It allows for counting characters, words and lines. I couldn&#x27;t find a version in UNIX V6, so I&#x27;m guessing this is one of the earliest versions of this program. It decides to read from stdin if the number of arguments fed to it is zero, and reads character by character using the standard C getc function.<p>The busybox version ([git.busybox.net](<a href="https:&#x2F;&#x2F;git.busybox.net&#x2F;busybox&#x2F;tree&#x2F;coreutils&#x2F;wc.c" rel="nofollow">https:&#x2F;&#x2F;git.busybox.net&#x2F;busybox&#x2F;tree&#x2F;coreutils&#x2F;wc.c</a>)) of wc sits at 257 lines (162 with comments stripped), while striving to be [POSIX-compliant](<a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;</a>), meaning it has a fair number of flags and a bit of complexity. It reads character by character by using the standard getc function, and decides to read from stdin or not using its own fopen_or_warn_stdin function. It uses two GOTOs to get around, and has some incomplete Unicode support.<p>The [plan9](<a href="https:&#x2F;&#x2F;9p.io&#x2F;sources&#x2F;plan9&#x2F;sys&#x2F;src&#x2F;cmd&#x2F;wc.c" rel="nofollow">https:&#x2F;&#x2F;9p.io&#x2F;sources&#x2F;plan9&#x2F;sys&#x2F;src&#x2F;cmd&#x2F;wc.c</a>) version implements some sort of table method in 331 lines. It uses plan9 rather than Unix libraries and methods, and seems to read from stdin if the number of args is 0.<p>The plan9port version of wc ([github](<a href="https:&#x2F;&#x2F;github.com&#x2F;9fans&#x2F;plan9port&#x2F;blob&#x2F;master&#x2F;src&#x2F;cmd&#x2F;wc.c">https:&#x2F;&#x2F;github.com&#x2F;9fans&#x2F;plan9port&#x2F;blob&#x2F;master&#x2F;src&#x2F;cmd&#x2F;wc.c</a>)) also implements some sort of table method, in 352 lines. It reads from stdin if the number of args is 0, and uses the Linux read function to read character by character.<p>The [OpenBSD](<a href="https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;blob&#x2F;master&#x2F;usr.bin&#x2F;wc&#x2F;wc.c">https:&#x2F;&#x2F;github.com&#x2F;openbsd&#x2F;src&#x2F;blob&#x2F;master&#x2F;usr.bin&#x2F;wc&#x2F;wc.c</a>) version is just *nice*. It reads from stdin by default, and uses a bit of buffering using read to speed things up. It defaults to using fstat when counting characters. It is generally pleasantly understandable, nice to read. I&#x27;m actually surprised at how pleasant it is to read.<p>The [FreeBSD version](<a href="https:&#x2F;&#x2F;cgit.freebsd.org&#x2F;src&#x2F;tree&#x2F;usr.bin&#x2F;wc&#x2F;wc.c" rel="nofollow">https:&#x2F;&#x2F;cgit.freebsd.org&#x2F;src&#x2F;tree&#x2F;usr.bin&#x2F;wc&#x2F;wc.c</a>) sits at 367 lines. It has enough new things that I can&#x27;t parse all that it&#x27;s doing: in lines 137-143, what is capabilities mode? what is casper?, but otherwise it decides whether to read from stdin by the number of arguments, in line 157. It uses a combination of fstat and read, depending on the type of file.<p>Finally, the GNU utils version ([github](<a href="https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;tree&#x2F;master&#x2F;src&#x2F;wc.c">https:&#x2F;&#x2F;github.com&#x2F;coreutils&#x2F;coreutils&#x2F;tree&#x2F;master&#x2F;src&#x2F;wc.c</a>), [savannah](<a href="http:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;gitweb&#x2F;?p=coreutils.git;a=blob;f=src&#x2F;wc.c;hb=HEAD" rel="nofollow">http:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;gitweb&#x2F;?p=coreutils.git;a=blob;f...</a>)) is a bit over 1K lines of C. It does many things and checks many possible failure modes. I think it detects whether it should be reading from stdin using some very wrapped fstat, and it reads character by character using its own custom function.<p>So this utility started out reasonably small, then started getting more and more complex. [The POSIX committee](<a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;</a>) ended up codifying that complexity, and now we are stuck with it because even implementations like busybox which strive to be quite small try to keep to POSIX.</div><br/><div id="40743146" class="c"><input type="checkbox" id="c-40743146" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40741107">parent</a><span>|</span><a href="#40740059">next</a><span>|</span><label class="collapse" for="c-40743146">[-]</label><label class="expand" for="c-40743146">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another version from Unix V10: <a href="http:&#x2F;&#x2F;tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V10&#x2F;cmd&#x2F;wc.c" rel="nofollow">http:&#x2F;&#x2F;tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V10&#x2F;cmd&#x2F;wc.c</a><p>Also, from V8: <a href="https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V8&#x2F;usr&#x2F;src&#x2F;cmd&#x2F;wc.c" rel="nofollow">https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V8&#x2F;usr&#x2F;src&#x2F;cmd&#x2F;wc...</a></div><br/></div></div></div></div><div id="40740059" class="c"><input type="checkbox" id="c-40740059" checked=""/><div class="controls bullet"><span class="by">rep_movsd</span><span>|</span><a href="#40741107">prev</a><span>|</span><a href="#40739598">next</a><span>|</span><label class="collapse" for="c-40740059">[-]</label><label class="expand" for="c-40740059">[1 more]</label></div><br/><div class="children"><div class="content">Remember &quot;The Zen of Code Optimization&quot; by Michael Abrash in the 90s?<p>This word count challenge was the first one he described.
The table driven approach was discussed, but was not necessarily the fastest due to the large cache overflowing (on 90s processors) table needed.<p>I used the same example in a chapter I wrote for a C++ book</div><br/></div></div><div id="40739598" class="c"><input type="checkbox" id="c-40739598" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#40740059">prev</a><span>|</span><a href="#40741106">next</a><span>|</span><label class="collapse" for="c-40739598">[-]</label><label class="expand" for="c-40739598">[1 more]</label></div><br/><div class="children"><div class="content">while you are in there,<p><pre><code>  wc --unicode
  wc --bom</code></pre></div><br/></div></div><div id="40739996" class="c"><input type="checkbox" id="c-40739996" checked=""/><div class="controls bullet"><span class="by">cryptos</span><span>|</span><a href="#40741106">prev</a><span>|</span><a href="#40739651">next</a><span>|</span><label class="collapse" for="c-40739996">[-]</label><label class="expand" for="c-40739996">[1 more]</label></div><br/><div class="children"><div class="content">Now we need another round of the language battle, because now this approach needs to be implemented in Rust, Go, Zig, Nim ... you name it!</div><br/></div></div><div id="40739651" class="c"><input type="checkbox" id="c-40739651" checked=""/><div class="controls bullet"><span class="by">aargh_aargh</span><span>|</span><a href="#40739996">prev</a><span>|</span><label class="collapse" for="c-40739651">[-]</label><label class="expand" for="c-40739651">[7 more]</label></div><br/><div class="children"><div class="content">I wanted to take a peek the state diagram (ASCII version). But I was feeling lazy, so apologies for having ChatGPT do the work for me. I wasn&#x27;t going for correctness and didn&#x27;t check it. If you&#x27;re like me, here you go:<p><a href="https:&#x2F;&#x2F;dreampuf.github.io&#x2F;GraphvizOnline&#x2F;#digraph%20StateMachine%20%7B%0A%20%20%20%20rankdir%3DLR%3B%0A%20%20%20%20size%3D%228%2C5%22%3B%0A%20%20%20%20node%20%5Bshape%20%3D%20circle%5D%3B%0A%20%20%20%20%0A%20%20%20%20LookingForWord%20-%3E%20InsideWord%20%5Blabel%3D%22Non-space%22%5D%3B%0A%20%20%20%20LookingForWord%20-%3E%20LookingForWord%20%5Blabel%3D%22Space%22%5D%3B%0A%20%20%20%20LookingForWord%20-%3E%20Newline%20%5Blabel%3D%22Newline%22%5D%3B%0A%20%20%20%20LookingForWord%20-%3E%20LookingForWord%20%5Blabel%3D%22Other%22%5D%3B%0A%20%20%20%20%0A%20%20%20%20Newline%20-%3E%20InsideWord%20%5Blabel%3D%22Non-space%22%5D%3B%0A%20%20%20%20Newline%20-%3E%20LookingForWord%20%5Blabel%3D%22Space%22%5D%3B%0A%20%20%20%20Newline%20-%3E%20Newline%20%5Blabel%3D%22Newline%22%5D%3B%0A%20%20%20%20Newline%20-%3E%20LookingForWord%20%5Blabel%3D%22Other%22%5D%3B%0A%20%20%20%20%0A%20%20%20%20InsideWord%20-%3E%20ContinueWord%20%5Blabel%3D%22Non-space%22%5D%3B%0A%20%20%20%20InsideWord%20-%3E%20LookingForWord%20%5Blabel%3D%22Space%22%5D%3B%0A%20%20%20%20InsideWord%20-%3E%20Newline%20%5Blabel%3D%22Newline%22%5D%3B%0A%20%20%20%20InsideWord%20-%3E%20LookingForWord%20%5Blabel%3D%22Other%22%5D%3B%0A%20%20%20%20%0A%20%20%20%20ContinueWord%20-%3E%20ContinueWord%20%5Blabel%3D%22Non-space%22%5D%3B%0A%20%20%20%20ContinueWord%20-%3E%20LookingForWord%20%5Blabel%3D%22Space%22%5D%3B%0A%20%20%20%20ContinueWord%20-%3E%20Newline%20%5Blabel%3D%22Newline%22%5D%3B%0A%20%20%20%20ContinueWord%20-%3E%20LookingForWord%20%5Blabel%3D%22Other%22%5D%3B%0A%7D%0A" rel="nofollow">https:&#x2F;&#x2F;dreampuf.github.io&#x2F;GraphvizOnline&#x2F;#digraph%20StateMa...</a><p>digraph StateMachine {
    rankdir=LR;
    size=&quot;8,5&quot;;
    node [shape = circle];<p><pre><code>    LookingForWord -&gt; InsideWord [label=&quot;Non-space&quot;];
    LookingForWord -&gt; LookingForWord [label=&quot;Space&quot;];
    LookingForWord -&gt; Newline [label=&quot;Newline&quot;];
    LookingForWord -&gt; LookingForWord [label=&quot;Other&quot;];
    
    Newline -&gt; InsideWord [label=&quot;Non-space&quot;];
    Newline -&gt; LookingForWord [label=&quot;Space&quot;];
    Newline -&gt; Newline [label=&quot;Newline&quot;];
    Newline -&gt; LookingForWord [label=&quot;Other&quot;];
    
    InsideWord -&gt; ContinueWord [label=&quot;Non-space&quot;];
    InsideWord -&gt; LookingForWord [label=&quot;Space&quot;];
    InsideWord -&gt; Newline [label=&quot;Newline&quot;];
    InsideWord -&gt; LookingForWord [label=&quot;Other&quot;];
    
    ContinueWord -&gt; ContinueWord [label=&quot;Non-space&quot;];
    ContinueWord -&gt; LookingForWord [label=&quot;Space&quot;];
    ContinueWord -&gt; Newline [label=&quot;Newline&quot;];
    ContinueWord -&gt; LookingForWord [label=&quot;Other&quot;];</code></pre>
}<p>EDIT: Under peer pressure, I checked it and it correctly reflects the code apart from being designed for one specific line ending sequence (as it should, being an example optimized for brevity).<p>As for the replies, as opposed to my approach, I&#x27;m sure when you&#x27;re browsing research papers, you&#x27;re doing a full reproducibility study for each one. I&#x27;m sorry I commented, I should have waited for you to post your results.</div><br/><div id="40739825" class="c"><input type="checkbox" id="c-40739825" checked=""/><div class="controls bullet"><span class="by">roywiggins</span><span>|</span><a href="#40739651">parent</a><span>|</span><a href="#40739666">next</a><span>|</span><label class="collapse" for="c-40739825">[-]</label><label class="expand" for="c-40739825">[1 more]</label></div><br/><div class="children"><div class="content">Surely correctness is the most important thing? Anyone can produce an <i>incorrect</i> state diagram.</div><br/></div></div><div id="40739666" class="c"><input type="checkbox" id="c-40739666" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#40739651">parent</a><span>|</span><a href="#40739825">prev</a><span>|</span><label class="collapse" for="c-40739666">[-]</label><label class="expand" for="c-40739666">[5 more]</label></div><br/><div class="children"><div class="content">This is a useless contribution to the discussion, maybe even negative... Why didn&#x27;t you check it at least before sharing?</div><br/><div id="40739856" class="c"><input type="checkbox" id="c-40739856" checked=""/><div class="controls bullet"><span class="by">aftbit</span><span>|</span><a href="#40739651">root</a><span>|</span><a href="#40739666">parent</a><span>|</span><label class="collapse" for="c-40739856">[-]</label><label class="expand" for="c-40739856">[4 more]</label></div><br/><div class="children"><div class="content">Why? Because it&#x27;s wrong? If it were correct, wouldn&#x27;t it be useful?</div><br/><div id="40740081" class="c"><input type="checkbox" id="c-40740081" checked=""/><div class="controls bullet"><span class="by">roywiggins</span><span>|</span><a href="#40739651">root</a><span>|</span><a href="#40739856">parent</a><span>|</span><label class="collapse" for="c-40740081">[-]</label><label class="expand" for="c-40740081">[3 more]</label></div><br/><div class="children"><div class="content">This is a bit like presenting someone with a raw egg on a plate and saying &quot;ah, but if I <i>had</i> cooked it, might it not be a tasty omelet?&quot; Correctness is the hard part!</div><br/><div id="40740356" class="c"><input type="checkbox" id="c-40740356" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40739651">root</a><span>|</span><a href="#40740081">parent</a><span>|</span><a href="#40745811">next</a><span>|</span><label class="collapse" for="c-40740356">[-]</label><label class="expand" for="c-40740356">[1 more]</label></div><br/><div class="children"><div class="content">More like a covered plate you&#x27;re expected to eat without looking. &quot;This may be an amazing omelet and you will have a great meal, or you may eat a raw egg, get salmonella, and be sick for a week. It&#x27;s probably an omelet, but I&#x27;m not sure, so you&#x27;ll probably be fine. Enjoy!&quot;</div><br/></div></div><div id="40745811" class="c"><input type="checkbox" id="c-40745811" checked=""/><div class="controls bullet"><span class="by">aftbit</span><span>|</span><a href="#40739651">root</a><span>|</span><a href="#40740081">parent</a><span>|</span><a href="#40740356">prev</a><span>|</span><label class="collapse" for="c-40745811">[-]</label><label class="expand" for="c-40745811">[1 more]</label></div><br/><div class="children"><div class="content">Right, but are its labels of the state actually incorrect? I don&#x27;t know well enough how to check.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>