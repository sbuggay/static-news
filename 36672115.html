<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689066068329" as="style"/><link rel="stylesheet" href="styles.css?v=1689066068329"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://articles.59.ca/doku.php?id=em:20482030">2048 Bit RSA and the Year 2030</a>Â <span class="domain">(<a href="https://articles.59.ca">articles.59.ca</a>)</span></div><div class="subtext"><span>upofadown</span> | <span>124 comments</span></div><br/><div><div id="36672750" class="c"><input type="checkbox" id="c-36672750" checked=""/><div class="controls bullet"><span class="by">sansseriff</span><span>|</span><a href="#36672510">next</a><span>|</span><label class="collapse" for="c-36672750">[-]</label><label class="expand" for="c-36672750">[21 more]</label></div><br/><div class="children"><div class="content">We can expect a quantum computer with 20 million noisy qubits to break RSA 2048 [1]<p>I can&#x27;t speak to coherence time or circuit depth concerns, but qubit counts are doubling roughly every year. Current chips have thousands of qubits, so the exponential scaling implies we&#x27;d have 20 million qubits by 2035-2040.<p>edit: And from the paper, the required quantum volume (&quot;megaqubitdays&quot;) scales bewteen O(n^3) and O(n^4) with RSA key length. So a few years after breaking RSA 2048, you&#x27;d have a computer five times larger that could break RSA 3072.<p>[1] <a href="https:&#x2F;&#x2F;quantum-journal.org&#x2F;papers&#x2F;q-2021-04-15-433&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;quantum-journal.org&#x2F;papers&#x2F;q-2021-04-15-433&#x2F;</a></div><br/><div id="36678222" class="c"><input type="checkbox" id="c-36678222" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#36672750">parent</a><span>|</span><a href="#36673626">next</a><span>|</span><label class="collapse" for="c-36678222">[-]</label><label class="expand" for="c-36678222">[1 more]</label></div><br/><div class="children"><div class="content">if qubit counts are doubling every year then why is 21 still the largest number ever factored with a quantum algorithm</div><br/></div></div><div id="36673626" class="c"><input type="checkbox" id="c-36673626" checked=""/><div class="controls bullet"><span class="by">fsh</span><span>|</span><a href="#36672750">parent</a><span>|</span><a href="#36678222">prev</a><span>|</span><a href="#36673524">next</a><span>|</span><label class="collapse" for="c-36673626">[-]</label><label class="expand" for="c-36673626">[10 more]</label></div><br/><div class="children"><div class="content">Google&#x27;s &quot;quantum supremacy&quot; paper was about a 53 qubit chip in 2019 [1]. This year, they reported having 70 qubits [2]. Looking at the papers (and supplements), the gate fidelities and qubit lifetimes have stayed roughly the same. This really doesn&#x27;t look like anything like Moore&#x27;s law to me.<p>[1] <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1038&#x2F;s41586-019-1666-5" rel="nofollow noreferrer">https:&#x2F;&#x2F;doi.org&#x2F;10.1038&#x2F;s41586-019-1666-5</a><p>[2] <a href="https:&#x2F;&#x2F;doi.org&#x2F;10.48550&#x2F;arXiv.2304.11119" rel="nofollow noreferrer">https:&#x2F;&#x2F;doi.org&#x2F;10.48550&#x2F;arXiv.2304.11119</a></div><br/><div id="36673816" class="c"><input type="checkbox" id="c-36673816" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36673626">parent</a><span>|</span><a href="#36673758">next</a><span>|</span><label class="collapse" for="c-36673816">[-]</label><label class="expand" for="c-36673816">[5 more]</label></div><br/><div class="children"><div class="content">Last time I took around 1 hour to do a review of literature, I discovered that the size of those computers were growing at a <i>linear</i> rate of around 4 qbits&#x2F;year.<p>It got slightly faster on the last few years, I don&#x27;t know if inherently so or just due to random fluctuation. Yet people keep repeating that claim that the growth is exponential, based on no evidence at all.</div><br/><div id="36674130" class="c"><input type="checkbox" id="c-36674130" checked=""/><div class="controls bullet"><span class="by">krastanov</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36673816">parent</a><span>|</span><a href="#36673758">next</a><span>|</span><label class="collapse" for="c-36674130">[-]</label><label class="expand" for="c-36674130">[4 more]</label></div><br/><div class="children"><div class="content">For example, is this developer roadmap far from the truth? <a href="https:&#x2F;&#x2F;newsroom.ibm.com&#x2F;2022-11-09-IBM-Unveils-400-Qubit-Plus-Quantum-Processor-and-Next-Generation-IBM-Quantum-System-Two" rel="nofollow noreferrer">https:&#x2F;&#x2F;newsroom.ibm.com&#x2F;2022-11-09-IBM-Unveils-400-Qubit-Pl...</a><p>While it is too early to call it exponential, it is wildly faster than 4 qubits&#x2F;year. Same can be said about other hardware systems too (trapped ions, neutral atoms, and with some caveats photonics and color centers too).</div><br/><div id="36674266" class="c"><input type="checkbox" id="c-36674266" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36674130">parent</a><span>|</span><a href="#36677314">next</a><span>|</span><label class="collapse" for="c-36674266">[-]</label><label class="expand" for="c-36674266">[2 more]</label></div><br/><div class="children"><div class="content">This is the kind of article I threw away for being unsubstantiated.<p>Besides, it has 2 &quot;real&quot; datapoints, and both are completely different from the sizes everybody else were achieving in well-public and well-reviewed computers.<p>If you restrict your data to devices other people were allowed to touch, a lot of those huge numbers just disappear.</div><br/><div id="36675537" class="c"><input type="checkbox" id="c-36675537" checked=""/><div class="controls bullet"><span class="by">EvgeniyZh</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36674266">parent</a><span>|</span><a href="#36677314">next</a><span>|</span><label class="collapse" for="c-36675537">[-]</label><label class="expand" for="c-36675537">[1 more]</label></div><br/><div class="children"><div class="content">People in academia are having access to 127-qubit computer, not sure about 400+ option. It more like you don&#x27;t have much to do with this amount of qubits that noisy (they aren&#x27;t particularly bad, just not good enough) and with sparse connectivity.</div><br/></div></div></div></div><div id="36677314" class="c"><input type="checkbox" id="c-36677314" checked=""/><div class="controls bullet"><span class="by">squokko</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36674130">parent</a><span>|</span><a href="#36674266">prev</a><span>|</span><a href="#36673758">next</a><span>|</span><label class="collapse" for="c-36677314">[-]</label><label class="expand" for="c-36677314">[1 more]</label></div><br/><div class="children"><div class="content">I would not believe anything I heard from IBM unless I also heard it from someone else</div><br/></div></div></div></div></div></div><div id="36673758" class="c"><input type="checkbox" id="c-36673758" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36673626">parent</a><span>|</span><a href="#36673816">prev</a><span>|</span><a href="#36673524">next</a><span>|</span><label class="collapse" for="c-36673758">[-]</label><label class="expand" for="c-36673758">[4 more]</label></div><br/><div class="children"><div class="content">If we didn&#x27;t invent photolithography, we&#x27;d still be using computers the size of buildings limited to universities and military installations.<p>Right now no one knows how to build a scalable quantum computer. But as soon as we find out the equivalent of lithography for building quantum chips, the progress will come, and it will come quickly and suddenly.</div><br/><div id="36673900" class="c"><input type="checkbox" id="c-36673900" checked=""/><div class="controls bullet"><span class="by">Mistletoe</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36673758">parent</a><span>|</span><a href="#36673524">next</a><span>|</span><label class="collapse" for="c-36673900">[-]</label><label class="expand" for="c-36673900">[3 more]</label></div><br/><div class="children"><div class="content">How do you know there is an equivalent process for quantum chips?</div><br/><div id="36674100" class="c"><input type="checkbox" id="c-36674100" checked=""/><div class="controls bullet"><span class="by">krastanov</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36673900">parent</a><span>|</span><a href="#36674217">next</a><span>|</span><label class="collapse" for="c-36674100">[-]</label><label class="expand" for="c-36674100">[1 more]</label></div><br/><div class="children"><div class="content">There are some equivalents already in existence (spin qubits in CMOS processes), that use the exact same lithography techniques. There are a few other potential alternatives too. All of them suffer from harder engineering challenges than the much &quot;easier&quot; to produce (in small volumes) transmons and trapped ions&#x2F;atoms&#x2F;molecules. Thus a plausible future is one in which the first somewhat-useful quantum computers are tens of thousands of qubits in transmon&#x2F;ion hybrid systems. Then (in that plausible future) the spin qubits in CMOS do catch up, and thanks to their superior manufacturing scalability, they blow past the capabilities of transmons&#x2F;ions.<p>Not too different from how we had to use vacuum lamps while we figure out how solid state systems can work... Or spinning hard drives before we figured out SDDs.<p>Or maybe none of this would work out and the whole field would be a bust... but you know Clarke&#x27;s laws <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Clarke%27s_three_laws" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Clarke%27s_three_laws</a></div><br/></div></div><div id="36674217" class="c"><input type="checkbox" id="c-36674217" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36673900">parent</a><span>|</span><a href="#36674100">prev</a><span>|</span><a href="#36673524">next</a><span>|</span><label class="collapse" for="c-36674217">[-]</label><label class="expand" for="c-36674217">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t. All I&#x27;m saying is that progress can be linear&#x2F;non-existing until a breakthrough is made that allows scaling. For microchips this was lithography. After such a breakthrough the scaling can (temporarily) be exponential.</div><br/></div></div></div></div></div></div></div></div><div id="36673524" class="c"><input type="checkbox" id="c-36673524" checked=""/><div class="controls bullet"><span class="by">sweis</span><span>|</span><a href="#36672750">parent</a><span>|</span><a href="#36673626">prev</a><span>|</span><a href="#36673201">next</a><span>|</span><label class="collapse" for="c-36673524">[-]</label><label class="expand" for="c-36673524">[1 more]</label></div><br/><div class="children"><div class="content">The record quantum computers can factor is 21 -- and that is by cheating by already knowing the factors are 3 and 7. There are other results that use special form composites which don&#x27;t count.<p>So a QC can factor a 5 bit number with Shor&#x27;s algorithm in 2023 (with some cheating). That record has not changed for 10+ years.<p>I publicly bet 8 years ago that nobody would factor the number 35 by 2030. I hope I&#x27;m proved wrong.</div><br/></div></div><div id="36673201" class="c"><input type="checkbox" id="c-36673201" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36672750">parent</a><span>|</span><a href="#36673524">prev</a><span>|</span><a href="#36673670">next</a><span>|</span><label class="collapse" for="c-36673201">[-]</label><label class="expand" for="c-36673201">[1 more]</label></div><br/><div class="children"><div class="content">More detail on progress towards quantum factoring of RSA (among other things):<p><a href="https:&#x2F;&#x2F;sam-jaques.appspot.com&#x2F;quantum_landscape" rel="nofollow noreferrer">https:&#x2F;&#x2F;sam-jaques.appspot.com&#x2F;quantum_landscape</a><p>I&#x27;m not super concerned. Cynically: one big driver of research into PQ cryptography is that it&#x27;s a full employment program for academic cryptographers. Not that there&#x27;s anything wrong with that! I like a Richelot isogeny as much as the next guy, or I would if I understood what they were.</div><br/></div></div><div id="36673670" class="c"><input type="checkbox" id="c-36673670" checked=""/><div class="controls bullet"><span class="by">jessriedel</span><span>|</span><a href="#36672750">parent</a><span>|</span><a href="#36673201">prev</a><span>|</span><a href="#36673314">next</a><span>|</span><label class="collapse" for="c-36673670">[-]</label><label class="expand" for="c-36673670">[5 more]</label></div><br/><div class="children"><div class="content">At least as of 2020, it looked like both qubit counts and two-qubit gate quality were improving exponentially, and our naive extrapolation said RSA 2048 wouldn&#x27;t get cracked by 2039 at 95% confidence.<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2009.05045" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2009.05045</a><p>As far as I can tell, this website suggests that two-qubit gate infidelity has continued to improve exponentially, although it&#x27;s hard to tell if these are reliable datapoints.<p><a href="https:&#x2F;&#x2F;metriq.info&#x2F;Task&#x2F;38" rel="nofollow noreferrer">https:&#x2F;&#x2F;metriq.info&#x2F;Task&#x2F;38</a><p>Because there&#x27;s typically an engineering tension between qubit count and gate quality, what you want to track is something like quantum volume, which looks to be on trend<p><a href="https:&#x2F;&#x2F;metriq.info&#x2F;Task&#x2F;34" rel="nofollow noreferrer">https:&#x2F;&#x2F;metriq.info&#x2F;Task&#x2F;34</a><p>but it&#x27;s notable that Google achieved quantum supremacy without having amazing quantum volume numbers, so it&#x27;s not a perfect metric<p><a href="https:&#x2F;&#x2F;spectrum.ieee.org&#x2F;quantum-computing-google-sycamore" rel="nofollow noreferrer">https:&#x2F;&#x2F;spectrum.ieee.org&#x2F;quantum-computing-google-sycamore</a><p>Worth noting that once you cross the fault tolerant threshold you will probably see a big shift in how engineering effort is distributed: many researchers think it will be harder to improve gate quality than just increase increase qubit counts to make up for it, so you may see gate quality stall and extrapolation become even less reliable.</div><br/><div id="36673781" class="c"><input type="checkbox" id="c-36673781" checked=""/><div class="controls bullet"><span class="by">akvadrako</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36673670">parent</a><span>|</span><a href="#36673314">next</a><span>|</span><label class="collapse" for="c-36673781">[-]</label><label class="expand" for="c-36673781">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; once you cross the fault tolerant threshold</i><p>If we cross the threshold. Until then, adding a qubit requires halving the noise floor, so the Moore&#x27;s law equivalent to exponential scaling is basically adding a fixed number of qubits per year.</div><br/><div id="36674660" class="c"><input type="checkbox" id="c-36674660" checked=""/><div class="controls bullet"><span class="by">jessriedel</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36673781">parent</a><span>|</span><a href="#36673314">next</a><span>|</span><label class="collapse" for="c-36674660">[-]</label><label class="expand" for="c-36674660">[3 more]</label></div><br/><div class="children"><div class="content">Not sure what you&#x27;re saying.<p>Are you suggesting that gates surpassing the fault tolerant threshold will never be achieved?  The vast majority of experts disagree with this.<p>Without fault tolerance, you have a hard wall on circuit depth because errors grow exponentially with depth.  You can&#x27;t make up for this by adding any number of qubits.  &quot;Halving the noise floor&quot; means...what, improving gate fidelity?</div><br/><div id="36677897" class="c"><input type="checkbox" id="c-36677897" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36674660">parent</a><span>|</span><a href="#36674804">next</a><span>|</span><label class="collapse" for="c-36677897">[-]</label><label class="expand" for="c-36677897">[1 more]</label></div><br/><div class="children"><div class="content">The vast majority of experts are being employed to say this. There is no demonstrable evidence of physical computation to the contrary.</div><br/></div></div><div id="36674804" class="c"><input type="checkbox" id="c-36674804" checked=""/><div class="controls bullet"><span class="by">akvadrako</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36674660">parent</a><span>|</span><a href="#36677897">prev</a><span>|</span><a href="#36673314">next</a><span>|</span><label class="collapse" for="c-36674804">[-]</label><label class="expand" for="c-36674804">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I&#x27;m saying. I don&#x27;t really mean never, but I don&#x27;t see why we have good reason to believe we&#x27;ll reach that threshold this millenium.<p>Until then, the best we can do is if you half the noise floor (or double the fidelity) you can add roughly one ideal qubit.</div><br/></div></div></div></div></div></div></div></div><div id="36673314" class="c"><input type="checkbox" id="c-36673314" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#36672750">parent</a><span>|</span><a href="#36673670">prev</a><span>|</span><a href="#36672510">next</a><span>|</span><label class="collapse" for="c-36673314">[-]</label><label class="expand" for="c-36673314">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Current chips have thousands of qubits,<p>really? I thought we have 70 max?</div><br/><div id="36673418" class="c"><input type="checkbox" id="c-36673418" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#36672750">root</a><span>|</span><a href="#36673314">parent</a><span>|</span><a href="#36672510">next</a><span>|</span><label class="collapse" for="c-36673418">[-]</label><label class="expand" for="c-36673418">[1 more]</label></div><br/><div class="children"><div class="content">I suspect d-wave nonsense was involved in the confusion.</div><br/></div></div></div></div></div></div><div id="36672510" class="c"><input type="checkbox" id="c-36672510" checked=""/><div class="controls bullet"><span class="by">capableweb</span><span>|</span><a href="#36672750">prev</a><span>|</span><a href="#36676091">next</a><span>|</span><label class="collapse" for="c-36672510">[-]</label><label class="expand" for="c-36672510">[22 more]</label></div><br/><div class="children"><div class="content">Unless you&#x27;re worried about storing and&#x2F;or transmitting a huge amount of keys (in the order of &quot;at least 100&#x2F;second&quot;) and&#x2F;or using one key &quot;at least 100 times&#x2F;second&quot;, why not just go for 4096 by default?</div><br/><div id="36675308" class="c"><input type="checkbox" id="c-36675308" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#36672510">parent</a><span>|</span><a href="#36673067">next</a><span>|</span><label class="collapse" for="c-36675308">[-]</label><label class="expand" for="c-36675308">[3 more]</label></div><br/><div class="children"><div class="content">Because 4096 bit RSA is a lot slower and bigger and those things matter.  And there isn&#x27;t any upside?  If you&#x27;re actually worried about 2048-bit RSA (and you should not be), you should switch to one of the elliptic curve schemes.</div><br/><div id="36676313" class="c"><input type="checkbox" id="c-36676313" checked=""/><div class="controls bullet"><span class="by">Grimburger</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36675308">parent</a><span>|</span><a href="#36676008">next</a><span>|</span><label class="collapse" for="c-36676313">[-]</label><label class="expand" for="c-36676313">[1 more]</label></div><br/><div class="children"><div class="content">All other things equal, 256-bit elliptical curve cryptography is going to break before RSA2048 does with quantum computing advances.<p>Do NOT switch to ECC if your threat model includes a quantum computer arriving.<p>Either use larger RSA keys or more appropriately a hybrid signature scheme combining one of NIST&#x27;s PQC signatures and a traditional algorithm.<p><a href="https:&#x2F;&#x2F;csrc.nist.gov&#x2F;Projects&#x2F;post-quantum-cryptography&#x2F;selected-algorithms-2022" rel="nofollow noreferrer">https:&#x2F;&#x2F;csrc.nist.gov&#x2F;Projects&#x2F;post-quantum-cryptography&#x2F;sel...</a></div><br/></div></div><div id="36676008" class="c"><input type="checkbox" id="c-36676008" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36675308">parent</a><span>|</span><a href="#36676313">prev</a><span>|</span><a href="#36673067">next</a><span>|</span><label class="collapse" for="c-36676008">[-]</label><label class="expand" for="c-36676008">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not actually sure about this. the elliptic curve schemes are just as broken with quantum computers, and the larger key size of rsa seems like it might add a few years of overhead in terms of qbits needed. not an expert though</div><br/></div></div></div></div><div id="36673067" class="c"><input type="checkbox" id="c-36673067" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#36672510">parent</a><span>|</span><a href="#36675308">prev</a><span>|</span><a href="#36672549">next</a><span>|</span><label class="collapse" for="c-36673067">[-]</label><label class="expand" for="c-36673067">[1 more]</label></div><br/><div class="children"><div class="content">Because that will soon become &quot;why not 128k&quot;. Or perhaps we should use 2 megabytes for each prime? We don&#x27;t know, but it&#x27;s better to be safe than sorry.</div><br/></div></div><div id="36672549" class="c"><input type="checkbox" id="c-36672549" checked=""/><div class="controls bullet"><span class="by">upofadown</span><span>|</span><a href="#36672510">parent</a><span>|</span><a href="#36673067">prev</a><span>|</span><a href="#36676091">next</a><span>|</span><label class="collapse" for="c-36672549">[-]</label><label class="expand" for="c-36672549">[17 more]</label></div><br/><div class="children"><div class="content">If you accept the current assumptions, then you would have to accept that 4096 bit RSA will be obsolete by 2060.</div><br/><div id="36672702" class="c"><input type="checkbox" id="c-36672702" checked=""/><div class="controls bullet"><span class="by">thewataccount</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36672549">parent</a><span>|</span><a href="#36672739">next</a><span>|</span><label class="collapse" for="c-36672702">[-]</label><label class="expand" for="c-36672702">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a significant amount of time if we&#x27;re talking about long-term file storage.<p>I&#x27;ve had my dropbox account for over 10 years now. Being concerned about a timescale of 20 to 30 years seems reasonable for things like long term file storage IMO.<p>Backblaze, dropbox, google drive, onedrive, AWS are all over a decade old.</div><br/><div id="36677559" class="c"><input type="checkbox" id="c-36677559" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36672702">parent</a><span>|</span><a href="#36672739">next</a><span>|</span><label class="collapse" for="c-36677559">[-]</label><label class="expand" for="c-36677559">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>That&#x27;s a significant amount of time</i><p>Depends on the threat model. I mean, WireGuard and Signal rotate derived keys every 2mins!</div><br/></div></div></div></div><div id="36672739" class="c"><input type="checkbox" id="c-36672739" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36672549">parent</a><span>|</span><a href="#36672702">prev</a><span>|</span><a href="#36672996">next</a><span>|</span><label class="collapse" for="c-36672739">[-]</label><label class="expand" for="c-36672739">[10 more]</label></div><br/><div class="children"><div class="content">So only 37 years? I think I can live with that.</div><br/><div id="36673083" class="c"><input type="checkbox" id="c-36673083" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36672739">parent</a><span>|</span><a href="#36672996">next</a><span>|</span><label class="collapse" for="c-36673083">[-]</label><label class="expand" for="c-36673083">[9 more]</label></div><br/><div class="children"><div class="content">It depends on what you are transmitting, right?<p>Hypothetically if you are a journalist working with communications from a source in an authoritarian country (or a country that could become authoritarian in the next 4 decades; and name one that couldnât, right?) it would be no good if you got some elderly person killed in the future.<p>Or just like bank account details I guess?</div><br/><div id="36673828" class="c"><input type="checkbox" id="c-36673828" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36673083">parent</a><span>|</span><a href="#36674839">next</a><span>|</span><label class="collapse" for="c-36673828">[-]</label><label class="expand" for="c-36673828">[4 more]</label></div><br/><div class="children"><div class="content">No cryptographic scheme remains unbreakable forever. If what you want is permanent protection, cryptography is not the solution. If people are encrypting things expecting that encryption will never be broken, they&#x27;re misusing encryption.<p>The point of cryptography isn&#x27;t to keep secrets forever, it&#x27;s to keep secrets for long enough that by the time those secrets are revealed, they are worthless.</div><br/><div id="36677802" class="c"><input type="checkbox" id="c-36677802" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36673828">parent</a><span>|</span><a href="#36674619">next</a><span>|</span><label class="collapse" for="c-36677802">[-]</label><label class="expand" for="c-36677802">[1 more]</label></div><br/><div class="children"><div class="content">&gt; No cryptographic scheme remains unbreakable forever. If what you want is permanent protection, cryptography is not the solution.<p>Whilst this has historically been true, it&#x27;s very plausible that AES-256 means that (for this limited problem, symmetric encryption) we&#x27;re done.<p>The &quot;obvious&quot; attack (some type of brute force) on AES-256, even assuming you have a quantum computer (which we don&#x27;t) and it&#x27;s actually <i>more</i> affordable than our current computers (which it won&#x27;t be) is not practical in our universe.</div><br/></div></div><div id="36674619" class="c"><input type="checkbox" id="c-36674619" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36673828">parent</a><span>|</span><a href="#36677802">prev</a><span>|</span><a href="#36675245">next</a><span>|</span><label class="collapse" for="c-36674619">[-]</label><label class="expand" for="c-36674619">[1 more]</label></div><br/><div class="children"><div class="content">I think this is a topic that much cleverer people than me have thought long and hard on. Of course nothing practical remains unbreakable forever, but it seems weird that for example the default key size for ssh-keygen isnât in the âprobably two lifetimesâ range.</div><br/></div></div></div></div><div id="36674839" class="c"><input type="checkbox" id="c-36674839" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36673083">parent</a><span>|</span><a href="#36673828">prev</a><span>|</span><a href="#36673557">next</a><span>|</span><label class="collapse" for="c-36674839">[-]</label><label class="expand" for="c-36674839">[1 more]</label></div><br/><div class="children"><div class="content">I can tell you that journalists aren&#x27;t worrying about that most of the time. It&#x27;s very much outside their threat model in the majority of cases, as it should be - there&#x27;s no way to feasibly predict and protect against cryptographic risks 30+ years from now.</div><br/></div></div><div id="36673557" class="c"><input type="checkbox" id="c-36673557" checked=""/><div class="controls bullet"><span class="by">trilobyte</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36673083">parent</a><span>|</span><a href="#36674839">prev</a><span>|</span><a href="#36673351">next</a><span>|</span><label class="collapse" for="c-36673557">[-]</label><label class="expand" for="c-36673557">[1 more]</label></div><br/><div class="children"><div class="content">In that case the volume of traffic such a communication medium would need to handle is likely small enough that you can bump the key size higher to ensure greater longevity, currently past the lifetimes of those involved, and accept that transmitting data will take a small fraction of time longer.</div><br/></div></div><div id="36673351" class="c"><input type="checkbox" id="c-36673351" checked=""/><div class="controls bullet"><span class="by">supertrope</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36673083">parent</a><span>|</span><a href="#36673557">prev</a><span>|</span><a href="#36672996">next</a><span>|</span><label class="collapse" for="c-36673351">[-]</label><label class="expand" for="c-36673351">[2 more]</label></div><br/><div class="children"><div class="content">If extreme security is needed itâs time to turn off your computer, leave your cellphone at home, donât tell details to colleagues who do not have a need to know, and maybe resort to dead drop methods so even you donât know who the source is yourself.</div><br/><div id="36673497" class="c"><input type="checkbox" id="c-36673497" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36673351">parent</a><span>|</span><a href="#36672996">next</a><span>|</span><label class="collapse" for="c-36673497">[-]</label><label class="expand" for="c-36673497">[1 more]</label></div><br/><div class="children"><div class="content">Some people are willing to take a on some extra risk to talk to journalists, and the world is a better place for their bravery.<p>And weâre talking about thousands of bits, we spend way more than that on stupid things like making UI slightly prettier. Iâm streaming music at, I guess, ~200kbps, why not spend a couple seconds worth of music on keys? (Who knows, maybe it will protect some famous journalist somehow and weâll end up ahead when it spares us a whole moment of silence).<p>Edit: TBH Iâm not really sure this is a useful way to look at things, but the music bandwidth&#x2F;moment of silence parallel was too convenient to pass up.</div><br/></div></div></div></div></div></div></div></div><div id="36672996" class="c"><input type="checkbox" id="c-36672996" checked=""/><div class="controls bullet"><span class="by">devmor</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36672549">parent</a><span>|</span><a href="#36672739">prev</a><span>|</span><a href="#36676091">next</a><span>|</span><label class="collapse" for="c-36672996">[-]</label><label class="expand" for="c-36672996">[4 more]</label></div><br/><div class="children"><div class="content">I would hope that someone invents a more robust cryptography protocol in the next 37 years.</div><br/><div id="36673116" class="c"><input type="checkbox" id="c-36673116" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36672996">parent</a><span>|</span><a href="#36675179">next</a><span>|</span><label class="collapse" for="c-36673116">[-]</label><label class="expand" for="c-36673116">[1 more]</label></div><br/><div class="children"><div class="content">A bit less, since you have to worry about an attacker storing anything you do now for future attacks.<p>But if you only want any given secret to stay save for 20 years, you can still use 4096 bit RSA for another 17 years. Which sounds like a good tradeoff: enough of time for better algorithms to get established, but little risk of a breach you will care about.</div><br/></div></div><div id="36675179" class="c"><input type="checkbox" id="c-36675179" checked=""/><div class="controls bullet"><span class="by">capableweb</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36672996">parent</a><span>|</span><a href="#36673116">prev</a><span>|</span><a href="#36676091">next</a><span>|</span><label class="collapse" for="c-36675179">[-]</label><label class="expand" for="c-36675179">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t RSA from like the 80s? That would already make it ~40 years old.</div><br/><div id="36675377" class="c"><input type="checkbox" id="c-36675377" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#36672510">root</a><span>|</span><a href="#36675179">parent</a><span>|</span><a href="#36676091">next</a><span>|</span><label class="collapse" for="c-36675377">[-]</label><label class="expand" for="c-36675377">[1 more]</label></div><br/><div class="children"><div class="content">Being pedantic: RSA is a cryptosystem, not a protocol, and the parameters that were used in 1980s RSA encryption look nothing like the parameters used in today&#x27;s RSA (in part because they&#x27;re much larger now, but also in part because we now know about all the weird things that happen when you choose non-standard exponents, primes that are too close to each other, etc.).<p>RSA is also not typically described as robust, for those reasons.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36676091" class="c"><input type="checkbox" id="c-36676091" checked=""/><div class="controls bullet"><span class="by">Tempest1981</span><span>|</span><a href="#36672510">prev</a><span>|</span><a href="#36672362">next</a><span>|</span><label class="collapse" for="c-36676091">[-]</label><label class="expand" for="c-36676091">[2 more]</label></div><br/><div class="children"><div class="content">No concern about &quot;store now, decrypt later&quot;?<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Harvest_now,_decrypt_later" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Harvest_now,_decrypt_later</a></div><br/><div id="36676482" class="c"><input type="checkbox" id="c-36676482" checked=""/><div class="controls bullet"><span class="by">I_am_tiberius</span><span>|</span><a href="#36676091">parent</a><span>|</span><a href="#36672362">next</a><span>|</span><label class="collapse" for="c-36676482">[-]</label><label class="expand" for="c-36676482">[1 more]</label></div><br/><div class="children"><div class="content">I always thought discussions about encryption forget about this topic. Encrypted data today is only hidden today, not in the future. So any darknet criminal should consider that files he&#x2F;she sends are being intercepted and readable in 30 years.</div><br/></div></div></div></div><div id="36672362" class="c"><input type="checkbox" id="c-36672362" checked=""/><div class="controls bullet"><span class="by">slater</span><span>|</span><a href="#36676091">prev</a><span>|</span><a href="#36672357">next</a><span>|</span><label class="collapse" for="c-36672362">[-]</label><label class="expand" for="c-36672362">[2 more]</label></div><br/><div class="children"><div class="content">Server appears to be hugged, web archive link:<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230710195916&#x2F;https:&#x2F;&#x2F;articles.59.ca&#x2F;doku.php?id=em:20482030" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230710195916&#x2F;https:&#x2F;&#x2F;articles....</a></div><br/><div id="36677571" class="c"><input type="checkbox" id="c-36677571" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#36672362">parent</a><span>|</span><a href="#36672357">next</a><span>|</span><label class="collapse" for="c-36677571">[-]</label><label class="expand" for="c-36677571">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;archive.is&#x2F;VaLO8" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.is&#x2F;VaLO8</a></div><br/></div></div></div></div><div id="36672357" class="c"><input type="checkbox" id="c-36672357" checked=""/><div class="controls bullet"><span class="by">roomey</span><span>|</span><a href="#36672362">prev</a><span>|</span><a href="#36678167">next</a><span>|</span><label class="collapse" for="c-36672357">[-]</label><label class="expand" for="c-36672357">[11 more]</label></div><br/><div class="children"><div class="content">I think the point is as computers get faster there is less trade off in having longer bit lengths, rather than focusing on the potential to crack sad keys.<p>That is, if it costs very little to have larger keys, why not have larger keys?<p>It is essentially hedging your bets as even if quantum computing key factorisation works, key lengths will still have an impact on the difficulty of factorisation, and it may make a difference in terms of practicality.</div><br/><div id="36672575" class="c"><input type="checkbox" id="c-36672575" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36672357">parent</a><span>|</span><a href="#36672536">next</a><span>|</span><label class="collapse" for="c-36672575">[-]</label><label class="expand" for="c-36672575">[5 more]</label></div><br/><div class="children"><div class="content">&gt; even if quantum computing key factorisation works, key lengths will still have an impact on the difficulty of factorisation, and it may make a difference in terms of practicality.<p>I mean, the whole thing with quantum computer factoring is it scales well. Getting to 2048 rsa seems really really difficult. But if we ever get there, getting to 4096 is probably just a tiny extra step.</div><br/><div id="36672700" class="c"><input type="checkbox" id="c-36672700" checked=""/><div class="controls bullet"><span class="by">alphager</span><span>|</span><a href="#36672357">root</a><span>|</span><a href="#36672575">parent</a><span>|</span><a href="#36672536">next</a><span>|</span><label class="collapse" for="c-36672700">[-]</label><label class="expand" for="c-36672700">[4 more]</label></div><br/><div class="children"><div class="content">The current state of quantum computing suggests that there is an exponential effort to increase the available qbits. Going from RSA 2048 to RSA 4096 would not just double the effort required on the quantum side.</div><br/><div id="36672827" class="c"><input type="checkbox" id="c-36672827" checked=""/><div class="controls bullet"><span class="by">upofadown</span><span>|</span><a href="#36672357">root</a><span>|</span><a href="#36672700">parent</a><span>|</span><a href="#36672536">next</a><span>|</span><label class="collapse" for="c-36672827">[-]</label><label class="expand" for="c-36672827">[3 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t that effectively prevent a threat to 2048 bit RSA in the first place?</div><br/><div id="36673936" class="c"><input type="checkbox" id="c-36673936" checked=""/><div class="controls bullet"><span class="by">ihattendorf</span><span>|</span><a href="#36672357">root</a><span>|</span><a href="#36672827">parent</a><span>|</span><a href="#36672536">next</a><span>|</span><label class="collapse" for="c-36673936">[-]</label><label class="expand" for="c-36673936">[2 more]</label></div><br/><div class="children"><div class="content">Almost like there&#x27;s no free lunch. I don&#x27;t see quantum computing ever really taking off without a fundamental breakthrough in our understanding of physics.<p>Would love to be proven wrong though if my understanding is incorrect and there&#x27;s actually a feasible path towards quantum computing at scale.</div><br/><div id="36674150" class="c"><input type="checkbox" id="c-36674150" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36672357">root</a><span>|</span><a href="#36673936">parent</a><span>|</span><a href="#36672536">next</a><span>|</span><label class="collapse" for="c-36674150">[-]</label><label class="expand" for="c-36674150">[1 more]</label></div><br/><div class="children"><div class="content">I dont think there is any fundamental physics reasons preventing quantum computers. My understanding is it is an engineering problem. A hard one no doubt, but not a fundamental physics one.<p>Anyways, my point was that getting a quantum computer at a decent scale is really difficult. If we manage to overcome that burden somehow, the difference between 2048 bit rsa abd 4096 bit is peanuts.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36672536" class="c"><input type="checkbox" id="c-36672536" checked=""/><div class="controls bullet"><span class="by">hujun</span><span>|</span><a href="#36672357">parent</a><span>|</span><a href="#36672575">prev</a><span>|</span><a href="#36672529">next</a><span>|</span><label class="collapse" for="c-36672536">[-]</label><label class="expand" for="c-36672536">[4 more]</label></div><br/><div class="children"><div class="content">`That is, if it costs very little to have larger keys, why not have larger keys?`
it is often very expensive&#x2F;difficult to change length of a RSA key is part of existing platform&#x2F;infrastructure, like key in TPM&#x2F;HSM&#x2F;CA infrastructure, regardless how fast computer CPU is</div><br/><div id="36673544" class="c"><input type="checkbox" id="c-36673544" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36672357">root</a><span>|</span><a href="#36672536">parent</a><span>|</span><a href="#36672529">next</a><span>|</span><label class="collapse" for="c-36673544">[-]</label><label class="expand" for="c-36673544">[3 more]</label></div><br/><div class="children"><div class="content">But RSA has been long time going out, and short-keyed RSA doubly so. I would estimate that since maybe 2015ish deploying stuff that is coupled to 2048bit RSA would have been mistake. That gives generous 15ish year transition period. Anyone who cares even the slightest should succeed transition in that sort of timeframe.</div><br/><div id="36674029" class="c"><input type="checkbox" id="c-36674029" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36672357">root</a><span>|</span><a href="#36673544">parent</a><span>|</span><a href="#36672529">next</a><span>|</span><label class="collapse" for="c-36674029">[-]</label><label class="expand" for="c-36674029">[2 more]</label></div><br/><div class="children"><div class="content">Why would deploying 2048 bit RSA be a mistake? If you believe 2048 is threatened in a meaningful time frame, when 1024 hasn&#x27;t even been broken (thus sort of implying that the collapse of 2048 will occur in a much shorter time frame than the one separating 512 and 1024), is there any realistic RSA key size that should make you comfortable?</div><br/><div id="36676078" class="c"><input type="checkbox" id="c-36676078" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#36672357">root</a><span>|</span><a href="#36674029">parent</a><span>|</span><a href="#36672529">next</a><span>|</span><label class="collapse" for="c-36676078">[-]</label><label class="expand" for="c-36676078">[1 more]</label></div><br/><div class="children"><div class="content">3 reasons<p>1. it&#x27;s reasonable to assume the NSA is a decade ahead and has more computers than academia.<p>2. you want your secrets to last a decade (or longer)<p>3. the total amount of data you&#x27;re encrypting per client is only 256 bits anyway (the size of a symmetric key) so the absolute performance impact is relatively minimal</div><br/></div></div></div></div></div></div></div></div><div id="36672529" class="c"><input type="checkbox" id="c-36672529" checked=""/><div class="controls bullet"><span class="by">nailer</span><span>|</span><a href="#36672357">parent</a><span>|</span><a href="#36672536">prev</a><span>|</span><a href="#36678167">next</a><span>|</span><label class="collapse" for="c-36672529">[-]</label><label class="expand" for="c-36672529">[1 more]</label></div><br/><div class="children"><div class="content">They cover that in the article:<p>&gt; Quantum computing of the sort intended to break RSA involves a breakthrough in both computing and algorithms. Normally some sort of new computing technology is invented and then algorithms are designed to enable that technology to do something useful. The quantum computing threat to RSA is different. We now have the algorithm (Shor&#x27;s) but the computer to run it on only exists in our imagination.<p>&gt; If someone were to invent such a computer then RSA 2048 would be immediately and trivially breakable. RSA 3072 would also be trivially breakable. The same applies to RSA 4096 and 8192.</div><br/></div></div></div></div><div id="36678167" class="c"><input type="checkbox" id="c-36678167" checked=""/><div class="controls bullet"><span class="by">unnouinceput</span><span>|</span><a href="#36672357">prev</a><span>|</span><a href="#36673252">next</a><span>|</span><label class="collapse" for="c-36678167">[-]</label><label class="expand" for="c-36678167">[1 more]</label></div><br/><div class="children"><div class="content">Quote: &quot;There seems to be no rational reason to increase RSA key sizes past 2048 starting in the year 2030. We don&#x27;t have any reason to increase RSA key sizes at any time based on our current understanding.&quot;<p>Yeahhhh, nice try NSA. If they say this, I&#x27;d say go to 8192 right now.</div><br/></div></div><div id="36673252" class="c"><input type="checkbox" id="c-36673252" checked=""/><div class="controls bullet"><span class="by">jbarrs</span><span>|</span><a href="#36678167">prev</a><span>|</span><a href="#36673190">next</a><span>|</span><label class="collapse" for="c-36673252">[-]</label><label class="expand" for="c-36673252">[2 more]</label></div><br/><div class="children"><div class="content">I find it amusing that the table published a conservative cutoff year and an optimistic cutoff year. Based on the trends I&#x27;ve seen, most non-critical software would probably have made the switch in time for the conservative year, whereas anything security-critical like a bank would probably use the optimistic year.</div><br/><div id="36673333" class="c"><input type="checkbox" id="c-36673333" checked=""/><div class="controls bullet"><span class="by">upofadown</span><span>|</span><a href="#36673252">parent</a><span>|</span><a href="#36673190">next</a><span>|</span><label class="collapse" for="c-36673333">[-]</label><label class="expand" for="c-36673333">[1 more]</label></div><br/><div class="children"><div class="content">The author of the paper had a problem. His elliptic curve method seemed like it might overtake the best known algorithm at the time for factoring. So the conservative estimate takes that into account. The elliptic curve method never managed supremacy so the optimistic estimate is actually more relevant. That means that the actual prediction is 2040 but it seems the various national cybersecurity entities might of missed that point.</div><br/></div></div></div></div><div id="36673190" class="c"><input type="checkbox" id="c-36673190" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#36673252">prev</a><span>|</span><a href="#36676162">next</a><span>|</span><label class="collapse" for="c-36673190">[-]</label><label class="expand" for="c-36673190">[3 more]</label></div><br/><div class="children"><div class="content">For Symmetric encryption, it says: &#x27;Current key size: 112 bits&#x27;<p>However the 3 linked examples, AES, ChaCha20 and Camellia all use a key size of at least 128 bits, with 192 or 256 bits also listed as options.<p>What does this current NIST key size recommendation (effective as of 2019) of 112 mean then? Does anyone use this size?</div><br/><div id="36673347" class="c"><input type="checkbox" id="c-36673347" checked=""/><div class="controls bullet"><span class="by">upofadown</span><span>|</span><a href="#36673190">parent</a><span>|</span><a href="#36673316">next</a><span>|</span><label class="collapse" for="c-36673347">[-]</label><label class="expand" for="c-36673347">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty much for 3DES, which is disliked for other reasons. The point still stands though...</div><br/></div></div><div id="36673316" class="c"><input type="checkbox" id="c-36673316" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#36673190">parent</a><span>|</span><a href="#36673347">prev</a><span>|</span><a href="#36676162">next</a><span>|</span><label class="collapse" for="c-36673316">[-]</label><label class="expand" for="c-36673316">[1 more]</label></div><br/><div class="children"><div class="content">112 bit effective key size almost certainly refers to 3des</div><br/></div></div></div></div><div id="36676162" class="c"><input type="checkbox" id="c-36676162" checked=""/><div class="controls bullet"><span class="by">cat_plus_plus</span><span>|</span><a href="#36673190">prev</a><span>|</span><a href="#36672915">next</a><span>|</span><label class="collapse" for="c-36676162">[-]</label><label class="expand" for="c-36676162">[1 more]</label></div><br/><div class="children"><div class="content">This ignores potential current unpublished advances by entities like NSA and potential unforeseen future algorithmic and computing power advances. Logically speaking, larger keys could help and are unlikely to hurt with both. Even if larger key still ends up breakable, adversaries may still go for low hanging fruit.<p>Other than that, it depends on secrecy timeline and cost&#x2F;performance sensitivity. An average credit card transaction is unlikely to be targeted by NSA or archived in hopes of cracking it 30 years later, and on the other hand volume is very high and latency is important. So use whatever is thought to not be breakable now and upgrade keys if and when technology progresses. On the other hand, list of American spies in Russia would not take more than a few minutes to decrypt even with enormous key sizes and on the other hand disclosure could cause real damage even decades later. Might as well overshoot even if there is no known reason as of yet.</div><br/></div></div><div id="36672915" class="c"><input type="checkbox" id="c-36672915" checked=""/><div class="controls bullet"><span class="by">thomashabets2</span><span>|</span><a href="#36676162">prev</a><span>|</span><a href="#36672613">next</a><span>|</span><label class="collapse" for="c-36672915">[-]</label><label class="expand" for="c-36672915">[1 more]</label></div><br/><div class="children"><div class="content">I use gpg plus kyber (quantum resistant). RSA may break, and kyber might suck. But I&#x27;m hoping not both.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ThomasHabets&#x2F;kybertest">https:&#x2F;&#x2F;github.com&#x2F;ThomasHabets&#x2F;kybertest</a></div><br/></div></div><div id="36672613" class="c"><input type="checkbox" id="c-36672613" checked=""/><div class="controls bullet"><span class="by">throw0101a</span><span>|</span><a href="#36672915">prev</a><span>|</span><a href="#36674256">next</a><span>|</span><label class="collapse" for="c-36672613">[-]</label><label class="expand" for="c-36672613">[3 more]</label></div><br/><div class="children"><div class="content">Recommendations from various organizations can be found at:<p>* <a href="https:&#x2F;&#x2F;www.keylength.com" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.keylength.com</a><p>Anything recent (â¥2016) seems to say 3072 for RSA.</div><br/><div id="36672883" class="c"><input type="checkbox" id="c-36672883" checked=""/><div class="controls bullet"><span class="by">q845712</span><span>|</span><a href="#36672613">parent</a><span>|</span><a href="#36674256">next</a><span>|</span><label class="collapse" for="c-36672883">[-]</label><label class="expand" for="c-36672883">[2 more]</label></div><br/><div class="children"><div class="content">I have no specialist knowledge in this subfield, but after reading the article&#x27;s arguments that basically if you could sic the entire bitcoin network on 2048 RSA it would take 700+ years,  I have to wonder about perverse incentives.<p>Another thing that&#x27;s missing is the lifetime expectancy,  e.g. &quot;for how many years does something encrypted in 2030 need to be unbreakable?&quot;<p>The author doesn&#x27;t seem to be a big authority, so has little to lose by staking their reputation on &quot;you don&#x27;t need it to be that good,&quot; whereas by the very nature of their authority, anyone in the resource you link is going to be motivated to never be wrong under any circumstances.  So if someone with some reputation&#x2F;authority&#x2F;power to lose think there&#x27;s a 0.001% chance that some new incremental improvements will allow for fast-enough breaking of 2048 bit encryption created in 2030 within a window where that would be unacceptable,  then they&#x27;re motivated to guess high.   The authority in this case doesn&#x27;t directly bear the costs of too high of a guess, whereas it could be very bad for, i dunno, some country&#x27;s government, and by extension the org or people that made that country&#x27;s standards recommendations, if some classified information became public 15 or 50 years earlier than intended just because it could be decrypted.</div><br/><div id="36673217" class="c"><input type="checkbox" id="c-36673217" checked=""/><div class="controls bullet"><span class="by">traceddd</span><span>|</span><a href="#36672613">root</a><span>|</span><a href="#36672883">parent</a><span>|</span><a href="#36674256">next</a><span>|</span><label class="collapse" for="c-36673217">[-]</label><label class="expand" for="c-36673217">[1 more]</label></div><br/><div class="children"><div class="content">I assume youâre aware, but for clarity: itâs not possible to sic the bitcoin network on anything, even cracking sha256, which it uses internally, due to hard-coded ASICs that incorporate specific quirks of the proof-of-work.</div><br/></div></div></div></div></div></div><div id="36674256" class="c"><input type="checkbox" id="c-36674256" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#36672613">prev</a><span>|</span><a href="#36672583">next</a><span>|</span><label class="collapse" for="c-36674256">[-]</label><label class="expand" for="c-36674256">[3 more]</label></div><br/><div class="children"><div class="content">One thing this paper ignores is side channel attacks. Those may involve hardware or software vulnerabilities, or they may be inherent to the process itself.<p>So the real bogeyman is not whether we have figured out how to factor large numbers yet (aside from Shor and the as of now mythical quantum computer), but how much information you might leak by using your key.<p>One (generally) overlooked idea might be, some sort of vulnerability between they key and the data being used. E.g., by multiplying many, many smaller numbers with the private key, is it possible to increase the efficiency of the sieve.<p>Then it might be the case that commonly used keys are more vulnerable and keys used less are less vulnerable.<p>Another idea would be a rainbow table of keys. It might not matter so much that you can arbitrarily factor a large number, if generating keys is fast. Especially when you mount attacks on the random number generators involved, you can reduce the search spaces.<p>Forcing the key itself is not so much the concern, this doesn&#x27;t make me think &quot;oh we are fine&quot;.<p>Historically we only have to look back to e.g. Heartbleed to be reminded that we broke ssl not by factoring primes, but by exploiting the many flaws in the protocol itself.</div><br/><div id="36675223" class="c"><input type="checkbox" id="c-36675223" checked=""/><div class="controls bullet"><span class="by">capableweb</span><span>|</span><a href="#36674256">parent</a><span>|</span><a href="#36672583">next</a><span>|</span><label class="collapse" for="c-36675223">[-]</label><label class="expand" for="c-36675223">[2 more]</label></div><br/><div class="children"><div class="content">&gt; One thing this paper ignores is side channel attacks.<p>I mean, that&#x27;s fair right? The article doesn&#x27;t talk about encryption in general but tries to answer &quot;How secure is RSA?&quot; or rather &quot;When is&#x2F;will N bit RSA be considered insecure?&quot;, so scoping it to only talk about that seems fair.<p>Of course, one could only focus their attention on so many things. Misuse, misconfiguration, side channel attacks and etc become unrelated to the topic at hand in this case.</div><br/><div id="36675637" class="c"><input type="checkbox" id="c-36675637" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#36674256">root</a><span>|</span><a href="#36675223">parent</a><span>|</span><a href="#36672583">next</a><span>|</span><label class="collapse" for="c-36675637">[-]</label><label class="expand" for="c-36675637">[1 more]</label></div><br/><div class="children"><div class="content">Possibly?<p>My point was essentially that key-length could have unintended side-effects.<p>E.g. if you were to have some rainbow table approach, e.g. in theory larger key size would mean more possible key combinations, meaning more expensive space complexity, and harder-to-crack keys. Factoring a key is not necessary if you already know the factors, a hashtable has O(log(N)) complexity. If you implement some custom FPGA hardware and a nice database its not too difficult to imagine some specialized operation storing off generated public keys to their corresponding private key pairs, and the power costs are rather low.<p>Of course due to combinatorics the size of this output space is rather large, despite the fact that the distribution of primes shrinks as they grow larger, but the argument is about factoring a single number, not about efficiently computing primes and their common multiples. Counter to the article, it completely obviates the need to hide your power bill, as you can cache every single computation from the past 30+ years...<p>To bring it back to what I was saying, the difficulty of brute-forcing RSA (or other schemes) is potentially irrelevant to the cost of obtaining a solution, and higher bit-length key-pairs offer some hedge against that possibility. It seems pretty relevant to the question &quot;how secure is RSA&quot; to me.</div><br/></div></div></div></div></div></div><div id="36672583" class="c"><input type="checkbox" id="c-36672583" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36674256">prev</a><span>|</span><a href="#36676039">next</a><span>|</span><label class="collapse" for="c-36672583">[-]</label><label class="expand" for="c-36672583">[17 more]</label></div><br/><div class="children"><div class="content">Iâm not a cryptographer, but I can see many more pressing reasons for migrating off RSA before 2030. Is there any reason to pick RSA for greenfield today?<p>RSA, to my knowledge, is vulnerable to side channels and poor parameter choices. Implementation simplicity is an underrated security parameter. The fewer feet you have, the fewer of them you can shoot.<p>The NSA data centers donât want to waste time on your RSA key anyway, much less your run-of-the-mill Russian black hat groups. What bites us in practice are 0-days of something stupid like heartbleed or rowhammer that can be automated, and takes a long time to patch.</div><br/><div id="36672920" class="c"><input type="checkbox" id="c-36672920" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#36672583">parent</a><span>|</span><a href="#36672669">next</a><span>|</span><label class="collapse" for="c-36672920">[-]</label><label class="expand" for="c-36672920">[2 more]</label></div><br/><div class="children"><div class="content">This is my (applied) cryptographic understanding as well: RSA 2048 probably won&#x27;t be broken by improvements to prime factorization by 2030, but will <i>continue to be</i> a pointlessly dangerous (and slow) cryptosystem when compared to ECC.</div><br/><div id="36673192" class="c"><input type="checkbox" id="c-36673192" checked=""/><div class="controls bullet"><span class="by">AnotherGoodName</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36672920">parent</a><span>|</span><a href="#36672669">next</a><span>|</span><label class="collapse" for="c-36673192">[-]</label><label class="expand" for="c-36673192">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced on the first part. That it won&#x27;t be broken by improvements to prime factorization.<p><a href="https:&#x2F;&#x2F;www.ams.org&#x2F;notices&#x2F;199612&#x2F;pomerance.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ams.org&#x2F;notices&#x2F;199612&#x2F;pomerance.pdf</a> has a great writeup on the history of the work around this. Essentially when you see improvements in complexity of the form<p>Old best: Quadratic Sieve: exp(c(log n)^1&#x2F;2(log log n)^1&#x2F;2)<p>New best: General Number field sieve: exp(c(log n)^1&#x2F;3(log log n)^2&#x2F;3)<p>I can&#x27;t help but feel that&#x27;s an exponent there that we&#x27;ve moved to 1&#x2F;3 that could be moved further. Sure we don&#x27;t know how and we&#x27;ve been stuck here on the current best for just over 25 years but i just feel that if you give me two methods and one moves a term like that there&#x27;s a good chance there&#x27;s a way to reduce that term further. It&#x27;d be weird for that complexity statement to stay as is. That&#x27;s telling me &quot;the universe doesn&#x27;t allow factorization any faster than a term that&#x27;s raised to a power of 1&#x2F;3rd&quot; and i&#x27;m asking &quot;why is 1&#x2F;3 so special?&quot;. So i&#x27;m not convinced that there&#x27;s not more here. I don&#x27;t have a clue how of course. But the history of RSA going &quot;256bits is secure&quot; to 512bits to 1024bits to 2048bits being needed has me worried about the safety of prime factorization.</div><br/></div></div></div></div><div id="36672669" class="c"><input type="checkbox" id="c-36672669" checked=""/><div class="controls bullet"><span class="by">forgotmypw17</span><span>|</span><a href="#36672583">parent</a><span>|</span><a href="#36672920">prev</a><span>|</span><a href="#36674191">next</a><span>|</span><label class="collapse" for="c-36672669">[-]</label><label class="expand" for="c-36672669">[8 more]</label></div><br/><div class="children"><div class="content">Top reason to use RSA for me, as with most tech I use, is its longevity.<p>Lindy Effect has been the best predictor of what will still work in five years.</div><br/><div id="36673771" class="c"><input type="checkbox" id="c-36673771" checked=""/><div class="controls bullet"><span class="by">HappyPanacea</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36672669">parent</a><span>|</span><a href="#36673552">next</a><span>|</span><label class="collapse" for="c-36673771">[-]</label><label class="expand" for="c-36673771">[1 more]</label></div><br/><div class="children"><div class="content">McEliece encryption algorithm was published in 1978 (one year later than RSA) and seems to be considered safe to classical and quantum computers, the only downside is the huge public key size.</div><br/></div></div><div id="36673552" class="c"><input type="checkbox" id="c-36673552" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36672669">parent</a><span>|</span><a href="#36673771">prev</a><span>|</span><a href="#36672976">next</a><span>|</span><label class="collapse" for="c-36673552">[-]</label><label class="expand" for="c-36673552">[1 more]</label></div><br/><div class="children"><div class="content">The Lindy effect applies to non-perishables. There are alternatives which are much more likely to conform to a reasonable equivalency of non-perishable for cryptography. Per this article, RSA strongly does not fit reasonable equivalent definitions.</div><br/></div></div><div id="36672976" class="c"><input type="checkbox" id="c-36672976" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36672669">parent</a><span>|</span><a href="#36673552">prev</a><span>|</span><a href="#36674191">next</a><span>|</span><label class="collapse" for="c-36672976">[-]</label><label class="expand" for="c-36672976">[5 more]</label></div><br/><div class="children"><div class="content">The fact that the sun rose today, has no effect on whether the sun will rise tomorrow.</div><br/><div id="36673203" class="c"><input type="checkbox" id="c-36673203" checked=""/><div class="controls bullet"><span class="by">Strom</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36672976">parent</a><span>|</span><a href="#36674592">next</a><span>|</span><label class="collapse" for="c-36673203">[-]</label><label class="expand" for="c-36673203">[3 more]</label></div><br/><div class="children"><div class="content">And yet I doubt you would be willing to bet against the sun rising tomorrow.<p>Our understanding is based on imperfect models, sure. That doesn&#x27;t matter most of the time. It wouldn&#x27;t matter in this bet.<p>So much of what any lifeform does is based on past experience, even though that experience isn&#x27;t the direct driver of future effects. Turns out that bets based on experience work really well.</div><br/><div id="36673285" class="c"><input type="checkbox" id="c-36673285" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36673203">parent</a><span>|</span><a href="#36673287">next</a><span>|</span><label class="collapse" for="c-36673285">[-]</label><label class="expand" for="c-36673285">[1 more]</label></div><br/><div class="children"><div class="content">Of course Iâd bet the sun would rise tomorrow, because if it doesnât, Iâm either dead or money will be worthlessâ¦<p>The same applies here, would you bet on a horse that is flagging (RSA wonât work forever)? We have the ability to take in new information, and throw away past information because it is no longer relevant. If you choose to ignore the new information, just because âitâs always been that wayâ, that doesnât seem rational.</div><br/></div></div><div id="36673287" class="c"><input type="checkbox" id="c-36673287" checked=""/><div class="controls bullet"><span class="by">cbm-vic-20</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36673203">parent</a><span>|</span><a href="#36673285">prev</a><span>|</span><a href="#36674592">next</a><span>|</span><label class="collapse" for="c-36673287">[-]</label><label class="expand" for="c-36673287">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. The sun has successfully rose every morning, hundreds of billions of times straight! That&#x27;s a pretty good record.</div><br/></div></div></div></div><div id="36674592" class="c"><input type="checkbox" id="c-36674592" checked=""/><div class="controls bullet"><span class="by">sn0wf1re</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36672976">parent</a><span>|</span><a href="#36673203">prev</a><span>|</span><a href="#36674191">next</a><span>|</span><label class="collapse" for="c-36674592">[-]</label><label class="expand" for="c-36674592">[1 more]</label></div><br/><div class="children"><div class="content">It does though. If it failed to rise today due to some cosmic anomaly, it would very likely fail to rise tomorrow.</div><br/></div></div></div></div></div></div><div id="36674191" class="c"><input type="checkbox" id="c-36674191" checked=""/><div class="controls bullet"><span class="by">yyyk</span><span>|</span><a href="#36672583">parent</a><span>|</span><a href="#36672669">prev</a><span>|</span><a href="#36672769">next</a><span>|</span><label class="collapse" for="c-36674191">[-]</label><label class="expand" for="c-36674191">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Implementation simplicity is an underrated security parameter.<p>Sure, if we were implementing cryptographic algorithms from scratch that would be a proper strong consideration. However, 99% of programmers should just link to an established library&#x2F;framework and use its cryptographic implementation. These established libraries already paid the price of implementation, and are very battle-tested. There&#x27;s therefore very good reason to believe their RSA implementation is secure.<p>Choosing an algorithm should be done on other considerations then. A lower keysize would point to ECC. But maybe we don&#x27;t want a single algorithm for all encryption - a mixed global ecosystem with RSA and ECC projects would be more robust.</div><br/><div id="36675407" class="c"><input type="checkbox" id="c-36675407" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36674191">parent</a><span>|</span><a href="#36675214">next</a><span>|</span><label class="collapse" for="c-36675407">[-]</label><label class="expand" for="c-36675407">[2 more]</label></div><br/><div class="children"><div class="content">&gt; These established libraries already paid the price of implementation, and are very battle-tested. There&#x27;s therefore very good reason to believe their RSA implementation is secure.<p>Many of these established libraries have fallen in battle, some several times. There&#x27;s always a new up and coming library that works on platform X, in language Y, or has a better license Z, or is integrated into an init system, and while some of them learn from the experience of others, many learn by making the same mistakes others did.<p>Pushing towards simpler constructions gives hope that those new implementations make fewer mistakes.</div><br/><div id="36677979" class="c"><input type="checkbox" id="c-36677979" checked=""/><div class="controls bullet"><span class="by">yyyk</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36675407">parent</a><span>|</span><a href="#36675214">next</a><span>|</span><label class="collapse" for="c-36677979">[-]</label><label class="expand" for="c-36677979">[1 more]</label></div><br/><div class="children"><div class="content">To be frank, &quot;RSA is so impossibly complicated that nobody ever could implement it&quot; is just spreading FUD. It&#x27;s not so complicated an expert* couldn&#x27;t do it, the code is small to review, it&#x27;s been done, and safe implementations are well-known. If you decide to go with a new up and coming library the risk is on you whatever algorithm you choose.<p>* The only type of person who should be writing a cryptographic implementation in the first place.</div><br/></div></div></div></div><div id="36675214" class="c"><input type="checkbox" id="c-36675214" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36674191">parent</a><span>|</span><a href="#36675407">prev</a><span>|</span><a href="#36672769">next</a><span>|</span><label class="collapse" for="c-36675214">[-]</label><label class="expand" for="c-36675214">[1 more]</label></div><br/><div class="children"><div class="content">&gt; These established libraries already paid the price of implementation, and are very battle-tested.<p>Yes absolutely. Iâm not saying users should pick the one thatâs easier to implement.<p>Simplicity is good for <i>implementers</i>. It allows for more participants, eg std libs to provide their own. Also, even the security geeks are humans and make mistakes. Heartbleed is a perfect example of where even simple things can go catastrophically wrong.<p>As a second order effect, users benefit from simplicity in the long run, because less complex systems have fewer bugs, and thus fewer security bugs.</div><br/></div></div></div></div><div id="36672769" class="c"><input type="checkbox" id="c-36672769" checked=""/><div class="controls bullet"><span class="by">upofadown</span><span>|</span><a href="#36672583">parent</a><span>|</span><a href="#36674191">prev</a><span>|</span><a href="#36676039">next</a><span>|</span><label class="collapse" for="c-36672769">[-]</label><label class="expand" for="c-36672769">[2 more]</label></div><br/><div class="children"><div class="content">If you accept the current assumption of double exponential growth for both computing performance and algorithmic efficiency then you would have to accept that 256 bit elliptic curve keys will become obsolete in the 2040s. So it might be just RSA and discrete logs today but a requirement for pointlessly long EC keys will be along soon.</div><br/><div id="36674112" class="c"><input type="checkbox" id="c-36674112" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#36672583">root</a><span>|</span><a href="#36672769">parent</a><span>|</span><a href="#36676039">next</a><span>|</span><label class="collapse" for="c-36674112">[-]</label><label class="expand" for="c-36674112">[1 more]</label></div><br/><div class="children"><div class="content">Yeah but does it matter? Either thatâs true or it isnât. If it is true, weâll (as usual) have ample time to migrate. With RSA though, itâs already today more complex, slower and about 8x larger key sizes. And the cryptanalysis track record is afaik (please correct me) much more successful than ECC, so itâs âhigher riskâ that the timeline gets pushed forward or that new patches are needed to avoid bad parameter choices.<p>&gt; So it might be just RSA and discrete logs today but a requirement for pointlessly long EC keys will be along soon.<p>It wouldnât be pointless if computers can crack those sizes. Itâd only be pointless if cryptanalysis can exploit structure to reduce the effective entropy, no?</div><br/></div></div></div></div></div></div><div id="36676039" class="c"><input type="checkbox" id="c-36676039" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36672583">prev</a><span>|</span><a href="#36673137">next</a><span>|</span><label class="collapse" for="c-36676039">[-]</label><label class="expand" for="c-36676039">[1 more]</label></div><br/><div class="children"><div class="content">My MITM proxy that sits on the LAN and acts as a filtering gateway to the Internet still uses a 1kbit RSA key, only because it&#x27;s the smallest size my devices will accept. It&#x27;s somewhat amusing that, despite widespread &quot;knowledge&quot; that 1024-bit RSA is &quot;insecure&quot;, this is still roughly 2^100 times more difficult to factor than the current latest record of 829 bits.</div><br/></div></div><div id="36673137" class="c"><input type="checkbox" id="c-36673137" checked=""/><div class="controls bullet"><span class="by">mmaunder</span><span>|</span><a href="#36676039">prev</a><span>|</span><a href="#36672603">next</a><span>|</span><label class="collapse" for="c-36673137">[-]</label><label class="expand" for="c-36673137">[6 more]</label></div><br/><div class="children"><div class="content">That AI will accelerate algorithmic improvements is a new factor that has not previously been taken into account. This may be too optimistic.</div><br/><div id="36673204" class="c"><input type="checkbox" id="c-36673204" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#36673137">parent</a><span>|</span><a href="#36676956">next</a><span>|</span><label class="collapse" for="c-36673204">[-]</label><label class="expand" for="c-36673204">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s practically no reason to think that AI will greatly accelerate the development of new algorithms.</div><br/><div id="36673595" class="c"><input type="checkbox" id="c-36673595" checked=""/><div class="controls bullet"><span class="by">zone411</span><span>|</span><a href="#36673137">root</a><span>|</span><a href="#36673204">parent</a><span>|</span><a href="#36676956">next</a><span>|</span><label class="collapse" for="c-36673595">[-]</label><label class="expand" for="c-36673595">[3 more]</label></div><br/><div class="children"><div class="content">Why? Because we&#x27;re nearing the theoretical limits or because AI will be too dumb to help or for other reasons?</div><br/><div id="36674759" class="c"><input type="checkbox" id="c-36674759" checked=""/><div class="controls bullet"><span class="by">I_am_uncreative</span><span>|</span><a href="#36673137">root</a><span>|</span><a href="#36673595">parent</a><span>|</span><a href="#36676956">next</a><span>|</span><label class="collapse" for="c-36674759">[-]</label><label class="expand" for="c-36674759">[2 more]</label></div><br/><div class="children"><div class="content">For the same reason that there&#x27;s no reason to think AI will continue to advance exponentially.<p>The idea of the singularity is fun, but it&#x27;s unrealistic. Nothing lasts exponentially forever.</div><br/><div id="36675391" class="c"><input type="checkbox" id="c-36675391" checked=""/><div class="controls bullet"><span class="by">zone411</span><span>|</span><a href="#36673137">root</a><span>|</span><a href="#36674759">parent</a><span>|</span><a href="#36676956">next</a><span>|</span><label class="collapse" for="c-36675391">[-]</label><label class="expand" for="c-36675391">[1 more]</label></div><br/><div class="children"><div class="content">Even if the exponential improvements, which have been happening in both hardware and AI algorithms, were to slow down to sub-exponential, this still assumes that exponential advancements are necessary for AI to reach a level where it can assist in algorithm design. And only now we&#x27;re seeing big jumps in AI investments, which could serve as another source of improvements. You could even argue that we&#x27;re seeing the first signs of recursive improvements, with Copilot making programmers ~20% more productive.</div><br/></div></div></div></div></div></div></div></div><div id="36676956" class="c"><input type="checkbox" id="c-36676956" checked=""/><div class="controls bullet"><span class="by">jaza</span><span>|</span><a href="#36673137">parent</a><span>|</span><a href="#36673204">prev</a><span>|</span><a href="#36672603">next</a><span>|</span><label class="collapse" for="c-36676956">[-]</label><label class="expand" for="c-36676956">[1 more]</label></div><br/><div class="children"><div class="content">I have yet to see an AI bot produce anything that&#x27;s truly intelligent and&#x2F;or original (all I see is ever more powerful hardware and ever bigger quantities of training data being thrown at essentially the same statistical probability algorithms), and I don&#x27;t predict that changing in the foreseeable future - at least, not without the same kind of fundamental breakthrough that would be required for quantum computing to become a practical reality.</div><br/></div></div></div></div><div id="36672603" class="c"><input type="checkbox" id="c-36672603" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#36673137">prev</a><span>|</span><a href="#36672552">next</a><span>|</span><label class="collapse" for="c-36672603">[-]</label><label class="expand" for="c-36672603">[6 more]</label></div><br/><div class="children"><div class="content">One of the other problems about RSA cracking progress is that not a lot of people care anymore.<p>RSA is so slow that a <i>lot</i> of people have switched to Elliptic Curve.<p>That&#x27;s going to dent progress as the smart people are all working on ECC instead of RSA.</div><br/><div id="36672632" class="c"><input type="checkbox" id="c-36672632" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36672603">parent</a><span>|</span><a href="#36672552">next</a><span>|</span><label class="collapse" for="c-36672632">[-]</label><label class="expand" for="c-36672632">[5 more]</label></div><br/><div class="children"><div class="content">Its not totally implausible that a factoring breakthrough in ECC could have implications for RSA.</div><br/><div id="36672674" class="c"><input type="checkbox" id="c-36672674" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#36672603">root</a><span>|</span><a href="#36672632">parent</a><span>|</span><a href="#36672552">next</a><span>|</span><label class="collapse" for="c-36672674">[-]</label><label class="expand" for="c-36672674">[4 more]</label></div><br/><div class="children"><div class="content">Could you say more? ECC&#x27;s trapdoor function isn&#x27;t prime factoring; it&#x27;s a variant of the discrete log problem.</div><br/><div id="36672811" class="c"><input type="checkbox" id="c-36672811" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#36672603">root</a><span>|</span><a href="#36672674">parent</a><span>|</span><a href="#36672924">next</a><span>|</span><label class="collapse" for="c-36672811">[-]</label><label class="expand" for="c-36672811">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;quant-ph&#x2F;0301141" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;quant-ph&#x2F;0301141</a></div><br/><div id="36672889" class="c"><input type="checkbox" id="c-36672889" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#36672603">root</a><span>|</span><a href="#36672811">parent</a><span>|</span><a href="#36672924">next</a><span>|</span><label class="collapse" for="c-36672889">[-]</label><label class="expand" for="c-36672889">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I know that DLP and prime factorization are similar problems. I was trying to understand if the GP&#x27;s comment was about improvements to prime factorization <i>specifically</i> having implications for DLP (since &quot;factoring breakthrough in ECC&quot; is an unusual phrasing to me.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36672552" class="c"><input type="checkbox" id="c-36672552" checked=""/><div class="controls bullet"><span class="by">gregw2</span><span>|</span><a href="#36672603">prev</a><span>|</span><a href="#36672514">next</a><span>|</span><label class="collapse" for="c-36672552">[-]</label><label class="expand" for="c-36672552">[2 more]</label></div><br/><div class="children"><div class="content">Is factoring something that GPU &#x2F;CUDA parallelism helps with?</div><br/><div id="36672680" class="c"><input type="checkbox" id="c-36672680" checked=""/><div class="controls bullet"><span class="by">upofadown</span><span>|</span><a href="#36672552">parent</a><span>|</span><a href="#36672514">next</a><span>|</span><label class="collapse" for="c-36672680">[-]</label><label class="expand" for="c-36672680">[1 more]</label></div><br/><div class="children"><div class="content">Not for the sort of technology we have today using the best known algorithm. The approach relies on the idea of sieving. Sieving takes a lot of memory. As an example, the most recent 829 bit factoring record used multi GB for each processor during the parallel phase and 1.5 TB for the final matrix reduction phase. Neither phase would really get much out of a bunch of processors attached to just a few GB.</div><br/></div></div></div></div><div id="36672514" class="c"><input type="checkbox" id="c-36672514" checked=""/><div class="controls bullet"><span class="by">nailer</span><span>|</span><a href="#36672552">prev</a><span>|</span><label class="collapse" for="c-36672514">[-]</label><label class="expand" for="c-36672514">[19 more]</label></div><br/><div class="children"><div class="content">Is there a quantum algorithm for cracking ECDSA like Shor&#x27;s for RSA? I was hoping they&#x27;d mention it in the article.</div><br/><div id="36672636" class="c"><input type="checkbox" id="c-36672636" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#36672514">parent</a><span>|</span><a href="#36672596">next</a><span>|</span><label class="collapse" for="c-36672636">[-]</label><label class="expand" for="c-36672636">[12 more]</label></div><br/><div class="children"><div class="content">Shor&#x27;s algorithm can also break elliptic curve encryption: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Post-quantum_cryptography" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Post-quantum_cryptography</a></div><br/><div id="36673251" class="c"><input type="checkbox" id="c-36673251" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36672636">parent</a><span>|</span><a href="#36672596">next</a><span>|</span><label class="collapse" for="c-36673251">[-]</label><label class="expand" for="c-36673251">[11 more]</label></div><br/><div class="children"><div class="content">Part of the issue as a prospective cryptographic user&#x2F;consumer is that not only do I not know which algorithm(s) should be used, the most likely library <a href="https:&#x2F;&#x2F;github.com&#x2F;open-quantum-safe&#x2F;liboqs">https:&#x2F;&#x2F;github.com&#x2F;open-quantum-safe&#x2F;liboqs</a> also explicitly states that it shouldn&#x27;t be used in production.<p>Hybrid deployment (E.G. with ECC using a curve like 25519) is a great recommendation and probably obvious, far more so than picking a winner among the available post quantum possibly safe algorithms.</div><br/><div id="36673388" class="c"><input type="checkbox" id="c-36673388" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36673251">parent</a><span>|</span><a href="#36672596">next</a><span>|</span><label class="collapse" for="c-36673388">[-]</label><label class="expand" for="c-36673388">[10 more]</label></div><br/><div class="children"><div class="content">It is more or less universally assumed in practice that PQ key agreement algorithms will be paired with classical (RSA&#x2F;ECC) cryptography. There&#x27;s not much need to discuss or standardize it; it&#x27;s a given.</div><br/><div id="36673886" class="c"><input type="checkbox" id="c-36673886" checked=""/><div class="controls bullet"><span class="by">ivlad</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36673388">parent</a><span>|</span><a href="#36673652">next</a><span>|</span><label class="collapse" for="c-36673886">[-]</label><label class="expand" for="c-36673886">[2 more]</label></div><br/><div class="children"><div class="content">Doesnât NSA object hybrid schemes on weird grounds that current implementations suck, full of implementation errors and all-new PQ-only ones will not?<p>Edit: reference <a href="https:&#x2F;&#x2F;mailarchive.ietf.org&#x2F;arch&#x2F;msg&#x2F;spasm&#x2F;McksDhejGgJJ6xG617FEWLbBq0k&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mailarchive.ietf.org&#x2F;arch&#x2F;msg&#x2F;spasm&#x2F;McksDhejGgJJ6xG6...</a></div><br/><div id="36673891" class="c"><input type="checkbox" id="c-36673891" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36673886">parent</a><span>|</span><a href="#36673652">next</a><span>|</span><label class="collapse" for="c-36673891">[-]</label><label class="expand" for="c-36673891">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t make much sense as an objection, since the classical cryptography code is better ironed out than the PQ stuff, and the logic to combine the two is fairly simple.<p>Unless there is an unexpected leap in the viability of quantum cryptanalysis, you should expect that all commercial&#x2F;standard cryptography with PQ capabilities will run in a hybrid configuration.<p>I&#x27;m only commenting here because there&#x27;s a pervasive belief that this is controversial in cryptography engineering circles, or that NIST is trying somehow to prevent hybrid schemes from happening, which is simply not the case --- though they may not bother to standardize any particular mechanism of combining ECC&#x2F;RSA with PQ exchanges (but: they don&#x27;t standardize stuff like TLS ciphersuites, either).</div><br/></div></div></div></div><div id="36673652" class="c"><input type="checkbox" id="c-36673652" checked=""/><div class="controls bullet"><span class="by">nailer</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36673388">parent</a><span>|</span><a href="#36673886">prev</a><span>|</span><a href="#36672596">next</a><span>|</span><label class="collapse" for="c-36673652">[-]</label><label class="expand" for="c-36673652">[7 more]</label></div><br/><div class="children"><div class="content">So ECDHE becomes EC(Post Quantum Exchange)? Am I understanding that correctly?</div><br/><div id="36673795" class="c"><input type="checkbox" id="c-36673795" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36673652">parent</a><span>|</span><a href="#36673727">next</a><span>|</span><label class="collapse" for="c-36673795">[-]</label><label class="expand" for="c-36673795">[2 more]</label></div><br/><div class="children"><div class="content">I suspect you do not understand given the phrasing.<p>Think of Tunneling or layers or nesting dolls.  The order doesn&#x27;t particularly matter from a security perspective.  Though today I&#x27;d wrap with the conventional algorithm on the OUTSIDE layer, since it takes less computational time to check &#x2F; validate.  The inner layer would then be one or more of the post-quantum algorithms; a particularly paranoid application might use more than one if something absolutely must remain a secret.</div><br/><div id="36674521" class="c"><input type="checkbox" id="c-36674521" checked=""/><div class="controls bullet"><span class="by">nailer</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36673795">parent</a><span>|</span><a href="#36673727">next</a><span>|</span><label class="collapse" for="c-36674521">[-]</label><label class="expand" for="c-36674521">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for answering.<p>So youâre encrypting with an asymmetric post quantum algorithm then using that as a payload with regular ED25519 or similar?<p>What value does the pre quantum wrapper add?</div><br/></div></div></div></div><div id="36673727" class="c"><input type="checkbox" id="c-36673727" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36673652">parent</a><span>|</span><a href="#36673795">prev</a><span>|</span><a href="#36672596">next</a><span>|</span><label class="collapse" for="c-36673727">[-]</label><label class="expand" for="c-36673727">[4 more]</label></div><br/><div class="children"><div class="content">A good Google search term is &quot;CECPQ2&quot;. Roughly: run a PQ KX to reach a shared secret, and run an independent X25519 to reach a second share secret, and then HKDF them both (conceptually: just cat them together and use them as a single secret).</div><br/><div id="36674021" class="c"><input type="checkbox" id="c-36674021" checked=""/><div class="controls bullet"><span class="by">HappyPanacea</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36673727">parent</a><span>|</span><a href="#36672596">next</a><span>|</span><label class="collapse" for="c-36674021">[-]</label><label class="expand" for="c-36674021">[3 more]</label></div><br/><div class="children"><div class="content">Why not just XOR them? Is the reason we use HKDF is so if one or both is only partially broken (only some bits or some correlation) instead of fully broken we still benefits from the information that is still there?</div><br/><div id="36674490" class="c"><input type="checkbox" id="c-36674490" checked=""/><div class="controls bullet"><span class="by">dadrian</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36674021">parent</a><span>|</span><a href="#36674486">next</a><span>|</span><label class="collapse" for="c-36674490">[-]</label><label class="expand" for="c-36674490">[1 more]</label></div><br/><div class="children"><div class="content">With an XOR, if you can control bits on one of the inputs, you can deterministically change one of the bits on the outputs. That is not the case with an HKDF.</div><br/></div></div><div id="36674486" class="c"><input type="checkbox" id="c-36674486" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36672514">root</a><span>|</span><a href="#36674021">parent</a><span>|</span><a href="#36674490">prev</a><span>|</span><a href="#36672596">next</a><span>|</span><label class="collapse" for="c-36674486">[-]</label><label class="expand" for="c-36674486">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, for all I know, they do XOR them. I didn&#x27;t look carefully at how CECPQ2 works! Just: there&#x27;s very straightforward joinery for running two key agreements and combining them so they both have to succeed to arrive at the session secret.<p><i>Later</i><p>(Leaving this comment here in perpetuity as evidence that I didn&#x27;t think about your question as hard as David Adrian did. The message still holds, and that message is: &quot;big ol&#x27; shrug&quot;.)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36672596" class="c"><input type="checkbox" id="c-36672596" checked=""/><div class="controls bullet"><span class="by">frutiger</span><span>|</span><a href="#36672514">parent</a><span>|</span><a href="#36672636">prev</a><span>|</span><a href="#36673842">next</a><span>|</span><label class="collapse" for="c-36672596">[-]</label><label class="expand" for="c-36672596">[1 more]</label></div><br/><div class="children"><div class="content">Yes. See <a href="https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;53425&#x2F;quantum-algorithm-for-elliptic-curves-private-keys" rel="nofollow noreferrer">https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;53425&#x2F;quantum-alg...</a>.</div><br/></div></div><div id="36673842" class="c"><input type="checkbox" id="c-36673842" checked=""/><div class="controls bullet"><span class="by">akvadrako</span><span>|</span><a href="#36672514">parent</a><span>|</span><a href="#36672596">prev</a><span>|</span><a href="#36673732">next</a><span>|</span><label class="collapse" for="c-36673842">[-]</label><label class="expand" for="c-36673842">[1 more]</label></div><br/><div class="children"><div class="content">Practically a quantum computer breaking ECC would happen much sooner than RSA, since ECC uses much smaller keys and the main issue with quantum computers is scaling.</div><br/></div></div><div id="36673732" class="c"><input type="checkbox" id="c-36673732" checked=""/><div class="controls bullet"><span class="by">pjs_</span><span>|</span><a href="#36672514">parent</a><span>|</span><a href="#36673842">prev</a><span>|</span><a href="#36672610">next</a><span>|</span><label class="collapse" for="c-36673732">[-]</label><label class="expand" for="c-36673732">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2306.08585" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2306.08585</a></div><br/></div></div><div id="36672610" class="c"><input type="checkbox" id="c-36672610" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#36672514">parent</a><span>|</span><a href="#36673732">prev</a><span>|</span><a href="#36672922">next</a><span>|</span><label class="collapse" for="c-36672610">[-]</label><label class="expand" for="c-36672610">[1 more]</label></div><br/><div class="children"><div class="content">I was under the impression that shor&#x27;s algorithm worked for ecdsa just as well as rsa.</div><br/></div></div><div id="36672922" class="c"><input type="checkbox" id="c-36672922" checked=""/><div class="controls bullet"><span class="by">flangola7</span><span>|</span><a href="#36672514">parent</a><span>|</span><a href="#36672610">prev</a><span>|</span><label class="collapse" for="c-36672922">[-]</label><label class="expand" for="c-36672922">[2 more]</label></div><br/><div class="children"><div class="content">Every mainstream asymmetric cipher is broken by quantum computing. Post-quantum ciphers are only this year slowly rolling out in canary &amp; beta platforms and demand more memory and CPU cycles<p>A conservative but reasonable risk assumption is to act as if all internet traffic prior to the year 2023 was transmitted in the clear. This includes Signal, PGP, and Tor.</div><br/></div></div></div></div></div></div></div></div></div></body></html>