<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692090071808" as="style"/><link rel="stylesheet" href="styles.css?v=1692090071808"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Ask HN: How did Paul Allen write an 8080 emulator in 1974?</a> </div><div class="subtext"><span>andrewstuart</span> | <span>22 comments</span></div><br/><div><div id="37130941" class="c"><input type="checkbox" id="c-37130941" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#37131233">next</a><span>|</span><label class="collapse" for="c-37130941">[-]</label><label class="expand" for="c-37130941">[2 more]</label></div><br/><div class="children"><div class="content">It didn&#x27;t really match the modern definition of emulator. AKA, something that takes raw machine code and implements all the IO capabilities of the target device.<p>Instead, Paul Allen&#x27;s emulator worked at the code source level, and was implemented as a  macros for the assembler. This wasn&#x27;t even an 8080 assembler, it was a PDP-10 assembler and they created a bunch of macros to output the proper bytes for 8080 machine code.<p>For PDP-10 mode, they switched to a different set of macros, that took the same source code but for each 8080 instruction, it generated one or more PDP-10 to replicated the behaviour of 8080. The source code also replaced the IO code with native PDP-10 IO routines. This gives you a PDP-10 binary that you can run as normal.<p>I&#x27;m sure Paul Allen could have written an 8080 machine code interpreter if he wanted to; It&#x27;s really not that hard to make an emulator of a single CPU with limited IO, especially when the instructions are all documented. But the goal wasn&#x27;t to emulate other people&#x27;s 8080 binaries, the goal was to quickly create a programming environment to target the 8080 platform.</div><br/><div id="37131237" class="c"><input type="checkbox" id="c-37131237" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#37130941">parent</a><span>|</span><a href="#37131233">next</a><span>|</span><label class="collapse" for="c-37131237">[-]</label><label class="expand" for="c-37131237">[1 more]</label></div><br/><div class="children"><div class="content">So..  like..  troff?</div><br/></div></div></div></div><div id="37131233" class="c"><input type="checkbox" id="c-37131233" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#37130941">prev</a><span>|</span><a href="#37131519">next</a><span>|</span><label class="collapse" for="c-37131233">[-]</label><label class="expand" for="c-37131233">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s not so very impressive. the 8080 is quite an easy processor to emulate (but not at the transistor or i&#x2F;o level) - you can do it with a switch - there are only 256 possible instructions (not all used). i wrote one on the Dec10 back in the early 1980s (with assembler, disassembler and debugger) in Fortran77 and ported it to VAX and IBM 4381. we used it to teach assembler programming at the polytechnic i worked for. you could easily (well, relatively easily) have written basic on my implementation.</div><br/></div></div><div id="37131519" class="c"><input type="checkbox" id="c-37131519" checked=""/><div class="controls bullet"><span class="by">ggambetta</span><span>|</span><a href="#37131233">prev</a><span>|</span><a href="#37108430">next</a><span>|</span><label class="collapse" for="c-37131519">[-]</label><label class="expand" for="c-37131519">[1 more]</label></div><br/><div class="children"><div class="content">Writing an emulator for a simple processor isn&#x27;t particularly complicated. You only need a reference manual of the processor (which I assume he had). The emulator itself can be as simple as a while loop with a switch statement inside and some simple variable manipulation. Nowhere near &quot;feat of computer programming&quot; or &quot;major legend&quot;. Source: I&#x27;ve written Z80 and x86 emulators for fun.</div><br/></div></div><div id="37108430" class="c"><input type="checkbox" id="c-37108430" checked=""/><div class="controls bullet"><span class="by">curiousObject</span><span>|</span><a href="#37131519">prev</a><span>|</span><a href="#37108888">next</a><span>|</span><label class="collapse" for="c-37108430">[-]</label><label class="expand" for="c-37108430">[3 more]</label></div><br/><div class="children"><div class="content">It was an 8800 emulator I believe, not 8080. (Edit - I’m mistaken - it was for the 8080 CPU)<p>Then they wrote the BASIC interpreter on the emulator, copied it to punched paper tape and Allen wrote the loader for that while he was on the plane to demo it for Altair.<p>On the real Altair 8800 hardware which they had never seen, it worked first time (they must have had some advance knowledge of the Altair’s I&#x2F;O functions)<p>It was a series of amazing feats<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Altair_BASIC" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Altair_BASIC</a><p>Edit: maybe this feat  was not so famous because the Altair was not sold in numbers like the Apple II, which Steve Wozniak is well known for (25000 Altairs sold vs Apple’s 6 million - plus clones)</div><br/><div id="37108917" class="c"><input type="checkbox" id="c-37108917" checked=""/><div class="controls bullet"><span class="by">GianFabien</span><span>|</span><a href="#37108430">parent</a><span>|</span><a href="#37108888">next</a><span>|</span><label class="collapse" for="c-37108917">[-]</label><label class="expand" for="c-37108917">[2 more]</label></div><br/><div class="children"><div class="content">As far as I can remember, the Altair used an Intel 8080A processor.  The Intel 8008 wasn&#x27;t widely used by hobbyists.  I don&#x27;t recall any CPU with 8800 designation from that era.  Possibly RCA or TI, but neither were used by Altair.<p>The Motorola 6800 and Mostek 6502 soon became more popular because they were easier to interface than the Intel 8080A.  The Zilog Z80 came out a couple of years later.</div><br/><div id="37108935" class="c"><input type="checkbox" id="c-37108935" checked=""/><div class="controls bullet"><span class="by">curiousObject</span><span>|</span><a href="#37108430">root</a><span>|</span><a href="#37108917">parent</a><span>|</span><a href="#37108888">next</a><span>|</span><label class="collapse" for="c-37108935">[-]</label><label class="expand" for="c-37108935">[1 more]</label></div><br/><div class="children"><div class="content">You’re right. Thank you. I was misled by Altair 8800!<p>Intel did originally call their iAPX CPU the 8800, but that’s almost got to be an unrelated coincidence because the Altair 8800 was launched in late 1974, but the iAPX’s development didn’t begin at Intel until 1975. The iAPX is also an utterly diverse architecture and instruction set that Intel abandoned later, and they continued with the x86 line.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_iAPX_432" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_iAPX_432</a></div><br/></div></div></div></div></div></div><div id="37108888" class="c"><input type="checkbox" id="c-37108888" checked=""/><div class="controls bullet"><span class="by">johndoe0815</span><span>|</span><a href="#37108430">prev</a><span>|</span><a href="#37108890">next</a><span>|</span><label class="collapse" for="c-37108888">[-]</label><label class="expand" for="c-37108888">[2 more]</label></div><br/><div class="children"><div class="content">The 8080 was brought to market in April 1974 and it’s not unrealistic to assume that preliminary information on instruction encodings etc. was available earlier.<p>The 8008 would have been available already, but it was not binary compatible. However, an assembly translator was available (similar to the latter one translating 8080 asm to 8086).<p>So the question is if Allen wrote a binary emulator or perhaps something that interpreted asm source code? Maybe the emulator code is still hiding somewhere in the Microsoft archives… :)</div><br/><div id="37110719" class="c"><input type="checkbox" id="c-37110719" checked=""/><div class="controls bullet"><span class="by">johndoe0815</span><span>|</span><a href="#37108888">parent</a><span>|</span><a href="#37108890">next</a><span>|</span><label class="collapse" for="c-37110719">[-]</label><label class="expand" for="c-37110719">[1 more]</label></div><br/><div class="children"><div class="content">Some background (and a bit of speculation) can be found in this retrocomputing StackExchange topic:<p><a href="https:&#x2F;&#x2F;retrocomputing.stackexchange.com&#x2F;questions&#x2F;4984&#x2F;how-was-the-traf-o-data-8008-simulator-developed" rel="nofollow noreferrer">https:&#x2F;&#x2F;retrocomputing.stackexchange.com&#x2F;questions&#x2F;4984&#x2F;how-...</a><p>And a bit more about the PDP10 macro assembler that was used (also for 6502 BASIC) at Michael Steil&#x27;s site:<p><a href="https:&#x2F;&#x2F;www.pagetable.com&#x2F;?p=774" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.pagetable.com&#x2F;?p=774</a></div><br/></div></div></div></div><div id="37108890" class="c"><input type="checkbox" id="c-37108890" checked=""/><div class="controls bullet"><span class="by">GianFabien</span><span>|</span><a href="#37108888">prev</a><span>|</span><a href="#37110751">next</a><span>|</span><label class="collapse" for="c-37108890">[-]</label><label class="expand" for="c-37108890">[1 more]</label></div><br/><div class="children"><div class="content">It wasn&#x27;t that unusual. Microcomputers of the day were very limited, especially lacking memory. 4k RAM was considered to be a luxury.  So many folks cross-developed using minicomputers.  At my Uni, we often developed our tools on PDP-11 computers, especially using RSTS and BASIC, punched paper tape which could be read by hand fed paper tape readers.  If you were lucky you had a ASR-33 terminal attached to your microcomputer or had a simple video card connected to a TV and a kludged up keyboard.<p>Development systems from Intel were almost as expensive as a cheap minicomputer.</div><br/></div></div><div id="37110751" class="c"><input type="checkbox" id="c-37110751" checked=""/><div class="controls bullet"><span class="by">timonoko</span><span>|</span><a href="#37108890">prev</a><span>|</span><a href="#37131265">next</a><span>|</span><label class="collapse" for="c-37110751">[-]</label><label class="expand" for="c-37110751">[2 more]</label></div><br/><div class="children"><div class="content">If you look at the 1974 8080 Assembly Programming Manual, there is not much to do. &quot;Appendix A Instruction Summary&quot; describes each operation in handy pseudocode. All you need to do is to make an interpreter for these:<p>CALL ADDR: ((SP)-1) &lt;-- (PCH), ((SP)-2) &lt;-- (PCL), (SP) &lt;-- (SP)+2, (PC) &lt;-- ADDR</div><br/></div></div><div id="37131265" class="c"><input type="checkbox" id="c-37131265" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37110751">prev</a><span>|</span><a href="#37109998">next</a><span>|</span><label class="collapse" for="c-37131265">[-]</label><label class="expand" for="c-37131265">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny the comments here saying it&#x27;s not hard or unusual.<p>Paul Allen did this in <i>1974 without the Internet or modern software tools</i>.<p>I think it is absolutely extraordinary and incredibly impressive.</div><br/><div id="37131590" class="c"><input type="checkbox" id="c-37131590" checked=""/><div class="controls bullet"><span class="by">TheOtherHobbes</span><span>|</span><a href="#37131265">parent</a><span>|</span><a href="#37131640">next</a><span>|</span><label class="collapse" for="c-37131590">[-]</label><label class="expand" for="c-37131590">[1 more]</label></div><br/><div class="children"><div class="content">Assembler programming wasn&#x27;t an unusually exotic skill in the early 70s, and the PDP-10 was an unusually friendly environment for it.<p>Compared to modern programming, assembler on a 16- or 36-bit machine is simple, logical, and not at all abstract. DEC made a point of offering high quality detailed docs to students, and there was a kind of assembler culture that produced operating systems like TOPS-10, compilers for various languages, and editing tools, often with access to the sources.<p>And as others have pointed out, the 8080 was not a complex processor. So mapping its instructions to macros wasn&#x27;t hugely challenging.<p>I had a friend who wrote a Z80 emulator - a harder challenge - on a PDP-10 as a spare time hobby project. It took about a month of after-hours programming. Full-time, it would have taken much less.<p>More interesting is that it&#x27;s possible Gates &amp; Allen had access to the sources for the PDP-11 4K word Dartmouth BASIC.<p>I have no idea if the original 8-bit MS-BASIC was a clean room reimplementation. But it&#x27;s at least possible it wasn&#x27;t.</div><br/></div></div><div id="37131640" class="c"><input type="checkbox" id="c-37131640" checked=""/><div class="controls bullet"><span class="by">chpatrick</span><span>|</span><a href="#37131265">parent</a><span>|</span><a href="#37131590">prev</a><span>|</span><a href="#37109998">next</a><span>|</span><label class="collapse" for="c-37131640">[-]</label><label class="expand" for="c-37131640">[1 more]</label></div><br/><div class="children"><div class="content">Emulating some simple instructions really isn&#x27;t that hard, we did it in first year CS. He would have had the documentation available, you don&#x27;t need the internet for that.</div><br/></div></div></div></div><div id="37128045" class="c"><input type="checkbox" id="c-37128045" checked=""/><div class="controls bullet"><span class="by">faangiq</span><span>|</span><a href="#37109998">prev</a><span>|</span><a href="#37130969">next</a><span>|</span><label class="collapse" for="c-37128045">[-]</label><label class="expand" for="c-37128045">[2 more]</label></div><br/><div class="children"><div class="content">He just sued everyone until they wrote it for him.</div><br/><div id="37131384" class="c"><input type="checkbox" id="c-37131384" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#37128045">parent</a><span>|</span><a href="#37130969">next</a><span>|</span><label class="collapse" for="c-37131384">[-]</label><label class="expand" for="c-37131384">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve banned this account for posting unsubstantive and flamebait comments, and ignoring our requests to stop.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33566110">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33566110</a> (Nov 2022)<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32359604">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32359604</a> (Aug 2022)<p>If you don&#x27;t want to be banned, you&#x27;re welcome to email hn@ycombinator.com and give us reason to believe that you&#x27;ll follow the rules in the future. They&#x27;re here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>