<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688893260983" as="style"/><link rel="stylesheet" href="styles.css?v=1688893260983"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://container.training/">Container Training</a> <span class="domain">(<a href="https://container.training">container.training</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>40 comments</span></div><br/><div><div id="36649684" class="c"><input type="checkbox" id="c-36649684" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#36652788">next</a><span>|</span><label class="collapse" for="c-36649684">[-]</label><label class="expand" for="c-36649684">[13 more]</label></div><br/><div class="children"><div class="content">I wonder if this is an unpopular opinion, but I just don&#x27;t get why so many people in the industry started using containers where using, say, jars in the JVM would have worked perfectly fine.<p>It seems so much is lost, for no apparent reason.  We used to have clean interfaces, architecture independence, pretty good performance, low startup times, low memory usage, and heaps of experience with the JVM or .NET for years.<p>We now seem to have regressed to modularising software into separate unix processes with less strict interfaces, extremely complex dependency chains, and many more moving parts.<p>Obviously, this is all fine if you are actually building systems at enormous scale, but I see this move to containers in all fields, even for applications that run on a single CPU where performance or scalability is not an issue.<p>What would be the reason for this?  Is it simply that younger generations need to relearn from their own mistakes?  Or is this part of the micro service hype?<p>(Of course I&#x27;m not ignorant to some positive aspects of containers, especially for interfacing with databases or web servers, and other unix services.)  My problem is mostly with using containers to split even the most straightforward applications, where existing techniques were (at least IMHO) vastly superior.)</div><br/><div id="36652815" class="c"><input type="checkbox" id="c-36652815" checked=""/><div class="controls bullet"><span class="by">dumpster_fire</span><span>|</span><a href="#36649684">parent</a><span>|</span><a href="#36649755">next</a><span>|</span><label class="collapse" for="c-36652815">[-]</label><label class="expand" for="c-36652815">[1 more]</label></div><br/><div class="children"><div class="content">I remember the good old days of having to script my own deployments on our own on-prem servers, with linter free wild west testing. It went to crap pretty easily because we were always customizing something, automating something, customizing the automating of something. Dependency checking was also very manual.<p>Nowadays we work with way more traffic that incentivizes strict bin packing of traffic within the tightest bounds of the resource pool, with the fastest actuation time. VMs won&#x27;t give you that. Containerization just makes that so much easier and snappier for large amounts of traffic. But then we had to go global, and orchestrating containers across continents is a PITA. So there&#x27;s value in k8s for dealing with that. These tools vastly reduce the complexity with regards to managing globally distributed services. But as usual, we start customizing these tools, leading to more complexity.<p>With that said, I believe startups need to focus on the fastest development and deployment times. So stuff like Docker, Kubernetes or Terraform are entirely unnecessary. As I commented elsewhere before, no one with a total QPS of 10 needs anything beyond GCE or EC2 or on-prem servers. People born in the Cloud age seem to have forgotten that they can just run the cheapest Linux machine with HAProxy and httpd behind a static IP. The focus on always going straight to Cloud complexity, if anything, smells more like engineers in on some VC grift.<p>Side note: It&#x27;s hard to hire senior&#x2F;motivated Java developers. It became a self-fulfilling cycle. Happened somewhere around 2011-2014, no one other than fresh grads graduating from legacy courses still used Java or .NET.</div><br/></div></div><div id="36649755" class="c"><input type="checkbox" id="c-36649755" checked=""/><div class="controls bullet"><span class="by">VectorLock</span><span>|</span><a href="#36649684">parent</a><span>|</span><a href="#36652815">prev</a><span>|</span><a href="#36652653">next</a><span>|</span><label class="collapse" for="c-36649755">[-]</label><label class="expand" for="c-36649755">[1 more]</label></div><br/><div class="children"><div class="content">Every programming language had its own version of jars, dependency management, etc. that you then need to reproduce everywhere you want those things to run. Containers mostly abstract that away - you just have a container image filled with what you want and you execute it.  It also provides a consistent means of isolation.  Thats the benefit I see.</div><br/></div></div><div id="36652653" class="c"><input type="checkbox" id="c-36652653" checked=""/><div class="controls bullet"><span class="by">fuzzy2</span><span>|</span><a href="#36649684">parent</a><span>|</span><a href="#36649755">prev</a><span>|</span><a href="#36652553">next</a><span>|</span><label class="collapse" for="c-36652653">[-]</label><label class="expand" for="c-36652653">[1 more]</label></div><br/><div class="children"><div class="content">Some applications cannot be deployed as a monolith. Maybe they mix native and managed dependencies. Maybe they rely on external software (like, say, ffmpeg) being present. Maybe this external software depends on specific system library versions.<p>Yes, you can make all of this work without containers. They make all this very easy and reliable though.<p>So your container has the right Java Runtime Environment and your app inside. I don&#x27;t even need to know it&#x27;s Java!</div><br/></div></div><div id="36652553" class="c"><input type="checkbox" id="c-36652553" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#36649684">parent</a><span>|</span><a href="#36652653">prev</a><span>|</span><a href="#36649703">next</a><span>|</span><label class="collapse" for="c-36652553">[-]</label><label class="expand" for="c-36652553">[1 more]</label></div><br/><div class="children"><div class="content">It complicates it downwards, but simplifies it upwards. For example, containers generalizes the workload in a Kubernetes world, where the JVM would not be a general abstraction. This mainly matters on a scale where Kubernetes or similar solutions are motivated.</div><br/></div></div><div id="36649703" class="c"><input type="checkbox" id="c-36649703" checked=""/><div class="controls bullet"><span class="by">fearface</span><span>|</span><a href="#36649684">parent</a><span>|</span><a href="#36652553">prev</a><span>|</span><a href="#36649855">next</a><span>|</span><label class="collapse" for="c-36649703">[-]</label><label class="expand" for="c-36649703">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to split an application into containers, you can have your full app in a container no problem. You can have all your jars in the container. Using containers doesn&#x27;t mean you know have to split your apps in different ways, it means you ship the runtime, compiled code, whatever libraries are required and all that in a bundle.</div><br/></div></div><div id="36649855" class="c"><input type="checkbox" id="c-36649855" checked=""/><div class="controls bullet"><span class="by">archsurface</span><span>|</span><a href="#36649684">parent</a><span>|</span><a href="#36649703">prev</a><span>|</span><a href="#36651429">next</a><span>|</span><label class="collapse" for="c-36649855">[-]</label><label class="expand" for="c-36649855">[2 more]</label></div><br/><div class="children"><div class="content">Which version of the JVM?  The one on your machine, my machine, or the server?</div><br/><div id="36651952" class="c"><input type="checkbox" id="c-36651952" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36649684">root</a><span>|</span><a href="#36649855">parent</a><span>|</span><a href="#36651429">next</a><span>|</span><label class="collapse" for="c-36651952">[-]</label><label class="expand" for="c-36651952">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, there are still things it doesn&#x27;t catch; I&#x27;ve hit containers that needed an update to the host to run. Too old of a kernel, maybe? I&#x27;m afraid I forget the details.</div><br/></div></div></div></div><div id="36651429" class="c"><input type="checkbox" id="c-36651429" checked=""/><div class="controls bullet"><span class="by">jb_gericke</span><span>|</span><a href="#36649684">parent</a><span>|</span><a href="#36649855">prev</a><span>|</span><a href="#36650007">next</a><span>|</span><label class="collapse" for="c-36651429">[-]</label><label class="expand" for="c-36651429">[1 more]</label></div><br/><div class="children"><div class="content">It’s actually a Kubernetes focussed course. The JVM isn’t going to auto scale or distribute my service.</div><br/></div></div><div id="36650007" class="c"><input type="checkbox" id="c-36650007" checked=""/><div class="controls bullet"><span class="by">doliveira</span><span>|</span><a href="#36649684">parent</a><span>|</span><a href="#36651429">prev</a><span>|</span><a href="#36651524">next</a><span>|</span><label class="collapse" for="c-36650007">[-]</label><label class="expand" for="c-36650007">[1 more]</label></div><br/><div class="children"><div class="content">I assume you haven&#x27;t been through the absolute hell that are Hadoop JARs</div><br/></div></div><div id="36651524" class="c"><input type="checkbox" id="c-36651524" checked=""/><div class="controls bullet"><span class="by">nikau</span><span>|</span><a href="#36649684">parent</a><span>|</span><a href="#36650007">prev</a><span>|</span><a href="#36652281">next</a><span>|</span><label class="collapse" for="c-36651524">[-]</label><label class="expand" for="c-36651524">[2 more]</label></div><br/><div class="children"><div class="content">its the ability to lower operating cost with less skilled staff.<p>No need to worry about some some other app using port 8080, dont need to ensure your scripts do a ps and filter out other users stuff, all those kinds of things.<p>Then theres libraries and vulnerability management which is easier to manage where the blast radius is just a single container.</div><br/><div id="36652335" class="c"><input type="checkbox" id="c-36652335" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#36649684">root</a><span>|</span><a href="#36651524">parent</a><span>|</span><a href="#36652281">next</a><span>|</span><label class="collapse" for="c-36652335">[-]</label><label class="expand" for="c-36652335">[1 more]</label></div><br/><div class="children"><div class="content">&gt; dont need to ensure your scripts do a ps and filter out other users stuff<p>Your broader point still stands, but I just wanted to say that finding processes to signal (presumably to kill or restart?) via `ps` is insane. Linux has really good process management tools available, whether service management via the init system (systemd, OpenRC, GNU Shepherd, etc.) or some other process management tool (supervisord, daemon tools, runit, etc.). Even beyond that, there&#x27;s good ol&#x27; nohup and pidfiles. All of those things are well established and easy to do. Filtering ps output and using it to decide what to do is indeed painful, but it&#x27;s painful because it&#x27;s the wrong approach for Unix, not because Unix multitenancy is more painful than containers.<p>Containers are nice but it sounds like maybe you have some trauma from bad ops mixed into your assessment!</div><br/></div></div></div></div></div></div><div id="36652788" class="c"><input type="checkbox" id="c-36652788" checked=""/><div class="controls bullet"><span class="by">simonjgreen</span><span>|</span><a href="#36649684">prev</a><span>|</span><a href="#36648376">next</a><span>|</span><label class="collapse" for="c-36652788">[-]</label><label class="expand" for="c-36652788">[1 more]</label></div><br/><div class="children"><div class="content">It greatly frustrates me that Docker Swarm fell out of favour leaving a void between single-host Docker and Kubernetes. It makes self hosting docker with a small amount of resilience and orchestration much more challenging.</div><br/></div></div><div id="36648376" class="c"><input type="checkbox" id="c-36648376" checked=""/><div class="controls bullet"><span class="by">anderspitman</span><span>|</span><a href="#36652788">prev</a><span>|</span><a href="#36649096">next</a><span>|</span><label class="collapse" for="c-36648376">[-]</label><label class="expand" for="c-36648376">[12 more]</label></div><br/><div class="children"><div class="content">I used to feel like docker wasn&#x27;t worth the complexity but I&#x27;ve come around. It strikes a pretty dang good balance. Is kubernetes worth learning if you don&#x27;t use microservices at work?</div><br/><div id="36649492" class="c"><input type="checkbox" id="c-36649492" checked=""/><div class="controls bullet"><span class="by">ericbarrett</span><span>|</span><a href="#36648376">parent</a><span>|</span><a href="#36651351">next</a><span>|</span><label class="collapse" for="c-36649492">[-]</label><label class="expand" for="c-36649492">[1 more]</label></div><br/><div class="children"><div class="content"><i>Using</i> Kubernetes is a skill worth learning and is pretty straightforward to pick up.<p><i>Running</i> a Kubernetes cluster, in a shared environment (e.g. not just a hobbyist or single-purpose cluster), is much more involved. I&#x27;d never say developing a skill isn&#x27;t worth it, but it is a deep subject with lots of unintuitive and frustrating corners, and you won&#x27;t pick it up in a day or without scars. There&#x27;s a reason lots of small- and medium-sized business just write a check to their cloud provider.</div><br/></div></div><div id="36651351" class="c"><input type="checkbox" id="c-36651351" checked=""/><div class="controls bullet"><span class="by">young_hopper</span><span>|</span><a href="#36648376">parent</a><span>|</span><a href="#36649492">prev</a><span>|</span><a href="#36648591">next</a><span>|</span><label class="collapse" for="c-36651351">[-]</label><label class="expand" for="c-36651351">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is kubernetes worth learning if you don&#x27;t use microservices at work?<p>Maybe. K8s makes orchestration better. (If you disagree look at the last time marathon&#x2F;mesos&#x2F;dcos released and propose a better replacement.) Do you need container orchestration? That&#x27;s a much better question. If you do, reach for k8s, if you don&#x27;t, don&#x27;t.</div><br/></div></div><div id="36648591" class="c"><input type="checkbox" id="c-36648591" checked=""/><div class="controls bullet"><span class="by">jahsome</span><span>|</span><a href="#36648376">parent</a><span>|</span><a href="#36651351">prev</a><span>|</span><a href="#36648961">next</a><span>|</span><label class="collapse" for="c-36648591">[-]</label><label class="expand" for="c-36648591">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so. It&#x27;s overkill for most stuff and probably not particularly worth learning until you &#x2F;need&#x2F; to.<p>If you&#x27;re curious about orchestration concepts in general, something like nomad is a nice way to wade into the pool rather than the whirlpool of obscenity that is k8s.</div><br/><div id="36648930" class="c"><input type="checkbox" id="c-36648930" checked=""/><div class="controls bullet"><span class="by">abalashov</span><span>|</span><a href="#36648376">root</a><span>|</span><a href="#36648591">parent</a><span>|</span><a href="#36648955">next</a><span>|</span><label class="collapse" for="c-36648930">[-]</label><label class="expand" for="c-36648930">[1 more]</label></div><br/><div class="children"><div class="content">+1, Nomad is fantastically simple (but still flexible), and gives you the proper level of insight into the nature of orchestration and distributed container workloads without bogging you down with arbitrary figments of &quot;because Kubernetes&quot; complexity.<p>After spending a day with Nomad, I feel I fully understand how this could get nightmarishly complicated in a Kubernetes way, and what that would look like, and why someone would want that in some situations. All the understanding without pointless but exacting detours.</div><br/></div></div><div id="36648955" class="c"><input type="checkbox" id="c-36648955" checked=""/><div class="controls bullet"><span class="by">chromatin</span><span>|</span><a href="#36648376">root</a><span>|</span><a href="#36648591">parent</a><span>|</span><a href="#36648930">prev</a><span>|</span><a href="#36648789">next</a><span>|</span><label class="collapse" for="c-36648955">[-]</label><label class="expand" for="c-36648955">[1 more]</label></div><br/><div class="children"><div class="content">Nomad is worth learning and something that can feasibly orchestrate your containers at home, as well.</div><br/></div></div><div id="36648789" class="c"><input type="checkbox" id="c-36648789" checked=""/><div class="controls bullet"><span class="by">bittermandel</span><span>|</span><a href="#36648376">root</a><span>|</span><a href="#36648591">parent</a><span>|</span><a href="#36648955">prev</a><span>|</span><a href="#36648961">next</a><span>|</span><label class="collapse" for="c-36648789">[-]</label><label class="expand" for="c-36648789">[1 more]</label></div><br/><div class="children"><div class="content">I fully support this! Nomad has a much smaller API surface compared to Kubernetes, at least by default. Expanding Nomad is also much more straight forward.</div><br/></div></div></div></div><div id="36648961" class="c"><input type="checkbox" id="c-36648961" checked=""/><div class="controls bullet"><span class="by">benjaminwootton</span><span>|</span><a href="#36648376">parent</a><span>|</span><a href="#36648591">prev</a><span>|</span><a href="#36648579">next</a><span>|</span><label class="collapse" for="c-36648961">[-]</label><label class="expand" for="c-36648961">[1 more]</label></div><br/><div class="children"><div class="content">Docker is really easy.  A few lines to describe your environment and a handful of commands (docker build, run, ps, images) and you are up and running.<p>Orchestration is more complex, but not too bad if you are using a managed platform.<p>A few days and you can get your head around it enough to get started with huge payback in efficiency.<p>After that, you can spend years really going deep on K8s and fully containerised stacks, but that’s more for DevOps&#x2F;Cloud engineers rather than Devs.</div><br/></div></div><div id="36648579" class="c"><input type="checkbox" id="c-36648579" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#36648376">parent</a><span>|</span><a href="#36648961">prev</a><span>|</span><a href="#36650786">next</a><span>|</span><label class="collapse" for="c-36648579">[-]</label><label class="expand" for="c-36648579">[1 more]</label></div><br/><div class="children"><div class="content">If you’re interested enough to be curious, it’s worth sitting down for a day with a mini kubernetes distribution and working through the basics of pods, deployments, and services. They are relatively simple conceptually (the hard part is grokking the kubernetes way of doing things) but they give you a feel for the way Kubernetes works.</div><br/></div></div><div id="36650786" class="c"><input type="checkbox" id="c-36650786" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#36648376">parent</a><span>|</span><a href="#36648579">prev</a><span>|</span><a href="#36648522">next</a><span>|</span><label class="collapse" for="c-36650786">[-]</label><label class="expand" for="c-36650786">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say yes, worth it, just to be aware about its capabilities and caveats, strong and weak sides.<p>At one point or another someone will say something about K8s, and it never hurts to know more than just the peachy marketing posters from the large cloud providers, so you can have an opinion. What it realistically can and cannot do for you - this kind of stuff.</div><br/></div></div><div id="36648792" class="c"><input type="checkbox" id="c-36648792" checked=""/><div class="controls bullet"><span class="by">theossuary</span><span>|</span><a href="#36648376">parent</a><span>|</span><a href="#36648522">prev</a><span>|</span><a href="#36649096">next</a><span>|</span><label class="collapse" for="c-36648792">[-]</label><label class="expand" for="c-36648792">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say so. I&#x27;ve been using k8s as a basis for all my projects for years. It&#x27;s the best solution I&#x27;ve seen to the problem of packaging and deploying apps. I have a kubespray cluster at home that runs dozens of services flawlessly. Flux is the easiest devops deployment system I&#x27;ve ever had.<p>For work, having minikube + skaffold is perfect for local dev of complex apps. And it&#x27;s easy to use production deployment manifests with it. It&#x27;s also easy to use Kind for running integration and e2e tests. The ecosystem is second to none.</div><br/></div></div></div></div><div id="36649096" class="c"><input type="checkbox" id="c-36649096" checked=""/><div class="controls bullet"><span class="by">dp-hackernews</span><span>|</span><a href="#36648376">prev</a><span>|</span><a href="#36648990">next</a><span>|</span><label class="collapse" for="c-36649096">[-]</label><label class="expand" for="c-36649096">[2 more]</label></div><br/><div class="children"><div class="content">btw, Jérôme Petazzoni is one of the very early adopters of docker, so while some stuff may seem a bit dated, it&#x27;ll still be worth looking into...</div><br/><div id="36652699" class="c"><input type="checkbox" id="c-36652699" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#36649096">parent</a><span>|</span><a href="#36648990">next</a><span>|</span><label class="collapse" for="c-36652699">[-]</label><label class="expand" for="c-36652699">[1 more]</label></div><br/><div class="children"><div class="content">He was there at the very start at DotCloud and worked on Dockers predecessor and then Docker itself. Early adopter is really underselling how much he contributed.</div><br/></div></div></div></div><div id="36648990" class="c"><input type="checkbox" id="c-36648990" checked=""/><div class="controls bullet"><span class="by">ChrisArchitect</span><span>|</span><a href="#36649096">prev</a><span>|</span><a href="#36649535">next</a><span>|</span><label class="collapse" for="c-36648990">[-]</label><label class="expand" for="c-36648990">[1 more]</label></div><br/><div class="children"><div class="content">(2018)</div><br/></div></div><div id="36649535" class="c"><input type="checkbox" id="c-36649535" checked=""/><div class="controls bullet"><span class="by">natsucks</span><span>|</span><a href="#36648990">prev</a><span>|</span><a href="#36647817">next</a><span>|</span><label class="collapse" for="c-36649535">[-]</label><label class="expand" for="c-36649535">[1 more]</label></div><br/><div class="children"><div class="content">One does not simply deploy...</div><br/></div></div></div></div></div></div></div></body></html>