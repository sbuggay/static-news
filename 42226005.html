<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732525268515" as="style"/><link rel="stylesheet" href="styles.css?v=1732525268515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.macchaffee.com/blog/2024/you-have-built-a-kubernetes/">Dear friend, you have built a Kubernetes</a> <span class="domain">(<a href="https://www.macchaffee.com">www.macchaffee.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>161 comments</span></div><br/><div><div id="42227960" class="c"><input type="checkbox" id="c-42227960" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#42233109">next</a><span>|</span><label class="collapse" for="c-42227960">[-]</label><label class="expand" for="c-42227960">[52 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, I&#x27;ve worked at multiple places that ran shell scripts just fine for their deploys.<p>- One had only 2 services [php] and ran over 1 billion requests a day. Deploy was trivial, ssh some new files to the server and run a migration, 0 downtime.<p>- One was in an industry that didn&#x27;t need &quot;Webscale&quot; (retirement accounts). Prod deploys were just docker commands run by jenkins. We ran two servers per service from the day I joined the day I left 4 years later (3x growth), and ultimately removed one service and one database during all that growth.<p>Another outstanding thing about both of these places was that we had all the testing environments you need, on-demand, in minutes.<p>The place I&#x27;m at now is trying to do kubernetes and is failing miserably (ongoing nightmare 4 months in and probably at least 8 to go, when it was allegedly supposed to only take 3 total). It has one shared test environment that it takes 3-hours to see your changes in.<p>I don&#x27;t fault kubernetes directly, I fault the overall complexity. But at the end of the day kubernetes feels like complexity trying to abstract over complexity, and often I find that&#x27;s less successful that removing complexity in the first place.</div><br/><div id="42231318" class="c"><input type="checkbox" id="c-42231318" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#42227960">parent</a><span>|</span><a href="#42231597">next</a><span>|</span><label class="collapse" for="c-42231318">[-]</label><label class="expand" for="c-42231318">[18 more]</label></div><br/><div class="children"><div class="content">If your application doesn&#x27;t need and likely won&#x27;t need to scale to large clusters, or multiple clusters, then there&#x27;s nothing wrong per se. with your solution.  I don&#x27;t think k8s is that hard but there are a lot of moving pieces and there&#x27;s a bit to learn. Finding someone with experience to help you can make a ton of difference.<p>Questions worth asking:<p>- Do you need a load balancer?<p>- TLS certs and rotation?<p>- Horizontal scalability.<p>- HA&#x2F;DR<p>- dev&#x2F;stage&#x2F;production + being able to test&#x2F;stage your complete stack on demand.<p>- CI&#x2F;CD integrations, tools like ArgoCD or Spinnaker<p>- Monitoring and&#x2F;or alerting with Prometheus and Grafana<p>- Would you benefit from being able to deploy a lot of off the shelf software (lessay Elastic Search, or some random database, or a monitoring stack) via helm quickly&#x2F;easily.<p>- &quot;Ingress&quot;&#x2F;proxy.<p>- DNS integrations.<p>If you answer yes to many of those questions there&#x27;s really no better alternative than k8s. If you&#x27;re building large enough scale web applications the almost to most of these will end up being yes at some point.</div><br/><div id="42233566" class="c"><input type="checkbox" id="c-42233566" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42231318">parent</a><span>|</span><a href="#42232102">next</a><span>|</span><label class="collapse" for="c-42233566">[-]</label><label class="expand" for="c-42233566">[5 more]</label></div><br/><div class="children"><div class="content">Kubernetes is great example of the &quot;second-system effect&quot;.<p>Kubernetes only works if you have a webapp written in a slow interpreted language. For anything else it is a huge impedance mismatch with what you&#x27;re actually trying to do.<p>P.S. In the real world, Kubernetes isn&#x27;t used to solve technical problems. It&#x27;s used as a buffer between the dev team and the ops team, who usually have different schedules&#x2F;budgets, and might even be different corporate entities. I&#x27;m sure there might be an easier way to solve that problem without dragging in Google&#x27;s ridiculous and broken tech stack.</div><br/><div id="42234275" class="c"><input type="checkbox" id="c-42234275" checked=""/><div class="controls bullet"><span class="by">mrweasel</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233566">parent</a><span>|</span><a href="#42234019">next</a><span>|</span><label class="collapse" for="c-42234275">[-]</label><label class="expand" for="c-42234275">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s used as a buffer between the dev team and the ops team, who usually have different schedules&#x2F;budgets<p>That depends on your definition. If the ops team is solely responsibly for running the Kubernetes cluster, then yes. In reality that&#x27;s rarely how things turns out. Developers want Kubernetes, because.... I don&#x27;t know. Ops doesn&#x27;t even want Kubernetes in many cases. Kubernetes is amazing, for those few organisations that really need it.<p>My rule of thumb is: If your worker nodes aren&#x27;t entire physical hosts, then you might not need Kubernetes. I&#x27;ve seen some absolutely crazy setups where developers had designed this entire solution around Kubernetes, only to run one or two containers. The reasoning is pretty much always the same, they know absolutely nothing about operations, and fail to understand that load balancers exists outside of Kubernetes, or that their solution could be an nginx configuration, 100 lines of Python and some systemd configuration.<p>I accept that I lost the fight that Kubernetes is overly complex and a nightmare to debug. In my current position I can even see some advantages to Kubernetes, so I was at least a little of in my criticism. Still I don&#x27;t think Kubernetes should be your default deployment platform, unless you have very specific needs.</div><br/></div></div><div id="42234019" class="c"><input type="checkbox" id="c-42234019" checked=""/><div class="controls bullet"><span class="by">rixed</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233566">parent</a><span>|</span><a href="#42234275">prev</a><span>|</span><a href="#42233697">next</a><span>|</span><label class="collapse" for="c-42234019">[-]</label><label class="expand" for="c-42234019">[1 more]</label></div><br/><div class="children"><div class="content">Contrary to popular belief, k8s is not Google&#x27;s tech stack.<p>My understanding is that it was initially sold as Google&#x27;s tech to benefit from Google&#x27;s tech reputation (exploiting the confusion caused by the fact that some of the original k8s devs where ex-googlers), and today it&#x27;s also Google trying to pose as k8s inventor, to benefit from its popularity. Interesting case of host&#x2F;parasite symbiosis, it seams.<p>Just my impression though, I can be wrong, please comment if you know more about the history of k8s.</div><br/></div></div><div id="42233697" class="c"><input type="checkbox" id="c-42233697" checked=""/><div class="controls bullet"><span class="by">maxdo</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233566">parent</a><span>|</span><a href="#42234019">prev</a><span>|</span><a href="#42232102">next</a><span>|</span><label class="collapse" for="c-42233697">[-]</label><label class="expand" for="c-42233697">[2 more]</label></div><br/><div class="children"><div class="content">kubernetes is an API for your cluster, that is portable between providers, more or less. 
there are other abstractions, but they are not portable, e.g. fly.io, DO etc. 
so unless you want a vendor lock-in, you need it. 
for one of my products, I had to migrate due to business reasons 4 times into different kube flavors, from self-manged ( 2 times ) to GKE and EKS.</div><br/><div id="42233878" class="c"><input type="checkbox" id="c-42233878" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233697">parent</a><span>|</span><a href="#42232102">next</a><span>|</span><label class="collapse" for="c-42233878">[-]</label><label class="expand" for="c-42233878">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there are other abstractions, but they are not portable<p>Not true. Unix itself is an API for your cluster too, like the original post implies.<p>Personally, as a &quot;tech lead&quot; I use NixOS. (Yes, I am that guy.)<p>The point is, k8s is a shitty API because it&#x27;s built only for Google&#x27;s &quot;run a huge webapp built on shitty Python scripts&quot; use case.<p>Most people don&#x27;t need this, what they actually want is some way for dev to pass the buck to ops in some way that PM&#x27;s can track on a Gantt chart.</div><br/></div></div></div></div></div></div><div id="42232102" class="c"><input type="checkbox" id="c-42232102" checked=""/><div class="controls bullet"><span class="by">xorcist</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42231318">parent</a><span>|</span><a href="#42233566">prev</a><span>|</span><a href="#42232372">next</a><span>|</span><label class="collapse" for="c-42232102">[-]</label><label class="expand" for="c-42232102">[7 more]</label></div><br/><div class="children"><div class="content">Every item on that list is &quot;boring&quot; tech. Approximately everyone have used load balancers, test environments and monitoring since the 90s just fine. What is it that you think make Kubernetes especially suited for this compared to every other solution during the past three decades?<p>There are good reasons to use Kubernetes, mainly if you are using public clouds and want to avoid lock-in. I may be partial, since managing it pays my bills. But it <i>is</i> complex, mostly unnecessarily so, and no one should be able to say with a straight face that it achieves better uptime or requires less personnel than any alternative. That&#x27;s just sales talk, and should be a big warning sign.</div><br/><div id="42232439" class="c"><input type="checkbox" id="c-42232439" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42232102">parent</a><span>|</span><a href="#42233807">next</a><span>|</span><label class="collapse" for="c-42232439">[-]</label><label class="expand" for="c-42232439">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the way things work together. If you want to add a new service you just annotate that service and DNS gets updated, your ingress gets the route added, cert-manager gets you the certs from let&#x27;s encrypt. You want Prometheus to monitor your pod you just add the right annotation. When your server goes down k8s will move your pod around. k8s storage will take care of having the storage follow your pod. Your entire configuration is highly available and replicated in etcd.<p>It&#x27;s just very different than your legacy &quot;standard&quot; technology.</div><br/><div id="42232908" class="c"><input type="checkbox" id="c-42232908" checked=""/><div class="controls bullet"><span class="by">gr3ml1n</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42232439">parent</a><span>|</span><a href="#42233807">next</a><span>|</span><label class="collapse" for="c-42232908">[-]</label><label class="expand" for="c-42232908">[3 more]</label></div><br/><div class="children"><div class="content">None of this is difficult to do or automate, and we&#x27;ve done it for years.  Kubernetes simply makes it more complex by adding additional abstractions in the pursuit of pretending hardware doesn&#x27;t exist.<p>There are, maybe, a dozen companies in the world with a large enough physical footprint where Kubernetes might make sense.  Everyone else is either engaged in resume-driven development, or has gone down some profoundly wrong path with their application architecture to where it is somehow the lesser evil.</div><br/><div id="42233196" class="c"><input type="checkbox" id="c-42233196" checked=""/><div class="controls bullet"><span class="by">sampullman</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42232908">parent</a><span>|</span><a href="#42233807">next</a><span>|</span><label class="collapse" for="c-42233196">[-]</label><label class="expand" for="c-42233196">[2 more]</label></div><br/><div class="children"><div class="content">I used to feel the same way, but have come around. I think it&#x27;s great for small companies for a few reasons. I can spin up effectively identical dev&#x2F;ci&#x2F;stg&#x2F;prod clusters for a new project in an hour for a medium sized project, with CD in addition to everything GP mentioned.<p>I basically don&#x27;t have to think about ops anymore until something exotic comes up, it&#x27;s nice. I agree that it feels clunky, and it was annoying to learn, but once you have something working it&#x27;s a huge time saver. The ability to scale without drastically changing the system is a bonus.</div><br/><div id="42233681" class="c"><input type="checkbox" id="c-42233681" checked=""/><div class="controls bullet"><span class="by">gr3ml1n</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233196">parent</a><span>|</span><a href="#42233807">next</a><span>|</span><label class="collapse" for="c-42233681">[-]</label><label class="expand" for="c-42233681">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I can spin up effectively identical dev&#x2F;ci&#x2F;stg&#x2F;prod clusters for a new project in an hour for a medium sized project, with CD in addition to everything GP mentioned.<p>I can do the same thing with `make local` invoking a few bash commands.  If the complexity increases beyond that, a mistake has been made.</div><br/></div></div></div></div></div></div></div></div><div id="42233807" class="c"><input type="checkbox" id="c-42233807" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42232102">parent</a><span>|</span><a href="#42232439">prev</a><span>|</span><a href="#42233410">next</a><span>|</span><label class="collapse" for="c-42233807">[-]</label><label class="expand" for="c-42233807">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Every item on that list is &quot;boring&quot; tech. Approximately everyone have used load balancers, test environments and monitoring since the 90s just fine. What is it that you think make Kubernetes especially suited for this compared to every other solution during the past three decades?<p>You could make the same argument against using cloud at all, or against using CI. The point of Kubernetes isn&#x27;t to make those things possible, it&#x27;s to make them easy and consistent.</div><br/></div></div><div id="42233410" class="c"><input type="checkbox" id="c-42233410" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42232102">parent</a><span>|</span><a href="#42233807">prev</a><span>|</span><a href="#42232372">next</a><span>|</span><label class="collapse" for="c-42233410">[-]</label><label class="expand" for="c-42233410">[1 more]</label></div><br/><div class="children"><div class="content">Kubernetes is boring tech as well.<p>And the advantage of it is <i>one</i> way to manage resources, scaling, logging, observability, hardware etc.<p>All of which is stored in Git and so audited, reviewed, versioned, tested etc in exactly the same way.</div><br/></div></div></div></div><div id="42232372" class="c"><input type="checkbox" id="c-42232372" checked=""/><div class="controls bullet"><span class="by">signal11</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42231318">parent</a><span>|</span><a href="#42232102">prev</a><span>|</span><a href="#42231830">next</a><span>|</span><label class="collapse" for="c-42232372">[-]</label><label class="expand" for="c-42232372">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If you answer yes to many of those questions there&#x27;s really no better alternative than k8s.<p>This is not even close to true with even a small number of resources. The notion that k8s somehow is the only choice is right along the lines of “Java Enterprise Edition is the only choice” — ie a real failure of the imagination.<p>For startups and teams with limited resources, DO, fly.io and render are doing lots of interesting work. But what if you can’t use them? Is k8s your only choice?<p>Let’s say you’re a large orgs with good engineering leadership, and you have high-revenue systems where downtime isn’t okay. Also for compliance reasons public cloud isn’t okay.<p>DNS in a tightly controlled large enterprise internal network can be handled with relatively simple microservices. Your org will likely have something already though.<p>Dev&#x2F;Stage&#x2F;Production: if you can spin up instances on demand this is trivial. Also financial services and other regulated biz have been doing this for eons before k8s.<p>Load Balancers: lots of non-k8s options exist (software and hardware appliances).<p>Prometheus &#x2F; Grafana (and things like Netdata) work very well even without k8s.<p>Load Balancing and Ingress is definitely the most interesting piece of the puzzle. Some choose nginx or Envoy, but there’s also teams that use their own ingress solution (sometimes open-sourced!)<p>But why would a team do this? Or more appropriately, why would their management spend on this? Answer: many don’t! But for those that do — the driver is usually cost*, availability and accountability, along with engineering capability as a secondary driver.<p>(*cost because it’s easy to set up a mixed ability team with experienced, mid-career and new engineers for this. You don’t need a team full of kernel hackers.)<p>It costs less than you think, it creates real accountability throughout the stack and most importantly you’ve now got a team of engineers who can rise to any reasonable challenge, and who can be cross pollinated throughout the org. In brief the goal is to have engineers not “k8s implementers” or “OpenShift implementers” or “Cloud Foundry implementers”.</div><br/><div id="42233830" class="c"><input type="checkbox" id="c-42233830" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42232372">parent</a><span>|</span><a href="#42231830">next</a><span>|</span><label class="collapse" for="c-42233830">[-]</label><label class="expand" for="c-42233830">[3 more]</label></div><br/><div class="children"><div class="content">&gt; DNS in a tightly controlled large enterprise internal network can be handled with relatively simple microservices. Your org will likely have something already though.<p>And it will likely be buggy with all sorts of edge cases.<p>&gt; Dev&#x2F;Stage&#x2F;Production: if you can spin up instances on demand this is trivial. Also financial services and other regulated biz have been doing this for eons before k8s.<p>In my experience financial services have been notably <i>not</i> doing it.<p>&gt; Load Balancers: lots of non-k8s options exist (software and hardware appliances).<p>The problem isn&#x27;t running a load balancer with a given configuration at a given point in time. It&#x27;s how you manage the required changes to load balancers and configuration as time goes on. It&#x27;s very common for that to be a pile of perl scripts that add up to an ad-hoc informally specified bug-ridden implementation of half of kubernetes.</div><br/><div id="42233996" class="c"><input type="checkbox" id="c-42233996" checked=""/><div class="controls bullet"><span class="by">signal11</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233830">parent</a><span>|</span><a href="#42231830">next</a><span>|</span><label class="collapse" for="c-42233996">[-]</label><label class="expand" for="c-42233996">[2 more]</label></div><br/><div class="children"><div class="content">&gt; And it will likely be buggy with all sorts of edge cases.<p>I have seen this view in corporate IT teams who’re happy to be “implementers” rather than engineers.<p>In real life, many orgs will in fact have third party vendor products for internal DNS and cert authorities. Writing bridge APIs to these isn’t difficult and it keeps the IT guys happy.<p>A relatively few orgs have written their own APIs, typically to manage a delegated zone. Again, you can say these must be buggy, but here’s the thing — everything’s buggy. Including k8s. As long as bugs are understood and fixed, no one cares. The proof of the pudding is how well it works.<p>Internal DNS in particular is easy enough to control and test if you have  engineers (vs implementers) in your team.<p>&gt; manage changes to load balancers … perl<p>That’s a very black and white view, that teams are either on k8s (which to you is the bees knees) or a pile of Perl (presumably unmaintainable). Speaks to interesting unconscious bias.<p>Perhaps it comes from personal experience, in which case I’m sorry you had to be part of such a team. But it’s not particularly difficult to follow modern best practices and operate your own stack.<p>But if your starter stance is that “k8s is the only way”, no one can talk you out of your own mental hard lines.</div><br/><div id="42234235" class="c"><input type="checkbox" id="c-42234235" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233996">parent</a><span>|</span><a href="#42231830">next</a><span>|</span><label class="collapse" for="c-42234235">[-]</label><label class="expand" for="c-42234235">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Again, you can say these must be buggy, but here’s the thing — everything’s buggy. Including k8s. As long as bugs are understood and fixed, no one cares.<p>Agreed, but internal products are generally buggier, because an internal product is in a kind of monopoly position. You generally want to be using a product that is subject to competition, that is a profit center rather than a cost center for the people who are making it.<p>&gt; Internal DNS in particular is easy enough to control and test if you have engineers (vs implementers) in your team.<p>Your team probably aren&#x27;t DNS experts, and why should they be? You&#x27;re not a DNS company. If you could make a better DNS - or a better DNS-deployment integration - than the pros, you&#x27;d be selling it. (The exception is if you really are a DNS company, either because you actually do sell it, or because you have some deep integration with DNS that enables your competitive advantage)<p>&gt; Perhaps it comes from personal experience, in which case I’m sorry you had to be part of such a team. But it’s not particularly difficult to follow modern best practices and operate your own stack.<p>I&#x27;d say that&#x27;s a contradiction in terms, because modern best practice is to not run your own stack.<p>I don&#x27;t particularly like kubernetes qua kubernetes (indeed I&#x27;d generally pick nomad instead). But I absolutely do think you need a declarative, single-source-of-truth way of managing your full deployment, end-to-end. And if your deployment is made up of a standard load balancer (or an equivalent of one), a standard DNS, and prometheus or grafana, then you&#x27;ve either got one of these products or you&#x27;ve got an internal product that does the same thing, which is something I&#x27;m extremely skeptical of for the same reason as above - if your company was capable of creating a better solution to this standard problem, why wouldn&#x27;t you be selling it? (And if an engineer was capable of creating a better solution to this standard problem, why would they work for you rather than one of the big cloud corps?)<p>In the same way I&#x27;m very skeptical of any company with an &quot;internal cloud&quot; - in my experience such a thing is usually a significantly worse implementation of AWS, and, yes, is usually held together with some flaky Perl scripts. Or an internal load balancer. It&#x27;s generally NIH, or at best a cost-cutting exercise which tends to show; a company might have an internal cloud that&#x27;s cheaper than AWS (I&#x27;ve worked for one), but you&#x27;ll notice the cheapness.<p>Now again, if you really are gaining a competitive advantage from your things then it may make sense to not use a standard solution. But in that case you&#x27;ll have something deeply integrated, i.e. monolithic, and that&#x27;s precisely the case where you&#x27;re not deploying separate standard DNS, separate standard load balancers, separate standard monitoring etc.. And in that case, as grandparent said, not using k8s makes total sense.<p>But if you&#x27;re just deploying a standard Rails (or what have you) app with a standard database, load balancer, DNS, monitoring setup? Then 95% of the time your company can&#x27;t solve that problem better than the companies that are dedicated to solving that problem. Either you don&#x27;t have a solution at all (beyond doing it manually), you use k8s or similar, or you NIH it. Writing custom code to solve custom problems can be smart, but writing custom code to solve standard problems usually isn&#x27;t.</div><br/></div></div></div></div></div></div></div></div><div id="42231830" class="c"><input type="checkbox" id="c-42231830" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42231318">parent</a><span>|</span><a href="#42232372">prev</a><span>|</span><a href="#42231597">next</a><span>|</span><label class="collapse" for="c-42231830">[-]</label><label class="expand" for="c-42231830">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you answer yes to many of those questions there&#x27;s really no better alternative than k8s.<p>Nah, most of that list is basically free for any company that uses an amazon loadbalancer and an autoscale group. In terms of likeliness of incidents, time, and cost, those will each be an order of magnitude higher with a team of kubernetes engineers than less complex setup.</div><br/></div></div></div></div><div id="42231597" class="c"><input type="checkbox" id="c-42231597" checked=""/><div class="controls bullet"><span class="by">a2tech</span><span>|</span><a href="#42227960">parent</a><span>|</span><a href="#42231318">prev</a><span>|</span><a href="#42232684">next</a><span>|</span><label class="collapse" for="c-42231597">[-]</label><label class="expand" for="c-42231597">[8 more]</label></div><br/><div class="children"><div class="content">People really underestimate the power of a shell scripts and ssh and trusted developers.</div><br/><div id="42233139" class="c"><input type="checkbox" id="c-42233139" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42231597">parent</a><span>|</span><a href="#42232684">next</a><span>|</span><label class="collapse" for="c-42233139">[-]</label><label class="expand" for="c-42233139">[7 more]</label></div><br/><div class="children"><div class="content">Besides the fact that shell scripts aren&#x27;t scalable (in terms of horizontal scalability like actor model), I would also like to point out that shell scripts should be simple, but if you want to handle something that big, you essentially and definitely is using it as a programming language in disguise -- not ideal and I would like to go Go or Rust instead.</div><br/><div id="42233486" class="c"><input type="checkbox" id="c-42233486" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233139">parent</a><span>|</span><a href="#42233257">next</a><span>|</span><label class="collapse" for="c-42233486">[-]</label><label class="expand" for="c-42233486">[2 more]</label></div><br/><div class="children"><div class="content">We don&#x27;t live in 1999 any more. A big machine with a database can serve ervyone in the US and I can fit it in my closet.<p>It&#x27;s like people are stuck in the early 2000s when they start thinking about computer capabilities. Today I have more flops in a single GPU under my desk than did the worlds largest super computer in 2004.</div><br/><div id="42233630" class="c"><input type="checkbox" id="c-42233630" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233486">parent</a><span>|</span><a href="#42233257">next</a><span>|</span><label class="collapse" for="c-42233630">[-]</label><label class="expand" for="c-42233630">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s like people are stuck in the early 2000s when they start thinking about computer capabilities.<p>This makes sense, because the code people write makes machines feel like they&#x27;re from the early 2000&#x27;s.<p>This is partially a joke, of course, but I think there is a massive chasm between the people who think you immediately need several computers to do things for anything other than redundancy, and the people who see how ridiculously much you can do with one.</div><br/></div></div></div></div><div id="42233257" class="c"><input type="checkbox" id="c-42233257" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233139">parent</a><span>|</span><a href="#42233486">prev</a><span>|</span><a href="#42232684">next</a><span>|</span><label class="collapse" for="c-42233257">[-]</label><label class="expand" for="c-42233257">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Besides the fact that shell scripts aren&#x27;t scalable…<p>What are you trying to say there? My understanding is that, way under the hood, a set of shell scripts is in fact enabling the scalable nature of… the internet.</div><br/><div id="42233818" class="c"><input type="checkbox" id="c-42233818" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233257">parent</a><span>|</span><a href="#42233382">next</a><span>|</span><label class="collapse" for="c-42233818">[-]</label><label class="expand" for="c-42233818">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My understanding is that, way under the hood, a set of shell scripts is in fact enabling the scalable nature of… the internet.<p>I sure hope not. The state of error handling in shell scripts alone is enough to disqualify them for serious production systems.<p>If you&#x27;re extremely smart and disciplined it&#x27;s theoretically possible to write a shell script that handles error states correctly. But there are better things to spend your discipline budget on.</div><br/></div></div><div id="42233370" class="c"><input type="checkbox" id="c-42233370" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42233257">parent</a><span>|</span><a href="#42233382">prev</a><span>|</span><a href="#42232684">next</a><span>|</span><label class="collapse" for="c-42233370">[-]</label><label class="expand" for="c-42233370">[1 more]</label></div><br/><div class="children"><div class="content">...that&#x27;s only for early internet, and the early internet is effing broken at best</div><br/></div></div></div></div></div></div></div></div><div id="42232684" class="c"><input type="checkbox" id="c-42232684" checked=""/><div class="controls bullet"><span class="by">starttoaster</span><span>|</span><a href="#42227960">parent</a><span>|</span><a href="#42231597">prev</a><span>|</span><a href="#42227993">next</a><span>|</span><label class="collapse" for="c-42232684">[-]</label><label class="expand" for="c-42232684">[1 more]</label></div><br/><div class="children"><div class="content">On the other hand, my team slapped 3 servers down in a datacenter, had each of them configured in a Proxmox cluster within a few hours. Some 8-10 hours later we had a fully configured kubernetes cluster running within Proxmox VMs, where the VMs and k8s cluster are created and configured using an automation workflow that we have running in GitHub Actions. An hour or two worth of work later we had several deployments running on it and serving requests.<p>Kubernetes is not simple. In fact it&#x27;s even more complex than just running an executable with your linux distro&#x27;s init system. The difference in my mind is that it&#x27;s more complex for the system maintainer, but less complex for the person deploying workloads to it.<p>And that&#x27;s before exploring all the benefits of kubernetes-ecosystem tooling like the Prometheus operator for k8s, or the horizontally scalable Loki deployments, for centrally collecting infrastructure and application metrics, and logs. In my mind, making the most of these kinds of tools, things start to look a bit easier even for the systems maintainers.<p>Not trying to discount your workplace too much. But I&#x27;d wager there&#x27;s a few people that are maybe not owning up to the fact that it&#x27;s their first time messing around with kubernetes.</div><br/></div></div><div id="42227993" class="c"><input type="checkbox" id="c-42227993" checked=""/><div class="controls bullet"><span class="by">loftsy</span><span>|</span><a href="#42227960">parent</a><span>|</span><a href="#42232684">prev</a><span>|</span><a href="#42232517">next</a><span>|</span><label class="collapse" for="c-42227993">[-]</label><label class="expand" for="c-42227993">[19 more]</label></div><br/><div class="children"><div class="content">Are you self hosting kubernetes or running it managed?<p>I&#x27;ve only used it managed. There is a bit of a learning curve but it&#x27;s not so bad. I can&#x27;t see how it can take 4 months to figure it out.</div><br/><div id="42228024" class="c"><input type="checkbox" id="c-42228024" checked=""/><div class="controls bullet"><span class="by">zug_zug</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42227993">parent</a><span>|</span><a href="#42228402">next</a><span>|</span><label class="collapse" for="c-42228024">[-]</label><label class="expand" for="c-42228024">[16 more]</label></div><br/><div class="children"><div class="content">We are using EKS<p>&gt; I can&#x27;t see how it can take 4 months to figure it out.<p>Well have you ever tried moving a company with a dozen services onto kubernetes piece-by-piece, with zero downtime? How long would it take you to correctly move and test every permission, environment variable, and issue you run into?<p>Then if you get a single setting wrong (e.g. memory size) and don&#x27;t load-test with realistic traffic, you bring down production, potentially lose customers, and have to do a public post-mortem about your mistakes? [true story for current employer]<p>I don&#x27;t see how anybody says they&#x27;d move a large company to kubernetes in such an environment in a few months with no screwups and solid testing.</div><br/><div id="42230319" class="c"><input type="checkbox" id="c-42230319" checked=""/><div class="controls bullet"><span class="by">Cpoll</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228024">parent</a><span>|</span><a href="#42228305">next</a><span>|</span><label class="collapse" for="c-42230319">[-]</label><label class="expand" for="c-42230319">[3 more]</label></div><br/><div class="children"><div class="content">It sounds like it&#x27;s not easy to figure out the permissions, envvars, memory size, etc. of your <i>existing</i> system, and that&#x27;s why the migration is so difficult? That&#x27;s not really one of Kubernetes&#x27; (many) failings.</div><br/><div id="42230668" class="c"><input type="checkbox" id="c-42230668" checked=""/><div class="controls bullet"><span class="by">Vegenoid</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42230319">parent</a><span>|</span><a href="#42230985">next</a><span>|</span><label class="collapse" for="c-42230668">[-]</label><label class="expand" for="c-42230668">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and now we are back at the ancestor comment’s original point: “at the end of the day kubernetes feels like complexity trying to abstract over complexity, and often I find that&#x27;s less successful that removing complexity in the first place”<p>Which I understand to mean “some people think using Kubernetes will make managing a system easier, but it often will not do that”</div><br/></div></div><div id="42230985" class="c"><input type="checkbox" id="c-42230985" checked=""/><div class="controls bullet"><span class="by">Pedro_Ribeiro</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42230319">parent</a><span>|</span><a href="#42230668">prev</a><span>|</span><a href="#42228305">next</a><span>|</span><label class="collapse" for="c-42230985">[-]</label><label class="expand" for="c-42230985">[1 more]</label></div><br/><div class="children"><div class="content">Can you elaborate on other things you think Kubernetes gets wrong? Asking out of curiosity because I haven&#x27;t delved deep into it.</div><br/></div></div></div></div><div id="42228305" class="c"><input type="checkbox" id="c-42228305" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228024">parent</a><span>|</span><a href="#42230319">prev</a><span>|</span><a href="#42228180">next</a><span>|</span><label class="collapse" for="c-42228305">[-]</label><label class="expand" for="c-42228305">[1 more]</label></div><br/><div class="children"><div class="content">Took us three-four years to go from self hosted multi-dc to getting the main product almost fully in k8s (some parts didn&#x27;t make sense in k8s and was pushed to our geo-distributed edge nodes). Dozens of services and teams and keeping the old stuff working while changing the tire on the car while driving. All while the company continues to grow and scale doubles every year or so. It takes maturity in testing and monitoring and it takes longer that everyone estimates</div><br/></div></div><div id="42228180" class="c"><input type="checkbox" id="c-42228180" checked=""/><div class="controls bullet"><span class="by">tail_exchange</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228024">parent</a><span>|</span><a href="#42228305">prev</a><span>|</span><a href="#42228203">next</a><span>|</span><label class="collapse" for="c-42228180">[-]</label><label class="expand" for="c-42228180">[6 more]</label></div><br/><div class="children"><div class="content">It largely depends how customized each microservice is, and how many people are working on this project.<p>I&#x27;ve seen migrations of thousands of microservices happening with the span of two years. Longer timeline, yes, but the number of microservices is orders of magnitude larger.<p>Though I suppose the organization works differently at this level. The Kubernetes team build a tool to migrate the microservices, and each owner was asked to perform the migration themselves. Small microservices could be migrated in less than three days, while the large and risk-critical ones took a couple weeks. This all happened in less than two years, but it took more than that in terms of engineer&#x2F;weeks.<p>The project was very successful though. The company spends way less money now because of the autoscaling features, and the ability to run multiple microservices in the same node.<p>Regardless, if the company is running 12 microservices and this number is expected to grow, this is probably a good time to migrate. How did they account for the different shape of services (stateful, stateless, leader elected, cron, etc), networking settings, styles of deployment (blue-green, rolling updates, etc), secret management, load testing, bug bashing, gradual rollouts, dockerizing the containers, etc? If it&#x27;s taking 4x longer than originally anticipated, it seems like there was a massive failure in project design.</div><br/><div id="42228544" class="c"><input type="checkbox" id="c-42228544" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228180">parent</a><span>|</span><a href="#42228203">next</a><span>|</span><label class="collapse" for="c-42228544">[-]</label><label class="expand" for="c-42228544">[5 more]</label></div><br/><div class="children"><div class="content">2000 products sounds like you made 2000 engineers learn kubernetes (a week, optimistically, 2000&#x2F;52 = 38 engineer years, or roughly one wasted career).<p>Similarly, the actual migration times you estimate add up to decades of engineer time.<p>It’s possible kubernetes saves more time than using the alternative costs, but that definitely wasn’t the case at my previous two jobs.  The jury is out at the current job.<p>I see the opportunity cost of this stuff every day at work, and am patiently waiting for a replacement.</div><br/><div id="42228564" class="c"><input type="checkbox" id="c-42228564" checked=""/><div class="controls bullet"><span class="by">tail_exchange</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228544">parent</a><span>|</span><a href="#42228582">next</a><span>|</span><label class="collapse" for="c-42228564">[-]</label><label class="expand" for="c-42228564">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 2000 products sounds like you made 2000 engineers learn kubernetes (a week, optimistically, 2000&#x2F;52 = 38 engineer years, or roughly one wasted career).<p>Not really, they only had to use the tool to run the migration and then validate that it worked properly. As the other commenter said, a very basic setup for kubernetes is not that hard; the difficult set up is left to the devops team, while the service owners just need to see the basics.<p>But sure, we can estimate it at 38 engineering years. That&#x27;s still 38 years for 2,000 microservices; it&#x27;s way better than 1 year for 12 microservices like in OP&#x27;s case. Savings that we got was enough to offset these 38 years of work, so this project is now paying dividends.</div><br/></div></div><div id="42228582" class="c"><input type="checkbox" id="c-42228582" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228544">parent</a><span>|</span><a href="#42228564">prev</a><span>|</span><a href="#42228203">next</a><span>|</span><label class="collapse" for="c-42228582">[-]</label><label class="expand" for="c-42228582">[3 more]</label></div><br/><div class="children"><div class="content">&gt; 2000 products sounds like you made 2000 engineers learn kubernetes (a week, optimistically, 2000&#x2F;52 = 38 engineer years, or roughly one wasted career).<p>Learning k8s enough to be able to work with it isn&#x27;t <i>that</i> hard. Have a centralized team write up a decent template for a CI&#x2F;CD pipeline, Dockerfile for the most common stacks you use and a Helm chart with an example for a Deployment, PersistentVolumeClaim, Service and Ingress, distribute that, and be available for support should the need for Kubernetes be beyond &quot;we need 1-N pods for this service, they got some environment variables from which they are configured, and maybe a Secret&#x2F;ConfigMap if the application rather wants configuration to be done in files&quot; is enough in my experience.</div><br/><div id="42228765" class="c"><input type="checkbox" id="c-42228765" checked=""/><div class="controls bullet"><span class="by">relaxing</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228582">parent</a><span>|</span><a href="#42228203">next</a><span>|</span><label class="collapse" for="c-42228765">[-]</label><label class="expand" for="c-42228765">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Learning k8s enough to be able to work with it isn&#x27;t that hard.<p>I’ve seen a lot of people learn enough k8s to be dangerous.<p>Learning it well enough to not get wrapped around the axle with some networking or storage details is quite a bit harder.</div><br/><div id="42228808" class="c"><input type="checkbox" id="c-42228808" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228765">parent</a><span>|</span><a href="#42228203">next</a><span>|</span><label class="collapse" for="c-42228808">[-]</label><label class="expand" for="c-42228808">[1 more]</label></div><br/><div class="children"><div class="content">For sure but that&#x27;s the job of a good ops department - where I work at for example, every project&#x27;s CI&#x2F;CD pipeline has its own IAM user mapping to a Kubernetes role that only has explicitly defined capabilities: create, modify and delete just the utter basics. Even if they&#x27;d commit something into the Helm chart that could cause an annoyance, the service account wouldn&#x27;t be able to call the required APIs. And the templates themselves come with security built-in - privileges are all explicitly dropped, pod UIDs&#x2F;GIDs hardcoded to non-root, and we&#x27;re deploying Network Policies at least for ingress as well now. Only egress network policies aren&#x27;t available, we haven&#x27;t been able to make these work with services.<p>Anyone wishing to do stuff like use the RDS database provisioner gets an introduction from us on how to use it and what the pitfalls are, and regular reviews of their code. They&#x27;re flexible but we keep tabs on what they&#x27;re doing, and when they have done something useful we aren&#x27;t shy from integrating whatever they have done to our shared template repository.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42228203" class="c"><input type="checkbox" id="c-42228203" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228024">parent</a><span>|</span><a href="#42228180">prev</a><span>|</span><a href="#42228266">next</a><span>|</span><label class="collapse" for="c-42228203">[-]</label><label class="expand" for="c-42228203">[1 more]</label></div><br/><div class="children"><div class="content">Comparing the simplicity of two PHP servers against a setup with a dozen services is always going to be one sided. The difference in complexity alone is massive, regardless of whether you use k8s or not.<p>My current employer did something similar, but with fewer services. The upshot is that with terraform and helm and all the other yaml files defining our cluster, we have test environments on demand, and our uptime is 100x better.</div><br/></div></div><div id="42228266" class="c"><input type="checkbox" id="c-42228266" checked=""/><div class="controls bullet"><span class="by">loftsy</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228024">parent</a><span>|</span><a href="#42228203">prev</a><span>|</span><a href="#42228199">next</a><span>|</span><label class="collapse" for="c-42228266">[-]</label><label class="expand" for="c-42228266">[2 more]</label></div><br/><div class="children"><div class="content">Fair enough that sounds hard.<p>Memory size is an interesting example. A typical Kubernetes deployment has much more control over this than a typical non-container setup. It is costing you to figure out the right setting but in the long term you are rewarded with a more robust and more re-deployable application.</div><br/><div id="42233828" class="c"><input type="checkbox" id="c-42233828" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228266">parent</a><span>|</span><a href="#42228199">next</a><span>|</span><label class="collapse" for="c-42233828">[-]</label><label class="expand" for="c-42233828">[1 more]</label></div><br/><div class="children"><div class="content">&gt; has much more control over this than a typical non-container setup<p>Actually not true, k8s uses the exact same cgroups API for this under the hood that systemd does.</div><br/></div></div></div></div><div id="42228199" class="c"><input type="checkbox" id="c-42228199" checked=""/><div class="controls bullet"><span class="by">jrs235</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228024">parent</a><span>|</span><a href="#42228266">prev</a><span>|</span><a href="#42230406">next</a><span>|</span><label class="collapse" for="c-42228199">[-]</label><label class="expand" for="c-42228199">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t see how anybody says they&#x27;d move a large company to kubernetes in such an environment in a few months with no screwups and solid testing.<p>Unfortunately, I do. Somebody says that when the culture of the organization expects to be told and hear what they want to hear rather than the cold hard truth. And likely the person saying that says it from a perch up high and not responsible for the day to day work of actually implementing the change. I see this happen when the person, management&#x2F;leadership, lacks the skills and knowledge to perform the work themselves. They&#x27;ve never been in the trenches and had to actually deal face to face with the devil in the details.</div><br/></div></div><div id="42230406" class="c"><input type="checkbox" id="c-42230406" checked=""/><div class="controls bullet"><span class="by">malux85</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228024">parent</a><span>|</span><a href="#42228199">prev</a><span>|</span><a href="#42228402">next</a><span>|</span><label class="collapse" for="c-42230406">[-]</label><label class="expand" for="c-42230406">[1 more]</label></div><br/><div class="children"><div class="content">Canary deploy dude (or dude-ette), route 0.001% of service traffic and then slowly move it over. Then set error budgets. Then a bad service wont &quot;bring down production&quot;.<p>Thats how we did it at Google (I was part of the core team responsible for ad serving infra - billions of ads to billions of users a day)</div><br/></div></div></div></div><div id="42228402" class="c"><input type="checkbox" id="c-42228402" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42227993">parent</a><span>|</span><a href="#42228024">prev</a><span>|</span><a href="#42232517">next</a><span>|</span><label class="collapse" for="c-42228402">[-]</label><label class="expand" for="c-42228402">[2 more]</label></div><br/><div class="children"><div class="content">Using microk8s or k3s on one node works fine. As the author of &quot;one big server,&quot; I am now working on an application that needs some GPUs and needs to be able to deploy on customer hardware, so k8s is natural. Our own hosted product runs on 2 servers, but it&#x27;s ~10 containers (including databases, etc).</div><br/><div id="42231811" class="c"><input type="checkbox" id="c-42231811" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42228402">parent</a><span>|</span><a href="#42232517">next</a><span>|</span><label class="collapse" for="c-42231811">[-]</label><label class="expand" for="c-42231811">[1 more]</label></div><br/><div class="children"><div class="content">Yup, I like this approach a lot.  With cloud providers considering VMs durable these days (they get new hardware for your VM if the hardware it&#x27;s on dies, without dropping any TCP connections), I think a 1 node approach is enough for small things.  You can get like 192 vCPUs per node.  This is enough for a lot of small companies.<p>I occasionally try non-k8s approaches to see what I&#x27;m missing.  I have a small ARM machine that runs Home Assistant and some other stuff.  My first instinct was to run k8s (probably kind honestly), but didn&#x27;t really want to write a bunch of manifests and let myself scope creep to running ArgoCD.  I decided on `podman generate systemd` instead (with nightly re-pulls of the &quot;latest&quot; tag; I live and die by the bleeding edge).  This was OK, until I added zwavejs, and now the versions sometimes get out of sync, which I notice by a certain light switch not working anymore.  What I should have done instead was have some sort of git repository where I have the versions of these two things, and to update them atomically both at the exact same time.  Oh wow, I really <i>did</i> need ArgoCD and Kubernetes ;)<p>I get by with podman by angrily ssh-ing in in my winter jacket when I&#x27;m trying to leave my house but can&#x27;t turn the lights off.  Maybe this can be blamed on auto-updates, but frankly anything exposed to a network that is out of date is also a risk, so, I don&#x27;t think you can ever really win.</div><br/></div></div></div></div></div></div><div id="42232517" class="c"><input type="checkbox" id="c-42232517" checked=""/><div class="controls bullet"><span class="by">nouripenny</span><span>|</span><a href="#42227960">parent</a><span>|</span><a href="#42227993">prev</a><span>|</span><a href="#42234252">next</a><span>|</span><label class="collapse" for="c-42232517">[-]</label><label class="expand" for="c-42232517">[1 more]</label></div><br/><div class="children"><div class="content">I think porting to k8s can succeed or fail, like any other project. I switched an app that I alone worked on, from Elastic Beanstalk (with Bash), to Kubernetes (with Babashka&#x2F;Clojure). It didn&#x27;t seem bad. I think k8s is basically a well-designed solution. I think of it as a declarative language which is sent to interpreters in k8s&#x27;s control plane.<p>Obviously, some parts of took a while to figure out. For example, I needed to figure out an AWS security group problem with Ingress objects, that I recall wasn&#x27;t well-documented. So I think parts of that declarative language can suck, if the declarative parts aren&#x27;t well factored-out from the imperative parts. Or if the log messages don&#x27;t help you diagnose errors, or if there isn&#x27;t some kind of (dynamic?) linter that helps you notice problems quickly<p>In your team&#x27;s case, more information seems needed to help us evaluate the problems. Why was it easier before to make testing environments, and harder now?</div><br/></div></div><div id="42234252" class="c"><input type="checkbox" id="c-42234252" checked=""/><div class="controls bullet"><span class="by">arkh</span><span>|</span><a href="#42227960">parent</a><span>|</span><a href="#42232517">prev</a><span>|</span><a href="#42227965">next</a><span>|</span><label class="collapse" for="c-42234252">[-]</label><label class="expand" for="c-42234252">[1 more]</label></div><br/><div class="children"><div class="content">So, my current experience somewhere most old apps are very old school:<p>- most server software is waaaaaaay out of date so getting a dev &#x2F; test env is a little harder (like last problem we got was the HAproxy version does not do ECDA keys for ssl certs, which is the default with certbot)
 - yeah pushing to prod is &quot;easy&quot;: FTP directly. But now which version of which files are really in prod? No idea. Yeah when I say old school it&#x27;s old school before things like Jenkins.
 - need something done around the servers? That&#x27;s the OPS team job. Team which also has too much different work to do so now you&#x27;ll have to wait a week or two for this simple &quot;add an upload file&quot; endpoint to this old API because you need somewhere to put those files.<p>Now we&#x27;ve started setting up some on-prem k8s nodes for the new developments. Not because we need crazy scaling but so the dev team can do most OPS they need. It takes time to have everything setup but once it started chugging along it felt good to be able to just declare whatever we need and get it.
You still need to get the devs to learn k8s which is not fun but that&#x27;s the life of a dev: learning new things every day.<p>Also k8s does not do data. You want a database or anything managing files: you want to do most of the job outside k8s.</div><br/></div></div><div id="42227965" class="c"><input type="checkbox" id="c-42227965" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#42227960">parent</a><span>|</span><a href="#42234252">prev</a><span>|</span><a href="#42231411">next</a><span>|</span><label class="collapse" for="c-42227965">[-]</label><label class="expand" for="c-42227965">[2 more]</label></div><br/><div class="children"><div class="content">Yea but that doesn&#x27;t sound shiny on your resume.</div><br/><div id="42228377" class="c"><input type="checkbox" id="c-42228377" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#42227960">root</a><span>|</span><a href="#42227965">parent</a><span>|</span><a href="#42231411">next</a><span>|</span><label class="collapse" for="c-42228377">[-]</label><label class="expand" for="c-42228377">[1 more]</label></div><br/><div class="children"><div class="content">Depends on what kind of company you want to join. Some value simplicity and efficiency more.</div><br/></div></div></div></div></div></div><div id="42233109" class="c"><input type="checkbox" id="c-42233109" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#42227960">prev</a><span>|</span><a href="#42228145">next</a><span>|</span><label class="collapse" for="c-42233109">[-]</label><label class="expand" for="c-42233109">[4 more]</label></div><br/><div class="children"><div class="content">Kubernetes is so easy that you only need two or three dedicated full-time employees to keep the mountains of YAML from collapsing in on themselves before cutting costs and outsourcing your cluster management to someone else.<p>Sure, it can be easy, just pick one of the many cloud providers that fix all the complicated parts for you. Though, when you do that, expect to pay extra for the privilege, and maybe take a look at the much easier proprietary alternatives. In theory the entire thing is portable enough that you can just switch hosting providers, in practice you&#x27;re never going to be able to do that without seriously rewriting part of your stack anyway.<p>The worst part is that the mountains of YAML were never supposed to be written by humans anyway, they&#x27;re readable configuration your tooling is supposed to generate for you. You still need your bash scripts and your complicated deployment strategies, but rather than using them directly you&#x27;re supposed to compile them into YAML first.<p>Kubernetes is nice and all but it&#x27;s not worth the effort for the vast majority of websites and services. WordPress works just fine without automatic replication and end-to-end microservice TLS encryption.</div><br/><div id="42233984" class="c"><input type="checkbox" id="c-42233984" checked=""/><div class="controls bullet"><span class="by">hmottestad</span><span>|</span><a href="#42233109">parent</a><span>|</span><a href="#42233717">next</a><span>|</span><label class="collapse" for="c-42233984">[-]</label><label class="expand" for="c-42233984">[1 more]</label></div><br/><div class="children"><div class="content">I went down the Kubernetes path. The product I picked 4 years ago is no longer maintained :(<p>The biggest breaking change to docker compose since it was introduced was that the docker-compose command stopped working and I had to switch to «docker compose» with a space. Had I stuck with docker and docker-compose I could have trivially kept everything up to date and running smoothly.</div><br/></div></div><div id="42233717" class="c"><input type="checkbox" id="c-42233717" checked=""/><div class="controls bullet"><span class="by">maxdo</span><span>|</span><a href="#42233109">parent</a><span>|</span><a href="#42233984">prev</a><span>|</span><a href="#42228145">next</a><span>|</span><label class="collapse" for="c-42233717">[-]</label><label class="expand" for="c-42233717">[2 more]</label></div><br/><div class="children"><div class="content">I ran small bootstrapped startup , I used GKE. Everything was templated.<p>each app has it&#x27;s own template e.g. nodejs-worker, and you don&#x27;t change the template unless you really needed.<p>i spent ~2% of my manger+eng leader+hiring manger+ god knows what else people do at startup on managing 100+ microservices because they were templates.</div><br/><div id="42233904" class="c"><input type="checkbox" id="c-42233904" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42233109">root</a><span>|</span><a href="#42233717">parent</a><span>|</span><a href="#42228145">next</a><span>|</span><label class="collapse" for="c-42233904">[-]</label><label class="expand" for="c-42233904">[1 more]</label></div><br/><div class="children"><div class="content">That works great until you want to change something low-level and have to apply it to all those templates.</div><br/></div></div></div></div></div></div><div id="42228145" class="c"><input type="checkbox" id="c-42228145" checked=""/><div class="controls bullet"><span class="by">elktown</span><span>|</span><a href="#42233109">prev</a><span>|</span><a href="#42233179">next</a><span>|</span><label class="collapse" for="c-42228145">[-]</label><label class="expand" for="c-42228145">[6 more]</label></div><br/><div class="children"><div class="content">This is so unnuanced that it reads like rationalization to me. People seem to get stuck on mantras that simple things are inherently fragile which isn&#x27;t really true, or at least not particularly more fragile than navigating a jungle of yaml files and k8s cottage industry products that link together in arcane ways and tend to be very hard to debug, or just to understand all the moving parts involved in the flow of a request and thus what can go wrong. I get the feeling that they mostly just don&#x27;t like that it doesn&#x27;t have <i>professional aesthetics</i>.</div><br/><div id="42228316" class="c"><input type="checkbox" id="c-42228316" checked=""/><div class="controls bullet"><span class="by">nbk_2000</span><span>|</span><a href="#42228145">parent</a><span>|</span><a href="#42228745">next</a><span>|</span><label class="collapse" for="c-42228316">[-]</label><label class="expand" for="c-42228316">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of the famous Taco Bell Programming post [1]. Simple can surprisingly often be good enough.<p>[1] <a href="http:&#x2F;&#x2F;widgetsandshit.com&#x2F;teddziuba&#x2F;2010&#x2F;10&#x2F;taco-bell-programming.html" rel="nofollow">http:&#x2F;&#x2F;widgetsandshit.com&#x2F;teddziuba&#x2F;2010&#x2F;10&#x2F;taco-bell-progra...</a></div><br/></div></div><div id="42228745" class="c"><input type="checkbox" id="c-42228745" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#42228145">parent</a><span>|</span><a href="#42228316">prev</a><span>|</span><a href="#42233179">next</a><span>|</span><label class="collapse" for="c-42228745">[-]</label><label class="expand" for="c-42228745">[4 more]</label></div><br/><div class="children"><div class="content">&gt; People seem to get stuck on mantras that simple things are inherently fragile which isn&#x27;t really true...<p>Ofc it isn&#x27;t true.<p>Kubernetes was designed at Google at a time when Google was already a behemoth. 99.99% of all startups and SMEs out there shall <i>never ever</i> have the same scaling issues and automation needs that Google has.<p>Now that said... When you begin running VMs and containers, even only a very few of them, you immediately run into issues and then you begin to think: <i>&quot;Kubernetes is the solution&quot;</i>. And it is. But it is also, in many cases, a solution to a problem you created. Still... the justification for creating that problem, if you&#x27;re not Google scale, are highly disputable.<p>And, deep down, there&#x27;s another very fundamental issue IMO: many of those &quot;let&#x27;s have only one process in one container&quot; solutions actually mean <i>&quot;we&#x27;re totally unable to write portable software working on several configs, so let&#x27;s start with a machine with zero libs and dependencies and install exactly the minimum deps needed to make our ultra-fragile piece of shit of a software kinda work. And because it&#x27;s still going to be a brittle piece of shit, let&#x27;s make sure we use heartbeats and try to shut it down and back up again once it&#x27;ll invariably have memory leaked and&#x2F;or whatnots&quot;</i>.<p>Then you also gained the right to be sloppy in the software you write: not respecting it. Treating it as cattle to be slaughtered, so it can be shitty. But you&#x27;ve now added an insane layer of complexity.<p>How do you like your uninitialized var when a container launchs but then silently doesn&#x27;t work as expected? How do you like them logs in that case? Someone here as described the lack of instant failure on any uninitialized var as the &quot;billion dollar mistake of the devops world&quot;.<p>Meanwhile look at some proper software like, say, the Linux kernel or a distro like Debian. Or compile Emacs or a browser from source and <i>marvel</i> at what&#x27;s happening. Sure, there may be hickups but it works. On many configs. On many different hardware. On many different architectures. These are robust software that don&#x27;t need to be &quot;pid 1 on a pristine filesystem&quot; to work properly.<p>In a way this whole <i>&quot;let&#x27;s have all our software each as pid 1 each on a pristine OS and filesystem&quot;</i> is an admission of a very deep and profound failure of our entire field.<p>I don&#x27;t think it&#x27;s something to be celebrated.<p>And don&#x27;t get me started on security: you know have ultra complicated LANs and VLANs, with a near impossible to monitor traffic, with shitloads of ports open everywhere, the most gigantic attack surface of them all and heartbeats and whatsnots constantly polluting the network, where nobody doesn&#x27;t even know anymore what&#x27;s going on. Where the only actual security seems to rely on the firewall being up and correctly configured, which is incredibly complicated to do seen the insane network complexity you added to your stack. <i>&quot;Oh wait, I have an idea, let&#x27;s make configuring the firewall a service!&quot;</i> (and make sure to not forget to initialize one of the countless var or it&#x27;ll all silently break and just be not be configuring firewalling for anything).<p>Now though love is true love: even at home I&#x27;m running an hypervisor with VMs and OCI containers ; )</div><br/><div id="42232630" class="c"><input type="checkbox" id="c-42232630" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42228145">root</a><span>|</span><a href="#42228745">parent</a><span>|</span><a href="#42232478">next</a><span>|</span><label class="collapse" for="c-42232630">[-]</label><label class="expand" for="c-42232630">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Meanwhile look at some proper software like, say, the Linux kernel or a distro like Debian. Or compile Emacs or a browser from source and marvel at what&#x27;s happening. Sure, there may be hickups but it works. On many configs. On many different hardware. On many different architectures. These are robust software<p>Lol no. The build systems flake out if you look at them funny. The build requirements are whatever Joe in Nebraska happened to have installed on his machine that day (I mean sure there&#x27;s a text file supposedly listing them, but it hasn&#x27;t been accurate for 6 years). They list systems that they haven&#x27;t <i>actually</i> supported for <i>years</i>, because no-one&#x27;s actually testing them.<p>I hate containers as much as anyone, but the state of &quot;native&quot; unix software is even worse.</div><br/></div></div><div id="42232478" class="c"><input type="checkbox" id="c-42232478" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#42228145">root</a><span>|</span><a href="#42228745">parent</a><span>|</span><a href="#42232630">prev</a><span>|</span><a href="#42231600">next</a><span>|</span><label class="collapse" for="c-42232478">[-]</label><label class="expand" for="c-42232478">[1 more]</label></div><br/><div class="children"><div class="content">+1 for talking about attack surface. Every service is a potential gateway for bad people. Locking them all down is incredibly difficult to get right.<p>99.99% of startups and SMEs should not be writing microservices.<p>But &quot;I wrote a commercial system that served thousands of users, it ran on a single process on a spare box out the back&quot; doesn&#x27;t look good on resumes.</div><br/></div></div><div id="42231600" class="c"><input type="checkbox" id="c-42231600" checked=""/><div class="controls bullet"><span class="by">Moru</span><span>|</span><a href="#42228145">root</a><span>|</span><a href="#42228745">parent</a><span>|</span><a href="#42232478">prev</a><span>|</span><a href="#42233179">next</a><span>|</span><label class="collapse" for="c-42231600">[-]</label><label class="expand" for="c-42231600">[1 more]</label></div><br/><div class="children"><div class="content">I sense a lot of painful insights written in blood here.</div><br/></div></div></div></div></div></div><div id="42233179" class="c"><input type="checkbox" id="c-42233179" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#42228145">prev</a><span>|</span><a href="#42230273">next</a><span>|</span><label class="collapse" for="c-42233179">[-]</label><label class="expand" for="c-42233179">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m giggling at the idea you&#x27;d need Kubernetes for a mere two servers. We don&#x27;t run any application with <i>less</i> than two instances for redundancy.<p>We&#x27;ve just never seen the need for Kubernetes. We&#x27;re not against it as much as the need to replace our working setup just never arrived. We run EC2 instances with a setup shell script under 50loc. We autoscale up to 40-50 web servers at peak load of a little over 100k concurrent users.<p>Different strokes for different folks but moreso if it ain&#x27;t broke, don&#x27;t fix it</div><br/></div></div><div id="42230273" class="c"><input type="checkbox" id="c-42230273" checked=""/><div class="controls bullet"><span class="by">danjl</span><span>|</span><a href="#42233179">prev</a><span>|</span><a href="#42228164">next</a><span>|</span><label class="collapse" for="c-42230273">[-]</label><label class="expand" for="c-42230273">[29 more]</label></div><br/><div class="children"><div class="content">I love that the only alternative is a &quot;pile of shell scripts&quot;. Nobody has posted a legitimate alternative to the complexity of K8S or the simplicity of doctor compose. Certainly feels like there&#x27;s a gap in the market for an opinionated deployment solution that works locally and on the cloud, with less functionality than K8S and a bit more complexity than docker compose.</div><br/><div id="42230350" class="c"><input type="checkbox" id="c-42230350" checked=""/><div class="controls bullet"><span class="by">drewbailey</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42231625">next</a><span>|</span><label class="collapse" for="c-42230350">[-]</label><label class="expand" for="c-42230350">[3 more]</label></div><br/><div class="children"><div class="content">K8s just drowns out all other options. Hashicorp Nomad is great, <a href="https:&#x2F;&#x2F;www.nomadproject.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.nomadproject.io&#x2F;</a></div><br/><div id="42234060" class="c"><input type="checkbox" id="c-42234060" checked=""/><div class="controls bullet"><span class="by">NomadConfig</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42230350">parent</a><span>|</span><a href="#42230901">next</a><span>|</span><label class="collapse" for="c-42234060">[-]</label><label class="expand" for="c-42234060">[1 more]</label></div><br/><div class="children"><div class="content">Nomad was amazing at every step of my experiments on it, except one. Simply including a file from the Nomad control to the Nomad host is... impossible? I saw indications of how to tell the host to get it from a file host, and I saw people complaining that they had to do it through the file host, with the response being security (I have thoughts about this and so did the complainants).<p>I was rather baffled to an extent. I was just trying to push a configuration file that would be the primary difference between a couple otherwise samey apps.</div><br/></div></div><div id="42230901" class="c"><input type="checkbox" id="c-42230901" checked=""/><div class="controls bullet"><span class="by">marvinblum</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42230350">parent</a><span>|</span><a href="#42234060">prev</a><span>|</span><a href="#42231625">next</a><span>|</span><label class="collapse" for="c-42230901">[-]</label><label class="expand" for="c-42230901">[1 more]</label></div><br/><div class="children"><div class="content">Thumbs up for Nomad. We&#x27;ve been running it for about 3 years in prod now and it hasn&#x27;t failed us a single time.</div><br/></div></div></div></div><div id="42231625" class="c"><input type="checkbox" id="c-42231625" checked=""/><div class="controls bullet"><span class="by">nikeee</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42230350">prev</a><span>|</span><a href="#42230860">next</a><span>|</span><label class="collapse" for="c-42231625">[-]</label><label class="expand" for="c-42231625">[1 more]</label></div><br/><div class="children"><div class="content">Docker Swarm is exactly what tried to fill that niche. It&#x27;s basically an extension to Docker Compose that adds clustering support and overlay networks.</div><br/></div></div><div id="42230860" class="c"><input type="checkbox" id="c-42230860" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42231625">prev</a><span>|</span><a href="#42231474">next</a><span>|</span><label class="collapse" for="c-42230860">[-]</label><label class="expand" for="c-42230860">[4 more]</label></div><br/><div class="children"><div class="content">I coined a term for this because I see it so often.<p>“People will always defend complexity, stating that the only alternative is shell scripts”.<p>I saw people defending docker this way, ansible this way and most recently systemd this way.<p>Now we’re on to kubernetes.</div><br/><div id="42231393" class="c"><input type="checkbox" id="c-42231393" checked=""/><div class="controls bullet"><span class="by">msm_</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42230860">parent</a><span>|</span><a href="#42230921">next</a><span>|</span><label class="collapse" for="c-42231393">[-]</label><label class="expand" for="c-42231393">[2 more]</label></div><br/><div class="children"><div class="content">&gt;and most recently systemd this way.<p>To be fair, most people attacking systemd say they <i>want</i> to return to shell scripts.</div><br/><div id="42231699" class="c"><input type="checkbox" id="c-42231699" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42231393">parent</a><span>|</span><a href="#42230921">next</a><span>|</span><label class="collapse" for="c-42231699">[-]</label><label class="expand" for="c-42231699">[1 more]</label></div><br/><div class="children"><div class="content">No, there are alternatives like runit and SMF that do not use shell scripts.<p>Its conveniently ignored by systemd-supporters and the conversation always revolves around the fact that we used to use shell scripts. Despite the fact that there are sensible inits that predate systemd that did not use shell languages.</div><br/></div></div></div></div><div id="42230921" class="c"><input type="checkbox" id="c-42230921" checked=""/><div class="controls bullet"><span class="by">d--b</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42230860">parent</a><span>|</span><a href="#42231393">prev</a><span>|</span><a href="#42231474">next</a><span>|</span><label class="collapse" for="c-42230921">[-]</label><label class="expand" for="c-42230921">[1 more]</label></div><br/><div class="children"><div class="content">At least I never saw anyone arguing that the only alternative to git was shell scripts.<p>Wait. Wouldn&#x27;t that be a good idea?</div><br/></div></div></div></div><div id="42231474" class="c"><input type="checkbox" id="c-42231474" checked=""/><div class="controls bullet"><span class="by">weikju</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42230860">prev</a><span>|</span><a href="#42230637">next</a><span>|</span><label class="collapse" for="c-42231474">[-]</label><label class="expand" for="c-42231474">[2 more]</label></div><br/><div class="children"><div class="content">Kamal was also built with that purpose in mind.<p><a href="https:&#x2F;&#x2F;kamal-deploy.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;kamal-deploy.org&#x2F;</a></div><br/><div id="42232374" class="c"><input type="checkbox" id="c-42232374" checked=""/><div class="controls bullet"><span class="by">danjl</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42231474">parent</a><span>|</span><a href="#42230637">next</a><span>|</span><label class="collapse" for="c-42232374">[-]</label><label class="expand" for="c-42232374">[1 more]</label></div><br/><div class="children"><div class="content">This looks cool and +1 for the 37Signals and Basecamp folks. I need to verify that I&#x27;ll be able to spin up GPU enabled containers, but I can&#x27;t imagine why that wouldn&#x27;t work...</div><br/></div></div></div></div><div id="42230637" class="c"><input type="checkbox" id="c-42230637" checked=""/><div class="controls bullet"><span class="by">kikimora</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42231474">prev</a><span>|</span><a href="#42231049">next</a><span>|</span><label class="collapse" for="c-42230637">[-]</label><label class="expand" for="c-42230637">[2 more]</label></div><br/><div class="children"><div class="content">While not opinionated but you can go with cloud specific tools (e.g. ECS in AWS).</div><br/><div id="42231042" class="c"><input type="checkbox" id="c-42231042" checked=""/><div class="controls bullet"><span class="by">danjl</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42230637">parent</a><span>|</span><a href="#42231049">next</a><span>|</span><label class="collapse" for="c-42231042">[-]</label><label class="expand" for="c-42231042">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but those don&#x27;t support local deployment, at least not in any sort of easy way.</div><br/></div></div></div></div><div id="42231049" class="c"><input type="checkbox" id="c-42231049" checked=""/><div class="controls bullet"><span class="by">czhu12</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42230637">prev</a><span>|</span><a href="#42230631">next</a><span>|</span><label class="collapse" for="c-42231049">[-]</label><label class="expand" for="c-42231049">[1 more]</label></div><br/><div class="children"><div class="content">This is basically exactly what we needed at the start up I worked at, with the added need of being able to host open source projects (airbyte, metabase) with a reasonable level of confidence.<p>We ended up migrating from Heroku to Kubernetes. I tried to take some of the learnings to build <a href="https:&#x2F;&#x2F;github.com&#x2F;czhu12&#x2F;canine">https:&#x2F;&#x2F;github.com&#x2F;czhu12&#x2F;canine</a><p>It basically wraps Kubernetes and tries to hide as much complexity from Kubernetes as possible, and only expose the good parts that will be enough for 95% of web application work loads.</div><br/></div></div><div id="42230631" class="c"><input type="checkbox" id="c-42230631" checked=""/><div class="controls bullet"><span class="by">iamsanteri</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42231049">prev</a><span>|</span><a href="#42231658">next</a><span>|</span><label class="collapse" for="c-42230631">[-]</label><label class="expand" for="c-42230631">[1 more]</label></div><br/><div class="children"><div class="content">Docker Swarm mode? I know it’s not as well maintained, but I think it’s exactly what you talk about here (forget K3s, etc). I believe smaller companies run it still and it’s perfect for personal projects. I myself run mostly docker compose + shell scripts though because I don’t really need zero-downtime deployments or redundancy&#x2F;fault tolerance.</div><br/></div></div><div id="42231658" class="c"><input type="checkbox" id="c-42231658" checked=""/><div class="controls bullet"><span class="by">faizshah</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42230631">prev</a><span>|</span><a href="#42230573">next</a><span>|</span><label class="collapse" for="c-42231658">[-]</label><label class="expand" for="c-42231658">[1 more]</label></div><br/><div class="children"><div class="content">Capistrano, Ansible et al. have existed this whole time if you want to do that.<p>The real difference in approaches is between short lived environments that you redeploy from scratch all the time and long lived environments we nurse back to health with runbooks.<p>You can use lambda, kube, etc. or chef, puppet etc. but you end up at this same crossroad.<p>Just starting a process and keeping it alive for a long time is easy to get started with but eventually you have to pay the runbook tax. Instead you could pay the kubernetes tax or the nomad tax at the start instead of the 12am ansible tax later.</div><br/></div></div><div id="42230573" class="c"><input type="checkbox" id="c-42230573" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42231658">prev</a><span>|</span><a href="#42230914">next</a><span>|</span><label class="collapse" for="c-42230573">[-]</label><label class="expand" for="c-42230573">[11 more]</label></div><br/><div class="children"><div class="content">I hate to shill my own company, but I took the job because I believe in it.<p>You should check out DBOS and see if it meets your middle ground requirements.<p>Works locally and in the cloud, has all the things you’d need to build a reliable and stateful application.<p>[0] <a href="https:&#x2F;&#x2F;dbos.dev" rel="nofollow">https:&#x2F;&#x2F;dbos.dev</a></div><br/><div id="42231454" class="c"><input type="checkbox" id="c-42231454" checked=""/><div class="controls bullet"><span class="by">stackskipton</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42230573">parent</a><span>|</span><a href="#42231036">next</a><span>|</span><label class="collapse" for="c-42231454">[-]</label><label class="expand" for="c-42231454">[4 more]</label></div><br/><div class="children"><div class="content">Looking at your page, it looks like Lambdas&#x2F;Functions but on your system, not Amazon&#x2F;Microsoft&#x2F;Google.<p>Every company I&#x27;ve ever had try to do this has ended in crying after some part of the system doesn&#x27;t fit neat into Serverless box and it becomes painful to extract from your system into &quot;Run FastAPI in containers.&quot;</div><br/><div id="42231462" class="c"><input type="checkbox" id="c-42231462" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42231454">parent</a><span>|</span><a href="#42231036">next</a><span>|</span><label class="collapse" for="c-42231462">[-]</label><label class="expand" for="c-42231462">[3 more]</label></div><br/><div class="children"><div class="content">We run on bare metal in AWS, so you get access to all your other AWS services.  We can also run on bare metal in whatever cloud you want.</div><br/><div id="42231499" class="c"><input type="checkbox" id="c-42231499" checked=""/><div class="controls bullet"><span class="by">stackskipton</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42231462">parent</a><span>|</span><a href="#42231036">next</a><span>|</span><label class="collapse" for="c-42231499">[-]</label><label class="expand" for="c-42231499">[2 more]</label></div><br/><div class="children"><div class="content">Sure but I&#x27;m still wrapped around your library no? So if your &quot;Process Kafka events&quot; decorator in Python doesn&#x27;t quite do what I need to, I&#x27;m forced to grab the Kafka library, write my code and then learn to build my own container since I assume you were handling the build part. Finally, figure out which 17 ways to run containers on AWS (<a href="https:&#x2F;&#x2F;www.lastweekinaws.com&#x2F;blog&#x2F;the-17-ways-to-run-containers-on-aws&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.lastweekinaws.com&#x2F;blog&#x2F;the-17-ways-to-run-contai...</a>) is proper for me and away I go?<p>That&#x27;s my SRE recommendation of &quot;These serverless are a trap, it&#x27;s quick to get going but you can quickly get locked into a bad place.&quot;</div><br/><div id="42231566" class="c"><input type="checkbox" id="c-42231566" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42231499">parent</a><span>|</span><a href="#42231036">next</a><span>|</span><label class="collapse" for="c-42231566">[-]</label><label class="expand" for="c-42231566">[1 more]</label></div><br/><div class="children"><div class="content">No, not at all.  We run standard python, so we can build with any kafka library.  Our decorator is just a subclass of the default decorator to add some kafka stuff, but you can use the generic decorator around whatever kafka library you want. We can build and run any arbitrary Python.<p>But yes, if you find there is something you can&#x27;t do, you would have to build a container for it or deploy it to an instance of however you want.  Although I&#x27;d say that mostly likely we&#x27;d work with you to make whatever it is you want to do possible.<p>I&#x27;d also consider that an advantage.  You aren&#x27;t locked into the platform, you can expand it to do whatever you want.  The whole point of serverless is to make <i>most</i> things easy, not all things.  If you can get your POC working without doing anything, isn&#x27;t that a great advantage to your business?<p>Let&#x27;s be real, if you start with containers, it will be a lot harder to get started and then still hard to add whatever functionality you want.  Containers doesn&#x27;t really make anything easier, it just makes things more consistent.</div><br/></div></div></div></div></div></div></div></div><div id="42231036" class="c"><input type="checkbox" id="c-42231036" checked=""/><div class="controls bullet"><span class="by">danjl</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42230573">parent</a><span>|</span><a href="#42231454">prev</a><span>|</span><a href="#42230829">next</a><span>|</span><label class="collapse" for="c-42231036">[-]</label><label class="expand" for="c-42231036">[4 more]</label></div><br/><div class="children"><div class="content">Nice, but I like my servers and find serverless difficult to debug.</div><br/><div id="42231052" class="c"><input type="checkbox" id="c-42231052" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42231036">parent</a><span>|</span><a href="#42230829">next</a><span>|</span><label class="collapse" for="c-42231052">[-]</label><label class="expand" for="c-42231052">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the beauty of this system.  You build it all locally, test it locally, debug it locally.  Only then do you deploy to the cloud.  And since you can build the whole thing with one file, it&#x27;s really easy to reason about.<p>And if somehow you get a bug in production, you have the time travel debugger to replay exactly what the state of the cloud was at the time.</div><br/><div id="42231074" class="c"><input type="checkbox" id="c-42231074" checked=""/><div class="controls bullet"><span class="by">danjl</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42231052">parent</a><span>|</span><a href="#42230829">next</a><span>|</span><label class="collapse" for="c-42231074">[-]</label><label class="expand" for="c-42231074">[2 more]</label></div><br/><div class="children"><div class="content">Great to hear you&#x27;ve improved serverless debugging. What if my endpoint wants to run ffmpeg and extract frames from video. How does that work on serverless?</div><br/><div id="42231602" class="c"><input type="checkbox" id="c-42231602" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42231074">parent</a><span>|</span><a href="#42230829">next</a><span>|</span><label class="collapse" for="c-42231602">[-]</label><label class="expand" for="c-42231602">[1 more]</label></div><br/><div class="children"><div class="content">That particular use case requires some pretty heavy binaries and isn&#x27;t really suited to serverless.  However, you could still use DBOS to manage chunking the work and managing to workflows to make sure every frame is only processed once.  Then you could call out to some of the existing serverless offerings that do exactly what you suggest (extract frames from video).<p>Or you could launch an EC2 instance that is running ffmpeg and takes in videos and spits out frames, and then use DBOS to manage launching and closing down those instances as well as the workflows of getting the work done.</div><br/></div></div></div></div></div></div></div></div><div id="42230829" class="c"><input type="checkbox" id="c-42230829" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42230573">parent</a><span>|</span><a href="#42231036">prev</a><span>|</span><a href="#42230914">next</a><span>|</span><label class="collapse" for="c-42230829">[-]</label><label class="expand" for="c-42230829">[2 more]</label></div><br/><div class="children"><div class="content">Looks interesting, but this is a bit worrying:<p><pre><code>  ... build reliable AI agents with automatic retries and no limit on how long they can
  run for.
</code></pre>
It&#x27;s pretty easy to see how that could go badly wrong. ;)<p>(and yeah, obviously &quot;don&#x27;t deploy that stuff&quot; is the solution)<p>---<p>That being said, is it all OSS?  I can see some stuff here that seems to be, but it mostly seems to be the client side stuff?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dbos-inc">https:&#x2F;&#x2F;github.com&#x2F;dbos-inc</a></div><br/><div id="42230898" class="c"><input type="checkbox" id="c-42230898" checked=""/><div class="controls bullet"><span class="by">jedberg</span><span>|</span><a href="#42230273">root</a><span>|</span><a href="#42230829">parent</a><span>|</span><a href="#42230914">next</a><span>|</span><label class="collapse" for="c-42230898">[-]</label><label class="expand" for="c-42230898">[1 more]</label></div><br/><div class="children"><div class="content">Maybe that is worded poorly. :). It&#x27;s supposed to mean there are no timeouts -- you can wait as long as you want between retries.<p>&gt; That being said, is it all OSS?<p>The Transact library is open source and always will be.  That is what you gets you the durability, statefulness, some observability, and local testing.<p>We also offer a hosted cloud product that adds in the reliability, scalability, more observability, and a time travel debugger.</div><br/></div></div></div></div></div></div><div id="42230914" class="c"><input type="checkbox" id="c-42230914" checked=""/><div class="controls bullet"><span class="by">nicodjimenez</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42230573">prev</a><span>|</span><a href="#42230814">next</a><span>|</span><label class="collapse" for="c-42230914">[-]</label><label class="expand" for="c-42230914">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, something simpler than Nomad as well hopefully.</div><br/></div></div><div id="42230814" class="c"><input type="checkbox" id="c-42230814" checked=""/><div class="controls bullet"><span class="by">sc68cal</span><span>|</span><a href="#42230273">parent</a><span>|</span><a href="#42230914">prev</a><span>|</span><a href="#42228164">next</a><span>|</span><label class="collapse" for="c-42230814">[-]</label><label class="expand" for="c-42230814">[1 more]</label></div><br/><div class="children"><div class="content">Ansible and the podman Ansible modules</div><br/></div></div></div></div><div id="42228164" class="c"><input type="checkbox" id="c-42228164" checked=""/><div class="controls bullet"><span class="by">do_not_redeem</span><span>|</span><a href="#42230273">prev</a><span>|</span><a href="#42228084">next</a><span>|</span><label class="collapse" for="c-42228164">[-]</label><label class="expand" for="c-42228164">[10 more]</label></div><br/><div class="children"><div class="content">&gt; The inscrutable iptables rules?<p>You mean the list of calls right there in the shell script?<p>&gt; Who will know about those undocumented sysctl edits you made on the VM?<p>You mean those calls to `sysctl` conveniently right there in the shell script?<p>&gt; your app needs to programmatically spawn other containers<p>Or you could run a job queue and push tasks to it (gaining all the usual benefits of observability, concurrency limits, etc), instead of spawning ad-hoc containers and hoping for the best.</div><br/><div id="42228226" class="c"><input type="checkbox" id="c-42228226" checked=""/><div class="controls bullet"><span class="by">jrs235</span><span>|</span><a href="#42228164">parent</a><span>|</span><a href="#42228249">next</a><span>|</span><label class="collapse" for="c-42228226">[-]</label><label class="expand" for="c-42228226">[3 more]</label></div><br/><div class="children"><div class="content">&quot;We don&#x27;t know how to learn&#x2F;read code we are unfamiliar with... Nor do we know how to grok and learn things quickly. Heck, we don&#x27;t know what grok means &quot;</div><br/><div id="42229160" class="c"><input type="checkbox" id="c-42229160" checked=""/><div class="controls bullet"><span class="by">ewuhic</span><span>|</span><a href="#42228164">root</a><span>|</span><a href="#42228226">parent</a><span>|</span><a href="#42228249">next</a><span>|</span><label class="collapse" for="c-42229160">[-]</label><label class="expand" for="c-42229160">[2 more]</label></div><br/><div class="children"><div class="content">Who do you quote?</div><br/><div id="42233335" class="c"><input type="checkbox" id="c-42233335" checked=""/><div class="controls bullet"><span class="by">ZeroSolstice</span><span>|</span><a href="#42228164">root</a><span>|</span><a href="#42229160">parent</a><span>|</span><a href="#42228249">next</a><span>|</span><label class="collapse" for="c-42233335">[-]</label><label class="expand" for="c-42233335">[1 more]</label></div><br/><div class="children"><div class="content">This quote mostly applies to people who don&#x27;t want to spend the time learning existing tooling, making improvements and instead create a slightly different wheel but with different problems. It also applies to people trying to apply &quot;google&quot; solutions to a non-google company.<p>Kubernetes and all tooling in the cloud native computing foundation(CNCF) were created to have people adopt the cloud and build communities that then created jobs roles that facilitated hiring people to maintain cloud presences that then fund cloud providers.<p>This is the same playbook that Microsoft did at Universities. They would give the entire suite of tools in the MSDN library away then then in roughly (4) years collect when another seat needs to be purchased for a new hire that has only used Microsoft tools for the last (4) years.</div><br/></div></div></div></div></div></div><div id="42231516" class="c"><input type="checkbox" id="c-42231516" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42228164">parent</a><span>|</span><a href="#42228249">prev</a><span>|</span><a href="#42228084">next</a><span>|</span><label class="collapse" for="c-42231516">[-]</label><label class="expand" for="c-42231516">[5 more]</label></div><br/><div class="children"><div class="content">&gt; You mean the list of calls right there in the shell script?<p>This is about the worst encoding for network rules I can think of.</div><br/><div id="42231679" class="c"><input type="checkbox" id="c-42231679" checked=""/><div class="controls bullet"><span class="by">do_not_redeem</span><span>|</span><a href="#42228164">root</a><span>|</span><a href="#42231516">parent</a><span>|</span><a href="#42228084">next</a><span>|</span><label class="collapse" for="c-42231679">[-]</label><label class="expand" for="c-42231679">[4 more]</label></div><br/><div class="children"><div class="content">Worse than yaml generated by string interpolation?</div><br/><div id="42232190" class="c"><input type="checkbox" id="c-42232190" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42228164">root</a><span>|</span><a href="#42231679">parent</a><span>|</span><a href="#42228084">next</a><span>|</span><label class="collapse" for="c-42232190">[-]</label><label class="expand" for="c-42232190">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;d have to give me an example. YAML is certainly better at representing tables of data than a shell script is.</div><br/><div id="42232607" class="c"><input type="checkbox" id="c-42232607" checked=""/><div class="controls bullet"><span class="by">do_not_redeem</span><span>|</span><a href="#42228164">root</a><span>|</span><a href="#42232190">parent</a><span>|</span><a href="#42228084">next</a><span>|</span><label class="collapse" for="c-42232607">[-]</label><label class="expand" for="c-42232607">[2 more]</label></div><br/><div class="children"><div class="content">Not entirely a fair comparison, but here. Can you honestly tell me you&#x27;d take the yaml over the shell script?<p>(If you&#x27;ve never had to use Helm, I envy you. And if you have, I genuinely look forward to you showing me an easier way to do this, since it would make my life easier.)<p>-------------------------------------<p>Shell script:<p><pre><code>  iptables -A INPUT -p tcp --dport 8080 -j ACCEPT
</code></pre>
Multiple ports:<p><pre><code>  for port in 80 443 8080; do
    iptables -A INPUT -p tcp --dport &quot;$port&quot; -j ACCEPT
  done
</code></pre>
Easy and concise.<p>-------------------------------------<p>Kubernetes (disclaimer: untested, obviously)<p><pre><code>  apiVersion: networking.k8s.io&#x2F;v1
  kind: NetworkPolicy
  spec:
    trafficPolicy:
      firewall:
        rules:
        - name: allow-port-8080
          ports:
          - port: 8080
            protocol: TCP
    podSelector:
      matchLabels:
        app.kubernetes.io&#x2F;name: my-app
</code></pre>
Multiple ports:<p><pre><code>  firewall:
    rules:
      - name: allow-port-80
        ports:
          - port: 80
            protocol: TCP
      - name: allow-port-443
        ports:
          - port: 443
            protocol: TCP
      - name: allow-port-8080
        ports:
          - port: 8080
            protocol: TCP

  apiVersion: networking.k8s.io&#x2F;v1
  kind: NetworkPolicy
  metadata:
    name: firewall
  spec:
    trafficPolicy:
      firewall:
        rules:
          {{- range .Values.firewall.rules }}
          - name: {{ .name }}
            ports:
            {{- range .ports }}
            - port: {{ .port }}
              protocol: {{ .protocol }}
            {{- end }}
          {{- end }}
    podSelector:
      matchLabels:
        app.kubernetes.io&#x2F;name: my-app</code></pre></div><br/><div id="42233443" class="c"><input type="checkbox" id="c-42233443" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42228164">root</a><span>|</span><a href="#42232607">parent</a><span>|</span><a href="#42228084">next</a><span>|</span><label class="collapse" for="c-42233443">[-]</label><label class="expand" for="c-42233443">[1 more]</label></div><br/><div class="children"><div class="content">I would take the YAML any day.<p>Because if one of those iptables fails above you&#x27;re in an inconsistent state.<p>Also if I want to swap from iptables to something like Istio then it&#x27;s basically the same YAML.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42228084" class="c"><input type="checkbox" id="c-42228084" checked=""/><div class="controls bullet"><span class="by">majkinetor</span><span>|</span><a href="#42228164">prev</a><span>|</span><a href="#42228253">next</a><span>|</span><label class="collapse" for="c-42228084">[-]</label><label class="expand" for="c-42228084">[2 more]</label></div><br/><div class="children"><div class="content">Highly amateurish take if you call shell spaghetti a Kubernates, especially if we compare complexity of both...<p>You know what would be even more bad? Introducing kubernates for your non-Google&#x2F;Netflix&#x2F;WhateverPlanetaryScale
App instead of just writing few scripts...</div><br/><div id="42232736" class="c"><input type="checkbox" id="c-42232736" checked=""/><div class="controls bullet"><span class="by">hyperadvanced</span><span>|</span><a href="#42228084">parent</a><span>|</span><a href="#42228253">next</a><span>|</span><label class="collapse" for="c-42232736">[-]</label><label class="expand" for="c-42232736">[1 more]</label></div><br/><div class="children"><div class="content">Hell, I’m a fan of k8s even for sub-planetary scale (assuming that scale is ultimately a goal of your business, it’s nice to build for success). But I agree that saying “well, it’s either k8s or you will build k8s yourself” is just ignorant. There are a lot of options between the two poles that can be both cheap and easy and offload the ugly bits of server management for the right price and complexity that your business needs.</div><br/></div></div></div></div><div id="42228253" class="c"><input type="checkbox" id="c-42228253" checked=""/><div class="controls bullet"><span class="by">kasey_junk</span><span>|</span><a href="#42228084">prev</a><span>|</span><a href="#42231459">next</a><span>|</span><label class="collapse" for="c-42228253">[-]</label><label class="expand" for="c-42228253">[8 more]</label></div><br/><div class="children"><div class="content">Both this piece and the piece it’s imitating seem to have 2 central implicit axioms that in my opinion don’t hold. The first, that the constraints of the home grown systems are all cost and the second that the flexibility of the general purpose solution is all benefit.<p>You generally speaking do not want a code generation or service orchestration system that will support the entire universe of choices. You want your programs and idioms to follow similar patterns across your codebase and you want your services architected and deployed the same way. You want to know when outliers get introduced and similarly you want to make it costly enough to require introspection on if the value of the benefit out ways the cost of oddity.</div><br/><div id="42229711" class="c"><input type="checkbox" id="c-42229711" checked=""/><div class="controls bullet"><span class="by">dogleash</span><span>|</span><a href="#42228253">parent</a><span>|</span><a href="#42228847">next</a><span>|</span><label class="collapse" for="c-42229711">[-]</label><label class="expand" for="c-42229711">[4 more]</label></div><br/><div class="children"><div class="content">The compiler one read to me like a reminder to not ignore the lessons of compiler design. The premise being that even though you have small scope project compared to a &quot;real&quot; compiler, you will evolve towards analogues of those <i>design</i> ideas.  The databases and k8s pieces are more like don&#x27;t even try a small scope project because you&#x27;ll want the same <i>features</i> eventually.</div><br/><div id="42231404" class="c"><input type="checkbox" id="c-42231404" checked=""/><div class="controls bullet"><span class="by">ufmace</span><span>|</span><a href="#42228253">root</a><span>|</span><a href="#42229711">parent</a><span>|</span><a href="#42230342">next</a><span>|</span><label class="collapse" for="c-42231404">[-]</label><label class="expand" for="c-42231404">[2 more]</label></div><br/><div class="children"><div class="content">I suppose I can see how people are taking this piece that way, but I don&#x27;t see it like that. It is snarky and ranty, which makes it hard to express or perceive nuance. They do explicitly acknowledge that &quot;a single server can go a long way&quot; though.<p>I think the real point, better expressed, is that if you find yourself building a system with like a third of the features of K8s but composed of hand-rolled scripts and random third-party tools kludged together, maybe you should have just bit the bullet and moved to K8s instead.<p>You probably shouldn&#x27;t start your project on it unless you have a dedicated DevOps department maintaining your cluster for you, but don&#x27;t be afraid to move to it if your needs start getting more complex.</div><br/><div id="42232319" class="c"><input type="checkbox" id="c-42232319" checked=""/><div class="controls bullet"><span class="by">mac-chaffee</span><span>|</span><a href="#42228253">root</a><span>|</span><a href="#42231404">parent</a><span>|</span><a href="#42230342">next</a><span>|</span><label class="collapse" for="c-42232319">[-]</label><label class="expand" for="c-42232319">[1 more]</label></div><br/><div class="children"><div class="content">Author here. Yes there were many times while writing this that I wanted to insert nuance, but couldn&#x27;t without breaking the format too much.<p>I appreciate the wide range of interpretations! I don&#x27;t necessarily think you should always move to k8s in those situations. I just want people to not dismiss k8s outright for being overly-complex without thinking too hard about it. &quot;You will evolve towards analogues of those design ideas&quot; is a good way to put it.<p>That&#x27;s also how I interpreted the original post about compilers. The reader is stubbornly refusing to acknowledge that compilers have irreducible complexity. They think they can build something simpler, but end up rediscovering the same path that lead to the creation of compilers in the first place.</div><br/></div></div></div></div><div id="42230342" class="c"><input type="checkbox" id="c-42230342" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42228253">root</a><span>|</span><a href="#42229711">parent</a><span>|</span><a href="#42231404">prev</a><span>|</span><a href="#42228847">next</a><span>|</span><label class="collapse" for="c-42230342">[-]</label><label class="expand" for="c-42230342">[1 more]</label></div><br/><div class="children"><div class="content">I had a hard time putting my finger on what was so annoying about the follow-ons to the compiler post, and this nails it for me. Thanks!</div><br/></div></div></div></div><div id="42228847" class="c"><input type="checkbox" id="c-42228847" checked=""/><div class="controls bullet"><span class="by">relaxing</span><span>|</span><a href="#42228253">parent</a><span>|</span><a href="#42229711">prev</a><span>|</span><a href="#42228588">next</a><span>|</span><label class="collapse" for="c-42228847">[-]</label><label class="expand" for="c-42228847">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You generally speaking do not want a code generation or service orchestration system that will support the entire universe of choices.<p>This. I will gladly give up the universe of choices for a one size fits most solution that just works. I will bend my use cases to fit the mold if it means not having to write k8s configuration in a twisty maze of managed services.</div><br/></div></div><div id="42228588" class="c"><input type="checkbox" id="c-42228588" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42228253">parent</a><span>|</span><a href="#42228847">prev</a><span>|</span><a href="#42228429">next</a><span>|</span><label class="collapse" for="c-42228588">[-]</label><label class="expand" for="c-42228588">[1 more]</label></div><br/><div class="children"><div class="content">I like to say, you can make anything look good by considering only the benefits and anything look bad by considering only the costs.<p>It&#x27;s a fun philosophy for online debates, but an expensive one to use in real engineering.</div><br/></div></div><div id="42228429" class="c"><input type="checkbox" id="c-42228429" checked=""/><div class="controls bullet"><span class="by">jesseendahl</span><span>|</span><a href="#42228253">parent</a><span>|</span><a href="#42228588">prev</a><span>|</span><a href="#42231459">next</a><span>|</span><label class="collapse" for="c-42228429">[-]</label><label class="expand" for="c-42228429">[1 more]</label></div><br/><div class="children"><div class="content">outweighs*<p>Only offering the correction because I was confused at what you meant by “out ways” until I figured it out.</div><br/></div></div></div></div><div id="42231459" class="c"><input type="checkbox" id="c-42231459" checked=""/><div class="controls bullet"><span class="by">hcrean</span><span>|</span><a href="#42228253">prev</a><span>|</span><a href="#42233172">next</a><span>|</span><label class="collapse" for="c-42231459">[-]</label><label class="expand" for="c-42231459">[4 more]</label></div><br/><div class="children"><div class="content">The elephant in the room: People who have gotten over the K8s learning curve almost all tell you it isn&#x27;t actually that bad.
Most people who have not attempted the learning curve, or have just dipped their toe in, will tell you they are scared of the complexity.<p>An anecdotal datapoint: My standard lecture teaching developers how to interact with K8s takes almost precisely 30 minutes to have them writing Helm charts for themselves. I have given it a whole bunch of times and it seems to do the job.</div><br/><div id="42232215" class="c"><input type="checkbox" id="c-42232215" checked=""/><div class="controls bullet"><span class="by">thunky</span><span>|</span><a href="#42231459">parent</a><span>|</span><a href="#42232019">next</a><span>|</span><label class="collapse" for="c-42232215">[-]</label><label class="expand" for="c-42232215">[2 more]</label></div><br/><div class="children"><div class="content">&gt; My standard lecture teaching developers how to interact with K8s takes almost precisely 30 minutes to have them writing Helm charts for themselves<p>And I can teach someone to write &quot;hello world&quot; in 10 languages in 30 minutes, but that doesn&#x27;t mean they&#x27;re qualified to develop or fix production software.</div><br/><div id="42232907" class="c"><input type="checkbox" id="c-42232907" checked=""/><div class="controls bullet"><span class="by">hnthrowaway0328</span><span>|</span><a href="#42231459">root</a><span>|</span><a href="#42232215">parent</a><span>|</span><a href="#42232019">next</a><span>|</span><label class="collapse" for="c-42232907">[-]</label><label class="expand" for="c-42232907">[1 more]</label></div><br/><div class="children"><div class="content">One has to start from somewhere I guess. I doubt anyone would learn K8s thoroughly before getting any such job. Tried once and the whole thing bored me out in the fourth video.</div><br/></div></div></div></div><div id="42232019" class="c"><input type="checkbox" id="c-42232019" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42231459">parent</a><span>|</span><a href="#42232215">prev</a><span>|</span><a href="#42233172">next</a><span>|</span><label class="collapse" for="c-42232019">[-]</label><label class="expand" for="c-42232019">[1 more]</label></div><br/><div class="children"><div class="content">I personally know many k8s experts that vehemently recommend against using it unless you have no other option.</div><br/></div></div></div></div><div id="42233172" class="c"><input type="checkbox" id="c-42233172" checked=""/><div class="controls bullet"><span class="by">fizx</span><span>|</span><a href="#42231459">prev</a><span>|</span><a href="#42230189">next</a><span>|</span><label class="collapse" for="c-42233172">[-]</label><label class="expand" for="c-42233172">[1 more]</label></div><br/><div class="children"><div class="content">Much like Javascript, the problem isn&#x27;t Kubernetes, its the zillions of half-tested open-source libraries that promise to make things easier but actually completely obfuscate what the system is doing while injecting fantastic amounts of bugs.</div><br/></div></div><div id="42230189" class="c"><input type="checkbox" id="c-42230189" checked=""/><div class="controls bullet"><span class="by">mbrumlow</span><span>|</span><a href="#42233172">prev</a><span>|</span><a href="#42228550">next</a><span>|</span><label class="collapse" for="c-42230189">[-]</label><label class="expand" for="c-42230189">[6 more]</label></div><br/><div class="children"><div class="content">Most of the complaints in this fun post are just bad practice, and really nothing to do with “making a Kubernetes”.<p>Sans bad engineering practices, if you built a system that did the same things as kubernetes I would have no problem with it.<p>In reality I don’t want everybody to use k8s. I want people finding different solutions to solve similar problems. Homogenized ecosystems create walls they block progress.<p>One is the big things that is overlooked when people move to k8s, and why things get better when moving to k8s, is that k8s made a set of rules that forced service owners to fix all of their bad practices.<p>Most deployment systems would work fine if the same work to remove bad practices from their stack occurred.<p>K8s is the hot thing today, but mark my words, it will be replaced with something far more simple and much nicer to integrate with. And this will come from some engineer “creating a kubernetes”<p>Don’t even get me started on how crappy the culture of “you are doing something hard that I think is already a solved problem” is. This goes for compilers and databases too. None is these are hard, and neither is k8s, and all good engineers tasked with making one, be able to do so.</div><br/><div id="42232381" class="c"><input type="checkbox" id="c-42232381" checked=""/><div class="controls bullet"><span class="by">mac-chaffee</span><span>|</span><a href="#42230189">parent</a><span>|</span><a href="#42232632">next</a><span>|</span><label class="collapse" for="c-42232381">[-]</label><label class="expand" for="c-42232381">[1 more]</label></div><br/><div class="children"><div class="content">I welcome a k8s replacement! Just how there are better compilers and better databases than we had 10-20 years ago, we need better deployment methods. I just believe those better methods came from really understanding the compilers and databases that came before, rather than dismissing them out of hand.</div><br/></div></div><div id="42232632" class="c"><input type="checkbox" id="c-42232632" checked=""/><div class="controls bullet"><span class="by">delifue</span><span>|</span><a href="#42230189">parent</a><span>|</span><a href="#42232381">prev</a><span>|</span><a href="#42230967">next</a><span>|</span><label class="collapse" for="c-42232632">[-]</label><label class="expand" for="c-42232632">[2 more]</label></div><br/><div class="children"><div class="content">Can you give examples of what &quot;bad practices&quot; does k8s force to fix?</div><br/><div id="42232861" class="c"><input type="checkbox" id="c-42232861" checked=""/><div class="controls bullet"><span class="by">hyperadvanced</span><span>|</span><a href="#42230189">root</a><span>|</span><a href="#42232632">parent</a><span>|</span><a href="#42230967">next</a><span>|</span><label class="collapse" for="c-42232861">[-]</label><label class="expand" for="c-42232861">[1 more]</label></div><br/><div class="children"><div class="content">To name a few:<p>K8s really kills the urge to say “oh well I guess we can just do that file onto the server as a part of startup rather than use a db&#x2F;config system&#x2F;etc.” No more “oh shit the VM died and we lost the file that was supposed to be static except for that thing John wrote to update it only if X happened, but now X happens everyday and the file is gone”.. or worse: it’s in git but now you have 3 different versions that have all drifted due to the John code change.<p>K8s makes you use containers, which makes you not run things on your machine, which makes you better at CI, which.. (the list goes on, containers are industry standard for a lot of reasons). In general the 12 Factor App is a great set of ideas, and k8s lets you do them (this is not exclusive, though). Containers alone are a huge game changer compared to “cp a JAR to the server and restart it”<p>K8s makes it really really really easy to just split off that one weird cronjob part of the codebase that Mike needed and man, it would be really nice to just use the same code and dependencies rather than boilerplating a whole new app and deploy, CI, configs, and yamls to make that run. See points about containerization.<p>K8s doesn’t assume that your business will always be a website&#x2F;mobile app. See the whole “edge computing” trend.<p>I do want to stress that k8s is not the only thing in the world that can do these or promote good development practices, and I do think it’s overkill to say that it MAKES you do things well - a foolhardy person can mess any well-intentioned system up.</div><br/></div></div></div></div><div id="42230967" class="c"><input type="checkbox" id="c-42230967" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#42230189">parent</a><span>|</span><a href="#42232632">prev</a><span>|</span><a href="#42228550">next</a><span>|</span><label class="collapse" for="c-42230967">[-]</label><label class="expand" for="c-42230967">[2 more]</label></div><br/><div class="children"><div class="content">So you&#x27;re saying companies should move to k8s and then immediately move to bash scripts</div><br/><div id="42231347" class="c"><input type="checkbox" id="c-42231347" checked=""/><div class="controls bullet"><span class="by">mbrumlow</span><span>|</span><a href="#42230189">root</a><span>|</span><a href="#42230967">parent</a><span>|</span><a href="#42228550">next</a><span>|</span><label class="collapse" for="c-42231347">[-]</label><label class="expand" for="c-42231347">[1 more]</label></div><br/><div class="children"><div class="content">No. I am saying that companies should have their engineers understand why k8s works and make those reasons an engineering practice.<p>As it is today the pattern is spend a ton of money moving to k8s (mostly costly managed solutions) in the process fix all the bad engineering patterns, forced by k8s. To then have an engineer save the company money by moving back to a more home grown solution, a solution that fits the companies needs and saves money, something that would only be possible once the engineering practices were fixed.</div><br/></div></div></div></div></div></div><div id="42228550" class="c"><input type="checkbox" id="c-42228550" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#42230189">prev</a><span>|</span><a href="#42230466">next</a><span>|</span><label class="collapse" for="c-42228550">[-]</label><label class="expand" for="c-42228550">[1 more]</label></div><br/><div class="children"><div class="content">Dear Amazon Elastic Beanstalk, Google App Engine, Heroku, Digital Ocean App Platform, and friends,<p>Thank you for building &quot;a kubernetes&quot; for me so I don&#x27;t have to muck with that nonsense, or have to hire people that do.<p>I don&#x27;t know what that other guy is talking about.</div><br/></div></div><div id="42230466" class="c"><input type="checkbox" id="c-42230466" checked=""/><div class="controls bullet"><span class="by">physicsguy</span><span>|</span><a href="#42228550">prev</a><span>|</span><a href="#42233633">next</a><span>|</span><label class="collapse" for="c-42230466">[-]</label><label class="expand" for="c-42230466">[7 more]</label></div><br/><div class="children"><div class="content">Kubernetes biggest competitor isn’t a pile of bash scripts and docker running on a server, it’s something like ECS which comes with a lot of the benefits but a hell of a lot less complexity</div><br/><div id="42231072" class="c"><input type="checkbox" id="c-42231072" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#42230466">parent</a><span>|</span><a href="#42231270">next</a><span>|</span><label class="collapse" for="c-42231072">[-]</label><label class="expand" for="c-42231072">[5 more]</label></div><br/><div class="children"><div class="content">FWIW I’ve been using ECS at my current work (previously K8s) and to me it feels just flat worse:<p>- only some of the features<p>- none of the community<p>- all of the complexity but none of the upsides.<p>It was genuinely a bit shocking that it was considered a serious product seeing as how chaotic it was.</div><br/><div id="42231197" class="c"><input type="checkbox" id="c-42231197" checked=""/><div class="controls bullet"><span class="by">avandekleut</span><span>|</span><a href="#42230466">root</a><span>|</span><a href="#42231072">parent</a><span>|</span><a href="#42231270">next</a><span>|</span><label class="collapse" for="c-42231197">[-]</label><label class="expand" for="c-42231197">[4 more]</label></div><br/><div class="children"><div class="content">Can you elaborate on some of the issues you faced? I was considering deploying to ECS fargate as we are all-in on AWS.</div><br/><div id="42231275" class="c"><input type="checkbox" id="c-42231275" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#42230466">root</a><span>|</span><a href="#42231197">parent</a><span>|</span><a href="#42231315">next</a><span>|</span><label class="collapse" for="c-42231275">[-]</label><label class="expand" for="c-42231275">[2 more]</label></div><br/><div class="children"><div class="content">Any kind of git-ops style deployment was out.<p>ECS merges “AWS config” and “app&#x2F;deployment config together” so it was difficult to separate “what should go in TF, and what is a runtime app configuration. In comparison this is basically trivial ootb with K8s.<p>I personally found a lot of the moving parts and names needlessly confusing. Tasks e.g. were not your equivalent to “Deployment”.<p>Want to just deploy something like Prometheus Agent? Well, too bad, the networking doesn’t work the same, so here’s some overly complicated guide where you have to deploy some extra stuff which will no doubt not work right the first dozen times you try. Admittedly, Prom can be a right pain to manage, but the fact that ECS makes you do _extra_ work on top of an already fiddly piece of software left a bad taste in my mouth.<p>I think ECS get a lot of airtime because of Fargate, but you can use Fargate on K8s these days, or, if you can afford the small increase in initial setup complexity, you can just have Fargates less-expensive, less-restrictive, better sibling: Karpenter on Spot instances.</div><br/><div id="42233813" class="c"><input type="checkbox" id="c-42233813" checked=""/><div class="controls bullet"><span class="by">physicsguy</span><span>|</span><a href="#42230466">root</a><span>|</span><a href="#42231275">parent</a><span>|</span><a href="#42231315">next</a><span>|</span><label class="collapse" for="c-42233813">[-]</label><label class="expand" for="c-42233813">[1 more]</label></div><br/><div class="children"><div class="content">I think the initial setup complexity is less with ECS personally, and the ongoing maintenance cost is significantly worse on K8s when you run anything serious which leads to people taking shortcuts.<p>Every time you have a cluster upgrade with K8s there’s a risk something breaks. For any product at scale, you’re likely to be using things like Istio and Metricbeat. You have a whole level of complexity in adding auth to your cluster on top of your existing SSO for the cloud provider. We’ve had to spend quite some time changing the plugin for AKS&#x2F;EntraID recently which has also meant a change in workflow for users. Upgrading clusters can break things since plenty of stuff (less these days) lives in beta namespaces, and there’s no LTS.<p>Again, it’s less bad than it was, but many core things live(d) in plugins for clusters which have a risk of breaking when you upgrade cluster.<p>My view was that the initial startup cost for ECS is lower and once it’s done, that’s kind of it - it’s stable and doesn’t change. With K8s it’s much more a moving target, and it requires someone to actively be maintaining it, which takes time.<p>In a small team I don’t think that cost and complexity is worth it - there are so many more concepts that you have to learn even on top of the cloud specific ones. It requires a real level of expertise so if you try and adopt it without someone who’s already worked with it for some time you can end up in a real mess</div><br/></div></div></div></div><div id="42231315" class="c"><input type="checkbox" id="c-42231315" checked=""/><div class="controls bullet"><span class="by">andycowley</span><span>|</span><a href="#42230466">root</a><span>|</span><a href="#42231197">parent</a><span>|</span><a href="#42231275">prev</a><span>|</span><a href="#42231270">next</a><span>|</span><label class="collapse" for="c-42231315">[-]</label><label class="expand" for="c-42231315">[1 more]</label></div><br/><div class="children"><div class="content">If your workloads are fairly static,ECS is fine. Bringing up new containers and nodes takes ages with very little feedback as to what&#x27;s going on. It&#x27;s very frustrating when iterating on workloads.<p>Also fargate is very expensive and inflexible. If you fit the narrow particular use case it&#x27;s quicker for bringing up workloads, but you pay extra for it.</div><br/></div></div></div></div></div></div><div id="42231270" class="c"><input type="checkbox" id="c-42231270" checked=""/><div class="controls bullet"><span class="by">jbmsf</span><span>|</span><a href="#42230466">parent</a><span>|</span><a href="#42231072">prev</a><span>|</span><a href="#42233633">next</a><span>|</span><label class="collapse" for="c-42231270">[-]</label><label class="expand" for="c-42231270">[1 more]</label></div><br/><div class="children"><div class="content">Can confirm. I&#x27;ve used ECS with Fargate successfully at multiple companies. Some eventually outgrew it. Some failed first. Some continue to use ECS happily.<p>Regardless of the outcome, it always felt more important to keep things simple and focus on product and business needs.</div><br/></div></div></div></div><div id="42233633" class="c"><input type="checkbox" id="c-42233633" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#42230466">prev</a><span>|</span><a href="#42233128">next</a><span>|</span><label class="collapse" for="c-42233633">[-]</label><label class="expand" for="c-42233633">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Inevitably, you find a reason to expand to a second server.<p>The author has some good points, but not every project needs multiple servers for the same reasons as a typical Kubernetes setup. In many scenarios those servers are dedicated to separate tasks.<p>For example, you can have a separate server for a redundant copy of your application layer, one server for load balancing and caching, one or more servers for the database, another for backups, and none of these servers requires anything more than separate Docker Compose configs for each server.<p>I&#x27;m not saying that Kubernetes is a bad idea, even for the hypothetical setup above, but you don&#x27;t necessarily need advanced service discovery tools for <i>every</i> workload.</div><br/></div></div><div id="42233128" class="c"><input type="checkbox" id="c-42233128" checked=""/><div class="controls bullet"><span class="by">jb_gericke</span><span>|</span><a href="#42233633">prev</a><span>|</span><a href="#42231070">next</a><span>|</span><label class="collapse" for="c-42233128">[-]</label><label class="expand" for="c-42233128">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think scale is the only consideration for using Kubernetes. The ops overhead in managing traditional infrastructure, especially if you’re a large enterprise, drops massively if you really buy into cloud native. Kubernetes converges application orchestration, job scheduling, scaling, monitoring&#x2F;observability, networking, load balancing, certificate management,  storage management, compute provisioning - and more. In a typical enterprise, doing all this requires multiple teams. Changes are request driven and take forever. Operating systems need to be patched. This all happens after hours and costs time and money. When properly implemented and backed by the right level of stakeholder, I’ve seen orgs move to business day maintenance, while gaining the confidence to release during peak times. It’s not just about scale, it’s about converging traditional infra practices into a single, declarative and eventually consistent platform that handles it all for you.</div><br/></div></div><div id="42231070" class="c"><input type="checkbox" id="c-42231070" checked=""/><div class="controls bullet"><span class="by">czhu12</span><span>|</span><a href="#42233128">prev</a><span>|</span><a href="#42233912">next</a><span>|</span><label class="collapse" for="c-42231070">[-]</label><label class="expand" for="c-42231070">[4 more]</label></div><br/><div class="children"><div class="content">I think one thing that is under appreciated with kubernetes is how massive the package library is. It becomes trivial to stand up basically every open source project with a single command via helm. It gets a lot of hate but for medium sized deployments, it’s fantastic.<p>Before helm, just trying to run third party containers on bare metal resulted in constant downtime when the process would just hang for no reason, and and engineer would have to SSH and manually restart the instance.<p>We used this as a previous start up to host metabase, sentry and airbyte seamlessly, on our own cluster. Which let us break out of the constant price increases we faced for hosted versions of these products.<p>Shameless plug: I’ve been building <a href="https:&#x2F;&#x2F;github.com&#x2F;czhu12&#x2F;canine">https:&#x2F;&#x2F;github.com&#x2F;czhu12&#x2F;canine</a> to try to make Kubernetes easier to use for solo developers. Would love any feedback from anyone looking to deploy something new to K8s!</div><br/><div id="42231138" class="c"><input type="checkbox" id="c-42231138" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#42231070">parent</a><span>|</span><a href="#42233912">next</a><span>|</span><label class="collapse" for="c-42231138">[-]</label><label class="expand" for="c-42231138">[3 more]</label></div><br/><div class="children"><div class="content">Right, but this isn&#x27;t a post about why K8s is <i>good</i>, it&#x27;s a post about why K8s is <i>effectively mandatory</i>, and it isn&#x27;t, which is why the post rankles some people.</div><br/><div id="42231263" class="c"><input type="checkbox" id="c-42231263" checked=""/><div class="controls bullet"><span class="by">czhu12</span><span>|</span><a href="#42231070">root</a><span>|</span><a href="#42231138">parent</a><span>|</span><a href="#42233912">next</a><span>|</span><label class="collapse" for="c-42231263">[-]</label><label class="expand" for="c-42231263">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I mostly agree. I&#x27;d even add that even K8 YAML&#x27;s are not trivial to maintain, especially if you need to have them be produced by a templating engine.</div><br/><div id="42231606" class="c"><input type="checkbox" id="c-42231606" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#42231070">root</a><span>|</span><a href="#42231263">parent</a><span>|</span><a href="#42233912">next</a><span>|</span><label class="collapse" for="c-42231606">[-]</label><label class="expand" for="c-42231606">[1 more]</label></div><br/><div class="children"><div class="content">They become trivial once you stop templating them with <i>text</i> templating engine.<p>They are serialized json objects, the YAML is there just because raw JSON is not user friendly when you need something done quick and dirty or include comments.<p>Proper templating should never use text templating on manifests.</div><br/></div></div></div></div></div></div></div></div><div id="42233912" class="c"><input type="checkbox" id="c-42233912" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#42231070">prev</a><span>|</span><a href="#42233116">next</a><span>|</span><label class="collapse" for="c-42233912">[-]</label><label class="expand" for="c-42233912">[1 more]</label></div><br/><div class="children"><div class="content">It sometimes blows my mind how reductionist and simplistic a world-view it&#x27;s possible to have and yet still attain some degree of success.<p>Shovels and mechanical excavators both exist and have a place on a building site. If you talk to a workman he may well tell you he has regular hammer with him at all times but will use a sledgehammer and even rent a pile driver on occasion if the task demands it.<p>And yet somehow we as software engineers are supposed to restrict ourselves to The One True Tool[tm] (which varies based on time and fashion) and use it for everything. It&#x27;s such an obviously dumb approach that even people who do basic manual labour realise its shortcomings.  Sometimes they will use a forklift truck to move things, sometimes an HGV, sometimes they will put things in a wheelbarrow and sometimes they will carry them by hand.  But us? No.  Sophisticated engineers as we are there is One Way and it doesn&#x27;t matter if you&#x27;re a 3 person startup or you&#x27;re Google, if you deploy once per year to a single big server or multiple times per day to a farm of thousands of hosts you&#x27;re supposed to do it that one way no matter what.<p>The real rule is this: Use your judgement.<p>You&#x27;re supposed to be smart. You&#x27;re supposed to be good.  Be good.  Figure out what&#x27;s actually going on and how best to solve the problems in your situation. Don&#x27;t rely on everyone else to tell you what to do or blindly apply &quot;best practises&quot; invented by someone who doesn&#x27;t know a thing about what you&#x27;re trying to do. Yes consider the experiences of others and learn from their mistakes where possible, but use your own goddamn brain and skill.  That&#x27;s why they pay you the big bucks.</div><br/></div></div><div id="42233116" class="c"><input type="checkbox" id="c-42233116" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#42233912">prev</a><span>|</span><a href="#42227961">next</a><span>|</span><label class="collapse" for="c-42233116">[-]</label><label class="expand" for="c-42233116">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but the people just cannot comprehend the complexity of it. Even my academic professor for my FYP back when was an undergrad, now he reverted back to Docker Compose, citing the integration is so convoluted that developing for it is very difficult. That&#x27;s why I&#x27;m aiming to cut down the complexity of Kubernetes with a low-friction, turnkey solution, but I guess the angel investors in Hong Kong aren&#x27;t buying into it yet. I&#x27;m still aiming to try again after 2 years when I can at least get an MVP that is complete though (I don&#x27;t like to present imperfect stuff, either you just have the idea or you give me the full product and not half baked shit)</div><br/></div></div><div id="42227961" class="c"><input type="checkbox" id="c-42227961" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#42233116">prev</a><span>|</span><a href="#42228020">next</a><span>|</span><label class="collapse" for="c-42227961">[-]</label><label class="expand" for="c-42227961">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Spawning containers, of course, requires you to mount the Docker socket in your web app, which is wildly insecure<p>Dear friend, you are not a systems programmer</div><br/><div id="42228432" class="c"><input type="checkbox" id="c-42228432" checked=""/><div class="controls bullet"><span class="by">pzmarzly</span><span>|</span><a href="#42227961">parent</a><span>|</span><a href="#42228020">next</a><span>|</span><label class="collapse" for="c-42228432">[-]</label><label class="expand" for="c-42228432">[2 more]</label></div><br/><div class="children"><div class="content">To expand on this, the author is describing the so-called &quot;Docker-out-of-Docker  (DooD) pattern&quot;, i.e. exposing Docker&#x27;s Unix socket into the container. Since Docker was designed to work remotely (CLI on another machine than DOCKER_HOST), this works fine, but essentially negates all isolation.<p>For many years now, all major container runtimes support nesting. Some make it easy (podman and runc just work), some hard (systemd-nspawn requires setting many flags to work nested). This is called &quot;Docker-in-a-Docker (DinD)&quot;.</div><br/><div id="42233422" class="c"><input type="checkbox" id="c-42233422" checked=""/><div class="controls bullet"><span class="by">waynesonfire</span><span>|</span><a href="#42227961">root</a><span>|</span><a href="#42228432">parent</a><span>|</span><a href="#42228020">next</a><span>|</span><label class="collapse" for="c-42233422">[-]</label><label class="expand" for="c-42233422">[1 more]</label></div><br/><div class="children"><div class="content">FreeBSD has supported nesting of jails natively since version 8.0, which dates back to 2009.<p>I prefer FreeBSD to K8s.</div><br/></div></div></div></div></div></div><div id="42228020" class="c"><input type="checkbox" id="c-42228020" checked=""/><div class="controls bullet"><span class="by">rthnbgrredf</span><span>|</span><a href="#42227961">prev</a><span>|</span><a href="#42228167">next</a><span>|</span><label class="collapse" for="c-42228020">[-]</label><label class="expand" for="c-42228020">[6 more]</label></div><br/><div class="children"><div class="content">I think we need to distinguish between two cases:<p>For a hobby project, using Docker Compose or Podman combined with systemd and some shell scripts is perfectly fine. You’re the only one responsible, and you have the freedom to choose whatever works best for you.<p>However, in a company setting, things are quite different. Your boss may assign you new tasks that could require writing a lot of custom scripts. This can become a problem for other team members and contractors, as such scripts are often undocumented and don’t follow industry standards.<p>In this case, I would recommend using Kubernetes (k8s), but only if the company has a dedicated Kubernetes team with an established on-call rotation. Alternatively, I suggest leveraging a managed cloud service like ECS Fargate to handle container orchestration.<p>There’s also strong competition in the &quot;Container as a Service&quot; (CaaS) space, with smaller and more cost-effective options available if you prefer to avoid the major cloud providers. Overall, these CaaS solutions require far less maintenance compared to managing your own cluster.</div><br/><div id="42228403" class="c"><input type="checkbox" id="c-42228403" checked=""/><div class="controls bullet"><span class="by">klooney</span><span>|</span><a href="#42228020">parent</a><span>|</span><a href="#42228093">next</a><span>|</span><label class="collapse" for="c-42228403">[-]</label><label class="expand" for="c-42228403">[1 more]</label></div><br/><div class="children"><div class="content">&gt; dedicated Kubernetes team with an established on-call rotation.<p>Using EKS or GKS is basically this. K8s is much nicer than ECS in terms of development and packaging your own apps.</div><br/></div></div><div id="42228093" class="c"><input type="checkbox" id="c-42228093" checked=""/><div class="controls bullet"><span class="by">chamomeal</span><span>|</span><a href="#42228020">parent</a><span>|</span><a href="#42228403">prev</a><span>|</span><a href="#42228137">next</a><span>|</span><label class="collapse" for="c-42228093">[-]</label><label class="expand" for="c-42228093">[3 more]</label></div><br/><div class="children"><div class="content">How would you feel if bash scripts were replaced with Ansible playbooks?<p>At a previous job at a teeny startup, each instance of the environment is a docker-compose instance on a VPS. It works great, but they’re starting to get a bunch of new clients, and some of them need fully independent instances of the app.<p>Deployment gets harder with every instance because it’s just a pile of bash scripts on each server. My old coworkers have to run a build for each instance for every deploy.<p>None of us had used ansible, which <i>seems</i> like it could be a solution. It would be a new headache to learn, but it seems like less of a headache than kubernetes!</div><br/><div id="42229081" class="c"><input type="checkbox" id="c-42229081" checked=""/><div class="controls bullet"><span class="by">rthnbgrredf</span><span>|</span><a href="#42228020">root</a><span>|</span><a href="#42228093">parent</a><span>|</span><a href="#42228392">next</a><span>|</span><label class="collapse" for="c-42229081">[-]</label><label class="expand" for="c-42229081">[1 more]</label></div><br/><div class="children"><div class="content">Ansible is better than Bash if your goals include:<p>* Automating repetitive tasks across many servers.<p>* Ensuring idempotent configurations (e.g., setting up web servers, installing packages consistently).<p>* Managing infrastructure as code for better version control and collaboration.<p>* Orchestrating complex workflows that involve multiple steps or dependencies.<p>However, Ansible is not a container orchestrator.<p>Kubernetes (K8s) provides capabilities that Ansible or Docker-Compose cannot match. While Docker-Compose only supports a basic subset, Kubernetes offers:<p>* Advanced orchestration features, such as rolling updates, health checks, scaling, and self-healing.<p>* Automatic maintenance of the desired state for running workloads.<p>* Restarting failed containers, rescheduling pods, and replacing unhealthy nodes.<p>* Horizontal pod auto-scaling based on metrics (e.g., CPU, memory, or custom metrics).<p>* Continuous monitoring and reconciliation of the actual state with the desired state.<p>* Immediate application of changes to bring resources to the desired configuration.<p>* Service discovery via DNS and automatic load balancing across pods.<p>* Native support for Persistent Volumes (PVs) and Persistent Volume Claims (PVCs) for storage management.<p>* Abstraction of storage providers, supporting local, cloud, and network storage.<p>If you need these features but are concerned about the complexity of Kubernetes, consider using a managed Kubernetes service like GKE or EKS to simplify deployment and management. Alternatively, and this is my prefered option, combining Terraform with a Container-as-a-Service (CaaS) platform allows the provider to handle most of the operational complexity for you.</div><br/></div></div><div id="42228392" class="c"><input type="checkbox" id="c-42228392" checked=""/><div class="controls bullet"><span class="by">klooney</span><span>|</span><a href="#42228020">root</a><span>|</span><a href="#42228093">parent</a><span>|</span><a href="#42229081">prev</a><span>|</span><a href="#42228137">next</a><span>|</span><label class="collapse" for="c-42228392">[-]</label><label class="expand" for="c-42228392">[1 more]</label></div><br/><div class="children"><div class="content">Ansible ultimately runs scripts, in parallel, in a defined order across machines. It can help a lot, but it&#x27;s subject to a lot of the same state bitrot issues as a pole of shell scripts.</div><br/></div></div></div></div><div id="42228137" class="c"><input type="checkbox" id="c-42228137" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#42228020">parent</a><span>|</span><a href="#42228093">prev</a><span>|</span><a href="#42228167">next</a><span>|</span><label class="collapse" for="c-42228137">[-]</label><label class="expand" for="c-42228137">[1 more]</label></div><br/><div class="children"><div class="content">Up until a few thousand instances, a well designed setup should be a part time job for a couple of people.<p>To that scale you can write a custom orchestrator that is likely to be smaller and simpler than the equivalent K8S setup. Been there, done that.</div><br/></div></div></div></div><div id="42228167" class="c"><input type="checkbox" id="c-42228167" checked=""/><div class="controls bullet"><span class="by">diminish</span><span>|</span><a href="#42228020">prev</a><span>|</span><a href="#42232451">next</a><span>|</span><label class="collapse" for="c-42228167">[-]</label><label class="expand" for="c-42228167">[1 more]</label></div><br/><div class="children"><div class="content">One can build a better container orchestration than kubernetes; things don&#x27;t need to be that complex.</div><br/></div></div><div id="42232451" class="c"><input type="checkbox" id="c-42232451" checked=""/><div class="controls bullet"><span class="by">skeptrune</span><span>|</span><a href="#42228167">prev</a><span>|</span><a href="#42231430">next</a><span>|</span><label class="collapse" for="c-42232451">[-]</label><label class="expand" for="c-42232451">[2 more]</label></div><br/><div class="children"><div class="content">I was very scared of K8s for a long time then we started using it and it&#x27;s actually great. Much less complex than its reputation suggests.</div><br/><div id="42233351" class="c"><input type="checkbox" id="c-42233351" checked=""/><div class="controls bullet"><span class="by">umvi</span><span>|</span><a href="#42232451">parent</a><span>|</span><a href="#42231430">next</a><span>|</span><label class="collapse" for="c-42233351">[-]</label><label class="expand" for="c-42233351">[1 more]</label></div><br/><div class="children"><div class="content">I had the exact opposite experience. I had a cloud run app in gcp and experimented with moving it to k8s and I was astonished with the amount of new complexity I had to manage</div><br/></div></div></div></div><div id="42231430" class="c"><input type="checkbox" id="c-42231430" checked=""/><div class="controls bullet"><span class="by">knowsuchagency</span><span>|</span><a href="#42232451">prev</a><span>|</span><a href="#42230165">next</a><span>|</span><label class="collapse" for="c-42231430">[-]</label><label class="expand" for="c-42231430">[1 more]</label></div><br/><div class="children"><div class="content">For my own websites, I host everything on a a single $20&#x2F;month hetzner instance using <a href="https:&#x2F;&#x2F;dokploy.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dokploy.com&#x2F;</a> and I&#x27;m never going back.</div><br/></div></div><div id="42230165" class="c"><input type="checkbox" id="c-42230165" checked=""/><div class="controls bullet"><span class="by">hamdouni</span><span>|</span><a href="#42231430">prev</a><span>|</span><a href="#42231034">next</a><span>|</span><label class="collapse" for="c-42230165">[-]</label><label class="expand" for="c-42230165">[1 more]</label></div><br/><div class="children"><div class="content">I was using some ansible playbook scripts to deploy to production some web app. One day the scripts stopped working because of a boring error about python version mismatch.<p>I rewrite all the deployment scripts with bash (took less than a hour) and never had a problem since.<p>Morality: it&#x27;s hard to find the right tool for the job</div><br/></div></div><div id="42231034" class="c"><input type="checkbox" id="c-42231034" checked=""/><div class="controls bullet"><span class="by">alganet</span><span>|</span><a href="#42230165">prev</a><span>|</span><a href="#42233247">next</a><span>|</span><label class="collapse" for="c-42231034">[-]</label><label class="expand" for="c-42231034">[1 more]</label></div><br/><div class="children"><div class="content">Why do I feel this is not so simple as the compiler scenario?<p>I&#x27;ve seen a lot of &quot;piles of YAML&quot;, even contributed to some. There were some good projects that didn&#x27;t end up in disaster, but to me the same could be said for the shell.</div><br/></div></div><div id="42233247" class="c"><input type="checkbox" id="c-42233247" checked=""/><div class="controls bullet"><span class="by">walterburns</span><span>|</span><a href="#42231034">prev</a><span>|</span><a href="#42228523">next</a><span>|</span><label class="collapse" for="c-42233247">[-]</label><label class="expand" for="c-42233247">[2 more]</label></div><br/><div class="children"><div class="content">I wish the world hadn&#x27;t consolidated around Kubernetes. Rancher was fantastic. Did what 95% of us need, and dead simple to add and manage services.</div><br/><div id="42234193" class="c"><input type="checkbox" id="c-42234193" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#42233247">parent</a><span>|</span><a href="#42228523">next</a><span>|</span><label class="collapse" for="c-42234193">[-]</label><label class="expand" for="c-42234193">[1 more]</label></div><br/><div class="children"><div class="content">Did you find Rancher v2 (which uses Kubernetes instead of their own Cattle system) is worse?</div><br/></div></div></div></div><div id="42228523" class="c"><input type="checkbox" id="c-42228523" checked=""/><div class="controls bullet"><span class="by">lttlrck</span><span>|</span><a href="#42233247">prev</a><span>|</span><a href="#42230492">next</a><span>|</span><label class="collapse" for="c-42228523">[-]</label><label class="expand" for="c-42228523">[1 more]</label></div><br/><div class="children"><div class="content">I thought k8s might be a solution so I decided to learn through doing. It quickly became obvious that we didn&#x27;t need 90% of its capabilities but more important it&#x27;d put undue load&#x2F;training on the rest of the team. It would be a lot more sensible to write custom orchestration using the docker API - that was straightforward.<p>Experimenting with k8s was very much worthwhile. It&#x27;s an amazing thing and was in many ways inspirational. But using it would have been swimming against the tide so to speak. So sure I built a mini-k8s-lite, it&#x27;s better for us, it fits better than wrapping docker compose.<p>My only doubt is whether I should have used podman instead but at the time podman seemed to be in an odd place (3-4 years ago now). Though it&#x27;d be quite easy to switch now it hardly seems worthwhile.</div><br/></div></div><div id="42230492" class="c"><input type="checkbox" id="c-42230492" checked=""/><div class="controls bullet"><span class="by">marcusestes</span><span>|</span><a href="#42228523">prev</a><span>|</span><a href="#42229291">next</a><span>|</span><label class="collapse" for="c-42230492">[-]</label><label class="expand" for="c-42230492">[1 more]</label></div><br/><div class="children"><div class="content">You did a no-SQL, you did a serverless, you did a micro-services. This makes it abundantly clear you do not understand the nature of your architectural patterns and the multiplicity of your offenses.</div><br/></div></div><div id="42229291" class="c"><input type="checkbox" id="c-42229291" checked=""/><div class="controls bullet"><span class="by">nanomcubed</span><span>|</span><a href="#42230492">prev</a><span>|</span><a href="#42231248">next</a><span>|</span><label class="collapse" for="c-42229291">[-]</label><label class="expand" for="c-42229291">[1 more]</label></div><br/><div class="children"><div class="content">Like, okay, if that&#x27;s how you see it, but what&#x27;s with the tone and content?<p>The tone&#x27;s vapidity is only comparable to the content&#x27;s.<p>This reads like mocking the target audience rather than showing them how you can help.<p>A write up that took said &quot;pile of shell scripts that do not work&quot; and showed how to &quot;make it work&quot; with your technology of choice would have been more interesting than whatever this is.</div><br/></div></div><div id="42231248" class="c"><input type="checkbox" id="c-42231248" checked=""/><div class="controls bullet"><span class="by">mildred593</span><span>|</span><a href="#42229291">prev</a><span>|</span><label class="collapse" for="c-42231248">[-]</label><label class="expand" for="c-42231248">[1 more]</label></div><br/><div class="children"><div class="content">Started with a large shell script, the next itération was written in go and less specific. I still think for some things, k8s is just too much<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mildred&#x2F;conductor.go&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;mildred&#x2F;conductor.go&#x2F;</a></div><br/></div></div></div></div></div></div></div></body></html>