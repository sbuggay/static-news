<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707469260071" as="style"/><link rel="stylesheet" href="styles.css?v=1707469260071"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.citusdata.com/blog/2024/02/08/whats-new-in-postgres-16-query-planner-optimizer/">What&#x27;s new in the Postgres 16 query planner</a> <span class="domain">(<a href="https://www.citusdata.com">www.citusdata.com</a>)</span></div><div class="subtext"><span>clairegiordano</span> | <span>43 comments</span></div><br/><div><div id="39312418" class="c"><input type="checkbox" id="c-39312418" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#39312814">next</a><span>|</span><label class="collapse" for="c-39312418">[-]</label><label class="expand" for="c-39312418">[6 more]</label></div><br/><div class="children"><div class="content">Query planner improvements are always welcome, it&#x27;s a very important part of the DB. Though of course most of the time you notice it is when it&#x27;s not doing what you want ;-).<p>One part of this I found rather frustrating is the JIT in newer Postgres versions. The heuristics on when to use appear not robust at all to me. I&#x27;ve seen this for a rather typical ORM-generated query that is pretty straightforward, but pulls in a lot of other tables via joins. It runs in a few milliseconds without the JIT, but the JIT spent 1-1.5 seconds doing its thing on top of that and makes it incredibly slow for tiny amounts of data.<p>I know now to just disable the JIT, but this feature can give a pretty terrible impression to users that don&#x27;t know enough yet to figure out why it&#x27;s slow. I like Postgres a lot, but enabling the JIT just seems far too dangerous as a default setting to me.</div><br/><div id="39312796" class="c"><input type="checkbox" id="c-39312796" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#39312418">parent</a><span>|</span><a href="#39312632">next</a><span>|</span><label class="collapse" for="c-39312796">[-]</label><label class="expand" for="c-39312796">[1 more]</label></div><br/><div class="children"><div class="content">I believe the JIT is pretty much a failure, yes. It was well-meant, but LLVM just isn&#x27;t the right tool for this. I&#x27;ve turned it off globally. (I don&#x27;t use any ORMs, so it&#x27;s not simply about strange query patterns.)<p>Query parallelization, on the other hand, can actually be useful—and most importantly, rarely hurts.</div><br/></div></div><div id="39312632" class="c"><input type="checkbox" id="c-39312632" checked=""/><div class="controls bullet"><span class="by">aidos</span><span>|</span><a href="#39312418">parent</a><span>|</span><a href="#39312796">prev</a><span>|</span><a href="#39312633">next</a><span>|</span><label class="collapse" for="c-39312632">[-]</label><label class="expand" for="c-39312632">[1 more]</label></div><br/><div class="children"><div class="content">We hit a curios bug recently on production with the JIT.<p>I had apt updated a couple of packages and then all of a sudden a bigger query we run every 5 minutes was failing. Or rather, Postgres just started silently hanging up the connection mid query execution with even putting anything in the logs.<p>Took me a while of running manually in explain to see that the variations of the query that ended up using the JIT broke while those that didn’t were ok. Disabled the JIT and everything was ok again.</div><br/></div></div><div id="39312633" class="c"><input type="checkbox" id="c-39312633" checked=""/><div class="controls bullet"><span class="by">czl</span><span>|</span><a href="#39312418">parent</a><span>|</span><a href="#39312632">prev</a><span>|</span><a href="#39312814">next</a><span>|</span><label class="collapse" for="c-39312633">[-]</label><label class="expand" for="c-39312633">[3 more]</label></div><br/><div class="children"><div class="content">Did you try using prepared statement so the compilation is done once and compiled results are reused each time that query is run?</div><br/><div id="39312752" class="c"><input type="checkbox" id="c-39312752" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#39312418">root</a><span>|</span><a href="#39312633">parent</a><span>|</span><a href="#39312814">next</a><span>|</span><label class="collapse" for="c-39312752">[-]</label><label class="expand" for="c-39312752">[2 more]</label></div><br/><div class="children"><div class="content">As far as I understand prepared statements don&#x27;t help here as the JIT output is not saved but generated for each execution. In this case I&#x27;m also using an ORM (EF Core) which doesn&#x27;t expose the ability to prepare statements.</div><br/><div id="39312798" class="c"><input type="checkbox" id="c-39312798" checked=""/><div class="controls bullet"><span class="by">trollied</span><span>|</span><a href="#39312418">root</a><span>|</span><a href="#39312752">parent</a><span>|</span><a href="#39312814">next</a><span>|</span><label class="collapse" for="c-39312798">[-]</label><label class="expand" for="c-39312798">[1 more]</label></div><br/><div class="children"><div class="content">Most optimisers cache the execution plan based on a hash of the query, hence reuse when using prepared statements vs not.<p>Oracle has an option to detect literals (CURSOR_SHARING) and essentially replace them with binds internally, in order to increase performance and stop the query pool getting filled up with the same statement(s).</div><br/></div></div></div></div></div></div></div></div><div id="39312814" class="c"><input type="checkbox" id="c-39312814" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#39312418">prev</a><span>|</span><a href="#39311396">next</a><span>|</span><label class="collapse" for="c-39312814">[-]</label><label class="expand" for="c-39312814">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be interested to know how often these changes have an effect in real queries. The &quot;Use Limit instead of Unique to implement DISTINCT, when possible&quot; change in particular feels like it would only apply to very silly queries.<p>Do the PostgreSQL developers have any source of information about this?</div><br/></div></div><div id="39311396" class="c"><input type="checkbox" id="c-39311396" checked=""/><div class="controls bullet"><span class="by">wiradikusuma</span><span>|</span><a href="#39312814">prev</a><span>|</span><a href="#39312734">next</a><span>|</span><label class="collapse" for="c-39311396">[-]</label><label class="expand" for="c-39311396">[8 more]</label></div><br/><div class="children"><div class="content">I use this tool to visualize my queries: <a href="https:&#x2F;&#x2F;explain.dalibo.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;explain.dalibo.com&#x2F;</a> (there&#x27;s also <a href="https:&#x2F;&#x2F;www.pgexplain.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.pgexplain.dev&#x2F;</a>, last time the output was less nice, but now both look the same)</div><br/><div id="39311821" class="c"><input type="checkbox" id="c-39311821" checked=""/><div class="controls bullet"><span class="by">uudecoded</span><span>|</span><a href="#39311396">parent</a><span>|</span><a href="#39311529">next</a><span>|</span><label class="collapse" for="c-39311821">[-]</label><label class="expand" for="c-39311821">[4 more]</label></div><br/><div class="children"><div class="content">I read your profile and see that you are a CTO of a fintech. Given that, by what method do you navigate that tool&#x27;s [explain.dalibo.com] assertion of &quot;It is recommended not to send any critical or sensitive information&quot;?<p>Is there an explain plan sanitizer that is helpful for this situation?</div><br/><div id="39311854" class="c"><input type="checkbox" id="c-39311854" checked=""/><div class="controls bullet"><span class="by">Defman</span><span>|</span><a href="#39311396">root</a><span>|</span><a href="#39311821">parent</a><span>|</span><a href="#39311529">next</a><span>|</span><label class="collapse" for="c-39311854">[-]</label><label class="expand" for="c-39311854">[3 more]</label></div><br/><div class="children"><div class="content">You can download the whole visualizer as a simple html file and use it this way. No need to obfuscate or sanitize anything at all.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dalibo&#x2F;pev2">https:&#x2F;&#x2F;github.com&#x2F;dalibo&#x2F;pev2</a></div><br/><div id="39311925" class="c"><input type="checkbox" id="c-39311925" checked=""/><div class="controls bullet"><span class="by">uudecoded</span><span>|</span><a href="#39311396">root</a><span>|</span><a href="#39311854">parent</a><span>|</span><a href="#39311529">next</a><span>|</span><label class="collapse" for="c-39311925">[-]</label><label class="expand" for="c-39311925">[2 more]</label></div><br/><div class="children"><div class="content">Thank you for sharing - I misunderstood - this is a javascript visualizer, and has no additional analytic capability beyond visualization, or did I miss something?</div><br/><div id="39312052" class="c"><input type="checkbox" id="c-39312052" checked=""/><div class="controls bullet"><span class="by">Defman</span><span>|</span><a href="#39311396">root</a><span>|</span><a href="#39311925">parent</a><span>|</span><a href="#39311529">next</a><span>|</span><label class="collapse" for="c-39312052">[-]</label><label class="expand" for="c-39312052">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, you’re right. This is the visualizer that’s linked in the parent comment. I just wanted to point out that you can use it locally without sending your explain plan to anyone. Sorry for the confusion, I’ll edit my original comment.</div><br/></div></div></div></div></div></div></div></div><div id="39311529" class="c"><input type="checkbox" id="c-39311529" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#39311396">parent</a><span>|</span><a href="#39311821">prev</a><span>|</span><a href="#39312734">next</a><span>|</span><label class="collapse" for="c-39311529">[-]</label><label class="expand" for="c-39311529">[3 more]</label></div><br/><div class="children"><div class="content">The tool is great and I use it, but I don&#x27;t really have a deep enough understanding to know how to fix issues in my approach from what looks bad in the plan.</div><br/><div id="39311611" class="c"><input type="checkbox" id="c-39311611" checked=""/><div class="controls bullet"><span class="by">davidrowley</span><span>|</span><a href="#39311396">root</a><span>|</span><a href="#39311529">parent</a><span>|</span><a href="#39312008">next</a><span>|</span><label class="collapse" for="c-39311611">[-]</label><label class="expand" for="c-39311611">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty hard to tell if a plan is good or bad from EXPLAIN without using the ANALYZE option.  With EXPLAIN ANALYZE you can see where the time is being spent, so can you get an idea of which part of the plan you should focus on.<p>To know if it&#x27;s a bad plan, it does take quite a bit of knowledge as you need to know what alternative plans could have been used instead.  It takes quite a bit of time to learn that stuff. You need to know what PostgreSQL is capable of. Some computer science knowledge helps here as you&#x27;ll know, for example, when a hash join is a good way to join a table vs a nested loop.<p>As for fixing plan you&#x27;ve identified as bad, that also takes quite a bit of experience.  If you understand the EXPLAIN ANALYZE output well, that&#x27;s a good start. Looking for places where the estimated rows differ from the actual can be key.  Having an understanding of how Postgres performed the row estimations helps. That&#x27;s not something that comes easily without looking at the source code, unfortunately.  Understanding tools that you have to change the plan is useful. Perhaps that&#x27;s CREATE STATISTICS, or adjusting the stats targets on existing single column stats.  Or maybe creating a new index.  Having a test environment that allows you to experiment is very useful too.</div><br/></div></div><div id="39312008" class="c"><input type="checkbox" id="c-39312008" checked=""/><div class="controls bullet"><span class="by">dewey</span><span>|</span><a href="#39311396">root</a><span>|</span><a href="#39311529">parent</a><span>|</span><a href="#39311611">prev</a><span>|</span><a href="#39312734">next</a><span>|</span><label class="collapse" for="c-39312008">[-]</label><label class="expand" for="c-39312008">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also <a href="https:&#x2F;&#x2F;www.pgmustard.com" rel="nofollow">https:&#x2F;&#x2F;www.pgmustard.com</a>, which gives you a bit more hints and information on the possible optimizations.</div><br/></div></div></div></div></div></div><div id="39312734" class="c"><input type="checkbox" id="c-39312734" checked=""/><div class="controls bullet"><span class="by">jhoechtl</span><span>|</span><a href="#39311396">prev</a><span>|</span><a href="#39311181">next</a><span>|</span><label class="collapse" for="c-39312734">[-]</label><label class="expand" for="c-39312734">[1 more]</label></div><br/><div class="children"><div class="content">Why is this released by citusdata instead on postgresql.org? Is this a paid feature only or an open source addition?</div><br/></div></div><div id="39311181" class="c"><input type="checkbox" id="c-39311181" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#39312734">prev</a><span>|</span><label class="collapse" for="c-39311181">[-]</label><label class="expand" for="c-39311181">[26 more]</label></div><br/><div class="children"><div class="content">Why wouldnt they implement hints..</div><br/><div id="39311231" class="c"><input type="checkbox" id="c-39311231" checked=""/><div class="controls bullet"><span class="by">davidrowley</span><span>|</span><a href="#39311181">parent</a><span>|</span><a href="#39312274">next</a><span>|</span><label class="collapse" for="c-39311231">[-]</label><label class="expand" for="c-39311231">[24 more]</label></div><br/><div class="children"><div class="content">There is a pg_hint_plan extension.  I think the danger with hints is that they might only be correct when written.  If the table sizes or data skew changes, they might make things worse.  I don&#x27;t have a link to hand, but last time I recall a discussion on hints there was no general objection to them, providing the implementation could be done in a way that didn&#x27;t force the planner&#x27;s hand too strongly and still allowed it to adapt to the underlying data changing.  For example, indicating there&#x27;s a correlation between two columns, rather than specifying a given predicate matches 10 rows.</div><br/><div id="39311857" class="c"><input type="checkbox" id="c-39311857" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311231">parent</a><span>|</span><a href="#39311610">next</a><span>|</span><label class="collapse" for="c-39311857">[-]</label><label class="expand" for="c-39311857">[2 more]</label></div><br/><div class="children"><div class="content">&gt;I think the danger with hints is that they might only be correct when written.<p>Not &quot;correct when written&quot;, but &quot;scaling as written&quot;. That means if you force the execution that scales linearly or quadratically, that&#x27;s what you get all the time. If the row number increases, you know what will happen. You can monitor that ahead of time and plan for the increase.<p>On the other hand without the hints, you don&#x27;t know when and how the plan will change without testing. At some random point postgres can decide to do something terribly stupid and at that point you get to figure out what happened and how to fix that in an emergency mode. Do you know how to adjust the right statistics? Do you need to change the indexes? Do you know how long that will take?</div><br/><div id="39312171" class="c"><input type="checkbox" id="c-39312171" checked=""/><div class="controls bullet"><span class="by">appplication</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311857">parent</a><span>|</span><a href="#39311610">next</a><span>|</span><label class="collapse" for="c-39312171">[-]</label><label class="expand" for="c-39312171">[1 more]</label></div><br/><div class="children"><div class="content">I had this happen for the first time to some prod jobs the other day in spark. We made a pretty normal update to a join with an additional condition, our integration tests which run local Spark succeeded. But something about it running on the cluster… it was generating a completely different query plan than it ran locally. We eventually had to rewrite the whole query to work around it because it was trying to broadcast a 3TB table and couldn’t be talked out of it.</div><br/></div></div></div></div><div id="39311610" class="c"><input type="checkbox" id="c-39311610" checked=""/><div class="controls bullet"><span class="by">hibikir</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311231">parent</a><span>|</span><a href="#39311857">prev</a><span>|</span><a href="#39312469">next</a><span>|</span><label class="collapse" for="c-39311610">[-]</label><label class="expand" for="c-39311610">[2 more]</label></div><br/><div class="children"><div class="content">The one I&#x27;d love to tell the planner is that a table holds transactions in time, and that it should not expect that today&#x27;s data is empty because it was empty 10 hours ago. It&#x27;s an extremely common pattern, it makes any statistics gathering based on percentage of data changed dubious pretty quickly, and harms a whole lot of real queries, because in data like this, people care the most about the recent data.<p>There are ways to organize data to minimize the issue, but it&#x27;d be so much nicer if we could just teach the optimizer that this is the way the data is shaped.</div><br/><div id="39311807" class="c"><input type="checkbox" id="c-39311807" checked=""/><div class="controls bullet"><span class="by">davidrowley</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311610">parent</a><span>|</span><a href="#39312469">next</a><span>|</span><label class="collapse" for="c-39311807">[-]</label><label class="expand" for="c-39311807">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The one I&#x27;d love to tell the planner is that a table holds transactions in time, and that it should not expect that today&#x27;s data is empty because it was empty 10 hours ago. It&#x27;s an extremely common pattern, it makes any statistics gathering based on percentage of data changed dubious pretty quickly, and harms a whole lot of real queries, because in data like this, people care the most about the recent data.<p>It&#x27;s not a hint, but PostgreSQL does have something that can help with cases like that.<p>In some cases, to obtain selectivity estimates, the planner will probe a btree index to find the <i>actual</i> lower and&#x2F;or upper bound. For this to apply, a btree index must exist and you have to be using indexes &gt;, &gt;=, &lt; or &lt;= operator.  The planner will probe the index if the query is comparing the indexed column to a value that&#x27;s known the planner <i>if</i> that value falls on the <i>first</i> or <i>last</i> histogram bucket.  This can help when your statistics are slightly out of date and you&#x27;re querying for some column which stores a monotonically increasing or decreasing value.</div><br/></div></div></div></div><div id="39312469" class="c"><input type="checkbox" id="c-39312469" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311231">parent</a><span>|</span><a href="#39311610">prev</a><span>|</span><a href="#39312472">next</a><span>|</span><label class="collapse" for="c-39312469">[-]</label><label class="expand" for="c-39312469">[2 more]</label></div><br/><div class="children"><div class="content">I feel the best abstraction for hints would be to declare on tables how large you expect them to be -- and even throw errors if query plans with a good <i>scaling</i> cannot be found.<p>Say I could declare &quot;assume this table will grow very large&quot;, &quot;assume this table will be a small enum table&quot;.<p>And then it would use that information instead of actual table size to guide planning AND throw an error for any query doing a full table scan on a declared-to-be-large table -- so that missing indices can be detected instantly, not after running in prod for some days&#x2F;weeks.<p>Google Data Store has this property and it is a joy to work with for a backend developer.<p>What I am usually after is NOT the fastest plan, but the most consistent and robust plan across test and prod environments.</div><br/><div id="39312733" class="c"><input type="checkbox" id="c-39312733" checked=""/><div class="controls bullet"><span class="by">Semaphor</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39312469">parent</a><span>|</span><a href="#39312472">next</a><span>|</span><label class="collapse" for="c-39312733">[-]</label><label class="expand" for="c-39312733">[1 more]</label></div><br/><div class="children"><div class="content">Oh, that sounds really cool. I like declaring expected size, but &quot;throw on certain behaviors&quot; would be something I’d love in MS SQL.</div><br/></div></div></div></div><div id="39312472" class="c"><input type="checkbox" id="c-39312472" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311231">parent</a><span>|</span><a href="#39312469">prev</a><span>|</span><a href="#39312409">next</a><span>|</span><label class="collapse" for="c-39312472">[-]</label><label class="expand" for="c-39312472">[1 more]</label></div><br/><div class="children"><div class="content">I suspect the ideological problem with hints is that if the planner is producing a poor query, then the correct place to fix that is in the planner.<p>While I agree with this viewpoint, The problem is that most people don&#x27;t want to be a Postgress dev,  To actually enable people to fix the planner it would have to be exposed as a runtime service. And unless there was a lot of diligence the planner script would quickly degrade into an unmaintainable mess(low blow: just like most schemas.)</div><br/></div></div><div id="39312409" class="c"><input type="checkbox" id="c-39312409" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311231">parent</a><span>|</span><a href="#39312472">prev</a><span>|</span><a href="#39311714">next</a><span>|</span><label class="collapse" for="c-39312409">[-]</label><label class="expand" for="c-39312409">[1 more]</label></div><br/><div class="children"><div class="content">I guess that the solution to this problem can be automated. The DB or an extension to the DB or application code can run the query without hints sometimes and compare the result with the version with hints. If the hinted version is still faster, good. If it is slower, it&#x27;s time to tell the DBA. Or switch to the unhinted query automatically if it&#x27;s faster for a large enough number of times.</div><br/></div></div><div id="39311714" class="c"><input type="checkbox" id="c-39311714" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311231">parent</a><span>|</span><a href="#39312409">prev</a><span>|</span><a href="#39311276">next</a><span>|</span><label class="collapse" for="c-39311714">[-]</label><label class="expand" for="c-39311714">[1 more]</label></div><br/><div class="children"><div class="content">IMO hints need to be provided out of band, that is, not in the SQL query itself.  To do this it is necessary to have a way to address every table source, in every sub-query, then one can have hints as a pile of {table source, hint}.  Not that this solves the problem of hints rotting, but being able to separate them from the text of the query at least keeps the query clean, and makes is possible to have different sets of hints for different contexts and different RDBMS versions.</div><br/></div></div><div id="39311276" class="c"><input type="checkbox" id="c-39311276" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311231">parent</a><span>|</span><a href="#39311714">prev</a><span>|</span><a href="#39312274">next</a><span>|</span><label class="collapse" for="c-39311276">[-]</label><label class="expand" for="c-39311276">[14 more]</label></div><br/><div class="children"><div class="content">&gt; I think the danger with hints is that they might only be correct when written. If the table sizes or data skew changes, they might make things worse.<p>they will work in prod in the way engineer is expecting.
Current planner also can change its mood in unpredictable way and often generates sub-optimal plans for complex queries, because can&#x27;t reason about what specific subquery will return exactly, and you learn about it when queries start work very slow in production in the middle of the night.</div><br/><div id="39311319" class="c"><input type="checkbox" id="c-39311319" checked=""/><div class="controls bullet"><span class="by">davidrowley</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311276">parent</a><span>|</span><a href="#39311366">next</a><span>|</span><label class="collapse" for="c-39311319">[-]</label><label class="expand" for="c-39311319">[6 more]</label></div><br/><div class="children"><div class="content">(Postgres committer and blog author here) Personally, I don&#x27;t have any objection to hints.  The resolution of any statistics is never going to be high enough to always be accurate enough for all cases.  I think it would be good to give DBAs a better way to coax the planner into making or not making a certain decision.  It would also be nice if the planner was a little more risk-averse.  Currently, it&#x27;s happy to do things like Nested Loop join because it thinks some complex WHERE clause will only match 1 row.  Nested Loop works best for that, but if there are 2 rows, then generally, any other join type is better, especially so when the inner side of the join is expensive.</div><br/><div id="39311411" class="c"><input type="checkbox" id="c-39311411" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311319">parent</a><span>|</span><a href="#39312096">next</a><span>|</span><label class="collapse" for="c-39311411">[-]</label><label class="expand" for="c-39311411">[3 more]</label></div><br/><div class="children"><div class="content">One way to look at this is that the most accurate way to &quot;estimate&quot; how fast a certain plan would run, is to actually run it on the full dataset. But that obviously doesn&#x27;t make sense, as the optimizer is expected to come up with a plan in matter of milliseconds (or less for simple queries) and you don&#x27;t want your &quot;optimizer stats&quot; to be as big as the whole dataset itself. So optimizer has limited information, by design, and it has to come up with _something_ in a very short amount of time.<p>I don&#x27;t know much about Postgres optimizer, but I imagine that in addition to table&#x2F;column stats, is also uses structural info as its inputs, like existence of (enabled &amp; valid) constraints for example. If the optimizer knows that some column never has NULLs or is guaranteed to be unique, all kinds of transformation &amp; shortcuts become possible.<p>(There are plenty of large big-vendor ERP&#x2F;CRM&#x2F;etc apps out there that do not use DB constraints for the sake of &quot;portability&quot;... not fun to work with these).</div><br/><div id="39311536" class="c"><input type="checkbox" id="c-39311536" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311411">parent</a><span>|</span><a href="#39311495">next</a><span>|</span><label class="collapse" for="c-39311536">[-]</label><label class="expand" for="c-39311536">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t know much about Postgres optimizer, but I imagine that in addition to table&#x2F;column stats, is also uses structural info as its inputs, like existence of (enabled &amp; valid) constraints for example.<p>Here&#x27;s one that surprised me when I found out about it years ago, because I&#x27;d never really given it thought:  There&#x27;s a correlation statistic on columns for how well the values in that column match the row order on disk, which can influence a few different things.<p>In my case a query that retrieved a ton of data with an ORDER BY was using a sort and taking like two hours to run (a data source for an ETL process) - turned out because of a really bad correlation postgres was refusing to use the index, because the random access would be even slower, so it did a table scan then sort.  After figuring this out and discovering the CLUSTER command (reorders the data on disk to match an index), it did an index scan and didn&#x27;t need to sort at the end, was able to start streaming results immediately, and finished the entire query in like ten minutes.<p>Just a nice example of where the obvious &quot;use query hints to make it use the index&quot; would have been the worst option, instead figuring out why postgres didn&#x27;t want to use it and fixing that resulted in something much better.</div><br/></div></div><div id="39311495" class="c"><input type="checkbox" id="c-39311495" checked=""/><div class="controls bullet"><span class="by">davidrowley</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311411">parent</a><span>|</span><a href="#39311536">prev</a><span>|</span><a href="#39312096">next</a><span>|</span><label class="collapse" for="c-39311495">[-]</label><label class="expand" for="c-39311495">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you don&#x27;t want your &quot;optimizer stats&quot; to be as big as the whole dataset itself. So optimizer has limited information, by design, and it has to come up with _something_ in a very short amount of time.<p>This is very true. PostgreSQL does not do any proactive plan caching, so it&#x27;s important that the planner remains fast.  It is possible to adjust the number of stats targets to control the size of the histograms and most common values list. Upping that can be useful for OLAP-type workloads.<p>&gt; I imagine that in addition to table&#x2F;column stats, is also uses structural info as its inputs, like existence of (enabled &amp; valid) constraints for example.<p>Yes. Foreign key constraints are used to assist with join selectivity estimations. PG17 (when released) should be able to make more use of NOT NULL constraints to improve plans.</div><br/></div></div></div></div><div id="39312096" class="c"><input type="checkbox" id="c-39312096" checked=""/><div class="controls bullet"><span class="by">hans_castorp</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311319">parent</a><span>|</span><a href="#39311411">prev</a><span>|</span><a href="#39311795">next</a><span>|</span><label class="collapse" for="c-39312096">[-]</label><label class="expand" for="c-39312096">[1 more]</label></div><br/><div class="children"><div class="content">I think Oracle style hints are not a good thing to have - especially because you have to change the query itself which sometimes isn&#x27;t possible in a production environment. Additionally, for me they quite frequently made things worse after minor Oracle upgrades.<p>I would prefer having &quot;externally attached&quot; hints for a query (e.g. identified by it&#x27;s queryid) like Oracle&#x27;s stored outlines.</div><br/></div></div><div id="39311795" class="c"><input type="checkbox" id="c-39311795" checked=""/><div class="controls bullet"><span class="by">clhodapp</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311319">parent</a><span>|</span><a href="#39312096">prev</a><span>|</span><a href="#39311366">next</a><span>|</span><label class="collapse" for="c-39311795">[-]</label><label class="expand" for="c-39311795">[1 more]</label></div><br/><div class="children"><div class="content">It would be neat if you could at least provide expressions (that can&#x27;t hit any actual tables) to compute bounds for how many rows are expected to come back from any particular row source.</div><br/></div></div></div></div><div id="39311366" class="c"><input type="checkbox" id="c-39311366" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311276">parent</a><span>|</span><a href="#39311319">prev</a><span>|</span><a href="#39312274">next</a><span>|</span><label class="collapse" for="c-39311366">[-]</label><label class="expand" for="c-39311366">[7 more]</label></div><br/><div class="children"><div class="content">Indeed, hints are super-useful (essential!) for applying quick fixes when something unexpected suddenly happens in the optimizer&#x27;s magic. Or you just want to instruct&#x2F;nudge the optimizer towards doing the right thing, if you know the shape of your data and optimizer can&#x27;t see it or doesn&#x27;t act on it correctly for some reason. The downside is that people who don&#x27;t really know what exactly they want to achieve, will start applying incomplete sets of hints in random locations, based on Internet searches. And sometimes you&#x27;d even get lucky, that single index hint makes the problem go away - for a while!<p>And few people tend to remove hints after DB version upgrades, where the optimizer magic (or your table stats) have improved. Now you&#x27;re limiting optimizer&#x27;s choices. That&#x27;s been a problem (by now) for decades in the Oracle world with lots of legacy SQL code full of random hints where some of them aren&#x27;t even valid anymore, but others still are - and limit optimizer&#x27;s choices.<p>At least Oracle folks had enough at some point and introduced an &quot;optimizer_ignore_hints&quot; parameter [1], so all legacy hints that were added 20 years ago just get ignored - and the modern optimizer does a much better job getting things right.<p>I do regularly use hints in SQL tuning and troubleshooting experiments, just to verify and prove that a better plan is theoretically and physically possible - and if yes, then go from there. When the (deliberately placed) hints make the query faster, the next step is to check the hinted, faster plan&#x27;s optimizer cost estimate and drill down from there: Why did optimizer think that the other plan was cheaper or why did the optimizer think that the faster plan was more expensive. Then you end up with measuring row-count misestimates, etc...<p>But yes, plenty of people (including myself) have made legacy Oracle apps run much more efficiently and faster just by globally telling the DB to stop paying attention to all the old random hints lingering on and gathering object stats using the modern settings &amp; defaults (doesn&#x27;t always work though).<p>[1] <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;database&#x2F;oracle&#x2F;oracle-database&#x2F;19&#x2F;refrn&#x2F;OPTIMIZER_IGNORE_HINTS.html#GUID-D62CA6D8-D0D8-4A20-93EA-EEB4B3144347" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;database&#x2F;oracle&#x2F;oracle-database&#x2F;1...</a></div><br/><div id="39311438" class="c"><input type="checkbox" id="c-39311438" checked=""/><div class="controls bullet"><span class="by">davidrowley</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311366">parent</a><span>|</span><a href="#39311822">next</a><span>|</span><label class="collapse" for="c-39311438">[-]</label><label class="expand" for="c-39311438">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At least Oracle folks had enough at some point and introduced an &quot;optimizer_ignore_hints&quot; parameter [1], so all legacy hints that were added 20 years ago just get ignored - and the modern optimizer does a much better job getting things right.<p>I think the general attitude in the Postgres community is been from a purist point of view.  When you have a codebase around 40 years old, you do have to think carefully about what you put into it, as it might not be that easy to take it out again.  However, yes, I do think hints would be useful for Postgres, providing they&#x27;re done well.  It would be good to at least have something to assist with selectivity estimations.  Those are at least not directly forcing the planner into a single choice.  New planner&#x2F;executor smarts, such as something like Memoize added in PG14 could still be considered after upgrading an older pre-PG14 application with such hints, but perhaps not if the hint told the planner that it must nested loop join these two tables.</div><br/></div></div><div id="39311822" class="c"><input type="checkbox" id="c-39311822" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311366">parent</a><span>|</span><a href="#39311438">prev</a><span>|</span><a href="#39312274">next</a><span>|</span><label class="collapse" for="c-39311822">[-]</label><label class="expand" for="c-39311822">[5 more]</label></div><br/><div class="children"><div class="content">If not hints and manual plans then we need a way to &quot;freeze&quot; automatic optimizer plans however optimal they are after each tested release.<p>The optimizer killing your heavily-loaded production because it randomly switched a frequent query to a bad plan is pretty annoying. People mostly put up with this because for a single-instance DB you can easily maintain 4x spare CPU capacity but it&#x27;s impossible at scale.</div><br/><div id="39311933" class="c"><input type="checkbox" id="c-39311933" checked=""/><div class="controls bullet"><span class="by">davidrowley</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311822">parent</a><span>|</span><a href="#39312274">next</a><span>|</span><label class="collapse" for="c-39311933">[-]</label><label class="expand" for="c-39311933">[4 more]</label></div><br/><div class="children"><div class="content">It sounds like it would have to be an opt-in feature which could be applied per query, as otherwise wouldn&#x27;t it be equally as annoying if the planner didn&#x27;t adapt to the table data changing?<p>What may be better is if the executor provided feedback to the planner to tell it the new plan was worse than the old one. With that, you might be able to recover much more quickly and less likely to get a midnight phonecall. The tricky part would be when should the planner then retry the new plan again.  Also, other factors that influence the plan&#x27;s execution time such as locking would be a cause of noise for any sub-system that was monitoring this.</div><br/><div id="39312459" class="c"><input type="checkbox" id="c-39312459" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311933">parent</a><span>|</span><a href="#39312176">next</a><span>|</span><label class="collapse" for="c-39312459">[-]</label><label class="expand" for="c-39312459">[1 more]</label></div><br/><div class="children"><div class="content">&gt; wouldn&#x27;t it be equally as annoying if the planner didn&#x27;t adapt to the table data changing?<p>Not really, because at scale tables don&#x27;t change suddenly unless you release something -- and that will re-generate the plans after the perf testing.<p>Whatever changes slowly accumulate over time will be covered in the next release which normally should be very frequent, daily or more.</div><br/></div></div><div id="39312176" class="c"><input type="checkbox" id="c-39312176" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39311933">parent</a><span>|</span><a href="#39312459">prev</a><span>|</span><a href="#39312274">next</a><span>|</span><label class="collapse" for="c-39312176">[-]</label><label class="expand" for="c-39312176">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It sounds like it would have to be an opt-in feature which could be applied per query<p>That&#x27;s called a hint :)</div><br/><div id="39312477" class="c"><input type="checkbox" id="c-39312477" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#39311181">root</a><span>|</span><a href="#39312176">parent</a><span>|</span><a href="#39312274">next</a><span>|</span><label class="collapse" for="c-39312477">[-]</label><label class="expand" for="c-39312477">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly because a hint contains information that may become obsolete. A directive that freezes a known good auto-plan until the next release will not become obsolete as long as you keep releases rolling.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39312274" class="c"><input type="checkbox" id="c-39312274" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#39311181">parent</a><span>|</span><a href="#39311231">prev</a><span>|</span><label class="collapse" for="c-39312274">[-]</label><label class="expand" for="c-39312274">[1 more]</label></div><br/><div class="children"><div class="content">Related discussion<p><i>Why PostgreSQL doesn&#x27;t have query hints</i><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2179433">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2179433</a> (60 comments, 2011)<p>The official stance from the Postgres wiki <a href="https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;OptimizerHintsDiscussion" rel="nofollow">https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;OptimizerHintsDiscussion</a>:<p>&gt; We are not interested in implementing hints in the exact ways they are commonly implemented on other databases.<p>&gt; Problems with existing Hint systems: Poor application code maintainability, Interference with upgrades, Encouraging bad DBA habits, Does not scale with data size<p>I don&#x27;t fault their stance, but it&#x27;s frustrating when Postgres picks a stupid plan and can&#x27;t be convinced to do something reasonable.</div><br/></div></div></div></div></div></div></div></div></div></body></html>