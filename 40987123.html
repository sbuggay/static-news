<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721638876449" as="style"/><link rel="stylesheet" href="styles.css?v=1721638876449"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://langdev.stackexchange.com/questions/3942/what-are-the-ways-compilers-recognize-complex-patterns">What are the ways compilers recognize complex patterns?</a> <span class="domain">(<a href="https://langdev.stackexchange.com">langdev.stackexchange.com</a>)</span></div><div class="subtext"><span>azeemba</span> | <span>12 comments</span></div><br/><div><div id="41030527" class="c"><input type="checkbox" id="c-41030527" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41030546">next</a><span>|</span><label class="collapse" for="c-41030527">[-]</label><label class="expand" for="c-41030527">[2 more]</label></div><br/><div class="children"><div class="content">Canonical forms, smart stuff, a lot of hardcoding.<p>Canonical forms are the really important part. Simple example: there are multiple ways a program might say “X * 2”. You could shift left by 1. You could multiple by 2. You could add X to itself. The idea of canonical forms is that in one pass, the compiler will pattern match all the ways you can do this and reduce all of them to the same canonical form - say, left shift by 1. Then, subsequent passes that want to catch more complex uses of that construct only have to look for one version of it (left shift 1) and not all three.<p>Here’s a more complex case. Ternary expressions in C and if-else statements have the same representation in llvm IR generated by clang: basic blocks and branches. There are multiple ways of representing the data flow (could use allocas and stores&#x2F;loads or SSA data flow) but both the sroa and mem2reg passes will canonicalize to SSA. And, last I checked llvm says that the preferred canonical form of a if-then-else is a select (I.e. conditional move) whenever the two are equivalent. So, no matter what you use to write the equivalent of std::min - macros, templates, whatever, coding style don’t matter - you will end up eventually with a select instruction whose predicate is a comparison. Then - if your CPU supports doing min in a single instruction, it’s trivial for the instruction selector to just look for that kind of select. This happens not because every way of writing min is hardcoded, but because multiple rounds of canonicalization (clang using basic blocks and branches for both if&#x2F;else and ternaries, sroa and mem2reg preferring SSA, and if conversion preferring select) gets you there.<p>A lot of this is hardcoding, but it’s not the boring “hardcode everything” kind of approach, but rather, it’s about using multiple phases that each produce increasingly canonical code that makes subsequent pattern matching simpler.</div><br/><div id="41031000" class="c"><input type="checkbox" id="c-41031000" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#41030527">parent</a><span>|</span><a href="#41030546">next</a><span>|</span><label class="collapse" for="c-41031000">[-]</label><label class="expand" for="c-41031000">[1 more]</label></div><br/><div class="children"><div class="content">So you hardcode canonical forms to simplify them down to a common form so that you only need to hardcode one kind of form for the next pass?</div><br/></div></div></div></div><div id="41030546" class="c"><input type="checkbox" id="c-41030546" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41030527">prev</a><span>|</span><label class="collapse" for="c-41030546">[-]</label><label class="expand" for="c-41030546">[9 more]</label></div><br/><div class="children"><div class="content">Imagine if x86 had POPCNT since the beginning, implemented in microcode at first, and optimised it over time to be faster and use more available hardware. There would be no need for this sort of &quot;decompiler&quot; in a compiler nor would software need recompilation for each CPU model.</div><br/><div id="41030911" class="c"><input type="checkbox" id="c-41030911" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41030546">parent</a><span>|</span><a href="#41031169">next</a><span>|</span><label class="collapse" for="c-41030911">[-]</label><label class="expand" for="c-41030911">[2 more]</label></div><br/><div class="children"><div class="content">If they somehow magically knew the future of the whole industry decades in advance, and were able to design the perfect ISA based on that, sure. But that&#x27;s not how things go in practice. If they&#x27;d put in all the opcodes that they thought would be important in the future back in the &#x27;80s and implemented them in microcode, I guarantee that we&#x27;d be a whole lot worse off now, with loads of pointless opcodes for 5GL and semantic networks and all the other dead ends of the era, and no space for things that turned out to be important like POPCNT.</div><br/><div id="41031299" class="c"><input type="checkbox" id="c-41031299" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41030546">root</a><span>|</span><a href="#41030911">parent</a><span>|</span><a href="#41031169">next</a><span>|</span><label class="collapse" for="c-41031299">[-]</label><label class="expand" for="c-41031299">[1 more]</label></div><br/><div class="children"><div class="content">POPCNT was not from the future, it was from the past.<p>The Intel designers only assumed that this belongs to the operations that would not be frequently used in the applications expected for their processors.<p>This was caused in part because they were not personally familiar with such applications. Even if POPCNT actually has a very wide area of applicability, during the seventies of the 20th century the only people who were concerned with the speed of executing POPCNT were some who worked at cryptographic applications and at that time almost all such work was classified.<p>However, with such operations there is always a chicken and egg problem. When they are not implemented in hardware, the programmers and the compiler writers avoid expressing algorithms with them and use various workarounds to implement in a different way the algorithms that would benefit from them.<p>This leads to a low frequency of use of such operations, which is then used to justify that it is not necessary to implement them in hardware.<p>The correct analysis whether such operations would be worthwhile when implemented in hardware requires much more work in writing alternative versions of various algorithms, to be run in simulated hardware, and this is almost never done.</div><br/></div></div></div></div><div id="41031169" class="c"><input type="checkbox" id="c-41031169" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#41030546">parent</a><span>|</span><a href="#41030911">prev</a><span>|</span><a href="#41031241">next</a><span>|</span><label class="collapse" for="c-41031169">[-]</label><label class="expand" for="c-41031169">[1 more]</label></div><br/><div class="children"><div class="content">C predates x86, and was written with the specific intent of being independent of the particular CPU architecture being compiled for.<p>At any point, the C standard could have introduced a standard POPCNT function that compilers could easily compile in whatever platform relevant way they want; but such has never happened.</div><br/></div></div><div id="41031241" class="c"><input type="checkbox" id="c-41031241" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41030546">parent</a><span>|</span><a href="#41031169">prev</a><span>|</span><a href="#41031468">next</a><span>|</span><label class="collapse" for="c-41031241">[-]</label><label class="expand" for="c-41031241">[1 more]</label></div><br/><div class="children"><div class="content">Which is not at all unrealistic, because POPCNT had been recognized as useful and it had already been implemented in some of the earliest computers with vacuum tubes (at the suggestion of Alan Turing). Those early computers, like the Ferranti Mark 1, were much simpler than Intel 8086.<p>The name &quot;population count&quot; had been introduced for this instruction by Cray 1, a couple of years before the launch of Intel 8086.</div><br/></div></div><div id="41031468" class="c"><input type="checkbox" id="c-41031468" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#41030546">parent</a><span>|</span><a href="#41031241">prev</a><span>|</span><a href="#41031182">next</a><span>|</span><label class="collapse" for="c-41031468">[-]</label><label class="expand" for="c-41031468">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t allow for the possibility of hardware and software co-evolving. In particular, that doesn&#x27;t allow hardware to get better by providing ways to run common software operations faster.</div><br/></div></div><div id="41031182" class="c"><input type="checkbox" id="c-41031182" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41030546">parent</a><span>|</span><a href="#41031468">prev</a><span>|</span><a href="#41030864">next</a><span>|</span><label class="collapse" for="c-41031182">[-]</label><label class="expand" for="c-41031182">[2 more]</label></div><br/><div class="children"><div class="content">POPCNT really doesn&#x27;t have a place on a 16bit processor.  Particularly one which can split the 16bit register into two 8bit pairs.</div><br/><div id="41031270" class="c"><input type="checkbox" id="c-41031270" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41030546">root</a><span>|</span><a href="#41031182">parent</a><span>|</span><a href="#41030864">next</a><span>|</span><label class="collapse" for="c-41031270">[-]</label><label class="expand" for="c-41031270">[1 more]</label></div><br/><div class="children"><div class="content">POPCNT might have not been very useful in the initial 8086 ISA of 1978, but it would have been at home in the NPX extension of the Intel ISA from 1980 (Numeric Procesor Extension, i.e. the instruction set of Intel 8087), which had operations with 64-bit integers and 64-bit significands of 80-bit floating-point numbers.</div><br/></div></div></div></div><div id="41030864" class="c"><input type="checkbox" id="c-41030864" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41030546">parent</a><span>|</span><a href="#41031182">prev</a><span>|</span><label class="collapse" for="c-41030864">[-]</label><label class="expand" for="c-41030864">[1 more]</label></div><br/><div class="children"><div class="content">Meh?<p>There will always be new CPU instructions that weren’t already part of whatever language you’re using, that corresponded to a pattern of code that people are already writing in that language. And the pattern matching isn’t rocket science. I wouldn’t characterize it as “decompilation”; that makes it seem more magical than it really is.<p>Popcnt may be a particularly amusing example but it’s far from the only one. A modern C compiler has countless patterns it recognizes, sometimes to match them to instructions, other times just to aid the compiler’s understanding of what’s going on. Usually the latter.</div><br/></div></div></div></div></div></div></div></div></div></body></html>