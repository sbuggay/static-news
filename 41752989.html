<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728205269160" as="style"/><link rel="stylesheet" href="styles.css?v=1728205269160"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://buildroot.org/">Buildroot</a> <span class="domain">(<a href="https://buildroot.org">buildroot.org</a>)</span></div><div class="subtext"><span>jakogut</span> | <span>16 comments</span></div><br/><div><div id="41753604" class="c"><input type="checkbox" id="c-41753604" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><label class="collapse" for="c-41753604">[-]</label><label class="expand" for="c-41753604">[15 more]</label></div><br/><div class="children"><div class="content">How are kernel or application updates applied to buildroot-installed systems?</div><br/><div id="41753645" class="c"><input type="checkbox" id="c-41753645" checked=""/><div class="controls bullet"><span class="by">jakogut</span><span>|</span><a href="#41753604">parent</a><span>|</span><a href="#41753610">next</a><span>|</span><label class="collapse" for="c-41753645">[-]</label><label class="expand" for="c-41753645">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve previously developed a commercial product that used buildroot.<p>In that case, it used an A&#x2F;B partition layout like Android, along with a custom update script and kernel-based bootloader to implement atomic updates and fallback capability. The rootfs image was built by buildroot and devices would query an API and download the image, then write it to the inactive root partition.<p>You can do effectively the same thing with GRUB, but the project I worked on also supported devices that booted using u-boot. The kexec bootloader allowed a single implementation for different architectures and platforms.<p>So, the answer is you can update however you want, but there are a few common ways it&#x27;s done in embedded.</div><br/><div id="41755177" class="c"><input type="checkbox" id="c-41755177" checked=""/><div class="controls bullet"><span class="by">jameshilliard</span><span>|</span><a href="#41753604">root</a><span>|</span><a href="#41753645">parent</a><span>|</span><a href="#41754363">next</a><span>|</span><label class="collapse" for="c-41755177">[-]</label><label class="expand" for="c-41755177">[1 more]</label></div><br/><div class="children"><div class="content">Rather than using a custom update script something like swupdate is probably a better option which is well supported in buildroot and can do A&#x2F;B dual-copy in addition to other layouts.<p><a href="https:&#x2F;&#x2F;sbabic.github.io&#x2F;swupdate&#x2F;scenarios.html" rel="nofollow">https:&#x2F;&#x2F;sbabic.github.io&#x2F;swupdate&#x2F;scenarios.html</a></div><br/></div></div><div id="41754363" class="c"><input type="checkbox" id="c-41754363" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#41753604">root</a><span>|</span><a href="#41753645">parent</a><span>|</span><a href="#41755177">prev</a><span>|</span><a href="#41753610">next</a><span>|</span><label class="collapse" for="c-41754363">[-]</label><label class="expand" for="c-41754363">[5 more]</label></div><br/><div class="children"><div class="content">Is there a common way with Buildroot and A&#x2F;B partitioning to make it so that if the reboot into the updated partition fails to boot, it will reboot into the old partition?<p>For example, if the new partition is corrupt, or if there is a software bug that causes one of the following to happen:<p>- the partition is unbootable, or<p>- the device is able to begin the boot, even starting to run the new kernel, but somewhere along the way it locks up. Whether that be a kernel panic early on, or later on when systemd has started but one or more important services fail to start, or<p>- The device finishes the initial boot successfully, including all of the services managed by systemd, but after say a few minutes, some services are exhibiting unstable behavior (like services crashing and starting and crashing and starting), or the kernel panics after everything had been up and running for a while</div><br/><div id="41754469" class="c"><input type="checkbox" id="c-41754469" checked=""/><div class="controls bullet"><span class="by">msarnoff</span><span>|</span><a href="#41753604">root</a><span>|</span><a href="#41754363">parent</a><span>|</span><a href="#41754468">next</a><span>|</span><label class="collapse" for="c-41754469">[-]</label><label class="expand" for="c-41754469">[1 more]</label></div><br/><div class="children"><div class="content">Use the hardware watchdog timer. When the machine resets, the bootloader can check a hardware register to determine the reset cause, and then boot into a different OS partition.<p>(note: not every SoC has a register indicating reset cause, I’ve worked with Allwinner chips that don’t, so alternate methods may be required)<p>Enable the watchdog timer at the start of the bootloader. (I work with arm systems so this would be in uboot). If no bootable OS is found, or the system crashes before the kernel fully boots, the watchdog times out.<p>In Linux, enable the watchdog timer at boot in your kconfig. Then have a userspace service that periodically pings &#x2F;dev&#x2F;watchdog to keep the system alive. Have your panic handler just hang, and the watchdog will reset the machine.<p>Another helpful trick to save panic logs is to use pstore&#x2F;ramoops to keep a portion of the kernel logs across resets, and then save the pstore buffer out to disk after booting into the recovery system.</div><br/></div></div><div id="41754468" class="c"><input type="checkbox" id="c-41754468" checked=""/><div class="controls bullet"><span class="by">opello</span><span>|</span><a href="#41753604">root</a><span>|</span><a href="#41754363">parent</a><span>|</span><a href="#41754469">prev</a><span>|</span><a href="#41754380">next</a><span>|</span><label class="collapse" for="c-41754468">[-]</label><label class="expand" for="c-41754468">[2 more]</label></div><br/><div class="children"><div class="content">For systems using U-Boot you can use the bootcount[1] feature to detect the failure and react by booting into the old environment.<p>Edit: This doesn&#x27;t cover your running instability case, but that seems more like a feature that should be implemented using a user space watchdog.<p>[1] <a href="https:&#x2F;&#x2F;docs.u-boot.org&#x2F;en&#x2F;latest&#x2F;api&#x2F;bootcount.html" rel="nofollow">https:&#x2F;&#x2F;docs.u-boot.org&#x2F;en&#x2F;latest&#x2F;api&#x2F;bootcount.html</a></div><br/><div id="41755429" class="c"><input type="checkbox" id="c-41755429" checked=""/><div class="controls bullet"><span class="by">tkfu</span><span>|</span><a href="#41753604">root</a><span>|</span><a href="#41754468">parent</a><span>|</span><a href="#41754380">next</a><span>|</span><label class="collapse" for="c-41755429">[-]</label><label class="expand" for="c-41755429">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a very useful framework called greenboot[0] for the latter case.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;fedora-iot&#x2F;greenboot">https:&#x2F;&#x2F;github.com&#x2F;fedora-iot&#x2F;greenboot</a></div><br/></div></div></div></div><div id="41754380" class="c"><input type="checkbox" id="c-41754380" checked=""/><div class="controls bullet"><span class="by">planewave</span><span>|</span><a href="#41753604">root</a><span>|</span><a href="#41754363">parent</a><span>|</span><a href="#41754468">prev</a><span>|</span><a href="#41753610">next</a><span>|</span><label class="collapse" for="c-41754380">[-]</label><label class="expand" for="c-41754380">[1 more]</label></div><br/><div class="children"><div class="content">Many embedded systems use SWupdate to manage this, which can hook into uboot.</div><br/></div></div></div></div></div></div><div id="41753610" class="c"><input type="checkbox" id="c-41753610" checked=""/><div class="controls bullet"><span class="by">leonheld</span><span>|</span><a href="#41753604">parent</a><span>|</span><a href="#41753645">prev</a><span>|</span><a href="#41753614">next</a><span>|</span><label class="collapse" for="c-41753610">[-]</label><label class="expand" for="c-41753610">[1 more]</label></div><br/><div class="children"><div class="content">Well, buildroot is mainly for embedded applications, so whatever applies to that: OTA updates with A&#x2F;B partitioning are common. OStree-based are getting a lot of traction as well.<p>But technically you could build something with a package manager etc and update as usual. It&#x27;s just a build system.</div><br/></div></div><div id="41753614" class="c"><input type="checkbox" id="c-41753614" checked=""/><div class="controls bullet"><span class="by">montecarl</span><span>|</span><a href="#41753604">parent</a><span>|</span><a href="#41753610">prev</a><span>|</span><a href="#41753657">next</a><span>|</span><label class="collapse" for="c-41753614">[-]</label><label class="expand" for="c-41753614">[3 more]</label></div><br/><div class="children"><div class="content">I would love to know. I currently have an embedded product using buildroot and as it is not exposed to a network at all, I don&#x27;t have any worries about security. However, I&#x27;d love to hear of a nice mechanism to basically upgrade the system image in place. I imagine you could use something like a pair of partitions and just change the kernel boot parameters to point at the most recent one, but I&#x27;m curious about what solutions people use.</div><br/><div id="41755107" class="c"><input type="checkbox" id="c-41755107" checked=""/><div class="controls bullet"><span class="by">lawik</span><span>|</span><a href="#41753604">root</a><span>|</span><a href="#41753614">parent</a><span>|</span><a href="#41755156">next</a><span>|</span><label class="collapse" for="c-41755107">[-]</label><label class="expand" for="c-41755107">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the general wisdom I&#x27;ve seen.<p>I work on the Nerves project which does Elixir on top of Buildroot and there we use fwup (<a href="https:&#x2F;&#x2F;github.com&#x2F;fwup-home&#x2F;fwup">https:&#x2F;&#x2F;github.com&#x2F;fwup-home&#x2F;fwup</a>) which does a very nice job of a lot of this. Including signing, hashing and more.<p>This is a real example of a config:
<a href="https:&#x2F;&#x2F;github.com&#x2F;nerves-project&#x2F;nerves_system_rpi4&#x2F;blob&#x2F;main&#x2F;fwup.conf">https:&#x2F;&#x2F;github.com&#x2F;nerves-project&#x2F;nerves_system_rpi4&#x2F;blob&#x2F;ma...</a></div><br/></div></div><div id="41755156" class="c"><input type="checkbox" id="c-41755156" checked=""/><div class="controls bullet"><span class="by">jameshilliard</span><span>|</span><a href="#41753604">root</a><span>|</span><a href="#41753614">parent</a><span>|</span><a href="#41755107">prev</a><span>|</span><a href="#41753657">next</a><span>|</span><label class="collapse" for="c-41755156">[-]</label><label class="expand" for="c-41755156">[1 more]</label></div><br/><div class="children"><div class="content">I use swupdate myself with buildroot.<p><a href="https:&#x2F;&#x2F;sbabic.github.io&#x2F;swupdate&#x2F;swupdate.html" rel="nofollow">https:&#x2F;&#x2F;sbabic.github.io&#x2F;swupdate&#x2F;swupdate.html</a></div><br/></div></div></div></div><div id="41753657" class="c"><input type="checkbox" id="c-41753657" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#41753604">parent</a><span>|</span><a href="#41753614">prev</a><span>|</span><a href="#41754083">next</a><span>|</span><label class="collapse" for="c-41753657">[-]</label><label class="expand" for="c-41753657">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s sort of out of the scope of Buildroot, but there are different systems like mender or swupdate that cover updates. They tend to need some level of platform specific changes because embedded systems these days have 7 levels of bootloaders.</div><br/><div id="41754491" class="c"><input type="checkbox" id="c-41754491" checked=""/><div class="controls bullet"><span class="by">msarnoff</span><span>|</span><a href="#41753604">root</a><span>|</span><a href="#41753657">parent</a><span>|</span><a href="#41754083">next</a><span>|</span><label class="collapse" for="c-41754491">[-]</label><label class="expand" for="c-41754491">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been using fwup (<a href="https:&#x2F;&#x2F;github.com&#x2F;fwup-home&#x2F;fwup">https:&#x2F;&#x2F;github.com&#x2F;fwup-home&#x2F;fwup</a>) in embedded Linux consumer products for almost 10 years and it has Just Worked.<p>Supports A&#x2F;B updates, uboot integration, and signed update files.<p>Not sure about buildroot, but in Yocto it’s fairly straightforward to write an image creation recipe that bundles your ext4 filesystem image(s) into an update file you can deploy.</div><br/></div></div></div></div><div id="41754083" class="c"><input type="checkbox" id="c-41754083" checked=""/><div class="controls bullet"><span class="by">thebeardisred</span><span>|</span><a href="#41753604">parent</a><span>|</span><a href="#41753657">prev</a><span>|</span><label class="collapse" for="c-41754083">[-]</label><label class="expand" for="c-41754083">[1 more]</label></div><br/><div class="children"><div class="content">You build a new filesystem image and apply the new filesystem to the system.</div><br/></div></div></div></div></div></div></div></div></div></body></html>