<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709197271225" as="style"/><link rel="stylesheet" href="styles.css?v=1709197271225"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pql.dev/">Pql, a pipelined query language that compiles to SQL</a> <span class="domain">(<a href="https://pql.dev">pql.dev</a>)</span></div><div class="subtext"><span>ejcx</span> | <span>102 comments</span></div><br/><div><div id="39543410" class="c"><input type="checkbox" id="c-39543410" checked=""/><div class="controls bullet"><span class="by">memset</span><span>|</span><a href="#39543448">next</a><span>|</span><label class="collapse" for="c-39543410">[-]</label><label class="expand" for="c-39543410">[2 more]</label></div><br/><div class="children"><div class="content">This is really great! Maybe I&#x27;ll incorporate this into my own software (scratchdata&#x2F;scratchdb)<p>Question: it looks like you wrote the parser by hand. How did you decide that that was the right approach? I myself am new to parsers and am working on implementing the PostgREST syntax in go using PEG to translate to Clickhouse, which is to say, a similar mission as this project. Would love to learn how you approached this problem!</div><br/><div id="39546064" class="c"><input type="checkbox" id="c-39546064" checked=""/><div class="controls bullet"><span class="by">seer</span><span>|</span><a href="#39543410">parent</a><span>|</span><a href="#39543448">next</a><span>|</span><label class="collapse" for="c-39546064">[-]</label><label class="expand" for="c-39546064">[1 more]</label></div><br/><div class="children"><div class="content">I also wrote a parser (in typescript) for postgres (<a href="https:&#x2F;&#x2F;github.com&#x2F;ivank&#x2F;potygen">https:&#x2F;&#x2F;github.com&#x2F;ivank&#x2F;potygen</a>), and it turned out quite the educational experience - Learned _a lot_ about the intricacies of SQL, and how to build parsers in general.<p>Turned out in webdev there are a lot of instances where you actually want a parser - legacy places where they used to save things in plain text for example, and I started seeing the pattern everywhere.<p>Where I would have reached for some monstrosity of a regex to solve this, now I just whip out a recursive decent parser and call it a day, takes surprisingly small amount of code! (<a href="https:&#x2F;&#x2F;github.com&#x2F;dmaevsky&#x2F;rd-parse">https:&#x2F;&#x2F;github.com&#x2F;dmaevsky&#x2F;rd-parse</a>)</div><br/></div></div></div></div><div id="39543448" class="c"><input type="checkbox" id="c-39543448" checked=""/><div class="controls bullet"><span class="by">brikym</span><span>|</span><a href="#39543410">prev</a><span>|</span><a href="#39547339">next</a><span>|</span><label class="collapse" for="c-39543448">[-]</label><label class="expand" for="c-39543448">[3 more]</label></div><br/><div class="children"><div class="content">It looks a lot like Kusto query language. Here is a kusto query:<p><pre><code>    StormEvents
    | where StartTime between (datetime(2007-01-01) .. datetime(2007-12-31)) 
    and DamageCrops &gt; 0
    | summarize EventCount = count() by bin(StartTime, 7d)
</code></pre>
edit... yes it indeed was inspired by Kusto as they mention on the github Readme <a href="https:&#x2F;&#x2F;github.com&#x2F;runreveal&#x2F;pql">https:&#x2F;&#x2F;github.com&#x2F;runreveal&#x2F;pql</a></div><br/><div id="39543615" class="c"><input type="checkbox" id="c-39543615" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39543448">parent</a><span>|</span><a href="#39547339">next</a><span>|</span><label class="collapse" for="c-39543615">[-]</label><label class="expand" for="c-39543615">[2 more]</label></div><br/><div class="children"><div class="content">Is that what AWS CloudWatch Insights uses?</div><br/><div id="39544345" class="c"><input type="checkbox" id="c-39544345" checked=""/><div class="controls bullet"><span class="by">theragra</span><span>|</span><a href="#39543448">root</a><span>|</span><a href="#39543615">parent</a><span>|</span><a href="#39547339">next</a><span>|</span><label class="collapse" for="c-39544345">[-]</label><label class="expand" for="c-39544345">[1 more]</label></div><br/><div class="children"><div class="content">Azure appinsights logs</div><br/></div></div></div></div></div></div><div id="39547339" class="c"><input type="checkbox" id="c-39547339" checked=""/><div class="controls bullet"><span class="by">ulucs</span><span>|</span><a href="#39543448">prev</a><span>|</span><a href="#39541989">next</a><span>|</span><label class="collapse" for="c-39547339">[-]</label><label class="expand" for="c-39547339">[1 more]</label></div><br/><div class="children"><div class="content">Is the &quot;piping&quot; associative? As in, does it allow me to put `where eventTime &gt; minus(now(), toIntervalMinute(15)) | count` into a variable so I can use it later on multiple different tables&#x2F;queries? I remember failing to do the same thing with ggplot2 when I wanted to share styling between components. If the operator is not associative, then the reading order will have to be mixed since composing will require functions (and Go doesn&#x27;t have pipes&#x2F;UFCS)</div><br/></div></div><div id="39541989" class="c"><input type="checkbox" id="c-39541989" checked=""/><div class="controls bullet"><span class="by">darcien</span><span>|</span><a href="#39547339">prev</a><span>|</span><a href="#39547467">next</a><span>|</span><label class="collapse" for="c-39541989">[-]</label><label class="expand" for="c-39541989">[1 more]</label></div><br/><div class="children"><div class="content">This is actually pretty awesome! I use KQL every few days for reading some logs from Azure App Insight. The syntax is pretty nice and you can make pretty complex stuff out of it. But that&#x27;s it, I can&#x27;t use KQL anywhere else outside Azure. With this, I can show off my KQL-fu to my teammates and surprise them with how fast you can write KQL-like syntax compared to SQL.</div><br/></div></div><div id="39547467" class="c"><input type="checkbox" id="c-39547467" checked=""/><div class="controls bullet"><span class="by">wingi</span><span>|</span><a href="#39541989">prev</a><span>|</span><a href="#39541507">next</a><span>|</span><label class="collapse" for="c-39547467">[-]</label><label class="expand" for="c-39547467">[1 more]</label></div><br/><div class="children"><div class="content">The first example is worse. Why learning a piping syntax instead learning SQL?</div><br/></div></div><div id="39541507" class="c"><input type="checkbox" id="c-39541507" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#39547467">prev</a><span>|</span><a href="#39547189">next</a><span>|</span><label class="collapse" for="c-39541507">[-]</label><label class="expand" for="c-39541507">[14 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the reason to go for this over PRQL?</div><br/><div id="39543269" class="c"><input type="checkbox" id="c-39543269" checked=""/><div class="controls bullet"><span class="by">caust1c</span><span>|</span><a href="#39541507">parent</a><span>|</span><a href="#39543270">next</a><span>|</span><label class="collapse" for="c-39543269">[-]</label><label class="expand" for="c-39543269">[1 more]</label></div><br/><div class="children"><div class="content">The simple answer is that it&#x27;s too distinct from where we&#x27;re trying to meet our users.<p>We&#x27;re not anti-PRQL, but our users (folks in security) coming from Kusto, Splunk, SumoLogic, LogScale, and others have expressed that they have a preference for this syntax over PRQL syntax.<p>I wouldn&#x27;t be surprised if we end up supporting both and letting folks choose the one they&#x27;re most happy with using.</div><br/></div></div><div id="39543270" class="c"><input type="checkbox" id="c-39543270" checked=""/><div class="controls bullet"><span class="by">memset</span><span>|</span><a href="#39541507">parent</a><span>|</span><a href="#39543269">prev</a><span>|</span><a href="#39541608">next</a><span>|</span><label class="collapse" for="c-39543270">[-]</label><label class="expand" for="c-39543270">[3 more]</label></div><br/><div class="children"><div class="content">The big advantage of this project in my opinion is that it will pass functions it doesn’t recognize to the underlying DB.<p>With prql, if they don’t support your favorite operator then you’re out of luck.</div><br/><div id="39543752" class="c"><input type="checkbox" id="c-39543752" checked=""/><div class="controls bullet"><span class="by">beeskip</span><span>|</span><a href="#39541507">root</a><span>|</span><a href="#39543270">parent</a><span>|</span><a href="#39541608">next</a><span>|</span><label class="collapse" for="c-39543752">[-]</label><label class="expand" for="c-39543752">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;book&#x2F;reference&#x2F;syntax&#x2F;s-strings.html" rel="nofollow">https:&#x2F;&#x2F;prql-lang.org&#x2F;book&#x2F;reference&#x2F;syntax&#x2F;s-strings.html</a></div><br/><div id="39543883" class="c"><input type="checkbox" id="c-39543883" checked=""/><div class="controls bullet"><span class="by">memset</span><span>|</span><a href="#39541507">root</a><span>|</span><a href="#39543752">parent</a><span>|</span><a href="#39541608">next</a><span>|</span><label class="collapse" for="c-39543883">[-]</label><label class="expand" for="c-39543883">[1 more]</label></div><br/><div class="children"><div class="content">Did not know about that!</div><br/></div></div></div></div></div></div><div id="39541608" class="c"><input type="checkbox" id="c-39541608" checked=""/><div class="controls bullet"><span class="by">zhiboz</span><span>|</span><a href="#39541507">parent</a><span>|</span><a href="#39543270">prev</a><span>|</span><a href="#39542618">next</a><span>|</span><label class="collapse" for="c-39541608">[-]</label><label class="expand" for="c-39541608">[1 more]</label></div><br/><div class="children"><div class="content">I had the exact same question when I saw the post.</div><br/></div></div><div id="39542618" class="c"><input type="checkbox" id="c-39542618" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39541507">parent</a><span>|</span><a href="#39541608">prev</a><span>|</span><a href="#39547189">next</a><span>|</span><label class="collapse" for="c-39542618">[-]</label><label class="expand" for="c-39542618">[8 more]</label></div><br/><div class="children"><div class="content">Looks like PRQL doesn&#x27;t have a Go library so I guess they just really wanted something in Go?<p>I would guess they didn&#x27;t wrap the main PRQL library (which is written in Rust) because Go code is a lot easier to deal with when it&#x27;s pure Go. And they probably didn&#x27;t just write a Go version of PRQL because that would be a mountain of work.<p>Still I think that&#x27;s a mistake. PRQL is a far more mature project and has things like IDE support and an online playground which they are never going to do...<p>Better just to bite the bullet and wrap the Rust library.</div><br/><div id="39542682" class="c"><input type="checkbox" id="c-39542682" checked=""/><div class="controls bullet"><span class="by">tstack</span><span>|</span><a href="#39541507">root</a><span>|</span><a href="#39542618">parent</a><span>|</span><a href="#39543930">next</a><span>|</span><label class="collapse" for="c-39542682">[-]</label><label class="expand" for="c-39542682">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Looks like PRQL doesn&#x27;t have a Go library so I guess they just really wanted something in Go?<p>There&#x27;s some C bindings and the example in the README shows integration with Go:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;tree&#x2F;main&#x2F;prqlc&#x2F;bindings&#x2F;prqlc-c">https:&#x2F;&#x2F;github.com&#x2F;PRQL&#x2F;prql&#x2F;tree&#x2F;main&#x2F;prqlc&#x2F;bindings&#x2F;prqlc-...</a></div><br/><div id="39543173" class="c"><input type="checkbox" id="c-39543173" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39541507">root</a><span>|</span><a href="#39542682">parent</a><span>|</span><a href="#39543930">next</a><span>|</span><label class="collapse" for="c-39543173">[-]</label><label class="expand" for="c-39543173">[1 more]</label></div><br/><div class="children"><div class="content">Ah yeah I wonder why they don&#x27;t mention that in their docs.</div><br/></div></div></div></div><div id="39543930" class="c"><input type="checkbox" id="c-39543930" checked=""/><div class="controls bullet"><span class="by">pkolaczk</span><span>|</span><a href="#39541507">root</a><span>|</span><a href="#39542618">parent</a><span>|</span><a href="#39542682">prev</a><span>|</span><a href="#39547189">next</a><span>|</span><label class="collapse" for="c-39543930">[-]</label><label class="expand" for="c-39543930">[5 more]</label></div><br/><div class="children"><div class="content">It’s not the problem with binding to Rust. Python can do it, Zig can do it, C can do it, even JS can do. It is Go which doesn’t integrate well with anything that isn’t Go.</div><br/><div id="39544555" class="c"><input type="checkbox" id="c-39544555" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#39541507">root</a><span>|</span><a href="#39543930">parent</a><span>|</span><a href="#39547189">next</a><span>|</span><label class="collapse" for="c-39544555">[-]</label><label class="expand" for="c-39544555">[4 more]</label></div><br/><div class="children"><div class="content">Where did you dream up that idea? PRQL integrates with Go just fine. The project even provides an example in Go.</div><br/><div id="39547098" class="c"><input type="checkbox" id="c-39547098" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39541507">root</a><span>|</span><a href="#39544555">parent</a><span>|</span><a href="#39547189">next</a><span>|</span><label class="collapse" for="c-39547098">[-]</label><label class="expand" for="c-39547098">[3 more]</label></div><br/><div class="children"><div class="content">He said it doesn&#x27;t integrate <i>well</i>, and he&#x27;s right. Go works best when you only have Go. (Ok that&#x27;s true of most languages but it&#x27;s especially true of Go.)<p>This article has some details: <a href="https:&#x2F;&#x2F;dave.cheney.net&#x2F;2016&#x2F;01&#x2F;18&#x2F;cgo-is-not-go" rel="nofollow">https:&#x2F;&#x2F;dave.cheney.net&#x2F;2016&#x2F;01&#x2F;18&#x2F;cgo-is-not-go</a><p>Note that this isn&#x27;t true of languages like Python (CPython) or Rust which are much more closely tied to C than Go is. Go is a &quot;from scratch as if C never existed&quot; language which is great because it doesn&#x27;t have any C baggage but it does make integrating with C more awkward.</div><br/><div id="39547436" class="c"><input type="checkbox" id="c-39547436" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#39541507">root</a><span>|</span><a href="#39547098">parent</a><span>|</span><a href="#39547189">next</a><span>|</span><label class="collapse" for="c-39547436">[-]</label><label class="expand" for="c-39547436">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; This article has some details</i><p>Couldn&#x27;t find your own words? Your link isn&#x27;t very convincing. Okay, sure, you have to bend to C to some degree, but that&#x27;s true of every language that wants to integrate with C. Go integrates no less well than any other language on that front.<p>And it&#x27;s not even really all that accurate. Consider &quot;Performance will always be an issue&quot; – gccgo and tinygo have shown that you don&#x27;t have to have any call overhead. They can call C functions as fast as C can. That is in no way a limitation of Go.<p>That is only a limitation of gc, and even then the overhead is only a few nanoseconds these days. You&#x27;re never going to notice. These may have been concerns in 2016, sure – overhead was a lot higher back then – but time marches forward. Things change. Why you are linking to something that is fast approaching being a decade old by this point boggles the mind.<p>This is why you should be using your own brain. Outsourcing thoughts to other people is nonsensical.<p><i>&gt; or Rust</i><p>PRQL is written in Rust, so it would be quite strange if it wasn&#x27;t true of Rust. Interestingly, the Javascript bindings use a WASM target. Go could also use the WASM target.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39547189" class="c"><input type="checkbox" id="c-39547189" checked=""/><div class="controls bullet"><span class="by">swman</span><span>|</span><a href="#39541507">prev</a><span>|</span><a href="#39544508">next</a><span>|</span><label class="collapse" for="c-39547189">[-]</label><label class="expand" for="c-39547189">[2 more]</label></div><br/><div class="children"><div class="content">Maybe I’m totally missing it but why would I use it over sql? All those companies have their own flavor DSL so are you saying this is to standardize using it? Thanks</div><br/><div id="39547265" class="c"><input type="checkbox" id="c-39547265" checked=""/><div class="controls bullet"><span class="by">eitland</span><span>|</span><a href="#39547189">parent</a><span>|</span><a href="#39544508">next</a><span>|</span><label class="collapse" for="c-39547265">[-]</label><label class="expand" for="c-39547265">[1 more]</label></div><br/><div class="children"><div class="content">My primary reason for caring ATM is because a better query language for SQL, one that specifies what tables to operate on before what to do, could simplify tooling quite a bit.</div><br/></div></div></div></div><div id="39544508" class="c"><input type="checkbox" id="c-39544508" checked=""/><div class="controls bullet"><span class="by">mavam</span><span>|</span><a href="#39547189">prev</a><span>|</span><a href="#39543049">next</a><span>|</span><label class="collapse" for="c-39544508">[-]</label><label class="expand" for="c-39544508">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re developing TQL (Tenzir Query Language, &quot;tea-quel&quot;) that is very similar to PQL: <a href="https:&#x2F;&#x2F;docs.tenzir.com&#x2F;pipelines" rel="nofollow">https:&#x2F;&#x2F;docs.tenzir.com&#x2F;pipelines</a><p>Also a pipeline language, PRQL-inspired, but differing in that (i) TQL supports multiple data types between operators, both unstructured blocks of bytes and structured data frames as Arrow record batches, (ii) TQL is multi-schema, i.e., a single pipeline can have different &quot;tables&quot;, as if you&#x27;re processing semi-structured JSON, and (iii) TQL has support for batch and stream processing, with a light-weight indexed storage layer on top of Parquet&#x2F;Feather files for historical workloads and a streaming executor.
We&#x27;re in the middle of getting TQL v2 [@] out of the door with support for expressions and more advanced control flow, e.g., match-case statements. There&#x27;s a blog post [#] about the core design of the engine as well.<p>While it&#x27;s a general-purpose ETL tool, we&#x27;re targeting primary operational security use case where people today use Splunk, Sentinel&#x2F;ADX, Elastic, etc. So some operators are very security&#x27;ish, like Sigma, YARA, or Velociraptor.<p>Comparison:<p><pre><code>    users
    | where eventTime &gt; minus(now(), toIntervalDay(1))
    | project user_id, user_email
</code></pre>
vs TQL:<p><pre><code>    export
    where eventTime &gt; now() - 1d
    select user_id, user_email
</code></pre>
[@] <a href="https:&#x2F;&#x2F;github.com&#x2F;tenzir&#x2F;tenzir&#x2F;blob&#x2F;64ef997d736e9416e859bfcd5f6fa74970565204&#x2F;rfc&#x2F;004-query-language&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;tenzir&#x2F;tenzir&#x2F;blob&#x2F;64ef997d736e9416e859bf...</a><p>[#] <a href="https:&#x2F;&#x2F;docs.tenzir.com&#x2F;blog&#x2F;five-design-principles-for-building-a-data-pipeline-engine" rel="nofollow">https:&#x2F;&#x2F;docs.tenzir.com&#x2F;blog&#x2F;five-design-principles-for-buil...</a></div><br/></div></div><div id="39543049" class="c"><input type="checkbox" id="c-39543049" checked=""/><div class="controls bullet"><span class="by">helloericsf</span><span>|</span><a href="#39544508">prev</a><span>|</span><a href="#39542395">next</a><span>|</span><label class="collapse" for="c-39543049">[-]</label><label class="expand" for="c-39543049">[3 more]</label></div><br/><div class="children"><div class="content">Wow, so many query languages, right? Do we really need another one? 
What&#x27;s the story behind that decision? Cheers.</div><br/><div id="39543190" class="c"><input type="checkbox" id="c-39543190" checked=""/><div class="controls bullet"><span class="by">brettv2</span><span>|</span><a href="#39543049">parent</a><span>|</span><a href="#39542395">next</a><span>|</span><label class="collapse" for="c-39543190">[-]</label><label class="expand" for="c-39543190">[2 more]</label></div><br/><div class="children"><div class="content">This is answered on their blog:<p><a href="https:&#x2F;&#x2F;blog.runreveal.com&#x2F;introducing-pql&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.runreveal.com&#x2F;introducing-pql&#x2F;</a></div><br/><div id="39543507" class="c"><input type="checkbox" id="c-39543507" checked=""/><div class="controls bullet"><span class="by">helloericsf</span><span>|</span><a href="#39543049">root</a><span>|</span><a href="#39543190">parent</a><span>|</span><a href="#39542395">next</a><span>|</span><label class="collapse" for="c-39543507">[-]</label><label class="expand" for="c-39543507">[1 more]</label></div><br/><div class="children"><div class="content">Cheers, mate! The blog cleared up a chunk of my question and the chat here gave me a better grasp of why it&#x27;s over PRQL.</div><br/></div></div></div></div></div></div><div id="39542395" class="c"><input type="checkbox" id="c-39542395" checked=""/><div class="controls bullet"><span class="by">smurda</span><span>|</span><a href="#39543049">prev</a><span>|</span><a href="#39546966">next</a><span>|</span><label class="collapse" for="c-39542395">[-]</label><label class="expand" for="c-39542395">[1 more]</label></div><br/><div class="children"><div class="content">This is cool. Splunk Search Processing Language (SPL) is a real vendor lock-in feature. Once the team has invested time to get ramped up on SPL, and it gets integrated in your workflows, ripping out Splunk has an even higher switching cost.</div><br/></div></div><div id="39546966" class="c"><input type="checkbox" id="c-39546966" checked=""/><div class="controls bullet"><span class="by">hans_castorp</span><span>|</span><a href="#39542395">prev</a><span>|</span><a href="#39541638">next</a><span>|</span><label class="collapse" for="c-39546966">[-]</label><label class="expand" for="c-39546966">[1 more]</label></div><br/><div class="children"><div class="content">What target database is that in the examples?<p><pre><code>     like (&quot;email&quot;, &#x27;gmail&#x27;)
     minus (now (), toIntervalDay (1))
</code></pre>
are non-standard functions&#x2F;conditions</div><br/></div></div><div id="39541638" class="c"><input type="checkbox" id="c-39541638" checked=""/><div class="controls bullet"><span class="by">anotherhue</span><span>|</span><a href="#39546966">prev</a><span>|</span><a href="#39545832">next</a><span>|</span><label class="collapse" for="c-39541638">[-]</label><label class="expand" for="c-39541638">[2 more]</label></div><br/><div class="children"><div class="content">Similarities to PRQL: <a href="https:&#x2F;&#x2F;prql-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;prql-lang.org&#x2F;</a></div><br/><div id="39544657" class="c"><input type="checkbox" id="c-39544657" checked=""/><div class="controls bullet"><span class="by">hashmash</span><span>|</span><a href="#39541638">parent</a><span>|</span><a href="#39545832">next</a><span>|</span><label class="collapse" for="c-39544657">[-]</label><label class="expand" for="c-39544657">[1 more]</label></div><br/><div class="children"><div class="content">PRQL is actually a first class functional programming language, with syntax for supporting readable query processing pipelines. The documentation for PQL is a bit light, so I don&#x27;t know if it&#x27;s as powerful as PRQL.</div><br/></div></div></div></div><div id="39545832" class="c"><input type="checkbox" id="c-39545832" checked=""/><div class="controls bullet"><span class="by">sinuhe69</span><span>|</span><a href="#39541638">prev</a><span>|</span><a href="#39541500">next</a><span>|</span><label class="collapse" for="c-39545832">[-]</label><label class="expand" for="c-39545832">[1 more]</label></div><br/><div class="children"><div class="content">Their first example doesn&#x27;t look idiomatic at all:<p>SELECT
      *
    FROM
      &quot;users&quot;
    WHERE
      like (&quot;email&quot;, &#x27;gmail&#x27;)<p>Should “like” here be a user-defined function? Because that’s not the syntax for SQL-like. To which SQL version will Pql translate its queries?</div><br/></div></div><div id="39541500" class="c"><input type="checkbox" id="c-39541500" checked=""/><div class="controls bullet"><span class="by">RedShift1</span><span>|</span><a href="#39545832">prev</a><span>|</span><a href="#39543076">next</a><span>|</span><label class="collapse" for="c-39541500">[-]</label><label class="expand" for="c-39541500">[2 more]</label></div><br/><div class="children"><div class="content">InfluxDB tried to do this with InfluxQL but abandoned it, and are now back to SQL. The biggest problem I had with it when I tried it, was that is was simply too slow, queries were on average 6x slower than their SQL equivalents. I think a language like this is just too hard to optimize well.</div><br/><div id="39544545" class="c"><input type="checkbox" id="c-39544545" checked=""/><div class="controls bullet"><span class="by">loic-sharma</span><span>|</span><a href="#39541500">parent</a><span>|</span><a href="#39543076">next</a><span>|</span><label class="collapse" for="c-39544545">[-]</label><label class="expand" for="c-39544545">[1 more]</label></div><br/><div class="children"><div class="content">This is incorrect. It was their query engine that was hard to optimize, not the language. InfluxDB has been working on a new query engine based off Apache DataFusion to fix this.<p>If you squint, this query language is very similar to Polars, which is state-of-the-art for performance. I expect Pql could be as performant with sufficient investment.<p>The real problem is that creating a new query language is a <i>ton</i> of work. You need to create tooling, language servers, integrate with notebooks, etc… If you use SQL you get all of this for free.</div><br/></div></div></div></div><div id="39543076" class="c"><input type="checkbox" id="c-39543076" checked=""/><div class="controls bullet"><span class="by">vincnetas</span><span>|</span><a href="#39541500">prev</a><span>|</span><a href="#39545885">next</a><span>|</span><label class="collapse" for="c-39543076">[-]</label><label class="expand" for="c-39543076">[1 more]</label></div><br/><div class="children"><div class="content">for anyone using anything more than basic SQL functionality so far this looks very limiting. No window functions, no agregate filtering, no data type specific functions (ranges).</div><br/></div></div><div id="39545885" class="c"><input type="checkbox" id="c-39545885" checked=""/><div class="controls bullet"><span class="by">prasoonds</span><span>|</span><a href="#39543076">prev</a><span>|</span><a href="#39544671">next</a><span>|</span><label class="collapse" for="c-39545885">[-]</label><label class="expand" for="c-39545885">[1 more]</label></div><br/><div class="children"><div class="content">One potential advantage of these compile-to-SQL languages seems to be - they might be easier to tune a codegen LLM on. SQL is very verbose and IME, english -&gt; SQL doesn&#x27;t really work too well, even in high end products (i.e. pricy SaaS offerings using presumably GPT-4)<p>My hunch is tuning english prompts on less verbose, more &quot;left to right&quot; flowing languages might yield better results.</div><br/></div></div><div id="39544671" class="c"><input type="checkbox" id="c-39544671" checked=""/><div class="controls bullet"><span class="by">shp0ngle</span><span>|</span><a href="#39545885">prev</a><span>|</span><a href="#39542225">next</a><span>|</span><label class="collapse" for="c-39544671">[-]</label><label class="expand" for="c-39544671">[1 more]</label></div><br/><div class="children"><div class="content">How do I get parametered queries into this? can I? should I?<p>edit: guess I can&#x27;t<p><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;runreveal&#x2F;pql" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;runreveal&#x2F;pql</a></div><br/></div></div><div id="39542225" class="c"><input type="checkbox" id="c-39542225" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#39544671">prev</a><span>|</span><a href="#39546020">next</a><span>|</span><label class="collapse" for="c-39542225">[-]</label><label class="expand" for="c-39542225">[17 more]</label></div><br/><div class="children"><div class="content">At this stage I feel that the natural evolution for SQL is instead to use english to describe what you want and have an LLM generate SQL. Often with comments.<p>For some reason, a lot of these SQL alternatives seem to be syntactic preference and not much simpler or clearer than the original.</div><br/><div id="39542406" class="c"><input type="checkbox" id="c-39542406" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#39542225">parent</a><span>|</span><a href="#39543228">next</a><span>|</span><label class="collapse" for="c-39542406">[-]</label><label class="expand" for="c-39542406">[4 more]</label></div><br/><div class="children"><div class="content">Does this really appeal to developers?  SQL is an extremely expressive language and while there are things in it I would change they are mostly minor points.  Writing a query in english where the actual SQL it translates to is dependent on the specific version of the LLM seems dangerous - and forcing the query expression to be in a language that not everyone speaks either as a first language or at all seems to make code less accessible.<p>When properly styled with good indentation and syntax habits SQL is extremely readable.</div><br/><div id="39543540" class="c"><input type="checkbox" id="c-39543540" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#39542225">root</a><span>|</span><a href="#39542406">parent</a><span>|</span><a href="#39545511">next</a><span>|</span><label class="collapse" for="c-39543540">[-]</label><label class="expand" for="c-39543540">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s good for the case where you want a somewhat complex analytical query generated on the spot.<p>But this is only for initial generation. After that, you should be using pure SQL.</div><br/></div></div><div id="39545511" class="c"><input type="checkbox" id="c-39545511" checked=""/><div class="controls bullet"><span class="by">towelpluswater</span><span>|</span><a href="#39542225">root</a><span>|</span><a href="#39542406">parent</a><span>|</span><a href="#39543540">prev</a><span>|</span><a href="#39543228">next</a><span>|</span><label class="collapse" for="c-39545511">[-]</label><label class="expand" for="c-39545511">[2 more]</label></div><br/><div class="children"><div class="content">I’ve never understood why people want a more verbose version of sql.<p>I think what people really want is business rules and data cleaning and schema discovery.<p>If you had to use English against multiple source systems to and tons of joins, the sentence would be paragraphs.<p>Where I think there’s value is in using something like a data catalog to label business rules against a data warehouse, tied to dashboard queries and other common ones.<p>But that’s a hard problem and a unique model to every customer. And always changing.</div><br/><div id="39546987" class="c"><input type="checkbox" id="c-39546987" checked=""/><div class="controls bullet"><span class="by">staticautomatic</span><span>|</span><a href="#39542225">root</a><span>|</span><a href="#39545511">parent</a><span>|</span><a href="#39543228">next</a><span>|</span><label class="collapse" for="c-39546987">[-]</label><label class="expand" for="c-39546987">[1 more]</label></div><br/><div class="children"><div class="content">Combining schema discovery and data catalog seems like it might be a hard problem requiring a lot of LLM prompt engineering gymnastics but maybe I underestimate the state of the art.</div><br/></div></div></div></div></div></div><div id="39543228" class="c"><input type="checkbox" id="c-39543228" checked=""/><div class="controls bullet"><span class="by">importantbrian</span><span>|</span><a href="#39542225">parent</a><span>|</span><a href="#39542406">prev</a><span>|</span><a href="#39542264">next</a><span>|</span><label class="collapse" for="c-39543228">[-]</label><label class="expand" for="c-39543228">[3 more]</label></div><br/><div class="children"><div class="content">We might eventually get a good LLM to SQL tool, but my experience with them is that they make slick sales demos, but are worse than useless in the real world.<p>You have to know SQL to use them. They produce a lot of code that looks correct and produces correct-looking results with subtle errors. So you can&#x27;t just hand it to someone who doesn&#x27;t know SQL and let them query the database, but that&#x27;s the use case where something like this would be valuable. You have to be experienced with SQL and know all the peccadillos of the DB you&#x27;re working with to check the query and output for correctness.<p>For someone like me who is experienced with SQL, I can write simple queries just as fast as I can figure out how to prompt the LLM to get what I want. Where a tool like this would be really helpful is if it could help me write more complex queries more quickly. However, it is non-trivial to get the LLM to generate complex queries that take into account all the idiosyncrasies of your specific data model. So again it ends up being much faster for me to just write the query myself and not involve the LLM.<p>Where I think LLMs go wrong with SQL is that to write good SQL you have to have a deep knowledge of the underlying data model, and the LLMs aren&#x27;t good at that yet.</div><br/><div id="39547643" class="c"><input type="checkbox" id="c-39547643" checked=""/><div class="controls bullet"><span class="by">apoorvnandan</span><span>|</span><a href="#39542225">root</a><span>|</span><a href="#39543228">parent</a><span>|</span><a href="#39547005">next</a><span>|</span><label class="collapse" for="c-39547643">[-]</label><label class="expand" for="c-39547643">[1 more]</label></div><br/><div class="children"><div class="content">Strongly agree. LLMs need something more than just the DDL of the tables and an instruction to write useful SQL in the real world. 
However, I&#x27;ve had decent success by (1) integrating heavily with a semantic layer on top of your database, and (2) going the agent approach where the LLM is allowed to run different queries and explore the data before writing the final query.</div><br/></div></div><div id="39547005" class="c"><input type="checkbox" id="c-39547005" checked=""/><div class="controls bullet"><span class="by">staticautomatic</span><span>|</span><a href="#39542225">root</a><span>|</span><a href="#39543228">parent</a><span>|</span><a href="#39547643">prev</a><span>|</span><a href="#39542264">next</a><span>|</span><label class="collapse" for="c-39547005">[-]</label><label class="expand" for="c-39547005">[1 more]</label></div><br/><div class="children"><div class="content">Asking the LLM if the query can be optimized a few times and then checking it in a planner  works surprisingly well for me but YMMV.</div><br/></div></div></div></div><div id="39542264" class="c"><input type="checkbox" id="c-39542264" checked=""/><div class="controls bullet"><span class="by">caust1c</span><span>|</span><a href="#39542225">parent</a><span>|</span><a href="#39543228">prev</a><span>|</span><a href="#39542998">next</a><span>|</span><label class="collapse" for="c-39542264">[-]</label><label class="expand" for="c-39542264">[5 more]</label></div><br/><div class="children"><div class="content">We built LLM-to-SQL before this at RunReveal, and while it&#x27;s useful and gets queries mostly correct 80% of the time, 20% of the time it&#x27;s way off or requires nontrivial manual intervention.<p>We&#x27;re still fairly bullish on the LLM-to-SQL front though, but in the meantime PQL is a good bridge.</div><br/><div id="39542655" class="c"><input type="checkbox" id="c-39542655" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#39542225">root</a><span>|</span><a href="#39542264">parent</a><span>|</span><a href="#39542998">next</a><span>|</span><label class="collapse" for="c-39542655">[-]</label><label class="expand" for="c-39542655">[4 more]</label></div><br/><div class="children"><div class="content">As a company that&#x27;s invested into this.  Would you mind talking as to why you don&#x27;t want to use raw SQL - are there particular deficiencies you&#x27;ve found in it?</div><br/><div id="39543028" class="c"><input type="checkbox" id="c-39543028" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#39542225">root</a><span>|</span><a href="#39542655">parent</a><span>|</span><a href="#39542908">next</a><span>|</span><label class="collapse" for="c-39543028">[-]</label><label class="expand" for="c-39543028">[1 more]</label></div><br/><div class="children"><div class="content">See tools like pandas and Polars. These database libraries are abstractions that give you a spray of SQL functionality. I prefer using these libraries because it feels much more intuitive (and works with the Python&#x2F;arrow ecosystem). (I&#x27;m also biased since I make a portion of my living off of pandas training material.)</div><br/></div></div><div id="39542908" class="c"><input type="checkbox" id="c-39542908" checked=""/><div class="controls bullet"><span class="by">ejcx</span><span>|</span><a href="#39542225">root</a><span>|</span><a href="#39542655">parent</a><span>|</span><a href="#39543028">prev</a><span>|</span><a href="#39542857">next</a><span>|</span><label class="collapse" for="c-39542908">[-]</label><label class="expand" for="c-39542908">[1 more]</label></div><br/><div class="children"><div class="content">We do use raw sql, but we&#x27;re a security business which tends to have heavy reliance on other languages that have a similar syntax to pql</div><br/></div></div><div id="39542857" class="c"><input type="checkbox" id="c-39542857" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#39542225">root</a><span>|</span><a href="#39542655">parent</a><span>|</span><a href="#39542908">prev</a><span>|</span><a href="#39542998">next</a><span>|</span><label class="collapse" for="c-39542857">[-]</label><label class="expand" for="c-39542857">[1 more]</label></div><br/><div class="children"><div class="content">Here is a long blogpost &quot;against SQL&quot; which lists many deficiencies of it: <a href="https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;against-sql&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;against-sql&#x2F;</a><p>In short, it has a longer spec than famously-complex C++ while making a much less expressive language out of it.</div><br/></div></div></div></div></div></div><div id="39542998" class="c"><input type="checkbox" id="c-39542998" checked=""/><div class="controls bullet"><span class="by">rgmerk</span><span>|</span><a href="#39542225">parent</a><span>|</span><a href="#39542264">prev</a><span>|</span><a href="#39542289">next</a><span>|</span><label class="collapse" for="c-39542998">[-]</label><label class="expand" for="c-39542998">[1 more]</label></div><br/><div class="children"><div class="content">A thought experiment:<p>Rather than an LLM, you can send your request for an SQL query directly to Donald D. Chamberlin, one of the original designers of SQL.  Furthermore, he gets an ERD for your database.<p>What odds you get back a query that gives you correct answers?</div><br/></div></div><div id="39543273" class="c"><input type="checkbox" id="c-39543273" checked=""/><div class="controls bullet"><span class="by">mritchie712</span><span>|</span><a href="#39542225">parent</a><span>|</span><a href="#39542289">prev</a><span>|</span><a href="#39542391">next</a><span>|</span><label class="collapse" for="c-39543273">[-]</label><label class="expand" for="c-39543273">[1 more]</label></div><br/><div class="children"><div class="content">we (<a href="https:&#x2F;&#x2F;www.definite.app&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.definite.app&#x2F;</a>) do this.<p>The SQL generation works well out of the box and works better as you update the semantic layer. The semantic layer includes things like joins and measures (e.g. aggregate functions) that you&#x27;d want standard definitions for. For example, you don&#x27;t want an LLM creating a definition for MRR on the fly. All the semantic definitions are plain SQL.<p>quick demo: <a href="https:&#x2F;&#x2F;www.loom.com&#x2F;share&#x2F;a0d3c0e273004d7982b2aed24628ef40?t=27&amp;sid=84351346-b644-40b5-a30f-ceb065b62027" rel="nofollow">https:&#x2F;&#x2F;www.loom.com&#x2F;share&#x2F;a0d3c0e273004d7982b2aed24628ef40?...</a></div><br/></div></div><div id="39542391" class="c"><input type="checkbox" id="c-39542391" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#39542225">parent</a><span>|</span><a href="#39543273">prev</a><span>|</span><a href="#39546020">next</a><span>|</span><label class="collapse" for="c-39542391">[-]</label><label class="expand" for="c-39542391">[1 more]</label></div><br/><div class="children"><div class="content">SQL is part of a generation of languages which attempted to have (within strict syntactical constraints), a natural language-sounding approach to begin with (another one that comes to mind is AppleScript).</div><br/></div></div></div></div><div id="39546020" class="c"><input type="checkbox" id="c-39546020" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#39542225">prev</a><span>|</span><a href="#39543248">next</a><span>|</span><label class="collapse" for="c-39546020">[-]</label><label class="expand" for="c-39546020">[1 more]</label></div><br/><div class="children"><div class="content">I never liked the original SQL syntax, it&#x27;s weird. It&#x27;s one of the few places where I think using s-exprs would&#x27;ve made more sense.</div><br/></div></div><div id="39543248" class="c"><input type="checkbox" id="c-39543248" checked=""/><div class="controls bullet"><span class="by">pknerd</span><span>|</span><a href="#39546020">prev</a><span>|</span><a href="#39544288">next</a><span>|</span><label class="collapse" for="c-39543248">[-]</label><label class="expand" for="c-39543248">[9 more]</label></div><br/><div class="children"><div class="content">Sorry I might be dumb but why do we need this?</div><br/><div id="39543711" class="c"><input type="checkbox" id="c-39543711" checked=""/><div class="controls bullet"><span class="by">falserum</span><span>|</span><a href="#39543248">parent</a><span>|</span><a href="#39543741">next</a><span>|</span><label class="collapse" for="c-39543711">[-]</label><label class="expand" for="c-39543711">[7 more]</label></div><br/><div class="children"><div class="content">Because SQL is a nightmare.
(Standard is in thousands of pages; nobody fully implements it; not actually a single language as usually each db has deviations and extensions; nonmodular, composability is hard - an afterthought)<p>And the worst part: nothing better exist; single’ish bad language is better than dozens of new shortlived ones that have quirks in various other places.<p>But somebody needs to be idealist and keep trying.</div><br/><div id="39545189" class="c"><input type="checkbox" id="c-39545189" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#39543248">root</a><span>|</span><a href="#39543711">parent</a><span>|</span><a href="#39544285">next</a><span>|</span><label class="collapse" for="c-39545189">[-]</label><label class="expand" for="c-39545189">[1 more]</label></div><br/><div class="children"><div class="content">SQL is indeed pretty terrible IMO. Here&#x27;s my favorite source to trot out when people inevitably disagree: <a href="https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;against-sql&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;against-sql&#x2F;</a></div><br/></div></div><div id="39544285" class="c"><input type="checkbox" id="c-39544285" checked=""/><div class="controls bullet"><span class="by">RoyTyrell</span><span>|</span><a href="#39543248">root</a><span>|</span><a href="#39543711">parent</a><span>|</span><a href="#39545189">prev</a><span>|</span><a href="#39544559">next</a><span>|</span><label class="collapse" for="c-39544285">[-]</label><label class="expand" for="c-39544285">[4 more]</label></div><br/><div class="children"><div class="content">That is quite a hyperbolic statement and I have to disagree with you. I&#x27;ve used SQL on a variety of databases over 15 years, and yes while some like MySQL have poorly implemented anything other than basic SQL&#x2F;RDBMS features, most are very similar in feature sets. There are vendors-specific additional features like how Oracle supports hierarchical queries with CONNECT, but you don&#x27;t have to use them.<p>- CTEs are very close if not the same across Oracle, PostgreSQL, DB2, Hive, Snowflake, and MS SQL Server - I believe even Sybase too but it&#x27;s been a while. - Joins work all largely the same even though a couple of those support additional join types, especially when you want to join on functions that return data sets.
- Window functions are supported by every major DB with similar or the same syntax too. Any differences take 5sec to lookup in documentation.<p>My only complaint is loading data is highly vendor specific.</div><br/><div id="39545298" class="c"><input type="checkbox" id="c-39545298" checked=""/><div class="controls bullet"><span class="by">bradford</span><span>|</span><a href="#39543248">root</a><span>|</span><a href="#39544285">parent</a><span>|</span><a href="#39546030">next</a><span>|</span><label class="collapse" for="c-39545298">[-]</label><label class="expand" for="c-39545298">[2 more]</label></div><br/><div class="children"><div class="content">I used SQL in various implementations for about 15 years. I didn&#x27;t find much fault in it until I started using KQL (the language which seems to have inspired Pql).<p>The difference in enjoyability is stark: I truly hate SQL now.<p>More robust criticism is provided here (<a href="https:&#x2F;&#x2F;carlineng.com&#x2F;?postid=sql-critique#blog" rel="nofollow">https:&#x2F;&#x2F;carlineng.com&#x2F;?postid=sql-critique#blog</a>).  The quote I usually drag out is from Chris Date, who helped pioneer relational DBs:<p>&quot;At the same time, I have to say too that we didn’t realize how truly awful SQL was or would turn out to be (note that it’s much worse now than it was then, though it was pretty bad right from the outset).&quot;<p><a href="https:&#x2F;&#x2F;www.red-gate.com&#x2F;simple-talk&#x2F;opinion&#x2F;opinion-pieces&#x2F;chris-date-and-the-relational-model&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.red-gate.com&#x2F;simple-talk&#x2F;opinion&#x2F;opinion-pieces&#x2F;...</a></div><br/><div id="39546067" class="c"><input type="checkbox" id="c-39546067" checked=""/><div class="controls bullet"><span class="by">ttfkam</span><span>|</span><a href="#39543248">root</a><span>|</span><a href="#39545298">parent</a><span>|</span><a href="#39546030">next</a><span>|</span><label class="collapse" for="c-39546067">[-]</label><label class="expand" for="c-39546067">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    For example, why not allow the following expression as a legal statement:

    tablename;
</code></pre>
FYI, in Postgres you can write<p><pre><code>    TABLE tablename;</code></pre></div><br/></div></div></div></div><div id="39546030" class="c"><input type="checkbox" id="c-39546030" checked=""/><div class="controls bullet"><span class="by">ttfkam</span><span>|</span><a href="#39543248">root</a><span>|</span><a href="#39544285">parent</a><span>|</span><a href="#39545298">prev</a><span>|</span><a href="#39544559">next</a><span>|</span><label class="collapse" for="c-39546030">[-]</label><label class="expand" for="c-39546030">[1 more]</label></div><br/><div class="children"><div class="content">MySQL has supported CTEs since v8.0. Sadly, still no support for RETURNING though, which limits their usefulness, but it does in fact support CTEs now.</div><br/></div></div></div></div><div id="39544559" class="c"><input type="checkbox" id="c-39544559" checked=""/><div class="controls bullet"><span class="by">throwanem</span><span>|</span><a href="#39543248">root</a><span>|</span><a href="#39543711">parent</a><span>|</span><a href="#39544285">prev</a><span>|</span><a href="#39543741">next</a><span>|</span><label class="collapse" for="c-39544559">[-]</label><label class="expand" for="c-39544559">[1 more]</label></div><br/><div class="children"><div class="content">Most of these problems are pretty trivial to solve by simply reading the manual for the database engine you happen to be using, which typically will document deviations from the standard in serviceable detail.<p>I&#x27;d be more sympathetic to concerns about switching engines if I had, at any point in a career now heading for its 25th year, ever seen that occur.<p>Given the frequency with which ORMs are used in greenfield to defend against this notional problem, and the many problems that using an ORM <i>always</i> inflicts, this may well be the costliest form of premature optimization I&#x27;ve ever seen. It certainly can&#x27;t be outside the top three.</div><br/></div></div></div></div><div id="39543741" class="c"><input type="checkbox" id="c-39543741" checked=""/><div class="controls bullet"><span class="by">pknerd</span><span>|</span><a href="#39543248">parent</a><span>|</span><a href="#39543711">prev</a><span>|</span><a href="#39544288">next</a><span>|</span><label class="collapse" for="c-39543741">[-]</label><label class="expand" for="c-39543741">[1 more]</label></div><br/><div class="children"><div class="content">many other DSLs transformed to SQL. And now we have LLMs that can do it much better way.</div><br/></div></div></div></div><div id="39544288" class="c"><input type="checkbox" id="c-39544288" checked=""/><div class="controls bullet"><span class="by">dkga</span><span>|</span><a href="#39543248">prev</a><span>|</span><a href="#39544137">next</a><span>|</span><label class="collapse" for="c-39544288">[-]</label><label class="expand" for="c-39544288">[2 more]</label></div><br/><div class="children"><div class="content">The R {dbplyr} package is also a very good way in practice to pipe SQL.</div><br/><div id="39544573" class="c"><input type="checkbox" id="c-39544573" checked=""/><div class="controls bullet"><span class="by">civilized</span><span>|</span><a href="#39544288">parent</a><span>|</span><a href="#39544137">next</a><span>|</span><label class="collapse" for="c-39544573">[-]</label><label class="expand" for="c-39544573">[1 more]</label></div><br/><div class="children"><div class="content">Also AFAICT the only one that is fully integrated with a general purpose programming language with an excellent IDE.</div><br/></div></div></div></div><div id="39544137" class="c"><input type="checkbox" id="c-39544137" checked=""/><div class="controls bullet"><span class="by">nitrix</span><span>|</span><a href="#39544288">prev</a><span>|</span><a href="#39546128">next</a><span>|</span><label class="collapse" for="c-39544137">[-]</label><label class="expand" for="c-39544137">[2 more]</label></div><br/><div class="children"><div class="content">Pipelining is cool, though this could&#x27;ve easily just been a library with nice chaining and combinators in your language of choice (seems to be Go here).</div><br/><div id="39544682" class="c"><input type="checkbox" id="c-39544682" checked=""/><div class="controls bullet"><span class="by">benrutter</span><span>|</span><a href="#39544137">parent</a><span>|</span><a href="#39546128">next</a><span>|</span><label class="collapse" for="c-39544682">[-]</label><label class="expand" for="c-39544682">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, but isn&#x27;t the nice thing here that you can run it directly in your database? Which has all the data and probably a fair bit more compute power than your laptop&#x2F;PC.<p>Edit: my comment acted like ORM type libraries than execute within databases like Ibis don&#x27;t exist. My bad!</div><br/></div></div></div></div><div id="39546128" class="c"><input type="checkbox" id="c-39546128" checked=""/><div class="controls bullet"><span class="by">jkn23jn23jn</span><span>|</span><a href="#39544137">prev</a><span>|</span><a href="#39544620">next</a><span>|</span><label class="collapse" for="c-39546128">[-]</label><label class="expand" for="c-39546128">[1 more]</label></div><br/><div class="children"><div class="content">So basically the same as C# LINQ feature that allows you to automatically generate SQL and perform database operations without using SQL language.</div><br/></div></div><div id="39544620" class="c"><input type="checkbox" id="c-39544620" checked=""/><div class="controls bullet"><span class="by">ben_jones</span><span>|</span><a href="#39546128">prev</a><span>|</span><a href="#39546057">next</a><span>|</span><label class="collapse" for="c-39544620">[-]</label><label class="expand" for="c-39544620">[1 more]</label></div><br/><div class="children"><div class="content">I’m glad this exists but would caution extensibility as the most important thing for devs to consider when picking there “ORM” stack especially in terse Golang.<p>For that I use squirrel which uses the builder pattern to compose sql strings. Keeping it as strings and interfaces allow it to be very easily extended, for example I was able to customize it to speak SOQL (salesforce). plenty of downide though.</div><br/></div></div><div id="39546057" class="c"><input type="checkbox" id="c-39546057" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#39544620">prev</a><span>|</span><a href="#39546536">next</a><span>|</span><label class="collapse" for="c-39546057">[-]</label><label class="expand" for="c-39546057">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it. These examples are kinda uninspiring, generated SQL output being unnecessarily complicated doesn&#x27;t help. I haven&#x27;t used PRQL, but at least it&#x27;s pretty obvious from examples, how it&#x27;s nicer to use than SQL. But this one — yeah, examples on the left are &quot;nicer&quot; than convoluted output on the right, but if you write SQL <i>normally</i>, it&#x27;s basically just a lot of &quot;|&quot; and table name in the beginning, instead of in the middle. So what&#x27;s the point?</div><br/></div></div><div id="39546536" class="c"><input type="checkbox" id="c-39546536" checked=""/><div class="controls bullet"><span class="by">outside1234</span><span>|</span><a href="#39546057">prev</a><span>|</span><a href="#39543329">next</a><span>|</span><label class="collapse" for="c-39546536">[-]</label><label class="expand" for="c-39546536">[1 more]</label></div><br/><div class="children"><div class="content">Serious question - in this day and age why not just as GPT4 in English to write the SQL you need?</div><br/></div></div><div id="39543329" class="c"><input type="checkbox" id="c-39543329" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#39546536">prev</a><span>|</span><a href="#39544193">next</a><span>|</span><label class="collapse" for="c-39543329">[-]</label><label class="expand" for="c-39543329">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of how ActiveRecord works in Rails</div><br/></div></div><div id="39544193" class="c"><input type="checkbox" id="c-39544193" checked=""/><div class="controls bullet"><span class="by">mcphage</span><span>|</span><a href="#39543329">prev</a><span>|</span><a href="#39545171">next</a><span>|</span><label class="collapse" for="c-39544193">[-]</label><label class="expand" for="c-39544193">[6 more]</label></div><br/><div class="children"><div class="content">Their very first example has issues:<p>&gt; users 
&gt;    | where like(email, &#x27;gmail&#x27;)
&gt;    | count<p>becomes<p>&gt; WITH
&gt;  &quot;__subquery0&quot; AS (
&gt;    SELECT
&gt;      *
&gt;    FROM
&gt;      &quot;users&quot;
&gt;    WHERE
&gt;      like (&quot;email&quot;, &#x27;gmail&#x27;)
&gt;  )
&gt; SELECT
&gt;  COUNT(*) AS &quot;count()&quot;
&gt; FROM
&gt;   &quot;__subquery0&quot;;<p>Fetching everything from the users table can be a ton slower than just running a count on that table, if the table is indexed on email.  I had to deal with that very problem this week.</div><br/><div id="39544259" class="c"><input type="checkbox" id="c-39544259" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39544193">parent</a><span>|</span><a href="#39544628">next</a><span>|</span><label class="collapse" for="c-39544259">[-]</label><label class="expand" for="c-39544259">[3 more]</label></div><br/><div class="children"><div class="content">That is the same query plan for any contemporary query planner.<p>(Just like any C compiler will produce the same output for `x += 2` and `x += 1 + 1`.)<p>---<p>A notable exception was PostgreSQL prior to version 12, which treated CTEs as an optimization fences.</div><br/><div id="39544607" class="c"><input type="checkbox" id="c-39544607" checked=""/><div class="controls bullet"><span class="by">throwanem</span><span>|</span><a href="#39544193">root</a><span>|</span><a href="#39544259">parent</a><span>|</span><a href="#39544628">next</a><span>|</span><label class="collapse" for="c-39544607">[-]</label><label class="expand" for="c-39544607">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be hesitant to assume the generated CTEs are always going to be amenable to optimization. The examples on the linked page are pretty trivial queries - I wonder what happens when that ceases to be the case, as seems very likely with a tool that apparently doesn&#x27;t do a great deal to promote understanding what goes on under the hood.</div><br/><div id="39544784" class="c"><input type="checkbox" id="c-39544784" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#39544193">root</a><span>|</span><a href="#39544607">parent</a><span>|</span><a href="#39544628">next</a><span>|</span><label class="collapse" for="c-39544784">[-]</label><label class="expand" for="c-39544784">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s possible for sure.<p>It&#x27;s just worth recognizing that SQL itself is a tool that doesn&#x27;t do a great deal promote understanding what goes on under the hood. (I&#x27;ve witnessed that firsthand many times.)</div><br/></div></div></div></div></div></div><div id="39544224" class="c"><input type="checkbox" id="c-39544224" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39544193">parent</a><span>|</span><a href="#39544628">prev</a><span>|</span><a href="#39545171">next</a><span>|</span><label class="collapse" for="c-39544224">[-]</label><label class="expand" for="c-39544224">[1 more]</label></div><br/><div class="children"><div class="content">Should not be a problem on modern Postgres.</div><br/></div></div></div></div><div id="39545171" class="c"><input type="checkbox" id="c-39545171" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39544193">prev</a><span>|</span><a href="#39541816">next</a><span>|</span><label class="collapse" for="c-39545171">[-]</label><label class="expand" for="c-39545171">[1 more]</label></div><br/><div class="children"><div class="content">Another day, another framework that tries to reinvent a limited subset of C#&#x27;s LINQ query syntax :)</div><br/></div></div><div id="39541816" class="c"><input type="checkbox" id="c-39541816" checked=""/><div class="controls bullet"><span class="by">gtroja</span><span>|</span><a href="#39545171">prev</a><span>|</span><label class="collapse" for="c-39541816">[-]</label><label class="expand" for="c-39541816">[20 more]</label></div><br/><div class="children"><div class="content">The only thing I like in SQL is that is almost the same language in decades. Learn it once and you&#x27;re done. If you really need, you could write macros yourself. I don&#x27;t see the value of learning a new language to do the same thing</div><br/><div id="39543219" class="c"><input type="checkbox" id="c-39543219" checked=""/><div class="controls bullet"><span class="by">dvdkon</span><span>|</span><a href="#39541816">parent</a><span>|</span><a href="#39544936">next</a><span>|</span><label class="collapse" for="c-39543219">[-]</label><label class="expand" for="c-39543219">[1 more]</label></div><br/><div class="children"><div class="content">Given how many new programming languages have become widely used in the time since SQL&#x27;s creation, it seems many others <i>do</i> se some value. For a mostly direct parallel to PQL, see CoffeeScript and TypeScript.</div><br/></div></div><div id="39542761" class="c"><input type="checkbox" id="c-39542761" checked=""/><div class="controls bullet"><span class="by">quaunaut</span><span>|</span><a href="#39541816">parent</a><span>|</span><a href="#39544936">prev</a><span>|</span><a href="#39543350">next</a><span>|</span><label class="collapse" for="c-39542761">[-]</label><label class="expand" for="c-39542761">[12 more]</label></div><br/><div class="children"><div class="content">SQL&#x27;s nonsensical handling of null is reason enough to learn other query languages.</div><br/><div id="39543726" class="c"><input type="checkbox" id="c-39543726" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39542761">parent</a><span>|</span><a href="#39544084">next</a><span>|</span><label class="collapse" for="c-39543726">[-]</label><label class="expand" for="c-39543726">[9 more]</label></div><br/><div class="children"><div class="content">Do you mean that NULL &lt;&gt; NULL and NULL infects boolean logic?<p>NULL is always an awkward thing to deal with - how you want to handle it depends on the specific thing you&#x27;re trying to accomplish.  I&#x27;d probably prefer it if NULL equaled NULL when dealing with where conditions but it actually makes join evaluations a lot cleaner - if NULL equaled NULL then joining on columns with nulls would get really weird.<p>At the end of the day IS NULL and IS DISTINCT FROM&#x2F;IS NOT DISTINCT FROM exist so you can handle cases where it&#x27;d be weird.</div><br/><div id="39543811" class="c"><input type="checkbox" id="c-39543811" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39543726">parent</a><span>|</span><a href="#39544084">next</a><span>|</span><label class="collapse" for="c-39543811">[-]</label><label class="expand" for="c-39543811">[8 more]</label></div><br/><div class="children"><div class="content">the best way to handle nulls is with Option &#x2F; Maybe types. that is, without null at all<p>unfortunately they were not invented at the time sql was created</div><br/><div id="39544047" class="c"><input type="checkbox" id="c-39544047" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39543811">parent</a><span>|</span><a href="#39544084">next</a><span>|</span><label class="collapse" for="c-39544047">[-]</label><label class="expand" for="c-39544047">[7 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s just a question on syntactic sugaring here - so, concretely, what would that mean for comparison operators?  If I wanted to `id = id` and both were nullable would I need to express that as two layers of statements where I tried to unwrap both sides first or would we have a maybe vs maybe comparison operator - if we had such an operator what would it do in this case?</div><br/><div id="39544274" class="c"><input type="checkbox" id="c-39544274" checked=""/><div class="controls bullet"><span class="by">setr</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39544047">parent</a><span>|</span><a href="#39544694">next</a><span>|</span><label class="collapse" for="c-39544274">[-]</label><label class="expand" for="c-39544274">[3 more]</label></div><br/><div class="children"><div class="content">You’d have to unwrap, usually with convenient mechanism for it —pattern matching<p>The problem is that id = id is fundamentally incorrect for a nullable column. You should have done id is not null and id = id. And you shouldn’t have been allowed to do the first anyways, because nothing good can come of it (there is no sane semantics to stuffing a trinary logic into a boolean algebra, and SQL chooses one of the many insane options, leading to both false positive and false negative matches depending.) the only correct answer is not to do that.</div><br/><div id="39544334" class="c"><input type="checkbox" id="c-39544334" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39544274">parent</a><span>|</span><a href="#39544694">next</a><span>|</span><label class="collapse" for="c-39544334">[-]</label><label class="expand" for="c-39544334">[2 more]</label></div><br/><div class="children"><div class="content">I can understand how that would make things more explicit - but given how common nullability is in the realm of databases I think it&#x27;d be a bad idea to force that much syntax in a situation where id=id is essentially what we want to discuss - especially since columns becoming potentially null is so trivial to achieve (even when impossible due to model constraints) as soon as you start throwing left joins in the mix.</div><br/><div id="39547013" class="c"><input type="checkbox" id="c-39547013" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39544334">parent</a><span>|</span><a href="#39544694">next</a><span>|</span><label class="collapse" for="c-39547013">[-]</label><label class="expand" for="c-39547013">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you really want explicit, rather than dealing with the errors caused by implicitness. And with a language that has proper support for things like Maybe, there isn&#x27;t that much syntax.<p>It&#x27;s true that you have to adopt a completely different language, but when that language saves you from potentially expensive bugs, it becomes appealing.</div><br/></div></div></div></div></div></div><div id="39544694" class="c"><input type="checkbox" id="c-39544694" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39544047">parent</a><span>|</span><a href="#39544274">prev</a><span>|</span><a href="#39544084">next</a><span>|</span><label class="collapse" for="c-39544694">[-]</label><label class="expand" for="c-39544694">[3 more]</label></div><br/><div class="children"><div class="content">You might be interested in my attempt: <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;plisqin&#x2F;Nullability.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;plisqin&#x2F;Nullability.html</a><p>I think it handles all the 3VL problems I&#x27;ve encountered in SQL, but that doesn&#x27;t mean it handles all possible 3VL problems. It also might not make any sense to anyone except me.</div><br/><div id="39544826" class="c"><input type="checkbox" id="c-39544826" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39544694">parent</a><span>|</span><a href="#39544084">next</a><span>|</span><label class="collapse" for="c-39544826">[-]</label><label class="expand" for="c-39544826">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a while since relational algebra so I don&#x27;t feel confident saying &quot;Yes&quot; or &quot;No&quot; (I guess you could say my reply is Null) - but that seems like a really good base approach - especially having a state for being uncertain whether something is nullable or not... having an operator embeded fallback approach also seems to be a lot more usable for the developer.<p>Also, this is an aside, but is your thing named after Snake Plissken?</div><br/><div id="39545140" class="c"><input type="checkbox" id="c-39545140" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39544826">parent</a><span>|</span><a href="#39544084">next</a><span>|</span><label class="collapse" for="c-39545140">[-]</label><label class="expand" for="c-39545140">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, kind of. I have seen Escape From New York but I don&#x27;t really remember it. I was more aware of the character via the reference&#x2F;homage in Metal Gear Solid 2. In any case, I don&#x27;t love the name but the obvious choice (Racquel) was already taken and &quot;Plisqin&quot; had zero Google results so I said &quot;meh, good enough.&quot;</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39544084" class="c"><input type="checkbox" id="c-39544084" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39542761">parent</a><span>|</span><a href="#39543726">prev</a><span>|</span><a href="#39543412">next</a><span>|</span><label class="collapse" for="c-39544084">[-]</label><label class="expand" for="c-39544084">[1 more]</label></div><br/><div class="children"><div class="content">Pql uses the same NUll handling, since it just passes it through to the generated SQL.</div><br/></div></div><div id="39543412" class="c"><input type="checkbox" id="c-39543412" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39542761">parent</a><span>|</span><a href="#39544084">prev</a><span>|</span><a href="#39543350">next</a><span>|</span><label class="collapse" for="c-39543412">[-]</label><label class="expand" for="c-39543412">[1 more]</label></div><br/><div class="children"><div class="content">Using this language on top won’t solve that though, it still compiles into sql, warts and all.</div><br/></div></div></div></div><div id="39543350" class="c"><input type="checkbox" id="c-39543350" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#39541816">parent</a><span>|</span><a href="#39542761">prev</a><span>|</span><label class="collapse" for="c-39543350">[-]</label><label class="expand" for="c-39543350">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The only thing I like in SQL is that is almost the same language in decades<p>So you do agree that the rest of SQL is broken. That’s why there is a value in creating (and learning) such new languages.</div><br/><div id="39544099" class="c"><input type="checkbox" id="c-39544099" checked=""/><div class="controls bullet"><span class="by">kubota</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39543350">parent</a><span>|</span><label class="collapse" for="c-39544099">[-]</label><label class="expand" for="c-39544099">[4 more]</label></div><br/><div class="children"><div class="content">I strongly disagree that SQL is broken. Try using JPA or your favorite ORM on a large project with a complex entity graph. It is a nightmare having to ctrl-click deep into the entity graph to see what annotations are on some great-grandchildren to get an idea as to what query is being executed. When working with relational data SQL has always been the ideal tool for the job on the projects I&#x27;ve worked on.</div><br/><div id="39544206" class="c"><input type="checkbox" id="c-39544206" checked=""/><div class="controls bullet"><span class="by">setr</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39544099">parent</a><span>|</span><label class="collapse" for="c-39544206">[-]</label><label class="expand" for="c-39544206">[3 more]</label></div><br/><div class="children"><div class="content">ORMs are fundamentally broken. Hiding the relational structure of a relational database is the act of madmen.<p>Using the psychosis of ORMs to defend the psychosis of SQL is itself a form of psychosis</div><br/><div id="39544636" class="c"><input type="checkbox" id="c-39544636" checked=""/><div class="controls bullet"><span class="by">xienze</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39544206">parent</a><span>|</span><label class="collapse" for="c-39544636">[-]</label><label class="expand" for="c-39544636">[2 more]</label></div><br/><div class="children"><div class="content">I think a lot of times people say “ORM” when they mean “Hibernate” or some other ORM implementation.<p>In your codebase, do you stick raw SQL all over the place and iterate over rows exclusively?  Or instead, as a convenience, do you write helpers that map objects into SQL statements and map result rows into objects?  If so, congratulations, you’re using an ORM. The concept of ORMs is not bad.  It’s a logical thing to do.  Some ORM _implementations_ have some very serious issues, but that does not make ORMs as a whole bad.</div><br/><div id="39547394" class="c"><input type="checkbox" id="c-39547394" checked=""/><div class="controls bullet"><span class="by">setr</span><span>|</span><a href="#39541816">root</a><span>|</span><a href="#39544636">parent</a><span>|</span><label class="collapse" for="c-39547394">[-]</label><label class="expand" for="c-39547394">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I&#x27;d consider query-builders to be ORMs. You do inevitably have a mapping from query resultset to list&lt;obj&gt;, so it does meet the name itself, but there&#x27;s clearly a very large difference between &quot;Hibernate&quot; and query-builder, and if you don&#x27;t want to use ORM to be the differentiating term calling out Hibernate and friends specifically, then let me know what you do wish to use. But as far as I know, colloquially and commonly, ORM refers to the former -- not the general act of having any mapping at all.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>