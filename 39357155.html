<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707901257900" as="style"/><link rel="stylesheet" href="styles.css?v=1707901257900"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://adam.nels.onl//blog/maybe-everything-is-a-coroutine/">Maybe Everything Is a Coroutine</a> <span class="domain">(<a href="https://adam.nels.onl">adam.nels.onl</a>)</span></div><div class="subtext"><span>rsaarelm</span> | <span>20 comments</span></div><br/><div><div id="39359283" class="c"><input type="checkbox" id="c-39359283" checked=""/><div class="controls bullet"><span class="by">quadhome</span><span>|</span><a href="#39367756">next</a><span>|</span><label class="collapse" for="c-39359283">[-]</label><label class="expand" for="c-39359283">[6 more]</label></div><br/><div class="children"><div class="content">Not everything, but if by “coroutine” we mean a delimited continuation, then we get: exceptions, async&#x2F;await, generators, and even the IO monad.<p><a href="http:&#x2F;&#x2F;logic.cs.tsukuba.ac.jp&#x2F;~sat&#x2F;pdf&#x2F;tfp2020.pdf" rel="nofollow">http:&#x2F;&#x2F;logic.cs.tsukuba.ac.jp&#x2F;~sat&#x2F;pdf&#x2F;tfp2020.pdf</a><p>In short: algebraic effects.<p>Here’s a whole thesis on the cool things that can do done with this one simple trick: <a href="https:&#x2F;&#x2F;publikationen.uni-tuebingen.de&#x2F;xmlui&#x2F;bitstream&#x2F;handle&#x2F;10900&#x2F;102021&#x2F;thesis-v1.1.pdf?sequence=1&amp;isAllowed=y" rel="nofollow">https:&#x2F;&#x2F;publikationen.uni-tuebingen.de&#x2F;xmlui&#x2F;bitstream&#x2F;handl...</a></div><br/><div id="39367189" class="c"><input type="checkbox" id="c-39367189" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#39359283">parent</a><span>|</span><a href="#39367756">next</a><span>|</span><label class="collapse" for="c-39367189">[-]</label><label class="expand" for="c-39367189">[5 more]</label></div><br/><div class="children"><div class="content">I get the first three
but what is the connection to the IO monad?</div><br/><div id="39367308" class="c"><input type="checkbox" id="c-39367308" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39359283">root</a><span>|</span><a href="#39367189">parent</a><span>|</span><a href="#39367756">next</a><span>|</span><label class="collapse" for="c-39367308">[-]</label><label class="expand" for="c-39367308">[4 more]</label></div><br/><div class="children"><div class="content">I guess every monad can be expressed as the continuation monad; and that includes the IO monad?</div><br/><div id="39367648" class="c"><input type="checkbox" id="c-39367648" checked=""/><div class="controls bullet"><span class="by">alipang</span><span>|</span><a href="#39359283">root</a><span>|</span><a href="#39367308">parent</a><span>|</span><a href="#39367756">next</a><span>|</span><label class="collapse" for="c-39367648">[-]</label><label class="expand" for="c-39367648">[3 more]</label></div><br/><div class="children"><div class="content">If you check out the linked paper you&#x27;ll see the title is &quot;One-shot Algebraic Effects as Coroutines&quot; - the keyword being &quot;one-shot&quot;.<p>In general every Monad can be expressed &quot;interpreting&quot; the free monad. This relaxes the &quot;one-shot&quot; restriction, and can be implemented using delimited control. One-shot means faster performance though and is still useful for many things - and that can be implemented using coroutines.<p>If you acquire some understanding of what this means then you&#x27;ll have a very good idea about the expressive power of what you can use coroutines (with nothing more) for, so it&#x27;s very interesting.</div><br/><div id="39367695" class="c"><input type="checkbox" id="c-39367695" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39359283">root</a><span>|</span><a href="#39367648">parent</a><span>|</span><a href="#39367756">next</a><span>|</span><label class="collapse" for="c-39367695">[-]</label><label class="expand" for="c-39367695">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not quite sure if the free monad (or the &#x27;freer&#x27; monad) can simulate the continuation monad?  See <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;25827271&#x2F;how-can-the-continuation-monad-be-expressed-using-the-free-monad" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;25827271&#x2F;how-can-the-con...</a></div><br/><div id="39367849" class="c"><input type="checkbox" id="c-39367849" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#39359283">root</a><span>|</span><a href="#39367695">parent</a><span>|</span><a href="#39367756">next</a><span>|</span><label class="collapse" for="c-39367849">[-]</label><label class="expand" for="c-39367849">[1 more]</label></div><br/><div class="children"><div class="content">After reading that, I think freer <i>can</i> in fact encode the continuation monad.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39367756" class="c"><input type="checkbox" id="c-39367756" checked=""/><div class="controls bullet"><span class="by">animal531</span><span>|</span><a href="#39359283">prev</a><span>|</span><a href="#39367641">next</a><span>|</span><label class="collapse" for="c-39367756">[-]</label><label class="expand" for="c-39367756">[1 more]</label></div><br/><div class="children"><div class="content">For my game projects in Unity I have been using coroutines quite a bit instead of the normal types of state machines.<p>It&#x27;s a lot easier to read and write, BUT it comes with the downside that its not easy to save or load, which makes it only usable in certain game types and&#x2F;or actions.</div><br/></div></div><div id="39367641" class="c"><input type="checkbox" id="c-39367641" checked=""/><div class="controls bullet"><span class="by">zgs</span><span>|</span><a href="#39367756">prev</a><span>|</span><a href="#39367559">next</a><span>|</span><label class="collapse" for="c-39367641">[-]</label><label class="expand" for="c-39367641">[1 more]</label></div><br/><div class="children"><div class="content">The programming language Beta took this way further many years ago:<p><a href="https:&#x2F;&#x2F;beta.cs.au.dk" rel="nofollow">https:&#x2F;&#x2F;beta.cs.au.dk</a><p>It&#x27;s syntax didn&#x27;t help it&#x27;s spread unfortunately.</div><br/></div></div><div id="39367559" class="c"><input type="checkbox" id="c-39367559" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#39367641">prev</a><span>|</span><a href="#39357279">next</a><span>|</span><label class="collapse" for="c-39367559">[-]</label><label class="expand" for="c-39367559">[2 more]</label></div><br/><div class="children"><div class="content">This makes me think of dataflow languages where functions are be suspended until their (logic variable) arguments are sufficiently bound, then they fire, with this being a somewhat more imperative take on it.</div><br/><div id="39367591" class="c"><input type="checkbox" id="c-39367591" checked=""/><div class="controls bullet"><span class="by">harperlee</span><span>|</span><a href="#39367559">parent</a><span>|</span><a href="#39357279">next</a><span>|</span><label class="collapse" for="c-39367591">[-]</label><label class="expand" for="c-39367591">[1 more]</label></div><br/><div class="children"><div class="content">In turn, it makes me think about relational &#x2F; logic programming languages.</div><br/></div></div></div></div><div id="39357279" class="c"><input type="checkbox" id="c-39357279" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#39367559">prev</a><span>|</span><a href="#39366990">next</a><span>|</span><label class="collapse" for="c-39357279">[-]</label><label class="expand" for="c-39357279">[3 more]</label></div><br/><div class="children"><div class="content">I designed a syntax for this: that everything is a state machine progression, a bit like sequence types in the article.<p><pre><code>   state1a state1b state1c | state2a state2b state2c | state3a state3b state3c
</code></pre>
This means wait for state1a, state1b state1c in any order, then move to the next sequence of things to wait for.<p>In a multithreaded server or multimachine distributed system, there are global states you want to wait for and then trigger behaviour. The communication can be inferred and optimised and scheduled.<p>It&#x27;s BNF syntax - inspired by parsing technology for parsing sequences of tokens but tokens represent events.<p>If you use printf debugging a lot, you know the progression of what you see is what happened and that helps you understand what went wrong. So why not write or generate the log of sequence of actions you want directly not worry about details?<p>But wait! There&#x27;s more. You can define movements between things.<p>So take an async&#x2F;await thread pool, this syntax defines an async&#x2F;await thread pool:<p><pre><code>  next_free_thread(thread:2);
  task(task:A) thread(thread:1) assignment(task:A, thread:1) = running_on(task:A, thread:1) | paused(task:A, thread:1);

  running_on(task:A, thread:1)
  thread(thread:1)
  assignment(task:A, thread:1)
  thread_free(thread:next_free_thread) = fork(task:A, task:B)
                                | send_task_to_thread(task:B, thread:next_free_thread)
                                |   running_on(task:B, thread:2)
                                    paused(task:A, thread:1)
                                    running_on(task:A, thread:1)
                                    assignment(task:B, thread:2)
                               | { yield(task:B, returnvalue) | paused(task:B, thread:2) }
                                 { await(task:A, task:B, returnvalue) | paused(task:A, thread:1) }
                               | send_returnvalue(task:B, task:A, returnvalue); 
  
</code></pre>
Why not just write what you want to happen and then the computer works out how to schedule it and parallelize it?<p>I think iteration&#x2F;looping and state persistence and closures are all related.<p>I have a parser for this syntax and a multithreaded barrier runtime which I&#x27;m working on, I use liburing. I want to get to 500 million requests per second of the and ~50ish nanosecond latency of LMAX Disruptor.<p>The notation could be used for business programming and low level server programming I think.</div><br/><div id="39367520" class="c"><input type="checkbox" id="c-39367520" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#39357279">parent</a><span>|</span><a href="#39367375">next</a><span>|</span><label class="collapse" for="c-39367520">[-]</label><label class="expand" for="c-39367520">[1 more]</label></div><br/><div class="children"><div class="content">This looks like it could be modelled by a petri net. Your states are typed tokens, and tasks (ie transitions) are triggered by the presence of tokens and produce tokens as output.<p>IMHO petri nets are the most widely applicable method for modelling concurrent processes that I&#x27;ve seen yet.</div><br/></div></div><div id="39367375" class="c"><input type="checkbox" id="c-39367375" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#39357279">parent</a><span>|</span><a href="#39367520">prev</a><span>|</span><a href="#39366990">next</a><span>|</span><label class="collapse" for="c-39367375">[-]</label><label class="expand" for="c-39367375">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>wait for state1a, state1b state1c in any order</i><p>Conway worked out some results for non-serialised (commutative) events in <i>Regular Algebra and Finite Machines</i> about half a century ago.</div><br/></div></div></div></div><div id="39366990" class="c"><input type="checkbox" id="c-39366990" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39357279">prev</a><span>|</span><a href="#39357342">next</a><span>|</span><label class="collapse" for="c-39366990">[-]</label><label class="expand" for="c-39366990">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this just iteratees? The examples look very similar to conduit code, unless I&#x27;m missing something.</div><br/><div id="39367872" class="c"><input type="checkbox" id="c-39367872" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#39366990">parent</a><span>|</span><a href="#39357342">next</a><span>|</span><label class="collapse" for="c-39367872">[-]</label><label class="expand" for="c-39367872">[1 more]</label></div><br/><div class="children"><div class="content">Iteratees are a subset. They don&#x27;t care about any kind of effects except for processing the data (and indicating the current state of how the process is going).<p>They are deliberately simple and for dataprocessing. They not meant&#x2F;suitable for things like e.g. IO whereas the continuation monad is.</div><br/></div></div></div></div><div id="39357342" class="c"><input type="checkbox" id="c-39357342" checked=""/><div class="controls bullet"><span class="by">xgstation</span><span>|</span><a href="#39366990">prev</a><span>|</span><a href="#39357765">next</a><span>|</span><label class="collapse" for="c-39357342">[-]</label><label class="expand" for="c-39357342">[2 more]</label></div><br/><div class="children"><div class="content">I desperately think GPU programming(or specifically CUDA) needs some language level support like coroutine&#x2F;async&#x2F;await to organize the data flow and the executions among different dispatched device side function calls, and more on that to have some synchronize primitives between different blocks&#x2F;warps etc.</div><br/><div id="39367656" class="c"><input type="checkbox" id="c-39367656" checked=""/><div class="controls bullet"><span class="by">mratsim</span><span>|</span><a href="#39357342">parent</a><span>|</span><a href="#39357765">next</a><span>|</span><label class="collapse" for="c-39367656">[-]</label><label class="expand" for="c-39367656">[1 more]</label></div><br/><div class="children"><div class="content">GPU drivers provide an event system:<p>- Cuda: <a href="https:&#x2F;&#x2F;github.com&#x2F;mratsim&#x2F;weave&#x2F;issues&#x2F;133">https:&#x2F;&#x2F;github.com&#x2F;mratsim&#x2F;weave&#x2F;issues&#x2F;133</a>
- OpenCL: <a href="https:&#x2F;&#x2F;github.com&#x2F;mratsim&#x2F;weave&#x2F;issues&#x2F;134">https:&#x2F;&#x2F;github.com&#x2F;mratsim&#x2F;weave&#x2F;issues&#x2F;134</a></div><br/></div></div></div></div><div id="39357765" class="c"><input type="checkbox" id="c-39357765" checked=""/><div class="controls bullet"><span class="by">Gys</span><span>|</span><a href="#39357342">prev</a><span>|</span><a href="#39367555">next</a><span>|</span><label class="collapse" for="c-39357765">[-]</label><label class="expand" for="c-39357765">[1 more]</label></div><br/><div class="children"><div class="content">Very OT:<p>First time that I learn of the .onl TLD. I thought it was a typo but it actually exists for 10 years already: <a href="https:&#x2F;&#x2F;icannwiki.org&#x2F;.onl" rel="nofollow">https:&#x2F;&#x2F;icannwiki.org&#x2F;.onl</a></div><br/></div></div><div id="39367555" class="c"><input type="checkbox" id="c-39367555" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39357765">prev</a><span>|</span><label class="collapse" for="c-39367555">[-]</label><label class="expand" for="c-39367555">[1 more]</label></div><br/><div class="children"><div class="content">...or maybe we should go back to cooperative multitasking with stack switching and just add some familiar language syntax sugar on top ;)<p>IMHO the invisible switch-case code transform only makes sense when stack switching isn&#x27;t available (such as in Javascript or WASM).</div><br/></div></div></div></div></div></div></div></body></html>