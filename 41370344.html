<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724835687388" as="style"/><link rel="stylesheet" href="styles.css?v=1724835687388"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://research.nccgroup.com/2023/02/06/rustproofing-linux-part-1-4-leaking-addresses/">Rustproofing Linux (Part 1/4 Leaking Addresses) (2023)</a>Â <span class="domain">(<a href="https://research.nccgroup.com">research.nccgroup.com</a>)</span></div><div class="subtext"><span>wglb</span> | <span>16 comments</span></div><br/><div><div id="41372635" class="c"><input type="checkbox" id="c-41372635" checked=""/><div class="controls bullet"><span class="by">tetromino_</span><span>|</span><a href="#41377292">next</a><span>|</span><label class="collapse" for="c-41372635">[-]</label><label class="expand" for="c-41372635">[11 more]</label></div><br/><div class="children"><div class="content">Summary: a naive port of a kernel driver from C to Rust can easily introduce information leak vulnerabilities, which in kernel-style C were automatically prevented by preprocessor trickery.</div><br/><div id="41373325" class="c"><input type="checkbox" id="c-41373325" checked=""/><div class="controls bullet"><span class="by">one_even_prime</span><span>|</span><a href="#41372635">parent</a><span>|</span><a href="#41376221">next</a><span>|</span><label class="collapse" for="c-41373325">[-]</label><label class="expand" for="c-41373325">[9 more]</label></div><br/><div class="children"><div class="content">More like: the Linux kernel re-implementation of Rust &quot;print&quot; has a bug that causes it to not adhere to Linux kernel conventions.<p>I&#x27;d expect that now that the bug has been reported, it&#x27;d be fixed by just hashing pointer addresses before printing them.<p>I also expect that &quot;reimplementing X in a different programming language&quot; introduces logic bugs, like the one above, and that those involved have deemed what they get out of it worth the effort of hashing these sort of bugs long term.<p>From the kernel pov, all of these bugs are safety issues, so the article authors are surprised the unsafe keyword is not required to introduce them, but from Rust&#x27;s pov, they are just logic bugs, which safe Rust does not protect against. One of the main challenges those working on Rust in the kernel will have is figuring out how to educate other kernel developers about Rust (what it does and does not protect against, setting the right expectations, etc.). I think these articles are a great step in that direction.</div><br/><div id="41374194" class="c"><input type="checkbox" id="c-41374194" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#41372635">root</a><span>|</span><a href="#41373325">parent</a><span>|</span><a href="#41373739">next</a><span>|</span><label class="collapse" for="c-41374194">[-]</label><label class="expand" for="c-41374194">[1 more]</label></div><br/><div class="children"><div class="content">&gt; article authors are surprised the unsafe keyword is not required<p>The often surprising part of raw pointers to system programmers newly dabbling in Rust is that every operation on them is safe, except for deref. You can freely take addresses and do pointer arithmetic on them without having to deal with unsafe, and only have to tell the compiler that you know what you are doing when you either load or store something through them.</div><br/></div></div><div id="41373739" class="c"><input type="checkbox" id="c-41373739" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41372635">root</a><span>|</span><a href="#41373325">parent</a><span>|</span><a href="#41374194">prev</a><span>|</span><a href="#41376221">next</a><span>|</span><label class="collapse" for="c-41373739">[-]</label><label class="expand" for="c-41373739">[7 more]</label></div><br/><div class="children"><div class="content">&gt; is figuring out how to educate other kernel developers about Rust<p>Why have one class of logic errors when you can have two?</div><br/><div id="41374382" class="c"><input type="checkbox" id="c-41374382" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#41372635">root</a><span>|</span><a href="#41373739">parent</a><span>|</span><a href="#41373980">next</a><span>|</span><label class="collapse" for="c-41374382">[-]</label><label class="expand" for="c-41374382">[3 more]</label></div><br/><div class="children"><div class="content">Why have any? Zero errors is trivially achievable by not writing code.</div><br/><div id="41375222" class="c"><input type="checkbox" id="c-41375222" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#41372635">root</a><span>|</span><a href="#41374382">parent</a><span>|</span><a href="#41376946">next</a><span>|</span><label class="collapse" for="c-41375222">[-]</label><label class="expand" for="c-41375222">[1 more]</label></div><br/><div class="children"><div class="content">What if not writing code is an error in and of itself?</div><br/></div></div><div id="41376946" class="c"><input type="checkbox" id="c-41376946" checked=""/><div class="controls bullet"><span class="by">oneshtein</span><span>|</span><a href="#41372635">root</a><span>|</span><a href="#41374382">parent</a><span>|</span><a href="#41375222">prev</a><span>|</span><a href="#41373980">next</a><span>|</span><label class="collapse" for="c-41376946">[-]</label><label class="expand" for="c-41376946">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s true, &#x2F;bin&#x2F;true.</div><br/></div></div></div></div><div id="41373980" class="c"><input type="checkbox" id="c-41373980" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#41372635">root</a><span>|</span><a href="#41373739">parent</a><span>|</span><a href="#41374382">prev</a><span>|</span><a href="#41376221">next</a><span>|</span><label class="collapse" for="c-41373980">[-]</label><label class="expand" for="c-41373980">[3 more]</label></div><br/><div class="children"><div class="content">Why try to improve anything when you could just keep the original implementation around for forever?</div><br/><div id="41374805" class="c"><input type="checkbox" id="c-41374805" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41372635">root</a><span>|</span><a href="#41373980">parent</a><span>|</span><a href="#41376221">next</a><span>|</span><label class="collapse" for="c-41374805">[-]</label><label class="expand" for="c-41374805">[2 more]</label></div><br/><div class="children"><div class="content">As they say, if it ain&#x27;t broke, don&#x27;t fix it</div><br/><div id="41375379" class="c"><input type="checkbox" id="c-41375379" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#41372635">root</a><span>|</span><a href="#41374805">parent</a><span>|</span><a href="#41376221">next</a><span>|</span><label class="collapse" for="c-41375379">[-]</label><label class="expand" for="c-41375379">[1 more]</label></div><br/><div class="children"><div class="content">The evidence that C is broke is pretty overwhelming at this point.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41376221" class="c"><input type="checkbox" id="c-41376221" checked=""/><div class="controls bullet"><span class="by">sundarurfriend</span><span>|</span><a href="#41372635">parent</a><span>|</span><a href="#41373325">prev</a><span>|</span><a href="#41377292">next</a><span>|</span><label class="collapse" for="c-41376221">[-]</label><label class="expand" for="c-41376221">[1 more]</label></div><br/><div class="children"><div class="content">A higher level summary: A lot of institutional knowledge has been embedded into the C code over the years, sometimes in subtle ways, and a naive port to Rust can introduce security vulnerabilities if some of these subtleties get overlooked.</div><br/></div></div></div></div><div id="41377292" class="c"><input type="checkbox" id="c-41377292" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#41372635">prev</a><span>|</span><a href="#41375079">next</a><span>|</span><label class="collapse" for="c-41377292">[-]</label><label class="expand" for="c-41377292">[1 more]</label></div><br/><div class="children"><div class="content">The hidden unsafety in the pr_ macros (here under the heading Bonus Point for no unsafe) was interesting. I wonder if there&#x27;s anything the compiler could do to detect this kind surprise-unsafety happening, for example a no-unsafe assertion in a source file.<p>Also, why doesn&#x27;t the compiler know by default that the stack allocated struct is &quot;MaybeUninit&quot;?</div><br/></div></div><div id="41375079" class="c"><input type="checkbox" id="c-41375079" checked=""/><div class="controls bullet"><span class="by">iknowstuff</span><span>|</span><a href="#41377292">prev</a><span>|</span><a href="#41372223">next</a><span>|</span><label class="collapse" for="c-41375079">[-]</label><label class="expand" for="c-41375079">[1 more]</label></div><br/><div class="children"><div class="content">This article is written ass backwards.<p>Should start with the last part which explains that they have the WritableToBytes trait - implementing it has to be marked unsafe because it has an explicit invariant: no padding.<p>When itâs not implemented on a type, you canât pass it to the writer unless you do what they did and use two pointer casts within an unsafe block. So you donât do that. Instead, you write the initialized parts of the struct individually. Theyâll probably add a derive macro to make implementing something a safe equivalent of the trait trivial.</div><br/></div></div><div id="41372223" class="c"><input type="checkbox" id="c-41372223" checked=""/><div class="controls bullet"><span class="by">smj-edison</span><span>|</span><a href="#41375079">prev</a><span>|</span><a href="#41372173">next</a><span>|</span><label class="collapse" for="c-41372223">[-]</label><label class="expand" for="c-41372223">[1 more]</label></div><br/><div class="children"><div class="content">I think &quot;pitfalls of porting Linux C to Rust&quot; would be a more descriptive title, if verbose.</div><br/></div></div></div></div></div></div></div></body></html>