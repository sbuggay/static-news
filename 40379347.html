<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716022854490" as="style"/><link rel="stylesheet" href="styles.css?v=1716022854490"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://domluna.com/blog/tiny-binary-rag">Exact binary vector search for RAG in 100 lines of Julia</a> <span class="domain">(<a href="https://domluna.com">domluna.com</a>)</span></div><div class="subtext"><span>lunaticd</span> | <span>20 comments</span></div><br/><div><div id="40395655" class="c"><input type="checkbox" id="c-40395655" checked=""/><div class="controls bullet"><span class="by">miguelraz</span><span>|</span><a href="#40394809">next</a><span>|</span><label class="collapse" for="c-40395655">[-]</label><label class="expand" for="c-40395655">[3 more]</label></div><br/><div class="children"><div class="content">Dom! Fellow Julian here!<p>I loved this post &lt;3 The hamming distance is one of my favorite demos of the conciseness of Julia:<p>hamming_distance(s1, s2) = mapreduce(!=, +, s1, s2)<p>I&#x27;m a bit swamped at the moment but I&#x27;ll a response article later - they&#x27;re still some juicy perf on the table here.<p>Thanks for the post, such a good showcase.</div><br/><div id="40395951" class="c"><input type="checkbox" id="c-40395951" checked=""/><div class="controls bullet"><span class="by">lunaticd</span><span>|</span><a href="#40395655">parent</a><span>|</span><a href="#40394809">next</a><span>|</span><label class="collapse" for="c-40395951">[-]</label><label class="expand" for="c-40395951">[2 more]</label></div><br/><div class="children"><div class="content">please make it even faster!</div><br/><div id="40396852" class="c"><input type="checkbox" id="c-40396852" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#40395655">root</a><span>|</span><a href="#40395951">parent</a><span>|</span><a href="#40394809">next</a><span>|</span><label class="collapse" for="c-40396852">[-]</label><label class="expand" for="c-40396852">[1 more]</label></div><br/><div class="children"><div class="content">And this right here is why the Julia crowd is awesome...<p>A great article inspires everyone to participate in the fun.<p>Cheers =3</div><br/></div></div></div></div></div></div><div id="40394809" class="c"><input type="checkbox" id="c-40394809" checked=""/><div class="controls bullet"><span class="by">klowrey</span><span>|</span><a href="#40395655">prev</a><span>|</span><a href="#40394607">next</a><span>|</span><label class="collapse" for="c-40394809">[-]</label><label class="expand" for="c-40394809">[2 more]</label></div><br/><div class="children"><div class="content">Why not use the built in BitVector type that has specialized code for things like xor?<p><a href="https:&#x2F;&#x2F;docs.julialang.org&#x2F;en&#x2F;v1&#x2F;base&#x2F;arrays&#x2F;#Base.BitArray" rel="nofollow">https:&#x2F;&#x2F;docs.julialang.org&#x2F;en&#x2F;v1&#x2F;base&#x2F;arrays&#x2F;#Base.BitArray</a></div><br/><div id="40395944" class="c"><input type="checkbox" id="c-40395944" checked=""/><div class="controls bullet"><span class="by">lunaticd</span><span>|</span><a href="#40394809">parent</a><span>|</span><a href="#40394607">next</a><span>|</span><label class="collapse" for="c-40395944">[-]</label><label class="expand" for="c-40395944">[1 more]</label></div><br/><div class="children"><div class="content">it doesn&#x27;t seem to have better support for things like xor and count_ones. I believe the main use case is comparisons.</div><br/></div></div></div></div><div id="40394607" class="c"><input type="checkbox" id="c-40394607" checked=""/><div class="controls bullet"><span class="by">mik1998</span><span>|</span><a href="#40394809">prev</a><span>|</span><a href="#40397007">next</a><span>|</span><label class="collapse" for="c-40394607">[-]</label><label class="expand" for="c-40394607">[7 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    for i in 0:7
        c += (r &gt;&gt; i) &amp; 1
    end
</code></pre>
This is just popcnt, surely Julia has a built in for that.</div><br/><div id="40394882" class="c"><input type="checkbox" id="c-40394882" checked=""/><div class="controls bullet"><span class="by">borodi</span><span>|</span><a href="#40394607">parent</a><span>|</span><a href="#40395381">next</a><span>|</span><label class="collapse" for="c-40394882">[-]</label><label class="expand" for="c-40394882">[1 more]</label></div><br/><div class="children"><div class="content">There is, it&#x27;s called count_ones. Though I wouldn&#x27;t be surprised if LLVM could maybe optimize some of these loops into a popcnt, but I&#x27;m sure it would be brittle</div><br/></div></div><div id="40395381" class="c"><input type="checkbox" id="c-40395381" checked=""/><div class="controls bullet"><span class="by">lunaticd</span><span>|</span><a href="#40394607">parent</a><span>|</span><a href="#40394882">prev</a><span>|</span><a href="#40394681">next</a><span>|</span><label class="collapse" for="c-40395381">[-]</label><label class="expand" for="c-40395381">[3 more]</label></div><br/><div class="children"><div class="content">author here. I thought there might be a machine instruction for this but wasn&#x27;t sure, I also didn&#x27;t know Julia had a count_ones that counted the 1s.<p>Thanks! With this the timings are even faster. I&#x27;ll update the post.</div><br/><div id="40395736" class="c"><input type="checkbox" id="c-40395736" checked=""/><div class="controls bullet"><span class="by">lunaticd</span><span>|</span><a href="#40394607">root</a><span>|</span><a href="#40395381">parent</a><span>|</span><a href="#40395494">next</a><span>|</span><label class="collapse" for="c-40395736">[-]</label><label class="expand" for="c-40395736">[1 more]</label></div><br/><div class="children"><div class="content">julia&gt; @code_typed hamming_distance(Int8(33), Int8(125))
CodeInfo(
1 ─ %1 = Base.xor_int(x1, x2)::Int8
│   %2 = Base.ctpop_int(%1)::Int8
│   %3 = Base.sext_int(Int64, %2)::Int64
│        nothing::Nothing
└──      return %3
) =&gt; Int64<p>julia&gt; @code_llvm hamming_distance(Int8(33), Int8(125))
; Function Signature: hamming_distance(Int8, Int8)
;  @ &#x2F;Users&#x2F;lunaticd&#x2F;code&#x2F;tiny-binary-rag&#x2F;rag.jl:13 within `hamming_distance`
define i64 @julia_hamming_distance_16366(i8 signext %&quot;x1::Int8&quot;, i8 signext %&quot;x2::Int8&quot;) #0 {
top:
;  @ &#x2F;Users&#x2F;lunaticd&#x2F;code&#x2F;tiny-binary-rag&#x2F;rag.jl:14 within `hamming_distance`
; ┌ @ int.jl:373 within `xor`
   %0 = xor i8 %&quot;x2::Int8&quot;, %&quot;x1::Int8&quot;
; └
; ┌ @ int.jl:415 within `count_ones`
   %1 = call i8 @llvm.ctpop.i8(i8 %0)
; │┌ @ int.jl:549 within `rem`
    %2 = zext i8 %1 to i64
; └└
  ret i64 %2
}<p>it lowers to the machine instruction now.<p>I also tried 8 Int64s vs 64 Int8s and it doesn&#x27;t seem to make a difference when doing the search.<p>EDIT: apologize for the formatting</div><br/></div></div><div id="40395494" class="c"><input type="checkbox" id="c-40395494" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#40394607">root</a><span>|</span><a href="#40395381">parent</a><span>|</span><a href="#40395736">prev</a><span>|</span><a href="#40394681">next</a><span>|</span><label class="collapse" for="c-40395494">[-]</label><label class="expand" for="c-40395494">[1 more]</label></div><br/><div class="children"><div class="content">I had Opus translate your code to Rust<p><pre><code>    fn hamming_distance_u8(x1: u8, x2: u8) -&gt; usize {
        (x1 ^ x2).count_ones() as usize
    }</code></pre></div><br/></div></div></div></div><div id="40394681" class="c"><input type="checkbox" id="c-40394681" checked=""/><div class="controls bullet"><span class="by">ummonk</span><span>|</span><a href="#40394607">parent</a><span>|</span><a href="#40395381">prev</a><span>|</span><a href="#40397007">next</a><span>|</span><label class="collapse" for="c-40394681">[-]</label><label class="expand" for="c-40394681">[2 more]</label></div><br/><div class="children"><div class="content">From what I&#x27;ve heard it&#x27;s actually faster to create a 256 byte lookup table than to use popcnt.</div><br/><div id="40394711" class="c"><input type="checkbox" id="c-40394711" checked=""/><div class="controls bullet"><span class="by">mik1998</span><span>|</span><a href="#40394607">root</a><span>|</span><a href="#40394681">parent</a><span>|</span><a href="#40397007">next</a><span>|</span><label class="collapse" for="c-40394711">[-]</label><label class="expand" for="c-40394711">[1 more]</label></div><br/><div class="children"><div class="content">It used to be pretty bad on old intel processors but nowadays it should be faster than an L1 fetch.</div><br/></div></div></div></div></div></div><div id="40397007" class="c"><input type="checkbox" id="c-40397007" checked=""/><div class="controls bullet"><span class="by">horsellama</span><span>|</span><a href="#40394607">prev</a><span>|</span><a href="#40394766">next</a><span>|</span><label class="collapse" for="c-40397007">[-]</label><label class="expand" for="c-40397007">[1 more]</label></div><br/><div class="children"><div class="content">Nice speed up!<p>Have you tried to benchmark also this heap implementation?<p><a href="https:&#x2F;&#x2F;juliacollections.github.io&#x2F;DataStructures.jl&#x2F;latest&#x2F;heaps&#x2F;" rel="nofollow">https:&#x2F;&#x2F;juliacollections.github.io&#x2F;DataStructures.jl&#x2F;latest&#x2F;...</a></div><br/></div></div><div id="40394766" class="c"><input type="checkbox" id="c-40394766" checked=""/><div class="controls bullet"><span class="by">floobertoober</span><span>|</span><a href="#40397007">prev</a><span>|</span><a href="#40395080">next</a><span>|</span><label class="collapse" for="c-40394766">[-]</label><label class="expand" for="c-40394766">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what is meant by &quot;exact&quot; here - do they describe their binarisation process at all? This seems more like an XOR benchmark than a rag benchmark, no mention of recall or other relevant performance metrics</div><br/><div id="40394933" class="c"><input type="checkbox" id="c-40394933" checked=""/><div class="controls bullet"><span class="by">jjnoakes</span><span>|</span><a href="#40394766">parent</a><span>|</span><a href="#40395387">next</a><span>|</span><label class="collapse" for="c-40394933">[-]</label><label class="expand" for="c-40394933">[1 more]</label></div><br/><div class="children"><div class="content">Some (not all) of your questions may be answered by the linked article near the top of the submitted article, which goes into more detail about how much is lost quantizing to 1 bit (and 1 byte): <a href="https:&#x2F;&#x2F;huggingface.co&#x2F;blog&#x2F;embedding-quantization" rel="nofollow">https:&#x2F;&#x2F;huggingface.co&#x2F;blog&#x2F;embedding-quantization</a></div><br/></div></div><div id="40395387" class="c"><input type="checkbox" id="c-40395387" checked=""/><div class="controls bullet"><span class="by">lunaticd</span><span>|</span><a href="#40394766">parent</a><span>|</span><a href="#40394933">prev</a><span>|</span><a href="#40395080">next</a><span>|</span><label class="collapse" for="c-40395387">[-]</label><label class="expand" for="c-40395387">[1 more]</label></div><br/><div class="children"><div class="content">exact in this case means that all the vectors are compared against the query vector. Where as other search methods such as HNSW are approximate searches.</div><br/></div></div></div></div><div id="40395080" class="c"><input type="checkbox" id="c-40395080" checked=""/><div class="controls bullet"><span class="by">fn-mote</span><span>|</span><a href="#40394766">prev</a><span>|</span><a href="#40396303">next</a><span>|</span><label class="collapse" for="c-40395080">[-]</label><label class="expand" for="c-40395080">[1 more]</label></div><br/><div class="children"><div class="content">For those like me who are not familiar with the field... The article assumes you know the entire context - as far as I could see there is no explanation of any part except the technical details.<p>RAG = Retrieval-Augmented Generation<p>The field is machine learning. Retrieval = get relevant documents. Generation = create answer for user (based on the docs).</div><br/></div></div><div id="40396303" class="c"><input type="checkbox" id="c-40396303" checked=""/><div class="controls bullet"><span class="by">sdan</span><span>|</span><a href="#40395080">prev</a><span>|</span><a href="#40396259">next</a><span>|</span><label class="collapse" for="c-40396303">[-]</label><label class="expand" for="c-40396303">[1 more]</label></div><br/><div class="children"><div class="content">cool to binary vector search -- I made something similar with numpy in python: <a href="https:&#x2F;&#x2F;github.com&#x2F;sdan&#x2F;vlite">https:&#x2F;&#x2F;github.com&#x2F;sdan&#x2F;vlite</a></div><br/></div></div></div></div></div></div></div></body></html>