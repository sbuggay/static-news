<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687510863303" as="style"/><link rel="stylesheet" href="styles.css?v=1687510863303"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://twitter.com/tianyin_xu/status/1671857283263868930">eBPF Verification Is Untenable</a> <span class="domain">(<a href="https://twitter.com">twitter.com</a>)</span></div><div class="subtext"><span>williamallthing</span> | <span>81 comments</span></div><br/><div><div id="36440205" class="c"><input type="checkbox" id="c-36440205" checked=""/><div class="controls bullet"><span class="by">wzdd</span><span>|</span><a href="#36439175">next</a><span>|</span><label class="collapse" for="c-36440205">[-]</label><label class="expand" for="c-36440205">[20 more]</label></div><br/><div class="children"><div class="content">This is weird.<p>1. Instead of having the kernel verify the program about to be installed at installation time, they rely on a trusted compiler and having the kernel perform signature validation. This means that the kernel is relying on a userspace component to enforce kernel-level safety guarantees, adds another level of coupling (via key infrastructure) between the kernel and a particular version of the Rust compiler, and if someone can get the signing key then the kernel will run their signed code no problem.<p>2. The Rust compiler famously prevents various memory safety correctness bugs, but does not enforce other important parts of eBPF such as termination. The proposed solution is basically just to have a timeout instead. This moves checking for bugs from load time (with the verifier) to runtime, which means you will not know you have a buggy eBPF program until you actually hit the bug and it&#x27;s terminated. Timeouts are strictly worse than termination checking because they are always either too long or too short.<p>3. Their major problem is with &quot;escape hatches&quot;, kernel code which eBPF programs call out to. They show that various escape hatches can be eliminated or simplified. However they don&#x27;t have a plan to eliminate all escape hatches, and don&#x27;t even demonstrate that their technique would eliminate particularly problematic escape hatches.</div><br/><div id="36440485" class="c"><input type="checkbox" id="c-36440485" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440205">parent</a><span>|</span><a href="#36444278">next</a><span>|</span><label class="collapse" for="c-36440485">[-]</label><label class="expand" for="c-36440485">[4 more]</label></div><br/><div class="children"><div class="content">&gt; 1. Instead of having the kernel verify the program about to be installed at installation time, they rely on a trusted compiler and having the kernel perform signature validation. This means that the kernel is relying on a userspace component to enforce kernel-level safety guarantees, adds another level of coupling (via key infrastructure) between the kernel and a particular version of the Rust compiler, and if someone can get the signing key then the kernel will run their signed code no problem.<p>FWIW I&#x27;m pretty sure this is how Microsoft does it. Verifier is in userland and signs programs post-verification. This keeps the attack surface unprivileged and is a great idea <i>if</i> you couple your Kernel to your userland and <i>if</i> your operating system has a notion of process protection - Linux doesn&#x27;t do either.</div><br/><div id="36441252" class="c"><input type="checkbox" id="c-36441252" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36440485">parent</a><span>|</span><a href="#36444278">next</a><span>|</span><label class="collapse" for="c-36441252">[-]</label><label class="expand" for="c-36441252">[3 more]</label></div><br/><div class="children"><div class="content">Driver Verifier? That’s not intended to prove the code under test secure, only to hopefully show that it’s not complete crap in well-known ways. Even a signed driver is still trusted code and requires administrator privileges to install. I guess the closest Linux counterpart would be a distro maintainer running a hardware vendor’s out-of-tree module under KASAN and, if it passes, signing the package with their PGP key.<p>But none of that is intended or able to check the module (resp. driver) is not gimmeroot.ko (resp. gimmesystem.dll)—that’s left to humans inspecting the source (resp. thoughts and prayers[1]). On the other hand, the eBPF VM absolutely is intended to be able to load anything any unprivileged user throws at it and emerge unscathed.<p>It’s not precisely essential that a kernel have this capability, but if one is to have it, restricting the allowable code to a predetermined vendor-approved set defeats most of the point. (The authors propose that a userspace compiler running <i>on the user’s computer</i> be allowed to extend it, as I understood them.)<p>[1] <a href="https:&#x2F;&#x2F;www.zdnet.com&#x2F;article&#x2F;these-hackers-used-microsoft-signed-malicious-drivers-to-further-their-ransomware-attacks&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.zdnet.com&#x2F;article&#x2F;these-hackers-used-microsoft-s...</a></div><br/><div id="36441431" class="c"><input type="checkbox" id="c-36441431" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36441252">parent</a><span>|</span><a href="#36444278">next</a><span>|</span><label class="collapse" for="c-36441431">[-]</label><label class="expand" for="c-36441431">[2 more]</label></div><br/><div class="children"><div class="content">No, not driver verifier. <a href="https:&#x2F;&#x2F;github.com&#x2F;vbpf&#x2F;ebpf-verifier">https:&#x2F;&#x2F;github.com&#x2F;vbpf&#x2F;ebpf-verifier</a></div><br/><div id="36443216" class="c"><input type="checkbox" id="c-36443216" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36441431">parent</a><span>|</span><a href="#36444278">next</a><span>|</span><label class="collapse" for="c-36443216">[-]</label><label class="expand" for="c-36443216">[1 more]</label></div><br/><div class="children"><div class="content">This link is about a proposed new eBPF verifier for the Linux kernel that doesn&#x27;t use signing. As a research project it is not integrated to the kernel, but their plan does not involve trusting user space (instead they suggest doing the heavy lifting of the verification in user space and provide a <i>proof of safety</i> that the kernel checks, which seems sensible to me).<p>I believe you meant to link <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;ebpf-for-windows&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;ebpf-for-windows&#x2F;</a> instead (discussed on HN recently) which is an implementation by Microsoft using the above research project that indeed does not follow the suggestion from the authors of the research project to use validation and does require trusting user space.</div><br/></div></div></div></div></div></div></div></div><div id="36440433" class="c"><input type="checkbox" id="c-36440433" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#36440205">parent</a><span>|</span><a href="#36444278">prev</a><span>|</span><a href="#36440789">next</a><span>|</span><label class="collapse" for="c-36440433">[-]</label><label class="expand" for="c-36440433">[6 more]</label></div><br/><div class="children"><div class="content">Your point 1 is the elephant herd in the room. If I were a paranoid person, I would think it’s by design - build in a way to compromise a system retroactively.</div><br/><div id="36440885" class="c"><input type="checkbox" id="c-36440885" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36440433">parent</a><span>|</span><a href="#36440587">prev</a><span>|</span><a href="#36440789">next</a><span>|</span><label class="collapse" for="c-36440885">[-]</label><label class="expand" for="c-36440885">[3 more]</label></div><br/><div class="children"><div class="content">That makes no sense</div><br/><div id="36441312" class="c"><input type="checkbox" id="c-36441312" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36440885">parent</a><span>|</span><a href="#36440789">next</a><span>|</span><label class="collapse" for="c-36441312">[-]</label><label class="expand" for="c-36441312">[2 more]</label></div><br/><div class="children"><div class="content">You should read Ken Thompson&#x27;s &quot;Reflections on trusting trust&quot;. Outsourcing security to a tool which you have to blindly trust, and can&#x27;t verify is very, very dangerous.</div><br/><div id="36441419" class="c"><input type="checkbox" id="c-36441419" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36441312">parent</a><span>|</span><a href="#36440789">next</a><span>|</span><label class="collapse" for="c-36441419">[-]</label><label class="expand" for="c-36441419">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve obviously misunderstood the proposal - there&#x27;s nothing about this that is &quot;blind trust&quot; at all.</div><br/></div></div></div></div></div></div></div></div><div id="36440789" class="c"><input type="checkbox" id="c-36440789" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#36440205">parent</a><span>|</span><a href="#36440433">prev</a><span>|</span><a href="#36441043">next</a><span>|</span><label class="collapse" for="c-36440789">[-]</label><label class="expand" for="c-36440789">[7 more]</label></div><br/><div class="children"><div class="content">The escape hatches are unfortunately core to how eBPF in the kernel can work at the moment.  It keeps the kernel from having to provide every possible piece of data the program might need as an argument, and provides a lot of assists that otherwise wouldn&#x27;t be verifiable in general code.  Stuff like string operations that would cut into the max 4096 instruction count.</div><br/><div id="36440857" class="c"><input type="checkbox" id="c-36440857" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36440789">parent</a><span>|</span><a href="#36441043">next</a><span>|</span><label class="collapse" for="c-36440857">[-]</label><label class="expand" for="c-36440857">[6 more]</label></div><br/><div class="children"><div class="content">For the most part, the kernel doesn&#x27;t provide generic string processing helpers. Most helpers are there to form the basis for specific eBPF integration points (the majority are packet and socket handling tools).<p><a href="https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;bpf-helpers.7.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;bpf-helpers.7.html</a></div><br/><div id="36443115" class="c"><input type="checkbox" id="c-36443115" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36440857">parent</a><span>|</span><a href="#36441043">next</a><span>|</span><label class="collapse" for="c-36443115">[-]</label><label class="expand" for="c-36443115">[5 more]</label></div><br/><div class="children"><div class="content">The kernel provides quite a few string processing helpers; I&#x27;m not sure why they&#x27;re not documented.  Perhaps the purpose of the document is to highlight bpf specific functionality rather than underlying runtime helpers?<p>You can see them listed here: <a href="https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;linux&#x2F;latest&#x2F;source&#x2F;kernel&#x2F;bpf&#x2F;helpers.c#L439" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;linux&#x2F;latest&#x2F;source&#x2F;kernel&#x2F;bpf&#x2F;he...</a><p>And my point in highlighting them in this discussion was to get one to consider how of trap outs to the kernel are sort of fundamental.  You get 4096 instructions to execute before you&#x27;re cut off by the kernel (albeit statically).  Given that, say, PATH_MAX is 32768, then you simply don&#x27;t have enough compute time available to process certain strings you&#x27;d expect some bpf filters to be able to handle.<p>So basically I just wanted to hit home that some raw computation expected of bpf is incompatible with it&#x27;s current verification model and at the very least extremely deep changes to bpf would need to occur to get rid of helpers.</div><br/><div id="36443611" class="c"><input type="checkbox" id="c-36443611" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36443115">parent</a><span>|</span><a href="#36441043">next</a><span>|</span><label class="collapse" for="c-36443611">[-]</label><label class="expand" for="c-36443611">[4 more]</label></div><br/><div class="children"><div class="content">This a link to string-&gt;integer conversion and comparison, and nothing else.</div><br/><div id="36443787" class="c"><input type="checkbox" id="c-36443787" checked=""/><div class="controls bullet"><span class="by">ongy</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36443611">parent</a><span>|</span><a href="#36443734">next</a><span>|</span><label class="collapse" for="c-36443787">[-]</label><label class="expand" for="c-36443787">[2 more]</label></div><br/><div class="children"><div class="content">that&#x27;s what GP said.<p>They are semantically simple string operations whose computational complexity scales with string length.
Near unbound string lengths would exhaust the time (somewhat aproximated by instruction) budget of eBPF applications doing even a single one.</div><br/><div id="36443874" class="c"><input type="checkbox" id="c-36443874" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36443787">parent</a><span>|</span><a href="#36443734">next</a><span>|</span><label class="collapse" for="c-36443874">[-]</label><label class="expand" for="c-36443874">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s <i>all</i> that&#x27;s there. String-integer conversion and comparison.</div><br/></div></div></div></div><div id="36443734" class="c"><input type="checkbox" id="c-36443734" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#36440205">root</a><span>|</span><a href="#36443611">parent</a><span>|</span><a href="#36443787">prev</a><span>|</span><a href="#36441043">next</a><span>|</span><label class="collapse" for="c-36443734">[-]</label><label class="expand" for="c-36443734">[1 more]</label></div><br/><div class="children"><div class="content">So &quot;generic string processing helpers&quot; provided by the kernel?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36441043" class="c"><input type="checkbox" id="c-36441043" checked=""/><div class="controls bullet"><span class="by">skywhopper</span><span>|</span><a href="#36440205">parent</a><span>|</span><a href="#36440789">prev</a><span>|</span><a href="#36439175">next</a><span>|</span><label class="collapse" for="c-36441043">[-]</label><label class="expand" for="c-36441043">[1 more]</label></div><br/><div class="children"><div class="content">In re 1, the system operator could configure the kernel to trust their signing key, and build the extensions themselves, which is still highly complex but would minimize the risk of a general compromise.<p>That said, I agree in general that this approach is mostly going backwards and fails to address the core risks. It’s also important to push back on the Rust-as-security-panacea meme. Rust prevents a certain class of bugs, but it doesn’t ensure reliable operation.</div><br/></div></div></div></div><div id="36439175" class="c"><input type="checkbox" id="c-36439175" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36440205">prev</a><span>|</span><a href="#36440601">next</a><span>|</span><label class="collapse" for="c-36439175">[-]</label><label class="expand" for="c-36439175">[7 more]</label></div><br/><div class="children"><div class="content">Hm. Doesn’t look viable to me.<p>I’m not against language-based security, proof-carrying code, and all that, but I have less than perfect confidence that the Rust compiler currently is or will soon be sound enough to be secure against actively hostile code—AFAIU the language designers haven’t even written down their core calculus, let alone proven it sound. Putting the entirety of the Rust compiler (including, at least for now, millions of lines of C++ from LLVM) in the TCB of your system also feels less than inspiring.<p>There’s also the part where if you want to instrument the kernel with something <i>other</i> than Rust but still relatively powerful—I dunno, Ada—then you’re looking at putting the compiler for <i>that</i> in the TCB, too; you benefit from none of the verification work. Sound, tractable, and expressive type systems are usually fairly isolated in design space, so source-to-source translation of arbitrary programs is impossible most of the time.<p>Uploading System F (e.g. Dhall) or CoC to the kernel I could see—except for the tiny problem of memory management of course—but uploading <i>Rust</i>, even precompiled, I honestly can’t.</div><br/><div id="36440556" class="c"><input type="checkbox" id="c-36440556" checked=""/><div class="controls bullet"><span class="by">DelightOne</span><span>|</span><a href="#36439175">parent</a><span>|</span><a href="#36440938">next</a><span>|</span><label class="collapse" for="c-36440556">[-]</label><label class="expand" for="c-36440556">[3 more]</label></div><br/><div class="children"><div class="content">&gt; to be secure against actively hostile code<p>Was that a requirement for the predecessor of eBPF: Custom kernel modules?</div><br/><div id="36440662" class="c"><input type="checkbox" id="c-36440662" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36439175">root</a><span>|</span><a href="#36440556">parent</a><span>|</span><a href="#36440714">next</a><span>|</span><label class="collapse" for="c-36440662">[-]</label><label class="expand" for="c-36440662">[1 more]</label></div><br/><div class="children"><div class="content">Kernel modules require root privileges to load and the Linux kernel&#x27;s philosophy (pre user namespaces lollllll) was that root -&gt; kernel privesc didn&#x27;t matter.</div><br/></div></div><div id="36440714" class="c"><input type="checkbox" id="c-36440714" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36439175">root</a><span>|</span><a href="#36440556">parent</a><span>|</span><a href="#36440662">prev</a><span>|</span><a href="#36440938">next</a><span>|</span><label class="collapse" for="c-36440714">[-]</label><label class="expand" for="c-36440714">[1 more]</label></div><br/><div class="children"><div class="content">eBPF is not a replacement for the general concept of custom kernel modules.</div><br/></div></div></div></div><div id="36440938" class="c"><input type="checkbox" id="c-36440938" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#36439175">parent</a><span>|</span><a href="#36440556">prev</a><span>|</span><a href="#36440601">next</a><span>|</span><label class="collapse" for="c-36440938">[-]</label><label class="expand" for="c-36440938">[3 more]</label></div><br/><div class="children"><div class="content">OK then!  Back to C it is I guess.  More seriously, we&#x27;re talking about the Linux kernel here: it&#x27;s written in C, and there&#x27;s some momentum to write new code in Rust.  You&#x27;re asking for the moon, but you may have to settle for a picture of it.</div><br/><div id="36441055" class="c"><input type="checkbox" id="c-36441055" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#36439175">root</a><span>|</span><a href="#36440938">parent</a><span>|</span><a href="#36441082">next</a><span>|</span><label class="collapse" for="c-36441055">[-]</label><label class="expand" for="c-36441055">[1 more]</label></div><br/><div class="children"><div class="content">I’m not talking about writing parts of the kernel in Rust. I‘m not even talking about using Rust inside the eBPF implementation specifically. In either case that’s replacing C with Rust, and if that’s what you want, sure, knock yourself out. In the spirit of full disclosure, I’ll admit to not being a fan, but it’s still entirely plausible and one can seriously argue it’d be an improvement.<p>But what TFA talks about amounts to replacing the eBPF verifier with (a blessed userspace version of) the Rust typechecker—dragging the rest of the compiler along for the ride—and that just feels like a downgrade in almost every respect. It’s humongous, it requires strange contortions due to not fitting in the kernel, it implements a comparatively very complicated spec, that spec is not written down, etc. The eBPF machine is not perfect, especially (as the authors point out) when you account for the “helpers“, but it mostly avoids these downsides. It’s not the moon—it’s already there.</div><br/></div></div><div id="36441082" class="c"><input type="checkbox" id="c-36441082" checked=""/><div class="controls bullet"><span class="by">lcvw</span><span>|</span><a href="#36439175">root</a><span>|</span><a href="#36440938">parent</a><span>|</span><a href="#36441055">prev</a><span>|</span><a href="#36440601">next</a><span>|</span><label class="collapse" for="c-36441082">[-]</label><label class="expand" for="c-36441082">[1 more]</label></div><br/><div class="children"><div class="content">You can write ebpf programs in rust. Bpftrace generates programs from an awk like language, you can make the program however you want. Solana does it with rust, I don’t know what it gains you though given the verifier protecting you from most of the pitfalls of C.</div><br/></div></div></div></div></div></div><div id="36440601" class="c"><input type="checkbox" id="c-36440601" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36439175">prev</a><span>|</span><a href="#36440366">next</a><span>|</span><label class="collapse" for="c-36440601">[-]</label><label class="expand" for="c-36440601">[3 more]</label></div><br/><div class="children"><div class="content">First off, I kinda skimmed this.<p>So I think the critical thing here is that verification is <i>not enough</i>. It has to be the critical thing, because the implementation in the kernel might suck but Microsoft has shown that it&#x27;s possible to build a powerful eBPF verifier that isn&#x27;t a hacky mess.<p>The main issue is seemingly these helper functions. The position is that even a perfectly verified program won&#x27;t be safe because of them. To me, the situation makes me think &quot;so why are we allowing these helper functions?&quot;. The suggestion is, among other things, to replace these helpers with Rust code. But couldn&#x27;t we just have the helpers not suck to begin with?<p>Using the Rust compiler as a sort of safety oracle also ignores the fact that rustc has <i>numerous</i> problems that can lead to unsafe code without `unsafe` (and tbh I don&#x27;t really see the project prioritizing these cases because it&#x27;s just not a meaningful problem for the typical rust threat model). They sort of address this but not very well imo - timers and runtime mitigations aren&#x27;t ideal.<p>I think what might make much more sense is to instead have the eBPF Virtual Machine (and verifier) written in Rust, including all helper functions, but to still execute pure, verified ebpf within it, using a verifier that&#x27;s been built in a way that&#x27;s actually sound.<p>1. The verifier attack surface goes down because it&#x27;s Rust. I think that removes the need to keep it in userland, which would fly for Windows &#x2F; BSD but not Linux.<p>2. Helpers are in Rust so they&#x27;re at least saf<i>er</i> - I feel like this addresses a (the?) major priority in the paper. Based on the paper&#x27;s notes about implementing helpers in rust requiring no unsafe, it&#x27;s probably safe to say that the verifier and helpers being in Rust would solve a lot of problems without requiring eBPF programs to be in Rust (and good news, Rust programs can expose a C API).<p>3. We don&#x27;t throw out the baby with the bath water. A verified program is a cool thing to have. I would rather keep verification.</div><br/><div id="36441009" class="c"><input type="checkbox" id="c-36441009" checked=""/><div class="controls bullet"><span class="by">lcvw</span><span>|</span><a href="#36440601">parent</a><span>|</span><a href="#36440366">next</a><span>|</span><label class="collapse" for="c-36441009">[-]</label><label class="expand" for="c-36441009">[2 more]</label></div><br/><div class="children"><div class="content">It’s worth noting the verifier doesn’t verify C code, it verifies the compiled ebpf bytecode. You can generate that bytecode from rust (the solana cryptocurrency does this) but you still need to verify the actual instructions since someone can just write whatever they want by hand.</div><br/><div id="36441427" class="c"><input type="checkbox" id="c-36441427" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440601">root</a><span>|</span><a href="#36441009">parent</a><span>|</span><a href="#36440366">next</a><span>|</span><label class="collapse" for="c-36441427">[-]</label><label class="expand" for="c-36441427">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m suggesting that the ebpf code still be verified and that the only rust code used is to implement the verifier and the virtual machine itself.</div><br/></div></div></div></div></div></div><div id="36440366" class="c"><input type="checkbox" id="c-36440366" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#36440601">prev</a><span>|</span><a href="#36440692">next</a><span>|</span><label class="collapse" for="c-36440366">[-]</label><label class="expand" for="c-36440366">[5 more]</label></div><br/><div class="children"><div class="content">I hope no one tries to use the rust &quot;safety&quot; guarantees for security guards.<p>They are designed to prevent bugs not intentional abuse.<p>If perfect without bugs they theoretically might be usable for security guards, but it&#x27;s not where priorities lies when it comes to bug fixes and design.<p>And people mistaking rust safety + no unsafe lint for &quot;security against evil code&quot; could be long term quite an issue for rust in various subtle ways (not technical problems put people problems).</div><br/><div id="36441017" class="c"><input type="checkbox" id="c-36441017" checked=""/><div class="controls bullet"><span class="by">zyedidia</span><span>|</span><a href="#36440366">parent</a><span>|</span><a href="#36440893">next</a><span>|</span><label class="collapse" for="c-36441017">[-]</label><label class="expand" for="c-36441017">[3 more]</label></div><br/><div class="children"><div class="content">I agree -- relying on Safe Rust&#x27;s &quot;guarantees&quot; for security purposes is very likely to be problematic. To make the reasons concrete: for the last 4 years rustc has had a bug that allows writing transmute (arbitrary type conversion) without the use of unsafe: <a href="https:&#x2F;&#x2F;zyedidia.github.io&#x2F;blog&#x2F;posts&#x2F;5-safe-transmute&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;zyedidia.github.io&#x2F;blog&#x2F;posts&#x2F;5-safe-transmute&#x2F;</a>. This is one of the 77 current open unsoundness bugs on the Rust issue tracker. To make this tenable you would probably have to use a separate language -- maybe some formally-verified minimal Rust-like language, and with different priorities from a people perspective.</div><br/><div id="36441047" class="c"><input type="checkbox" id="c-36441047" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#36440366">root</a><span>|</span><a href="#36441017">parent</a><span>|</span><a href="#36440893">next</a><span>|</span><label class="collapse" for="c-36441047">[-]</label><label class="expand" for="c-36441047">[2 more]</label></div><br/><div class="children"><div class="content">I am a bit skeptical this is a workable approach long term, but there is a project based on an attempt to enumerate all of Rust&#x27;s soundness holes and use Rust&#x27;s compiler infrastructure to detect and forbid them. They think that by erring on the side of forbidding valid code this is feasible. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35501065">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35501065</a></div><br/><div id="36443275" class="c"><input type="checkbox" id="c-36443275" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#36440366">root</a><span>|</span><a href="#36441047">parent</a><span>|</span><a href="#36440893">next</a><span>|</span><label class="collapse" for="c-36443275">[-]</label><label class="expand" for="c-36443275">[1 more]</label></div><br/><div class="children"><div class="content">From the horse&#x27;s mouth (article of the linked HN post):<p>&gt; PL&#x2F;Rust contains a small set of lints to block what the developers have deemed the most egregious &quot;I-Unsound&quot; Rust bugs.
&gt; [...]
&gt; Note that this is done on a best-effort basis, and does not provide a strong level of security — it&#x27;s not a sandbox, and as such, it&#x27;s likely that a skilled hostile attacker who is sufficiently motivated could find ways around it (PostgreSQL itself is not a particularly hardened codebase, after all).<p>They have extra lints to help you avoid what they deem the most common soundness bugs. They make no claims that there is a way to make this approach safe against an attacker.</div><br/></div></div></div></div></div></div><div id="36440893" class="c"><input type="checkbox" id="c-36440893" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440366">parent</a><span>|</span><a href="#36441017">prev</a><span>|</span><a href="#36440692">next</a><span>|</span><label class="collapse" for="c-36440893">[-]</label><label class="expand" for="c-36440893">[1 more]</label></div><br/><div class="children"><div class="content">They didn&#x27;t mistake rust safety for anything. This is called out by them as a shrotcoming of their approach that has to be mitigated separately.</div><br/></div></div></div></div><div id="36440692" class="c"><input type="checkbox" id="c-36440692" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36440366">prev</a><span>|</span><a href="#36441035">next</a><span>|</span><label class="collapse" for="c-36440692">[-]</label><label class="expand" for="c-36440692">[8 more]</label></div><br/><div class="children"><div class="content">This paper is an easy read, but it&#x27;s basically just restating the premises of eBPF:<p>* Most programs can&#x27;t be expressed in verified eBPF.<p>* The verifier functions, to the extent it does, in large part by rejecting most programs (and implicitly limiting the uses to which eBPF can be put).<p>* This is &quot;extension code&quot;, and by definition, it interacts with the unsafe, unverified C code that the kernel is built out of.<p>(In addition to helpers, most serious eBPF-based systems also interact extensively with userland code, which is also not verified, and might even be memory-unsafe, though that&#x27;s increasingly less likely).<p>It follows from these premises that vendors should be careful about enabling non-root access to eBPF; when you do that, you really are placing a lot of faith in the verifier. And: most people don&#x27;t allow non-root eBPF. The verifier is in an uncomfortable place between being a security boundary and a reliability tool.<p>I&#x27;d argue that most of the benefit of eBPF is that you&#x27;re unlikely to panic your kernel playing with it. Ironically, that&#x27;s a feature you might not get out of signed, userland-verified, memory-safe Rust code.</div><br/><div id="36441498" class="c"><input type="checkbox" id="c-36441498" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440692">parent</a><span>|</span><a href="#36440955">next</a><span>|</span><label class="collapse" for="c-36441498">[-]</label><label class="expand" for="c-36441498">[3 more]</label></div><br/><div class="children"><div class="content">&gt; ows from these premises that vendors should be careful about enabling non-root access to eBPF;<p>The thing is that it would be really nice to be able to set up a seccomp filter without a suid :\</div><br/><div id="36441840" class="c"><input type="checkbox" id="c-36441840" checked=""/><div class="controls bullet"><span class="by">TheJH_</span><span>|</span><a href="#36440692">root</a><span>|</span><a href="#36441498">parent</a><span>|</span><a href="#36440955">next</a><span>|</span><label class="collapse" for="c-36441840">[-]</label><label class="expand" for="c-36441840">[2 more]</label></div><br/><div class="children"><div class="content">seccomp does not use the eBPF userspace interface or any of the associated permission checks. seccomp (and also the classic socket filter interface) take cBPF (classic BPF), with no privilege checks; they use completely separate verification logic for this cBPF bytecode (the eBPF verifier is not involved IIRC), and then the cBPF code is (on almost all architectures) translated into eBPF. The eBPF kernel component is then only responsible for execution&#x2F;JITting of this already-verified code, nothing else.</div><br/><div id="36441864" class="c"><input type="checkbox" id="c-36441864" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440692">root</a><span>|</span><a href="#36441840">parent</a><span>|</span><a href="#36440955">next</a><span>|</span><label class="collapse" for="c-36441864">[-]</label><label class="expand" for="c-36441864">[1 more]</label></div><br/><div class="children"><div class="content">Makes sense, thanks.</div><br/></div></div></div></div></div></div><div id="36440955" class="c"><input type="checkbox" id="c-36440955" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#36440692">parent</a><span>|</span><a href="#36441498">prev</a><span>|</span><a href="#36441035">next</a><span>|</span><label class="collapse" for="c-36440955">[-]</label><label class="expand" for="c-36440955">[4 more]</label></div><br/><div class="children"><div class="content">Surely if you are allowing non-root eBPF then security of the programs is one of your least worries? Given all the implicit privilege escalation that comes with allowing non-root to spy on everything the kernel does.</div><br/><div id="36441410" class="c"><input type="checkbox" id="c-36441410" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36440692">root</a><span>|</span><a href="#36440955">parent</a><span>|</span><a href="#36441035">next</a><span>|</span><label class="collapse" for="c-36441410">[-]</label><label class="expand" for="c-36441410">[3 more]</label></div><br/><div class="children"><div class="content">Unprivileged BPF is used for socket filters, for programs to BPF-extend themselves. It wasn&#x27;t ever the case that unprivileged eBPF would allow you to, say, load a TC filter and read everybody&#x27;s traffic.</div><br/><div id="36443402" class="c"><input type="checkbox" id="c-36443402" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36440692">root</a><span>|</span><a href="#36441410">parent</a><span>|</span><a href="#36441035">next</a><span>|</span><label class="collapse" for="c-36443402">[-]</label><label class="expand" for="c-36443402">[2 more]</label></div><br/><div class="children"><div class="content">Ok but you can like put a tracepoint on read&#x2F;write and peek at what’s going through those, no?</div><br/><div id="36443616" class="c"><input type="checkbox" id="c-36443616" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36440692">root</a><span>|</span><a href="#36443402">parent</a><span>|</span><a href="#36441035">next</a><span>|</span><label class="collapse" for="c-36443616">[-]</label><label class="expand" for="c-36443616">[1 more]</label></div><br/><div class="children"><div class="content">I have no idea, because every system I&#x27;ve ever worked on has disabled unprivileged  eBPF.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36441035" class="c"><input type="checkbox" id="c-36441035" checked=""/><div class="controls bullet"><span class="by">lcvw</span><span>|</span><a href="#36440692">prev</a><span>|</span><a href="#36444257">next</a><span>|</span><label class="collapse" for="c-36441035">[-]</label><label class="expand" for="c-36441035">[2 more]</label></div><br/><div class="children"><div class="content">I feel that this proposal defeats the entire purpose of ebpf. The point is to have a bytecode language that can do simple processing in the kernel. This code is frequently generated adhoc, such as with bpftrace. I don’t like all the limitations that currently exist in bpf, but just replacing it with rust and signature verification basically turns this into kernel modules all over again.</div><br/><div id="36441386" class="c"><input type="checkbox" id="c-36441386" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36441035">parent</a><span>|</span><a href="#36444257">next</a><span>|</span><label class="collapse" for="c-36441386">[-]</label><label class="expand" for="c-36441386">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing really &quot;simple&quot; about eBPF bytecode; it&#x27;s a full fledged ISA, so much so that the idiomatic way to build eBPF programs is to compile them from straight C with clang.</div><br/></div></div></div></div><div id="36444257" class="c"><input type="checkbox" id="c-36444257" checked=""/><div class="controls bullet"><span class="by">ezekiel68</span><span>|</span><a href="#36441035">prev</a><span>|</span><a href="#36441257">next</a><span>|</span><label class="collapse" for="c-36444257">[-]</label><label class="expand" for="c-36444257">[1 more]</label></div><br/><div class="children"><div class="content">Windows on houses (and other buildings) are flawed.  Look!  I just broke one with a sledgehammer to prove it.  News at 11.</div><br/></div></div><div id="36441257" class="c"><input type="checkbox" id="c-36441257" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#36444257">prev</a><span>|</span><a href="#36443804">next</a><span>|</span><label class="collapse" for="c-36441257">[-]</label><label class="expand" for="c-36441257">[9 more]</label></div><br/><div class="children"><div class="content">Put extensions in a Wasm sandbox. The type system has been proven sound to the highest level of assurance possible with today&#x27;s technology, mechanized at least twice, once in Coq and once in Isabelle. The algorithm is efficiently implementable and there are approaching a dozen production Wasm engines, some of which have tiers with proven safety guarantees. There is even an interpreter written in a proof assistant that has been proven fully functionally correct.</div><br/><div id="36441372" class="c"><input type="checkbox" id="c-36441372" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36441257">parent</a><span>|</span><a href="#36441333">next</a><span>|</span><label class="collapse" for="c-36441372">[-]</label><label class="expand" for="c-36441372">[6 more]</label></div><br/><div class="children"><div class="content">eBPF code gets to read and, with many limits, write kernel memory; further, the most fundamental guarantee BPF provides, going back to 1991, is that programs terminate, which isn&#x27;t a Wasm guarantee.<p>The verifier is doing something much more ambitious than hardened runtimes do (and that only because it makes drastic compromises in the otherwise valid programs it will accept).</div><br/><div id="36441421" class="c"><input type="checkbox" id="c-36441421" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#36441257">root</a><span>|</span><a href="#36441372">parent</a><span>|</span><a href="#36441528">next</a><span>|</span><label class="collapse" for="c-36441421">[-]</label><label class="expand" for="c-36441421">[3 more]</label></div><br/><div class="children"><div class="content">&gt; eBPF code gets to read and, with many limits, write kernel memory<p>Import kernel read&#x2F;write functions into the Wasm module, so they can be policed. Or, if performance needs be, map limited portions of the kernel memory into the Wasm extensions linear memory.<p>&gt;  programs terminate,<p>Several Wasm runtimes count Wasm instructions (e.g. by internal bytecode rewriting) and dynamically enforce execution times. If static enforcement of termination is really all that important, exactly the same kinds of restrictions could be applied to Wasm code (e.g. bounded loops, no recursion, limits on function size, memory size, etc).</div><br/><div id="36441462" class="c"><input type="checkbox" id="c-36441462" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36441257">root</a><span>|</span><a href="#36441421">parent</a><span>|</span><a href="#36441528">next</a><span>|</span><label class="collapse" for="c-36441462">[-]</label><label class="expand" for="c-36441462">[2 more]</label></div><br/><div class="children"><div class="content">The BPF verifier doesn&#x27;t simply count instructions (though there is a maximum instruction count as a failsafe). It can&#x27;t: eBPF programs are JIT&#x27;d down to machine code --- that&#x27;s part of what makes eBPF so attractive, because the code you&#x27;re running is comparably fast to the &quot;native&quot; kernel code. Instead, it refuses to admit programs that can&#x27;t be proven to constrain their loops.</div><br/><div id="36443649" class="c"><input type="checkbox" id="c-36443649" checked=""/><div class="controls bullet"><span class="by">neerajsi</span><span>|</span><a href="#36441257">root</a><span>|</span><a href="#36441462">parent</a><span>|</span><a href="#36441528">next</a><span>|</span><label class="collapse" for="c-36443649">[-]</label><label class="expand" for="c-36443649">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think jitting necessarily precludes counting runtime instructions. You could always jit in an internal variable that gets incremented for each high level instruction being translated. And of course you can optimize the increments within each basic block.  There&#x27;s even a cool minimum spanning tree algorithm due to Larus and Ball originally for path profiling that might be adaptable to reduce increments across the blocks.<p>I know this is a bit of an aside. The point still stands about the user not wanting their bpf program to terminate at runtime investment.</div><br/></div></div></div></div></div></div><div id="36441528" class="c"><input type="checkbox" id="c-36441528" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36441257">root</a><span>|</span><a href="#36441372">parent</a><span>|</span><a href="#36441421">prev</a><span>|</span><a href="#36441333">next</a><span>|</span><label class="collapse" for="c-36441528">[-]</label><label class="expand" for="c-36441528">[2 more]</label></div><br/><div class="children"><div class="content">Program termination is a solved problem with gas metering. Ethereum popularized the idea, but the idea itself is as old as hills.</div><br/><div id="36441698" class="c"><input type="checkbox" id="c-36441698" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36441257">root</a><span>|</span><a href="#36441528">parent</a><span>|</span><a href="#36441333">next</a><span>|</span><label class="collapse" for="c-36441698">[-]</label><label class="expand" for="c-36441698">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a subtlety being missed here. Proven termination of BPF programs far predates the adversarial threat model you and the WASM person are thinking about. It was a property of the original 1991 McCanne BPF. It&#x27;s a safeguard for the programmer <i>against themselves</i>. eBPF shims in all over the place in the kernel; it would not be OK for the guarantee to simply be &quot;there&#x27;s a worst case maximum cycle budget for programs&quot;. eBPF programs are bounded, so they can be installed in hot places in the kernel.<p>The solved problem you&#x27;re referring to is a much simpler problem.</div><br/></div></div></div></div></div></div><div id="36441333" class="c"><input type="checkbox" id="c-36441333" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#36441257">parent</a><span>|</span><a href="#36441372">prev</a><span>|</span><a href="#36443804">next</a><span>|</span><label class="collapse" for="c-36441333">[-]</label><label class="expand" for="c-36441333">[2 more]</label></div><br/><div class="children"><div class="content">This is such an obvious solution that I wonder why eBPF exists at all. WebAssembly is better for the purpose in like every way? Be against Not-Invented-Here, don&#x27;t reinvent the wheel.</div><br/><div id="36441379" class="c"><input type="checkbox" id="c-36441379" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36441257">root</a><span>|</span><a href="#36441333">parent</a><span>|</span><a href="#36443804">next</a><span>|</span><label class="collapse" for="c-36441379">[-]</label><label class="expand" for="c-36441379">[1 more]</label></div><br/><div class="children"><div class="content">Well, for one thing, eBPF predates WebAssembly.</div><br/></div></div></div></div></div></div><div id="36443804" class="c"><input type="checkbox" id="c-36443804" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#36441257">prev</a><span>|</span><a href="#36440588">next</a><span>|</span><label class="collapse" for="c-36443804">[-]</label><label class="expand" for="c-36443804">[1 more]</label></div><br/><div class="children"><div class="content">When I read the title I thought this was maybe about eBPF verification and the difficulty of creating eBPF programs that actually pass the verifier. What&#x27;s the HN take on this?</div><br/></div></div><div id="36440588" class="c"><input type="checkbox" id="c-36440588" checked=""/><div class="controls bullet"><span class="by">cwzwarich</span><span>|</span><a href="#36443804">prev</a><span>|</span><a href="#36441183">next</a><span>|</span><label class="collapse" for="c-36440588">[-]</label><label class="expand" for="c-36440588">[1 more]</label></div><br/><div class="children"><div class="content">The Rust compiler has several unsoundness bugs that are years old. If you trusted Rust language security in the kernel, these would all be security holes.</div><br/></div></div><div id="36441183" class="c"><input type="checkbox" id="c-36441183" checked=""/><div class="controls bullet"><span class="by">manaskarekar</span><span>|</span><a href="#36440588">prev</a><span>|</span><a href="#36440990">next</a><span>|</span><label class="collapse" for="c-36441183">[-]</label><label class="expand" for="c-36441183">[1 more]</label></div><br/><div class="children"><div class="content">Somewhat tangentially related, if anyone is interested in writing eBPF programs in Rust, check out aya-rs (<a href="https:&#x2F;&#x2F;aya-rs.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;aya-rs.dev&#x2F;</a>).<p>Rustc supports eBPF bytecode as a target, and aya-rs avoids using clang&#x2F;llvm. So you can use rust to write eBPF code in both user and kernel space.<p>This is a different beast from the usual rust though - lots of `unsafe`s.</div><br/></div></div><div id="36440990" class="c"><input type="checkbox" id="c-36440990" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#36441183">prev</a><span>|</span><a href="#36440376">next</a><span>|</span><label class="collapse" for="c-36440990">[-]</label><label class="expand" for="c-36440990">[3 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t been following the eBPF situation for a while, but... how did it come to this? I thought the point of BPF (sans &#x27;e&#x27; anyway) was that it was pretty much secure by construction, or at minimum was simple enough to fully verify in polynomial time. So these eBPF vulnerabilities sound like a completely invented, unnecessary class of problems.</div><br/><div id="36441497" class="c"><input type="checkbox" id="c-36441497" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36440990">parent</a><span>|</span><a href="#36441079">next</a><span>|</span><label class="collapse" for="c-36441497">[-]</label><label class="expand" for="c-36441497">[1 more]</label></div><br/><div class="children"><div class="content">The track record of eBPF to date has been reasonably strong, and the threat model serious systems give to eBPF is narrow: you care a lot about the formal soundness of the verifier if you&#x27;re loading untrusted code, and much less if you&#x27;re never doing that. eBPF has been a pretty important victory for the Linux systems design model.<p>The real goal of eBPF verification is to avoid kernel crashes, and for that goal, eBPF has been unreasonably successful.</div><br/></div></div><div id="36441079" class="c"><input type="checkbox" id="c-36441079" checked=""/><div class="controls bullet"><span class="by">skywhopper</span><span>|</span><a href="#36440990">parent</a><span>|</span><a href="#36441497">prev</a><span>|</span><a href="#36440376">next</a><span>|</span><label class="collapse" for="c-36441079">[-]</label><label class="expand" for="c-36441079">[1 more]</label></div><br/><div class="children"><div class="content">Because devs latched into their interpretation of eBPF’s promises and found ways to make them happen via the way any problem in computer science gets solved: indirection. This is human nature (just look at the stack of BIOS&#x2F;EFI&#x2F;OS execution rings that pre-empt each other to provide more features at lower hardware levels). Responsible operators should avoid these hacks where possible.</div><br/></div></div></div></div><div id="36440376" class="c"><input type="checkbox" id="c-36440376" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36440990">prev</a><span>|</span><a href="#36443396">next</a><span>|</span><label class="collapse" for="c-36440376">[-]</label><label class="expand" for="c-36440376">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not happy about the entire concept of running user code in the kernel. As a special-purpose hack for servers that do very little else, maybe. As a standard OS feature, it seems to create too big an attack surface. One which has been exploited.[1]<p>[1] <a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2022&#x2F;02&#x2F;23&#x2F;chinese_nsa_linux&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.theregister.com&#x2F;2022&#x2F;02&#x2F;23&#x2F;chinese_nsa_linux&#x2F;</a></div><br/><div id="36443449" class="c"><input type="checkbox" id="c-36443449" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#36440376">parent</a><span>|</span><a href="#36440837">next</a><span>|</span><label class="collapse" for="c-36443449">[-]</label><label class="expand" for="c-36443449">[1 more]</label></div><br/><div class="children"><div class="content">Your example doesn’t really document an exploit but use of it as a tool in an attack. It’s just an interface they chose to use, not something they broke.</div><br/></div></div><div id="36440837" class="c"><input type="checkbox" id="c-36440837" checked=""/><div class="controls bullet"><span class="by">lcvw</span><span>|</span><a href="#36440376">parent</a><span>|</span><a href="#36443449">prev</a><span>|</span><a href="#36443396">next</a><span>|</span><label class="collapse" for="c-36440837">[-]</label><label class="expand" for="c-36440837">[3 more]</label></div><br/><div class="children"><div class="content">It requires root to use, if someone has root they’ve already owned your system anyway.</div><br/><div id="36441516" class="c"><input type="checkbox" id="c-36441516" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440376">root</a><span>|</span><a href="#36440837">parent</a><span>|</span><a href="#36443396">next</a><span>|</span><label class="collapse" for="c-36441516">[-]</label><label class="expand" for="c-36441516">[2 more]</label></div><br/><div class="children"><div class="content">The kernel should be considered a tier above root, they shouldn&#x27;t be considered the same level.<p>a) Root can be constrained by the kernel via LSM - you can run a program as root and it could be limited to very little given the current set of tools we have.<p>b) These days unprivileged users can be &quot;root&quot; in their own namespaces, so what &quot;root&quot; is means something very different</div><br/><div id="36441935" class="c"><input type="checkbox" id="c-36441935" checked=""/><div class="controls bullet"><span class="by">TheJH_</span><span>|</span><a href="#36440376">root</a><span>|</span><a href="#36441516">parent</a><span>|</span><a href="#36443396">next</a><span>|</span><label class="collapse" for="c-36441935">[-]</label><label class="expand" for="c-36441935">[1 more]</label></div><br/><div class="children"><div class="content">Re b): Yeah but, like, colloquially &quot;root&quot; means &quot;a process in the init user namespace with all UIDs set to 0 and a full capability mask&quot;.<p>Re a):
If you are root in that sense (and haven&#x27;t been blanket-denied the ability to use capabilities like CAP_SYS_ADMIN by an LSM), and not subject to a strict seccomp policy, then you cannot really in general be securely constrained with LSMs.<p>The kernel essentially treats CAP_SYS_ADMIN in the init userns as the catch-all for &quot;you have been granted the ability to administer and access anything on the system&quot;, for anything that doesn&#x27;t have a more specific permission and isn&#x27;t access-controlled by UID. And if you can, like, call swapon() on an arbitrary file to make the kernel swap memory from the whole system into that file of your choice, LSM-enforced security boundaries probably don&#x27;t work all that well anymore.</div><br/></div></div></div></div></div></div></div></div><div id="36443396" class="c"><input type="checkbox" id="c-36443396" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#36440376">prev</a><span>|</span><a href="#36441281">next</a><span>|</span><label class="collapse" for="c-36443396">[-]</label><label class="expand" for="c-36443396">[1 more]</label></div><br/><div class="children"><div class="content">The whole BPF verifier and development process is so botched, it&#x27;s ridiculous. It&#x27;s like maintainers decided to make this as hard as possible out of pettiness and &quot;they have to use C APIs instead&quot; or something.<p>- Loading an eBPF module without the CAP_BPF (and in some cases without the CAP_NET_ADMIN which you need for XDP) capabilities will generate a &quot;unknown&#x2F;invalid memory access&quot; error which is super useless as an error message.<p>- In my personal opinion a bytecode format for both little endian (bpfel) and big endian (bpfeb) machines is kinda unnecessary. I mean, it&#x27;s a virtual bytecode format for a reason, right!?<p>- Compiling eBPF via clang to the bpf bytecode format without debug symbols will make every following error message down the line utterly useless. Took me a while to figure out what &quot;unknown scalar&quot; really means. If you forget that &quot;-g&quot; flag you&#x27;re totally fucked.<p>- Anything pointer related that eBPF verifier itself doesn&#x27;t support will lead to &quot;unknown scalar&quot; errors which are actually out of bounds errors most of the time (e.g. have to use if pointer &lt; size(packet) around it), which only happen in the verification process and can only be shown using the bpftool. If you miss them, good luck getting a better error message out of the kernel while loading the module.<p>- The bpftool maintainer is kind of unfriendly, he&#x27;s telling you to read a book about the bytecode format if your code doesn&#x27;t compile and you&#x27;re asking about examples on how to use pointers inside a BPF codebase because it seems to enforce specific rules in terms of what kind of method (__always_static) are allowed to modify or allocate memory. There&#x27;s a lot of limitations that are documented _nowhere_ on the internet, and seemingly all developers are supposed to know them by reading the bpftool codebase itself!? Who&#x27;s the audience for using the bpftool then? Developers of the bpftool itself?<p>- The BCC tools (bpf compiler collection) are still using examples that can&#x27;t compile on an up-to-date kernel. [1] If you don&#x27;t have the old headers, you&#x27;ll find a lot of issues that show you the specific git hash where the &quot;bpf-helpers.h&quot; file was still inside the kernel codebase.<p>- The libbpf repo contain also examples that won&#x27;t compile. Especially the xdp related ones [2]<p>- There&#x27;s also an ongoing migration of all projects (?) to xdp-tools, which seems to be redundant in terms of bpf related topics, but also has only a couple examples that somehow work [3]<p>- Literally the only userspace eBPF generation framework that worked outside a super outdated enterprise linux environment is the cilium ebpf project [4], but only because they&#x27;re using the old &quot;bpf-helpers.h&quot; file that are meanwhile removed from the kernel itself. [5] They&#x27;re also incomplete for things like the new &quot;__u128&quot; and &quot;__bpf_helper_methods&quot; syntax which are sometimes missing.<p>- The only working examples that can also be used for reference on &quot;what&#x27;s available&quot; in terms of eBPF and kernel userspace APIs is a forked repo of the bootlin project [6] which literally taught me how to use eBPF in practice.<p>- All other (official?) examples show you how to make a bpf_printk call, but _none_ of them show you how to even interact with bpf maps (whose syntax changed like 5 times over the course of the last years, and 4 of them don&#x27;t run through the verifier, obviously). They&#x27;re also somewhat documented in the wiki of the libbpf project, without further explanation on why or what [7]. Without that bootlin repo I still would have no idea other than how to make a print inside a &quot;kretprobe&quot;. Anything more advanced is totally undocumented.<p>- OpenSnitch even has a workflow that copies their own codebase inside the kernel codebase, just to make it compile - because all other ways are too redundant or too broken. Not kidding you. [8]<p>Note that none of any BPF related projects uses any kind of reliable version scheme, and none of those project uses anything &quot;modern&quot; like conan (or whatever) as a package manager. Because that would have been too easy to use, and too easy on documenting on what breaks when. &#x2F;s<p>Overall I have to say, BPF was the worst development experience I ever had. Writing a kernel module is _easier_ than writing a BPF module, because then you have at least reliable tooling. In the BPF world, anything will and can break at any unpredictable moment. If you compare that to the experience of other development environments like say, JVM or even the JS world, where debuggers that interact with JIT compilers are the norm, well ... then you&#x27;ve successfully been transferred back to the PTSD moments of the 90s.<p>Honestly I don&#x27;t know how people can use BPF and say &quot;yeah this has been a great experience and I love it&quot; and not realize how broken the tooling is on every damn level.<p>I totally recommend reading the book [9] and watching the YouTube videos of Liz Rice [10]. They&#x27;re awesome, and they show you how to tackle some of the problems I mentioned. I think that without her work, BPF would have had zero chance of success.<p>What&#x27;s missing in the BPF world is definitely better tooling, better error messages (e.g. &quot;did you forget to do this?&quot; or even &quot;unexpected statement&quot; would be sooooo much better than the current state), and an easier way to debug an eBPF program. Documentation on what&#x27;s available and what is not is also necessary, because it&#x27;s impossible to find out right now. If I am not allowed to use pointers or whatever, then say so in the beginning.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bcc">https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bcc</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;libbpf&#x2F;libbpf">https:&#x2F;&#x2F;github.com&#x2F;libbpf&#x2F;libbpf</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;xdp-project&#x2F;xdp-tools">https:&#x2F;&#x2F;github.com&#x2F;xdp-project&#x2F;xdp-tools</a><p>[4] <a href="https:&#x2F;&#x2F;github.com&#x2F;cilium&#x2F;ebpf&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;cilium&#x2F;ebpf&#x2F;</a><p>[5] <a href="https:&#x2F;&#x2F;github.com&#x2F;cilium&#x2F;ebpf&#x2F;tree&#x2F;master&#x2F;examples&#x2F;headers">https:&#x2F;&#x2F;github.com&#x2F;cilium&#x2F;ebpf&#x2F;tree&#x2F;master&#x2F;examples&#x2F;headers</a><p>[6] <a href="https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;linux&#x2F;latest&#x2F;source&#x2F;tools&#x2F;testing&#x2F;selftests&#x2F;bpf" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;linux&#x2F;latest&#x2F;source&#x2F;tools&#x2F;testing...</a><p>[7] <a href="https:&#x2F;&#x2F;github.com&#x2F;libbpf&#x2F;libbpf&#x2F;wiki&#x2F;Libbpf-1.0-migration-guide">https:&#x2F;&#x2F;github.com&#x2F;libbpf&#x2F;libbpf&#x2F;wiki&#x2F;Libbpf-1.0-migration-g...</a><p>[8] <a href="https:&#x2F;&#x2F;github.com&#x2F;evilsocket&#x2F;opensnitch&#x2F;blob&#x2F;master&#x2F;ebpf_prog&#x2F;Makefile">https:&#x2F;&#x2F;github.com&#x2F;evilsocket&#x2F;opensnitch&#x2F;blob&#x2F;master&#x2F;ebpf_pr...</a><p>[9] <a href="https:&#x2F;&#x2F;isovalent.com&#x2F;learning-ebpf&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;isovalent.com&#x2F;learning-ebpf&#x2F;</a><p>[10] (e.g.) <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=L3_AOFSNKK8">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=L3_AOFSNKK8</a></div><br/></div></div><div id="36441281" class="c"><input type="checkbox" id="c-36441281" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#36443396">prev</a><span>|</span><a href="#36441584">next</a><span>|</span><label class="collapse" for="c-36441281">[-]</label><label class="expand" for="c-36441281">[3 more]</label></div><br/><div class="children"><div class="content">to secure linux, both ebpf and io_ring need to be disabled in kconfig at kernel compile time.<p>in security insensitive scenarios, they are both interesting tech.</div><br/><div id="36441505" class="c"><input type="checkbox" id="c-36441505" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36441281">parent</a><span>|</span><a href="#36441584">next</a><span>|</span><label class="collapse" for="c-36441505">[-]</label><label class="expand" for="c-36441505">[2 more]</label></div><br/><div class="children"><div class="content">Radically different thread models. io_uring is conventionally exposed to unprivileged programs, and eBPF virtually never is.</div><br/><div id="36441567" class="c"><input type="checkbox" id="c-36441567" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#36441281">root</a><span>|</span><a href="#36441505">parent</a><span>|</span><a href="#36441584">next</a><span>|</span><label class="collapse" for="c-36441567">[-]</label><label class="expand" for="c-36441567">[1 more]</label></div><br/><div class="children"><div class="content">isn’t the current linux security mindset that all access is potentially privileged?</div><br/></div></div></div></div></div></div><div id="36441584" class="c"><input type="checkbox" id="c-36441584" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#36441281">prev</a><span>|</span><a href="#36440750">next</a><span>|</span><label class="collapse" for="c-36441584">[-]</label><label class="expand" for="c-36441584">[1 more]</label></div><br/><div class="children"><div class="content">Secure code inside the kernel is untenable.<p>We can do ok, lots of hard work goes in to doing ok, but this isn&#x27;t the kernels top priority, and never will be.<p>Userspace is the security boundary.</div><br/></div></div><div id="36440750" class="c"><input type="checkbox" id="c-36440750" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#36441584">prev</a><span>|</span><a href="#36441329">next</a><span>|</span><label class="collapse" for="c-36440750">[-]</label><label class="expand" for="c-36440750">[1 more]</label></div><br/><div class="children"><div class="content">The actual paper.<p><a href="https:&#x2F;&#x2F;tianyin.github.io&#x2F;pub&#x2F;rust-kernel-ext.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;tianyin.github.io&#x2F;pub&#x2F;rust-kernel-ext.pdf</a></div><br/></div></div><div id="36441329" class="c"><input type="checkbox" id="c-36441329" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#36440750">prev</a><span>|</span><a href="#36440958">next</a><span>|</span><label class="collapse" for="c-36441329">[-]</label><label class="expand" for="c-36441329">[2 more]</label></div><br/><div class="children"><div class="content">eBPF verification was always a laugh from the very beginning design stages, if you ask me, because as this paper demonstrates, it was never going to be enough. Anyone with a modicum of security or PLT experience could have told you this when evaluating the design and history. Like, if I had to be completely honest, the very fact the security&#x2F;robustness model started on principles like &quot;fixed number of loop iterations&quot; or &quot;no backedge jumps&quot; (among several others) in the verifier was a pretty good sign that this was always going to be a source of continuous vulnerabilities. It makes me think people are flying blind. If you&#x27;re not systematically fixing these issues in the very design stages of the system, and using duct tape, you&#x27;re just going to patch every single thing one by one as it happens, and then how is that any different from today?<p>The basic idea is simple. You have the verifier, and the TCB. The verifier has to reject invalid programs, so the TCB does not have its integrity compromised by the program. The verifier is small, so it can be audited. That&#x27;s nice -- until you back out and realize the TCB is &quot;the entire linux kernel and everything inside of it and all of the surface area API between it and the BPF Virtual Machine&quot; and it dawns on you that at that point the principle of &quot;system integrity being maintained&quot; relies very little on the verifier and actually a whole lot on Linux being functionally correct. Which is where you started at in the first place. The goal of eBPF after all isn&#x27;t just to burn CPU cycles and return an integer code. It has to <i>interact</i> with the system. Having the TCB functionally be &quot;every line of code we&#x27;re trying to protect&quot; is the Windows 3.1 of integrity models.<p>Now, this might <i>also</i> be OK and quantifiable to some extent. Except for the other fact that the guiding design principle in Linux is to pretty much grow without bound, without end, rewrite code left and right, and the eBPF subsystem itself has been endlessly tacking on features left and right for what -- years now?<p>If you take away any of these three things (flawed design basis, ridiculously large TCB, endless and boundless growth) and modify or remove one of them, the picture looks much better. Solid basis? You can maybe handle the other two if you&#x27;re careful and on top of things, big hand waive. Very small TCB? Great, you can put significantly more trust in the verifier, freeing you from the need to worry about every line of code. No endless growth? Then you have a target you can monitor and maybe improve on e.g. reduce trends downward over time. But the combination of all three of these things means that the end result is &quot;greater than the sum of the parts&quot; so to speak and it will always be a matter of pushing the boulder up the hill every day, all so it can fall back down again.<p>That said, eBPF is really useful. I get a ton of value out of it. The verifier does allow you to have greater trust in running things in the kernel. In this case, doing <i>something</i> is quite literally 1,000% better than doing nothing in this if you ask me, at least for <i>most</i> intents and purposes. So making it safer and more robust is worthwhile. But it was pretty easy to see this sort of stuff from a long way out, IMO.</div><br/><div id="36441720" class="c"><input type="checkbox" id="c-36441720" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36441329">parent</a><span>|</span><a href="#36440958">next</a><span>|</span><label class="collapse" for="c-36441720">[-]</label><label class="expand" for="c-36441720">[1 more]</label></div><br/><div class="children"><div class="content">The original BPF model was &quot;no backedge jumps, constrained memory model&quot;, and its track record is quite good. Say more about why you think &quot;no backedge jumps&quot; --- which isn&#x27;t the current, more-sophisticated, harder-to-understand verification model --- was obviously weak.</div><br/></div></div></div></div><div id="36440958" class="c"><input type="checkbox" id="c-36440958" checked=""/><div class="controls bullet"><span class="by">nightowl_games</span><span>|</span><a href="#36441329">prev</a><span>|</span><label class="collapse" for="c-36440958">[-]</label><label class="expand" for="c-36440958">[6 more]</label></div><br/><div class="children"><div class="content">When I read about eBPF for kernel extension, it immediately made me think it would be full of security problems. I don&#x27;t even know anything about the kernel, eBPF validation and barely anything about security, but just from a theoretical level, it seems highly insecure to run someone else&#x27;s code in the kernel. &quot;Verifying&quot; it seems impossible from a theoretical level. Am I wrong? What&#x27;s the limits of security in eBPF kernel extensions?</div><br/><div id="36440986" class="c"><input type="checkbox" id="c-36440986" checked=""/><div class="controls bullet"><span class="by">lcvw</span><span>|</span><a href="#36440958">parent</a><span>|</span><label class="collapse" for="c-36440986">[-]</label><label class="expand" for="c-36440986">[5 more]</label></div><br/><div class="children"><div class="content">1. Using eBPF requires root<p>2. The verifier checks memory bounds access, guarantees termination in a certain number of instructions, and restricts function calls to a limited number of helper functions provided by the kernel.<p>3. BPF code runs on a vm, think like the jvm. It’s impossible to express a lot of nasty stuff given the restrictive bytecode language.<p>There have been bugs in the verifier, but overall it works very well, the biggest issue being that it drastically limits the complexity of your program.</div><br/><div id="36441522" class="c"><input type="checkbox" id="c-36441522" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440958">root</a><span>|</span><a href="#36440986">parent</a><span>|</span><label class="collapse" for="c-36441522">[-]</label><label class="expand" for="c-36441522">[4 more]</label></div><br/><div class="children"><div class="content">&gt; 1. Using eBPF requires root<p>Unprivileged eBPF has been around for a long time.</div><br/><div id="36441723" class="c"><input type="checkbox" id="c-36441723" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36440958">root</a><span>|</span><a href="#36441522">parent</a><span>|</span><label class="collapse" for="c-36441723">[-]</label><label class="expand" for="c-36441723">[3 more]</label></div><br/><div class="children"><div class="content">Except that it&#x27;s been almost universally disabled, for many years. Nobody trusts it.</div><br/><div id="36441859" class="c"><input type="checkbox" id="c-36441859" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36440958">root</a><span>|</span><a href="#36441723">parent</a><span>|</span><label class="collapse" for="c-36441859">[-]</label><label class="expand" for="c-36441859">[2 more]</label></div><br/><div class="children"><div class="content">Idk if I&#x27;d call 2 years &quot;many&quot;, but yes.</div><br/><div id="36443800" class="c"><input type="checkbox" id="c-36443800" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#36440958">root</a><span>|</span><a href="#36441859">parent</a><span>|</span><label class="collapse" for="c-36443800">[-]</label><label class="expand" for="c-36443800">[1 more]</label></div><br/><div class="children"><div class="content">In eBPF years, 2 years is an eternity.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>