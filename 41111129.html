<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722416514608" as="style"/><link rel="stylesheet" href="styles.css?v=1722416514608"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.swift.org/blog/announcing-swift-homomorphic-encryption/">Swift Homomorphic Encryption</a> <span class="domain">(<a href="https://www.swift.org">www.swift.org</a>)</span></div><div class="subtext"><span>yAak</span> | <span>113 comments</span></div><br/><div><div id="41117478" class="c"><input type="checkbox" id="c-41117478" checked=""/><div class="controls bullet"><span class="by">menkalinan</span><span>|</span><a href="#41117312">next</a><span>|</span><label class="collapse" for="c-41117478">[-]</label><label class="expand" for="c-41117478">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite understand how the server can match the ciphertext with a value without knowing the key. How does the server determine that the ciphertext corresponds to the specific value? If the server constructs this ciphertext-value database, how does it know what algorithm to use to create ciphertext from a value and store on its side?</div><br/></div></div><div id="41117312" class="c"><input type="checkbox" id="c-41117312" checked=""/><div class="controls bullet"><span class="by">oulipo</span><span>|</span><a href="#41117478">prev</a><span>|</span><a href="#41112383">next</a><span>|</span><label class="collapse" for="c-41117312">[-]</label><label class="expand" for="c-41117312">[2 more]</label></div><br/><div class="children"><div class="content">How does it compare to the FHE from <a href="https:&#x2F;&#x2F;zama.ai" rel="nofollow">https:&#x2F;&#x2F;zama.ai</a> ?</div><br/><div id="41117371" class="c"><input type="checkbox" id="c-41117371" checked=""/><div class="controls bullet"><span class="by">rhindi</span><span>|</span><a href="#41117312">parent</a><span>|</span><a href="#41112383">next</a><span>|</span><label class="collapse" for="c-41117371">[-]</label><label class="expand" for="c-41117371">[1 more]</label></div><br/><div class="children"><div class="content">They use BFV, which is an FHE scheme allowing a limited number of fast additions and multiplications (enough for their use case).<p>Zama uses TFHE, which allows any operation (eg comparisons) with unlimited depth.<p>So if you only need add&#x2F;mul, BFV, BGV and CKKS are good options. For anything else, you better use TFHE</div><br/></div></div></div></div><div id="41112383" class="c"><input type="checkbox" id="c-41112383" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#41117312">prev</a><span>|</span><a href="#41112955">next</a><span>|</span><label class="collapse" for="c-41112383">[-]</label><label class="expand" for="c-41112383">[14 more]</label></div><br/><div class="children"><div class="content">I feel like phone number lookup is the textbook example of homomorphic encryption not actually working because there&#x27;s so few keys you can simply enumerate them.</div><br/><div id="41112476" class="c"><input type="checkbox" id="c-41112476" checked=""/><div class="controls bullet"><span class="by">colmmacc</span><span>|</span><a href="#41112383">parent</a><span>|</span><a href="#41114574">next</a><span>|</span><label class="collapse" for="c-41112476">[-]</label><label class="expand" for="c-41112476">[9 more]</label></div><br/><div class="children"><div class="content">I think here the query exposes who called who, which isn&#x27;t as enumerable. By encrypting the query homomorphically on the client, the answering service has no knowledge of what number the lookup is for, and so Apple can&#x27;t build a database of who calls you.</div><br/><div id="41112560" class="c"><input type="checkbox" id="c-41112560" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#41112383">root</a><span>|</span><a href="#41112476">parent</a><span>|</span><a href="#41114574">next</a><span>|</span><label class="collapse" for="c-41112560">[-]</label><label class="expand" for="c-41112560">[8 more]</label></div><br/><div class="children"><div class="content">It includes both numbers? That wasn&#x27;t clear. It sounded like they&#x27;re just looking up the calling number for fancy caller id. How does the recipient affect the query?</div><br/><div id="41112647" class="c"><input type="checkbox" id="c-41112647" checked=""/><div class="controls bullet"><span class="by">colmmacc</span><span>|</span><a href="#41112383">root</a><span>|</span><a href="#41112560">parent</a><span>|</span><a href="#41114574">next</a><span>|</span><label class="collapse" for="c-41112647">[-]</label><label class="expand" for="c-41112647">[7 more]</label></div><br/><div class="children"><div class="content">The lookup has to come from your phone, which implicitly discloses you. Encrypting the caller-id symmetrically or asymmetrically wouldn&#x27;t get privacy, because the receiver would have the decryption key. Hashing it, even with a seed, would be dumb because it&#x27;s enumerable as you pointed out. But encrypting the entire query does work, because it becomes on a homomorphic search on uniform looking data. So the receiver has no idea what you queried.<p>That said, research on things like memory access side-channels is thin here. Like if I take a guess and try a query for my guess number, are there timings there that could be exploited because of cache effects? I have no idea, but a lot of PIR schemes have fallen to this.</div><br/><div id="41112712" class="c"><input type="checkbox" id="c-41112712" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#41112383">root</a><span>|</span><a href="#41112647">parent</a><span>|</span><a href="#41114574">next</a><span>|</span><label class="collapse" for="c-41112712">[-]</label><label class="expand" for="c-41112712">[6 more]</label></div><br/><div class="children"><div class="content">Okay, I figure if Apple wanted, they could simply query every number and see which disk blocks get read. But now maybe I&#x27;m confused. They read the whole database on every query?</div><br/><div id="41112850" class="c"><input type="checkbox" id="c-41112850" checked=""/><div class="controls bullet"><span class="by">colmmacc</span><span>|</span><a href="#41112383">root</a><span>|</span><a href="#41112712">parent</a><span>|</span><a href="#41114574">next</a><span>|</span><label class="collapse" for="c-41112850">[-]</label><label class="expand" for="c-41112850">[5 more]</label></div><br/><div class="children"><div class="content">My understanding of encrypted search in FHE is that there can be multiple copies of the same search key, and that search keys aren&#x27;t simply in-place encrypted versions of themselves - as encrypted fields in a database are - but are mappings embedded in a higher dimensional space that is encrypted.<p>That reads like sci-fi nonsense, but the &quot;on the metal&quot; result is that a search key will translate to a set of memory locations that are combined to determine the match, and a separate query for the same search key will translate to a different (but potentially overlapping) set of memory locations that produce the same result.</div><br/><div id="41113759" class="c"><input type="checkbox" id="c-41113759" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41112383">root</a><span>|</span><a href="#41112850">parent</a><span>|</span><a href="#41114574">next</a><span>|</span><label class="collapse" for="c-41113759">[-]</label><label class="expand" for="c-41113759">[4 more]</label></div><br/><div class="children"><div class="content">Do I have this right?<p>If the server could actually decode things it would’ve gotten something that could be decrypted into let’s say 15 phone numbers. A little bit like if they were hashed, to simplify.<p>So the answer the server returns isn’t who the phone number belongs to, it’s who those 15 phone numbers belong to.<p>And then the client can decrypt it and just get the one that it cares about.<p>But unlike if you were just doing hash buckets no one who saw the data going back-and-forth could actually understand any of it. Correct?<p>Is this only really good for data to look up cases? I had thought homomorphic encryption could be used to do actual calculations, at least certain kinds.</div><br/><div id="41117404" class="c"><input type="checkbox" id="c-41117404" checked=""/><div class="controls bullet"><span class="by">GTP</span><span>|</span><a href="#41112383">root</a><span>|</span><a href="#41113759">parent</a><span>|</span><a href="#41116567">next</a><span>|</span><label class="collapse" for="c-41117404">[-]</label><label class="expand" for="c-41117404">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK (but my knowledge is 2&#x2F;3 years out of date) the problem with general computation is that current schemes are still too slow for parctical use. But recent developments give hope that it could be doable in the future.</div><br/></div></div><div id="41116567" class="c"><input type="checkbox" id="c-41116567" checked=""/><div class="controls bullet"><span class="by">ElFitz</span><span>|</span><a href="#41112383">root</a><span>|</span><a href="#41113759">parent</a><span>|</span><a href="#41117404">prev</a><span>|</span><a href="#41113997">next</a><span>|</span><label class="collapse" for="c-41116567">[-]</label><label class="expand" for="c-41116567">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I had thought homomorphic encryption could be used to do actual calculations, at least certain kinds.<p>Well yes. There was this:<p>- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21638639">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=21638639</a><p>- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31933995">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31933995</a><p>- <a href="https:&#x2F;&#x2F;azeemba.com&#x2F;posts&#x2F;homomorphic-encryption-with-images.html" rel="nofollow">https:&#x2F;&#x2F;azeemba.com&#x2F;posts&#x2F;homomorphic-encryption-with-images...</a><p>And quite a few more.</div><br/></div></div><div id="41113997" class="c"><input type="checkbox" id="c-41113997" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41112383">root</a><span>|</span><a href="#41113759">parent</a><span>|</span><a href="#41116567">prev</a><span>|</span><a href="#41114574">next</a><span>|</span><label class="collapse" for="c-41113997">[-]</label><label class="expand" for="c-41113997">[1 more]</label></div><br/><div class="children"><div class="content">Theoretically it can, but the tech isn&#x27;t quite there yet, so we don&#x27;t know for sure.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41114574" class="c"><input type="checkbox" id="c-41114574" checked=""/><div class="controls bullet"><span class="by">silasdavis</span><span>|</span><a href="#41112383">parent</a><span>|</span><a href="#41112476">prev</a><span>|</span><a href="#41112452">next</a><span>|</span><label class="collapse" for="c-41114574">[-]</label><label class="expand" for="c-41114574">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what enumeration attack you have in mind, but if you were to encrypt the same value many times you would not get the same ciphertext under most schemes.</div><br/></div></div><div id="41112452" class="c"><input type="checkbox" id="c-41112452" checked=""/><div class="controls bullet"><span class="by">willseth</span><span>|</span><a href="#41112383">parent</a><span>|</span><a href="#41114574">prev</a><span>|</span><a href="#41112503">next</a><span>|</span><label class="collapse" for="c-41112452">[-]</label><label class="expand" for="c-41112452">[1 more]</label></div><br/><div class="children"><div class="content">The novelty is that the server processing the phone number can perform the lookup without actually knowing the phone number or whether it matched.</div><br/></div></div><div id="41112503" class="c"><input type="checkbox" id="c-41112503" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41112383">parent</a><span>|</span><a href="#41112452">prev</a><span>|</span><a href="#41114565">next</a><span>|</span><label class="collapse" for="c-41112503">[-]</label><label class="expand" for="c-41112503">[1 more]</label></div><br/><div class="children"><div class="content">Are you thinking of hashing?<p>As far as I&#x27;m aware homomorphic encryption can keep even a single bit safe, but maybe I missed something.</div><br/></div></div><div id="41114565" class="c"><input type="checkbox" id="c-41114565" checked=""/><div class="controls bullet"><span class="by">scosman</span><span>|</span><a href="#41112383">parent</a><span>|</span><a href="#41112503">prev</a><span>|</span><a href="#41112955">next</a><span>|</span><label class="collapse" for="c-41114565">[-]</label><label class="expand" for="c-41114565">[1 more]</label></div><br/><div class="children"><div class="content">add a seed.</div><br/></div></div></div></div><div id="41112955" class="c"><input type="checkbox" id="c-41112955" checked=""/><div class="controls bullet"><span class="by">golol</span><span>|</span><a href="#41112383">prev</a><span>|</span><a href="#41113719">next</a><span>|</span><label class="collapse" for="c-41112955">[-]</label><label class="expand" for="c-41112955">[2 more]</label></div><br/><div class="children"><div class="content">I find homomorphic encryption fascinating as it can in some sense move a simulation into an inaccessible parallel universe.</div><br/><div id="41115085" class="c"><input type="checkbox" id="c-41115085" checked=""/><div class="controls bullet"><span class="by">Jerrrrrrry</span><span>|</span><a href="#41112955">parent</a><span>|</span><a href="#41113719">next</a><span>|</span><label class="collapse" for="c-41115085">[-]</label><label class="expand" for="c-41115085">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  move a simulation into an inaccessible parallel universe.<p>more like, &quot;move a computation into an progressed, but still unknown, state&quot;</div><br/></div></div></div></div><div id="41113719" class="c"><input type="checkbox" id="c-41113719" checked=""/><div class="controls bullet"><span class="by">tpurves</span><span>|</span><a href="#41112955">prev</a><span>|</span><a href="#41113587">next</a><span>|</span><label class="collapse" for="c-41113719">[-]</label><label class="expand" for="c-41113719">[1 more]</label></div><br/><div class="children"><div class="content">Anyone interested in FHE should also be checking out <a href="https:&#x2F;&#x2F;www.zama.ai" rel="nofollow">https:&#x2F;&#x2F;www.zama.ai</a> they&#x27;ve made a ton of progress recently in making FHE practical.</div><br/></div></div><div id="41113587" class="c"><input type="checkbox" id="c-41113587" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#41113719">prev</a><span>|</span><a href="#41112344">next</a><span>|</span><label class="collapse" for="c-41113587">[-]</label><label class="expand" for="c-41113587">[9 more]</label></div><br/><div class="children"><div class="content">The thing that I always want to know with FHE: the gold standard of modern encryption is IND-CCA security. FHE by definition cannot meet that standard (being able to change a ciphertext to have predictable effects on the plaintext is the definition of a chosen ciphertext attack). So how close do modern FHE schemes get? ie how much security am I sacrificing to get the FHE goodness?</div><br/><div id="41114265" class="c"><input type="checkbox" id="c-41114265" checked=""/><div class="controls bullet"><span class="by">GTP</span><span>|</span><a href="#41113587">parent</a><span>|</span><a href="#41114395">next</a><span>|</span><label class="collapse" for="c-41114265">[-]</label><label class="expand" for="c-41114265">[3 more]</label></div><br/><div class="children"><div class="content">Is the used scheme <i>fully</i> homomorphic encryption or just homomorphic wrt a specific operation? Because they only mention &quot;homomorphic&quot; without the &quot;fully&quot;.</div><br/><div id="41115293" class="c"><input type="checkbox" id="c-41115293" checked=""/><div class="controls bullet"><span class="by">fboemer</span><span>|</span><a href="#41113587">root</a><span>|</span><a href="#41114265">parent</a><span>|</span><a href="#41114395">next</a><span>|</span><label class="collapse" for="c-41115293">[-]</label><label class="expand" for="c-41115293">[2 more]</label></div><br/><div class="children"><div class="content">Swift Homomorphic Encryption implements the Brakerski-Fan-Vercauteren (BFV) HE scheme (<a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2012&#x2F;078" rel="nofollow">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2012&#x2F;078</a>, <a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2012&#x2F;144" rel="nofollow">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2012&#x2F;144</a>) (without bootstrapping). This is a leveled HE scheme, which supports a limited number of encrypted adds and multiplies (among other operations).<p>[Disclosure: I work on the team responsible for the feature]</div><br/><div id="41116802" class="c"><input type="checkbox" id="c-41116802" checked=""/><div class="controls bullet"><span class="by">Jommi</span><span>|</span><a href="#41113587">root</a><span>|</span><a href="#41115293">parent</a><span>|</span><a href="#41114395">next</a><span>|</span><label class="collapse" for="c-41116802">[-]</label><label class="expand" for="c-41116802">[1 more]</label></div><br/><div class="children"><div class="content">That’s awesome. I’m part of a cryptography group working on more applied uses of homomorphic encryption, is there a way to contact you?</div><br/></div></div></div></div></div></div><div id="41114395" class="c"><input type="checkbox" id="c-41114395" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41113587">parent</a><span>|</span><a href="#41114265">prev</a><span>|</span><a href="#41112344">next</a><span>|</span><label class="collapse" for="c-41114395">[-]</label><label class="expand" for="c-41114395">[5 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t attain IND-CCA2 (adaptively choosing cyphertexts based on previous decryptions). You can attain IND-CCA1 (after a decryption oracle, you&#x27;re done fiddling with the system).</div><br/><div id="41114511" class="c"><input type="checkbox" id="c-41114511" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#41113587">root</a><span>|</span><a href="#41114395">parent</a><span>|</span><a href="#41112344">next</a><span>|</span><label class="collapse" for="c-41114511">[-]</label><label class="expand" for="c-41114511">[4 more]</label></div><br/><div class="children"><div class="content">Right, but IND-CCA1 is kind of a toy security goal though. A sort theoretical consolation prize if you can’t achieve the real thing. And AFAICT, no actually implemented schemes do obtain even CCA1?</div><br/><div id="41115439" class="c"><input type="checkbox" id="c-41115439" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41113587">root</a><span>|</span><a href="#41114511">parent</a><span>|</span><a href="#41112344">next</a><span>|</span><label class="collapse" for="c-41115439">[-]</label><label class="expand" for="c-41115439">[3 more]</label></div><br/><div class="children"><div class="content">Sure, but that&#x27;s &quot;how much security you&#x27;re sacrificing to get the FHE goodness,&quot; and, as always in crypto systems, implementations might not be that good.<p>&gt; A sort theoretical consolation prize if you can’t achieve the real thing<p>The real thing exists largely because it makes proofs easier. For something like FHE you can bolt on some extra user-space features to build something like IND-vCCA (your decryption oracle refuses to operate if the result was not obtained by executing the right algorithm on the right ciphertext), which may or may not make FHE suitable for this or that target application. It&#x27;s not a weak property though.</div><br/><div id="41116730" class="c"><input type="checkbox" id="c-41116730" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#41113587">root</a><span>|</span><a href="#41115439">parent</a><span>|</span><a href="#41112344">next</a><span>|</span><label class="collapse" for="c-41116730">[-]</label><label class="expand" for="c-41116730">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The real thing exists largely because it makes proofs easier.<p>I would not say that. It exists because practical padding oracle attacks (which are adaptive CCA) have been known for decades. CCA2 very much captures real-world attacks. Is there any realistic attack that is captured by CCA1? (Or vCCA).<p>Padding oracle attacks also generalise to any kind of parsing after decryption. Padding tends to be studied because it is independent of any particular format&#x2F;application and also part of several encryption scheme definitions. The definition of CCA2 captures very realistic scenarios - almost all applications do some parsing after decryption and so are quite likely to reveal an oracle. Would vCCA also capture such attacks?</div><br/><div id="41117302" class="c"><input type="checkbox" id="c-41117302" checked=""/><div class="controls bullet"><span class="by">MzxgckZtNqX5i</span><span>|</span><a href="#41113587">root</a><span>|</span><a href="#41116730">parent</a><span>|</span><a href="#41112344">next</a><span>|</span><label class="collapse" for="c-41117302">[-]</label><label class="expand" for="c-41117302">[1 more]</label></div><br/><div class="children"><div class="content">While it might not provide a direct answer to your question, this paper could be an interesting read: <a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2021&#x2F;1624" rel="nofollow">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2021&#x2F;1624</a>.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41112344" class="c"><input type="checkbox" id="c-41112344" checked=""/><div class="controls bullet"><span class="by">bluedevilzn</span><span>|</span><a href="#41113587">prev</a><span>|</span><a href="#41112990">next</a><span>|</span><label class="collapse" for="c-41112344">[-]</label><label class="expand" for="c-41112344">[17 more]</label></div><br/><div class="children"><div class="content">This must be the first real world use case of HE. It has generally been considered too slow to do anything useful but this is an excellent use case.</div><br/><div id="41112808" class="c"><input type="checkbox" id="c-41112808" checked=""/><div class="controls bullet"><span class="by">osaariki</span><span>|</span><a href="#41112344">parent</a><span>|</span><a href="#41112776">next</a><span>|</span><label class="collapse" for="c-41112808">[-]</label><label class="expand" for="c-41112808">[5 more]</label></div><br/><div class="children"><div class="content">Edge&#x27;s Password Monitor feature uses homomorphic encryption to match passwords against a database of leaks without revealing anything about those passwords: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;blog&#x2F;password-monitor-safeguarding-passwords-in-microsoft-edge&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;blog&#x2F;password-monit...</a> So not the first, but definitely cool to see more adoption!</div><br/><div id="41113892" class="c"><input type="checkbox" id="c-41113892" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#41112344">root</a><span>|</span><a href="#41112808">parent</a><span>|</span><a href="#41112964">next</a><span>|</span><label class="collapse" for="c-41113892">[-]</label><label class="expand" for="c-41113892">[1 more]</label></div><br/><div class="children"><div class="content">This is nicer than the k-anonymity algorithm that Have I Been Pwned uses, but probably an order of magnitude more expensive to run.</div><br/></div></div><div id="41112964" class="c"><input type="checkbox" id="c-41112964" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#41112344">root</a><span>|</span><a href="#41112808">parent</a><span>|</span><a href="#41113892">prev</a><span>|</span><a href="#41112776">next</a><span>|</span><label class="collapse" for="c-41112964">[-]</label><label class="expand" for="c-41112964">[3 more]</label></div><br/><div class="children"><div class="content">I believe Safari does the same as well, so not even technically the first at Apple if I’m correct?</div><br/><div id="41113288" class="c"><input type="checkbox" id="c-41113288" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41112344">root</a><span>|</span><a href="#41112964">parent</a><span>|</span><a href="#41112776">next</a><span>|</span><label class="collapse" for="c-41113288">[-]</label><label class="expand" for="c-41113288">[2 more]</label></div><br/><div class="children"><div class="content">After reading the technical details... I&#x27;m really not sure tbh: <a href="https:&#x2F;&#x2F;support.apple.com&#x2F;guide&#x2F;security&#x2F;password-monitoring-sec78e79fc3b&#x2F;1&#x2F;web&#x2F;1" rel="nofollow">https:&#x2F;&#x2F;support.apple.com&#x2F;guide&#x2F;security&#x2F;password-monitoring...</a><p>I&#x27;m sure someone here understands that and can answer conclusively, but that&#x27;s not me today.</div><br/><div id="41115639" class="c"><input type="checkbox" id="c-41115639" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#41112344">root</a><span>|</span><a href="#41113288">parent</a><span>|</span><a href="#41112776">next</a><span>|</span><label class="collapse" for="c-41115639">[-]</label><label class="expand" for="c-41115639">[1 more]</label></div><br/><div class="children"><div class="content">No, the Apple article says that they&#x27;re using the much faster and easier to implement k-anonymity strategy</div><br/></div></div></div></div></div></div></div></div><div id="41112776" class="c"><input type="checkbox" id="c-41112776" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41112344">parent</a><span>|</span><a href="#41112808">prev</a><span>|</span><a href="#41115629">next</a><span>|</span><label class="collapse" for="c-41112776">[-]</label><label class="expand" for="c-41112776">[6 more]</label></div><br/><div class="children"><div class="content">I tried to look homomorphic encryption up casually earlier this year. I saw references that it was being used, but I don’t think they said where.<p>This is one topic I have a very hard time with, I just don’t know enough math to really grok it.<p>It just seems crazy a system could operate on encrypted data (which is effectively random noise from the server’s point of view) and return a result that is correctly calculated and encrypted for the client, despite never understanding the data at any point.<p>I sort of understand the theory (at a very simple level) but my brain doesn’t want to agree.</div><br/><div id="41113083" class="c"><input type="checkbox" id="c-41113083" checked=""/><div class="controls bullet"><span class="by">oblvious-earth</span><span>|</span><a href="#41112344">root</a><span>|</span><a href="#41112776">parent</a><span>|</span><a href="#41113339">next</a><span>|</span><label class="collapse" for="c-41113083">[-]</label><label class="expand" for="c-41113083">[1 more]</label></div><br/><div class="children"><div class="content">Maybe it’s the fact it can be done with multiple operators and strong encryption that is hard to grok, but at least here is a very simple example of a limited partially homomorphic encryption:<p>You have a 7-bit character representation (e.g. ASCII) and your encryption is to add 1 mod 128. E.g. 0 -&gt; 1, 1 -&gt; 2, ... 126 -&gt; 127, 127 -&gt; 0.<p>As it turns out, all your operations can be represented as adding or subtracting constants. You can now encrypt your data (+1), send it to a remote server, send all the adding and subtracting operations, pull back the processed data, decrypt the data (-1).<p>Of course, this example is neither useful encryption nor generally useful operation, but can be useful for grokking why it might be possible.</div><br/></div></div><div id="41113339" class="c"><input type="checkbox" id="c-41113339" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#41112344">root</a><span>|</span><a href="#41112776">parent</a><span>|</span><a href="#41113083">prev</a><span>|</span><a href="#41112860">next</a><span>|</span><label class="collapse" for="c-41113339">[-]</label><label class="expand" for="c-41113339">[3 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s say I want you to add two numbers, but I don&#x27;t want you to know what those numbers are, nor what the result is. What I can do is multiply both numbers by some other number you don&#x27;t know. I then give you the premultiplied numbers, you add them, and give back a premultiplied answer. I can then divide out the number to get the true result.<p>What we&#x27;ve done here is this:<p>(a * key) + (b * key) = (c * key)<p>The rules of elementary algebra allow us to divide out the key on both sides because of a few useful symmetries that addition and multiplication have. Namely, these two equations are always the same number:<p>(a + b) * key = (a * key) + (b * key)<p>This is known as the distributive property. Normally, we talk about it applying to numbers being added and multiplied, but there are plenty of other mathematical structures and pairs of operations that do this, too. In the language of abstract algebra, we call any number system and pair of operations that distribute like this a &quot;field&quot;, of which addition and multiplication over real[0] numbers is just one of.<p>A simple example of a field that isn&#x27;t the normal number system you&#x27;re used to is a &#x27;finite field&#x27;. To visualize these, imagine a number <i>circle</i> instead of a line. We get a finite field by chopping off the number line at some prime[1] number that we decide is the highest in the loop. But this is still a field: addition and multiplication keep distributing.<p>It turns out cryptography <i>loves</i> using finite fields, so a lot of these identities hold in various cryptosystems. If I encrypt some data with RSA, which is just a pair of finite field exponents, multiplying that encrypted data will multiply the result when I decrypt it later on. In normal crypto, this is an attack we have to defend against, but in homomorphic crypto we want to deliberately design systems that allow manipulation of encrypted data like this in ways we approve of.<p>[0] Also complex numbers.<p>[1] Yes, it has to be prime and I&#x27;m unable to find a compact explanation as to why, I assume all the symmetries of algebra we&#x27;re used to stop working if it&#x27;s not.</div><br/><div id="41116150" class="c"><input type="checkbox" id="c-41116150" checked=""/><div class="controls bullet"><span class="by">innermatrix</span><span>|</span><a href="#41112344">root</a><span>|</span><a href="#41113339">parent</a><span>|</span><a href="#41115159">next</a><span>|</span><label class="collapse" for="c-41116150">[-]</label><label class="expand" for="c-41116150">[1 more]</label></div><br/><div class="children"><div class="content">Finite fields have multiplicative inverse only if the base is a prime, and that&#x27;s what makes the rest of your usual algebra work (or not).<p>For example, for N = 5, 0 * 2 = 2, 1 * 2 = 2, 2 * 2 = 4, 3 * 2 = 1, 4 * 2 = 3, so the inverse of &quot;* 2&quot; is uniquely defined. On the other hand, for N = 4, 0 * 2 = 0, 1 * 2 = 2, 2 * 2 = 4, 3 * 2 = 2, so the inverse of &quot;* 2&quot; is not uniquely defined.</div><br/></div></div><div id="41115159" class="c"><input type="checkbox" id="c-41115159" checked=""/><div class="controls bullet"><span class="by">rozap</span><span>|</span><a href="#41112344">root</a><span>|</span><a href="#41113339">parent</a><span>|</span><a href="#41116150">prev</a><span>|</span><a href="#41112860">next</a><span>|</span><label class="collapse" for="c-41115159">[-]</label><label class="expand" for="c-41115159">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, this is a nice explanation. Appreciate the clarity.</div><br/></div></div></div></div></div></div><div id="41115629" class="c"><input type="checkbox" id="c-41115629" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#41112344">parent</a><span>|</span><a href="#41112776">prev</a><span>|</span><a href="#41116107">next</a><span>|</span><label class="collapse" for="c-41115629">[-]</label><label class="expand" for="c-41115629">[1 more]</label></div><br/><div class="children"><div class="content">Second: Google Recaptcha Enterprise can use Homomorphic Encryption to check whether your password has been compromised (searching the set of all breached passwords without disclosing which individual password you want to check)<p>Now, in practice, HaveIBeenPwned does the exact same thing with a k-anonymity scheme based off of MD5 collisions, which is wayyyy easier in practice and what most people actually deploy, but the Google thing is cool too.</div><br/></div></div><div id="41116107" class="c"><input type="checkbox" id="c-41116107" checked=""/><div class="controls bullet"><span class="by">glenngillen</span><span>|</span><a href="#41112344">parent</a><span>|</span><a href="#41115629">prev</a><span>|</span><a href="#41112887">next</a><span>|</span><label class="collapse" for="c-41116107">[-]</label><label class="expand" for="c-41116107">[1 more]</label></div><br/><div class="children"><div class="content">I believe Cipherstash is using HE to do what they do: <a href="https:&#x2F;&#x2F;cipherstash.com" rel="nofollow">https:&#x2F;&#x2F;cipherstash.com</a></div><br/></div></div><div id="41112887" class="c"><input type="checkbox" id="c-41112887" checked=""/><div class="controls bullet"><span class="by">7e</span><span>|</span><a href="#41112344">parent</a><span>|</span><a href="#41116107">prev</a><span>|</span><a href="#41112888">next</a><span>|</span><label class="collapse" for="c-41112887">[-]</label><label class="expand" for="c-41112887">[2 more]</label></div><br/><div class="children"><div class="content">A TEE would be a cheaper and more straightforward solution, though.</div><br/><div id="41113957" class="c"><input type="checkbox" id="c-41113957" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41112344">root</a><span>|</span><a href="#41112887">parent</a><span>|</span><a href="#41112888">next</a><span>|</span><label class="collapse" for="c-41113957">[-]</label><label class="expand" for="c-41113957">[1 more]</label></div><br/><div class="children"><div class="content">They also mean if you break the TEE then your privacy guarantees are lost. This, of course, has happened many times.</div><br/></div></div></div></div></div></div><div id="41112990" class="c"><input type="checkbox" id="c-41112990" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#41112344">prev</a><span>|</span><a href="#41115465">next</a><span>|</span><label class="collapse" for="c-41112990">[-]</label><label class="expand" for="c-41112990">[1 more]</label></div><br/><div class="children"><div class="content">This is hugely significant (long-term), that won&#x27;t be felt immediately.<p>This is a massive announcement for AI and use cases related to PII.</div><br/></div></div><div id="41115465" class="c"><input type="checkbox" id="c-41115465" checked=""/><div class="controls bullet"><span class="by">yalogin</span><span>|</span><a href="#41112990">prev</a><span>|</span><a href="#41112467">next</a><span>|</span><label class="collapse" for="c-41115465">[-]</label><label class="expand" for="c-41115465">[4 more]</label></div><br/><div class="children"><div class="content">FHE is cool but I wonder how many use cases it actually fits. Don’t get me wrong, it gives better security guarantees for the end user but do they really care if the organization makes a promise about a secure execution environment in the cloud?<p>Also from an engineering point of view, using FHE requires a refactoring of flows and an inflexible commitment to all processing downstream. Without laws mandating it, do organizations have enough motivation to do that?</div><br/><div id="41117014" class="c"><input type="checkbox" id="c-41117014" checked=""/><div class="controls bullet"><span class="by">kybernetikos</span><span>|</span><a href="#41115465">parent</a><span>|</span><a href="#41116176">next</a><span>|</span><label class="collapse" for="c-41117014">[-]</label><label class="expand" for="c-41117014">[1 more]</label></div><br/><div class="children"><div class="content">I think the main thing that throws it into question is when you get the software that sends the data to the service and the service from the same people (in this case apple). You&#x27;re already trusting them with your data, and a fancy HE scheme doesn&#x27;t change that. They can update their software and start sending everything in plain text and you wouldn&#x27;t even realise they&#x27;d done it.<p>FHE is plausibly most useful when you trust the source of the client code but want to use the compute resource of an organisation you don&#x27;t want to have to trust.</div><br/></div></div><div id="41116176" class="c"><input type="checkbox" id="c-41116176" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#41115465">parent</a><span>|</span><a href="#41117014">prev</a><span>|</span><a href="#41115597">next</a><span>|</span><label class="collapse" for="c-41116176">[-]</label><label class="expand" for="c-41116176">[1 more]</label></div><br/><div class="children"><div class="content">I assume companies like it because it lets them compute on servers they don&#x27;t trust. The corollary is they don&#x27;t need to secure HE servers as much because any data the servers lose isn&#x27;t valuable. And the corollary to that is that companies can have much more flexible compute infra, sending HE requests to arbitrary machines instead of only those that are known to be highly secure.</div><br/></div></div><div id="41115597" class="c"><input type="checkbox" id="c-41115597" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#41115465">parent</a><span>|</span><a href="#41116176">prev</a><span>|</span><a href="#41112467">next</a><span>|</span><label class="collapse" for="c-41115597">[-]</label><label class="expand" for="c-41115597">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but do they really care if the organization makes a promise about a secure execution environment in the cloud?<p>Uh... demonstrably yes? No &quot;secure execution environment&quot; is secure against a government wiretap order. FHE is.</div><br/></div></div></div></div><div id="41112467" class="c"><input type="checkbox" id="c-41112467" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#41115465">prev</a><span>|</span><a href="#41115172">next</a><span>|</span><label class="collapse" for="c-41112467">[-]</label><label class="expand" for="c-41112467">[16 more]</label></div><br/><div class="children"><div class="content">The name is hilarious because HME is anything but speedy -- by many orders of magnitude.<p>I think the real fix is secure enclaves, and those have proven to be difficult as well.</div><br/><div id="41112613" class="c"><input type="checkbox" id="c-41112613" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41112467">parent</a><span>|</span><a href="#41112894">next</a><span>|</span><label class="collapse" for="c-41112613">[-]</label><label class="expand" for="c-41112613">[8 more]</label></div><br/><div class="children"><div class="content">&gt; I think the real fix is secure enclaves<p>FTA: <i>“Live Caller ID Lookup uses homomorphic encryption to send an encrypted query to a server that can provide information about a phone number without the server knowing the specific phone number in the request”</i><p>So, this would require a distributed Secure Enclave or one of them on Apple’s server communicating with one on an Apple device (likely, certainly over time, with lots of different Apple devices fo lots of different iCloud accounts)</div><br/><div id="41113349" class="c"><input type="checkbox" id="c-41113349" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#41112467">root</a><span>|</span><a href="#41112613">parent</a><span>|</span><a href="#41112894">next</a><span>|</span><label class="collapse" for="c-41113349">[-]</label><label class="expand" for="c-41113349">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see why it would?  IIUC, the promise of homomorphic encryption is that I can encrypt my database of contacts and send it to an untrusted server, later send the encrypted query to that untrusted server, and get back an encrypted response, without the server being able to tell anything that couldn&#x27;t be told from the wire (some bounds on how much data, timing of communication, that sort of thing) or provide an incorrect answer.</div><br/><div id="41113551" class="c"><input type="checkbox" id="c-41113551" checked=""/><div class="controls bullet"><span class="by">tempay</span><span>|</span><a href="#41112467">root</a><span>|</span><a href="#41113349">parent</a><span>|</span><a href="#41112894">next</a><span>|</span><label class="collapse" for="c-41113551">[-]</label><label class="expand" for="c-41113551">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the use case mentioned here. The example given is blocking known spam callers and displaying identity information on the incoming call screen. To do this without homomorphic encryption requires the entire DB to be sent to every client. Even if size wasn&#x27;t an issue (which it is), it&#x27;s hard to update it frequently.<p>Homomorphic encryption means you can ask Apple &quot;who is calling me&quot; without Apple knowing who is calling you.</div><br/><div id="41116992" class="c"><input type="checkbox" id="c-41116992" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#41112467">root</a><span>|</span><a href="#41113551">parent</a><span>|</span><a href="#41113816">next</a><span>|</span><label class="collapse" for="c-41116992">[-]</label><label class="expand" for="c-41116992">[1 more]</label></div><br/><div class="children"><div class="content">Ah, interesting.  Yeah, they seem to point at &quot;Private Information Retrieval&quot; but I don&#x27;t see where they explain how they do it?  I see some mention of &quot;cleartext inputs&quot; and I guess if you can do that you can pass the whole DB that way?  That sounds expensive, but I think if you want to actually keep the number completely confidential it has to touch every record - otherwise you could look at the access pattern...</div><br/></div></div><div id="41113816" class="c"><input type="checkbox" id="c-41113816" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41112467">root</a><span>|</span><a href="#41113551">parent</a><span>|</span><a href="#41116992">prev</a><span>|</span><a href="#41112894">next</a><span>|</span><label class="collapse" for="c-41113816">[-]</label><label class="expand" for="c-41113816">[4 more]</label></div><br/><div class="children"><div class="content">Not really. You could do it the way the Have I Been Pwned database works.<p>You hash your query and then send only the first X number of bits.<p>The server returns all results that hash up to that same first X number of bits.<p>The server doesn’t know exactly what number you were looking for, and you don’t have to download the entire database.<p>But in this case the server WOULD be able to figure out the set of possible phone numbers you were asking about. Because of the complexity of passwords the search space would be a lot larger.<p>So privacy wise this does seem better.</div><br/><div id="41114174" class="c"><input type="checkbox" id="c-41114174" checked=""/><div class="controls bullet"><span class="by">tempay</span><span>|</span><a href="#41112467">root</a><span>|</span><a href="#41113816">parent</a><span>|</span><a href="#41112894">next</a><span>|</span><label class="collapse" for="c-41114174">[-]</label><label class="expand" for="c-41114174">[3 more]</label></div><br/><div class="children"><div class="content">Indeed, I wasn&#x27;t clear enough in my original message that it was under the assumption that you want to keep the caller 100% private from Apple.<p>Though there is a valid argument that you&#x27;re still leaking information (e.g. &quot;Person X received a call at 21:05:43&quot;), but I&#x27;m not sure how you could possibly make an API that avoided that given the time sensitive nature of identifying callers.</div><br/><div id="41117474" class="c"><input type="checkbox" id="c-41117474" checked=""/><div class="controls bullet"><span class="by">Cyphase</span><span>|</span><a href="#41112467">root</a><span>|</span><a href="#41114174">parent</a><span>|</span><a href="#41115312">next</a><span>|</span><label class="collapse" for="c-41117474">[-]</label><label class="expand" for="c-41117474">[1 more]</label></div><br/><div class="children"><div class="content">The client can constantly and at random intervals make lots of chaff queries to the API, so the service doesn&#x27;t know which are real calls and which aren&#x27;t.  The client knows it&#x27;s incoming calls history, so it can make sure it&#x27;s chaff queries are statistically convincing.<p>For instance, if you often receive a call at the same time of day, that could be a detectable signal in the noise, unless the client then creates a lot of similar fake signals in the noise.</div><br/></div></div><div id="41115312" class="c"><input type="checkbox" id="c-41115312" checked=""/><div class="controls bullet"><span class="by">fboemer</span><span>|</span><a href="#41112467">root</a><span>|</span><a href="#41114174">parent</a><span>|</span><a href="#41117474">prev</a><span>|</span><a href="#41112894">next</a><span>|</span><label class="collapse" for="c-41115312">[-]</label><label class="expand" for="c-41115312">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;sms_and_call_reporting&#x2F;understanding_how_live_caller_id_lookup_preserves_privacy" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;sms_and_call_repor...</a> has some more details on privacy in Live Caller ID Lookup.<p>[Disclosure: I work on the team responsible for the feature]</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41112894" class="c"><input type="checkbox" id="c-41112894" checked=""/><div class="controls bullet"><span class="by">shortstuffsushi</span><span>|</span><a href="#41112467">parent</a><span>|</span><a href="#41112613">prev</a><span>|</span><a href="#41115361">next</a><span>|</span><label class="collapse" for="c-41112894">[-]</label><label class="expand" for="c-41112894">[2 more]</label></div><br/><div class="children"><div class="content">I think Swift in this case is just referring to the programming language, Swift, and not a characteristic of the encryption library itself</div><br/><div id="41113318" class="c"><input type="checkbox" id="c-41113318" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#41112467">root</a><span>|</span><a href="#41112894">parent</a><span>|</span><a href="#41115361">next</a><span>|</span><label class="collapse" for="c-41113318">[-]</label><label class="expand" for="c-41113318">[1 more]</label></div><br/><div class="children"><div class="content">Right, but that doesn&#x27;t make it not funny.</div><br/></div></div></div></div><div id="41115361" class="c"><input type="checkbox" id="c-41115361" checked=""/><div class="controls bullet"><span class="by">karulont</span><span>|</span><a href="#41112467">parent</a><span>|</span><a href="#41112894">prev</a><span>|</span><a href="#41114014">next</a><span>|</span><label class="collapse" for="c-41115361">[-]</label><label class="expand" for="c-41115361">[1 more]</label></div><br/><div class="children"><div class="content">There was a recent paper that also uses Swift in the name:<p>“Cheddar: A Swift Fully Homomorphic Encryption Library for CUDA GPUs” - <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2407.13055" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2407.13055</a><p>We were a little worried, but quickly discovered that they used Swift as an adjective not as a programming language.<p>[Disclosure: I work on the team responsible for the feature]</div><br/></div></div><div id="41114014" class="c"><input type="checkbox" id="c-41114014" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41112467">parent</a><span>|</span><a href="#41115361">prev</a><span>|</span><a href="#41113482">next</a><span>|</span><label class="collapse" for="c-41114014">[-]</label><label class="expand" for="c-41114014">[1 more]</label></div><br/><div class="children"><div class="content">Its like high-temperature super conductors, its all relative.</div><br/></div></div><div id="41113482" class="c"><input type="checkbox" id="c-41113482" checked=""/><div class="controls bullet"><span class="by">ganyu</span><span>|</span><a href="#41112467">parent</a><span>|</span><a href="#41114014">prev</a><span>|</span><a href="#41112975">next</a><span>|</span><label class="collapse" for="c-41113482">[-]</label><label class="expand" for="c-41113482">[2 more]</label></div><br/><div class="children"><div class="content">At least 10^4 times slower than raw code, i think<p>That makes HE anything but Swift (</div><br/></div></div><div id="41112975" class="c"><input type="checkbox" id="c-41112975" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41112467">parent</a><span>|</span><a href="#41113482">prev</a><span>|</span><a href="#41115172">next</a><span>|</span><label class="collapse" for="c-41112975">[-]</label><label class="expand" for="c-41112975">[1 more]</label></div><br/><div class="children"><div class="content">I didn’t look at domain at first and ended up being quite disappointed. :)</div><br/></div></div></div></div><div id="41115172" class="c"><input type="checkbox" id="c-41115172" checked=""/><div class="controls bullet"><span class="by">motohagiography</span><span>|</span><a href="#41112467">prev</a><span>|</span><a href="#41114966">next</a><span>|</span><label class="collapse" for="c-41115172">[-]</label><label class="expand" for="c-41115172">[2 more]</label></div><br/><div class="children"><div class="content">great to see this becoming part of mainstream tools. the question I have is,  when a weakness is published in FHE, is it more like a hash function you can do some transformations on, but there is no &#x27;decryption&#x27; to recover plaintext again- or is it more like a symmetric cipher, where all your old ciphertexts can be cracked, but now your FHE data sets are no longer considered secure or private and need to be re-generated from their plaintexts with the updated version?<p>what is the failure mode of FHE and how does it recover?</div><br/><div id="41116183" class="c"><input type="checkbox" id="c-41116183" checked=""/><div class="controls bullet"><span class="by">j2kun</span><span>|</span><a href="#41115172">parent</a><span>|</span><a href="#41114966">next</a><span>|</span><label class="collapse" for="c-41116183">[-]</label><label class="expand" for="c-41116183">[1 more]</label></div><br/><div class="children"><div class="content">It is more like a symmetric cipher. Once you have a key you can decrypt everything encrypted with that key</div><br/></div></div></div></div><div id="41114966" class="c"><input type="checkbox" id="c-41114966" checked=""/><div class="controls bullet"><span class="by">lsh123</span><span>|</span><a href="#41115172">prev</a><span>|</span><a href="#41115233">next</a><span>|</span><label class="collapse" for="c-41114966">[-]</label><label class="expand" for="c-41114966">[14 more]</label></div><br/><div class="children"><div class="content">If we assume that server is “evil” then the server can store both PIR encrypted and plain text phone number in the same row in the database and when this row is read, simply log plain text phone number. What do I miss here? We can send PIR request and trust server not to do the above; or we can send plain text phone number and trust server not to log it — what’s the difference?</div><br/><div id="41115179" class="c"><input type="checkbox" id="c-41115179" checked=""/><div class="controls bullet"><span class="by">karulont</span><span>|</span><a href="#41114966">parent</a><span>|</span><a href="#41115062">next</a><span>|</span><label class="collapse" for="c-41115179">[-]</label><label class="expand" for="c-41115179">[4 more]</label></div><br/><div class="children"><div class="content">A very simple PIR scheme on top of homomorphic encryption that supports multiplying with a plaintext and homomorphic addition, would look like this:<p>The client one-hot-encodes the query: Enc(0), Enc(1), Enc(0).
The server has 3 values: x, y, z.
Now the server computes: Enc(0) * x + Enc(1) * y + Enc(0) * z == Enc(y).
Client can decrypt Enc(y) and get the value y. Server received three ciphertexts, but does not know which one of them was encryption of zero or one, because the multiplications and additions that the server did, never leak the underlying value.<p>This gives some intuition on how PIR works, actual schemes are more efficient.<p>[Disclosure: I work on the team responsible for the feature]</div><br/><div id="41115206" class="c"><input type="checkbox" id="c-41115206" checked=""/><div class="controls bullet"><span class="by">lsh123</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115179">parent</a><span>|</span><a href="#41115062">next</a><span>|</span><label class="collapse" for="c-41115206">[-]</label><label class="expand" for="c-41115206">[3 more]</label></div><br/><div class="children"><div class="content">Does the server reads specific rows from spam numbers DB or the whole database?</div><br/><div id="41115272" class="c"><input type="checkbox" id="c-41115272" checked=""/><div class="controls bullet"><span class="by">karulont</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115206">parent</a><span>|</span><a href="#41115062">next</a><span>|</span><label class="collapse" for="c-41115272">[-]</label><label class="expand" for="c-41115272">[2 more]</label></div><br/><div class="children"><div class="content">In this PIR model the server has to read the whole database, otherwise it would be easy on the server to see, that these rows were not accessed and therefore they are not the one the client queried.<p>In this PIR model the server runtime is O(n) where n is the number of rows.<p>To keep it practical, we do support sharding the database. Client leaks a few bits of hashed query to pick the right shard, where we process the entire shard. There is a inherent privacy-performance tradeoff: less shards = less leakage vs more shards = better performance &amp; less privacy.</div><br/><div id="41115323" class="c"><input type="checkbox" id="c-41115323" checked=""/><div class="controls bullet"><span class="by">lsh123</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115272">parent</a><span>|</span><a href="#41115062">next</a><span>|</span><label class="collapse" for="c-41115323">[-]</label><label class="expand" for="c-41115323">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for explanation. I will read the code to see how sharing works.</div><br/></div></div></div></div></div></div></div></div><div id="41115062" class="c"><input type="checkbox" id="c-41115062" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41114966">parent</a><span>|</span><a href="#41115179">prev</a><span>|</span><a href="#41115079">next</a><span>|</span><label class="collapse" for="c-41115062">[-]</label><label class="expand" for="c-41115062">[6 more]</label></div><br/><div class="children"><div class="content">The server never gets the plaintext at all.  It only ever receives encrypted data that it cannot read.</div><br/><div id="41115087" class="c"><input type="checkbox" id="c-41115087" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115062">parent</a><span>|</span><a href="#41115079">next</a><span>|</span><label class="collapse" for="c-41115087">[-]</label><label class="expand" for="c-41115087">[5 more]</label></div><br/><div class="children"><div class="content">I think OP is talking about the set of “spam phone numbers” stored on the server and looking at side channels based on what data is looked up by processing the query.</div><br/><div id="41115090" class="c"><input type="checkbox" id="c-41115090" checked=""/><div class="controls bullet"><span class="by">lsh123</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115087">parent</a><span>|</span><a href="#41115079">next</a><span>|</span><label class="collapse" for="c-41115090">[-]</label><label class="expand" for="c-41115090">[4 more]</label></div><br/><div class="children"><div class="content">Exactly, plain text phone number in the same db row</div><br/><div id="41115135" class="c"><input type="checkbox" id="c-41115135" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115090">parent</a><span>|</span><a href="#41115121">next</a><span>|</span><label class="collapse" for="c-41115135">[-]</label><label class="expand" for="c-41115135">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if its implemented exactly like this but one could imagine that the server must use the client&#x27;s public key to encrypt the database into a blob it can&#x27;t decrypt.  The encrypted input is used to read the encrypted blob in a way the server can&#x27;t understand to construct a result the server cannot understand.  The result blob is sent to the client which <i>can</i> decrypt it.</div><br/></div></div><div id="41115121" class="c"><input type="checkbox" id="c-41115121" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115090">parent</a><span>|</span><a href="#41115135">prev</a><span>|</span><a href="#41115079">next</a><span>|</span><label class="collapse" for="c-41115121">[-]</label><label class="expand" for="c-41115121">[2 more]</label></div><br/><div class="children"><div class="content">Yeah but as I wrote elsewhere, the DB isn’t a KV store of plain text numbers and their encrypted representation. Instead the entire database would be encrypted and you’d do set containment operations in encrypted space which wouldn’t &#x2F;couldn’t leak anything about your query (modulo unexpected side channels in the design).<p>I don’t know how they do this efficiently and at scale with lots of updates, but maybe this database is kinda small to begin with anyway and the updates are reasonably cheap to process relative to how many spam numbers are out there.</div><br/><div id="41115219" class="c"><input type="checkbox" id="c-41115219" checked=""/><div class="controls bullet"><span class="by">lsh123</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115121">parent</a><span>|</span><a href="#41115079">next</a><span>|</span><label class="collapse" for="c-41115219">[-]</label><label class="expand" for="c-41115219">[1 more]</label></div><br/><div class="children"><div class="content">That’s not what I saw in the code but I didn’t spend much time so I might be wrong. I’ll check it more carefully later. But if this indeed is whole DB then it’s very limited use case.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41115079" class="c"><input type="checkbox" id="c-41115079" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41114966">parent</a><span>|</span><a href="#41115062">prev</a><span>|</span><a href="#41115233">next</a><span>|</span><label class="collapse" for="c-41115079">[-]</label><label class="expand" for="c-41115079">[3 more]</label></div><br/><div class="children"><div class="content">It’s a lot more complicated because the phone numbers themselves are stored encrypted and there’s not a 1:1 mapping between encrypted representation and the mapping. So processing the query is actually blinding the evil server afaik.</div><br/><div id="41115093" class="c"><input type="checkbox" id="c-41115093" checked=""/><div class="controls bullet"><span class="by">lsh123</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115079">parent</a><span>|</span><a href="#41115233">next</a><span>|</span><label class="collapse" for="c-41115093">[-]</label><label class="expand" for="c-41115093">[2 more]</label></div><br/><div class="children"><div class="content">Evil server stores BOTH encrypted and plain text phone number in the same db row</div><br/><div id="41115138" class="c"><input type="checkbox" id="c-41115138" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41114966">root</a><span>|</span><a href="#41115093">parent</a><span>|</span><a href="#41115233">next</a><span>|</span><label class="collapse" for="c-41115138">[-]</label><label class="expand" for="c-41115138">[1 more]</label></div><br/><div class="children"><div class="content">There’s no single encrypted representation of a phone number. Rather the entire database is encrypted and the accesses performed by the HE algorithm would be randomly accessing the database in a way that wouldn’t leak anything. Now of course if you have billions of lookups a day maybe something does end up leaking because you’d be able to extract networks from data patterns (ie if the same number is contacting 100 numbers, the data access patterns might be the same) but it’s a lot more complicated than what you’re proposing and I wouldn’t be surprised if this is explicitly handled in the design of the feature.</div><br/></div></div></div></div></div></div></div></div><div id="41115233" class="c"><input type="checkbox" id="c-41115233" checked=""/><div class="controls bullet"><span class="by">attilakun</span><span>|</span><a href="#41114966">prev</a><span>|</span><a href="#41113555">next</a><span>|</span><label class="collapse" for="c-41115233">[-]</label><label class="expand" for="c-41115233">[2 more]</label></div><br/><div class="children"><div class="content">Is there a good primer that explains the math basis of this?</div><br/><div id="41116186" class="c"><input type="checkbox" id="c-41116186" checked=""/><div class="controls bullet"><span class="by">j2kun</span><span>|</span><a href="#41115233">parent</a><span>|</span><a href="#41113555">next</a><span>|</span><label class="collapse" for="c-41116186">[-]</label><label class="expand" for="c-41116186">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.jeremykun.com&#x2F;2024&#x2F;05&#x2F;04&#x2F;fhe-overview&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.jeremykun.com&#x2F;2024&#x2F;05&#x2F;04&#x2F;fhe-overview&#x2F;</a></div><br/></div></div></div></div><div id="41113555" class="c"><input type="checkbox" id="c-41113555" checked=""/><div class="controls bullet"><span class="by">ReptileMan</span><span>|</span><a href="#41115233">prev</a><span>|</span><a href="#41113404">next</a><span>|</span><label class="collapse" for="c-41113555">[-]</label><label class="expand" for="c-41113555">[6 more]</label></div><br/><div class="children"><div class="content">What is the processing that the server does on the encrypted phone number? I am not sure I understand. I always thought that this type of encryption was (roughly and imprecisely) - you send some encrypted blob to the server, it does some side effect free number crunching on the blob and returns the output blob. You decrypt the blob and everyone is happy.<p>But to return information if some number is spam it has to be either plaintext or hashed condition somewhere outside of the phone?</div><br/><div id="41115338" class="c"><input type="checkbox" id="c-41115338" checked=""/><div class="controls bullet"><span class="by">fboemer</span><span>|</span><a href="#41113555">parent</a><span>|</span><a href="#41113884">next</a><span>|</span><label class="collapse" for="c-41115338">[-]</label><label class="expand" for="c-41115338">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41115179">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41115179</a> give some intuition.
The server database is stored in plaintext, but the server response will be encrypted under the client&#x27;s key.<p>[Disclosure: I work on the team responsible for the feature]</div><br/></div></div><div id="41113884" class="c"><input type="checkbox" id="c-41113884" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#41113555">parent</a><span>|</span><a href="#41115338">prev</a><span>|</span><a href="#41113404">next</a><span>|</span><label class="collapse" for="c-41113884">[-]</label><label class="expand" for="c-41113884">[4 more]</label></div><br/><div class="children"><div class="content">The &quot;side effect free number crunching&quot; in this case is: is &lt;encrypted_phone_number&gt; in &lt;set_of_encrypted_bad_numbers&gt;<p>You&#x27;re on the right track with the idea of hashing -- I find it helpful to explain any fancy encryption scheme beginning with &quot;if it were just hashing&quot;, then extend to &quot;well this is a very fancy kind of hash&quot;, and &lt;poof&gt; now I kind of understand what&#x27;s going on. Or at least it&#x27;s no longer magic.</div><br/><div id="41113989" class="c"><input type="checkbox" id="c-41113989" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41113555">root</a><span>|</span><a href="#41113884">parent</a><span>|</span><a href="#41113404">next</a><span>|</span><label class="collapse" for="c-41113989">[-]</label><label class="expand" for="c-41113989">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the set of bad numbers needs to be encrypted.</div><br/><div id="41115111" class="c"><input type="checkbox" id="c-41115111" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41113555">root</a><span>|</span><a href="#41113989">parent</a><span>|</span><a href="#41113404">next</a><span>|</span><label class="collapse" for="c-41115111">[-]</label><label class="expand" for="c-41115111">[2 more]</label></div><br/><div class="children"><div class="content">It does - otherwise you would know which numbers are queried to process the query, letting you narrow things down (ie huge side channel and thus not HE anymore).</div><br/><div id="41115193" class="c"><input type="checkbox" id="c-41115193" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41113555">root</a><span>|</span><a href="#41115111">parent</a><span>|</span><a href="#41113404">next</a><span>|</span><label class="collapse" for="c-41115193">[-]</label><label class="expand" for="c-41115193">[1 more]</label></div><br/><div class="children"><div class="content">How so? You can just query all the numbers and discard results you don&#x27;t want.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41113404" class="c"><input type="checkbox" id="c-41113404" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#41113555">prev</a><span>|</span><a href="#41114540">next</a><span>|</span><label class="collapse" for="c-41113404">[-]</label><label class="expand" for="c-41113404">[18 more]</label></div><br/><div class="children"><div class="content">I wrote some basic homomorphic encryption code for a hackathon like 8 years ago.  When I interviewed for a BigTechCo [1] about a year later, the topic came up, and when I tried explaining what homomorphic encryption was to one of the interviewers, he told me that I misunderstood, because it was &quot;impossible&quot; to update encrypted data without decrypting it. I politely tried saying &quot;actually no, that&#x27;s what makes homomorphic encryption super cool&quot;, and we went back and forth; eventually I kind of gave up because I was trying to make a good impression.<p>I did actually get that job, but I found out that that interviewer actually said &quot;no&quot;, I believe because he thought I was wrong about that.<p>[1] My usual disclaimer: It&#x27;s not hard to find my work history, I don&#x27;t hide it, but I politely ask that you do not post it here directly.</div><br/><div id="41114276" class="c"><input type="checkbox" id="c-41114276" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#41113404">parent</a><span>|</span><a href="#41115163">next</a><span>|</span><label class="collapse" for="c-41114276">[-]</label><label class="expand" for="c-41114276">[1 more]</label></div><br/><div class="children"><div class="content">I had the same experience with Python&#x27;s walrus operator [0] in a BigTechCo interview. After few times of the interviewer insisting I had no idea what I was talking about, I wrote it a different way. I can&#x27;t imagine trying explaining something actually complicated in that environment.<p>It didn&#x27;t hold me back from the job either. I like to believe the interviewer looked it up later, but I never poked into my hiring packet.<p>[0] It was useful at the time to have a prefix sum primitive. Ignoring annotations, something like this:<p><pre><code>    def scan(f, items, x):
        return [x := f(x, item) for item in items]</code></pre></div><br/></div></div><div id="41115163" class="c"><input type="checkbox" id="c-41115163" checked=""/><div class="controls bullet"><span class="by">tomlue</span><span>|</span><a href="#41113404">parent</a><span>|</span><a href="#41114276">prev</a><span>|</span><a href="#41114785">next</a><span>|</span><label class="collapse" for="c-41115163">[-]</label><label class="expand" for="c-41115163">[1 more]</label></div><br/><div class="children"><div class="content">This happened to me in a grant application. We had written a web application that did a homomorphic encryption based calculation of molecular weight to demonstrate that HE could be used to build federated learning models for chemical libraries.<p>Our reviewers told us that machine learning on encrypted data was impossible. We had the citations and the working model to refute them. Very frustrating.</div><br/></div></div><div id="41114785" class="c"><input type="checkbox" id="c-41114785" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#41113404">parent</a><span>|</span><a href="#41115163">prev</a><span>|</span><a href="#41114774">next</a><span>|</span><label class="collapse" for="c-41114785">[-]</label><label class="expand" for="c-41114785">[1 more]</label></div><br/><div class="children"><div class="content">This is pretty bad. We learned in school how RSA works, which can be easily extended to show HME multiplication at least. I can&#x27;t remember it off the top of my head, but I know it&#x27;s possible.</div><br/></div></div><div id="41113701" class="c"><input type="checkbox" id="c-41113701" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#41113404">parent</a><span>|</span><a href="#41114774">prev</a><span>|</span><a href="#41115481">next</a><span>|</span><label class="collapse" for="c-41113701">[-]</label><label class="expand" for="c-41113701">[9 more]</label></div><br/><div class="children"><div class="content">Digression-- this is a good example where the mumbo jumbo that anarchists buzz on about applies in a very obvious way.<p>You were literate in that domain. The interviewer wasn&#x27;t. In a conversation among equals you&#x27;d just continue talking until the interviewer yielded (or revealed their narcissism). The other interviewers would then stand educated. You see this process happen all the time on (healthy) FOSS mailing lists.<p>Instead, you had to weigh the benefit of sharing your knowledge against the risk of getting in a pissing contest with someone who had some unspecified (but real!) amount of power over your hiring.<p>That&#x27;s the problem with a power imbalance, and it generally makes humans feel shitty. It&#x27;s also insidious-- in this case you <i>still</i> don&#x27;t know if the interviewer said &quot;no&quot; because they misunderstood homomorphic encryption.<p>Plus it&#x27;s a BigTechCo, so we know they understand why freely sharing knowledge is important-- hell, if we didn&#x27;t do it, nearly none of them would have a business model!</div><br/><div id="41113785" class="c"><input type="checkbox" id="c-41113785" checked=""/><div class="controls bullet"><span class="by">ChadNauseam</span><span>|</span><a href="#41113404">root</a><span>|</span><a href="#41113701">parent</a><span>|</span><a href="#41113821">next</a><span>|</span><label class="collapse" for="c-41113785">[-]</label><label class="expand" for="c-41113785">[2 more]</label></div><br/><div class="children"><div class="content">In my experience this comes up a lot less often when people are paid to be empirically right, and the most annoying arguments occur when no one has an interest in being right and instead wants to defend their status. e.g. try telling a guy with his date nearby that he&#x27;s wrong about something irrelevant like how state alcohol minimum markups work. An even more common scenario is when someone is passionate about a political topic and they publicly say something incorrect, and now would look like a fool if they admitted they were wrong. Sometimes I worry that a post-money future would become entirely dominated by status considerations and there would be no domain where people are actually incentivized to be right. Do you know if there&#x27;s any anarchist thought related to this topic?</div><br/><div id="41115075" class="c"><input type="checkbox" id="c-41115075" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41113404">root</a><span>|</span><a href="#41113785">parent</a><span>|</span><a href="#41113821">next</a><span>|</span><label class="collapse" for="c-41115075">[-]</label><label class="expand" for="c-41115075">[1 more]</label></div><br/><div class="children"><div class="content">That does kind of make sense though - if you are paid to be right but someone doesn&#x27;t believe you, you are still getting paid, so what does it matter?</div><br/></div></div></div></div><div id="41113821" class="c"><input type="checkbox" id="c-41113821" checked=""/><div class="controls bullet"><span class="by">lcnPylGDnU4H9OF</span><span>|</span><a href="#41113404">root</a><span>|</span><a href="#41113701">parent</a><span>|</span><a href="#41113785">prev</a><span>|</span><a href="#41113924">next</a><span>|</span><label class="collapse" for="c-41113821">[-]</label><label class="expand" for="c-41113821">[3 more]</label></div><br/><div class="children"><div class="content">&gt; the mumbo jumbo that anarchists buzz on about<p>I enjoy exposing myself to new-to-me opinions. Do you know a decent anarchist blog&#x2F;vlog to dip my toes into this area?</div><br/><div id="41114317" class="c"><input type="checkbox" id="c-41114317" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#41113404">root</a><span>|</span><a href="#41113821">parent</a><span>|</span><a href="#41114702">next</a><span>|</span><label class="collapse" for="c-41114317">[-]</label><label class="expand" for="c-41114317">[1 more]</label></div><br/><div class="children"><div class="content">Not OP, nor do I understand what he&#x27;s referring to, but <a href="https:&#x2F;&#x2F;theanarchistlibrary.org&#x2F;special&#x2F;index" rel="nofollow">https:&#x2F;&#x2F;theanarchistlibrary.org&#x2F;special&#x2F;index</a> is a good starting point.</div><br/></div></div><div id="41114702" class="c"><input type="checkbox" id="c-41114702" checked=""/><div class="controls bullet"><span class="by">317070</span><span>|</span><a href="#41113404">root</a><span>|</span><a href="#41113821">parent</a><span>|</span><a href="#41114317">prev</a><span>|</span><a href="#41113924">next</a><span>|</span><label class="collapse" for="c-41114702">[-]</label><label class="expand" for="c-41114702">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The Utopia of Rules: On Technology, Stupidity, and the Secret Joys of Bureaucracy&quot;, by David Graeber might be good for this one, though some of Graeber&#x27;s other books also apply.</div><br/></div></div></div></div><div id="41113924" class="c"><input type="checkbox" id="c-41113924" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41113404">root</a><span>|</span><a href="#41113701">parent</a><span>|</span><a href="#41113821">prev</a><span>|</span><a href="#41113970">next</a><span>|</span><label class="collapse" for="c-41113924">[-]</label><label class="expand" for="c-41113924">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In a conversation among equals you&#x27;d just continue talking until the interviewer yielded (or revealed their narcissism). The other interviewers would then stand educated. You see this process happen all the time on (healthy) FOSS mailing lists.<p>Yeah, what actually happens is that both parties think they are right and keep yapping until someone &quot;yields&quot; by being so fed up that they don&#x27;t want to argue anymore. Everyone else watching learns nothing.</div><br/></div></div><div id="41113970" class="c"><input type="checkbox" id="c-41113970" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41113404">root</a><span>|</span><a href="#41113701">parent</a><span>|</span><a href="#41113924">prev</a><span>|</span><a href="#41114621">next</a><span>|</span><label class="collapse" for="c-41113970">[-]</label><label class="expand" for="c-41113970">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You see this process happen all the time on (healthy) FOSS mailing lists.<p>In a FOSS mailing list, someone would hopefully just link to wikipedia.<p>No amount of arguing is going to resolve a duspute about definitions of terms.</div><br/></div></div></div></div><div id="41115481" class="c"><input type="checkbox" id="c-41115481" checked=""/><div class="controls bullet"><span class="by">77pt77</span><span>|</span><a href="#41113404">parent</a><span>|</span><a href="#41113701">prev</a><span>|</span><a href="#41114661">next</a><span>|</span><label class="collapse" for="c-41115481">[-]</label><label class="expand" for="c-41115481">[1 more]</label></div><br/><div class="children"><div class="content">&gt; he told me that I misunderstood, because it was &quot;impossible&quot; to update encrypted data without decrypting it. I politely tried saying &quot;actually no, that&#x27;s what makes homomorphic encryption super cool&quot;, and we went back and forth; eventually I kind of gave up because I was trying to make a good impression.<p>The moment you have to explain yourself you&#x27;ve already lost.<p>No argument you make will change their mind.<p>They are just stupid and that will never change.<p>And never forget, these people have power over you.</div><br/></div></div><div id="41114976" class="c"><input type="checkbox" id="c-41114976" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#41113404">parent</a><span>|</span><a href="#41114661">prev</a><span>|</span><a href="#41115587">next</a><span>|</span><label class="collapse" for="c-41114976">[-]</label><label class="expand" for="c-41114976">[1 more]</label></div><br/><div class="children"><div class="content">Something similar happened to me at my first(!) tech interview, with Apple&#x27;s [REDACTED] team.<p>There was ~3 minutes left in the interview, and they asked me a difficult l33t code concurrency question that was trivially answerable if you knew a specific, but lesser known, function in Apple&#x27;s concurrency library. [1]<p>I said as much, TL;DR: &quot;hmm I could do full leetcode that  requires X, Y, and Z, and I might not have enough time to finish it, but there is a one-liner via a new API y&#x27;all got that I could do quick&quot;<p>They said go ahead and write it, I did, then they insisted I was making up the function -- slapping the table and getting loud the second time they said it. Paired interviewer put a hand on their arm.<p>Looking back, that was not only a stark warning about the arbitrariness of interviews, but also that going from dropout waiter =&gt; founder =&gt; sold, then to Google, wasn&#x27;t going to be all sunshine and moonbeams just because people were smart and worked in tech too. People are people, everywhere. (fwiw, Apple rejected w&#x2F;&quot;not a college grad, no bigco experience, come back in 3 years if you can hack it somewhere else&quot;. Took Google, stayed 7 years)<p>[1] <a href="https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;dispatch&#x2F;3191903-dispatch_barrier_async_and_wait" rel="nofollow">https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;dispatch&#x2F;3191903-d...</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>