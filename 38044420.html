<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698483652248" as="style"/><link rel="stylesheet" href="styles.css?v=1698483652248"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://proofassistants.stackexchange.com/questions/1093/can-the-language-of-proof-assistants-be-used-for-general-purpose-programming">Can the language of proof assistants be used for general purpose programming?</a> <span class="domain">(<a href="https://proofassistants.stackexchange.com">proofassistants.stackexchange.com</a>)</span></div><div class="subtext"><span>wslh</span> | <span>33 comments</span></div><br/><div><div id="38045826" class="c"><input type="checkbox" id="c-38045826" checked=""/><div class="controls bullet"><span class="by">pyjarrett</span><span>|</span><a href="#38046763">next</a><span>|</span><label class="collapse" for="c-38045826">[-]</label><label class="expand" for="c-38045826">[5 more]</label></div><br/><div class="children"><div class="content">Yes.  SPARK is a verifiable subset of Ada and can be mixed with it in the same project.  There are SPARK crates you can use via Alire [1].  There&#x27;s a SPARK implementation of the TweetNaCl crypto library[2]<p>You can use it for general purpose programming, but it&#x27;s very difficult and various degrees of verification you can achieve with it [3].  I made a verified version of Rob Pike&#x27;s simple C regex matcher in SPARK -- proving an absence of runtime errors (e.g. never raise an exception or hit an out of bounds condition).<p>[1]: <a href="https:&#x2F;&#x2F;alire.ada.dev&#x2F;crates.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;alire.ada.dev&#x2F;crates.html</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;rod-chapman&#x2F;SPARKNaCl">https:&#x2F;&#x2F;github.com&#x2F;rod-chapman&#x2F;SPARKNaCl</a><p>[3]: <a href="https:&#x2F;&#x2F;blog.adacore.com&#x2F;from-ada-to-platinum-spark-a-case-study-for-reusable-bounded-stacks" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.adacore.com&#x2F;from-ada-to-platinum-spark-a-case-s...</a></div><br/><div id="38048231" class="c"><input type="checkbox" id="c-38048231" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38045826">parent</a><span>|</span><a href="#38047321">next</a><span>|</span><label class="collapse" for="c-38048231">[-]</label><label class="expand" for="c-38048231">[1 more]</label></div><br/><div class="children"><div class="content">SPARK features have been merged into Ada 2012, so it is also available in regular code.</div><br/></div></div><div id="38047321" class="c"><input type="checkbox" id="c-38047321" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#38045826">parent</a><span>|</span><a href="#38048231">prev</a><span>|</span><a href="#38046763">next</a><span>|</span><label class="collapse" for="c-38047321">[-]</label><label class="expand" for="c-38047321">[3 more]</label></div><br/><div class="children"><div class="content">Is Ada actually used outside of the US military? I&#x27;d love to hear more, I&#x27;ve always thought that&#x27;s where it was.</div><br/><div id="38048242" class="c"><input type="checkbox" id="c-38048242" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38045826">root</a><span>|</span><a href="#38047321">parent</a><span>|</span><a href="#38047604">next</a><span>|</span><label class="collapse" for="c-38048242">[-]</label><label class="expand" for="c-38048242">[1 more]</label></div><br/><div class="children"><div class="content">Yes, as mentioned on sibling comment in Europe.<p>That is also VHDL, which is based on Ada, is also mostly used in Europe in detriment to Verilog.<p>FOSDEM tends to have a regular Ada room.<p>Besides military, there is avionics, transport, critical factory infrastructure, lots of stuff that falls under high integrity computing.</div><br/></div></div><div id="38047604" class="c"><input type="checkbox" id="c-38047604" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#38045826">root</a><span>|</span><a href="#38047321">parent</a><span>|</span><a href="#38048242">prev</a><span>|</span><a href="#38046763">next</a><span>|</span><label class="collapse" for="c-38047604">[-]</label><label class="expand" for="c-38047604">[1 more]</label></div><br/><div class="children"><div class="content">It’s surprisingly used a bit more in Europe than the US. You can look at AdaCore’s users&#x2F;case studies to get a brief overview of industries using it.</div><br/></div></div></div></div></div></div><div id="38046763" class="c"><input type="checkbox" id="c-38046763" checked=""/><div class="controls bullet"><span class="by">hirple</span><span>|</span><a href="#38045826">prev</a><span>|</span><a href="#38048169">next</a><span>|</span><label class="collapse" for="c-38046763">[-]</label><label class="expand" for="c-38046763">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been interested in this question myself - and recently wrote a basic web &#x27;microframework&#x27; for Lean 4 [1].<p>I&#x27;ve loved being able to use Lean&#x27;s macro system to write JSX-like HTML:<p><pre><code>  def header :=  &lt;header class_=&quot;header&quot;&gt;
    &lt;h1&gt;todo&lt;&#x2F;h1&gt;
  ...
</code></pre>
Ironically I&#x27;ve come up a bit short on how to use dependent types to do anything more advanced than matching handlers&#x27; to route types, which Servant [2] can do fantastically already.<p>I would love to be able to write types that describe, e.g., assumptions made about external resources, so that I can prove that &quot;assuming my DB has such-and-such a latency, my page will always render in such-and-such a time&quot; or something similar - but it&#x27;s a bit beyond me at the moment.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;alex-wellbelove&#x2F;LeanServer">https:&#x2F;&#x2F;github.com&#x2F;alex-wellbelove&#x2F;LeanServer</a>
[2] <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;servant" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;servant</a></div><br/><div id="38048189" class="c"><input type="checkbox" id="c-38048189" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#38046763">parent</a><span>|</span><a href="#38048169">next</a><span>|</span><label class="collapse" for="c-38048189">[-]</label><label class="expand" for="c-38048189">[1 more]</label></div><br/><div class="children"><div class="content">Before taking the plunge on using dependent types in production, please heed the warnings discussed here: <a href="https:&#x2F;&#x2F;lean-lang.org&#x2F;functional_programming_in_lean&#x2F;dependent-types&#x2F;pitfalls.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;lean-lang.org&#x2F;functional_programming_in_lean&#x2F;depende...</a></div><br/></div></div></div></div><div id="38048169" class="c"><input type="checkbox" id="c-38048169" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#38046763">prev</a><span>|</span><a href="#38045418">next</a><span>|</span><label class="collapse" for="c-38048169">[-]</label><label class="expand" for="c-38048169">[1 more]</label></div><br/><div class="children"><div class="content">Well, I&#x27;d claim that Idris is pretty much that. A general purpose (if highly experimental) programming language with the power of a proof assistant.<p>Also, I have seen people write proofs in Coq and extract them to compilable OCaml source code.</div><br/></div></div><div id="38045418" class="c"><input type="checkbox" id="c-38045418" checked=""/><div class="controls bullet"><span class="by">rabbits77</span><span>|</span><a href="#38048169">prev</a><span>|</span><a href="#38045501">next</a><span>|</span><label class="collapse" for="c-38045418">[-]</label><label class="expand" for="c-38045418">[7 more]</label></div><br/><div class="children"><div class="content">I can’t see why this should not be the case. Logic Programming languages like Prolog can be used for general purposes. The main catch is that you need to be really good at Prolog to use it to full generality. But if you’re willing to put in the time it should be able the same.</div><br/><div id="38047911" class="c"><input type="checkbox" id="c-38047911" checked=""/><div class="controls bullet"><span class="by">mostlylurks</span><span>|</span><a href="#38045418">parent</a><span>|</span><a href="#38047960">next</a><span>|</span><label class="collapse" for="c-38047911">[-]</label><label class="expand" for="c-38047911">[1 more]</label></div><br/><div class="children"><div class="content">Understanding the techniques that make general purpose programming in prolog easy is one of the easiest parts of learning prolog, such that even beginners shouldn&#x27;t have trouble with it. Learning to use prolog the way it was meant to be used is actually much harder, and you&#x27;ll certainly have a good grasp of general-purpose programming in prolog long before you become &quot;really good&quot; at prolog.</div><br/></div></div><div id="38047960" class="c"><input type="checkbox" id="c-38047960" checked=""/><div class="controls bullet"><span class="by">Jaxan</span><span>|</span><a href="#38045418">parent</a><span>|</span><a href="#38047911">prev</a><span>|</span><a href="#38045506">next</a><span>|</span><label class="collapse" for="c-38047960">[-]</label><label class="expand" for="c-38047960">[1 more]</label></div><br/><div class="children"><div class="content">My feeling is that proof assistants are much closer to general purpose programming than logic programming such as prolog.</div><br/></div></div><div id="38045506" class="c"><input type="checkbox" id="c-38045506" checked=""/><div class="controls bullet"><span class="by">sargstuff</span><span>|</span><a href="#38045418">parent</a><span>|</span><a href="#38047960">prev</a><span>|</span><a href="#38045501">next</a><span>|</span><label class="collapse" for="c-38045506">[-]</label><label class="expand" for="c-38045506">[4 more]</label></div><br/><div class="children"><div class="content">Just add a GPT natural language to language proof assistant translator as a front end (with appropriate audio device permissions)<p>Change the need to be really good at proglog to just need to distinctly describe what want&#x2F;need.</div><br/><div id="38046186" class="c"><input type="checkbox" id="c-38046186" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#38045418">root</a><span>|</span><a href="#38045506">parent</a><span>|</span><a href="#38045501">next</a><span>|</span><label class="collapse" for="c-38046186">[-]</label><label class="expand" for="c-38046186">[3 more]</label></div><br/><div class="children"><div class="content">Adding a large language model is going to move you in the exact opposite direction from ease of formal verification.</div><br/><div id="38046546" class="c"><input type="checkbox" id="c-38046546" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#38045418">root</a><span>|</span><a href="#38046186">parent</a><span>|</span><a href="#38045501">next</a><span>|</span><label class="collapse" for="c-38046546">[-]</label><label class="expand" for="c-38046546">[2 more]</label></div><br/><div class="children"><div class="content">I mean... Not necessarily? It depends how you use it or what part of the process you delegate to it, no?<p>Whether AI produces Lean code or a human produces Lean code... The Lean code should speak for itself. Both humans and AI are the weak link in either case, and it&#x27;s unclear to me which of the two is the weaker.</div><br/><div id="38046776" class="c"><input type="checkbox" id="c-38046776" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#38045418">root</a><span>|</span><a href="#38046546">parent</a><span>|</span><a href="#38045501">next</a><span>|</span><label class="collapse" for="c-38046776">[-]</label><label class="expand" for="c-38046776">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I think I misunderstood the proposal there. I thought the language model was meant to be producing (only) code, not proofs.<p>If it manages to produce successful proofs of pre-existing property specifications, then that&#x27;s great!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38045501" class="c"><input type="checkbox" id="c-38045501" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#38045418">prev</a><span>|</span><a href="#38047664">next</a><span>|</span><label class="collapse" for="c-38045501">[-]</label><label class="expand" for="c-38045501">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been thrashing around with agda (as a hobby) for a few months. Maybe it&#x27;s time to take lean for a spin.<p>My thinking is still pretty fuzzy. But I feel like there&#x27;s something important and valuable with the idea of &quot;this is the specification of the software&quot; and the &quot;this software meets that specification&quot;.<p>Now, yes, maybe the specification is wrong. Proofs are hard to write. All software has a bunch of implicit constraints. I forget them for the code I wrote, and it&#x27;s even tougher to figure them out when I&#x27;m handed a legacy project where the author is long gone.<p>There&#x27;s something really important about that dual view of, this is what it&#x27;s supposed to do, and this is what it does. And tools can help check that they agree!<p>There&#x27;s like the classic Haskell example of verified email - at some point the user was sent an email and they clicked a link, so that string is special, pretty sure foo@example.com is a real email.<p>The ability to slap a type on something, then have tools tell you &quot;this is everything that needs to be updated&quot; is really appealing. Like, The account must be in good standing before shipping product. So I keep puttering around with it.<p>It&#x27;s often difficult to add features and be super sure you&#x27;re not breaking stuff. Well, maybe not you, but me, for sure.</div><br/><div id="38045586" class="c"><input type="checkbox" id="c-38045586" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#38045501">parent</a><span>|</span><a href="#38046538">next</a><span>|</span><label class="collapse" for="c-38045586">[-]</label><label class="expand" for="c-38045586">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s something really important about that dual view of, this is what it&#x27;s supposed to do, and this is what it does. And tools can help check that they agree!<p>Isn’t this the whole concept behind writing tests?</div><br/><div id="38045676" class="c"><input type="checkbox" id="c-38045676" checked=""/><div class="controls bullet"><span class="by">jfoutz</span><span>|</span><a href="#38045501">root</a><span>|</span><a href="#38045586">parent</a><span>|</span><a href="#38046538">next</a><span>|</span><label class="collapse" for="c-38045676">[-]</label><label class="expand" for="c-38045676">[1 more]</label></div><br/><div class="children"><div class="content">It is! And I&#x27;m a big fan of test systems that optionally invert the logic and require failure - to weed out bullshit tests.<p>But there are some things that are challenging to test for. Tests sample the space, proofs define the space. you can&#x27;t build it wrong. (you can sure have a bad spec, and build the wrong thing though)<p>Tests definitely help. It sorta feels like there&#x27;s value left on the table. The spec, the types let you define broader constraints, and you catch them all.</div><br/></div></div></div></div><div id="38046538" class="c"><input type="checkbox" id="c-38046538" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#38045501">parent</a><span>|</span><a href="#38045586">prev</a><span>|</span><a href="#38047664">next</a><span>|</span><label class="collapse" for="c-38046538">[-]</label><label class="expand" for="c-38046538">[1 more]</label></div><br/><div class="children"><div class="content">I’d like to see one of these systems designed around generating test suites for the specification. So, you’d prove your algorithm correct using some inefficient representation (nats for integers or whatever) and then the verifier would detect edge cases and generate a junit test suite for the real implementation.</div><br/></div></div></div></div><div id="38047664" class="c"><input type="checkbox" id="c-38047664" checked=""/><div class="controls bullet"><span class="by">agentultra</span><span>|</span><a href="#38045501">prev</a><span>|</span><a href="#38046650">next</a><span>|</span><label class="collapse" for="c-38047664">[-]</label><label class="expand" for="c-38047664">[1 more]</label></div><br/><div class="children"><div class="content">I think so.<p><a href="https:&#x2F;&#x2F;agentultra.github.io&#x2F;lean-4-hackers&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;agentultra.github.io&#x2F;lean-4-hackers&#x2F;</a></div><br/></div></div><div id="38046650" class="c"><input type="checkbox" id="c-38046650" checked=""/><div class="controls bullet"><span class="by">b9r5</span><span>|</span><a href="#38047664">prev</a><span>|</span><a href="#38045771">next</a><span>|</span><label class="collapse" for="c-38046650">[-]</label><label class="expand" for="c-38046650">[1 more]</label></div><br/><div class="children"><div class="content">I thought this post was fun:
<a href="https:&#x2F;&#x2F;blog.codeminer42.com&#x2F;overcoming-challenges-and-crafting-in-the-uncharted-territory-of-lean4&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.codeminer42.com&#x2F;overcoming-challenges-and-craft...</a></div><br/></div></div><div id="38045771" class="c"><input type="checkbox" id="c-38045771" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#38046650">prev</a><span>|</span><a href="#38047159">next</a><span>|</span><label class="collapse" for="c-38045771">[-]</label><label class="expand" for="c-38045771">[3 more]</label></div><br/><div class="children"><div class="content">tl;dr; Yes. But trying to prove anything beyond very tiny functions (especially things like GUIs and world state) is near-impossible and massive overkill. Also, you&#x27;ll need to work around termination checking (even if your functions always terminate, <i>proving</i> that is another matter).<p>Theorem provering languages are cool. Being able to prove the absence of bugs, enforce complex invariants, etc. is cool and useful in certain cases (like cryptography and safety-critical software). But it&#x27;s also very hard, at least state-of-the-art, so often I feel writing good tests is better.</div><br/><div id="38046627" class="c"><input type="checkbox" id="c-38046627" checked=""/><div class="controls bullet"><span class="by">MichaelZuo</span><span>|</span><a href="#38045771">parent</a><span>|</span><a href="#38047159">next</a><span>|</span><label class="collapse" for="c-38046627">[-]</label><label class="expand" for="c-38046627">[2 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t some Australian group manage to prove a simplified kernel?</div><br/><div id="38046913" class="c"><input type="checkbox" id="c-38046913" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#38045771">root</a><span>|</span><a href="#38046627">parent</a><span>|</span><a href="#38047159">next</a><span>|</span><label class="collapse" for="c-38046913">[-]</label><label class="expand" for="c-38046913">[1 more]</label></div><br/><div class="children"><div class="content">seL4 has a formal correctness prof that was developed by NICTA. The project started in 2006 and the formal proof and artifact was submitted in 2009. The elements of the implementation and resulting qualities present during run time are well defined but are limited to exactly those properties the project chose, like lack of dead and livelocks, arithmetic based exceptions, and buffer overruns.<p>L4 is less a simplified kernel and more of a microkernel, but it is fully general purpose.<p>One of the neat things they did was transport memory&#x2F;resource management to userland and maintain a strict capabilities scheme for ensuring correctness. The other was the cost estimate they claim, which was something like a 60% cost saving for doing the formally verified programming compared to standard ‘high assurance’ programming.<p>It was a cool project but is not often used to support further pushes into more general systems level applicability of ‘theorem proving’ based programming languages.</div><br/></div></div></div></div></div></div><div id="38047159" class="c"><input type="checkbox" id="c-38047159" checked=""/><div class="controls bullet"><span class="by">LightMachine</span><span>|</span><a href="#38045771">prev</a><span>|</span><a href="#38045216">next</a><span>|</span><label class="collapse" for="c-38047159">[-]</label><label class="expand" for="c-38047159">[1 more]</label></div><br/><div class="children"><div class="content">We have built an entire real time game in Kind lang...</div><br/></div></div><div id="38045216" class="c"><input type="checkbox" id="c-38045216" checked=""/><div class="controls bullet"><span class="by">ipsum2</span><span>|</span><a href="#38047159">prev</a><span>|</span><label class="collapse" for="c-38045216">[-]</label><label class="expand" for="c-38045216">[7 more]</label></div><br/><div class="children"><div class="content">I suspect that a Python DSL on top of Lean4 would be hugely popular, similar to PyTorch replacing existing Torch, which was written in Lua.</div><br/><div id="38046619" class="c"><input type="checkbox" id="c-38046619" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#38045216">parent</a><span>|</span><a href="#38045286">next</a><span>|</span><label class="collapse" for="c-38046619">[-]</label><label class="expand" for="c-38046619">[1 more]</label></div><br/><div class="children"><div class="content">I think the biggest jump between interactive theorem provers like Lean &quot;normal&quot; languages is the &quot;interactive&quot; part: Lean or Coq or the like really work well in a specialized IDE mode where you&#x27;re editing the file and getting instant feedback about the state of your proof. You might be able to get a Python DSL to work, but there would be a lot of tooling work involved to pipe everything back.<p>You can write proofs in a non-interactive way, but you&#x27;re signing yourself up for a lot of tedium.<p>EDIT: A video showing someone working through some simple stuff. You can obviously do a lot of things &quot;in your head&quot; but having the feedback loop is helpful. Though thinking about it more I don&#x27;t think this precludes a Python DSL entirely. It would just require some smart design to support this form of interactivity. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=VYFTph2izIs">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=VYFTph2izIs</a></div><br/></div></div><div id="38045286" class="c"><input type="checkbox" id="c-38045286" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#38045216">parent</a><span>|</span><a href="#38046619">prev</a><span>|</span><a href="#38045741">next</a><span>|</span><label class="collapse" for="c-38045286">[-]</label><label class="expand" for="c-38045286">[2 more]</label></div><br/><div class="children"><div class="content">... also like using Z3 with Python [1].<p>[1] <a href="https:&#x2F;&#x2F;ericpony.github.io&#x2F;z3py-tutorial&#x2F;guide-examples.htm" rel="nofollow noreferrer">https:&#x2F;&#x2F;ericpony.github.io&#x2F;z3py-tutorial&#x2F;guide-examples.htm</a></div><br/><div id="38045323" class="c"><input type="checkbox" id="c-38045323" checked=""/><div class="controls bullet"><span class="by">ipsum2</span><span>|</span><a href="#38045216">root</a><span>|</span><a href="#38045286">parent</a><span>|</span><a href="#38045741">next</a><span>|</span><label class="collapse" for="c-38045323">[-]</label><label class="expand" for="c-38045323">[1 more]</label></div><br/><div class="children"><div class="content">This is quite nice! I wasn&#x27;t aware of this.</div><br/></div></div></div></div><div id="38045741" class="c"><input type="checkbox" id="c-38045741" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#38045216">parent</a><span>|</span><a href="#38045286">prev</a><span>|</span><a href="#38045350">next</a><span>|</span><label class="collapse" for="c-38045741">[-]</label><label class="expand" for="c-38045741">[1 more]</label></div><br/><div class="children"><div class="content">Why do you suspect that? (Or was it ironic?)</div><br/></div></div><div id="38045350" class="c"><input type="checkbox" id="c-38045350" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#38045216">parent</a><span>|</span><a href="#38045741">prev</a><span>|</span><label class="collapse" for="c-38045350">[-]</label><label class="expand" for="c-38045350">[2 more]</label></div><br/><div class="children"><div class="content">I have a very negative visceral reaction at the thought. (I am someone who uses python for work, and not for fun…)</div><br/></div></div></div></div></div></div></div></div></div></body></html>