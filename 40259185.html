<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714899712614" as="style"/><link rel="stylesheet" href="styles.css?v=1714899712614"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/verus-lang/verus">Verified Rust for low-level systems code</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>gz09</span> | <span>64 comments</span></div><br/><div><div id="40261562" class="c"><input type="checkbox" id="c-40261562" checked=""/><div class="controls bullet"><span class="by">lsuresh</span><span>|</span><a href="#40261546">next</a><span>|</span><label class="collapse" for="c-40261562">[-]</label><label class="expand" for="c-40261562">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve used Verus to write formally verified Kubernetes controllers.<p>Basically, we can prove liveness properties of the form &quot;eventually, the controller will reconcile the cluster to the requested desired state&quot;. As you can imagine, there is a lot of subtlety and nuance to even specifying correctness here (think rapid changes to the desired state requirement, asynchrony, failures and what not).<p>Code: <a href="https:&#x2F;&#x2F;github.com&#x2F;vmware-research&#x2F;verifiable-controllers&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;vmware-research&#x2F;verifiable-controllers&#x2F;</a>, with a corresponding paper due to appear at OSDI 2024.</div><br/></div></div><div id="40261546" class="c"><input type="checkbox" id="c-40261546" checked=""/><div class="controls bullet"><span class="by">jph</span><span>|</span><a href="#40261562">prev</a><span>|</span><a href="#40260398">next</a><span>|</span><label class="collapse" for="c-40261546">[-]</label><label class="expand" for="c-40261546">[1 more]</label></div><br/><div class="children"><div class="content">If you want a small stepping stone toward Versus, you can add Rust debug_assert for preconditions and postconditions; the Rust compiler strips these out of production builds by default.<p>Example from the Versus tutorial with verification:<p><pre><code>    fn octuple(x1: i8) -&gt; (x8: i8)
        requires
            -16 &lt;= x1,
            x1 &lt; 16,
        ensures
            x8 == 8 * x1,
    {
        let x2 = x1 + x1;
        let x4 = x2 + x2;
        x4 + x4
    }
</code></pre>
Example using debug_assert with runtime checks:<p><pre><code>    fn octuple(x1: i8) -&gt; i8 {
        debug_assert(-16 &lt;= x1);
        debug_assert(x1 &lt; 16);
        let x2 = x1 + x1;
        let x4 = x2 + x2;
        let x8 = x4 + x4;
        debug_assert(x8 == 8 * x1);
        x8
    }</code></pre></div><br/></div></div><div id="40260398" class="c"><input type="checkbox" id="c-40260398" checked=""/><div class="controls bullet"><span class="by">sdsd</span><span>|</span><a href="#40261546">prev</a><span>|</span><a href="#40261037">next</a><span>|</span><label class="collapse" for="c-40260398">[-]</label><label class="expand" for="c-40260398">[43 more]</label></div><br/><div class="children"><div class="content">Noob question from someone with little real CS experience, when the README for this project says:<p>&gt; verifying the correctness of code<p>What is the difference between &quot;verifying&quot; the correctness of code, as they say here, vs &quot;proving&quot; the correctness of code, as I sometimes see said elsewhere?<p>Also, is there a good learning resource on &quot;proving&quot; things about code for working programmers without a strong CS &#x2F; math background?<p>Edit: I&#x27;m also very curious why &quot;zero knowledge&quot; proofs are so significant, and why this is so relevant. Eg I heard people talking about this and don&#x27;t really understand why it&#x27;s so cool: x.com&#x2F;ZorpZK</div><br/><div id="40260557" class="c"><input type="checkbox" id="c-40260557" checked=""/><div class="controls bullet"><span class="by">opnitro</span><span>|</span><a href="#40260398">parent</a><span>|</span><a href="#40260439">next</a><span>|</span><label class="collapse" for="c-40260557">[-]</label><label class="expand" for="c-40260557">[1 more]</label></div><br/><div class="children"><div class="content">A very good resource for both verifying code and functional programming is Software Foundations (<a href="https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu" rel="nofollow">https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu</a>).<p>One note though: Verus and the tool Software Foundations works with (Coq) take different approaches to proving things.<p>Verus attempts to prove properties automatically using something called an SMT solver, which is an automated system for solving constraints. Coq on the other hand, requires you to manually prove much more, offering a more limited set of automations for proving things.<p>Both have their advantages and disadvantages, namely that automation is great when it works and annoying when it doesn&#x27;t.<p>(Another side note: Zero Knowledge Proofs (ZKPs) are kind of something different. A great many people who work in formal verification&#x2F;proof don&#x27;t touch ZKPs at all (ex: me). They are better thought about as a cryptography primitive)</div><br/></div></div><div id="40260439" class="c"><input type="checkbox" id="c-40260439" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">parent</a><span>|</span><a href="#40260557">prev</a><span>|</span><a href="#40261152">next</a><span>|</span><label class="collapse" for="c-40260439">[-]</label><label class="expand" for="c-40260439">[19 more]</label></div><br/><div class="children"><div class="content">Verifying and proving are used synonymously, as made clear later in the opening paragraph.<p>As for zero knowledge proofs, there is little practical use, significance, or relevance to them due to the overhead involved and the lack of a &quot;killer app&quot;, so to speak. But they&#x27;re conceptually interesting.</div><br/><div id="40260921" class="c"><input type="checkbox" id="c-40260921" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260439">parent</a><span>|</span><a href="#40261238">next</a><span>|</span><label class="collapse" for="c-40260921">[-]</label><label class="expand" for="c-40260921">[13 more]</label></div><br/><div class="children"><div class="content">Whenever I hear people talk about the lack of practicality of some mathematical construct, I always remember G H Hardy who worked on number theory at the turn of the century. One of his famous quotes I love is:<p>&gt; I have never done anything &#x27;useful.&#x27; No discovery of mine has made, or is likely to make, directly or indirectly, for good or ill, the least difference to the amenity of the world.<p>Despite his self-proclaimed focus on pure mathematics, Hardy&#x27;s work, particularly in number theory, has had profound applications in cryptography and other fields.<p>I agree about the overhead. The costs have come down significantly already but they still remain a few orders of magnitude too large. That being said, it’s killer app is cloud compute. Right now the only way to amortize the cost of HW is to run it on someone else’s computer, which brings along with it all sorts of security and privacy risks. Well-performing ZK proofs (which we don’t know if it exists &#x2F; it may be a long time before we figure out how to do it) would 
let you do cloud computing securely without worrying about vulnerabilities in your cloud provider’s network. Like all cryptography, it’s a double-edged sword because the same techniques would let websites deliver code for your machine to execute that you have no knowledge of what it’s doing.</div><br/><div id="40261519" class="c"><input type="checkbox" id="c-40261519" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260921">parent</a><span>|</span><a href="#40261238">next</a><span>|</span><label class="collapse" for="c-40261519">[-]</label><label class="expand" for="c-40261519">[12 more]</label></div><br/><div class="children"><div class="content">Do you ever think about the many more folks who worked on stuff that really was completely useless and nobody remembers? &quot;Whenever I hear people talking about how the lottery is a waste of money with net negative expected returns, I think about the person I saw on TV who did win.&quot;<p>Cloud compute <i>might</i> be a good use case. But the overhead would have to come down <i>dramatically</i> for it to ever beat simply doing the compute in-house and incurring the overhead of managing a physical rack. Which is (and always has been, and likely always will be) an extremely viable option for anyone who is seriously interested in data access control.</div><br/><div id="40262485" class="c"><input type="checkbox" id="c-40262485" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261519">parent</a><span>|</span><a href="#40262665">next</a><span>|</span><label class="collapse" for="c-40262485">[-]</label><label class="expand" for="c-40262485">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But the overhead would have to come down dramatically for it to ever beat simply doing the compute in-house and incurring the overhead of managing a physical rack.<p>A physical rack needs several physical people to look after it. Imagine it going down in the middle of the night while your sysadmin is on a vacation on Hawaii.<p>And cloud computing is also not expensive. If you don&#x27;t have a large load, a t4g.micro instance on AWS costs 0.5 cents per hour ($1.2 per day, $438 per year). It will run most small workloads just fine, and you can easily scale it up with a couple of clicks.</div><br/><div id="40263081" class="c"><input type="checkbox" id="c-40263081" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40262485">parent</a><span>|</span><a href="#40262665">next</a><span>|</span><label class="collapse" for="c-40263081">[-]</label><label class="expand" for="c-40263081">[1 more]</label></div><br/><div class="children"><div class="content">ZKP&#x27;s are a large load, so this hypothetical is invalid. Also ZKPs require you to already have some amount of in house compute on an in house rack, or else who are you even protecting your data from? So the question is do you provision slightly more compute into the rack you&#x27;re already managing, or incur orders of magnitude more CPU time expense and a complete refactoring of your business logic to use ZKP&#x27;s in order to... have slightly fewer servers in your rack? The benefits are hard to even comprehend.</div><br/></div></div></div></div><div id="40262665" class="c"><input type="checkbox" id="c-40262665" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261519">parent</a><span>|</span><a href="#40262485">prev</a><span>|</span><a href="#40262075">next</a><span>|</span><label class="collapse" for="c-40262665">[-]</label><label class="expand" for="c-40262665">[1 more]</label></div><br/><div class="children"><div class="content">I think you may be overestimating the complexity &amp; costs involved. Hyperscalars run millions of machines and have extracted impressive efficiencies from that that you’re not going to be able to compete with by buying and maintaining your own rack. This starts to become clear when you consider how ancient, outdated and expensive servers for hospital systems are.</div><br/></div></div><div id="40262075" class="c"><input type="checkbox" id="c-40262075" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261519">parent</a><span>|</span><a href="#40262665">prev</a><span>|</span><a href="#40261238">next</a><span>|</span><label class="collapse" for="c-40262075">[-]</label><label class="expand" for="c-40262075">[8 more]</label></div><br/><div class="children"><div class="content">&gt; But the overhead would have to come down dramatically for it to ever beat simply doing the compute in-house and incurring the overhead of managing a physical rack.<p>Out of sheer curiosity, by which metric deploying the pre-packaged code (which takes seconds) into the cloud incurs a higher overhead compared to maintaining an in-house physical rack?</div><br/><div id="40263075" class="c"><input type="checkbox" id="c-40263075" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40262075">parent</a><span>|</span><a href="#40262173">next</a><span>|</span><label class="collapse" for="c-40263075">[-]</label><label class="expand" for="c-40263075">[1 more]</label></div><br/><div class="children"><div class="content">When the code has to use ZKP&#x27;s, there is an intrinsic overhead measured in orders of magnitude of CPU time. By avoiding the use of third parties, that overhead is eliminated.<p>So the question is, does this hypothetical entity with <i>very precious data</i> incur the extra orders of magnitude of compute time in oder to not maintain a rack in house, or do they just... maintain a rack. Keeping in mind, of course, that they <i>already must maintain a rack</i> in order for ZKP&#x27;s to make any sense at all. So... do they add a server to their existing rack to handle the workload, or refactor their entire computation to use ZKP&#x27;s, and incur several extra orders of magnitude of compute time, and outsource the work to a cloud service?</div><br/></div></div><div id="40262173" class="c"><input type="checkbox" id="c-40262173" checked=""/><div class="controls bullet"><span class="by">phanimahesh</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40262075">parent</a><span>|</span><a href="#40263075">prev</a><span>|</span><a href="#40262287">next</a><span>|</span><label class="collapse" for="c-40262173">[-]</label><label class="expand" for="c-40262173">[3 more]</label></div><br/><div class="children"><div class="content">Usually when you need to do it many times at scale, self managed rack can be cheaper than cloud. The downside is requiring expertise to manage and maintain it.</div><br/><div id="40262566" class="c"><input type="checkbox" id="c-40262566" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40262173">parent</a><span>|</span><a href="#40262287">next</a><span>|</span><label class="collapse" for="c-40262566">[-]</label><label class="expand" for="c-40262566">[2 more]</label></div><br/><div class="children"><div class="content">The cost of deployment into the cloud is $0 at a scale that is unfathomable to any rack with the overhead being a near zero as well. Initial capital investment for the cloud is $0 as well.<p>The self-managed rack:<p><pre><code>  1. Has to exist somewhere.
  2. Therefore it required the initial capital investment at some point, which is a mid five figure amount or more.
  3. Scales by its weight, height, depth and hardware specifications.
  4. Does not scale beyond (3) – hardware constraints of blades deployed in the rack are very rigid.
  5. Has to have available processing capacity to support the new workload.
  6. Has a habit of running of capacity at the most inconvenient moment requiring, well, a new rack.
</code></pre>
A new&#x2F;extra rack:<p><pre><code>  1. Has to be paid for from a budget. The budget may or may not exist when the new rack is required, therefore potentially incurring further, potentially lengthy, delays (i.e. «no money in the budget until the next financial year». Boom.).
  2. Has to be taken through the procurement. Depending on the organisation and its size, procurement can take anywhere in between 3 and 12 months.
  3. Has to be in stock.
  4. Has to be installed, deployed and configured.
  5. Requires technicians and engineers to be available within a designated time slot to complete (4). The technicians and the engineers (all of them or a single&#x2F;few) may be unavailable due to X, Y or Z.
</code></pre>
Bonus points:<p><pre><code>  1. The DC may not have enough room &#x2F; power &#x2F; cooling &#x2F; etc. You and your rack are now stuck for an non-deterministic amount time.

  2. Adding a new rack to your rack HA setup requires a new network interconnect due to the network capacity reaching a saturation point. It is called «an expensive network switch». Add further delays, repeat all steps required to procure a new rack, add new&#x2F;unforeseen delays.
</code></pre>
With the above in mind, I fail to see how the overhead of a poorly scalable, self-managed rack is lower compared to a $0, software driven code deployment into the cloud at a scale that is limited by the size of one&#x27;s wallet.</div><br/><div id="40263118" class="c"><input type="checkbox" id="c-40263118" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40262566">parent</a><span>|</span><a href="#40262287">next</a><span>|</span><label class="collapse" for="c-40263118">[-]</label><label class="expand" for="c-40263118">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, <i>the cloud</i>, where network interconnect issues simply <i>do not exist</i>, and extra capacity is <i>always available</i>, and the budget <i>never runs dry</i>, and configuration <i>is not required</i>, and technicians and engineers <i>are always available</i>.<p>Can I have a puff of whatever it is you smoked to reach this cloud?</div><br/></div></div></div></div></div></div><div id="40262287" class="c"><input type="checkbox" id="c-40262287" checked=""/><div class="controls bullet"><span class="by">Nursie</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40262075">parent</a><span>|</span><a href="#40262173">prev</a><span>|</span><a href="#40261238">next</a><span>|</span><label class="collapse" for="c-40262287">[-]</label><label class="expand" for="c-40262287">[3 more]</label></div><br/><div class="children"><div class="content">&gt; by which metric deploying the pre-packaged code (which takes seconds) into the cloud incurs a higher overhead compared to maintaining an in-house physical rack?<p>In terms of time? Probably not much. In terms of cost, we’ll it’s about scale.<p>I worked on a project for a big financial firm about 8 years ago, to implement a burst-capacity overflow to cloud strategy for their compute needs. About one week a month or even one week a quarter, they would need a few tens of thousands of extra cores.<p>At this scale the cloud providers were not really able to react or provision fast enough, and required us to reserve the capacity full time. In the end the costs for “buy and manage more racks” internally worked out cheaper.</div><br/><div id="40262602" class="c"><input type="checkbox" id="c-40262602" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40262287">parent</a><span>|</span><a href="#40261238">next</a><span>|</span><label class="collapse" for="c-40262602">[-]</label><label class="expand" for="c-40262602">[2 more]</label></div><br/><div class="children"><div class="content">&gt; […] to implement a burst-capacity overflow to cloud strategy for their compute needs.<p>8 years ago the cloud did not effectively exist yet. Today the available capacity surpasses the needs of the prevailing majority of cloud customers, with a caveat – see below.<p>&gt; At this scale the cloud providers were not really able to react or provision fast enough, and required us to reserve the capacity full time.<p>A few things have happened since then:<p><pre><code>  1. Hardware capacity has been ramped up at a very large scale.
  2. Most importantly, advances in the workload distribution and optimisation: the cloud control plane distributes workloads to the available capacity across cloud data centres.
</code></pre>
The caveat.<p>For most demanding customers, cloud providers have a solution called «the cloud appliance». A truck rolls in with the hardware that gets deployed as an extension of your own private cloud within a few days. Deployed software does not notice a difference and gets automatically distributed to the new processing capacity. If that is not enough, another truck rolls in with another «cloud appliance». It is presumed that if one operates at such a scale, they also have the money to pay for it.</div><br/><div id="40262919" class="c"><input type="checkbox" id="c-40262919" checked=""/><div class="controls bullet"><span class="by">Nursie</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40262602">parent</a><span>|</span><a href="#40261238">next</a><span>|</span><label class="collapse" for="c-40262919">[-]</label><label class="expand" for="c-40262919">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 8 years ago the cloud did not effectively exist yet<p>Yeah it really did. I’ve been around a while. “Cloud” was becoming a buzzword around the tech industry <i>16</i> years ago. 8 years ago we had AWS, IBM, and Microsoft all vying for our business on this project.<p>&gt; For most demanding customers, cloud providers have a solution called «the cloud appliance». A truck rolls in with the hardware that gets deployed as an extension of your own private cloud within a few days<p>None of which was as cost effective as adding more capacity to your own data centres, if you’re already running them at scale, because fundamentally someone is profiting from renting out those cloud appliances. If you have the in-house capabilities already, you can cut out the middlemen.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40261238" class="c"><input type="checkbox" id="c-40261238" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260439">parent</a><span>|</span><a href="#40260921">prev</a><span>|</span><a href="#40261152">next</a><span>|</span><label class="collapse" for="c-40261238">[-]</label><label class="expand" for="c-40261238">[5 more]</label></div><br/><div class="children"><div class="content">&gt; As for zero knowledge proofs, there is little practical use, significance, or relevance to them due to the overhead involved and the lack of a &quot;killer app&quot;, so to speak. But they&#x27;re conceptually interesting.<p>This is just plain wrong. There are numerous applications in the blockchain space where the overhead is tolerable because they provide properties (privacy, succinct verification) that other techniques cannot provide.<p>Their relevance to blockchains has led to massive reductions in the overhead, making it quite plausible that ZKPs will find use in settings where integrity is a must.<p>For example, you could prove that a particular binary is the resulting of compiling source code that satisfies particular properties, such as memory safety. This would allow you to skip unnecessary safety checks.</div><br/><div id="40261554" class="c"><input type="checkbox" id="c-40261554" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261238">parent</a><span>|</span><a href="#40261152">next</a><span>|</span><label class="collapse" for="c-40261554">[-]</label><label class="expand" for="c-40261554">[4 more]</label></div><br/><div class="children"><div class="content">For a tool to be of &quot;practical use, significance, or relevance&quot; requires that the work it produces also is of &quot;practical use, significance, or relevance&quot;. Blockchains are not.<p>And the best way to verify a compiled binary is correctly compiled is to do the compilation. That&#x27;s a trivial amount of work. Constructing a ZKP of the same is certainly more cost intensive.</div><br/><div id="40262949" class="c"><input type="checkbox" id="c-40262949" checked=""/><div class="controls bullet"><span class="by">A1kmm</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261554">parent</a><span>|</span><a href="#40263072">next</a><span>|</span><label class="collapse" for="c-40262949">[-]</label><label class="expand" for="c-40262949">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Constructing a ZKP of the same is certainly more cost intensive.
That is certainly true for the compilation phase (i.e. constructing the ZKP).<p>But for the verifier, that isn&#x27;t so obviously true:
- Firstly, the verifier might not even have access to the formal proof that the program meets the memory correctness guarantees. It might have access to a binary code, plus a proof that the binary code compiled from a completely memory safe language. The verifier would need zero knowledge of the code (which might be proprietary).
- Secondly, proofs aren&#x27;t necessarily that big (especially for Groth16 circuits), and can be applied recursively (you prove that you had a proof that something was true), and aren&#x27;t that expensive to verify. If verifying a program once when you download it means it can be flagged as being safe to run without expensive bounds and MMU checks, it could open up new types of more performant CPUs, and potentially save far more than it costs to verify.</div><br/></div></div><div id="40263072" class="c"><input type="checkbox" id="c-40263072" checked=""/><div class="controls bullet"><span class="by">sabas123</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261554">parent</a><span>|</span><a href="#40262949">prev</a><span>|</span><a href="#40261152">next</a><span>|</span><label class="collapse" for="c-40263072">[-]</label><label class="expand" for="c-40263072">[2 more]</label></div><br/><div class="children"><div class="content">&gt; And the best way to verify a compiled binary is correctly compiled is to do the compilation. That&#x27;s a trivial amount of work. Constructing a ZKP of the same is certainly more cost intensive.<p>This makes the assumption that you both have the source code and that the compiler is deterministic. With the latter one being not the case for (most?) modern compilers.</div><br/><div id="40263096" class="c"><input type="checkbox" id="c-40263096" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40263072">parent</a><span>|</span><a href="#40261152">next</a><span>|</span><label class="collapse" for="c-40263096">[-]</label><label class="expand" for="c-40263096">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, the totally-valid use case of ensuring that a third party has properly compiled source code that you don&#x27;t have access to. I&#x27;m sure this comes up in industry all the time.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40261152" class="c"><input type="checkbox" id="c-40261152" checked=""/><div class="controls bullet"><span class="by">yodsanklai</span><span>|</span><a href="#40260398">parent</a><span>|</span><a href="#40260439">prev</a><span>|</span><a href="#40260552">next</a><span>|</span><label class="collapse" for="c-40261152">[-]</label><label class="expand" for="c-40261152">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;proving&quot; things about code for working programmers<p>I&#x27;d argue that this is antinomic. Proving things about code isn&#x27;t something working programmers do yet. I&#x27;d say that Hoare logic is a good starting point as it is sometimes taught in introductory CS classes.<p>Coq has a steep learning curve, especially if you&#x27;re not familiar with OCaml or similar languages. Maybe Why3 is more beginner friendly <a href="https:&#x2F;&#x2F;www.why3.org" rel="nofollow">https:&#x2F;&#x2F;www.why3.org</a><p>Proving vs verifying: could mean the same thing. Proving seems to me as something more interactive in nature, while verifying could be automatized (model checking, SMT-solving of annotated programs).</div><br/><div id="40261200" class="c"><input type="checkbox" id="c-40261200" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261152">parent</a><span>|</span><a href="#40260552">next</a><span>|</span><label class="collapse" for="c-40261200">[-]</label><label class="expand" for="c-40261200">[2 more]</label></div><br/><div class="children"><div class="content">Working programmers write proofs in a limited sense. Any time you write types you&#x27;re writing a proof. Maybe it&#x27;s a stretch to say &quot;const a: int = b;&quot; is a proof, but when you get into higher-order types in TypeScript it&#x27;s appropriate.</div><br/><div id="40261809" class="c"><input type="checkbox" id="c-40261809" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261200">parent</a><span>|</span><a href="#40260552">next</a><span>|</span><label class="collapse" for="c-40261809">[-]</label><label class="expand" for="c-40261809">[1 more]</label></div><br/><div class="children"><div class="content">A trivial proof is still a proof.<p>There&#x27;s nothing trivial about &quot;const a: int = foo();&quot; though. Compilers disprove the claim by contradiction all the time.</div><br/></div></div></div></div></div></div><div id="40260552" class="c"><input type="checkbox" id="c-40260552" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#40260398">parent</a><span>|</span><a href="#40261152">prev</a><span>|</span><a href="#40262863">next</a><span>|</span><label class="collapse" for="c-40260552">[-]</label><label class="expand" for="c-40260552">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, is there a good learning resource on &quot;proving&quot; things about code for working programmers without a strong CS &#x2F; math background?<p>I don’t know how difficult Software Foundations is for someone with a limited background but it’s probably worth trying:<p><a href="https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu&#x2F;</a></div><br/></div></div><div id="40262863" class="c"><input type="checkbox" id="c-40262863" checked=""/><div class="controls bullet"><span class="by">A1kmm</span><span>|</span><a href="#40260398">parent</a><span>|</span><a href="#40260552">prev</a><span>|</span><a href="#40260886">next</a><span>|</span><label class="collapse" for="c-40262863">[-]</label><label class="expand" for="c-40262863">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What is the difference between &quot;verifying&quot; the 
&gt; correctness of code, as they say here, vs &quot;proving&quot; 
&gt; the correctness of code, as I sometimes see said 
&gt; elsewhere?<p>There is not much difference, except that verification usually includes identifying a formal logical proposition about the behaviour of the code.<p>In other words, formally verified code is code that has been proven to meet at least one formal proposition about its behaviour - for example, a proposition about a function f might be: if variable x is greater than 0, then `f(x) = 1`.<p>There is no such thing as proving something &#x27;correct&#x27;, you need someone to define what exactly correct means, and then someone proves it meets that definition. So the proving is only a subset of the overall formal verification task.<p>&gt; Also, is there a good learning resource on &quot;proving&quot; things about code for working 
&gt; programmers without a strong CS &#x2F; math background?<p>Most will be specific to a particular technology and type of verification. There are some courses online that provide a high level overview, e.g. <a href="https:&#x2F;&#x2F;anton-trunov.github.io&#x2F;csclub-coq-course-spring-2021&#x2F;slides&#x2F;intro.html" rel="nofollow">https:&#x2F;&#x2F;anton-trunov.github.io&#x2F;csclub-coq-course-spring-2021...</a>.<p>If you want to get into specifics, you might need to pick an approach. You could learn a dependently typed language, for example there are some good resources out there on proving things in Agda or Idris. Or perhaps play around with one of the formal verification systems that can be bolted on to C or Rust.<p>&gt; Edit: I&#x27;m also very curious why &quot;zero knowledge&quot; proofs are so significant, and why this
&gt; is so relevant. Eg I heard people talking about this and don&#x27;t really understand why it&#x27;s
&gt;  so cool: x.com&#x2F;ZorpZK<p>ZK is an exciting area of cryptology because breakthroughs in that area power new applications that people wouldn&#x27;t have thought possible before. Applications to cryptocurrencies in particular can solve some of their scaling and privacy problems.<p>For example, one of the biggest problems with cryptocurrencies is that every single transaction ever needs to be recorded in a ledger that is distributed to every node participating in the network. That simply won&#x27;t scale to microtransactions. Let&#x27;s say that 1000 people each start with 1 coin, and do 100,000 small transactions averaging 0.001 coins amongst themselves (maybe they bought a coffee, or paid for information on a per-view basis, or whatever). Storing those 100,000 transactions forever will have an ongoing cost for every one of thousands of nodes on the network long after the transaction has happened.<p>Now that could be solved with centralisation - the parties send their transactions to a trusted company, who maintains balances for each of them without sending transactions to the network, but lets them withdraw their balance to the network if they ever want to. But centralisation is a risk - what if the company betrays their trust?<p>Zero-knowledge cryptography allows for the parties to roll up the signed transactions into a cryptographic proof saying, given these were the balances at the start of the 100,000 transactions, the person creating the roll-up has access to the signed transactions proving that the balances of each of the 1,000 parties at the end are this. Notably, the proof can be much smaller than the size of the 100,000 transactions. So that enables applications where people work off in &#x27;side chains&#x27;, and but can merge the side chain back into the main chain by submitting proof about the effects (but not all the detail of) the side chain into the main chain.</div><br/></div></div><div id="40260886" class="c"><input type="checkbox" id="c-40260886" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#40260398">parent</a><span>|</span><a href="#40262863">prev</a><span>|</span><a href="#40260453">next</a><span>|</span><label class="collapse" for="c-40260886">[-]</label><label class="expand" for="c-40260886">[1 more]</label></div><br/><div class="children"><div class="content">Verification is proving specific things about specific properties of the program.</div><br/></div></div><div id="40260453" class="c"><input type="checkbox" id="c-40260453" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40260398">parent</a><span>|</span><a href="#40260886">prev</a><span>|</span><a href="#40260454">next</a><span>|</span><label class="collapse" for="c-40260453">[-]</label><label class="expand" for="c-40260453">[8 more]</label></div><br/><div class="children"><div class="content">&gt; What is the difference between &quot;verifying&quot; the correctness of code, as they say here, vs &quot;proving&quot; the correctness of code, as I sometimes see said elsewhere?<p>In this context it is the same.<p>&gt; Also, is there a good learning resource on &quot;proving&quot; things about code for working programmers without a strong CS &#x2F; math background?<p>I wish. The Dafny docs are pretty good but IMO formal software verification is not really at the point where it is usable for normal programmers like us who don&#x27;t have a PhD in CS &#x2F; maths. The examples make it look relatively easy, but you will quickly run into &quot;nope, couldn&#x27;t prove it&quot; and the answer as to why is some hardcore implementation detail that only the authors would know.</div><br/><div id="40261837" class="c"><input type="checkbox" id="c-40261837" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260453">parent</a><span>|</span><a href="#40260483">next</a><span>|</span><label class="collapse" for="c-40261837">[-]</label><label class="expand" for="c-40261837">[1 more]</label></div><br/><div class="children"><div class="content">&gt; IMO formal software verification is not really at the point where it is usable for normal programmers like us who don&#x27;t have a PhD in CS &#x2F; maths.<p>I know. Four decades ago I headed a project to build a system amazingly similar to this one, intended for real-time automobile engine control code.[1][2] This new system for Rust looks practical. It seems to be intended for people who need bug-free code. Most verification systems come from people in love with formalism. Those involve too much human labor.<p>Hints:<p>- The assertions and invariants need to be part of the language. Not something in comments, and not different syntax. They should be syntax and type checked during compiles, even if the compiler doesn&#x27;t do much with them.<p>- It&#x27;s useful to work off the compiler&#x27;s intermediate representation rather than the raw source code. Then you&#x27;re sure the compiler and verifier interpret the syntax the same way.<p>- SAT solvers aren&#x27;t powerful enough to do the whole job, and systems like Coq are too manual. You need two provers. A SAT solver is enough to knock off 90% of the proofs automatically. Then, the programmer focuses the problem by adding assertions, until you get the point where you have<p><pre><code>    assert(a);
    assert(b);
 </code></pre>
and just need to prove that a implies b as an abstraction mostly separate from the code.
<i>Then</i> you go to the more elaborate prover. We used the Boyer-Moore prover for that. After proving a implies b, that became a theorem&#x2F;rule the fast prover could use when it matched. So if the same situation came up again in code, the rule would be re-used automatically.<p>I notice that the examples for this verified Rust system don&#x27;t seem to include a termination check for loops. You prove that loops terminate by demonstrating that some nonnegative integer expression decreases on each iteration and never goes negative. If you can&#x27;t prove that easily, the code has no place in mission-critical code.<p>Microsoft&#x27;s F* is probably the biggest success in this area.[3]<p>[1] <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;manualzilla-id-5928072&#x2F;page&#x2F;n3&#x2F;mode&#x2F;2up" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;manualzilla-id-5928072&#x2F;page&#x2F;n3&#x2F;m...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;John-Nagle&#x2F;pasv">https:&#x2F;&#x2F;github.com&#x2F;John-Nagle&#x2F;pasv</a><p>[3] <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;video&#x2F;programming-with-proofs-for-high-assurance-software&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;video&#x2F;programming-w...</a></div><br/></div></div><div id="40260483" class="c"><input type="checkbox" id="c-40260483" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260453">parent</a><span>|</span><a href="#40261837">prev</a><span>|</span><a href="#40261208">next</a><span>|</span><label class="collapse" for="c-40260483">[-]</label><label class="expand" for="c-40260483">[4 more]</label></div><br/><div class="children"><div class="content">Formal software verification encompasses a wide set of what we refer to as advanced mathematics. The process of taking some thing you want the code to do, correctly abstracting it out into component lemmas, and generating proofs for those lemmas, is itself advanced mathematics. I don&#x27;t really see a way that this could be simplified.</div><br/><div id="40261835" class="c"><input type="checkbox" id="c-40261835" checked=""/><div class="controls bullet"><span class="by">screcth</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260483">parent</a><span>|</span><a href="#40261208">next</a><span>|</span><label class="collapse" for="c-40261835">[-]</label><label class="expand" for="c-40261835">[3 more]</label></div><br/><div class="children"><div class="content">Formal hardware verification has been much more successful in industry. Are there fundamental differences in the types of problems that they solve? EDA companies have been able to create tools that don&#x27;t require a PhD in Math to be used effectively.<p>I think that the explanation for such different levels of success is that economic incentives are different. The cost of a hardware bug is much much higher than the cost of the average software bug; this means that hardware companies are willing to spend a lot of money in getting designs right the first time, versus software companies that know they can always make bug fixes in new versions of their products.
Additionally, hardware companies are used to paying millions of dollars in software licenses, which is not common in the software world.</div><br/><div id="40262857" class="c"><input type="checkbox" id="c-40262857" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261835">parent</a><span>|</span><a href="#40261208">next</a><span>|</span><label class="collapse" for="c-40262857">[-]</label><label class="expand" for="c-40262857">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I agree formal hardware verification is an order of magnitude easier to use.<p>My guess is it&#x27;s because the problem is so much simpler. No variables, no loops, no recursion, etc.</div><br/><div id="40263107" class="c"><input type="checkbox" id="c-40263107" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40262857">parent</a><span>|</span><a href="#40261208">next</a><span>|</span><label class="collapse" for="c-40263107">[-]</label><label class="expand" for="c-40263107">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the challenge in any formal software verification is dealing with unbounded inputs and compute durations, as enabled by recursive programs. If the code under analysis is straight-line non-reentrant basic logical blocks, the verification is quite trivial indeed. This is <i>vaguely</i> the case for hardware verification, though of course there are complexities introduced by the physical nature of the embedding.</div><br/></div></div></div></div></div></div></div></div><div id="40261208" class="c"><input type="checkbox" id="c-40261208" checked=""/><div class="controls bullet"><span class="by">opnitro</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260453">parent</a><span>|</span><a href="#40260483">prev</a><span>|</span><a href="#40260454">next</a><span>|</span><label class="collapse" for="c-40261208">[-]</label><label class="expand" for="c-40261208">[2 more]</label></div><br/><div class="children"><div class="content">This is why I think interactive proof assistants (as opposed to &quot;automatic&quot; ones like Dafny), are a better starting point for learning. You&#x27;re still gonna need to learn some higher level concepts, but you won&#x27;t have the frustrating experience of the automation just failing and leaving you shrugging.<p>Software Foundations is great: <a href="https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu" rel="nofollow">https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu</a><p>If you stick with it long enough, you&#x27;ll even build up to Hoare logic which is the underpinning the tools like dafny use to generate the equations they throw to the solver.</div><br/><div id="40261911" class="c"><input type="checkbox" id="c-40261911" checked=""/><div class="controls bullet"><span class="by">algorithmsRcool</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261208">parent</a><span>|</span><a href="#40260454">next</a><span>|</span><label class="collapse" for="c-40261911">[-]</label><label class="expand" for="c-40261911">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve found the DX of Dafny to be very approachable. The VSCode extension is pretty great, and you get feedback as you type. Also, its ability to give you counter examples in the IDE is really nice.</div><br/></div></div></div></div></div></div><div id="40260454" class="c"><input type="checkbox" id="c-40260454" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40260398">parent</a><span>|</span><a href="#40260453">prev</a><span>|</span><a href="#40261037">next</a><span>|</span><label class="collapse" for="c-40260454">[-]</label><label class="expand" for="c-40260454">[8 more]</label></div><br/><div class="children"><div class="content">AFAIK, zero-knowledge proofs allow you to prove that you know something without revealing what it is you know. For example, verifying you know a password, but without having to send the password to the server, so a malicious server or MitM wouldn&#x27;t be able to sniff it.<p>It also might provide better options for identity verification, i.e. proving you have a certain government-issued ID but without actually leaking the document to the server (for it to be stored &quot;for a maximum of 2 years &#x2F; 3 years &#x2F; 6 months &#x2F; etc.&quot; but then leaked in a data breach anyway).</div><br/><div id="40260492" class="c"><input type="checkbox" id="c-40260492" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260454">parent</a><span>|</span><a href="#40261037">next</a><span>|</span><label class="collapse" for="c-40260492">[-]</label><label class="expand" for="c-40260492">[7 more]</label></div><br/><div class="children"><div class="content">Secure password verification does not require anything close to what we mean when we refer to modern &quot;zero knowledge proofs&quot;. A better example would be verifying you know the answer to a SAT problem without sharing the answer. Which is of... limited.. practical application.</div><br/><div id="40260928" class="c"><input type="checkbox" id="c-40260928" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260492">parent</a><span>|</span><a href="#40260525">next</a><span>|</span><label class="collapse" for="c-40260928">[-]</label><label class="expand" for="c-40260928">[4 more]</label></div><br/><div class="children"><div class="content">ZK proofs could be used to implement secure cloud computing where a total compromise of a vendor’s machines &#x2F; network wouldn’t in any way compromise the customers running workloads on that network.</div><br/><div id="40261541" class="c"><input type="checkbox" id="c-40261541" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260928">parent</a><span>|</span><a href="#40261656">next</a><span>|</span><label class="collapse" for="c-40261541">[-]</label><label class="expand" for="c-40261541">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps. But if someone cares that much about data access control, they can <i>very easily</i> manage a rack in house (they probably already do), and do the compute on that. Paying someone else to do orders of magnitude more work than strictly needed when you have private enough data to justify just buying a server (again, you already have one) is a very hard sell. It could <i>maybe, possibly</i> be justified if the workload is highly burstable, but... even then, it&#x27;s hard to come up with numbers that make sense.</div><br/></div></div><div id="40261656" class="c"><input type="checkbox" id="c-40261656" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260928">parent</a><span>|</span><a href="#40261541">prev</a><span>|</span><a href="#40260525">next</a><span>|</span><label class="collapse" for="c-40261656">[-]</label><label class="expand" for="c-40261656">[2 more]</label></div><br/><div class="children"><div class="content">Is homomorphic encryption a type of ZKP or is it a different thing entirely?</div><br/><div id="40262656" class="c"><input type="checkbox" id="c-40262656" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40261656">parent</a><span>|</span><a href="#40260525">next</a><span>|</span><label class="collapse" for="c-40262656">[-]</label><label class="expand" for="c-40262656">[1 more]</label></div><br/><div class="children"><div class="content">Good question. I found [1] but I’m not a cryptographer so I may have made mistake because they’re so closely related. It sounds like homomorphic encryption is the strong aspect. ZKP are used in securing chats in Signal for example: <a href="https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2019&#x2F;1416.pdf" rel="nofollow">https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2019&#x2F;1416.pdf</a><p>[1] <a href="https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;57747&#x2F;what-is-the-link-if-any-between-zero-knowledge-proof-zkp-and-homomorphic-enc" rel="nofollow">https:&#x2F;&#x2F;crypto.stackexchange.com&#x2F;questions&#x2F;57747&#x2F;what-is-the...</a></div><br/></div></div></div></div></div></div><div id="40260525" class="c"><input type="checkbox" id="c-40260525" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260492">parent</a><span>|</span><a href="#40260928">prev</a><span>|</span><a href="#40261037">next</a><span>|</span><label class="collapse" for="c-40260525">[-]</label><label class="expand" for="c-40260525">[2 more]</label></div><br/><div class="children"><div class="content">I never said it required ZKP.</div><br/><div id="40260547" class="c"><input type="checkbox" id="c-40260547" checked=""/><div class="controls bullet"><span class="by">dumbo-octopus</span><span>|</span><a href="#40260398">root</a><span>|</span><a href="#40260525">parent</a><span>|</span><a href="#40261037">next</a><span>|</span><label class="collapse" for="c-40260547">[-]</label><label class="expand" for="c-40260547">[1 more]</label></div><br/><div class="children"><div class="content">You implied it would be a helpful tool for soling that particular problem, which is to dramatically misrepresent their utility to the parent asking for concrete examples of their relevance.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40261037" class="c"><input type="checkbox" id="c-40261037" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40260398">prev</a><span>|</span><a href="#40263021">next</a><span>|</span><label class="collapse" for="c-40261037">[-]</label><label class="expand" for="c-40261037">[2 more]</label></div><br/><div class="children"><div class="content">For those that are interested but perhaps not aware of this similar project, Dafny is a &quot;verification-aware programming language&quot; that can compile to rust: <a href="https:&#x2F;&#x2F;github.com&#x2F;dafny-lang&#x2F;dafny">https:&#x2F;&#x2F;github.com&#x2F;dafny-lang&#x2F;dafny</a></div><br/><div id="40261424" class="c"><input type="checkbox" id="c-40261424" checked=""/><div class="controls bullet"><span class="by">algorithmsRcool</span><span>|</span><a href="#40261037">parent</a><span>|</span><a href="#40263021">next</a><span>|</span><label class="collapse" for="c-40261424">[-]</label><label class="expand" for="c-40261424">[1 more]</label></div><br/><div class="children"><div class="content">Always cool to see Dafny mentioned!<p>Shameless plug: I just wrote a beginner&#x27;s introduction to Dafny a few days ago.<p><a href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;pulse&#x2F;getting-started-dafny-your-first-formal-proof-alfred-white-puucc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.linkedin.com&#x2F;pulse&#x2F;getting-started-dafny-your-fi...</a></div><br/></div></div></div></div><div id="40263021" class="c"><input type="checkbox" id="c-40263021" checked=""/><div class="controls bullet"><span class="by">camkego</span><span>|</span><a href="#40261037">prev</a><span>|</span><a href="#40263018">next</a><span>|</span><label class="collapse" for="c-40263021">[-]</label><label class="expand" for="c-40263021">[1 more]</label></div><br/><div class="children"><div class="content">Could someone familiar with Verus comment on the power and expressiveness of Verus vs. Lean4<p>I understand Verus is an SMT based verification tool, and Lean is both an interactive prover and SMT based tool.<p>But my understanding in the area of formal verification is limited, and it would be good to get an opinion from someone well versed in formal methods for software.</div><br/></div></div><div id="40263018" class="c"><input type="checkbox" id="c-40263018" checked=""/><div class="controls bullet"><span class="by">lifeinthevoid</span><span>|</span><a href="#40263021">prev</a><span>|</span><a href="#40260721">next</a><span>|</span><label class="collapse" for="c-40263018">[-]</label><label class="expand" for="c-40263018">[2 more]</label></div><br/><div class="children"><div class="content">Is there some way to implement this so that the resulting code is still valid Rust code that can be compiled using vanilla Rust tools?</div><br/><div id="40263074" class="c"><input type="checkbox" id="c-40263074" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40263018">parent</a><span>|</span><a href="#40260721">next</a><span>|</span><label class="collapse" for="c-40263074">[-]</label><label class="expand" for="c-40263074">[1 more]</label></div><br/><div class="children"><div class="content">It is valid Rust... but only because it wraps everything in a proc macro.<p>Creusot does it in a different way using attributes, which IMO is a better approach because it means normal tooling works, though it does have much worse syntax.</div><br/></div></div></div></div><div id="40260721" class="c"><input type="checkbox" id="c-40260721" checked=""/><div class="controls bullet"><span class="by">dist1ll</span><span>|</span><a href="#40263018">prev</a><span>|</span><a href="#40260733">next</a><span>|</span><label class="collapse" for="c-40260721">[-]</label><label class="expand" for="c-40260721">[1 more]</label></div><br/><div class="children"><div class="content">One of the main contributors gave an excellent talk [0] on Verus at the Rust meetup in Zürich. I was really impressed how clean this &quot;ghost&quot; code fits into programs (reminded me a bit of Ada).<p>[0] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ZZTk-zS4ZCY" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ZZTk-zS4ZCY</a></div><br/></div></div><div id="40260733" class="c"><input type="checkbox" id="c-40260733" checked=""/><div class="controls bullet"><span class="by">TachyonicBytes</span><span>|</span><a href="#40260721">prev</a><span>|</span><a href="#40260912">next</a><span>|</span><label class="collapse" for="c-40260733">[-]</label><label class="expand" for="c-40260733">[2 more]</label></div><br/><div class="children"><div class="content">Is there any relationship between this and Kani[1]? Do they work differently?<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;model-checking&#x2F;kani">https:&#x2F;&#x2F;github.com&#x2F;model-checking&#x2F;kani</a></div><br/><div id="40260901" class="c"><input type="checkbox" id="c-40260901" checked=""/><div class="controls bullet"><span class="by">mmoskal</span><span>|</span><a href="#40260733">parent</a><span>|</span><a href="#40260912">next</a><span>|</span><label class="collapse" for="c-40260901">[-]</label><label class="expand" for="c-40260901">[1 more]</label></div><br/><div class="children"><div class="content">Model checkers typically only explore a bounded number of states which is efficient at bug finding and often doesn&#x27;t require additional annotations in the program.<p>Automatic (SMT-based) verifiers like Verus, Dafny, F* (and my VCC :) require you to annotate most every function and loop but give you broad guarantees about the correctness of the program.<p>Tools based on interactive provers (like Coq or Lean) typically require more guidance from the user but can guarantee even more complex properties.</div><br/></div></div></div></div><div id="40260912" class="c"><input type="checkbox" id="c-40260912" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#40260733">prev</a><span>|</span><a href="#40261844">next</a><span>|</span><label class="collapse" for="c-40260912">[-]</label><label class="expand" for="c-40260912">[1 more]</label></div><br/><div class="children"><div class="content">This looks really cool. One thing I think would be really useful for people is some instructions &#x2F; examples of how to add proofs for an existing codebase.<p>So maybe an example could be a bare-bones gui app with a single textbox, that does an http request to some resource (having data that is unknown at compile-time and potentially untrusted is a very common thing) and fetches an array, which is bubble-sorted and displayed in the box. The bubble sort has some intentional bug (maybe due to some off by one error, the last element remains untouched). There are unit-tests that somehow don&#x27;t trigger the bug (worrying that your tests are incomplete would be a primary motivator to go for proofs). It could then show how to replace the unit tests with a proof, in the process discovering the bug and fixing it.<p>The example wouldn&#x27;t need to go into huge detail about the proof code itself as it is potentially advanced, instead it would focus on the nitty-gritty details of adding the proof, like how the interface between proved mathematical code and non-proved io code works, what command line to run to prove&amp;build, and finally a zip archive with all of that, that you can play around with.<p>Edit: Actually just reading from stdin and writing to stdout is probably good enough.</div><br/></div></div><div id="40261844" class="c"><input type="checkbox" id="c-40261844" checked=""/><div class="controls bullet"><span class="by">nullorempty</span><span>|</span><a href="#40260912">prev</a><span>|</span><a href="#40260396">next</a><span>|</span><label class="collapse" for="c-40261844">[-]</label><label class="expand" for="c-40261844">[3 more]</label></div><br/><div class="children"><div class="content">Hm, so you write the code twice :)</div><br/><div id="40262910" class="c"><input type="checkbox" id="c-40262910" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40261844">parent</a><span>|</span><a href="#40262838">next</a><span>|</span><label class="collapse" for="c-40262910">[-]</label><label class="expand" for="c-40262910">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not wrong, but formal verification is still useful for multiple reasons:<p>1. Cases where specification is much less complex than implementation, like proving a sorting algorithm - the spec is very simple, forall integer i,j : i&lt;j ==&gt; result[i]&lt;=result[j] plus the requirement that elements may not be removed or added<p>2. Ability to eliminate checks for improved performance (not sure if this applies to Rust yet, but it works great with Frama-C).<p>3. &quot;Unit tests&quot; for entire classes of behavior, not just specific inputs. Even if you cannot write a formal specification for a huge complex protocol, you can incrementally add asserts which cover much more area than simple unit tests.</div><br/></div></div><div id="40262838" class="c"><input type="checkbox" id="c-40262838" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#40261844">parent</a><span>|</span><a href="#40262910">prev</a><span>|</span><a href="#40260396">next</a><span>|</span><label class="collapse" for="c-40262838">[-]</label><label class="expand" for="c-40262838">[1 more]</label></div><br/><div class="children"><div class="content">You make implicit assumptions you had during development explicit through code or comments which doesn&#x27;t actually effect runtime execution speed since it only runs in debug&#x2F;compile time.<p>There&#x27;s a place for formal verification, usually in places where a bug causes death or significant financial loss.</div><br/></div></div></div></div><div id="40260396" class="c"><input type="checkbox" id="c-40260396" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40261844">prev</a><span>|</span><a href="#40260391">next</a><span>|</span><label class="collapse" for="c-40260396">[-]</label><label class="expand" for="c-40260396">[3 more]</label></div><br/><div class="children"><div class="content">Interesting! Looks most similar to Creusot. The syntax is definitely nicer but wrapping your entire code in a macro surely is going to upset rust-analyzer?</div><br/><div id="40260760" class="c"><input type="checkbox" id="c-40260760" checked=""/><div class="controls bullet"><span class="by">jaybosamiya</span><span>|</span><a href="#40260396">parent</a><span>|</span><a href="#40260449">next</a><span>|</span><label class="collapse" for="c-40260760">[-]</label><label class="expand" for="c-40260760">[1 more]</label></div><br/><div class="children"><div class="content">A fork of rust-analyzer, called verus-analyzer, provides support for Verus syntax and actions (including new proof-specific actions) <a href="https:&#x2F;&#x2F;github.com&#x2F;verus-lang&#x2F;verus-analyzer&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;verus-lang&#x2F;verus-analyzer&#x2F;</a></div><br/></div></div><div id="40260449" class="c"><input type="checkbox" id="c-40260449" checked=""/><div class="controls bullet"><span class="by">tsujamin</span><span>|</span><a href="#40260396">parent</a><span>|</span><a href="#40260760">prev</a><span>|</span><a href="#40260391">next</a><span>|</span><label class="collapse" for="c-40260449">[-]</label><label class="expand" for="c-40260449">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure how rust-analyser works, but presumably you’d make the macro a no-op and just return the original tokens in debug builds</div><br/></div></div></div></div><div id="40260391" class="c"><input type="checkbox" id="c-40260391" checked=""/><div class="controls bullet"><span class="by">jimsimmons</span><span>|</span><a href="#40260396">prev</a><span>|</span><label class="collapse" for="c-40260391">[-]</label><label class="expand" for="c-40260391">[3 more]</label></div><br/><div class="children"><div class="content">What exactly do SMT systems &quot;solve&quot; in cases like this?<p>If I wrote a simple BFS or DFS and enumerated the search space how far would I get.. Is that not what TLA+ does in principle.<p>I am surprised people prefer having a dependency of something like Z3 at compiler level.</div><br/><div id="40261081" class="c"><input type="checkbox" id="c-40261081" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#40260391">parent</a><span>|</span><a href="#40260435">next</a><span>|</span><label class="collapse" for="c-40261081">[-]</label><label class="expand" for="c-40261081">[1 more]</label></div><br/><div class="children"><div class="content">SAT is an NP-complete problem. Doing an exhaustive search is very time-consuming. An SMT or SAT solver uses heuristics to make that process quicker for practical problems.<p>It looks like there are some TLA+ implementations that do use SMT solvers under the hood.</div><br/></div></div><div id="40260435" class="c"><input type="checkbox" id="c-40260435" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40260391">parent</a><span>|</span><a href="#40261081">prev</a><span>|</span><label class="collapse" for="c-40260435">[-]</label><label class="expand" for="c-40260435">[1 more]</label></div><br/><div class="children"><div class="content">They try to find a counter-example to the constraints you have set up, or tell you that no such counter-example exists, in which case your program is correct. The counter-example is in the form of inputs to your program or function.<p>It looks like the TLA+ Proof System does the same thing, but I believe you can also use TLA+ in &quot;brute force all the states&quot; mode. I haven&#x27;t actually used it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>