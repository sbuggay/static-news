<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1711357261539" as="style"/><link rel="stylesheet" href="styles.css?v=1711357261539"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://cons.io/">Gerbil Scheme – A Lisp for the 21st Century</a> <span class="domain">(<a href="https://cons.io">cons.io</a>)</span></div><div class="subtext"><span>gjvc</span> | <span>39 comments</span></div><br/><div><div id="39813054" class="c"><input type="checkbox" id="c-39813054" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#39811806">next</a><span>|</span><label class="collapse" for="c-39813054">[-]</label><label class="expand" for="c-39813054">[5 more]</label></div><br/><div class="children"><div class="content">I miss pg. Lisp commentary has never recovered from his departure. Ten hours with no comments about the project or a tangent about Lisp itself is a darn shame.<p>Why not write one myself? Drained. Lisp is near and dear to my heart, but midnight when I have to do our morning time routine with our 7mo at 6am isn’t the time to wax poetic.<p>The most worrisome thing is actually the most ironic: no one is posting any hate comments either. Back a decade ago, you’d get into long battles about whether it was a good or bad idea to choose any Lisp, or at least some jeers from the sidelines. But that, counterintuitively, was one of Lisp’s strengths. When I was younger, that kind of thing originally sparked my curiosity: if most people were jeering, and most people weren’t too smart, then could there be something to this whole Lisp trend (even if it seemed like more of a university project than a trend)? And it turns out there was.<p>Loved or hated, you’re noticed. The pit of indifference is a bad place for an ecosystem to be. It’s long past time someone write about it in… well, in a way that can only be described as pg style. He had a knack for making young devs hungry for more. <a href="https:&#x2F;&#x2F;paulgraham.com&#x2F;avg.html" rel="nofollow">https:&#x2F;&#x2F;paulgraham.com&#x2F;avg.html</a><p>The essays still hold up. They’re as true today as they were then. But no one will believe them without an example. I wouldn’t have believed it if pg hadn’t released Arc, and sometimes it feels like I’m the only one in the world that actually uses it to solve problems that I personally have.<p>But the nice thing about Lisp is that it’s always there, waiting to be discovered. It’s arguably one of the few types of programming ecosystems that can be discovered rather than designed. It’s precisely why there are so many choices. And it also doesn’t matter that nobody else uses it, just that you like it, that it solves your problems, and you find it endlessly fascinating. Hopefully our generation won’t be the last, at least for a long while.</div><br/><div id="39813502" class="c"><input type="checkbox" id="c-39813502" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#39813054">parent</a><span>|</span><a href="#39811806">next</a><span>|</span><label class="collapse" for="c-39813502">[-]</label><label class="expand" for="c-39813502">[4 more]</label></div><br/><div class="children"><div class="content">OK, I&#x27;ll jeer: I&#x27;m a big fan of [McCarthy60], but everything-is-a-list implicitly introduces order, and the 21st century ought to explicitly accommodate the unordered as well. (there ought not be any is-more-basic-than relation between ordered and unordered)</div><br/><div id="39813981" class="c"><input type="checkbox" id="c-39813981" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#39813054">root</a><span>|</span><a href="#39813502">parent</a><span>|</span><a href="#39813606">next</a><span>|</span><label class="collapse" for="c-39813981">[-]</label><label class="expand" for="c-39813981">[1 more]</label></div><br/><div class="children"><div class="content">This is actually very good insight that makes me pause and ponder about its implications. Do you know any in depth research&#x2F;paper on this topic?<p>Ordered data types are core to computers actually: arrays, heck even the memory itself. I always thought the list to be the most fundamental construct, but outside the neat world of computer, the real world is mostly unordered. Order is artificial, is indeed often not a given.</div><br/></div></div><div id="39813606" class="c"><input type="checkbox" id="c-39813606" checked=""/><div class="controls bullet"><span class="by">sillysaurusx</span><span>|</span><a href="#39813054">root</a><span>|</span><a href="#39813502">parent</a><span>|</span><a href="#39813981">prev</a><span>|</span><a href="#39811806">next</a><span>|</span><label class="collapse" for="c-39813606">[-]</label><label class="expand" for="c-39813606">[2 more]</label></div><br/><div class="children"><div class="content">I agree! That’s actually not a jeer, it’s one of my main criticisms of lisp. You don’t need lists to have lisp. In many respects it works better without them; <a href="https:&#x2F;&#x2F;github.com&#x2F;sctb&#x2F;lumen">https:&#x2F;&#x2F;github.com&#x2F;sctb&#x2F;lumen</a> proves it, since hash tables and arrays are the fundamental data structure. They have to be, because that’s the only way lumen can run in JS or Lua.<p>Every time I can’t delete the first element of a list in lisp (I.e. del x[0] in the python sense) I get annoyed with racket.<p>The reason I look past it is because the benefits are so good that they outweigh the annoyances. I wouldn’t trade it away.</div><br/></div></div></div></div></div></div><div id="39811806" class="c"><input type="checkbox" id="c-39811806" checked=""/><div class="controls bullet"><span class="by">chmaynard</span><span>|</span><a href="#39813054">prev</a><span>|</span><a href="#39811809">next</a><span>|</span><label class="collapse" for="c-39811806">[-]</label><label class="expand" for="c-39811806">[2 more]</label></div><br/><div class="children"><div class="content">Gerbil scheme is a variant of Scheme implemented on Gambit-C. It supports current R*RS standards and common SRFIs and has a state of the art macro and module system inspired by Racket.<p>Source: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gambit_(Scheme_implementation)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gambit_(Scheme_implementation)</a></div><br/><div id="39813050" class="c"><input type="checkbox" id="c-39813050" checked=""/><div class="controls bullet"><span class="by">petre</span><span>|</span><a href="#39811806">parent</a><span>|</span><a href="#39811809">next</a><span>|</span><label class="collapse" for="c-39813050">[-]</label><label class="expand" for="c-39813050">[1 more]</label></div><br/><div class="children"><div class="content">If one is acquainted to Scheme, it&#x27;s better skimming through the introduction for an overview of all the language features.<p><a href="https:&#x2F;&#x2F;cons.io&#x2F;guide&#x2F;intro.html" rel="nofollow">https:&#x2F;&#x2F;cons.io&#x2F;guide&#x2F;intro.html</a><p>Seeing it has objects, methods structs, optional type annotation, couroutines, actor model, I tried to build it but the Gambit Scheme on my system was too old and I gave up.<p>Also an older but still useful overview of all the Schemes when used for scientific computing:<p><a href="http:&#x2F;&#x2F;fmnt.info&#x2F;blog&#x2F;20181029_scheme.html" rel="nofollow">http:&#x2F;&#x2F;fmnt.info&#x2F;blog&#x2F;20181029_scheme.html</a></div><br/></div></div></div></div><div id="39811809" class="c"><input type="checkbox" id="c-39811809" checked=""/><div class="controls bullet"><span class="by">clircle</span><span>|</span><a href="#39811806">prev</a><span>|</span><a href="#39812812">next</a><span>|</span><label class="collapse" for="c-39811809">[-]</label><label class="expand" for="c-39811809">[29 more]</label></div><br/><div class="children"><div class="content">Lisp, like linux, might actually benefit from fewer choices</div><br/><div id="39812620" class="c"><input type="checkbox" id="c-39812620" checked=""/><div class="controls bullet"><span class="by">magpi3</span><span>|</span><a href="#39811809">parent</a><span>|</span><a href="#39812569">next</a><span>|</span><label class="collapse" for="c-39812620">[-]</label><label class="expand" for="c-39812620">[1 more]</label></div><br/><div class="children"><div class="content">That is short-term thinking for both linux and lisp. In the long-term, we need more experimentation, more creativity, and more risk-taking. Always. And what better place for that than on HN (at least for discussion purposes).</div><br/></div></div><div id="39812569" class="c"><input type="checkbox" id="c-39812569" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#39811809">parent</a><span>|</span><a href="#39812620">prev</a><span>|</span><a href="#39813068">next</a><span>|</span><label class="collapse" for="c-39812569">[-]</label><label class="expand" for="c-39812569">[3 more]</label></div><br/><div class="children"><div class="content">The vast array of Schemes available is part of what made me eventually land at Tcl and just dig in there.</div><br/><div id="39813846" class="c"><input type="checkbox" id="c-39813846" checked=""/><div class="controls bullet"><span class="by">a-french-anon</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812569">parent</a><span>|</span><a href="#39813210">next</a><span>|</span><label class="collapse" for="c-39813846">[-]</label><label class="expand" for="c-39813846">[1 more]</label></div><br/><div class="children"><div class="content">Fun thing is that Tcl was relegated to the role of gateway drug to Common Lisp, in my case. I still use it when I want a more modern stdlib or its well-integrated event loop.<p>(I actually tried to retrofit some of CL in Tcl, heh; <a href="https:&#x2F;&#x2F;wiki.tcl-lang.org&#x2F;page&#x2F;q3cpma" rel="nofollow">https:&#x2F;&#x2F;wiki.tcl-lang.org&#x2F;page&#x2F;q3cpma</a>)</div><br/></div></div><div id="39813210" class="c"><input type="checkbox" id="c-39813210" checked=""/><div class="controls bullet"><span class="by">jrapdx3</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812569">parent</a><span>|</span><a href="#39813846">prev</a><span>|</span><a href="#39813068">next</a><span>|</span><label class="collapse" for="c-39813210">[-]</label><label class="expand" for="c-39813210">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly I&#x27;ve had a similar experience. I used Chicken Scheme for a number of years after programming in Tcl for a long time. Tcl always seemed to be a kind of Lisp, an impression that only increased over time. Eventually I resumed using Tcl when I realized the language had been steadily improved over several years. With Tcl 9.0 on the horizon I see no reason to look elsewhere for accomplishing most programming tasks.</div><br/></div></div></div></div><div id="39813068" class="c"><input type="checkbox" id="c-39813068" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#39811809">parent</a><span>|</span><a href="#39812569">prev</a><span>|</span><a href="#39812759">next</a><span>|</span><label class="collapse" for="c-39813068">[-]</label><label class="expand" for="c-39813068">[3 more]</label></div><br/><div class="children"><div class="content">I wonder how much the existence of the &quot;a lisp&quot; concept&#x2F;term affects this.<p>We don&#x27;t have top-level terms that cover Java, C# and Kotlin, or TypeScript and JS, or C&#x2F;Objective-C&#x2F;C++.</div><br/><div id="39813102" class="c"><input type="checkbox" id="c-39813102" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39813068">parent</a><span>|</span><a href="#39813984">next</a><span>|</span><label class="collapse" for="c-39813102">[-]</label><label class="expand" for="c-39813102">[1 more]</label></div><br/><div class="children"><div class="content">Lisp programmers often call these algol-like languages or c-like languages.</div><br/></div></div><div id="39813984" class="c"><input type="checkbox" id="c-39813984" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39813068">parent</a><span>|</span><a href="#39813102">prev</a><span>|</span><a href="#39812759">next</a><span>|</span><label class="collapse" for="c-39813984">[-]</label><label class="expand" for="c-39813984">[1 more]</label></div><br/><div class="children"><div class="content">1) C-syntax languages<p>2) JavaScript family languages<p>3) C family languages</div><br/></div></div></div></div><div id="39812759" class="c"><input type="checkbox" id="c-39812759" checked=""/><div class="controls bullet"><span class="by">beanjuiceII</span><span>|</span><a href="#39811809">parent</a><span>|</span><a href="#39813068">prev</a><span>|</span><a href="#39813027">next</a><span>|</span><label class="collapse" for="c-39812759">[-]</label><label class="expand" for="c-39812759">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually how lisp plans to take over.. Enough implementations and before you know it you have enough lispers to eclipse all other programmers</div><br/><div id="39812961" class="c"><input type="checkbox" id="c-39812961" checked=""/><div class="controls bullet"><span class="by">lioeters</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812759">parent</a><span>|</span><a href="#39813027">next</a><span>|</span><label class="collapse" for="c-39812961">[-]</label><label class="expand" for="c-39812961">[1 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;ll call my next Lisp implementation Eclispe.</div><br/></div></div></div></div><div id="39813027" class="c"><input type="checkbox" id="c-39813027" checked=""/><div class="controls bullet"><span class="by">audiodude</span><span>|</span><a href="#39811809">parent</a><span>|</span><a href="#39812759">prev</a><span>|</span><a href="#39812887">next</a><span>|</span><label class="collapse" for="c-39813027">[-]</label><label class="expand" for="c-39813027">[1 more]</label></div><br/><div class="children"><div class="content">I think the wording of the article title helps push people to this conclusion. My first thought was &quot;we&#x27;re 24 years into the 21st century, I&#x27;m sure we already have one of those&quot;.</div><br/></div></div><div id="39812887" class="c"><input type="checkbox" id="c-39812887" checked=""/><div class="controls bullet"><span class="by">54hpk124j32p34</span><span>|</span><a href="#39811809">parent</a><span>|</span><a href="#39813027">prev</a><span>|</span><a href="#39812344">next</a><span>|</span><label class="collapse" for="c-39812887">[-]</label><label class="expand" for="c-39812887">[1 more]</label></div><br/><div class="children"><div class="content">Hasn&#x27;t worked for Common Lisp.</div><br/></div></div><div id="39812344" class="c"><input type="checkbox" id="c-39812344" checked=""/><div class="controls bullet"><span class="by">entropie</span><span>|</span><a href="#39811809">parent</a><span>|</span><a href="#39812887">prev</a><span>|</span><a href="#39812146">next</a><span>|</span><label class="collapse" for="c-39812344">[-]</label><label class="expand" for="c-39812344">[2 more]</label></div><br/><div class="children"><div class="content">We love variance.</div><br/><div id="39812628" class="c"><input type="checkbox" id="c-39812628" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812344">parent</a><span>|</span><a href="#39812146">next</a><span>|</span><label class="collapse" for="c-39812628">[-]</label><label class="expand" for="c-39812628">[1 more]</label></div><br/><div class="children"><div class="content">I think you meant to say variety.</div><br/></div></div></div></div><div id="39812146" class="c"><input type="checkbox" id="c-39812146" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#39811809">parent</a><span>|</span><a href="#39812344">prev</a><span>|</span><a href="#39812812">next</a><span>|</span><label class="collapse" for="c-39812146">[-]</label><label class="expand" for="c-39812146">[15 more]</label></div><br/><div class="children"><div class="content">Hard disagree on all counts.</div><br/><div id="39812310" class="c"><input type="checkbox" id="c-39812310" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812146">parent</a><span>|</span><a href="#39812266">next</a><span>|</span><label class="collapse" for="c-39812310">[-]</label><label class="expand" for="c-39812310">[1 more]</label></div><br/><div class="children"><div class="content">Well, choice has its charms, but a non fragmented experience, with the wider combined adoption, and all the now scattered resources devoted to it, has more actual benefits.</div><br/></div></div><div id="39812266" class="c"><input type="checkbox" id="c-39812266" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812146">parent</a><span>|</span><a href="#39812310">prev</a><span>|</span><a href="#39812552">next</a><span>|</span><label class="collapse" for="c-39812266">[-]</label><label class="expand" for="c-39812266">[12 more]</label></div><br/><div class="children"><div class="content">Seriously, how many Lisps for the 21st century do we really need? Especially considering that we are almost a quarter into that century already.</div><br/><div id="39812780" class="c"><input type="checkbox" id="c-39812780" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812266">parent</a><span>|</span><a href="#39812333">next</a><span>|</span><label class="collapse" for="c-39812780">[-]</label><label class="expand" for="c-39812780">[4 more]</label></div><br/><div class="children"><div class="content">If 10 people deciding to make a language invent different new syntaxes, they don&#x27;t show up on the same radar at once.<p>If they each make it a Lisp: oh no, how many Lisps do we need?</div><br/><div id="39813158" class="c"><input type="checkbox" id="c-39813158" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812780">parent</a><span>|</span><a href="#39812333">next</a><span>|</span><label class="collapse" for="c-39813158">[-]</label><label class="expand" for="c-39813158">[3 more]</label></div><br/><div class="children"><div class="content">All these toy lisps aren&#x27;t really advancing the state of the art. It&#x27;s dog bites man at this point, there really isn&#x27;t much new to talk about.<p>There&#x27;s nothing wrong with that, but , oh, look, a new scheme, yea. None of the previous 70 changed my life in any meaningful way.<p>Functional programming is easily available in almost any modern lang, virtually all of which have better tooling (and no, I have <i>zero</i> interest in using emacs) and ecosystems.</div><br/><div id="39813321" class="c"><input type="checkbox" id="c-39813321" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39813158">parent</a><span>|</span><a href="#39813379">next</a><span>|</span><label class="collapse" for="c-39813321">[-]</label><label class="expand" for="c-39813321">[1 more]</label></div><br/><div class="children"><div class="content">gerbil is hardly a toy lisp!</div><br/></div></div></div></div></div></div><div id="39812333" class="c"><input type="checkbox" id="c-39812333" checked=""/><div class="controls bullet"><span class="by">GeorgeTirebiter</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812266">parent</a><span>|</span><a href="#39812780">prev</a><span>|</span><a href="#39812552">next</a><span>|</span><label class="collapse" for="c-39812333">[-]</label><label class="expand" for="c-39812333">[7 more]</label></div><br/><div class="children"><div class="content">There&#x27;s newLISP <a href="http:&#x2F;&#x2F;www.newlisp.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.newlisp.org&#x2F;</a>  which takes a fresh look at lisp and has plenty of libraries.<p>Lately, I&#x27;m going back to what I used years ago: Common Lisp.  There are great books describing it, and implementations like SBCL <a href="https:&#x2F;&#x2F;www.sbcl.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.sbcl.org&#x2F;</a> are solid.<p>p.s. Plenty of time to come with the lisp for the 22nd century!</div><br/><div id="39812661" class="c"><input type="checkbox" id="c-39812661" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812333">parent</a><span>|</span><a href="#39813957">next</a><span>|</span><label class="collapse" for="c-39812661">[-]</label><label class="expand" for="c-39812661">[4 more]</label></div><br/><div class="children"><div class="content">I know it&#x27;s a bit of an oddball in these discussions, but I find that I still have the most fun with Clojure.  It&#x27;s fast enough, relatively easy to get anything I want done, with proper functional data structures built in, with the entire JVM ecosystem to play with if I need it.<p>I got pretty into Chicken Scheme a few years ago, and I did a quick breakout clone in Racket as well, and I think they&#x27;re pretty cool, but Clojure is the only one that has ever evolved past &quot;toy&quot; for me.</div><br/><div id="39812818" class="c"><input type="checkbox" id="c-39812818" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812661">parent</a><span>|</span><a href="#39813957">next</a><span>|</span><label class="collapse" for="c-39812818">[-]</label><label class="expand" for="c-39812818">[3 more]</label></div><br/><div class="children"><div class="content">&gt; the entire JVM ecosystem to play with if I need it.<p>Do you ever need it?</div><br/><div id="39812889" class="c"><input type="checkbox" id="c-39812889" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812818">parent</a><span>|</span><a href="#39813957">next</a><span>|</span><label class="collapse" for="c-39812889">[-]</label><label class="expand" for="c-39812889">[2 more]</label></div><br/><div class="children"><div class="content">Keep in mind, I&#x27;m almost always in the engineering world more than the pure CS world, and yeah, it&#x27;s often pretty useful.<p>The Apache tools are the biggest things for me; I do a lot of work with Apache Kafka, so being able to directly use the first-party libraries like Kafka Streams is useful.  If I need to do any kind of distributed processing stuff, I have Apache Spark or Apache Flink when I need it. It&#x27;s kind of falling out of favor now, but I still occasionally have a need for Apache Zookeeper as well.<p>Now, I&#x27;m sure that there&#x27;s Clojure-first versions of these things, but the sad truth of the software landscape for me is that a lot of it is still powered by Java.  I can either be tasked with reinventing a lot of the infrastructure myself by using a language that doesn&#x27;t have good Java interop, or I can use a JVM language.  I think that Clojure is the least-bad of the latter category.<p>In some ways, Clojure is an even better Java than Java; it&#x27;s easy to compose together arbitrary java methods, without any kind of fancy fluent interface or anything, for example, and there&#x27;s lots of helper macros that I think really do smooth over the Java-ness of certain interfaces.</div><br/><div id="39813975" class="c"><input type="checkbox" id="c-39813975" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812889">parent</a><span>|</span><a href="#39813957">next</a><span>|</span><label class="collapse" for="c-39813975">[-]</label><label class="expand" for="c-39813975">[1 more]</label></div><br/><div class="children"><div class="content">This is how I feel about Kawa Scheme. It has very good Java interop without all the... Clojurisms which are like pebbles in my shoe while I&#x27;m working. It&#x27;s what I&#x27;d reach for if I wanted to author, say, a large web service from scratch.</div><br/></div></div></div></div></div></div></div></div><div id="39813957" class="c"><input type="checkbox" id="c-39813957" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812333">parent</a><span>|</span><a href="#39812661">prev</a><span>|</span><a href="#39812370">next</a><span>|</span><label class="collapse" for="c-39813957">[-]</label><label class="expand" for="c-39813957">[1 more]</label></div><br/><div class="children"><div class="content">Newlisp actually revives ancient mistakes in Lisp history. For example, there is no lexical scoping -- and &quot;contexts&quot; are not a substitute for lexical scoping. Lexical scoping ensures that bindings introduced within a scope cannot leak outside the text of that scope, avoiding subtle bugs that may manifest with dynamic scoping. Hence, Newlisp&#x27;s lambda isn&#x27;t really lambda, like Lisp 1.5&#x27;s but very unlike Common Lisp or Scheme (absent side effects).<p>Newlisp&#x27;s default (and most used) FFI is also... dangerous. You simply import a symbol from a shared lib and it gets bound to a procedure corresponding to a C call to that shared lib. No specifying of parameter types -- and most platforms do not encode parameter type information in shared libraries in a standard universal way. (Things like C++ name mangling, and COM, only apply to libraries written within their respective ecosystems.) But don&#x27;t worry. Newlisp trusts you to get the parameter types right, because Newlisp is for the <i>practical</i> Lisp programmer. Woe betide you if you don&#x27;t, though!<p>Guile&#x27;s (system foreign) module provides a similarly dangerous FFI, but at least you can (and must) specify parameter and return types when you import a foreign procedure from a shared lib that way, allowing for checks for parameter correctness at the call site, if not the import site.</div><br/></div></div><div id="39812370" class="c"><input type="checkbox" id="c-39812370" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812333">parent</a><span>|</span><a href="#39813957">prev</a><span>|</span><a href="#39812552">next</a><span>|</span><label class="collapse" for="c-39812370">[-]</label><label class="expand" for="c-39812370">[1 more]</label></div><br/><div class="children"><div class="content">Yep, I regularly try new ones but sbcl and emacs&#x2F;slime are hard to beat.</div><br/></div></div></div></div></div></div><div id="39812552" class="c"><input type="checkbox" id="c-39812552" checked=""/><div class="controls bullet"><span class="by">smegsicle</span><span>|</span><a href="#39811809">root</a><span>|</span><a href="#39812146">parent</a><span>|</span><a href="#39812266">prev</a><span>|</span><a href="#39812812">next</a><span>|</span><label class="collapse" for="c-39812552">[-]</label><label class="expand" for="c-39812552">[1 more]</label></div><br/><div class="children"><div class="content">including the implication that scheme is a lisp</div><br/></div></div></div></div></div></div><div id="39812812" class="c"><input type="checkbox" id="c-39812812" checked=""/><div class="controls bullet"><span class="by">bckr</span><span>|</span><a href="#39811809">prev</a><span>|</span><a href="#39811607">next</a><span>|</span><label class="collapse" for="c-39812812">[-]</label><label class="expand" for="c-39812812">[1 more]</label></div><br/><div class="children"><div class="content">I would love to see a list of all programming languages in a table with a list of all programming language features</div><br/></div></div><div id="39811607" class="c"><input type="checkbox" id="c-39811607" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#39812812">prev</a><span>|</span><label class="collapse" for="c-39811607">[-]</label><label class="expand" for="c-39811607">[1 more]</label></div><br/><div class="children"><div class="content">Has anyone here actually used this for anything real? What&#x27;s the library ecosystem like?</div><br/></div></div></div></div></div></div></div></body></html>