<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700557264901" as="style"/><link rel="stylesheet" href="styles.css?v=1700557264901"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://retrocomputing.stackexchange.com/questions/3019/why-did-base64-win-against-uuencode">Why did base64 win against uuencode?</a> <span class="domain">(<a href="https://retrocomputing.stackexchange.com">retrocomputing.stackexchange.com</a>)</span></div><div class="subtext"><span>egorpv</span> | <span>67 comments</span></div><br/><div><div id="38358684" class="c"><input type="checkbox" id="c-38358684" checked=""/><div class="controls bullet"><span class="by">ekidd</span><span>|</span><a href="#38358093">next</a><span>|</span><label class="collapse" for="c-38358684">[-]</label><label class="expand" for="c-38358684">[12 more]</label></div><br/><div class="children"><div class="content">One reason that uuencode lost out to Base64 was that uuencode used spaces in its encoding. It was fairly common for Internet protocols in those days to mess with whitespace, so it was often necessary to patch up corrupted uuencode files by hand.<p>Base64, on the other hand, was carefully designed to survive everything from whitespace corruption to being passed through non-ASCII character sets. And then it became widely used as part of MIME.</div><br/><div id="38359112" class="c"><input type="checkbox" id="c-38359112" checked=""/><div class="controls bullet"><span class="by">jjeaff</span><span>|</span><a href="#38358684">parent</a><span>|</span><a href="#38359475">next</a><span>|</span><label class="collapse" for="c-38359112">[-]</label><label class="expand" for="c-38359112">[10 more]</label></div><br/><div class="children"><div class="content">and yet, Internet protocols (http, at least) don&#x27;t play well with equal signs which are part of base64, sometimes. That little issue has caused lots of intermittent bugs for me over the years, either from forgetting to urlencode it or not urldecoding it at the right time.</div><br/><div id="38360759" class="c"><input type="checkbox" id="c-38360759" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#38358684">root</a><span>|</span><a href="#38359112">parent</a><span>|</span><a href="#38359286">next</a><span>|</span><label class="collapse" for="c-38360759">[-]</label><label class="expand" for="c-38360759">[1 more]</label></div><br/><div class="children"><div class="content">And slashes as well, which is a magic character in both urls and file systems. Means you can&#x27;t reliably use normal base64 for filenames, for instance. That might seem like a niche use-case, but it&#x27;s really not, because you can use it for content-based addressing. Git does this, names all the blobs in the .git folder after their hash, but you can&#x27;t encode the hash with regular base64.</div><br/></div></div><div id="38359286" class="c"><input type="checkbox" id="c-38359286" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#38358684">root</a><span>|</span><a href="#38359112">parent</a><span>|</span><a href="#38360759">prev</a><span>|</span><a href="#38360236">next</a><span>|</span><label class="collapse" for="c-38359286">[-]</label><label class="expand" for="c-38359286">[2 more]</label></div><br/><div class="children"><div class="content">Ditto the obnoxious &quot;quoted-printable&quot; mail encoding, which turns every = into =3D.<p>Still more robust than uuencode though.</div><br/><div id="38359732" class="c"><input type="checkbox" id="c-38359732" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#38358684">root</a><span>|</span><a href="#38359286">parent</a><span>|</span><a href="#38360236">next</a><span>|</span><label class="collapse" for="c-38359732">[-]</label><label class="expand" for="c-38359732">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s basically the same as URL encoding, they just picked = instead of %</div><br/></div></div></div></div><div id="38360236" class="c"><input type="checkbox" id="c-38360236" checked=""/><div class="controls bullet"><span class="by">eastbound</span><span>|</span><a href="#38358684">root</a><span>|</span><a href="#38359112">parent</a><span>|</span><a href="#38359286">prev</a><span>|</span><a href="#38359193">next</a><span>|</span><label class="collapse" for="c-38360236">[-]</label><label class="expand" for="c-38360236">[2 more]</label></div><br/><div class="children"><div class="content">So there are 7 base64 encodings, one with “+ &#x2F; =“, one with “- _ =“, one with “+,” and no “=“… <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Base64#Variants_summary_table" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Base64#Variants_summary_table</a></div><br/><div id="38360805" class="c"><input type="checkbox" id="c-38360805" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#38358684">root</a><span>|</span><a href="#38360236">parent</a><span>|</span><a href="#38359193">next</a><span>|</span><label class="collapse" for="c-38360805">[-]</label><label class="expand" for="c-38360805">[1 more]</label></div><br/><div class="children"><div class="content">TIL.<p>And Python uses RFC 4648</div><br/></div></div></div></div><div id="38359193" class="c"><input type="checkbox" id="c-38359193" checked=""/><div class="controls bullet"><span class="by">Vt71fcAqt7</span><span>|</span><a href="#38358684">root</a><span>|</span><a href="#38359112">parent</a><span>|</span><a href="#38360236">prev</a><span>|</span><a href="#38359475">next</a><span>|</span><label class="collapse" for="c-38359193">[-]</label><label class="expand" for="c-38359193">[4 more]</label></div><br/><div class="children"><div class="content">And now we <i>can</i> have whitespace in url queries but we are still using %20 everywhere because &quot;that&#x27;s standard&quot;...</div><br/><div id="38359255" class="c"><input type="checkbox" id="c-38359255" checked=""/><div class="controls bullet"><span class="by">CydeWeys</span><span>|</span><a href="#38358684">root</a><span>|</span><a href="#38359193">parent</a><span>|</span><a href="#38359264">next</a><span>|</span><label class="collapse" for="c-38359255">[-]</label><label class="expand" for="c-38359255">[1 more]</label></div><br/><div class="children"><div class="content">Try copy-pasting a link that has actual whitespace in its URL queries and see if it gets linkified correctly. Just because you can doesn&#x27;t mean you should! A space is like the <i>one</i> delimiter that is applicable for separating out URLs from the context of a larger blob of text.</div><br/></div></div><div id="38359264" class="c"><input type="checkbox" id="c-38359264" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#38358684">root</a><span>|</span><a href="#38359193">parent</a><span>|</span><a href="#38359255">prev</a><span>|</span><a href="#38359475">next</a><span>|</span><label class="collapse" for="c-38359264">[-]</label><label class="expand" for="c-38359264">[2 more]</label></div><br/><div class="children"><div class="content">Browsers will often display %20 as a space, but that&#x27;s not the same thing as spaces being legal within URLs.</div><br/><div id="38359344" class="c"><input type="checkbox" id="c-38359344" checked=""/><div class="controls bullet"><span class="by">Vt71fcAqt7</span><span>|</span><a href="#38358684">root</a><span>|</span><a href="#38359264">parent</a><span>|</span><a href="#38359475">next</a><span>|</span><label class="collapse" for="c-38359344">[-]</label><label class="expand" for="c-38359344">[1 more]</label></div><br/><div class="children"><div class="content">You are right. Seems firefox displays %20 as whitespace and converts whitespace to %20 when you use it. Chrome displays it as %20 but still converts whitespace to %20 if you try to use it.</div><br/></div></div></div></div></div></div></div></div><div id="38359475" class="c"><input type="checkbox" id="c-38359475" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#38358684">parent</a><span>|</span><a href="#38359112">prev</a><span>|</span><a href="#38358093">next</a><span>|</span><label class="collapse" for="c-38359475">[-]</label><label class="expand" for="c-38359475">[1 more]</label></div><br/><div class="children"><div class="content">...only for base64 to become fragmented into standard or URL due to character choice, and padded or not padded as a &quot;cool trick to save some bytes&quot;.</div><br/></div></div></div></div><div id="38358093" class="c"><input type="checkbox" id="c-38358093" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#38358684">prev</a><span>|</span><a href="#38359539">next</a><span>|</span><label class="collapse" for="c-38358093">[-]</label><label class="expand" for="c-38358093">[8 more]</label></div><br/><div class="children"><div class="content">Having lived through the transition, I can say personally it comes down to &quot;packaging&quot; -if MIME had adopted UUENCODE format, I probably would have used it but as materials emerged to me which depended on base64 decode, it became compelling to use it. Once it was ubiquitously available in e.g ssl, it became trivial to decode a base64 encoded thing, no matter what. Not all systems had a functioning uudecode all the time. DOS for instance, you had to find one. If you&#x27;re given base64 content, you install a base64 encode&#x2F;decode package and then its what you have.<p>There was also an extended period of time where people did uux much as they did shar: both of which are inviting somebody else&#x27;s hands into your execution state and filestore.<p>We were also obsessed with efficiency. base64 was &quot;sold&quot; as denser encoding. I can&#x27;t say if it was true overall, but just as we discussed lempel-zif and gzip tuning on usenet news, we discussed uuencode&#x2F;base64 and other text wrapping.<p>Ned Freed, Nathaniel Borenstein, Patrik Falstrom and Robert Elz amongst others come to mind as people who worked on the baseXX encoding and discussed this on the lists at the time. Other alphabets were discussed.<p>uu* was the product of Mike Lesk a decade before, who was a lot quieter on the lists: He&#x27;d moved into different circles, was doing other things and not really that interested in the chatter around line encoding issues.</div><br/><div id="38358272" class="c"><input type="checkbox" id="c-38358272" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#38358093">parent</a><span>|</span><a href="#38360187">next</a><span>|</span><label class="collapse" for="c-38358272">[-]</label><label class="expand" for="c-38358272">[4 more]</label></div><br/><div class="children"><div class="content">After a given point usenet was nearly 8-bit clean, and thus <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;YEnc" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;YEnc</a> was also developed to convolve all the octets (I + 42 (decimal)) and escape the results that happened to still match reserved characters (CR, LF, 0x0, = (yEnc escape)) - it seems that if the result character was among that set, then = was output and new output determined by O = (I+64) % 256 instead.</div><br/><div id="38358996" class="c"><input type="checkbox" id="c-38358996" checked=""/><div class="controls bullet"><span class="by">wkat4242</span><span>|</span><a href="#38358093">root</a><span>|</span><a href="#38358272">parent</a><span>|</span><a href="#38359589">next</a><span>|</span><label class="collapse" for="c-38358996">[-]</label><label class="expand" for="c-38358996">[1 more]</label></div><br/><div class="children"><div class="content">Yenc is still used a lot actually, for the purpose of what Usenet has de facto become, a piracy network :)</div><br/></div></div><div id="38359589" class="c"><input type="checkbox" id="c-38359589" checked=""/><div class="controls bullet"><span class="by">u801e</span><span>|</span><a href="#38358093">root</a><span>|</span><a href="#38358272">parent</a><span>|</span><a href="#38358996">prev</a><span>|</span><a href="#38360187">next</a><span>|</span><label class="collapse" for="c-38359589">[-]</label><label class="expand" for="c-38359589">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s too bad yenc didn&#x27;t take the place of base64 for email.</div><br/><div id="38359780" class="c"><input type="checkbox" id="c-38359780" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#38358093">root</a><span>|</span><a href="#38359589">parent</a><span>|</span><a href="#38360187">next</a><span>|</span><label class="collapse" for="c-38359780">[-]</label><label class="expand" for="c-38359780">[1 more]</label></div><br/><div class="children"><div class="content">yEnc was rejected by the MIME standardization group for two main reasons, one good and one bad. The good reason was that it has some encoding pathologies, although these could have been fixed in the standardization process. The bad reason was &quot;it&#x27;s too hard to add a new Content-Transfer-Encoding because you have to change all the user agents&quot;, which given that by that time <i>all the clients were changing to support yEnc</i> it was quite clear that uptake would likely of a new addition would have been fairly rapid.</div><br/></div></div></div></div></div></div><div id="38360187" class="c"><input type="checkbox" id="c-38360187" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#38358093">parent</a><span>|</span><a href="#38358272">prev</a><span>|</span><a href="#38358553">next</a><span>|</span><label class="collapse" for="c-38360187">[-]</label><label class="expand" for="c-38360187">[1 more]</label></div><br/><div class="children"><div class="content">Here are Usenet comments from the the 1994 comp.mail.mime thread &quot;Q: why base64 ,not UUencode?&quot;<p>1) <a href="https:&#x2F;&#x2F;www.usenetarchives.com&#x2F;view.php?id=comp.mail.mime&amp;mid=PDE5OTQwNDE1MjEyNy5SQUEyMjEwOUB3aWxtYS5jcy51dGsuZWR1Pg" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.usenetarchives.com&#x2F;view.php?id=comp.mail.mime&amp;mi...</a><p>&gt; Some of the characters used by uuencode cannot be represented in some of the mail systems used to carry rfc 822 (and therefore MIME) mail messages. Using uuencode in these environments causes corruption of encoded data. The working group that developed MIME felt that reliability of the encoding scheme was more important that compatibility with uuencode.<p>In a followup (same link):<p>&gt; &quot;The only character translation problem I have encountered is that the back-quote (`) does not make it through all mailers and becomes a space ( ).&quot;<p>A followup from that at <a href="https:&#x2F;&#x2F;www.usenetarchives.com&#x2F;view.php?id=comp.mail.mime&amp;mid=PDE5OTQwNDE3MTY0Mi5NQUEwMTc0NkB3aWxtYS5jcy51dGsuZWR1Pg" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.usenetarchives.com&#x2F;view.php?id=comp.mail.mime&amp;mi...</a> says:<p>&gt; The back-quote problem is only one of many. Several of the characters used by uuencode are not present in (for example) the EBCDIC character set. So a message transmitted over BITNET could get mangled -- especially for traffic between two different countries where they use different versions of EBCDIC, and therefore different translate tables between EBCDIC and ASCII. There are other character sets used by 822-based mail systems that impose similar restrictions, but EBCDIC is the most obvious one.<p>&gt; We didn&#x27;t use uuencode because several members of our working group had experience with cases where uuencoded files were garbaged in transit. It works fine for some people, but not for &quot;everybody&quot; (or even &quot;nearly everybody&quot;).<p>&gt; The &quot;no standards for uuencode&quot; wasn&#x27;t really a problem. If we had wanted to use uuencode, we would have documented the format in the MIME RFC.<p>That last comment was from Keith Moore, &quot;the author and co-author of several IETF RFCs related to the MIME and SMTP protocols for electronic mail, among others&quot; says <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Keith_Moore" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Keith_Moore</a> .</div><br/></div></div><div id="38358553" class="c"><input type="checkbox" id="c-38358553" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#38358093">parent</a><span>|</span><a href="#38360187">prev</a><span>|</span><a href="#38359539">next</a><span>|</span><label class="collapse" for="c-38358553">[-]</label><label class="expand" for="c-38358553">[2 more]</label></div><br/><div class="children"><div class="content">&gt; We were also obsessed with efficiency. base64 was &quot;sold&quot; as denser encoding. I can&#x27;t say if it was true overall<p>uuencode has file headers&#x2F;footers, like MIME.  But the actual content encoding is basically base64 with a different alphabet; both add precisely 1&#x2F;3 overhead (plus up to 2 padding bytes at the end).</div><br/><div id="38358593" class="c"><input type="checkbox" id="c-38358593" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#38358093">root</a><span>|</span><a href="#38358553">parent</a><span>|</span><a href="#38359539">next</a><span>|</span><label class="collapse" for="c-38358593">[-]</label><label class="expand" for="c-38358593">[1 more]</label></div><br/><div class="children"><div class="content">uuencode has some additional overhead, namely 2 additional bytes per line,  that means it varies from 60-70%, the latter being best case, while base64 is 75% efficient in all cases.</div><br/></div></div></div></div></div></div><div id="38359539" class="c"><input type="checkbox" id="c-38359539" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#38358093">prev</a><span>|</span><a href="#38357704">next</a><span>|</span><label class="collapse" for="c-38359539">[-]</label><label class="expand" for="c-38359539">[12 more]</label></div><br/><div class="children"><div class="content">A thing I wonder: why is using = padding required in the most common base64 variant?<p>It&#x27;s redundant since this info can be fully inferred from the length of the stream.<p>Even for concatenations it is not necessary to require it, since you must still know the length of each sub stream (and = does not always appear so is not a separator).<p>There&#x27;s no way that using the = instead of per-byte length-checking gains any speed, since to prevent reading out of bounds you must check the per byte length anyway, you can&#x27;t trust input to be a multiple of 4 length.<p>It could only make sense if it&#x27;s somehow required to read 4 bytes at once, and you can&#x27;t possibly read less, but what platform is such?</div><br/><div id="38360790" class="c"><input type="checkbox" id="c-38360790" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#38359539">parent</a><span>|</span><a href="#38360299">next</a><span>|</span><label class="collapse" for="c-38360790">[-]</label><label class="expand" for="c-38360790">[1 more]</label></div><br/><div class="children"><div class="content">Without padding, how would you encode, for example, a message with just a single zero? To be more precise, how do you distinguish it from two zeroes and three zeroes?</div><br/></div></div><div id="38359556" class="c"><input type="checkbox" id="c-38359556" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#38359539">parent</a><span>|</span><a href="#38360299">prev</a><span>|</span><a href="#38359733">next</a><span>|</span><label class="collapse" for="c-38359556">[-]</label><label class="expand" for="c-38359556">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Even for concatenations it is not necessary to require it, since you must still know the length of each sub stream<p>I&#x27;m not sure I understand this part. You can decode aGVsbG8=IHdvcmxk, what do you need to know?</div><br/><div id="38359604" class="c"><input type="checkbox" id="c-38359604" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#38359539">root</a><span>|</span><a href="#38359556">parent</a><span>|</span><a href="#38359733">next</a><span>|</span><label class="collapse" for="c-38359604">[-]</label><label class="expand" for="c-38359604">[5 more]</label></div><br/><div class="children"><div class="content">The = does not appear if the base64 data is a multiple of 4 length. So you wouldn&#x27;t know if aGVsbG8I is one or two streams. The = is not a separator, only padding to make the base64 stream a multiple of 4 length for some reason.<p>I only mentioned the concatenation because Wikipedia claims this use case requires padding while in reality it doesn&#x27;t.</div><br/><div id="38359661" class="c"><input type="checkbox" id="c-38359661" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38359539">root</a><span>|</span><a href="#38359604">parent</a><span>|</span><a href="#38359691">next</a><span>|</span><label class="collapse" for="c-38359661">[-]</label><label class="expand" for="c-38359661">[3 more]</label></div><br/><div class="children"><div class="content">Base64 doesn&#x27;t have a concept of &quot;stream&quot;. Conceptually base64-encoded string with padding is a concatenation of fragments that are always 4 bytes long but can encode one to three bytes. Concatenating two base64-encoded strings with padding therefore don&#x27;t destroy fragment structures and can be decoded into a byte sequence that is a concatenation of two original input sequences. Without padding, fragments can be also 2 or 3 bytes and short fragments are not distinguishable from long fragments, so the concatenation will destroy fragment structures.</div><br/><div id="38359711" class="c"><input type="checkbox" id="c-38359711" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#38359539">root</a><span>|</span><a href="#38359661">parent</a><span>|</span><a href="#38359691">next</a><span>|</span><label class="collapse" for="c-38359711">[-]</label><label class="expand" for="c-38359711">[2 more]</label></div><br/><div class="children"><div class="content">Oh I see, so it&#x27;s for concatenating multiple base64 fragments of the same single piece of data? But where is this used? Never seen that. Javascript&#x27;s base64 decoder gives an error for =&#x27;s in the middle (but I just found out the Linux base64 -d command supports it!)</div><br/><div id="38359835" class="c"><input type="checkbox" id="c-38359835" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38359539">root</a><span>|</span><a href="#38359711">parent</a><span>|</span><a href="#38359691">next</a><span>|</span><label class="collapse" for="c-38359835">[-]</label><label class="expand" for="c-38359835">[1 more]</label></div><br/><div class="children"><div class="content">I actually don&#x27;t know if it&#x27;s an intention, but it is the only explanation that makes sense. It should be noted that the original PEM specification (RFC 989) did have a similar use case where alternating encrypted and unencrypted bytes can be intermixed by `*` characters, but you are still required to pad each portion to 4n bytes (e.g. `c2VjcmV0LCA=*cHVibGlj*IGFuZCBzZWNyZXQgYWdhaW4=`). It is still the closest to what I think padding characters are required for.</div><br/></div></div></div></div></div></div><div id="38359691" class="c"><input type="checkbox" id="c-38359691" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#38359539">root</a><span>|</span><a href="#38359604">parent</a><span>|</span><a href="#38359661">prev</a><span>|</span><a href="#38359733">next</a><span>|</span><label class="collapse" for="c-38359691">[-]</label><label class="expand" for="c-38359691">[1 more]</label></div><br/><div class="children"><div class="content">It would decode correctly but you wouldn&#x27;t know the boundary, if that matters. I see, thanks.</div><br/></div></div></div></div></div></div><div id="38359733" class="c"><input type="checkbox" id="c-38359733" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#38359539">parent</a><span>|</span><a href="#38359556">prev</a><span>|</span><a href="#38360591">next</a><span>|</span><label class="collapse" for="c-38359733">[-]</label><label class="expand" for="c-38359733">[2 more]</label></div><br/><div class="children"><div class="content">IMO padding is not necessary and just a relic of old implementations.</div><br/><div id="38359752" class="c"><input type="checkbox" id="c-38359752" checked=""/><div class="controls bullet"><span class="by">Aardwolf</span><span>|</span><a href="#38359539">root</a><span>|</span><a href="#38359733">parent</a><span>|</span><a href="#38360591">next</a><span>|</span><label class="collapse" for="c-38359752">[-]</label><label class="expand" for="c-38359752">[1 more]</label></div><br/><div class="children"><div class="content">I think so too. It feels similar to how many specifications from the 90s use big endian 4-byte integers for many things (like png, riff, jpeg, ...) despite little endian CPU&#x27;s being most common since the 80s already, and those specifications seemingly assuming that you would want to decode those 4-byte values with fread without any bounds checking or endianness dependency.</div><br/></div></div></div></div><div id="38360591" class="c"><input type="checkbox" id="c-38360591" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38359539">parent</a><span>|</span><a href="#38359733">prev</a><span>|</span><a href="#38357704">next</a><span>|</span><label class="collapse" for="c-38360591">[-]</label><label class="expand" for="c-38360591">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps to simplify implementations that read multiple characters at a time?<p>But I think it&#x27;s likely just poor design taste.</div><br/></div></div></div></div><div id="38357704" class="c"><input type="checkbox" id="c-38357704" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#38359539">prev</a><span>|</span><a href="#38357075">next</a><span>|</span><label class="collapse" for="c-38357704">[-]</label><label class="expand" for="c-38357704">[18 more]</label></div><br/><div class="children"><div class="content">On a related note, I&#x27;m getting flashbacks to being on the web in the late-1990s, back when &quot;Downloads!&quot; was a reason to visit a particular website; and noticing that Windows users like myself could just download-and-run an .exe file, while 
the same downloads for Mactintosh users would be a BinHex file that&#x27;d also be much larger than the Windows equivalent - and this wasn&#x27;t over FTP or Telnet, but an in-browser HTTP download, just like today.<p>Can anyone explain why BinHex remained &quot;popular&quot; in online Mac communities through to the early 2000s? Why couldn&#x27;t Macs download &quot;real&quot; binary files back then?</div><br/><div id="38357815" class="c"><input type="checkbox" id="c-38357815" checked=""/><div class="controls bullet"><span class="by">ksherlock</span><span>|</span><a href="#38357704">parent</a><span>|</span><a href="#38358488">next</a><span>|</span><label class="collapse" for="c-38357815">[-]</label><label class="expand" for="c-38357815">[3 more]</label></div><br/><div class="children"><div class="content">Classic Macintosh files were basically 2 separate files with the same name (data fork and resource fork).  Additionally, there was important meta data (Finder Info, most importantly the file type, creator type).  Since other file systems couldn&#x27;t handle forks or finder info, it had to be encapsulated in some other format like binhex, macbinary, applesingle, or stuffit.  The other 3 were binary so they would have been smaller. Why not them... <i>shrug</i></div><br/><div id="38358033" class="c"><input type="checkbox" id="c-38358033" checked=""/><div class="controls bullet"><span class="by">ksherlock</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38357815">parent</a><span>|</span><a href="#38358488">next</a><span>|</span><label class="collapse" for="c-38358033">[-]</label><label class="expand" for="c-38358033">[2 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t a macintosh user back in the day but for the file archives I frequented (apple II), sometimes files were in BINSCII which was a similar text encoding. The advantage being that they could be emailed inline, posted to usenet, didn&#x27;t require an 8-bit connection (important back in the 80s), and could be transferred by screen scraping if there wasn&#x27;t a better alternative.</div><br/><div id="38358325" class="c"><input type="checkbox" id="c-38358325" checked=""/><div class="controls bullet"><span class="by">devilbunny</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38358033">parent</a><span>|</span><a href="#38358488">next</a><span>|</span><label class="collapse" for="c-38358325">[-]</label><label class="expand" for="c-38358325">[1 more]</label></div><br/><div class="children"><div class="content">So this is really random, but Kermit actually could route around your 7-bit issues. Everyone remembers it as a godawful protocol choice, because terminal programs usually implemented the most basic version of the protocol, but if configured correctly it was on par with or better than Zmodem.</div><br/></div></div></div></div></div></div><div id="38358488" class="c"><input type="checkbox" id="c-38358488" checked=""/><div class="controls bullet"><span class="by">LeoPanthera</span><span>|</span><a href="#38357704">parent</a><span>|</span><a href="#38357815">prev</a><span>|</span><a href="#38358138">next</a><span>|</span><label class="collapse" for="c-38358488">[-]</label><label class="expand" for="c-38358488">[3 more]</label></div><br/><div class="children"><div class="content">The most common Macintosh archive format was (eventually) StuffIt, but StuffIt Expander couldn&#x27;t open a .sit file which was missing its resource fork, and when you downloaded a file from the internet, it only came with a data fork.<p>So a common hack was to binhex the .sit file. Binhex was originally designed to make files 7-bit clean, but had the side effect that it bundled the resource fork and the data fork together.<p>Later versions of StuffIt could open .sit files which lacked the resource fork just fine, but by then .zip was starting to become more common.</div><br/><div id="38360181" class="c"><input type="checkbox" id="c-38360181" checked=""/><div class="controls bullet"><span class="by">amatecha</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38358488">parent</a><span>|</span><a href="#38358138">next</a><span>|</span><label class="collapse" for="c-38360181">[-]</label><label class="expand" for="c-38360181">[2 more]</label></div><br/><div class="children"><div class="content">I could be remembering wrong, but didn&#x27;t later versions of stuffit compress to a .sit file that had no resource fork, so it would stay fully-intact on any filesystem?  I may be imagining that, but I remember hitting a certain version where &quot;copying to Windows&quot; would no longer ruin my .sit files... haha</div><br/><div id="38360401" class="c"><input type="checkbox" id="c-38360401" checked=""/><div class="controls bullet"><span class="by">LeoPanthera</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38360181">parent</a><span>|</span><a href="#38358138">next</a><span>|</span><label class="collapse" for="c-38360401">[-]</label><label class="expand" for="c-38360401">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a long time, but I don&#x27;t think that&#x27;s exactly true. The resource fork simply became optional, assisted by later versions of MacOS, which let applications open files which didn&#x27;t have one.</div><br/></div></div></div></div></div></div><div id="38358138" class="c"><input type="checkbox" id="c-38358138" checked=""/><div class="controls bullet"><span class="by">tornato7</span><span>|</span><a href="#38357704">parent</a><span>|</span><a href="#38358488">prev</a><span>|</span><a href="#38357800">next</a><span>|</span><label class="collapse" for="c-38358138">[-]</label><label class="expand" for="c-38358138">[9 more]</label></div><br/><div class="children"><div class="content">Funny because today I find the install process for Mac much simpler. Most installs are &quot;drag this .app file to your Applications folder&quot;, meanwhile on Windows you download an installer that downloads another installer that does who-knows-what to your system and leaves ambiguously-named files and registry modifications all over the place.</div><br/><div id="38359767" class="c"><input type="checkbox" id="c-38359767" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38358138">parent</a><span>|</span><a href="#38358947">next</a><span>|</span><label class="collapse" for="c-38359767">[-]</label><label class="expand" for="c-38359767">[1 more]</label></div><br/><div class="children"><div class="content">There are plenty of portable windows applications (distributed as a zipped directory) and there are plenty of pkg macOS installers.<p>I don&#x27;t really understand why macOS users like this &quot;simple&quot; installation, because when you &quot;uninstall&quot; the app, it leaves all the trash in your system without a chance to clean up. And implying that macOS application somehow will not do &quot;who-knows-what&quot; to your system is just wrong. Docker Desktop is &quot;simple&quot;, yet the first thing it does after launch is installing &quot;who-knows-what&quot;.</div><br/></div></div><div id="38358947" class="c"><input type="checkbox" id="c-38358947" checked=""/><div class="controls bullet"><span class="by">Clamchop</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38358138">parent</a><span>|</span><a href="#38359767">prev</a><span>|</span><a href="#38358312">next</a><span>|</span><label class="collapse" for="c-38358947">[-]</label><label class="expand" for="c-38358947">[1 more]</label></div><br/><div class="children"><div class="content">There are plenty of inscrutable installers for macOS software. DRM-riddled bullshit and enterprise crapware are a disease.<p>But yeah, the simple case is quite nice.</div><br/></div></div><div id="38358312" class="c"><input type="checkbox" id="c-38358312" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38358138">parent</a><span>|</span><a href="#38358947">prev</a><span>|</span><a href="#38357800">next</a><span>|</span><label class="collapse" for="c-38358312">[-]</label><label class="expand" for="c-38358312">[6 more]</label></div><br/><div class="children"><div class="content">The one annoying thing macOS apps do is pollute &#x2F;Library. Even apps that don’t explicitly write to this area end up with dozens of permafiles. Tons of stuff is spewed in there when you install an application that actually uses it.  It’s like a directory version of a registry kitchen sink.</div><br/><div id="38358842" class="c"><input type="checkbox" id="c-38358842" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38358312">parent</a><span>|</span><a href="#38357800">next</a><span>|</span><label class="collapse" for="c-38358842">[-]</label><label class="expand" for="c-38358842">[5 more]</label></div><br/><div class="children"><div class="content">Spare a thought for us Windows users - we went from our pristine and oddly beautiful home directories in Windows 7, where everything was neatly squared-away to either AppData\Roaming or AppData\Local - to our post-Electron, lazily-ported software world where my home directory now has no-less than <i>twenty</i> Unix-style dot-directories littering my %USERPROFILE%<p>Incidentally, the worst offender is Microsoft themselves: it all got worse with .nuget, .vs, .azcopy, .azdata, .azure, .azuredatastudio, .dotnet, etc. I just don&#x27;t understand it.</div><br/><div id="38359792" class="c"><input type="checkbox" id="c-38359792" checked=""/><div class="controls bullet"><span class="by">pezezin</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38358842">parent</a><span>|</span><a href="#38359187">next</a><span>|</span><label class="collapse" for="c-38359792">[-]</label><label class="expand" for="c-38359792">[2 more]</label></div><br/><div class="children"><div class="content">We Linux users suffer it. Supposedly, nowadays applications should store their files under ~&#x2F;.config, ~&#x2F;.local and ~&#x2F;.cache, but you still find a million applications that create their own folders without following any standards. But at least file browsers hide those folders by default...</div><br/><div id="38359949" class="c"><input type="checkbox" id="c-38359949" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38359792">parent</a><span>|</span><a href="#38359187">next</a><span>|</span><label class="collapse" for="c-38359949">[-]</label><label class="expand" for="c-38359949">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d have thought you could easily enable some fs-jail that maps any-and-every request matching &#x2F;~&#x2F;..+&#x2F;i wherever you want?</div><br/></div></div></div></div><div id="38359187" class="c"><input type="checkbox" id="c-38359187" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38358842">parent</a><span>|</span><a href="#38359792">prev</a><span>|</span><a href="#38357800">next</a><span>|</span><label class="collapse" for="c-38359187">[-]</label><label class="expand" for="c-38359187">[2 more]</label></div><br/><div class="children"><div class="content">Pristine? You mean the same home directory that contains the 80 character NTUSER files? ;)</div><br/><div id="38359470" class="c"><input type="checkbox" id="c-38359470" checked=""/><div class="controls bullet"><span class="by">DaiPlusPlus</span><span>|</span><a href="#38357704">root</a><span>|</span><a href="#38359187">parent</a><span>|</span><a href="#38357800">next</a><span>|</span><label class="collapse" for="c-38359470">[-]</label><label class="expand" for="c-38359470">[1 more]</label></div><br/><div class="children"><div class="content">Or the back-compat symlinks for NetHood, Start, Recent, SendTo, ah yes. I had a post-install VBScript that cleaned those out.<p>My current sad-thing I’m unhappy about is how the “My Documents” folder ended up being a second AppData folder, with lots of software storing settings, templates, project files, etc in that dir instead of AppData.<p>Windows absolutely needs application-silos to protect users from lazy apps. I hate to say it, but Apple was 100% right to make iPhone OS a file-system-free OS - we can’t do that on desktop, but gosh-darn-it, why is software so terrible? :(</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38357075" class="c"><input type="checkbox" id="c-38357075" checked=""/><div class="controls bullet"><span class="by">smudgy</span><span>|</span><a href="#38357704">prev</a><span>|</span><a href="#38359727">next</a><span>|</span><label class="collapse" for="c-38357075">[-]</label><label class="expand" for="c-38357075">[1 more]</label></div><br/><div class="children"><div class="content">You know, when I first got into binary encoding into text I asked myself this very question but never put any effort into looking it up.<p>Now, 25+ years later, I have some answers - thanks!</div><br/></div></div><div id="38359727" class="c"><input type="checkbox" id="c-38359727" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#38357075">prev</a><span>|</span><a href="#38343898">next</a><span>|</span><label class="collapse" for="c-38359727">[-]</label><label class="expand" for="c-38359727">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;wikipedia.org&#x2F;wiki&#x2F;Binary-to-text_encoding" rel="nofollow noreferrer">https:&#x2F;&#x2F;wikipedia.org&#x2F;wiki&#x2F;Binary-to-text_encoding</a></div><br/><div id="38360717" class="c"><input type="checkbox" id="c-38360717" checked=""/><div class="controls bullet"><span class="by">whoopdedo</span><span>|</span><a href="#38359727">parent</a><span>|</span><a href="#38343898">next</a><span>|</span><label class="collapse" for="c-38360717">[-]</label><label class="expand" for="c-38360717">[1 more]</label></div><br/><div class="children"><div class="content">Not listed was a clever encoding for MS-DOS files, XXBUG[1]. DOS had a rudimentary debugger and memory editor. (It even stuck around all the way to Windows XP but didn&#x27;t survive the transition to 64-bit.) Because it had the ability to write to disk you could convert any file to hexadecimal bytes and sprinkle some control commands about to create a script for DEBUG.EXE. The text-encoded file could then be sent anywhere without needing to download a decoder program first.<p>[1] <a href="http:&#x2F;&#x2F;justsolve.archiveteam.org&#x2F;wiki&#x2F;XXBUG" rel="nofollow noreferrer">http:&#x2F;&#x2F;justsolve.archiveteam.org&#x2F;wiki&#x2F;XXBUG</a></div><br/></div></div></div></div><div id="38343898" class="c"><input type="checkbox" id="c-38343898" checked=""/><div class="controls bullet"><span class="by">t-3</span><span>|</span><a href="#38359727">prev</a><span>|</span><a href="#38359038">next</a><span>|</span><label class="collapse" for="c-38343898">[-]</label><label class="expand" for="c-38343898">[12 more]</label></div><br/><div class="children"><div class="content">Base64 is very bizarre in general. Why did they use such a weird pattern of symbols instead of a contiguous section, or at least segments ordered from low-&gt;high (on that note, ASCII is also quite strange, I&#x27;m guessing due to some backwards compatibility idiocy that seemed like it made sense at some point (or maybe changing case was <i>super important</i> to a lot of workloads or something, making a compelling reason to fuck over the future in favor of optimisation now))?</div><br/><div id="38357825" class="c"><input type="checkbox" id="c-38357825" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#38343898">parent</a><span>|</span><a href="#38357835">next</a><span>|</span><label class="collapse" for="c-38357825">[-]</label><label class="expand" for="c-38357825">[1 more]</label></div><br/><div class="children"><div class="content">The original specification is in RFC 989 [0] from 1987, called “Printable Encoding”, where it explains “The bits resulting from the encryption operation are encoded into characters which are universally representable at all sites, though not necessarily
with the same bit patterns […] each group of 6 bits is used as an index into an array of 64 printable characters; the character referenced by the index is placed in the output string. These characters, identified in Table 1, are selected so as to be universally representable, and the set excludes characters with particular significance to SMTP (e.g., &quot;.&quot;, &quot;&lt;CR&gt;&quot;, &quot;&lt;LF&gt;&quot;).”<p>Using the array-indexing method, the noncontiguity of the characters doesn’t matter, and the processing is also independent of the character encoding (e.g. works exactly the same way in EBCDIC).<p>[0] <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc989.html#page-9" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc989.html#page-9</a></div><br/></div></div><div id="38357835" class="c"><input type="checkbox" id="c-38357835" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38343898">parent</a><span>|</span><a href="#38357825">prev</a><span>|</span><a href="#38360393">next</a><span>|</span><label class="collapse" for="c-38357835">[-]</label><label class="expand" for="c-38357835">[1 more]</label></div><br/><div class="children"><div class="content">Look at ASCII mapped out with four bits across and four bits down and the logic may suddenly snap into place.  Also remember that it was implemented by <i>mechanical</i> printing terminals.</div><br/></div></div><div id="38360393" class="c"><input type="checkbox" id="c-38360393" checked=""/><div class="controls bullet"><span class="by">jibal</span><span>|</span><a href="#38343898">parent</a><span>|</span><a href="#38357835">prev</a><span>|</span><a href="#38345034">next</a><span>|</span><label class="collapse" for="c-38360393">[-]</label><label class="expand" for="c-38360393">[2 more]</label></div><br/><div class="children"><div class="content">Base64 and ASCII both made perfect sense in terms of their requirements, and the future, while not fully anticipated at the time, is doing just fine, with ASCII being now incorporated into largely future-proof UTF-8.<p>Considerably stranger in regard to contiguity was EBCDIC, but it too made sense in terms of its technological requirements, which centered around Hollerith punch cards. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;EBCDIC" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;EBCDIC</a><p>There are numerous other examples where a lack of knowledge of the technological landscape of the past leads some people to project unwarranted assumptions of incompetence onto the engineers who lived under those constraints.<p>(Hmmm ... perhaps I should have read this person&#x27;s profile before commenting.)</div><br/></div></div><div id="38345034" class="c"><input type="checkbox" id="c-38345034" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#38343898">parent</a><span>|</span><a href="#38360393">prev</a><span>|</span><a href="#38359038">next</a><span>|</span><label class="collapse" for="c-38345034">[-]</label><label class="expand" for="c-38345034">[7 more]</label></div><br/><div class="children"><div class="content">The comments point out conversion issues with EBCDIC. You can&#x27;t use ASCII characters like @ which are not in EBCDIC.<p><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc2045#section-6.8" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc2045#section-6.8</a> says:<p><pre><code>   This subset has the important property that it is represented
   identically in all versions of ISO 646, including US-ASCII, and all
   characters in the subset are also represented identically in all
   versions of EBCDIC. Other popular encodings, such as the encoding
   used by the uuencode utility, Macintosh binhex 4.0 [RFC-1741], and
   the base85 encoding specified as part of Level 2 PostScript, do not
   share these properties, and thus do not fulfill the portability
   requirements a binary transport encoding for mail must meet.
</code></pre>
If you want to learn why ASCII is the way it is, try &quot;The Evolution of Character Codes, 1874-1968&quot; at <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;enf-ascii&#x2F;mode&#x2F;2up" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;enf-ascii&#x2F;mode&#x2F;2up</a> by Eric Fischer (an HN&#x27;er). My reading is contiguous A-Z was meant for better compatibility with 6-bit use.</div><br/><div id="38357605" class="c"><input type="checkbox" id="c-38357605" checked=""/><div class="controls bullet"><span class="by">mikecoles</span><span>|</span><a href="#38343898">root</a><span>|</span><a href="#38345034">parent</a><span>|</span><a href="#38359038">next</a><span>|</span><label class="collapse" for="c-38357605">[-]</label><label class="expand" for="c-38357605">[6 more]</label></div><br/><div class="children"><div class="content">I thought the ASCII upper-case &lt;-&gt; lower-case being a bit operation as being clever.</div><br/><div id="38358232" class="c"><input type="checkbox" id="c-38358232" checked=""/><div class="controls bullet"><span class="by">throw0101a</span><span>|</span><a href="#38343898">root</a><span>|</span><a href="#38357605">parent</a><span>|</span><a href="#38357934">next</a><span>|</span><label class="collapse" for="c-38358232">[-]</label><label class="expand" for="c-38358232">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I thought the ASCII upper-case &lt;-&gt; lower-case being a bit operation as being clever.</i><p>From &quot;Things Every Hacker Once Knew&quot; (2017), has an entire section on ASCII and the clever bit-fiddling that occurs:<p>* <a href="http:&#x2F;&#x2F;www.catb.org&#x2F;~esr&#x2F;faqs&#x2F;things-every-hacker-once-knew&#x2F;#_ascii" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.catb.org&#x2F;~esr&#x2F;faqs&#x2F;things-every-hacker-once-knew&#x2F;...</a><p>* Discussion from ~2 months ago: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37701117">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37701117</a></div><br/></div></div><div id="38357934" class="c"><input type="checkbox" id="c-38357934" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#38343898">root</a><span>|</span><a href="#38357605">parent</a><span>|</span><a href="#38358232">prev</a><span>|</span><a href="#38361072">next</a><span>|</span><label class="collapse" for="c-38357934">[-]</label><label class="expand" for="c-38357934">[3 more]</label></div><br/><div class="children"><div class="content">In the context of a terminal, the Control key is also a bitwise operation.<p>Shifted numerals were nearly a bitwise operation as well, but we didn&#x27;t end up using that keyboard layout.</div><br/><div id="38358053" class="c"><input type="checkbox" id="c-38358053" checked=""/><div class="controls bullet"><span class="by">mmcgaha</span><span>|</span><a href="#38343898">root</a><span>|</span><a href="#38357934">parent</a><span>|</span><a href="#38361072">next</a><span>|</span><label class="collapse" for="c-38358053">[-]</label><label class="expand" for="c-38358053">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;2&#x2F;28&#x2F;Silent-700.jpg" rel="nofollow noreferrer">https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;2&#x2F;28&#x2F;Silent-7...</a></div><br/><div id="38360062" class="c"><input type="checkbox" id="c-38360062" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#38343898">root</a><span>|</span><a href="#38358053">parent</a><span>|</span><a href="#38361072">next</a><span>|</span><label class="collapse" for="c-38360062">[-]</label><label class="expand" for="c-38360062">[1 more]</label></div><br/><div class="children"><div class="content">Yep! There&#x27;s even a term for it -- this is called a bit-paired keyboard.</div><br/></div></div></div></div></div></div><div id="38361072" class="c"><input type="checkbox" id="c-38361072" checked=""/><div class="controls bullet"><span class="by">eesmith</span><span>|</span><a href="#38343898">root</a><span>|</span><a href="#38357605">parent</a><span>|</span><a href="#38357934">prev</a><span>|</span><a href="#38359038">next</a><span>|</span><label class="collapse" for="c-38361072">[-]</label><label class="expand" for="c-38361072">[1 more]</label></div><br/><div class="children"><div class="content">Yes, though in principle you could interleave AaBbCc and so on, which would also be a single bit difference, and the naive collation would be more like that people expect.<p>The design considerations at <a href="https:&#x2F;&#x2F;ia800606.us.archive.org&#x2F;17&#x2F;items&#x2F;enf-ascii-1972-1975&#x2F;Image070917152640_text.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;ia800606.us.archive.org&#x2F;17&#x2F;items&#x2F;enf-ascii-1972-1975...</a> show that 6-bit support was more important than naive collation support:<p>&gt; A6.4 It is expected that devices having the capability of printing only 64 graphic symbols will continue to be important. It may be desirable to arrange these devices to print one symbol for the bit pattern of both upper and lower case of a given alphabetic letter. To facilitate this, there should be a single-bit difference between the upper and lower case representations of any given letter. Combined with the requirement that a given case of the alphabet be contiguous, this dictated the assignment of the alphabet, as shown in columns 4 through 7.<p>I just found and skimmed Bob Bemer&#x27;s &quot;A Story of ASCII&quot;, which includes personal recollections of the history. It seems that the 6-bit subset was firmed up first. From <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ascii-bemer&#x2F;page&#x2F;n17&#x2F;mode&#x2F;2up?q=lower" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ascii-bemer&#x2F;page&#x2F;n17&#x2F;mode&#x2F;2up?q=...</a> :<p>&gt; This is reflected in the set I proposed to X3 on 1961 September 18 (Table 3, column 3), and these three characters remained in the set from that time on. The lower case alphabet was also shown, but for some time this was resisted, lest the communications people find a need for more than the two columns then allocated for control functions.<p>but serious discussion of lower case wasn&#x27;t taken up until later. From <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ascii-bemer&#x2F;page&#x2F;n25&#x2F;mode&#x2F;2up?q=lower" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ascii-bemer&#x2F;page&#x2F;n25&#x2F;mode&#x2F;2up?q=...</a> :<p>&gt; ISO&#x2F;TC97&#x2F;SC2 held its next meeting in 1963 October, at which time it was decided to add the lower case alphabet.<p>and at <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ascii-bemer&#x2F;page&#x2F;n27&#x2F;mode&#x2F;2up?q=lower" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ascii-bemer&#x2F;page&#x2F;n27&#x2F;mode&#x2F;2up?q=...</a> :<p>&gt; At the 1963 May meeting in Geneva, CCITT endorsed the principle of the 7-bit code for any new telegraph alphabet, and expressed general but preliminary agreement with the ISO work. It further requested the placement of the lower case alphabet in the unassigned area.<p>Bemer did not like interleaving lower- and upper-case. From <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ascii-bemer&#x2F;page&#x2F;n5&#x2F;mode&#x2F;2up?q=lower" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;ascii-bemer&#x2F;page&#x2F;n5&#x2F;mode&#x2F;2up?q=l...</a> :<p>&gt; I had a great opportunity to start on the standards road when invited by Dr. Werner Buchholz to do the main design of the 120-character set [9,24] for the Stretch computer (the IBM 7030). I had help, but the mistakes are all mine (such as the interspersal of the upper and lower case alphabets). ...<p>&gt; he didn&#x27;t make the same mistake I made for STRETCH by interspersing both cases of the alphabet!</div><br/></div></div></div></div></div></div></div></div><div id="38359038" class="c"><input type="checkbox" id="c-38359038" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38343898">prev</a><span>|</span><label class="collapse" for="c-38359038">[-]</label><label class="expand" for="c-38359038">[1 more]</label></div><br/><div class="children"><div class="content">I first met base64 in ASP.NET viewstate.</div><br/></div></div></div></div></div></div></div></body></html>