<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704531656404" as="style"/><link rel="stylesheet" href="styles.css?v=1704531656404"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.lysator.liu.se/c/dmr-on-or.html">Dennis Ritchie on the priorities of &amp;&amp; || vs. == etc. (1982)</a> <span class="domain">(<a href="https://www.lysator.liu.se">www.lysator.liu.se</a>)</span></div><div class="subtext"><span>spc476</span> | <span>124 comments</span></div><br/><div><div id="38885868" class="c"><input type="checkbox" id="c-38885868" checked=""/><div class="controls bullet"><span class="by">Sohcahtoa82</span><span>|</span><a href="#38886063">next</a><span>|</span><label class="collapse" for="c-38885868">[-]</label><label class="expand" for="c-38885868">[84 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t even know the priority between &amp;&amp; and ||.  If I&#x27;m using both, I use parentheses just so it&#x27;s more explicit.  &quot;a &amp;&amp; b || c&quot; should flag a linter, IMO, with &quot;(a &amp;&amp; b) || c&quot; or &quot;a &amp;&amp; (b || c)&quot; being required.</div><br/><div id="38885977" class="c"><input type="checkbox" id="c-38885977" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38886613">next</a><span>|</span><label class="collapse" for="c-38885977">[-]</label><label class="expand" for="c-38885977">[47 more]</label></div><br/><div class="children"><div class="content">Convert them to arithmetic. If you ignore the casting,<p><pre><code>  a &amp;&amp; b   is just   a * b
  a || b   is just   a + b
</code></pre>
Now you remember the precedence between them (except in broken languages, of which the only notable one is shell).</div><br/><div id="38889173" class="c"><input type="checkbox" id="c-38889173" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885977">parent</a><span>|</span><a href="#38886986">next</a><span>|</span><label class="collapse" for="c-38889173">[-]</label><label class="expand" for="c-38889173">[4 more]</label></div><br/><div class="children"><div class="content">My problem here is that I distinguish between multiplication and addition by seeing which one distributes over the other.<p><pre><code>  a * (x + y) = (a * x) + (a * y)
</code></pre>
However, the reverse doesn’t work…<p><pre><code>  a + (x * y) =? (a + x) * (a + y)
</code></pre>
Why is this a problem?<p><pre><code>  a ∧ (x ∨ y) = (a ∧ x) ∨ (a ∧ y)
  a ∨ (x ∧ y) = (a ∨ x) ∧ (a ∨ y)
</code></pre>
Both are true. So, who are we to say that one corresponds to multiplication, and the other corresponds to addition? The two operations are too similar to each other.</div><br/><div id="38889412" class="c"><input type="checkbox" id="c-38889412" checked=""/><div class="controls bullet"><span class="by">throwaway421967</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38889173">parent</a><span>|</span><a href="#38886986">next</a><span>|</span><label class="collapse" for="c-38889412">[-]</label><label class="expand" for="c-38889412">[3 more]</label></div><br/><div class="children"><div class="content">because 1 \and 0 = 0 same as 1 * 0 = 0
and     1  \or  0 = 1 same as 1 + 0 = 1</div><br/><div id="38889438" class="c"><input type="checkbox" id="c-38889438" checked=""/><div class="controls bullet"><span class="by">dietrichepp</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38889412">parent</a><span>|</span><a href="#38886986">next</a><span>|</span><label class="collapse" for="c-38889438">[-]</label><label class="expand" for="c-38889438">[2 more]</label></div><br/><div class="children"><div class="content">Choosing false = 0 and true = 1 is putting the cart before the horse.<p>It is equally true that 1*0=0 is the same as false|true=true, and 0+1=1 is the same as true&amp;false=false.<p>But it is also not true that 1+1=1, so it is probably wrong to equate &#x27;or&#x27; with &#x27;+&#x27;. The operation has the wrong properties.<p>As someone who sometimes dabbles in electronics, 0 = true makes a lot of intuitive sense to me. You have your pin with an open collector, your pull-up resistor, and “true” (as in, it is <i>true</i> that the transistor is conducting) pulls the voltage to ground, which is 0.<p>As someone who uses a Unix shell, 0 = true makes a lot of intuitive sense to me.<p><pre><code>  $ true; echo $?
  0
  $ false; echo $?
  1</code></pre></div><br/><div id="38889710" class="c"><input type="checkbox" id="c-38889710" checked=""/><div class="controls bullet"><span class="by">ninthcat</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38889438">parent</a><span>|</span><a href="#38886986">next</a><span>|</span><label class="collapse" for="c-38889710">[-]</label><label class="expand" for="c-38889710">[1 more]</label></div><br/><div class="children"><div class="content">You can interpret 0 and 1 as probabilities. 1 + 1 = 1 in this case makes sense because P(A or B) = P(A) + P(B) - P(A and B). You can interpret &quot;A or B&quot; as a set union and &quot;A and B&quot; as a set intersection. Of course it&#x27;s easy to draw a three-way correspondence between Boolean arithmetic, the events represented by the empty set and the whole space, and sets within some universe because all the objects are so simple, but these correspondences also generalize well to systems with more than two possible values. The ease of generalizing makes me think it&#x27;s not just a matter of coincidence or convention that we have 0 &lt;=&gt; false.</div><br/></div></div></div></div></div></div></div></div><div id="38886986" class="c"><input type="checkbox" id="c-38886986" checked=""/><div class="controls bullet"><span class="by">anonnon</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885977">parent</a><span>|</span><a href="#38889173">prev</a><span>|</span><a href="#38886065">next</a><span>|</span><label class="collapse" for="c-38886986">[-]</label><label class="expand" for="c-38886986">[3 more]</label></div><br/><div class="children"><div class="content">&gt; except in broken languages, of which the only notable one is shell<p>All binary messages in Smalltalk (messages with selectors consisting of punctuation, like !@+-, including punctuation sequences like &quot;+-&amp;|&quot;, if you want) have the same precedence, and the keyword variants (which short-circuit, using block arguments) and: and or: also have the same precedence (one level lower than the binary&#x2F;punctuation messages), but because they take block arguments, are usually disambiguated:<p><pre><code>    a | (b &amp; c) &quot;parens needed to ensure b &amp; c is evaluated first&quot;
        ifTrue: [self doSomething]
        ifFalse: [
                &quot;because the and: is sent in a block arg to or:, it won&#x27;t be evaluated unless or:&#x27;s receiver is false&quot;
                (self hasPendingTask or: [self updateTaskQueue and: [self hasPendingTask]])
                        ifTrue: [self processTask]]
</code></pre>
Smalltalk is extremely elegant, powerful, and simple. 6 reserved words, 3 levels of operator precedence, and not much syntax to learn. It&#x27;s what r5rs Scheme should have been.</div><br/><div id="38888826" class="c"><input type="checkbox" id="c-38888826" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886986">parent</a><span>|</span><a href="#38886065">next</a><span>|</span><label class="collapse" for="c-38888826">[-]</label><label class="expand" for="c-38888826">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Smalltalk [...] what r5rs Scheme should have been.</i><p>I&#x27;m a fan of both languages, but R5RS Scheme was to be an algorithmic language, and Smalltalk is a particular flavor of OO language (class-instance, single dispatch).<p>Would you say that doing conditionals and Boolean expressions with Smalltalk&#x27;s object semantics and `ifTrue:ifFalse:` and mix of `and:` and `&amp;` etc. is cleaner than Scheme&#x27;s `if`, `and`, etc. syntax?<p>&gt; <i>3 levels of operator precedence,</i><p>Scheme doesn&#x27;t see what&#x27;s wrong with fewer:<p><pre><code>    (if (or a (and b c))
        (do-something)
        (if (or (has-pending-task)
                (and (update-task-queue)
                     (has-pending-task)))
            (process-task)))</code></pre></div><br/><div id="38889029" class="c"><input type="checkbox" id="c-38889029" checked=""/><div class="controls bullet"><span class="by">anonnon</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38888826">parent</a><span>|</span><a href="#38886065">next</a><span>|</span><label class="collapse" for="c-38889029">[-]</label><label class="expand" for="c-38889029">[1 more]</label></div><br/><div class="children"><div class="content">By &quot;should have been&quot; I meant striking the balance of simplicity, power, and ease of learning that Smalltalk does. R5RS is simple and powerful (even more powerful due to macros), but not really usable, since it doesn&#x27;t ship with something like Smalltalk&#x27;s object model out-of-the box that streamlines creating ADTs and code reuse. Instead they give you the rudiments (functions, closures) and leave everything else up to you.</div><br/></div></div></div></div></div></div><div id="38886065" class="c"><input type="checkbox" id="c-38886065" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885977">parent</a><span>|</span><a href="#38886986">prev</a><span>|</span><a href="#38886064">next</a><span>|</span><label class="collapse" for="c-38886065">[-]</label><label class="expand" for="c-38886065">[1 more]</label></div><br/><div class="children"><div class="content">Also if you forget which is multiplication and which is addition, remember false is 0 and true is 1, then work it out from there: a * b is only nonzero if both of them are nonzero, so it&#x27;s AND.</div><br/></div></div><div id="38886064" class="c"><input type="checkbox" id="c-38886064" checked=""/><div class="controls bullet"><span class="by">dananabread</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885977">parent</a><span>|</span><a href="#38886065">prev</a><span>|</span><a href="#38886194">next</a><span>|</span><label class="collapse" for="c-38886064">[-]</label><label class="expand" for="c-38886064">[20 more]</label></div><br/><div class="children"><div class="content">Is there an intuition for this correspondence otherwise I don&#x27;t think it&#x27;s very helpful</div><br/><div id="38886368" class="c"><input type="checkbox" id="c-38886368" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886064">parent</a><span>|</span><a href="#38886137">next</a><span>|</span><label class="collapse" for="c-38886368">[-]</label><label class="expand" for="c-38886368">[6 more]</label></div><br/><div class="children"><div class="content">There is:<p>The neutral element for + is 0 (<i>x</i> + 0 = <i>x</i> for any <i>x</i>).<p>The neutral element for * is 1 (<i>x</i> * 1 = <i>x</i> for any <i>x</i>).<p>Furthermore, you have arithmetic properties like <i>x</i> * 0 = 0 for any <i>x</i> (annulation) or (<i>x</i> + <i>y</i>) * <i>z</i> = (<i>x</i> * <i>z</i>) + (<i>y</i> * <i>z</i>) for any <i>x</i>, <i>y</i>, <i>z</i> (distributivity).<p>Similarly:<p>The neutral element for OR is <i>false</i> (<i>x</i> OR <i>false</i> = <i>x</i> for any <i>x</i>).<p>The neutral element for AND is <i>true</i> (<i>x</i> AND <i>true</i> = <i>x</i> for any <i>x</i>).<p>Furthermore, <i>x</i> AND <i>false</i> = <i>false</i> for any <i>x</i>, and (<i>x</i> OR <i>y</i>) AND <i>z</i> = (<i>x</i> AND <i>z</i>) OR (<i>y</i> AND <i>z</i>) for any <i>x</i>, <i>y</i>, <i>z</i>.<p>So OR works very much like + algebraically, and AND works very much like *.<p>When using 0 and 1 for <i>false</i> and <i>true</i>, AND is exactly the same as multiplication, and OR is like addition with saturation arithmetics (i.e. 1 + 1 = 1).<p>The common precedence rules stem from those parallels.</div><br/><div id="38886412" class="c"><input type="checkbox" id="c-38886412" checked=""/><div class="controls bullet"><span class="by">threatofrain</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886368">parent</a><span>|</span><a href="#38886439">next</a><span>|</span><label class="collapse" for="c-38886412">[-]</label><label class="expand" for="c-38886412">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never heard of saturation arithmetic and now it all makes sense. Otherwise I thought it was more common to think of XOR as boolean addition, and OR would be represented as xy + x + y.</div><br/><div id="38886549" class="c"><input type="checkbox" id="c-38886549" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886412">parent</a><span>|</span><a href="#38888230">next</a><span>|</span><label class="collapse" for="c-38886549">[-]</label><label class="expand" for="c-38886549">[1 more]</label></div><br/><div class="children"><div class="content">Yes, <i>true</i> and <i>false</i>  with AND and XOR form a mathematical ring [0]. Still, OR is also an additive operation. IMO one could give OR and XOR the same precedence.<p>On the other hand, there is no strict need to have a dedicated boolean XOR operator, as it works the same as = (equals).<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ring_(mathematics)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ring_(mathematics)</a></div><br/></div></div><div id="38888230" class="c"><input type="checkbox" id="c-38888230" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886412">parent</a><span>|</span><a href="#38886549">prev</a><span>|</span><a href="#38887089">next</a><span>|</span><label class="collapse" for="c-38888230">[-]</label><label class="expand" for="c-38888230">[1 more]</label></div><br/><div class="children"><div class="content">Fun (but not particularly useful fact) is you can also represent x OR y as 1 - (1 - x)(1 - y). This shouldn&#x27;t be too weird since x OR y is equal to NOT ((NOT x) AND (NOT y)).</div><br/></div></div><div id="38887089" class="c"><input type="checkbox" id="c-38887089" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886412">parent</a><span>|</span><a href="#38888230">prev</a><span>|</span><a href="#38886439">next</a><span>|</span><label class="collapse" for="c-38887089">[-]</label><label class="expand" for="c-38887089">[1 more]</label></div><br/><div class="children"><div class="content">Saturation is actually the wrong way to think about bools when other operations get involved:<p>saturate(0 - 1) = 0<p>bool(0 - 1) = 1</div><br/></div></div></div></div><div id="38886439" class="c"><input type="checkbox" id="c-38886439" checked=""/><div class="controls bullet"><span class="by">nostrademons</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886368">parent</a><span>|</span><a href="#38886412">prev</a><span>|</span><a href="#38886137">next</a><span>|</span><label class="collapse" for="c-38886439">[-]</label><label class="expand" for="c-38886439">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also a connection to probability: if you want the probability of A and B and C happening and they&#x27;re independent, it&#x27;s P(A) * P(B) * P(C).  If you want the probability of A or B or C happening and they&#x27;re mutually exclusive, it&#x27;s P(A) + P(B) + P(C).<p>Similar analogue for set theory, as another commenter pointed out.</div><br/></div></div></div></div><div id="38886137" class="c"><input type="checkbox" id="c-38886137" checked=""/><div class="controls bullet"><span class="by">aragonite</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886064">parent</a><span>|</span><a href="#38886368">prev</a><span>|</span><a href="#38886367">next</a><span>|</span><label class="collapse" for="c-38886137">[-]</label><label class="expand" for="c-38886137">[1 more]</label></div><br/><div class="children"><div class="content">Conjunction used to be called logical product, and disjunction logical sum, for the reason the other commenters pointed out.</div><br/></div></div><div id="38886367" class="c"><input type="checkbox" id="c-38886367" checked=""/><div class="controls bullet"><span class="by">fasterik</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886064">parent</a><span>|</span><a href="#38886137">prev</a><span>|</span><a href="#38886076">next</a><span>|</span><label class="collapse" for="c-38886367">[-]</label><label class="expand" for="c-38886367">[1 more]</label></div><br/><div class="children"><div class="content">I always remember it in terms of set operations. &amp;&amp; corresponds to set intersection, while || corresponds to set union. The union operation is similar to &quot;adding&quot; two sets together. You also have the distributive property: a &amp;&amp; (b || c) == (a &amp;&amp; b) || (a &amp;&amp; c).<p>The analogy isn&#x27;t perfect, because || is also distributive over &amp;&amp;, but addition isn&#x27;t distributive over multiplication. I think this is actually one of the essential properties that distinguishes a Boolean algebra from a ring. Someone with more knowledge of abstract algebra could probably provide more insight here, though.</div><br/></div></div><div id="38886076" class="c"><input type="checkbox" id="c-38886076" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886064">parent</a><span>|</span><a href="#38886367">prev</a><span>|</span><a href="#38886272">next</a><span>|</span><label class="collapse" for="c-38886076">[-]</label><label class="expand" for="c-38886076">[4 more]</label></div><br/><div class="children"><div class="content">a * b * c is only nonzero if all of a, b, c are nonzero. That&#x27;s AND, and should be pretty intuitive.<p>a + b + c is nonzero if any of them are nonzero. (Remember each value is either 0 or 1.) So that&#x27;s the intuition for OR.</div><br/><div id="38886124" class="c"><input type="checkbox" id="c-38886124" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886076">parent</a><span>|</span><a href="#38886272">next</a><span>|</span><label class="collapse" for="c-38886124">[-]</label><label class="expand" for="c-38886124">[3 more]</label></div><br/><div class="children"><div class="content">a+b+c is nonzero if any of a or b or c are nonzero.</div><br/><div id="38886145" class="c"><input type="checkbox" id="c-38886145" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886124">parent</a><span>|</span><a href="#38886272">next</a><span>|</span><label class="collapse" for="c-38886145">[-]</label><label class="expand" for="c-38886145">[2 more]</label></div><br/><div class="children"><div class="content">Yeah I just added that. I was hesitant initially cause you have to also note they&#x27;re nonnegative, and that you&#x27;re treating them like real numbers rather than mod 2.</div><br/><div id="38888550" class="c"><input type="checkbox" id="c-38888550" checked=""/><div class="controls bullet"><span class="by">explaininjs</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886145">parent</a><span>|</span><a href="#38886272">next</a><span>|</span><label class="collapse" for="c-38888550">[-]</label><label class="expand" for="c-38888550">[1 more]</label></div><br/><div class="children"><div class="content">Natural numbers are the natural numbers for me! (ISO 80000-2, of course)</div><br/></div></div></div></div></div></div></div></div><div id="38886272" class="c"><input type="checkbox" id="c-38886272" checked=""/><div class="controls bullet"><span class="by">nicklecompte</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886064">parent</a><span>|</span><a href="#38886076">prev</a><span>|</span><a href="#38886402">next</a><span>|</span><label class="collapse" for="c-38886272">[-]</label><label class="expand" for="c-38886272">[4 more]</label></div><br/><div class="children"><div class="content">IMO the intuition is to not use any intuition at all: there aren&#x27;t built-in booleans in C, true is a #define for 1 and false is a #define for 0. For C conditionals, 0 = false, nonzero = true.  So<p>a+b != 0 &lt;=&gt; a!=0 or b!=0<p>a*b != 0 &lt;=&gt; a!=0 and b!=0<p>Of course this intuition also reveals the pitfall behind this correspondence! You&#x27;d better make sure those are <i>unsigned</i> ints or #defined booleans, so you&#x27;re not using general C expressions. 1 || -1 is true but 1 + (-1) is false.<p>Edit: forgot to mention: INT_MAX || 1 is true, but what about INT_MAX + 1 :)</div><br/><div id="38886431" class="c"><input type="checkbox" id="c-38886431" checked=""/><div class="controls bullet"><span class="by">vzaliva</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886272">parent</a><span>|</span><a href="#38886402">next</a><span>|</span><label class="collapse" for="c-38886431">[-]</label><label class="expand" for="c-38886431">[3 more]</label></div><br/><div class="children"><div class="content">&quot;true is a #define for 1&quot; is bad idea. Because when `x` is, say, `2` then `if x` is not the same as `if x==true`.</div><br/><div id="38886824" class="c"><input type="checkbox" id="c-38886824" checked=""/><div class="controls bullet"><span class="by">BenjiWiebe</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886431">parent</a><span>|</span><a href="#38886402">next</a><span>|</span><label class="collapse" for="c-38886824">[-]</label><label class="expand" for="c-38886824">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just the way C is. If you want to check &quot;truthiness&quot; (as much as you can in C), just do &#x27;if x&#x27;.</div><br/><div id="38889579" class="c"><input type="checkbox" id="c-38889579" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886824">parent</a><span>|</span><a href="#38886402">next</a><span>|</span><label class="collapse" for="c-38889579">[-]</label><label class="expand" for="c-38889579">[1 more]</label></div><br/><div class="children"><div class="content">Something nice in C is that &quot;if (x)&quot; is always equivalent to &quot;if (x != 0)&quot;. NULL is a macro for 0, and so is false. Boolean expressions evaluate to 0 if they don&#x27;t hold. This isn&#x27;t true in C++, though.</div><br/></div></div></div></div></div></div></div></div><div id="38886402" class="c"><input type="checkbox" id="c-38886402" checked=""/><div class="controls bullet"><span class="by">artsi0m</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886064">parent</a><span>|</span><a href="#38886272">prev</a><span>|</span><a href="#38886289">next</a><span>|</span><label class="collapse" for="c-38886402">[-]</label><label class="expand" for="c-38886402">[1 more]</label></div><br/><div class="children"><div class="content">Yes, sometimes logical AND called logical multiplication and logical OR called logical summation.<p>It seems clear for me, because I remember learning De Morgan&#x27;s Laws in electronics class and from one specific level of Turing Complete game.</div><br/></div></div><div id="38886289" class="c"><input type="checkbox" id="c-38886289" checked=""/><div class="controls bullet"><span class="by">rantingdemon</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886064">parent</a><span>|</span><a href="#38886402">prev</a><span>|</span><a href="#38886097">next</a><span>|</span><label class="collapse" for="c-38886289">[-]</label><label class="expand" for="c-38886289">[1 more]</label></div><br/><div class="children"><div class="content">Kudos to the people that responded to explain why the correspondence is helpful.</div><br/></div></div><div id="38886097" class="c"><input type="checkbox" id="c-38886097" checked=""/><div class="controls bullet"><span class="by">naitgacem</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886064">parent</a><span>|</span><a href="#38886289">prev</a><span>|</span><a href="#38886194">next</a><span>|</span><label class="collapse" for="c-38886097">[-]</label><label class="expand" for="c-38886097">[1 more]</label></div><br/><div class="children"><div class="content">this is the notation used in the chapters about boolean algebra in my digital design course. I think it&#x27;s pretty neat. I honestly never looked into operator precedence in any language enough to notice the relation.</div><br/></div></div></div></div><div id="38886194" class="c"><input type="checkbox" id="c-38886194" checked=""/><div class="controls bullet"><span class="by">threatofrain</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885977">parent</a><span>|</span><a href="#38886064">prev</a><span>|</span><a href="#38886179">next</a><span>|</span><label class="collapse" for="c-38886194">[-]</label><label class="expand" for="c-38886194">[5 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it x ^ y which is like x + y?</div><br/><div id="38886286" class="c"><input type="checkbox" id="c-38886286" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886194">parent</a><span>|</span><a href="#38889677">next</a><span>|</span><label class="collapse" for="c-38886286">[-]</label><label class="expand" for="c-38886286">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, | is technically x + y + x*y over GF(2) (this is the Boolean ring to Boolean algebra relation [1]). The GP is still a good way to remember the precedence though.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Boolean_ring#Relation_to_Boolean_algebras" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Boolean_ring#Relation_to_Boole...</a></div><br/></div></div><div id="38889677" class="c"><input type="checkbox" id="c-38889677" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886194">parent</a><span>|</span><a href="#38886286">prev</a><span>|</span><a href="#38887071">next</a><span>|</span><label class="collapse" for="c-38889677">[-]</label><label class="expand" for="c-38889677">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. To sum two bits x and y, the immediate sum is x XOR y, and the carry is x AND y. That&#x27;s how a simple half-adder circuit can be made.</div><br/></div></div><div id="38887071" class="c"><input type="checkbox" id="c-38887071" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886194">parent</a><span>|</span><a href="#38889677">prev</a><span>|</span><a href="#38886841">next</a><span>|</span><label class="collapse" for="c-38887071">[-]</label><label class="expand" for="c-38887071">[1 more]</label></div><br/><div class="children"><div class="content">^ is like + when operating over bits, since (bit)2 == 0<p>| is like + when operating over bools, since (bool)2 == 1</div><br/></div></div><div id="38886841" class="c"><input type="checkbox" id="c-38886841" checked=""/><div class="controls bullet"><span class="by">pvtmert</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886194">parent</a><span>|</span><a href="#38887071">prev</a><span>|</span><a href="#38886179">next</a><span>|</span><label class="collapse" for="c-38886841">[-]</label><label class="expand" for="c-38886841">[1 more]</label></div><br/><div class="children"><div class="content">xor is more like a substraction...</div><br/></div></div></div></div><div id="38886295" class="c"><input type="checkbox" id="c-38886295" checked=""/><div class="controls bullet"><span class="by">ksherlock</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885977">parent</a><span>|</span><a href="#38886179">prev</a><span>|</span><a href="#38889713">next</a><span>|</span><label class="collapse" for="c-38886295">[-]</label><label class="expand" for="c-38886295">[1 more]</label></div><br/><div class="children"><div class="content">0x8000 &amp;&amp; 2 != 0x8000 * 2<p>-1 || 1 != -1 + 1<p>0x8000 || 0x8000 != 0x8000 + 0x8000<p>(with a 16-bit integer, adjust accordingly for larger word sizes)</div><br/></div></div><div id="38889713" class="c"><input type="checkbox" id="c-38889713" checked=""/><div class="controls bullet"><span class="by">msla</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885977">parent</a><span>|</span><a href="#38886295">prev</a><span>|</span><a href="#38886129">next</a><span>|</span><label class="collapse" for="c-38889713">[-]</label><label class="expand" for="c-38889713">[1 more]</label></div><br/><div class="children"><div class="content">&gt; except in broken languages, of which the only notable one is shell<p>The array language people (APL, J, K) are going to come in and protest, but you aren&#x27;t going to be able to understand them.<p>&#x2F;s</div><br/></div></div><div id="38886129" class="c"><input type="checkbox" id="c-38886129" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885977">parent</a><span>|</span><a href="#38889713">prev</a><span>|</span><a href="#38886613">next</a><span>|</span><label class="collapse" for="c-38886129">[-]</label><label class="expand" for="c-38886129">[10 more]</label></div><br/><div class="children"><div class="content">1+1=1? My maths education was a long time ago, but I triple checked with my calculator, and I&#x27;m uncertain this is quite right.<p>My own mnemonic: SAXO. Shift, And, Xor, Or. (Like a real Saxo, it&#x27;s fun to go a bit faster like this, but you do have to trust everybody involved, because any accident is probably going to end up badly for you.)<p>And now you know the bitwise precedence as well! And this ordering actually works out tidily for common operations: &quot;x=a&lt;&lt;sa|b&lt;&lt;sb|c&lt;&lt;sb&quot;; &quot;x=p&gt;&gt;n&amp;m&quot;; &quot;x=x&amp;~ma|a&lt;&lt;sa&quot;; and so on. You do need brackets sometimes, but fewer than you&#x27;d think, and it helps the unusual cases stand out.<p>(Main annoying thing: a lot of compilers, even popular ones such as clang and gcc, don&#x27;t actually seem to know what the precedence rules actually are, and generate warnings asking you to clarify. Presumably the authors didn&#x27;t realise that C has an ISO standard, that can be consulted to answer this question? Very surprising.)</div><br/><div id="38886171" class="c"><input type="checkbox" id="c-38886171" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886129">parent</a><span>|</span><a href="#38886293">next</a><span>|</span><label class="collapse" for="c-38886171">[-]</label><label class="expand" for="c-38886171">[2 more]</label></div><br/><div class="children"><div class="content">&gt; (Main annoying thing: a lot of compilers, even popular ones such as clang and gcc, don&#x27;t actually seem to know what the precedence rules actually are, and generate warnings asking you to clarify. Presumably the authors didn&#x27;t realise that C has an ISO standard, that can be consulted to answer this question? Very surprising.)<p>The compilers do know what the precedence rules are, but they know that programmers don&#x27;t routinely consult the ISO standard, so they emit those warnings to reduce the chance of error. Compilers are tools that are designed to help programmers avoid bugs. If they don&#x27;t help programmers, they aren&#x27;t doing their job.</div><br/><div id="38888418" class="c"><input type="checkbox" id="c-38888418" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886171">parent</a><span>|</span><a href="#38886293">next</a><span>|</span><label class="collapse" for="c-38888418">[-]</label><label class="expand" for="c-38888418">[1 more]</label></div><br/><div class="children"><div class="content">Alternatively, they&#x27;re encouraging programmers to be stupid and ignorant, causing a dumbing-down feedback loop which is ultimately damaging in the long term.<p>It ain&#x27;t no surprise if you see the crap that passes for software these days and the nosedive in quality, but that&#x27;s a rant for some other time...</div><br/></div></div></div></div><div id="38886293" class="c"><input type="checkbox" id="c-38886293" checked=""/><div class="controls bullet"><span class="by">LeifCarrotson</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886129">parent</a><span>|</span><a href="#38886171">prev</a><span>|</span><a href="#38886999">next</a><span>|</span><label class="collapse" for="c-38886293">[-]</label><label class="expand" for="c-38886293">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 1+1=1?<p>True + True = True, because &quot;true&quot; means &quot;not zero&quot; and &quot;false&quot; means &quot;zero&quot;. In most all languages that permit int-&gt;bool casting, if(2) will evaluate to &quot;true&quot;.<p>The warnings clang and FCC generate are a style warning because it&#x27;s unclear on casual reading. Even readers who know the precedence rules will typically want to insert the parentheses manually. If the meaning were undefined, the compiler would give an error, not a warning.</div><br/><div id="38886684" class="c"><input type="checkbox" id="c-38886684" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886293">parent</a><span>|</span><a href="#38886999">next</a><span>|</span><label class="collapse" for="c-38886684">[-]</label><label class="expand" for="c-38886684">[1 more]</label></div><br/><div class="children"><div class="content">It’s true as long as you don’t chain more than a couple billion Boolean checks.<p>More importantly, only if you don’t rely on short circuiting logic.</div><br/></div></div></div></div><div id="38886999" class="c"><input type="checkbox" id="c-38886999" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886129">parent</a><span>|</span><a href="#38886293">prev</a><span>|</span><a href="#38886231">next</a><span>|</span><label class="collapse" for="c-38886999">[-]</label><label class="expand" for="c-38886999">[2 more]</label></div><br/><div class="children"><div class="content">I suspect that most people here won’t get the joke. Renault pulled out of the US market 40 years ago, and was never more than a tiny player.</div><br/><div id="38887499" class="c"><input type="checkbox" id="c-38887499" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886999">parent</a><span>|</span><a href="#38886231">next</a><span>|</span><label class="collapse" for="c-38887499">[-]</label><label class="expand" for="c-38887499">[1 more]</label></div><br/><div class="children"><div class="content">Better than that: the Saxo was from Citroen, who apparently haven&#x27;t served North America since 1974 ;) The Renault equivalent would probably be the Clio.<p>(Not a big hot hatch connoisseur though, I must admit - I just remember the Saxo in particular as having a reputation of hitting a bad spot on the tradeoff graph for flimsiness&#x2F;power&#x2F;good sense of average member of target demographic.)</div><br/></div></div></div></div><div id="38886231" class="c"><input type="checkbox" id="c-38886231" checked=""/><div class="controls bullet"><span class="by">jovial_cavalier</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886129">parent</a><span>|</span><a href="#38886999">prev</a><span>|</span><a href="#38886239">next</a><span>|</span><label class="collapse" for="c-38886231">[-]</label><label class="expand" for="c-38886231">[1 more]</label></div><br/><div class="children"><div class="content">The analogy between logical AND and multiplication, and logical OR and addition is called Boolean Algebra, and it&#x27;s very well known.<p>The analogy is that when you set 1 to true and 0 to false, 1 becomes the identity for AND, and 0 becomes the identity for OR. Just as 1 is the identity for multiplication and 0 is the identity for addition.<p>X * 0 = 0  |  X ^ F = F<p>X * 1 = X  |  X ^ T = X<p>X + 0 = X  |  X V F = X<p>X + 1 = ? |  X V T = T &lt;-- This one breaks the analogy<p>With this, you can turn any logical expression into something that looks and feels like normal algebra, with the only weird exception being that both operators distribute over each other:<p>A * (B + C) = A*B + A*C<p>A + (B * C) = (A + B) * (A + C)</div><br/></div></div><div id="38886239" class="c"><input type="checkbox" id="c-38886239" checked=""/><div class="controls bullet"><span class="by">LordShredda</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886129">parent</a><span>|</span><a href="#38886231">prev</a><span>|</span><a href="#38886613">next</a><span>|</span><label class="collapse" for="c-38886239">[-]</label><label class="expand" for="c-38886239">[2 more]</label></div><br/><div class="children"><div class="content">1+1 isn&#x27;t zero, so it&#x27;s one.</div><br/></div></div></div></div></div></div><div id="38886613" class="c"><input type="checkbox" id="c-38886613" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38885977">prev</a><span>|</span><a href="#38889520">next</a><span>|</span><label class="collapse" for="c-38886613">[-]</label><label class="expand" for="c-38886613">[3 more]</label></div><br/><div class="children"><div class="content">The Ada language <i>requires explicit parentheses in the case of a succession of different logical operators</i>  precisely to avoid precedence-related bugs. [0]<p>In the Pony language, <i>any expression where more than one infix operator is used must use parentheses to remove the ambiguity.</i> [1]<p>The Zig language considered following Pony, but didn&#x27;t. [2]<p>[0] <a href="http:&#x2F;&#x2F;archive.adaic.com&#x2F;standards&#x2F;83rat&#x2F;html&#x2F;ratl-03-06.html" rel="nofollow">http:&#x2F;&#x2F;archive.adaic.com&#x2F;standards&#x2F;83rat&#x2F;html&#x2F;ratl-03-06.htm...</a><p>[1] <a href="https:&#x2F;&#x2F;tutorial.ponylang.io&#x2F;expressions&#x2F;ops#precedence" rel="nofollow">https:&#x2F;&#x2F;tutorial.ponylang.io&#x2F;expressions&#x2F;ops#precedence</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;114">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;114</a></div><br/><div id="38886643" class="c"><input type="checkbox" id="c-38886643" checked=""/><div class="controls bullet"><span class="by">pi-e-sigma</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886613">parent</a><span>|</span><a href="#38886931">next</a><span>|</span><label class="collapse" for="c-38886643">[-]</label><label class="expand" for="c-38886643">[1 more]</label></div><br/><div class="children"><div class="content">Ada is such an underrated language. The lack of its adoption is a testament to the old adage that technologies don&#x27;t thrive or die on their technical merits.</div><br/></div></div><div id="38886931" class="c"><input type="checkbox" id="c-38886931" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886613">parent</a><span>|</span><a href="#38886643">prev</a><span>|</span><a href="#38889520">next</a><span>|</span><label class="collapse" for="c-38886931">[-]</label><label class="expand" for="c-38886931">[1 more]</label></div><br/><div class="children"><div class="content">What about using the same associative operator multiple times?</div><br/></div></div></div></div><div id="38889520" class="c"><input type="checkbox" id="c-38889520" checked=""/><div class="controls bullet"><span class="by">cm2187</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38886613">prev</a><span>|</span><a href="#38888791">next</a><span>|</span><label class="collapse" for="c-38889520">[-]</label><label class="expand" for="c-38889520">[1 more]</label></div><br/><div class="children"><div class="content">I just asked myself the question for SQL&#x27;s AND and OR this week. Apparently AND takes precedence but I don&#x27;t know if it is consistent accross all SQL engines. In any case it seems to me that few programers will know anyway, so it is bad practice to not have parenthesis.</div><br/></div></div><div id="38888791" class="c"><input type="checkbox" id="c-38888791" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38889520">prev</a><span>|</span><a href="#38886808">next</a><span>|</span><label class="collapse" for="c-38888791">[-]</label><label class="expand" for="c-38888791">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, it&#x27;s quite justified: If their implicit combined behavior isn&#x27;t easy-to-read-obvious to the author <i>composing</i> the code, then it&#x27;s also problematic for any poor future-person (perhaps even the original author) tasked with reading and verifying the code. Checking parens is faster than remembering and applying the knowledge.<p>Plus the rules may be just different enough in different languages to trip up even those who try to remember them.</div><br/></div></div><div id="38886808" class="c"><input type="checkbox" id="c-38886808" checked=""/><div class="controls bullet"><span class="by">moritzwarhier</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38888791">prev</a><span>|</span><a href="#38888980">next</a><span>|</span><label class="collapse" for="c-38886808">[-]</label><label class="expand" for="c-38886808">[1 more]</label></div><br/><div class="children"><div class="content">It bothered me a while for &quot;short&quot; boolean expressions to have a linter expect parens, where I&#x27;d simultaneously expect everyone with a high school degree to understand the implicit operator precedence.<p>Then, since my first bug having been merged that was caused by a &amp;&amp; vs || operator precedence mistake, I like my parens-always ESLint rule (or whatever exactly it was called).<p>Even redundant parens can start to look as pleasent as indents, after getting used to them.<p>In short, I think expressions like (a &amp;&amp; b || c &amp;&amp; d || e) are a footgun and linters should forbid them. Parens fit well with logical thinking, similar to relative clauses in language.</div><br/></div></div><div id="38888980" class="c"><input type="checkbox" id="c-38888980" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38886808">prev</a><span>|</span><a href="#38885909">next</a><span>|</span><label class="collapse" for="c-38888980">[-]</label><label class="expand" for="c-38888980">[1 more]</label></div><br/><div class="children"><div class="content">I also do (it also makes it more clearly, in my opinion), as well as with the bitwise operators &amp; and | but sometimes with the bitwise operators the code is written in such a way that the precedence doesn&#x27;t matter anyways and so I will not need to add parentheses anyways.</div><br/></div></div><div id="38885909" class="c"><input type="checkbox" id="c-38885909" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38888980">prev</a><span>|</span><a href="#38886378">next</a><span>|</span><label class="collapse" for="c-38885909">[-]</label><label class="expand" for="c-38885909">[7 more]</label></div><br/><div class="children"><div class="content">Consider (&amp;&amp; a b) and (|| a b) for no uncertainty over operator precedence and easy variadic representation (&amp;&amp; a b c) at the cost of zero additional parentheses.</div><br/><div id="38887433" class="c"><input type="checkbox" id="c-38887433" checked=""/><div class="controls bullet"><span class="by">tasty_freeze</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885909">parent</a><span>|</span><a href="#38888420">next</a><span>|</span><label class="collapse" for="c-38887433">[-]</label><label class="expand" for="c-38887433">[1 more]</label></div><br/><div class="children"><div class="content">... at the cost of having parentheses around every subexpression.</div><br/></div></div><div id="38888420" class="c"><input type="checkbox" id="c-38888420" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885909">parent</a><span>|</span><a href="#38887433">prev</a><span>|</span><a href="#38885948">next</a><span>|</span><label class="collapse" for="c-38888420">[-]</label><label class="expand" for="c-38888420">[1 more]</label></div><br/><div class="children"><div class="content">I hate Excel for this very reason.</div><br/></div></div><div id="38885948" class="c"><input type="checkbox" id="c-38885948" checked=""/><div class="controls bullet"><span class="by">namrog84</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885909">parent</a><span>|</span><a href="#38888420">prev</a><span>|</span><a href="#38885971">next</a><span>|</span><label class="collapse" for="c-38885948">[-]</label><label class="expand" for="c-38885948">[2 more]</label></div><br/><div class="children"><div class="content">While true and might be easy to read in the example context of a b c I&#x27;d imagine having the &amp;&amp; separator in real world conditions to be far more readable and clear for vast majority if people</div><br/><div id="38887018" class="c"><input type="checkbox" id="c-38887018" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885948">parent</a><span>|</span><a href="#38885971">next</a><span>|</span><label class="collapse" for="c-38887018">[-]</label><label class="expand" for="c-38887018">[1 more]</label></div><br/><div class="children"><div class="content">Pipe looks far too much like a 1 or lowercase ell.</div><br/></div></div></div></div><div id="38885971" class="c"><input type="checkbox" id="c-38885971" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885909">parent</a><span>|</span><a href="#38885948">prev</a><span>|</span><a href="#38886274">next</a><span>|</span><label class="collapse" for="c-38885971">[-]</label><label class="expand" for="c-38885971">[1 more]</label></div><br/><div class="children"><div class="content">Most, and possibly all languages I&#x27;ve used day to day do not have prefix operators like that.</div><br/></div></div><div id="38886274" class="c"><input type="checkbox" id="c-38886274" checked=""/><div class="controls bullet"><span class="by">ant6n</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38885909">parent</a><span>|</span><a href="#38885971">prev</a><span>|</span><a href="#38886378">next</a><span>|</span><label class="collapse" for="c-38886274">[-]</label><label class="expand" for="c-38886274">[1 more]</label></div><br/><div class="children"><div class="content">Prefix operators considered harmful for readability.</div><br/></div></div></div></div><div id="38886378" class="c"><input type="checkbox" id="c-38886378" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38885909">prev</a><span>|</span><a href="#38889207">next</a><span>|</span><label class="collapse" for="c-38886378">[-]</label><label class="expand" for="c-38886378">[10 more]</label></div><br/><div class="children"><div class="content">Sorry, but I&#x27;m of the exact opposite opinion. If you don&#x27;t know, learn. It&#x27;s not hard (as other sibling comments have noted). Code with superfluous parentheses is even more confusing, since I expect them to be present only when overriding precedence.<p>...and I just realised your username adds some additional irony.</div><br/><div id="38886593" class="c"><input type="checkbox" id="c-38886593" checked=""/><div class="controls bullet"><span class="by">mdbauman</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886378">parent</a><span>|</span><a href="#38889717">prev</a><span>|</span><a href="#38886534">next</a><span>|</span><label class="collapse" for="c-38886593">[-]</label><label class="expand" for="c-38886593">[1 more]</label></div><br/><div class="children"><div class="content">Although I agree, most times where I mix any of these without parentheses I end up having to explain it either in code review or when somebody does a `git blame` a couple months later. Rather than waste everyone&#x27;s time explaining it, it&#x27;s easier to just use the parentheses since it&#x27;s what many&#x2F;most people expect and everyone else can read it well enough.</div><br/></div></div><div id="38886534" class="c"><input type="checkbox" id="c-38886534" checked=""/><div class="controls bullet"><span class="by">sublinear</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886378">parent</a><span>|</span><a href="#38886593">prev</a><span>|</span><a href="#38889207">next</a><span>|</span><label class="collapse" for="c-38886534">[-]</label><label class="expand" for="c-38886534">[7 more]</label></div><br/><div class="children"><div class="content">Explicit is better than implicit. I think the real problem is not breaking up complicated expressions. If it&#x27;s more than just a few pairs of parentheses making it hard to read there&#x27;s something more wrong there.</div><br/><div id="38886833" class="c"><input type="checkbox" id="c-38886833" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886534">parent</a><span>|</span><a href="#38889207">next</a><span>|</span><label class="collapse" for="c-38886833">[-]</label><label class="expand" for="c-38886833">[6 more]</label></div><br/><div class="children"><div class="content">I think most people agree &quot;a*x**b + c&quot; is more clear than &quot;(a*(x**b))+c&quot;.
Or &quot;a+b+c+d&quot; is more clear than &quot;a+(b+(c+d))&quot;.<p>Why are we happy to avoid parentheses for these operations but not for &amp;&amp; and ||? Probably because we are all really used to the precedences for + and *.<p>So at the end of the day, what&#x27;s more clear depends on How familiar  the engineers working on your code are with a given set of operators.</div><br/><div id="38889133" class="c"><input type="checkbox" id="c-38889133" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886833">parent</a><span>|</span><a href="#38888393">next</a><span>|</span><label class="collapse" for="c-38889133">[-]</label><label class="expand" for="c-38889133">[1 more]</label></div><br/><div class="children"><div class="content">Parentheses need to be matched. That adds cognitive overhead. It&#x27;s especially frustrating when you find the closing parenthesis and then realise it wasn&#x27;t even necessary.<p>IMHO it&#x27;s on a similar level as &quot;== true&quot; &quot;== false&quot; and variations thereof --- absolutely redundant and unnecessary, and shows a lack of knowledge. The same &quot;explicit is better than implicit&quot; mantra is often repeated to justify the latter, but if you think<p><pre><code>    if(x == true)
</code></pre>
is somehow more &quot;explicit&quot;, then surely<p><pre><code>    if((x == true) == true)
</code></pre>
is even better?<p><i>So at the end of the day, what&#x27;s more clear depends on How familiar the engineers working on your code are with a given set of operators</i><p>If someone is not familiar then they should be encouraged to learn and level up, rather than pulling down everyone else.</div><br/></div></div><div id="38888393" class="c"><input type="checkbox" id="c-38888393" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886833">parent</a><span>|</span><a href="#38889133">prev</a><span>|</span><a href="#38888926">next</a><span>|</span><label class="collapse" for="c-38888393">[-]</label><label class="expand" for="c-38888393">[2 more]</label></div><br/><div class="children"><div class="content">Most people might agree with that, I don&#x27;t know, but I know I don&#x27;t think your first example is clearer. And I&#x27;ve had the operator precedence rules memorized for decades. Parentheses save my brain a step.<p>The second example is irrelevant because addition is commutative so the parentheses are meaningless. (This is why languages shouldn&#x27;t override + to be a concatenation operator.)</div><br/><div id="38889403" class="c"><input type="checkbox" id="c-38889403" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38888393">parent</a><span>|</span><a href="#38888926">next</a><span>|</span><label class="collapse" for="c-38889403">[-]</label><label class="expand" for="c-38889403">[1 more]</label></div><br/><div class="children"><div class="content">The important part that makes the parens in the second operation unnecessary is that addition is associative, not that it&#x27;s commutative. And concatentation is also associative, so even if those were strings, the parens would still be unnecessary.<p>That is, (a+b)+c == a+(b+c).<p>Interestingly, C integer addition is not <i>actually</i> associative, since (1+INT_MAX) + (-1) is UB, but 1+(INT_MAX+(-1)) should in principle be defined as INT_MAX.</div><br/></div></div></div></div><div id="38888926" class="c"><input type="checkbox" id="c-38888926" checked=""/><div class="controls bullet"><span class="by">saberience</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886833">parent</a><span>|</span><a href="#38888393">prev</a><span>|</span><a href="#38888673">next</a><span>|</span><label class="collapse" for="c-38888926">[-]</label><label class="expand" for="c-38888926">[1 more]</label></div><br/><div class="children"><div class="content">I think the opposite, I think most people would prefer the version with parentheses, including myself, also, in 20 years experience all companies I’ve worked for would prefer the second expression.<p>The first expression looks messy and confusing, the second is completely clear in how it will work.</div><br/></div></div><div id="38888673" class="c"><input type="checkbox" id="c-38888673" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886833">parent</a><span>|</span><a href="#38888926">prev</a><span>|</span><a href="#38889207">next</a><span>|</span><label class="collapse" for="c-38888673">[-]</label><label class="expand" for="c-38888673">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    ((x**b) * a) + c
</code></pre>
Is equivalent and is the clearer way to express it.</div><br/></div></div></div></div></div></div></div></div><div id="38889207" class="c"><input type="checkbox" id="c-38889207" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38886378">prev</a><span>|</span><a href="#38886711">next</a><span>|</span><label class="collapse" for="c-38889207">[-]</label><label class="expand" for="c-38889207">[3 more]</label></div><br/><div class="children"><div class="content">Do you know the priority in this?<p>[ -e &quot;${target}&quot; ] &amp;&amp; echo &quot;Getting information about ${target}&quot; &amp;&amp; stat &quot;${target}&quot; || echo &quot;Failed to stat file.&quot;<p>EDIT: What about the || die(&quot;...&quot;) pattern in Perl?<p>Or the fact that the glyphs in || are visually lower than the glyphs in &amp;&amp;?<p>Or that &quot;and&quot; comes before &quot;or&quot; in the expression &quot;and&#x2F;or&quot;?</div><br/><div id="38889699" class="c"><input type="checkbox" id="c-38889699" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38889207">parent</a><span>|</span><a href="#38889250">next</a><span>|</span><label class="collapse" for="c-38889699">[-]</label><label class="expand" for="c-38889699">[1 more]</label></div><br/><div class="children"><div class="content">The shell command is very readable.<p>a &amp;&amp; b &amp;&amp; c is a common idiom for &quot;stop if any step fails&quot;. In the shell language &amp;&amp; and || are more like control flow concepts, rather than binary operators.<p>And a &amp;&amp; b || c is a universal &quot;ternary operator&quot; (with one minor deviation) idiom across many languages, not just the shell</div><br/></div></div><div id="38889250" class="c"><input type="checkbox" id="c-38889250" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38889207">parent</a><span>|</span><a href="#38889699">prev</a><span>|</span><a href="#38886711">next</a><span>|</span><label class="collapse" for="c-38889250">[-]</label><label class="expand" for="c-38889250">[1 more]</label></div><br/><div class="children"><div class="content">Shell scripting sucks, but that’s hardly news.<p>If I really have to touch a bash script, I just assume nothing works like I might expect from proper programming languages despite any surface similarity, and google every construct with sweat drops dripping down my face. ChatGPT has made the process somewhat more tolerable.</div><br/></div></div></div></div><div id="38886711" class="c"><input type="checkbox" id="c-38886711" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38889207">prev</a><span>|</span><a href="#38886832">next</a><span>|</span><label class="collapse" for="c-38886711">[-]</label><label class="expand" for="c-38886711">[1 more]</label></div><br/><div class="children"><div class="content">I know the priorities of these, but I still use parentheses to make the precedence explicit. I think it&#x27;s just great practice -- and it makes things easier for the next dev who might have to work with the code.</div><br/></div></div><div id="38886832" class="c"><input type="checkbox" id="c-38886832" checked=""/><div class="controls bullet"><span class="by">asimeqi</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38886711">prev</a><span>|</span><a href="#38886967">next</a><span>|</span><label class="collapse" for="c-38886832">[-]</label><label class="expand" for="c-38886832">[1 more]</label></div><br/><div class="children"><div class="content">I once implemented a logical expression evaluator to be used as filters on a search page. My boss tested it and filed a bug because he expected OR to have higher precedence than AND. I pointed him to a page with the rules and told him that he could use parenthesis if he wanted to modify the order of precedence. He was sort of convinced but never closed the ticket. Every release he would move it to the next release.</div><br/></div></div><div id="38886967" class="c"><input type="checkbox" id="c-38886967" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38886832">prev</a><span>|</span><a href="#38887008">next</a><span>|</span><label class="collapse" for="c-38886967">[-]</label><label class="expand" for="c-38886967">[1 more]</label></div><br/><div class="children"><div class="content">|| is lower precedence than &amp;&amp;. I memorized that, just like I memorized that + is lower precedence than *.<p>There are some languages (e.g. shell) where they have the same precedence.<p>Prettier (JavaScript) adds parens like you suggest automatically.</div><br/></div></div><div id="38887008" class="c"><input type="checkbox" id="c-38887008" checked=""/><div class="controls bullet"><span class="by">nealabq</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38886967">prev</a><span>|</span><a href="#38886752">next</a><span>|</span><label class="collapse" for="c-38887008">[-]</label><label class="expand" for="c-38887008">[1 more]</label></div><br/><div class="children"><div class="content">Smalltalk doesn&#x27;t have operator precedence rules. They just apply left-to-right. The infix operators aren&#x27;t part of the language - they&#x27;re messages (aka methods), and precedence would be inconsistent with the language&#x27;s simple syntax.</div><br/></div></div><div id="38886752" class="c"><input type="checkbox" id="c-38886752" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38887008">prev</a><span>|</span><a href="#38887297">next</a><span>|</span><label class="collapse" for="c-38886752">[-]</label><label class="expand" for="c-38886752">[4 more]</label></div><br/><div class="children"><div class="content">You’re in good company[1]:<p><pre><code>  Do not introduce priority rules that destroy symmetry. I remember how much more pleasant the predicate calculus became to work with after we had decided to give con- and disjunction the same binding power and thus to consider p ∧ q ∨ r an ill-formed formula.
</code></pre>
[1] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD13xx&#x2F;EWD1300.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD13xx&#x2F;E...</a></div><br/><div id="38889701" class="c"><input type="checkbox" id="c-38889701" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886752">parent</a><span>|</span><a href="#38888829">next</a><span>|</span><label class="collapse" for="c-38889701">[-]</label><label class="expand" for="c-38889701">[1 more]</label></div><br/><div class="children"><div class="content">It should be noted that this is not same to using a default order (typically, but not necessarily, left-to-right) in such case. Some languages use a term &quot;non-associative&quot; instead.</div><br/></div></div><div id="38888829" class="c"><input type="checkbox" id="c-38888829" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886752">parent</a><span>|</span><a href="#38889701">prev</a><span>|</span><a href="#38886876">next</a><span>|</span><label class="collapse" for="c-38888829">[-]</label><label class="expand" for="c-38888829">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We don’t want to baffle or puzzle our readers, in particular it should be clear what has to be done to check our argument and it should be possible to do so without pencil and paper. This dictates small, explicit steps.<p>I feel this justifies why I sometimes write code with lots of temporary variables on their own lines: It&#x27;s a way to break down the problem, to <i>name</i> each thing (especially when it&#x27;s not a simple method-call to a correctly-named method) and it also makes it easier to verify the behavior with the average line-by-line debugger or line-by-line debugging easier.<p>In many cases, such temporary local variables have no negative performance impact, being optimized away.</div><br/></div></div><div id="38886876" class="c"><input type="checkbox" id="c-38886876" checked=""/><div class="controls bullet"><span class="by">thomasahle</span><span>|</span><a href="#38885868">root</a><span>|</span><a href="#38886752">parent</a><span>|</span><a href="#38888829">prev</a><span>|</span><a href="#38887297">next</a><span>|</span><label class="collapse" for="c-38886876">[-]</label><label class="expand" for="c-38886876">[1 more]</label></div><br/><div class="children"><div class="content">This article is a joy to read.</div><br/></div></div></div></div><div id="38887297" class="c"><input type="checkbox" id="c-38887297" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#38885868">parent</a><span>|</span><a href="#38886752">prev</a><span>|</span><a href="#38886063">next</a><span>|</span><label class="collapse" for="c-38887297">[-]</label><label class="expand" for="c-38887297">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m always surprised when people don&#x27;t know this one because they&#x27;re like multiplication and clamped addition.</div><br/></div></div></div></div><div id="38886063" class="c"><input type="checkbox" id="c-38886063" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#38885868">prev</a><span>|</span><a href="#38885940">next</a><span>|</span><label class="collapse" for="c-38886063">[-]</label><label class="expand" for="c-38886063">[9 more]</label></div><br/><div class="children"><div class="content">The relative priorities of &amp;&amp; vs ||, or &amp; vs |, match the traditional precedence in logical expressions: &quot;and&quot; binds more tightly than &quot;or&quot;, just as * binds more tightly than + (&quot;and&quot; is equivalent to * for one-bit values, and &quot;or&quot; is addition modulo 2). So I think that they got this correct.<p>However, the precedence of &amp; vs &amp;&amp;, or &amp; vs ||, etc is a source of problems.</div><br/><div id="38886427" class="c"><input type="checkbox" id="c-38886427" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#38886063">parent</a><span>|</span><a href="#38886396">next</a><span>|</span><label class="collapse" for="c-38886427">[-]</label><label class="expand" for="c-38886427">[4 more]</label></div><br/><div class="children"><div class="content">&amp; vs &amp;&amp; doesn&#x27;t feel like a problem to me.<p>&amp; vs == is the real problem: `(val &amp; MASK) == CONSTANT` needs parentheses due to this mistake.<p>`a &amp; (b == c)` essentially almost never makes sense (== gives you a boolean, and when dealing with booleans you can use &amp;&amp; instead), yet that it what you get by default if omitting the parentheses.</div><br/><div id="38886739" class="c"><input type="checkbox" id="c-38886739" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#38886063">root</a><span>|</span><a href="#38886427">parent</a><span>|</span><a href="#38886538">next</a><span>|</span><label class="collapse" for="c-38886739">[-]</label><label class="expand" for="c-38886739">[1 more]</label></div><br/><div class="children"><div class="content">The example given in the post is that &amp; used to be the <i>only</i> conjunction operator, before &amp;&amp; was added. Therefore, it was normal to write “if (a==b &amp; c==d)”. While this is definitely not used anymore, the historical context is useful for explaining why the precedence of &amp; is so low.</div><br/></div></div><div id="38886538" class="c"><input type="checkbox" id="c-38886538" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#38886063">root</a><span>|</span><a href="#38886427">parent</a><span>|</span><a href="#38886739">prev</a><span>|</span><a href="#38886772">next</a><span>|</span><label class="collapse" for="c-38886538">[-]</label><label class="expand" for="c-38886538">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the latter issue comes up when the user meant to say &amp;&amp; but types &amp; instead.</div><br/></div></div><div id="38886772" class="c"><input type="checkbox" id="c-38886772" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#38886063">root</a><span>|</span><a href="#38886427">parent</a><span>|</span><a href="#38886538">prev</a><span>|</span><a href="#38886396">next</a><span>|</span><label class="collapse" for="c-38886772">[-]</label><label class="expand" for="c-38886772">[1 more]</label></div><br/><div class="children"><div class="content">Off the top of my head I can’t think of anything that should bind more weakly than the equivalence.</div><br/></div></div></div></div><div id="38886396" class="c"><input type="checkbox" id="c-38886396" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#38886063">parent</a><span>|</span><a href="#38886427">prev</a><span>|</span><a href="#38886860">next</a><span>|</span><label class="collapse" for="c-38886396">[-]</label><label class="expand" for="c-38886396">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; However, the precedence of &amp; vs &amp;&amp;, or &amp; vs ||, etc is a source of problems.</i><p>Do you have any examples of this? In my experience you almost always want the bitwise operators to have a higher precedence than the logical operators, as using the result of logical operators as a bitmask makes little sense. Consider e.g. `A &amp; B &amp;&amp; C &amp; D`, which currently is equivalent to `(A &amp; B) &amp;&amp; (C &amp; D)`, but with reversed precedence would be equivalent to the almost nonsensical `A &amp; (B &amp;&amp; C) &amp; D`.<p>Now, the precedence of == with respect to &amp; and | is actually problematic (as Ritchie admits as well). Having `A == B | C` interpreted as `(A == B) | C` is almost never desirable. For extra annoyance, the shift operators do have higher precedence than comparison, so `A == B &lt;&lt; C` does what you usually want (`A == (B &lt;&lt; C)`).</div><br/><div id="38886524" class="c"><input type="checkbox" id="c-38886524" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#38886063">root</a><span>|</span><a href="#38886396">parent</a><span>|</span><a href="#38886860">next</a><span>|</span><label class="collapse" for="c-38886524">[-]</label><label class="expand" for="c-38886524">[2 more]</label></div><br/><div class="children"><div class="content">It usually comes up if the user intended to write &amp;&amp; and writes &amp; at one point in an expression, the different precedence can produce an unexpected result. But gcc and clang have warnings for that.</div><br/><div id="38886597" class="c"><input type="checkbox" id="c-38886597" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#38886063">root</a><span>|</span><a href="#38886524">parent</a><span>|</span><a href="#38886860">next</a><span>|</span><label class="collapse" for="c-38886597">[-]</label><label class="expand" for="c-38886597">[1 more]</label></div><br/><div class="children"><div class="content">The only operators with precedence between &amp; and &amp;&amp; are ^ and |, though. In e.g. the expression from the sibling comment, `a &amp; b == c`, writing &amp; or &amp;&amp; doesn&#x27;t make any difference (aside from short-circuiting). I guess it&#x27;s an issue if you write &amp; instead of &amp;&amp; in an expression that also involves a bitwise-OR (or | instead of || in an expression that also involves logical-AND), but that seems quite rare. I expect that reversing the precedence of the bitwise and logical operators would create problems a lot more often.</div><br/></div></div></div></div></div></div><div id="38886860" class="c"><input type="checkbox" id="c-38886860" checked=""/><div class="controls bullet"><span class="by">c2occnw</span><span>|</span><a href="#38886063">parent</a><span>|</span><a href="#38886396">prev</a><span>|</span><a href="#38885940">next</a><span>|</span><label class="collapse" for="c-38886860">[-]</label><label class="expand" for="c-38886860">[1 more]</label></div><br/><div class="children"><div class="content">&gt; match the traditional precedence in logical expressions<p>arithmetic expressions?</div><br/></div></div></div></div><div id="38885940" class="c"><input type="checkbox" id="c-38885940" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38886063">prev</a><span>|</span><a href="#38886386">next</a><span>|</span><label class="collapse" for="c-38885940">[-]</label><label class="expand" for="c-38885940">[3 more]</label></div><br/><div class="children"><div class="content">Somewhere, I sat down and wrote a <i>combined</i> precedence table across many languages. It was quite hairy; sometimes there&#x27;s even variation across language versions.<p>Besides `not` (which often has different precedence depending on whether it&#x27;s a keyword or a punctuator, and is a great reminder that multiple levels of pratt parsing is meaningful), `await` is the one with the most variation - in most languages, it binds tighter than binary operators, whereas in C++ it&#x27;s just barely tighter than assignment.</div><br/><div id="38886428" class="c"><input type="checkbox" id="c-38886428" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#38885940">parent</a><span>|</span><a href="#38886386">next</a><span>|</span><label class="collapse" for="c-38886428">[-]</label><label class="expand" for="c-38886428">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; `await` is the one with the most variation [..] in C++ it&#x27;s just barely tighter than assignment.</i><p>That doesn&#x27;t seem right to me. According to cppreference[1] it&#x27;s the operator with the third-highest precedence, well above assignment, which is the second-lowest.<p>[1] <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;operator_precedence" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;operator_preceden...</a></div><br/><div id="38887117" class="c"><input type="checkbox" id="c-38887117" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38885940">root</a><span>|</span><a href="#38886428">parent</a><span>|</span><a href="#38886386">next</a><span>|</span><label class="collapse" for="c-38887117">[-]</label><label class="expand" for="c-38887117">[1 more]</label></div><br/><div class="children"><div class="content">Hm, I looked at Wikipedia, and I&#x27;m pretty sure cppreference used to agree with it? Did it ever differ between drafts?<p>I&#x27;ve gotten surprisingly out of touch with the C++ world, even though it was my first serious language and I used to have the draft numbers memorized ...</div><br/></div></div></div></div></div></div><div id="38886386" class="c"><input type="checkbox" id="c-38886386" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#38885940">prev</a><span>|</span><a href="#38887871">next</a><span>|</span><label class="collapse" for="c-38886386">[-]</label><label class="expand" for="c-38886386">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately even though this was called out as a mistake in 1982, much more modern languages (e.g. C#) are still copying it.<p>As painful as breaking changes might be, they beat the alternative of dealing with a bad design indefinitely. At least in more modern languages, the type checker usually catches the mistakes caused by this design mistake.</div><br/><div id="38887003" class="c"><input type="checkbox" id="c-38887003" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#38886386">parent</a><span>|</span><a href="#38887871">next</a><span>|</span><label class="collapse" for="c-38887003">[-]</label><label class="expand" for="c-38887003">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; much more modern languages (e.g. C#) are still copying it</i><p>Fortunately Go, Rust, and Swift all chose to defy C and fix the precedence of &amp;, which I expect sets enough of a precedence (heh) for every language for the rest of human history to get it right.</div><br/></div></div></div></div><div id="38887871" class="c"><input type="checkbox" id="c-38887871" checked=""/><div class="controls bullet"><span class="by">zajio1am</span><span>|</span><a href="#38886386">prev</a><span>|</span><a href="#38885945">next</a><span>|</span><label class="collapse" for="c-38887871">[-]</label><label class="expand" for="c-38887871">[1 more]</label></div><br/><div class="children"><div class="content">For languages that have strict distinction between booleans and integers (or other non-logical types) there is the natural priority of operations:<p>1) algebraic<p>2) relational<p>3) logical<p>From this, bitwise &amp; and | are algebraic, so they should have higher priority than relationals.<p>One problem is !, which as a logical operator should have much lower priority.<p>Another problem is ==, which could be interpreted as both relational (when used on integers) or logical when used on booleans).</div><br/></div></div><div id="38885945" class="c"><input type="checkbox" id="c-38885945" checked=""/><div class="controls bullet"><span class="by">naitgacem</span><span>|</span><a href="#38887871">prev</a><span>|</span><a href="#38886316">next</a><span>|</span><label class="collapse" for="c-38885945">[-]</label><label class="expand" for="c-38885945">[1 more]</label></div><br/><div class="children"><div class="content">quite interesting. in VHDL we have a similar thing. `&lt;=` is the assignment operator, however after an if, it means &quot;less than or equal&quot;. I&#x27;ll have to check it this was inherited from Ada.<p>Edit:
on a quick glance, Ada uses the := as the assignment operator. However there seems to be only one version of the and, or, xor operators, used for both logical and bitwise.</div><br/></div></div><div id="38886316" class="c"><input type="checkbox" id="c-38886316" checked=""/><div class="controls bullet"><span class="by">hibbelig</span><span>|</span><a href="#38885945">prev</a><span>|</span><a href="#38886084">next</a><span>|</span><label class="collapse" for="c-38886316">[-]</label><label class="expand" for="c-38886316">[10 more]</label></div><br/><div class="children"><div class="content">Several comments about &amp;&amp; and ||. But where does == go?</div><br/><div id="38886502" class="c"><input type="checkbox" id="c-38886502" checked=""/><div class="controls bullet"><span class="by">laxd</span><span>|</span><a href="#38886316">parent</a><span>|</span><a href="#38888997">next</a><span>|</span><label class="collapse" for="c-38886502">[-]</label><label class="expand" for="c-38886502">[8 more]</label></div><br/><div class="children"><div class="content">Lower than either, so you can do logical (or arithmetical) expressions on both sides of ==. Has nothing to do with nature, it&#x27;s all about pragmatic decisions on how we want it.</div><br/><div id="38886527" class="c"><input type="checkbox" id="c-38886527" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#38886316">root</a><span>|</span><a href="#38886502">parent</a><span>|</span><a href="#38888997">next</a><span>|</span><label class="collapse" for="c-38886527">[-]</label><label class="expand" for="c-38886527">[7 more]</label></div><br/><div class="children"><div class="content">Wrong. In C and C++, == has a higher precedence than &amp;&amp; and ||, so `A &amp;&amp; B == C &amp;&amp; D` parses as `A &amp;&amp; (B == C) &amp;&amp; D`.</div><br/><div id="38889004" class="c"><input type="checkbox" id="c-38889004" checked=""/><div class="controls bullet"><span class="by">elromulous</span><span>|</span><a href="#38886316">root</a><span>|</span><a href="#38886527">parent</a><span>|</span><a href="#38886626">next</a><span>|</span><label class="collapse" for="c-38889004">[-]</label><label class="expand" for="c-38889004">[2 more]</label></div><br/><div class="children"><div class="content">== is really just a logical xor anyway.</div><br/><div id="38889552" class="c"><input type="checkbox" id="c-38889552" checked=""/><div class="controls bullet"><span class="by">adwn</span><span>|</span><a href="#38886316">root</a><span>|</span><a href="#38889004">parent</a><span>|</span><a href="#38886626">next</a><span>|</span><label class="collapse" for="c-38889552">[-]</label><label class="expand" for="c-38889552">[1 more]</label></div><br/><div class="children"><div class="content">You mean &quot;xnor&quot;, right? It&#x27;s the <i>!=</i> operator which corresponds to <i>xor</i>.</div><br/></div></div></div></div><div id="38886626" class="c"><input type="checkbox" id="c-38886626" checked=""/><div class="controls bullet"><span class="by">laxd</span><span>|</span><a href="#38886316">root</a><span>|</span><a href="#38886527">parent</a><span>|</span><a href="#38889004">prev</a><span>|</span><a href="#38888997">next</a><span>|</span><label class="collapse" for="c-38886626">[-]</label><label class="expand" for="c-38886626">[4 more]</label></div><br/><div class="children"><div class="content">Wrong? Did&#x27;nt ask how C does it and clearly  you did not understand my simple comment. Wtf is going on with hn? It&#x27;s turning into yet another site were kids think they seem smart by intentionally misinterpreting and bickering.</div><br/><div id="38886692" class="c"><input type="checkbox" id="c-38886692" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#38886316">root</a><span>|</span><a href="#38886626">parent</a><span>|</span><a href="#38886679">next</a><span>|</span><label class="collapse" for="c-38886692">[-]</label><label class="expand" for="c-38886692">[2 more]</label></div><br/><div class="children"><div class="content">I interpreted GP&#x27;s comment as asking what the precedence of == was (assumably in C, given that we&#x27;re discussing a post by Dennis Ritchie). On second read it could also be interpreted as asking what a good precedence for == <i>would</i> be, in which case you&#x27;re absolutely right. Sorry about that.</div><br/><div id="38886746" class="c"><input type="checkbox" id="c-38886746" checked=""/><div class="controls bullet"><span class="by">laxd</span><span>|</span><a href="#38886316">root</a><span>|</span><a href="#38886692">parent</a><span>|</span><a href="#38886679">next</a><span>|</span><label class="collapse" for="c-38886746">[-]</label><label class="expand" for="c-38886746">[1 more]</label></div><br/><div class="children"><div class="content">On second read I C your point given the context. Got triggered because I feel hn is downhill lately. Cheers!</div><br/></div></div></div></div><div id="38886679" class="c"><input type="checkbox" id="c-38886679" checked=""/><div class="controls bullet"><span class="by">pi-e-sigma</span><span>|</span><a href="#38886316">root</a><span>|</span><a href="#38886626">parent</a><span>|</span><a href="#38886692">prev</a><span>|</span><a href="#38888997">next</a><span>|</span><label class="collapse" for="c-38886679">[-]</label><label class="expand" for="c-38886679">[1 more]</label></div><br/><div class="children"><div class="content">WTF? Seriously, just check any C&#x2F;C++ reference, equality operator has higher precedence than any logical or bitwise one.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38886084" class="c"><input type="checkbox" id="c-38886084" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38886316">prev</a><span>|</span><a href="#38886280">next</a><span>|</span><label class="collapse" for="c-38886084">[-]</label><label class="expand" for="c-38886084">[10 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a niche language called Sail that has &amp; and | act as both bitwise and boolean operators. It actually works really well and isn&#x27;t confusing at all after the initial &quot;this is different&quot;. There&#x27;s no real downside because it is a modern strictly typed language unlike C.<p>On the other hand I don&#x27;t know if there&#x27;s a real upside either. It&#x27;s not very difficult to use &amp;&amp; and || and it serves as extra documentation, and everyone is used to it by now.</div><br/><div id="38886478" class="c"><input type="checkbox" id="c-38886478" checked=""/><div class="controls bullet"><span class="by">pdw</span><span>|</span><a href="#38886084">parent</a><span>|</span><a href="#38886329">next</a><span>|</span><label class="collapse" for="c-38886478">[-]</label><label class="expand" for="c-38886478">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not familiar with Sail, but the reason for separate logical operators is that you want short-circuiting behavior. For example, in:<p><pre><code>    (a != NULL) &amp;&amp; a-&gt;x
</code></pre>
You don&#x27;t want to right-hand side to be evaluated if the left-hand side is false.</div><br/><div id="38886658" class="c"><input type="checkbox" id="c-38886658" checked=""/><div class="controls bullet"><span class="by">Denvercoder9</span><span>|</span><a href="#38886084">root</a><span>|</span><a href="#38886478">parent</a><span>|</span><a href="#38889589">next</a><span>|</span><label class="collapse" for="c-38886658">[-]</label><label class="expand" for="c-38886658">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also not familiar with Sail, but you could have a single token (&quot;&amp;&amp;&quot;) behave as either a bitwise or logical AND, depending on the context: if both operands are an boolean, operate logically, if both operands are an integer, operate bitwise. The complexity lies in what you do with mixed expressions. One solution is to just forbid them. This makes bitwise expressions nested within logical expressions more verbose (you&#x27;d need to add a cast), but I&#x27;d wager that those aren&#x27;t used often in most high-level languages.</div><br/></div></div><div id="38889589" class="c"><input type="checkbox" id="c-38889589" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38886084">root</a><span>|</span><a href="#38886478">parent</a><span>|</span><a href="#38886658">prev</a><span>|</span><a href="#38886329">next</a><span>|</span><label class="collapse" for="c-38889589">[-]</label><label class="expand" for="c-38889589">[1 more]</label></div><br/><div class="children"><div class="content">It does short circuit if the parameters are booleans.</div><br/></div></div></div></div><div id="38886329" class="c"><input type="checkbox" id="c-38886329" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38886084">parent</a><span>|</span><a href="#38886478">prev</a><span>|</span><a href="#38886139">next</a><span>|</span><label class="collapse" for="c-38886329">[-]</label><label class="expand" for="c-38886329">[1 more]</label></div><br/><div class="children"><div class="content">Most langages with a passing link to C support &amp; and | on booleans (even when they have a legitimate non-integer boolean type). However they are eager which makes them generally useless.<p>^ is a lot more valuable.</div><br/></div></div><div id="38886139" class="c"><input type="checkbox" id="c-38886139" checked=""/><div class="controls bullet"><span class="by">48864w6ui</span><span>|</span><a href="#38886084">parent</a><span>|</span><a href="#38886329">prev</a><span>|</span><a href="#38886348">next</a><span>|</span><label class="collapse" for="c-38886139">[-]</label><label class="expand" for="c-38886139">[2 more]</label></div><br/><div class="children"><div class="content">Forths often use -1 as TRUE so logical and bitwise operators coincide.</div><br/><div id="38889511" class="c"><input type="checkbox" id="c-38889511" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38886084">root</a><span>|</span><a href="#38886139">parent</a><span>|</span><a href="#38886348">next</a><span>|</span><label class="collapse" for="c-38889511">[-]</label><label class="expand" for="c-38889511">[1 more]</label></div><br/><div class="children"><div class="content">So did BASIC traditionally, with no short-circuiting behavior AFAIK. At least Visual Basic has `AndAlso` and `OrElse` variants that do short-circuit though.</div><br/></div></div></div></div><div id="38886348" class="c"><input type="checkbox" id="c-38886348" checked=""/><div class="controls bullet"><span class="by">cyco130</span><span>|</span><a href="#38886084">parent</a><span>|</span><a href="#38886139">prev</a><span>|</span><a href="#38886119">next</a><span>|</span><label class="collapse" for="c-38886348">[-]</label><label class="expand" for="c-38886348">[1 more]</label></div><br/><div class="children"><div class="content">Pascal also uses the same operators for bitwise and logical and and or and they’re simply and and or.</div><br/></div></div><div id="38886119" class="c"><input type="checkbox" id="c-38886119" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#38886084">parent</a><span>|</span><a href="#38886348">prev</a><span>|</span><a href="#38886280">next</a><span>|</span><label class="collapse" for="c-38886119">[-]</label><label class="expand" for="c-38886119">[2 more]</label></div><br/><div class="children"><div class="content">Well in C-derived languages &amp;&amp; and || will short-circuit the evaluation whereas &amp; and | will not.</div><br/><div id="38886490" class="c"><input type="checkbox" id="c-38886490" checked=""/><div class="controls bullet"><span class="by">shagie</span><span>|</span><a href="#38886084">root</a><span>|</span><a href="#38886119">parent</a><span>|</span><a href="#38886280">next</a><span>|</span><label class="collapse" for="c-38886490">[-]</label><label class="expand" for="c-38886490">[1 more]</label></div><br/><div class="children"><div class="content">Aside, In Oral Tradition in Software Engineering by Bryan Cantrill, he talks a bit about the lack of logical xor in C.  <a href="https:&#x2F;&#x2F;youtu.be&#x2F;4PaWFYm0kEw?t=2236&amp;si=MZPbopZPQtnnT-Tb" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;4PaWFYm0kEw?t=2236&amp;si=MZPbopZPQtnnT-Tb</a></div><br/></div></div></div></div></div></div><div id="38886280" class="c"><input type="checkbox" id="c-38886280" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#38886084">prev</a><span>|</span><label class="collapse" for="c-38886280">[-]</label><label class="expand" for="c-38886280">[3 more]</label></div><br/><div class="children"><div class="content">this is why lisp is beautiful</div><br/><div id="38886463" class="c"><input type="checkbox" id="c-38886463" checked=""/><div class="controls bullet"><span class="by">artsi0m</span><span>|</span><a href="#38886280">parent</a><span>|</span><a href="#38886636">next</a><span>|</span><label class="collapse" for="c-38886463">[-]</label><label class="expand" for="c-38886463">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. But lisp is much more than prefix notation.<p>Different notations like revers polish notation also easier to parse. You can evaluate RPN only using stack.<p>Also, recently I learned about thread-last macro in emacs lisp. Using it you can evaluate forms from left to right, and using it you can write less parenthesis.</div><br/></div></div></div></div></div></div></div></div></div></body></html>