<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716627665238" as="style"/><link rel="stylesheet" href="styles.css?v=1716627665238"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ldpreload.com/blog/signalfd-is-useless">Signalfd Is Useless (2015)</a> <span class="domain">(<a href="https://ldpreload.com">ldpreload.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>14 comments</span></div><br/><div><div id="40473257" class="c"><input type="checkbox" id="c-40473257" checked=""/><div class="controls bullet"><span class="by">t8sr</span><span>|</span><a href="#40473200">next</a><span>|</span><label class="collapse" for="c-40473257">[-]</label><label class="expand" for="c-40473257">[1 more]</label></div><br/><div class="children"><div class="content">The author is unhappy with how signals work, and proposes some really wonky ways to get the behavior he thinks is correct. But for a programmer, it&#x27;s a lot easier to just do things the way designers of signals intended.<p>For example, multiple SIGCHLD coalesce, so you are supposed to call waitpid in a loop:<p><pre><code>  int status;
  while((pid_t child = waitpid(-1, &amp;status, WHOHANG)) &gt; 0) { &#x2F;&#x2F; handle zombie
</code></pre>
This API is mature and obvious problems like the author points out have already been solved before. The author seems to reject the established practice on purely aesthetic grounds, which is a... choice. But not one you should make, if you want your life to be easy.</div><br/></div></div><div id="40473200" class="c"><input type="checkbox" id="c-40473200" checked=""/><div class="controls bullet"><span class="by">shachaf</span><span>|</span><a href="#40473257">prev</a><span>|</span><a href="#40473496">next</a><span>|</span><label class="collapse" for="c-40473200">[-]</label><label class="expand" for="c-40473200">[2 more]</label></div><br/><div class="children"><div class="content">I use signalfd when I can, and this argument doesn&#x27;t make much sense to me. The main goal of most signals you&#x27;d use it with -- like SIGCHLD&#x2F;SIGPIPE -- is to wake you up and tell you that something happened, not to give you all the information. If you get a SIGCHLD, you can call wait() to get information. If you get SIGPIPE you can poll your file descriptors (though you might be doing that anyway so the signal isn&#x27;t very useful). For the purpose of waking you up, coalescing isn&#x27;t a problem -- only missed notifications are a problem, and signalfd handles those correctly.<p>Of course, for &quot;real&quot; signals that you must handle synchronously, like SIGSEGV, signalfd is less useful and makes less sense (and arguably something closer to Windows&#x27;s SEH might make more sense). It&#x27;s an odd historical artifact of Unix that SIGCHLD and SIGSEGV use the same mechanism.</div><br/><div id="40473304" class="c"><input type="checkbox" id="c-40473304" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#40473200">parent</a><span>|</span><a href="#40473496">next</a><span>|</span><label class="collapse" for="c-40473304">[-]</label><label class="expand" for="c-40473304">[1 more]</label></div><br/><div class="children"><div class="content">The point of the article is that signald could and probably should be more useful than it is.<p>Even if you don&#x27;t worry about coalescing, it would be a lot more useful if you didn&#x27;t have to separately set the signal mask, and reset it for child processes.<p>&gt; If you get a SIGCHLD, you can call wait() to get information<p>But you don&#x27;t know how many signals actually happened, so what you actually need to do is call waitpid in non-blocking mode in a loop until you don&#x27;t get an actual pid back. Or poll pidfd file descriptors.</div><br/></div></div></div></div><div id="40473496" class="c"><input type="checkbox" id="c-40473496" checked=""/><div class="controls bullet"><span class="by">koverstreet</span><span>|</span><a href="#40473200">prev</a><span>|</span><a href="#40473322">next</a><span>|</span><label class="collapse" for="c-40473496">[-]</label><label class="expand" for="c-40473496">[1 more]</label></div><br/><div class="children"><div class="content">Everything about signals makes more sense if you understand that they&#x27;re modeled on hardware interrupts. They&#x27;re the same mechanism, but for userspace code instead of kernel code. Preempting and taking over the stack, coalescing (without which a flood generated faster than they could be consumed could consume unbounded memory) - all the same upsides and downsides. IOW, they&#x27;re not message passing.<p>(Which makes sense, considering they date from the 70s (research UNIX era) - that&#x27;s not much later than the first modern code for handling hardware interrupts, which date roughly circa the Apollo program.)<p>And similar workarounds for those limitations: threaded interrupts (although in practice, we just punt to workqueue context in the kernel) vs. sigaltstack or signalfd with a dedicated thread.<p>Not as much code has to deal with them directly anymore; they&#x27;re really only used in the interfaces that date way back, but the concept of edge (and vs. level) triggered interrupts is still worth understanding.</div><br/></div></div><div id="40473322" class="c"><input type="checkbox" id="c-40473322" checked=""/><div class="controls bullet"><span class="by">JohnMakin</span><span>|</span><a href="#40473496">prev</a><span>|</span><a href="#40473224">next</a><span>|</span><label class="collapse" for="c-40473322">[-]</label><label class="expand" for="c-40473322">[2 more]</label></div><br/><div class="children"><div class="content">While my C is familiar yet rusty enough to raise an eyebrow at this post and not elaborate better than the other comments in this thread - stuff like this I feel is a sign of a mentality I often see in software that goes roughly like “this piece of software doesn’t do what I think it should do therefore it is bad.”<p>I used to think like this but find it more valuable to think more in the mindset “this may have been useful to <i>somebody</i> or else it wouldn’t have been written this way” (which really falls apart with enterprise software sometimes I am aware) which allows me to think more critically about what I am implementing.</div><br/><div id="40473429" class="c"><input type="checkbox" id="c-40473429" checked=""/><div class="controls bullet"><span class="by">ZiiS</span><span>|</span><a href="#40473322">parent</a><span>|</span><a href="#40473224">next</a><span>|</span><label class="collapse" for="c-40473429">[-]</label><label class="expand" for="c-40473429">[1 more]</label></div><br/><div class="children"><div class="content">In the current world it is also more valuable to read a title like &quot;Signalfd Is Useless&quot; as &quot;A usecase where Signalfd could be made more useful&quot;</div><br/></div></div></div></div><div id="40473224" class="c"><input type="checkbox" id="c-40473224" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#40473322">prev</a><span>|</span><a href="#40473054">next</a><span>|</span><label class="collapse" for="c-40473224">[-]</label><label class="expand" for="c-40473224">[3 more]</label></div><br/><div class="children"><div class="content">Pretentious title with little substance to justify the claim. The inherited signal disposition mask with the blocked signals can be restored in a forked child process, before an exec. Because it makes a shell-spawning function like system() even less desirable, doesn’t render it “useless”.</div><br/><div id="40473309" class="c"><input type="checkbox" id="c-40473309" checked=""/><div class="controls bullet"><span class="by">lmz</span><span>|</span><a href="#40473224">parent</a><span>|</span><a href="#40473054">next</a><span>|</span><label class="collapse" for="c-40473309">[-]</label><label class="expand" for="c-40473309">[2 more]</label></div><br/><div class="children"><div class="content">The whole signal mask &#x2F; handler thing (and inherited FDs to a certain extent) certainly make a function to &quot;just launch another program&quot; harder to write.</div><br/><div id="40473397" class="c"><input type="checkbox" id="c-40473397" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#40473224">root</a><span>|</span><a href="#40473309">parent</a><span>|</span><a href="#40473054">next</a><span>|</span><label class="collapse" for="c-40473397">[-]</label><label class="expand" for="c-40473397">[1 more]</label></div><br/><div class="children"><div class="content">It’s an essential part of the Unix process model. The whole design feels dated and centered around shells and terminals.<p>A more productive endeavour would be to propose a new design without all these warts. Not cherry-picking and whining about random aspects, without seeing the big picture.</div><br/></div></div></div></div></div></div><div id="40473054" class="c"><input type="checkbox" id="c-40473054" checked=""/><div class="controls bullet"><span class="by">Sniffnoy</span><span>|</span><a href="#40473224">prev</a><span>|</span><a href="#40473223">next</a><span>|</span><label class="collapse" for="c-40473054">[-]</label><label class="expand" for="c-40473054">[1 more]</label></div><br/><div class="children"><div class="content">(2015)</div><br/></div></div><div id="40473223" class="c"><input type="checkbox" id="c-40473223" checked=""/><div class="controls bullet"><span class="by">mindslight</span><span>|</span><a href="#40473054">prev</a><span>|</span><a href="#40473154">next</a><span>|</span><label class="collapse" for="c-40473223">[-]</label><label class="expand" for="c-40473223">[1 more]</label></div><br/><div class="children"><div class="content">Most of this article seems like mere unfamiliarity with how interrupts are generally processed. The point is you&#x27;re just getting a flag indicating that you need to poll. You do the least possible in the interrupt handler so the rest of your program is disrupted as little as possible. The advantages of this aren&#x27;t so super necessary when you&#x27;re already event driven using select() and its descendants. But it&#x27;s also not terribly hard to work into that paradigm, awkwardness of the loopback fd pattern in directly-written-C not withstanding.<p>System calls returning early with EINTR is the exact example from <i>Worse is Better</i>, so that&#x27;s been been debated to death.<p>And FWIW it seems like SA_SIGINFO itself is more of the problem, especially if (when?) there isn&#x27;t a good way to poll that information elsewhere.</div><br/></div></div><div id="40473154" class="c"><input type="checkbox" id="c-40473154" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40473223">prev</a><span>|</span><a href="#40473630">next</a><span>|</span><label class="collapse" for="c-40473154">[-]</label><label class="expand" for="c-40473154">[1 more]</label></div><br/><div class="children"><div class="content">I fail to see how creating a new thread which waits forever and ensuring it is the only one which receives signals (by blocking them in all other threads, which requires unblocking them when starting child processes just like with signals) is any better than signalfd. Also now your program is multithreaded. Good luck.</div><br/></div></div></div></div></div></div></div></body></html>