<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724835687388" as="style"/><link rel="stylesheet" href="styles.css?v=1724835687388"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://josephg.com/blog/crdts-go-brrr/">Faster CRDTs (2021)</a> <span class="domain">(<a href="https://josephg.com">josephg.com</a>)</span></div><div class="subtext"><span>bpierre</span> | <span>81 comments</span></div><br/><div><div id="41374827" class="c"><input type="checkbox" id="c-41374827" checked=""/><div class="controls bullet"><span class="by">pjz</span><span>|</span><a href="#41373616">next</a><span>|</span><label class="collapse" for="c-41374827">[-]</label><label class="expand" for="c-41374827">[3 more]</label></div><br/><div class="children"><div class="content">&gt; And why 32 entries? I ran this benchmark with a bunch of different bucket sizes and 32 worked well. I have no idea why that worked out to be the best.<p>If you were using 2-byte ints, this is likely because cache lines are 64 bytes, so 32 entries would be exactly one cache line, letting each cache line hold an entire bucket, thus reducing those expensive main memory transfers.</div><br/><div id="41375060" class="c"><input type="checkbox" id="c-41375060" checked=""/><div class="controls bullet"><span class="by">VHRanger</span><span>|</span><a href="#41374827">parent</a><span>|</span><a href="#41373616">next</a><span>|</span><label class="collapse" for="c-41375060">[-]</label><label class="expand" for="c-41375060">[2 more]</label></div><br/><div class="children"><div class="content">Yeah when benchmarking by batch sizes it&#x27;s common to see huge jumps associated with the memory hierarchy:<p>- word size (64bits)
- cache alingment fetch size (generally 64bytes as mentioned above)
- OS page size (4-16kb)
- L1 size (~80kb&#x2F;core)
- L2 (low megabyte number)</div><br/><div id="41375863" class="c"><input type="checkbox" id="c-41375863" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41374827">root</a><span>|</span><a href="#41375060">parent</a><span>|</span><a href="#41373616">next</a><span>|</span><label class="collapse" for="c-41375863">[-]</label><label class="expand" for="c-41375863">[1 more]</label></div><br/><div class="children"><div class="content">With lots of bizarre artifacts if you don’t force alignment.</div><br/></div></div></div></div></div></div><div id="41373616" class="c"><input type="checkbox" id="c-41373616" checked=""/><div class="controls bullet"><span class="by">jzelinskie</span><span>|</span><a href="#41374827">prev</a><span>|</span><a href="#41376658">next</a><span>|</span><label class="collapse" for="c-41373616">[-]</label><label class="expand" for="c-41373616">[42 more]</label></div><br/><div class="children"><div class="content">What are some real world apps using CRDTs that have really good experiences?<p>IIRC Notion was supposed to be one of them but realistically taking notes with two people in Notion is almost unusable compared to Google Docs.</div><br/><div id="41374429" class="c"><input type="checkbox" id="c-41374429" checked=""/><div class="controls bullet"><span class="by">jdvh</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41374248">next</a><span>|</span><label class="collapse" for="c-41374429">[-]</label><label class="expand" for="c-41374429">[2 more]</label></div><br/><div class="children"><div class="content">Thymer[1] uses CRDTs for everything. It&#x27;s an IDE for tasks and planning. It&#x27;s a multiplayer app, end-to-end encrypted and offline first, optionally self-hosted, and an entire workspace is a single graph. So CRDTs were the logical choice.<p>All operations in Thymer get reduced to a handful of CRDT transformations. It doesn&#x27;t matter whether you are moving or copying text, changing &quot;frontmatter&quot; attributes, dragging cards, uploading files, or adding tags. It&#x27;s all done with the same handful of CRDT operations. Although this was a lot of extra work up front (we&#x27;re not using any libraries) the benefits make it totally worth it. When your application state is a single graph you can move text between pages, link between pages (with backlinks), have transclusions, and do all sorts of cool stuff without having to worry about synchronization. CRDTs guarantee that all clients converge to the same state. And because CRDTs are by their nature append-only you get point-in-time versioning for free! We did end up having to make a couple of compromises for performance, though. Version history is not available offline (too much data) and in some cases we resort to last-writer-wins conflict resolution. On balance I think CRDTs are very much worth it, especially if you design an app with CRDTs in mind from day one. I probably wouldn&#x27;t use CRDTs if I had to retrofit multiplayer in a more conventional AJAX app. Mutations in CRDTs are first applied optimistically, and then when the authoritative sequence of events is determined all clients need to revert their state to the last shared state and then re-apply all events in the correct order (thereby guaranteeing that all clients end up in the same state). Sometimes your app might need to revert and re-apply days worth of changes if you&#x27;ve been offline for a while. This all happens behind the scenes and the user doesn&#x27;t know how many tree transformations are happening in the background but I guess my point is that CRDTs affect the design of the entire application. Most apps that are popular today were designed back when CRDT transformations were not yet well understood.<p>[1] <a href="https:&#x2F;&#x2F;thymer.com" rel="nofollow">https:&#x2F;&#x2F;thymer.com</a> (almost ready for beta)</div><br/><div id="41374547" class="c"><input type="checkbox" id="c-41374547" checked=""/><div class="controls bullet"><span class="by">pnw</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374429">parent</a><span>|</span><a href="#41374248">next</a><span>|</span><label class="collapse" for="c-41374547">[-]</label><label class="expand" for="c-41374547">[1 more]</label></div><br/><div class="children"><div class="content">This looks really cool, signed up for the beta!</div><br/></div></div></div></div><div id="41374248" class="c"><input type="checkbox" id="c-41374248" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41374429">prev</a><span>|</span><a href="#41376804">next</a><span>|</span><label class="collapse" for="c-41374248">[-]</label><label class="expand" for="c-41374248">[3 more]</label></div><br/><div class="children"><div class="content">Today Notion is a last-write-wins system with limited intention-preserving operations for list data (like block ordering). Text is last-write-wins, each block text or property is a last-write-wins register. We&#x27;re working on a new CRDT format for block text.</div><br/><div id="41374843" class="c"><input type="checkbox" id="c-41374843" checked=""/><div class="controls bullet"><span class="by">felipefar</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374248">parent</a><span>|</span><a href="#41376804">next</a><span>|</span><label class="collapse" for="c-41374843">[-]</label><label class="expand" for="c-41374843">[2 more]</label></div><br/><div class="children"><div class="content">Do you use last-write-wins using the received order of operations on the server or using a logical clock?<p>I believe that for Notion the collaboration use case is more important than async editing, so a CRDT makes more sense, but for text editing apps that favor asynchronous collaboration maybe explicit conflict resolution is more reasonable.</div><br/><div id="41374912" class="c"><input type="checkbox" id="c-41374912" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374843">parent</a><span>|</span><a href="#41376804">next</a><span>|</span><label class="collapse" for="c-41374912">[-]</label><label class="expand" for="c-41374912">[1 more]</label></div><br/><div class="children"><div class="content">No clocks on the write side</div><br/></div></div></div></div></div></div><div id="41376804" class="c"><input type="checkbox" id="c-41376804" checked=""/><div class="controls bullet"><span class="by">yazaddaruvala</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41374248">prev</a><span>|</span><a href="#41374385">next</a><span>|</span><label class="collapse" for="c-41376804">[-]</label><label class="expand" for="c-41376804">[1 more]</label></div><br/><div class="children"><div class="content">Thinking about it more, I’ll provide another that people will not immediately appreciate.<p>Any and all networked video games with some form of rollback or correction. Best effort with a fallback to Rollback might actually be the “best” ie ergonomic experience for CRDTs that are most widely used.<p>Again, not academically a CRDT because technically game state is not perfectly replicated to every client. Each client only gets partial game state.<p>Additionally, game clients require low latency syncing, which could academically be considered “coordinating”. Even tho the client actually accepts and renders the input’s results locally probabilistically before any conflict resolution &#x2F; rollback is returned to the client for correction.<p>Again people are likely going to be pedantic but with three post now, I’d like to hope, people might see the common theme:<p>The most popular, highly ergonomic, best implementations of CRDTs actually break the academic rules of CRDTs.<p>This is a relatively typical trap of an overly academic mental model. Most real world algorithms and data types are actually more creative than their academic “rulesets”. eg Timsort.<p>Especially if you’re building a product for actual use (as apposed to for review in a paper), then don’t fall into the over engineered&#x2F;academic trap. Be creative, learn the academic rules, then intentionally break those rules, build what actually adds value and make it ergonomic rather than try to perfectly implement a concept that academics defined so stringently it’s only useful for other academics.</div><br/></div></div><div id="41374385" class="c"><input type="checkbox" id="c-41374385" checked=""/><div class="controls bullet"><span class="by">minkles</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41376804">prev</a><span>|</span><a href="#41374556">next</a><span>|</span><label class="collapse" for="c-41374385">[-]</label><label class="expand" for="c-41374385">[3 more]</label></div><br/><div class="children"><div class="content">Most of iCloud&#x27;s services use CRDTs underneath I believe. That includes Notes, Reminders and possibly Photos as well. FoundationDB is some of the backend as well. I was told this by a drunken former Apple SRE in a bar :)</div><br/><div id="41374821" class="c"><input type="checkbox" id="c-41374821" checked=""/><div class="controls bullet"><span class="by">mweidner</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374385">parent</a><span>|</span><a href="#41375619">next</a><span>|</span><label class="collapse" for="c-41374821">[-]</label><label class="expand" for="c-41374821">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, Apple Notes has a reasonably sophisticated CRDT, including support for tables: <a href="https:&#x2F;&#x2F;github.com&#x2F;dunhamsteve&#x2F;notesutils&#x2F;blob&#x2F;master&#x2F;notes.md">https:&#x2F;&#x2F;github.com&#x2F;dunhamsteve&#x2F;notesutils&#x2F;blob&#x2F;master&#x2F;notes....</a></div><br/></div></div><div id="41375619" class="c"><input type="checkbox" id="c-41375619" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374385">parent</a><span>|</span><a href="#41374821">prev</a><span>|</span><a href="#41374556">next</a><span>|</span><label class="collapse" for="c-41375619">[-]</label><label class="expand" for="c-41375619">[1 more]</label></div><br/><div class="children"><div class="content">one would hope that is what they are using it for, since they bought one of the best foundations for a db to exist:
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9418255">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9418255</a></div><br/></div></div></div></div><div id="41374556" class="c"><input type="checkbox" id="c-41374556" checked=""/><div class="controls bullet"><span class="by">ndr</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41374385">prev</a><span>|</span><a href="#41373910">next</a><span>|</span><label class="collapse" for="c-41374556">[-]</label><label class="expand" for="c-41374556">[1 more]</label></div><br/><div class="children"><div class="content">Linear: <a href="https:&#x2F;&#x2F;linear.app&#x2F;" rel="nofollow">https:&#x2F;&#x2F;linear.app&#x2F;</a><p>See their Local First Conf talk: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;VLgmjzERT08" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;VLgmjzERT08</a></div><br/></div></div><div id="41373910" class="c"><input type="checkbox" id="c-41373910" checked=""/><div class="controls bullet"><span class="by">iced_beverage</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41374556">prev</a><span>|</span><a href="#41376829">next</a><span>|</span><label class="collapse" for="c-41373910">[-]</label><label class="expand" for="c-41373910">[1 more]</label></div><br/><div class="children"><div class="content">The code editor Zed uses them for collaboration. It was discussed in a Developer Voices episode - <a href="https:&#x2F;&#x2F;youtu.be&#x2F;fV4aPy1bmY0?si=0O6fCmK8NziFf9Hi" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;fV4aPy1bmY0?si=0O6fCmK8NziFf9Hi</a></div><br/></div></div><div id="41376829" class="c"><input type="checkbox" id="c-41376829" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41373910">prev</a><span>|</span><a href="#41376029">next</a><span>|</span><label class="collapse" for="c-41376829">[-]</label><label class="expand" for="c-41376829">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a CRDT, it&#x27;s LWW at the cell level, transmitted pretty much a typing speed so conflicts are low</div><br/></div></div><div id="41376029" class="c"><input type="checkbox" id="c-41376029" checked=""/><div class="controls bullet"><span class="by">leonseled</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41376829">prev</a><span>|</span><a href="#41373765">next</a><span>|</span><label class="collapse" for="c-41376029">[-]</label><label class="expand" for="c-41376029">[1 more]</label></div><br/><div class="children"><div class="content">Muse. I love how I can write something on my iPad with the pencil and see the strokes real time on the mac app.<p>I then switch to my mac to drag images and screenshots and see it synced to the ipad in real time. Then i annotate w the apple pencil.<p>One of the best “whiteboarding” tools I’ve used.</div><br/></div></div><div id="41373765" class="c"><input type="checkbox" id="c-41373765" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41376029">prev</a><span>|</span><a href="#41375382">next</a><span>|</span><label class="collapse" for="c-41373765">[-]</label><label class="expand" for="c-41373765">[1 more]</label></div><br/><div class="children"><div class="content">Figma uses a CRDT-ish approach. I&#x27;m working on one at the moment, but it&#x27;ll be a while before it&#x27;s publicly available. At the moment, I&#x27;m using Loro: <a href="https:&#x2F;&#x2F;loro.dev" rel="nofollow">https:&#x2F;&#x2F;loro.dev</a></div><br/></div></div><div id="41375382" class="c"><input type="checkbox" id="c-41375382" checked=""/><div class="controls bullet"><span class="by">yazaddaruvala</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41373765">prev</a><span>|</span><a href="#41373769">next</a><span>|</span><label class="collapse" for="c-41375382">[-]</label><label class="expand" for="c-41375382">[5 more]</label></div><br/><div class="children"><div class="content">&gt; What are some real world apps using CRDTs that have really good experiences?<p>Since people loved my other hot take :)<p>I suppose &quot;good experience&quot; can be subjective, but Blockchains are also in practice a distributed trust-less CRDT that is used by a LOT of people.<p>- With redundant validation, across more than 2 nodes, used to solve for conflict resolution.<p>- and proof of work&#x2F;stake used to solve for distributed trust.<p>Again, academically, maybe not a CRDT because they will not &quot;always converge&quot;. Hard forks can happen. However, pragmatically, Blockchains are a CRDT.</div><br/><div id="41376774" class="c"><input type="checkbox" id="c-41376774" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41375382">parent</a><span>|</span><a href="#41376343">next</a><span>|</span><label class="collapse" for="c-41376774">[-]</label><label class="expand" for="c-41376774">[1 more]</label></div><br/><div class="children"><div class="content">Author here<p>&gt; Again, academically, maybe not a CRDT because they will not &quot;always converge&quot;. Hard forks can happen. However, pragmatically, Blockchains are a CRDT.<p>The term &quot;CRDT&quot; is an academic term. So the academic definition matters. They&#x27;re not &quot;pragmatically&quot; a CRDT because that&#x27;s simply not how we decide what is and isn&#x27;t a CRDT.<p>The proper definition is any algorithm, replicated across multiple computers in a network with these 3 properties (at least according to wikipedia):<p>1. The application can update any replica independently, concurrently and without coordinating with other replicas.
2. An algorithm (itself part of the data type) automatically resolves any inconsistencies that might occur.
3. Although replicas may have different state at any particular point in time, they are guaranteed to eventually converge.<p>Blockchains meet criteria 2 and 3. But in my opinion, property 1 is too much of a stretch.<p>In a blockchain, you can&#x27;t meaningfully update your local replica independently and without coordination. Sure - you can add local transactions. But blockchains care about global consensus, not the local state. A transaction in a blockchain isn&#x27;t generally considered to have happened until its been included in a block &amp; witnessed throughout the network.<p>This is in stark contrast to, say, Apple Notes (which uses a CRDT internally). In Notes, I can edit a note on my phone and the note changes. There&#x27;s no consensus required before my new edits are considered to be legitimate.</div><br/></div></div><div id="41376343" class="c"><input type="checkbox" id="c-41376343" checked=""/><div class="controls bullet"><span class="by">plesiv</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41375382">parent</a><span>|</span><a href="#41376774">prev</a><span>|</span><a href="#41375401">next</a><span>|</span><label class="collapse" for="c-41376343">[-]</label><label class="expand" for="c-41376343">[1 more]</label></div><br/><div class="children"><div class="content">The cat runs, eats and has fur. The cat is a dog.</div><br/></div></div><div id="41375401" class="c"><input type="checkbox" id="c-41375401" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41375382">parent</a><span>|</span><a href="#41376343">prev</a><span>|</span><a href="#41373769">next</a><span>|</span><label class="collapse" for="c-41375401">[-]</label><label class="expand" for="c-41375401">[2 more]</label></div><br/><div class="children"><div class="content">I think blockchains are overkill because they&#x27;re trying to get a global consensus about every transaction in the world, which is very expensive (with electricity, stake etc.). They&#x27;re trying to solve the additional problem of preventing &quot;forking&quot; of a history. Whereas if you allow forks then CRDTs are more lightweight.<p>Internet Computer canisters, Merkle DAGs (like IOTA), Hashgraphs and Holochains are probably a better architecture than Blockchains.<p>Having said that, I think Merkle Trees are the future, for minimizing the amount of sync. They let you see exactly what changed, and so on.<p><a href="https:&#x2F;&#x2F;joelgustafson.com&#x2F;posts&#x2F;2023-05-04&#x2F;merklizing-the-key-value-store-for-fun-and-profit" rel="nofollow">https:&#x2F;&#x2F;joelgustafson.com&#x2F;posts&#x2F;2023-05-04&#x2F;merklizing-the-ke...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;canvasxyz&#x2F;okra-js">https:&#x2F;&#x2F;github.com&#x2F;canvasxyz&#x2F;okra-js</a><p>There&#x27;s already great software done by Dat (later called Hypercore, now called Holepunch) that has an append-only log based on the SLEEP protocol. That&#x27;s essentially all you need, in my opinion. They&#x27;ve built everything from key-value databases (hyperbee) to full-scale file systems (hyperdrive) on top of it. Beaker browser has been built on top of it.<p>I mean, merging state-based CRDTs is cool, but you may as well just use operation-based CRDTs with something like Hypercore or the older PouchDB.</div><br/><div id="41375592" class="c"><input type="checkbox" id="c-41375592" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41375401">parent</a><span>|</span><a href="#41373769">next</a><span>|</span><label class="collapse" for="c-41375592">[-]</label><label class="expand" for="c-41375592">[1 more]</label></div><br/><div class="children"><div class="content">If anyone is familiar, I would like to ask:<p>How does Okra compare to something like Quadrable: <a href="https:&#x2F;&#x2F;github.com&#x2F;hoytech&#x2F;quadrable-solidity">https:&#x2F;&#x2F;github.com&#x2F;hoytech&#x2F;quadrable-solidity</a></div><br/></div></div></div></div></div></div><div id="41373769" class="c"><input type="checkbox" id="c-41373769" checked=""/><div class="controls bullet"><span class="by">spacecadet</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41375382">prev</a><span>|</span><a href="#41373938">next</a><span>|</span><label class="collapse" for="c-41373769">[-]</label><label class="expand" for="c-41373769">[1 more]</label></div><br/><div class="children"><div class="content">Not a public high bandwidth example, but a consulting team I was on implemented CRDTs in a private mobile app used for a compliance documentation use case. More of a precaution, the actual number of end-users editing a record at any given time is expected to be 1, but while reviewing their system, we found that the clients system can support multiple and sometimes their employees don&#x27;t communicate&#x2F;follow procedures. We first tried to convince them to make changes on their end, but their development team straight up refused.</div><br/></div></div><div id="41373938" class="c"><input type="checkbox" id="c-41373938" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41373769">prev</a><span>|</span><a href="#41375700">next</a><span>|</span><label class="collapse" for="c-41373938">[-]</label><label class="expand" for="c-41373938">[4 more]</label></div><br/><div class="children"><div class="content">Doesn’t google docs use crdt?</div><br/><div id="41373957" class="c"><input type="checkbox" id="c-41373957" checked=""/><div class="controls bullet"><span class="by">surfmike</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41373938">parent</a><span>|</span><a href="#41375700">next</a><span>|</span><label class="collapse" for="c-41373957">[-]</label><label class="expand" for="c-41373957">[3 more]</label></div><br/><div class="children"><div class="content">I believe it uses Operational Transforms</div><br/><div id="41375467" class="c"><input type="checkbox" id="c-41375467" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41373957">parent</a><span>|</span><a href="#41375700">next</a><span>|</span><label class="collapse" for="c-41375467">[-]</label><label class="expand" for="c-41375467">[2 more]</label></div><br/><div class="children"><div class="content">OT vs CRDT: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;26694359&#x2F;differences-between-ot-and-crdt" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;26694359&#x2F;differences-bet...</a><p>In my opinion, the problem with CRDTs is they don&#x27;t really have a great concept of access control and enforcing rules. Since everyone&#x27;s a peer, you can only do things like &quot;last write wins&quot; etc.<p>In a video game, for instance, I could disconnect and then spam the peers with tons of updates, claiming they were all done in the past, and they&#x27;d have to accept them all.<p>PouchDB and IPFS lets nodes sort of make decisions about who to replicate from, but it&#x27;s rudimentary: <a href="https:&#x2F;&#x2F;pouchdb.com&#x2F;guides&#x2F;replication.html" rel="nofollow">https:&#x2F;&#x2F;pouchdb.com&#x2F;guides&#x2F;replication.html</a><p>Hypercore is much better because it is an append-only log where every chunk is signed: <a href="https:&#x2F;&#x2F;docs.pears.com&#x2F;how-tos&#x2F;replicate-and-persist-with-hypercore" rel="nofollow">https:&#x2F;&#x2F;docs.pears.com&#x2F;how-tos&#x2F;replicate-and-persist-with-hy...</a><p>However, it&#x27;s still not enough, because hypercore only supports a single-writer. There has been some work on hypercore multiwriter in the last few years (which I followed with interest) but none of it is Byzantine fault-tolerant, and it was ultimately dropped. In fact, if you leak the key, anyone you can probably corrupt a hypercore rather easily and prevent it from making forward progress.<p>This is why at the end of the day, you still go back to the ideas of preventing forks. The problem is that blockchains do it via global consensus, which is hugely wasteful and overkill. But you do need something to run essentially &quot;smart contracts&quot;, i.e. software that runs &quot;in the cloud&quot; which is infeasible to tamper with. Like Internet Computer&#x27;s canisters for example... <a href="https:&#x2F;&#x2F;internetcomputer.org&#x2F;docs&#x2F;current&#x2F;concepts&#x2F;canisters-code" rel="nofollow">https:&#x2F;&#x2F;internetcomputer.org&#x2F;docs&#x2F;current&#x2F;concepts&#x2F;canisters...</a><p>Ultimately, these architectures will end up being far more reliable and resilient than the Web, because the Web is based around hosting and location (&quot;where&quot; something is) rather than content (&quot;what&quot; something is). IPFS and cids are a step towards that future, but other projects like ICP and Freenet are leapfrogging them... they have smart contracts based around WebAssembly.<p>Incidentally, I interviewed Ian Clarke about the original freenet, and he recently announced the new freenet, which is based around webassembly, and the swarming is done using &quot;small-world topology&quot; instead of kademlia DHT: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yBtyNIqZios" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=yBtyNIqZios</a><p>(Here is my interview with him a couple years ago: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=JWrRqUkJpMQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=JWrRqUkJpMQ</a>)</div><br/><div id="41376849" class="c"><input type="checkbox" id="c-41376849" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41375467">parent</a><span>|</span><a href="#41375700">next</a><span>|</span><label class="collapse" for="c-41376849">[-]</label><label class="expand" for="c-41376849">[1 more]</label></div><br/><div class="children"><div class="content">Author here. I had a chat with PHV about this (a principle author of the Local First Software paper).<p>He sees the access control problem like scribbling on your copy of the US Constitution. If you print out the constitution, you can make whatever marks on the page that you want. But nobody else is obliged to copy your changes.<p>Its the same as Git in that sense. I can fork a repository and submit pull requests. But I can only push my changes upstream if I have write access to the repository.<p>If you need a single authoritative &quot;truth&quot; - like a video game - then you can still do that by having one peer act as a hub and it can decide which edits to merge &amp; broadcast. If a video game used a CRDT, you might still want a server - and that server might still want to reject any incoming edits that are older than a few seconds.<p>But I generally agree - I don&#x27;t think CRDTs add a lot of value in multiplayer video games. CRDTs make sense when a local user wants to edit some data, and those changes are useful locally even if you never share them with other peers. So, creative work is the use case I think about the most - like video editing, writing, design, programming, and so on.<p>In the video game industry, I think the best use for CRDTs would be to make Unity &#x2F; Unreal &#x2F; etc collaborative spaces.</div><br/></div></div></div></div></div></div></div></div><div id="41375700" class="c"><input type="checkbox" id="c-41375700" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41373938">prev</a><span>|</span><a href="#41373866">next</a><span>|</span><label class="collapse" for="c-41375700">[-]</label><label class="expand" for="c-41375700">[1 more]</label></div><br/><div class="children"><div class="content">I think a lot of things. CRDTs predate the term &quot;CRDT&quot;, they seem to be a mathematical construct&#x2F;pattern found in the wild, that smart people codified and formalised.<p>IME CRDTs just lay out the rules you need to follow for syncing eventually consistent nodes properly, ie without weird surprises or data loss.<p>As for concrete examples:<p>- in the famous Amazon Dynamo Whitepaper, they perfectly describe a CRDT in section 4.4. 
 (<a href="https:&#x2F;&#x2F;www.allthingsdistributed.com&#x2F;files&#x2F;amazon-dynamo-sosp2007.pdf" rel="nofollow">https:&#x2F;&#x2F;www.allthingsdistributed.com&#x2F;files&#x2F;amazon-dynamo-sos...</a>), though I don&#x27;t think this made it to modern Dynamo DB<p>- I believe CouchDB follows all the CRDT laws<p>- TomTom uses them<p>I think the TL:DR is if you&#x27;re going to sync two data stores that can be written to without coordination, learn the CRDT laws and make sure you follow them. They&#x27;re fairly simple mathematical properties at the end of the day.</div><br/></div></div><div id="41373866" class="c"><input type="checkbox" id="c-41373866" checked=""/><div class="controls bullet"><span class="by">yazaddaruvala</span><span>|</span><a href="#41373616">parent</a><span>|</span><a href="#41375700">prev</a><span>|</span><a href="#41376658">next</a><span>|</span><label class="collapse" for="c-41373866">[-]</label><label class="expand" for="c-41373866">[16 more]</label></div><br/><div class="children"><div class="content">In practice, Git<p>Some CRDT purists would say &quot;its not perfectly conflict free so its not a CRDT&quot;.<p>Sure[0], but for the rest of us that are pragmatic about best effort conflict resolution Git is likely the most successful CRDT application.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;No_true_Scotsman" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;No_true_Scotsman</a></div><br/><div id="41374028" class="c"><input type="checkbox" id="c-41374028" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41373866">parent</a><span>|</span><a href="#41373978">next</a><span>|</span><label class="collapse" for="c-41374028">[-]</label><label class="expand" for="c-41374028">[3 more]</label></div><br/><div class="children"><div class="content">This comes up every time but there’s three criterion for CRDTs and git fails 2 of them. Even ignoring the requirement for automatic conflict resolution (which git can’t meet since automatic resolution fails as a matter of course) and ignoring that the conflict resolution algorithm has to be part of the data type (it’s not), it fails the requirement that separate different copies must eventually converge when brought online but that’s demonstrably false as people may use different conflict resolution mechanisms AND the commit graph of a resolved conflict may itself then be different resulting in different histories from the process of brining git online.<p>This is because the commit graph itself isn’t CRDT. If I commit A and then B but someone’s clone only has B applied, you can’t synchronize even automatically; different git histories don’t resolve in any way automatically at all and once you pick a solution manually your copy will not have the same history as anyone else that tries to redo your operations.<p>No true Scotsman doesn’t apply here because there is a very precise definition of what makes a CRDT that is a clear delineating line.</div><br/><div id="41375281" class="c"><input type="checkbox" id="c-41375281" checked=""/><div class="controls bullet"><span class="by">yazaddaruvala</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374028">parent</a><span>|</span><a href="#41373978">next</a><span>|</span><label class="collapse" for="c-41375281">[-]</label><label class="expand" for="c-41375281">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 1. The application can update any replica independently, concurrently and without coordinating with other replicas.<p>&gt; 2. An algorithm (itself part of the data type) automatically resolves any inconsistencies that might occur.<p>&gt; 3. Although replicas may have different state at any particular point in time, they are guaranteed to eventually converge.<p>[0]<p>Again, in theory it fails 2 and 3. However, in practice 3 is a normal part of working with git in a team. Barring a hard fork in git - which is equivalent to a deep copy of a CRDT. Like any deep copy of a data type, a CRDT&#x27;s deep copy can be used in non-conformant manners (forks are VCS specific jargon for a CRDT deep copy; or shallow copy sometimes).<p>&gt; If I commit A and then B but someone’s clone only has B applied, you can’t synchronize even automatically; different git histories don’t resolve in any way automatically<p>Maybe I don&#x27;t understand your point specifically, but this example seems entirely solved by --rebase. In practice --rebase is typical, and best described as &quot;do your best to automatically resolve histories; I&#x27;ll handle any of the complex conflicts&quot;.<p>All that said, I already agreed: &quot;academically Git is not a CRDT&quot;. However, and I&#x27;m happy to disagree with you, in practice Git is the most popular CRDT.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Conflict-free_replicated_data_type" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Conflict-free_replicated_data_...</a></div><br/><div id="41375380" class="c"><input type="checkbox" id="c-41375380" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41375281">parent</a><span>|</span><a href="#41373978">next</a><span>|</span><label class="collapse" for="c-41375380">[-]</label><label class="expand" for="c-41375380">[1 more]</label></div><br/><div class="children"><div class="content">given how easy it is to run into merge conflicts doing normal things with git, I can&#x27;t say that I&#x27;d agree that in practice git is a CRDT either.</div><br/></div></div></div></div></div></div><div id="41373978" class="c"><input type="checkbox" id="c-41373978" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41373866">parent</a><span>|</span><a href="#41374028">prev</a><span>|</span><a href="#41374269">next</a><span>|</span><label class="collapse" for="c-41373978">[-]</label><label class="expand" for="c-41373978">[4 more]</label></div><br/><div class="children"><div class="content">CRDT literally means Conflict-free Replicated Data Type. Expecting CRDTs to be conflict-free isn&#x27;t purism, it&#x27;s simple validation. Git is, inarguably, not a CRDT.</div><br/><div id="41375324" class="c"><input type="checkbox" id="c-41375324" checked=""/><div class="controls bullet"><span class="by">yazaddaruvala</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41373978">parent</a><span>|</span><a href="#41375722">next</a><span>|</span><label class="collapse" for="c-41375324">[-]</label><label class="expand" for="c-41375324">[2 more]</label></div><br/><div class="children"><div class="content">&gt; CRDT literally means Conflict-free Replicated Data Type.<p>Git could be &quot;conflict-free&quot; with a simple `rand(ours, theirs)`.<p>It would be useless, but technically &quot;conflict-free&quot;. Is the addition or removal of that rand function <i>really</i>, <i>pragmatically</i> the difference in the answer to &quot;what is a CRDT?&quot;</div><br/><div id="41375820" class="c"><input type="checkbox" id="c-41375820" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41375324">parent</a><span>|</span><a href="#41375722">next</a><span>|</span><label class="collapse" for="c-41375820">[-]</label><label class="expand" for="c-41375820">[1 more]</label></div><br/><div class="children"><div class="content">Adding extra rules on top of git to try to turn it into a CRDT doesn&#x27;t make <i>git</i> one, even if you succeed (and rand would not succeed).  You can do that with a pencil and paper, but that doesn&#x27;t make paper a CRDT.</div><br/></div></div></div></div><div id="41375722" class="c"><input type="checkbox" id="c-41375722" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41373978">parent</a><span>|</span><a href="#41375324">prev</a><span>|</span><a href="#41374269">next</a><span>|</span><label class="collapse" for="c-41375722">[-]</label><label class="expand" for="c-41375722">[1 more]</label></div><br/><div class="children"><div class="content">There are CDTS that have &quot;multiple versions&quot;, which look an awful lot like conflicts to me, ie, the Multi-Value Register in this paper:<p><a href="https:&#x2F;&#x2F;inria.hal.science&#x2F;inria-00555588&#x2F;" rel="nofollow">https:&#x2F;&#x2F;inria.hal.science&#x2F;inria-00555588&#x2F;</a></div><br/></div></div></div></div><div id="41374269" class="c"><input type="checkbox" id="c-41374269" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41373866">parent</a><span>|</span><a href="#41373978">prev</a><span>|</span><a href="#41374152">next</a><span>|</span><label class="collapse" for="c-41374269">[-]</label><label class="expand" for="c-41374269">[7 more]</label></div><br/><div class="children"><div class="content">I really wish someone would make a git-like tool on top of CRDTs. I want conflicts when merging commits like git does, but I also want the crdt features - like better cherry-picking and cleaner merging when merging several branches together. And of course, live pair programming.<p>CRDTs store a superset of the information git stores - so we should be able to use that information to emit git style conflicts when we want. But I think nobody has implemented that yet. (Pijul probably comes closest.)</div><br/><div id="41374317" class="c"><input type="checkbox" id="c-41374317" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374269">parent</a><span>|</span><a href="#41374994">next</a><span>|</span><label class="collapse" for="c-41374317">[-]</label><label class="expand" for="c-41374317">[4 more]</label></div><br/><div class="children"><div class="content">I suspect a major reason why CRDTs haven&#x27;t been a clear dominator in VCSes is that the &quot;conflict free&quot; decision is not necessarily the <i>correct</i> decision.  It&#x27;s merely a <i>consistent</i> one.<p>When editing is relatively &quot;live&quot;, those are small enough that they&#x27;re probably also correct.  But adding your month of changes to a dozen other people&#x27;s month of changes doesn&#x27;t mean it&#x27;s going to build correctly (or even look sane) when you change the same file.  Manually seeing the issue and fixing it gives you a chance to correct that, at the time it&#x27;s relevant, rather than &quot;it all changed, good luck&quot;.<p>---<p>If you&#x27;re interested in distributed-VCS systems that have some different semantics than git, <a href="https:&#x2F;&#x2F;pijul.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pijul.org&#x2F;</a> might be interesting.  And Jujutsu is... complicated, as it abstracts across a few and brings in a few things from multiple VCSes, but it&#x27;s mostly git-like afaict: <a href="https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj">https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj</a><p>No doubt there are others too (if anyone has favorites, please post!  I&#x27;m curious too)</div><br/><div id="41377394" class="c"><input type="checkbox" id="c-41377394" checked=""/><div class="controls bullet"><span class="by">n0w</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374317">parent</a><span>|</span><a href="#41376880">next</a><span>|</span><label class="collapse" for="c-41377394">[-]</label><label class="expand" for="c-41377394">[1 more]</label></div><br/><div class="children"><div class="content">CRDTs seem to give the best experience when they correctly model the &quot;intent&quot; of changes.<p>But a diff between two different states of raw text can&#x27;t convey the intent of a code change (beyond very simple changes).<p>This is why I think CRDTs haven&#x27;t caught on for VCSes and I&#x27;m not sure they _could_ without some kind of structured editing.</div><br/></div></div><div id="41376880" class="c"><input type="checkbox" id="c-41376880" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374317">parent</a><span>|</span><a href="#41377394">prev</a><span>|</span><a href="#41374532">next</a><span>|</span><label class="collapse" for="c-41376880">[-]</label><label class="expand" for="c-41376880">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the &quot;conflict free&quot; decision is not necessarily the correct decision. It&#x27;s merely a consistent one.<p>Yep. But there&#x27;s no reason you couldn&#x27;t build a system that supports both approaches - conflict-free when live pair programming, but conflicts are still generated when merging long lived branches. As I say, text CRDTs store all the data needed to do this. Just, nobody (as far as I know) has built that.</div><br/></div></div><div id="41374532" class="c"><input type="checkbox" id="c-41374532" checked=""/><div class="controls bullet"><span class="by">nrr</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374317">parent</a><span>|</span><a href="#41376880">prev</a><span>|</span><a href="#41374994">next</a><span>|</span><label class="collapse" for="c-41374532">[-]</label><label class="expand" for="c-41374532">[1 more]</label></div><br/><div class="children"><div class="content">Fossil (<a href="https:&#x2F;&#x2F;fossil-scm.org" rel="nofollow">https:&#x2F;&#x2F;fossil-scm.org</a>) is actually a proper grow-only set from what I can tell: merge conflicts upon synchronization are encoded in the DAG as forks of the history at the conflicting points in time. If no action is taken after a fork, all clones will eventually see the exact same view of the history.<p>The tooling will normally bail with a &quot;would fork&quot; message if a `fossil update` (and, hence, local resolution of those conflicts) wasn&#x27;t undertaken before pushing, but this is not at all necessary to preserve useful operation.</div><br/></div></div></div></div><div id="41374994" class="c"><input type="checkbox" id="c-41374994" checked=""/><div class="controls bullet"><span class="by">felipefar</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374269">parent</a><span>|</span><a href="#41374317">prev</a><span>|</span><a href="#41375402">next</a><span>|</span><label class="collapse" for="c-41374994">[-]</label><label class="expand" for="c-41374994">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been researching CRDTs for a reference manager that I&#x27;m building (<a href="https:&#x2F;&#x2F;getcahier.com" rel="nofollow">https:&#x2F;&#x2F;getcahier.com</a>), and thought that some hybrid of automatic and user-operated conflict resolution would be ideal, as you described. But current efforts are mostly directed to automatic resolution.</div><br/></div></div><div id="41375402" class="c"><input type="checkbox" id="c-41375402" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#41373616">root</a><span>|</span><a href="#41374269">parent</a><span>|</span><a href="#41374994">prev</a><span>|</span><a href="#41374152">next</a><span>|</span><label class="collapse" for="c-41375402">[-]</label><label class="expand" for="c-41375402">[1 more]</label></div><br/><div class="children"><div class="content">I would want the git-like tool to have semantic diffs, and so have much better conflict resolution as a result; not CRDTs and more obtuse &amp; confused conflicts than it&#x27;s already capable of.</div><br/></div></div></div></div></div></div></div></div><div id="41376658" class="c"><input type="checkbox" id="c-41376658" checked=""/><div class="controls bullet"><span class="by">riedel</span><span>|</span><a href="#41373616">prev</a><span>|</span><a href="#41376903">next</a><span>|</span><label class="collapse" for="c-41376658">[-]</label><label class="expand" for="c-41376658">[1 more]</label></div><br/><div class="children"><div class="content">Quoting the current github Readme [0]:
&gt;And since that blog post came out, performance has increased another 10-80x (!).<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;josephg&#x2F;diamond-types">https:&#x2F;&#x2F;github.com&#x2F;josephg&#x2F;diamond-types</a></div><br/></div></div><div id="41376903" class="c"><input type="checkbox" id="c-41376903" checked=""/><div class="controls bullet"><span class="by">arkh</span><span>|</span><a href="#41376658">prev</a><span>|</span><a href="#41374801">next</a><span>|</span><label class="collapse" for="c-41376903">[-]</label><label class="expand" for="c-41376903">[1 more]</label></div><br/><div class="children"><div class="content">Seeing the hierarchical structure used I wonder if they tried using nested set instead. No idea if a possible gain in read operation would offset the losses in insertions.</div><br/></div></div><div id="41374801" class="c"><input type="checkbox" id="c-41374801" checked=""/><div class="controls bullet"><span class="by">felipefar</span><span>|</span><a href="#41376903">prev</a><span>|</span><a href="#41375011">next</a><span>|</span><label class="collapse" for="c-41374801">[-]</label><label class="expand" for="c-41374801">[10 more]</label></div><br/><div class="children"><div class="content">CRDTs are powerful, but it&#x27;s unfortunate that they leave behind a trail of historical operations (or elements), both in their ops- or state-based variants. Even with compression, it&#x27;s still a downside that makes me concerned about adopting them.<p>Even so, the discussion surrounding them made me excited by the possibility of implementing conflict-free (or fine-grained conflict resolution) algorithms over file-based storage providers (Dropbox, Syncthing, etc.).</div><br/><div id="41376914" class="c"><input type="checkbox" id="c-41376914" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41374801">parent</a><span>|</span><a href="#41374864">next</a><span>|</span><label class="collapse" for="c-41376914">[-]</label><label class="expand" for="c-41376914">[1 more]</label></div><br/><div class="children"><div class="content">Author here. I&#x27;ve had this conversation with people <i>a lot</i>. And people in the CRDT world also talk about it a lot. But in practice, at least with text editing, the overhead is so tiny that I can&#x27;t imagine it ever coming up in practice. Diamond types - my post-CRDT project - does (by default) grow without bound over time. But the overhead is usually less than 1 byte for every character ever typed. If I turn on LZ4 compression on the stored text, documents edited with diamond types are often smaller than the resulting document state. <i>Even though we store the entire editing history!</i><p>I know a bunch of ways to solve this technically. But I&#x27;m just not convinced its a real problem in most systems.<p>(I have heard of it being a problem for someone using yjs for a 3d modelling tool. While dragging objects, they created persistent edits with each pixel movement of the mouse. But I think its smarter to use ephemeral edits for stuff like that - which aren&#x27;t supported by most crdt libraries.)<p>Git also suffers from this problem, by the way. Repositories only grow over time. And they grow way faster than they would if modern CRDT libraries were used instead. But nobody seems bothered by it. (Yes, you can do a shallow clone in git. But almost nobody does. And you could also do that with CRDTs as well if you want!)</div><br/></div></div><div id="41374864" class="c"><input type="checkbox" id="c-41374864" checked=""/><div class="controls bullet"><span class="by">jakelazaroff</span><span>|</span><a href="#41374801">parent</a><span>|</span><a href="#41376914">prev</a><span>|</span><a href="#41375184">next</a><span>|</span><label class="collapse" for="c-41374864">[-]</label><label class="expand" for="c-41374864">[2 more]</label></div><br/><div class="children"><div class="content">If you’re not building something fully decentralized, you may be able to loosen some of the constraints CRDTs require. As an example, if you can guarantee that all clients have received changes later than X date, you can safely drop any operations from before that date.</div><br/><div id="41376746" class="c"><input type="checkbox" id="c-41376746" checked=""/><div class="controls bullet"><span class="by">shipp02</span><span>|</span><a href="#41374801">root</a><span>|</span><a href="#41374864">parent</a><span>|</span><a href="#41375184">next</a><span>|</span><label class="collapse" for="c-41376746">[-]</label><label class="expand" for="c-41376746">[1 more]</label></div><br/><div class="children"><div class="content">Could you also make it fully decentralized but require clients to come online within a deadline (1 day, week) or risk losing their local changes? This would also allowing trimming history but with loss of some functionality to sync.</div><br/></div></div></div></div><div id="41375184" class="c"><input type="checkbox" id="c-41375184" checked=""/><div class="controls bullet"><span class="by">jchanimal</span><span>|</span><a href="#41374801">parent</a><span>|</span><a href="#41374864">prev</a><span>|</span><a href="#41375774">next</a><span>|</span><label class="collapse" for="c-41375184">[-]</label><label class="expand" for="c-41375184">[2 more]</label></div><br/><div class="children"><div class="content">The full op-log plus deterministic merging is a great fit for immutable block storage, which can have other security, performance, and cost benefits. I&#x27;m building Fireproof[1] to take advantage of recent research in this area. An additional benefit to content addressing the immutable data is that each operation resolves to a cryptographically guaranteed proof (or diff), enforcing causal consistency and allowing stable references to be made to snapshots. This means your interactive, offline-capable, losslessly-merging database can run on the edge or in the browser, but still have the integrity you&#x27;d have looked to a centralized database or the blockchain for in the past. (Eg you can drop a snapshot CID into a PDF for signature, or a smart contract, and remove all ambiguity about the referenced state.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;fireproof-storage&#x2F;fireproof">https:&#x2F;&#x2F;github.com&#x2F;fireproof-storage&#x2F;fireproof</a></div><br/><div id="41375517" class="c"><input type="checkbox" id="c-41375517" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41374801">root</a><span>|</span><a href="#41375184">parent</a><span>|</span><a href="#41375774">next</a><span>|</span><label class="collapse" for="c-41375517">[-]</label><label class="expand" for="c-41375517">[1 more]</label></div><br/><div class="children"><div class="content">how do such immutable systems deal with redaction eg for GDPR delete requests? Do you need to repack the whole history, and break the existing signature chain?</div><br/></div></div></div></div><div id="41375774" class="c"><input type="checkbox" id="c-41375774" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#41374801">parent</a><span>|</span><a href="#41375184">prev</a><span>|</span><a href="#41375730">next</a><span>|</span><label class="collapse" for="c-41375774">[-]</label><label class="expand" for="c-41375774">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the concern if you can delete history?</div><br/><div id="41376431" class="c"><input type="checkbox" id="c-41376431" checked=""/><div class="controls bullet"><span class="by">orthecreedence</span><span>|</span><a href="#41374801">root</a><span>|</span><a href="#41375774">parent</a><span>|</span><a href="#41375730">next</a><span>|</span><label class="collapse" for="c-41376431">[-]</label><label class="expand" for="c-41376431">[2 more]</label></div><br/><div class="children"><div class="content">In a distributed system, which is often a place CRDTs thrive, deleted history means a new client cannot be brought up to the current state unless there is some form of state summarization. Doing this summarization&#x2F;checkpointing in a consistent manner is difficult to do without some form of online consensus mechanism, which is also difficult to do in a distributed system with clients popping in and out all the time.</div><br/><div id="41376921" class="c"><input type="checkbox" id="c-41376921" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41374801">root</a><span>|</span><a href="#41376431">parent</a><span>|</span><a href="#41375730">next</a><span>|</span><label class="collapse" for="c-41376921">[-]</label><label class="expand" for="c-41376921">[1 more]</label></div><br/><div class="children"><div class="content">It depends on the system. Some approaches (like Greg Little&#x27;s Shelf or my Eg-walker algorithm for text) make this trivial to implement.</div><br/></div></div></div></div></div></div><div id="41375730" class="c"><input type="checkbox" id="c-41375730" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#41374801">parent</a><span>|</span><a href="#41375774">prev</a><span>|</span><a href="#41375011">next</a><span>|</span><label class="collapse" for="c-41375730">[-]</label><label class="expand" for="c-41375730">[1 more]</label></div><br/><div class="children"><div class="content"><i>CRDTs are powerful, but it&#x27;s unfortunate that they leave behind a trail of historical operations (or elements), both in their ops- or state-based variants. Even with compression, it&#x27;s still a downside that makes me concerned about adopting them.</i><p>There&#x27;s nothing inherent in the concept of a CRDT that requires you to leave behind a trail of historical operations or elements.<p>You&#x27;d be better off directing your criticism and specific implementations than making this blanket statement about what is, at the end of the day, a set of mathematical laws that certain data types &#x2F; databases follow.</div><br/></div></div></div></div><div id="41375011" class="c"><input type="checkbox" id="c-41375011" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#41374801">prev</a><span>|</span><a href="#41373288">next</a><span>|</span><label class="collapse" for="c-41375011">[-]</label><label class="expand" for="c-41375011">[2 more]</label></div><br/><div class="children"><div class="content">This is one of those rare articles which, although much of the material is over my head, I couldn&#x27;t stop reading because it&#x27;s written so well.</div><br/><div id="41376883" class="c"><input type="checkbox" id="c-41376883" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41375011">parent</a><span>|</span><a href="#41373288">next</a><span>|</span><label class="collapse" for="c-41376883">[-]</label><label class="expand" for="c-41376883">[1 more]</label></div><br/><div class="children"><div class="content">Author here. Very kind :)</div><br/></div></div></div></div><div id="41373288" class="c"><input type="checkbox" id="c-41373288" checked=""/><div class="controls bullet"><span class="by">kirubakaran</span><span>|</span><a href="#41375011">prev</a><span>|</span><a href="#41373061">next</a><span>|</span><label class="collapse" for="c-41373288">[-]</label><label class="expand" for="c-41373288">[3 more]</label></div><br/><div class="children"><div class="content">- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28017204">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28017204</a> (3 years ago, 151 comments)<p>- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33903563">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33903563</a> (2 years ago, 22 comments)<p>- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41372833">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41372833</a> (this post)<p>- <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41373288">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41373288</a> (this comment)</div><br/><div id="41374117" class="c"><input type="checkbox" id="c-41374117" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41373288">parent</a><span>|</span><a href="#41373673">next</a><span>|</span><label class="collapse" for="c-41374117">[-]</label><label class="expand" for="c-41374117">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Macroexpanded:<p><i>5000x faster CRDTs: An adventure in optimization (2021)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33903563">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33903563</a> - Dec 2022 (22 comments)<p><i>Faster CRDTs: An Adventure in Optimization</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28017204">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28017204</a> - July 2021 (151 comments)</div><br/></div></div></div></div><div id="41373061" class="c"><input type="checkbox" id="c-41373061" checked=""/><div class="controls bullet"><span class="by">fredrikholm</span><span>|</span><a href="#41373288">prev</a><span>|</span><a href="#41374234">next</a><span>|</span><label class="collapse" for="c-41373061">[-]</label><label class="expand" for="c-41373061">[3 more]</label></div><br/><div class="children"><div class="content">I remember stumbling over this post a few years ago. Really entertaining post, one of my favorites in recent years.</div><br/><div id="41373215" class="c"><input type="checkbox" id="c-41373215" checked=""/><div class="controls bullet"><span class="by">anaclet0</span><span>|</span><a href="#41373061">parent</a><span>|</span><a href="#41374234">next</a><span>|</span><label class="collapse" for="c-41373215">[-]</label><label class="expand" for="c-41373215">[2 more]</label></div><br/><div class="children"><div class="content">IIRC the title was CRDTs go brrr</div><br/><div id="41374231" class="c"><input type="checkbox" id="c-41374231" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41373061">root</a><span>|</span><a href="#41373215">parent</a><span>|</span><a href="#41374234">next</a><span>|</span><label class="collapse" for="c-41374231">[-]</label><label class="expand" for="c-41374231">[1 more]</label></div><br/><div class="children"><div class="content">Author here. CRDTs go brrr was my working title and it’s still in the url. I should probably rename it back to that - so many people latch on to that title anyway. The meme value is strong.</div><br/></div></div></div></div></div></div><div id="41374234" class="c"><input type="checkbox" id="c-41374234" checked=""/><div class="controls bullet"><span class="by">ericyd</span><span>|</span><a href="#41373061">prev</a><span>|</span><a href="#41373303">next</a><span>|</span><label class="collapse" for="c-41374234">[-]</label><label class="expand" for="c-41374234">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Why is WASM 4x slower than native execution?<p>I thought it was because every string operation had to be copied into WASM memory and then back into JS when the result was computed. Am I wrong? Am I misunderstanding the context? Genuinely curious!</div><br/><div id="41374360" class="c"><input type="checkbox" id="c-41374360" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41374234">parent</a><span>|</span><a href="#41374301">next</a><span>|</span><label class="collapse" for="c-41374360">[-]</label><label class="expand" for="c-41374360">[1 more]</label></div><br/><div class="children"><div class="content">Author here. This post was from a few years ago but from memory I controlled for that. So the problem wasn&#x27;t FFI.<p>I loaded the whole history into wasm before I started timing, then processed it in an inner loop that was written in rust, running in the wasm context itself. There were only 2 calls to wasm or something. The 4x slowdown wasn&#x27;t FFI. The algorithmic code itself was actually running 4x slower.<p>It&#x27;d be interesting to rerun the benchmark now. I assume compilers are better at emitting wasm, and wasm runtimes have gotten faster. I&#x27;m sure I&#x27;ve still got the benchmarking code around somewhere.</div><br/></div></div><div id="41374301" class="c"><input type="checkbox" id="c-41374301" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#41374234">parent</a><span>|</span><a href="#41374360">prev</a><span>|</span><a href="#41373303">next</a><span>|</span><label class="collapse" for="c-41374301">[-]</label><label class="expand" for="c-41374301">[1 more]</label></div><br/><div class="children"><div class="content">That strikes me as the likely plausible culprit.<p>The one that keeps tripping me up in unrelated domains is that the multithreading story is not easy or fully supported by libraries and tooling. We&#x27;ve run game engines and utility binaries (ffmpeg, zip, etc.) in the browser and they&#x27;re super slow because of this.</div><br/></div></div></div></div><div id="41373303" class="c"><input type="checkbox" id="c-41373303" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41374234">prev</a><span>|</span><a href="#41373219">next</a><span>|</span><label class="collapse" for="c-41373303">[-]</label><label class="expand" for="c-41373303">[4 more]</label></div><br/><div class="children"><div class="content">(2021) and Automerge&#x27;s Rust implementation seems to have landed so it would be interesting to see an updated benchmark.</div><br/><div id="41374140" class="c"><input type="checkbox" id="c-41374140" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41373303">parent</a><span>|</span><a href="#41373219">next</a><span>|</span><label class="collapse" for="c-41374140">[-]</label><label class="expand" for="c-41374140">[3 more]</label></div><br/><div class="children"><div class="content">Author here. Yjs has also been rewritten in rust (yrs) and it’s significantly faster than the JavaScript version.<p>I’ve also got a new, totally different approach to solving this problem too.<p>It would definitely be good to update the benchmarks. Everything has gotten faster.</div><br/><div id="41374487" class="c"><input type="checkbox" id="c-41374487" checked=""/><div class="controls bullet"><span class="by">demircancelebi</span><span>|</span><a href="#41373303">root</a><span>|</span><a href="#41374140">parent</a><span>|</span><a href="#41373219">next</a><span>|</span><label class="collapse" for="c-41374487">[-]</label><label class="expand" for="c-41374487">[2 more]</label></div><br/><div class="children"><div class="content">would love to read the totally different approach</div><br/><div id="41374733" class="c"><input type="checkbox" id="c-41374733" checked=""/><div class="controls bullet"><span class="by">og2023</span><span>|</span><a href="#41373303">root</a><span>|</span><a href="#41374487">parent</a><span>|</span><a href="#41373219">next</a><span>|</span><label class="collapse" for="c-41374733">[-]</label><label class="expand" for="c-41374733">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely support this, so do I!</div><br/></div></div></div></div></div></div></div></div><div id="41373219" class="c"><input type="checkbox" id="c-41373219" checked=""/><div class="controls bullet"><span class="by">JohnDeHope</span><span>|</span><a href="#41373303">prev</a><span>|</span><a href="#41375389">next</a><span>|</span><label class="collapse" for="c-41373219">[-]</label><label class="expand" for="c-41373219">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, new rule: I don&#x27;t believe anything in a published scientific paper until it has been independently verified for the third time. I don&#x27;t even want to <i>hear</i> about it, before then, unless I read the journal the original (or second) paper was published in. What I&#x27;d really like, and would subscribe to even as a lay person, is the JOURNAL OF STUDIES WHOSE FINDINGS HAVE BEEN SUCCESSFULLY REPRODUCED FOR THE THIRD TIME. I&#x27;d pay for a subscription to that.</div><br/><div id="41374040" class="c"><input type="checkbox" id="c-41374040" checked=""/><div class="controls bullet"><span class="by">lylejantzi3rd</span><span>|</span><a href="#41373219">parent</a><span>|</span><a href="#41375389">next</a><span>|</span><label class="collapse" for="c-41374040">[-]</label><label class="expand" for="c-41374040">[1 more]</label></div><br/><div class="children"><div class="content">Me too.</div><br/></div></div></div></div><div id="41375389" class="c"><input type="checkbox" id="c-41375389" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#41373219">prev</a><span>|</span><a href="#41373187">next</a><span>|</span><label class="collapse" for="c-41375389">[-]</label><label class="expand" for="c-41375389">[2 more]</label></div><br/><div class="children"><div class="content">Can someone explain to me please why CRDTs are slow?<p>This article suggests the future to me: <a href="https:&#x2F;&#x2F;joelgustafson.com&#x2F;posts&#x2F;2023-05-04&#x2F;merklizing-the-key-value-store-for-fun-and-profit" rel="nofollow">https:&#x2F;&#x2F;joelgustafson.com&#x2F;posts&#x2F;2023-05-04&#x2F;merklizing-the-ke...</a><p>Take a look at this and compare it to Y.js or automerge: <a href="https:&#x2F;&#x2F;github.com&#x2F;canvasxyz&#x2F;okra-js">https:&#x2F;&#x2F;github.com&#x2F;canvasxyz&#x2F;okra-js</a></div><br/><div id="41376935" class="c"><input type="checkbox" id="c-41376935" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41375389">parent</a><span>|</span><a href="#41373187">next</a><span>|</span><label class="collapse" for="c-41376935">[-]</label><label class="expand" for="c-41376935">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Can someone explain to me please why CRDTs are slow?<p>Author here. The main reason was that a lot of CRDT libraries were written by academics, who don&#x27;t have the time, skill or interest in optimising them.<p>Since writing this article a few years ago, all the major CRDT libraries have gotten orders of magnitude faster.</div><br/></div></div></div></div><div id="41373187" class="c"><input type="checkbox" id="c-41373187" checked=""/><div class="controls bullet"><span class="by">luke-stanley</span><span>|</span><a href="#41375389">prev</a><span>|</span><a href="#41373444">next</a><span>|</span><label class="collapse" for="c-41373187">[-]</label><label class="expand" for="c-41373187">[3 more]</label></div><br/><div class="children"><div class="content">Could be good to have the date put with the title?</div><br/><div id="41374114" class="c"><input type="checkbox" id="c-41374114" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41373187">parent</a><span>|</span><a href="#41373930">next</a><span>|</span><label class="collapse" for="c-41374114">[-]</label><label class="expand" for="c-41374114">[1 more]</label></div><br/><div class="children"><div class="content">Added above.</div><br/></div></div><div id="41373930" class="c"><input type="checkbox" id="c-41373930" checked=""/><div class="controls bullet"><span class="by">gchamonlive</span><span>|</span><a href="#41373187">parent</a><span>|</span><a href="#41374114">prev</a><span>|</span><a href="#41373444">next</a><span>|</span><label class="collapse" for="c-41373930">[-]</label><label class="expand" for="c-41373930">[1 more]</label></div><br/><div class="children"><div class="content">July 31 2021</div><br/></div></div></div></div></div></div></div></div></div></body></html>