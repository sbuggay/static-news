<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693299664915" as="style"/><link rel="stylesheet" href="styles.css?v=1693299664915"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://questdb.io/blog/concurrent-lockfree-datastructure-design-walkthrough/">Designing a new concurrent data structure</a> <span class="domain">(<a href="https://questdb.io">questdb.io</a>)</span></div><div class="subtext"><span>goodroot</span> | <span>26 comments</span></div><br/><div><div id="37300396" class="c"><input type="checkbox" id="c-37300396" checked=""/><div class="controls bullet"><span class="by">IndoorPatio</span><span>|</span><a href="#37295415">next</a><span>|</span><label class="collapse" for="c-37300396">[-]</label><label class="expand" for="c-37300396">[9 more]</label></div><br/><div class="children"><div class="content">In my experience Left-Write is the clear place to start. It&#x27;s general purpose and fast for reads. Only if that is unsuitable (eg memory usage) does one design a custom data structure. There&#x27;s a Rust lib implementation with links to more resources:<p><a href="https:&#x2F;&#x2F;docs.rs&#x2F;left-right&#x2F;latest&#x2F;left_right&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.rs&#x2F;left-right&#x2F;latest&#x2F;left_right&#x2F;</a></div><br/><div id="37300583" class="c"><input type="checkbox" id="c-37300583" checked=""/><div class="controls bullet"><span class="by">jerrinot</span><span>|</span><a href="#37300396">parent</a><span>|</span><a href="#37303060">next</a><span>|</span><label class="collapse" for="c-37300583">[-]</label><label class="expand" for="c-37300583">[3 more]</label></div><br/><div class="children"><div class="content">I only learned about the left-right schema after finishing my design. I thought I came up with something novel - it turns out it was just my ignorance:)<p>Still, I think the left-right crate could benefit from one optimization I came up with. This is what the lib says in the docs:<p>&gt; When WriteHandle::publish is called, the writer, atomically swaps the reader pointer to point to the other T. It then waits for the epochs of all current readers to change, and then replays the operational log to bring the stale copy up to date.<p>I think the lib could postpone the log replaying until the next publish. Chances are all readers will have the new epoch by than = the writer thread won&#x27;t have to wait at all.</div><br/><div id="37302305" class="c"><input type="checkbox" id="c-37302305" checked=""/><div class="controls bullet"><span class="by">the_svd_doctor</span><span>|</span><a href="#37300396">root</a><span>|</span><a href="#37300583">parent</a><span>|</span><a href="#37303941">next</a><span>|</span><label class="collapse" for="c-37302305">[-]</label><label class="expand" for="c-37302305">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; I thought I came up with something novel - it turns out it was just my ignorance:)<p>The first 3 years of my PhD summarized in one sentence.</div><br/></div></div><div id="37303941" class="c"><input type="checkbox" id="c-37303941" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#37300396">root</a><span>|</span><a href="#37300583">parent</a><span>|</span><a href="#37302305">prev</a><span>|</span><a href="#37303060">next</a><span>|</span><label class="collapse" for="c-37303941">[-]</label><label class="expand" for="c-37303941">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think the lib could postpone the log replaying until the next publish. Chances are all readers will have the new epoch by than = the writer thread won&#x27;t have to wait at all.<p>I think you can&#x27;t even do a new publish if all readers haven&#x27;t finished switching to a new epoch after a previous publish. Otherwise, you risk corrupting readers that are still on the original epoch.</div><br/></div></div></div></div><div id="37303060" class="c"><input type="checkbox" id="c-37303060" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#37300396">parent</a><span>|</span><a href="#37300583">prev</a><span>|</span><a href="#37303508">next</a><span>|</span><label class="collapse" for="c-37303060">[-]</label><label class="expand" for="c-37303060">[2 more]</label></div><br/><div class="children"><div class="content">Interesting, I have always called this double buffering.</div><br/><div id="37304041" class="c"><input type="checkbox" id="c-37304041" checked=""/><div class="controls bullet"><span class="by">cjbgkagh</span><span>|</span><a href="#37300396">root</a><span>|</span><a href="#37303060">parent</a><span>|</span><a href="#37303508">next</a><span>|</span><label class="collapse" for="c-37304041">[-]</label><label class="expand" for="c-37304041">[1 more]</label></div><br/><div class="children"><div class="content">I think the difference is that with double buffering the stale data is thrown away but here they maintain a list of operations to repeat on the stale data to bring it into sync.</div><br/></div></div></div></div><div id="37303508" class="c"><input type="checkbox" id="c-37303508" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37300396">parent</a><span>|</span><a href="#37303060">prev</a><span>|</span><a href="#37302724">next</a><span>|</span><label class="collapse" for="c-37303508">[-]</label><label class="expand" for="c-37303508">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re ok with single writer as a constraint, hazard pointers get you similar read availability at the cost of maybe more expensive writes (and similar 2x memory overhead so long as the read sections are relatively short).</div><br/></div></div><div id="37302724" class="c"><input type="checkbox" id="c-37302724" checked=""/><div class="controls bullet"><span class="by">sa46</span><span>|</span><a href="#37300396">parent</a><span>|</span><a href="#37303508">prev</a><span>|</span><a href="#37300685">next</a><span>|</span><label class="collapse" for="c-37302724">[-]</label><label class="expand" for="c-37302724">[1 more]</label></div><br/><div class="children"><div class="content">Oh neat, that’s what that’s called. I did something similar in ignorance. I needed a histogram metric with multiple lock-free writers and a single reader.<p>- create two ring buffers (left&#x2F;right; I called them hot&#x2F;cold)<p>- store the hot ring buffer in an atomic pointer<p>- single reader swaps hot and cold and waits for writers to finish</div><br/></div></div><div id="37300685" class="c"><input type="checkbox" id="c-37300685" checked=""/><div class="controls bullet"><span class="by">colonelxc</span><span>|</span><a href="#37300396">parent</a><span>|</span><a href="#37302724">prev</a><span>|</span><a href="#37295415">next</a><span>|</span><label class="collapse" for="c-37300685">[-]</label><label class="expand" for="c-37300685">[1 more]</label></div><br/><div class="children"><div class="content">I agree, it is a great pattern if you can spare the memory.</div><br/></div></div></div></div><div id="37295415" class="c"><input type="checkbox" id="c-37295415" checked=""/><div class="controls bullet"><span class="by">jerrinot</span><span>|</span><a href="#37300396">prev</a><span>|</span><a href="#37301282">next</a><span>|</span><label class="collapse" for="c-37295415">[-]</label><label class="expand" for="c-37295415">[4 more]</label></div><br/><div class="children"><div class="content">Hello, the author here. It feels great to see my blog on HN!<p>It was quite a journey, at first I thought I invented a novel concurrency schema. However, it turns out that it was simply a mix of my ignorance and hubris! :-)<p>Still, I had a lot of fun while designing this data structure and I believe it made a nice story. Ask me anything!</div><br/><div id="37302310" class="c"><input type="checkbox" id="c-37302310" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#37295415">parent</a><span>|</span><a href="#37301777">next</a><span>|</span><label class="collapse" for="c-37302310">[-]</label><label class="expand" for="c-37302310">[2 more]</label></div><br/><div class="children"><div class="content">If the keys are strings and you can use Rust, have you considered fst [0]? If the keys have prefixes in common, it is <i>very</i> compact. There&#x27;s a blog post about it [1]<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;fst">https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;fst</a><p>[1] <a href="https:&#x2F;&#x2F;blog.burntsushi.net&#x2F;transducers&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.burntsushi.net&#x2F;transducers&#x2F;</a><p>The main limitation of it is that it doesn&#x27;t support removal, but if removals are infrequent you can workaround that with another fst with removed items (and periodically rebuild the whole thing)</div><br/><div id="37304889" class="c"><input type="checkbox" id="c-37304889" checked=""/><div class="controls bullet"><span class="by">porridgeandrice</span><span>|</span><a href="#37295415">root</a><span>|</span><a href="#37302310">parent</a><span>|</span><a href="#37301777">next</a><span>|</span><label class="collapse" for="c-37304889">[-]</label><label class="expand" for="c-37304889">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this. this? <a href="https:&#x2F;&#x2F;swtch.com&#x2F;~rsc&#x2F;regexp&#x2F;regexp1.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;swtch.com&#x2F;~rsc&#x2F;regexp&#x2F;regexp1.html</a></div><br/></div></div></div></div><div id="37301777" class="c"><input type="checkbox" id="c-37301777" checked=""/><div class="controls bullet"><span class="by">impish9208</span><span>|</span><a href="#37295415">parent</a><span>|</span><a href="#37302310">prev</a><span>|</span><a href="#37301282">next</a><span>|</span><label class="collapse" for="c-37301777">[-]</label><label class="expand" for="c-37301777">[1 more]</label></div><br/><div class="children"><div class="content">How do you learn stuff like this? Especially the JNI and off-heap memory parts.</div><br/></div></div></div></div><div id="37301282" class="c"><input type="checkbox" id="c-37301282" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#37295415">prev</a><span>|</span><a href="#37300288">next</a><span>|</span><label class="collapse" for="c-37301282">[-]</label><label class="expand" for="c-37301282">[1 more]</label></div><br/><div class="children"><div class="content">You could also check out hazard pointers. This is basically the example used in <a href="https:&#x2F;&#x2F;melodiessim.netlify.app&#x2F;intro-hazard-ptrs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;melodiessim.netlify.app&#x2F;intro-hazard-ptrs&#x2F;</a></div><br/></div></div><div id="37300288" class="c"><input type="checkbox" id="c-37300288" checked=""/><div class="controls bullet"><span class="by">motoboi</span><span>|</span><a href="#37301282">prev</a><span>|</span><a href="#37301774">next</a><span>|</span><label class="collapse" for="c-37300288">[-]</label><label class="expand" for="c-37300288">[2 more]</label></div><br/><div class="children"><div class="content">Hi. You missed the opportunity to implement the reader as an AutoCloseable and do the get as a Reader method.<p>That way, classe users will be warned by the IDE that they should use a try-with-resources when acquiring a Reader.<p>For the sake of completeness here, Java compiler will warn about it, but that warning is disabled by default.</div><br/><div id="37300419" class="c"><input type="checkbox" id="c-37300419" checked=""/><div class="controls bullet"><span class="by">jerrinot</span><span>|</span><a href="#37300288">parent</a><span>|</span><a href="#37301774">next</a><span>|</span><label class="collapse" for="c-37300419">[-]</label><label class="expand" for="c-37300419">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually exactly what I did! I removed this part from the article as I felt it was not relevant for the concurrent protocol design and it was adding mental load for readers not that fluent in Java.</div><br/></div></div></div></div><div id="37301774" class="c"><input type="checkbox" id="c-37301774" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#37300288">prev</a><span>|</span><a href="#37301267">next</a><span>|</span><label class="collapse" for="c-37301774">[-]</label><label class="expand" for="c-37301774">[2 more]</label></div><br/><div class="children"><div class="content">Did you consider just making an array of HashMap, say 512 of them, and locking only one of them based on your key&#x27;s hash?<p>Or, more generally, minimizing the odds of waiting on a lock, without resorting to a complex lock free scheme?</div><br/><div id="37303460" class="c"><input type="checkbox" id="c-37303460" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#37301774">parent</a><span>|</span><a href="#37301267">next</a><span>|</span><label class="collapse" for="c-37303460">[-]</label><label class="expand" for="c-37303460">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Did you consider just making an array of HashMap, say 512 of them, and locking only one of them based on your key&#x27;s hash?<p>A disadvantage of that approach is that even without any lock contention you would still have two writes to memory for every lock acquisition.</div><br/></div></div></div></div><div id="37301267" class="c"><input type="checkbox" id="c-37301267" checked=""/><div class="controls bullet"><span class="by">cafxx</span><span>|</span><a href="#37301774">prev</a><span>|</span><a href="#37299911">next</a><span>|</span><label class="collapse" for="c-37301267">[-]</label><label class="expand" for="c-37301267">[4 more]</label></div><br/><div class="children"><div class="content">Why not just allocating the blobs off-heap? (That is something you probably want to do anyway if it&#x27;s cryptographic material, to avoid being at the mercy of the GC leaving copies around)<p>ByteBuffer.allocateDirect should do that IIRC. This allows you to use the standard ConcurrentHashMap while being able to get a stable pointer for use by the rust logic.</div><br/><div id="37301397" class="c"><input type="checkbox" id="c-37301397" checked=""/><div class="controls bullet"><span class="by">jerrinot</span><span>|</span><a href="#37301267">parent</a><span>|</span><a href="#37303401">next</a><span>|</span><label class="collapse" for="c-37301397">[-]</label><label class="expand" for="c-37301397">[2 more]</label></div><br/><div class="children"><div class="content">I could use DirectByteBuffer instances as CHM values. But Java deallocates the backing memory of DirectByteBuffers during object finalization. If there is no on-heap memory pressure then there is no GC and thus no finalization. So it would leak offheap memory. I could also use Unsafe to hack into DirectByteBuffer and call the Cleaner explicitly. Many libraries do that anyway. But then I would still need some kind of reference counting to make sure I won&#x27;t deallocate a buffer with active readers.</div><br/><div id="37301497" class="c"><input type="checkbox" id="c-37301497" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#37301267">root</a><span>|</span><a href="#37301397">parent</a><span>|</span><a href="#37303401">next</a><span>|</span><label class="collapse" for="c-37301497">[-]</label><label class="expand" for="c-37301497">[1 more]</label></div><br/><div class="children"><div class="content">is there any regret from choosing Java for Db development and need to work around this and likely many other issues?</div><br/></div></div></div></div><div id="37303401" class="c"><input type="checkbox" id="c-37303401" checked=""/><div class="controls bullet"><span class="by">dee-bee</span><span>|</span><a href="#37301267">parent</a><span>|</span><a href="#37301397">prev</a><span>|</span><a href="#37299911">next</a><span>|</span><label class="collapse" for="c-37303401">[-]</label><label class="expand" for="c-37303401">[1 more]</label></div><br/><div class="children"><div class="content">Is this the equivalent of directly asking the os for more pages, or does it work via some other heap-like mechanism that simply isn&#x27;t garbage collected?</div><br/></div></div></div></div><div id="37299911" class="c"><input type="checkbox" id="c-37299911" checked=""/><div class="controls bullet"><span class="by">audnaun252</span><span>|</span><a href="#37301267">prev</a><span>|</span><label class="collapse" for="c-37299911">[-]</label><label class="expand" for="c-37299911">[3 more]</label></div><br/><div class="children"><div class="content">seems like a lot of effort - could you have moved the map state to rust instead? to invoke the AuthCrypto.verifySignature with just the key?</div><br/><div id="37300364" class="c"><input type="checkbox" id="c-37300364" checked=""/><div class="controls bullet"><span class="by">jerrinot</span><span>|</span><a href="#37299911">parent</a><span>|</span><label class="collapse" for="c-37300364">[-]</label><label class="expand" for="c-37300364">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s indeed a very good question! There are 2 sets of reasons:<p>1. Technical<p>The contract is given - I&#x27;m receiving usernames as CharSequence(String). I could change that, but that would likely require changes in the SQL parser - not simple at all. Alternatively, I could pass the whole CharSequence to Rust - but passing objects over the JNI boundary comes with perf. penalty (when compared to passing primitive) and we avoid that whenever possible. Or I could encode CharSequence content to a temporary offheap buffer and pass just the pointer to Rust. But this brings back some of the questions from the article - like who owns the buffer?<p>2. Other reasons<p>I realized this was a possibility only when I was nearly done with the design (this whole endeavor took less than one day) and I felt the urge to finish it. Also: This article wouldn&#x27;t have been created!</div><br/><div id="37304877" class="c"><input type="checkbox" id="c-37304877" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#37299911">root</a><span>|</span><a href="#37300364">parent</a><span>|</span><label class="collapse" for="c-37304877">[-]</label><label class="expand" for="c-37304877">[1 more]</label></div><br/><div class="children"><div class="content">I have the opposite question: why not write everything in java?</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>