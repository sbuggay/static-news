<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733475653505" as="style"/><link rel="stylesheet" href="styles.css?v=1733475653505"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.danielh.cc/blog/sat">Accidentally writing a fast SAT solver</a> <span class="domain">(<a href="https://blog.danielh.cc">blog.danielh.cc</a>)</span></div><div class="subtext"><span>max__dev</span> | <span>25 comments</span></div><br/><div><div id="42333068" class="c"><input type="checkbox" id="c-42333068" checked=""/><div class="controls bullet"><span class="by">porcoda</span><span>|</span><a href="#42333702">next</a><span>|</span><label class="collapse" for="c-42333068">[-]</label><label class="expand" for="c-42333068">[5 more]</label></div><br/><div class="children"><div class="content">Interesting post, but I’m not sure this really speaks to what goes into actually writing what would be considered a “fast” SAT solver.  It seems more like a post about how SAT pops up in a lot of places if you look at them right.  For the state of the art in what constitutes fast solvers, the annual SAT competition papers are quite interesting to read if you’re interested in the techniques people come up with to make them fast.  A few years ago I was working through Knuth’s satisfiability book and writing my own solvers, and was always amazed how stunningly fast the SAT competition winners were compared to the ones I’d code up.</div><br/><div id="42334357" class="c"><input type="checkbox" id="c-42334357" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42333068">parent</a><span>|</span><a href="#42333828">next</a><span>|</span><label class="collapse" for="c-42334357">[-]</label><label class="expand" for="c-42334357">[2 more]</label></div><br/><div class="children"><div class="content">One would assume there are some low-hanging fruits that make up the bulk of the speed-ups, but maybe it’s really a huge pile of small incremental improvements?</div><br/><div id="42337560" class="c"><input type="checkbox" id="c-42337560" checked=""/><div class="controls bullet"><span class="by">ted_dunning</span><span>|</span><a href="#42333068">root</a><span>|</span><a href="#42334357">parent</a><span>|</span><a href="#42333828">next</a><span>|</span><label class="collapse" for="c-42337560">[-]</label><label class="expand" for="c-42337560">[1 more]</label></div><br/><div class="children"><div class="content">My impression is that going from a very simple case like this to a moderately fast solver involves bringing in a fair number of intuitive improvements like memoization of anti-patterns and heuristic reordering of the search.<p>But getting a really fast solver requires multiple strategies that don&#x27;t work well together (so they have to work semi-independently). This leads to other problems related to managing shared resources like how much you should let different strategies cache information at the expense of how much other strategies can cache information. Tuning all of these trade-offs is exceedingly difficult to do well since it depends a lot on the types of problems that you need to solve.</div><br/></div></div></div></div><div id="42333828" class="c"><input type="checkbox" id="c-42333828" checked=""/><div class="controls bullet"><span class="by">ComplexSystems</span><span>|</span><a href="#42333068">parent</a><span>|</span><a href="#42334357">prev</a><span>|</span><a href="#42333702">next</a><span>|</span><label class="collapse" for="c-42333828">[-]</label><label class="expand" for="c-42333828">[2 more]</label></div><br/><div class="children"><div class="content">SAT turns up everywhere because it&#x27;s almost universal kind of problem. Since it is NP complete, everything in NP can be transformed into an instance of SAT. Since P is a subset of NP, everything in P can be also be turned into an instance of SAT. Nobody knows if things in PSPACE can be, though.</div><br/><div id="42334439" class="c"><input type="checkbox" id="c-42334439" checked=""/><div class="controls bullet"><span class="by">CaptainNegative</span><span>|</span><a href="#42333068">root</a><span>|</span><a href="#42333828">parent</a><span>|</span><a href="#42333702">next</a><span>|</span><label class="collapse" for="c-42334439">[-]</label><label class="expand" for="c-42334439">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Since P is a subset of NP, everything in P can be also be turned into an instance of SAT.<p>This statement is kind of trivial. The same is true for any language (other than the empty language and the language containing all strings). The reduction is (1) hardcode the values of one string, y, that is in the language and another string, z, that is not in the language (2) solve the problem on the given input x in polynomial time poly(x) (3) return y if x is to be accepted and z otherwise.<p>The total running time is at most poly(x)+O(|y|+|z|) which is still poly(x) since |y| and |z| are hardcoded constant values.</div><br/></div></div></div></div></div></div><div id="42333702" class="c"><input type="checkbox" id="c-42333702" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42333068">prev</a><span>|</span><a href="#42337132">next</a><span>|</span><label class="collapse" for="c-42333702">[-]</label><label class="expand" for="c-42333702">[1 more]</label></div><br/><div class="children"><div class="content">Backtracking is not a fast SAT solver.</div><br/></div></div><div id="42337132" class="c"><input type="checkbox" id="c-42337132" checked=""/><div class="controls bullet"><span class="by">baol</span><span>|</span><a href="#42333702">prev</a><span>|</span><a href="#42336814">next</a><span>|</span><label class="collapse" for="c-42337132">[-]</label><label class="expand" for="c-42337132">[2 more]</label></div><br/><div class="children"><div class="content">Probably worth mentioning that there are well-known linear time algorithms to construct a solution for n-queen problem  <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Eight_queens_puzzle#Existence_of_solutions" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Eight_queens_puzzle#Existence_...</a></div><br/><div id="42337519" class="c"><input type="checkbox" id="c-42337519" checked=""/><div class="controls bullet"><span class="by">Arcuru</span><span>|</span><a href="#42337132">parent</a><span>|</span><a href="#42336814">next</a><span>|</span><label class="collapse" for="c-42337519">[-]</label><label class="expand" for="c-42337519">[1 more]</label></div><br/><div class="children"><div class="content">True, finding one solution is easy but finding all the solutions can be a fun little optimization challenge.<p>I made a repo many years ago with a bunch of grab bag solutions for comparisons [1]; from dumb brute force to DLX (Knuth&#x27;s Dancing Links) and a multithreaded bitwise backtracking algorithm. And one where I just hardcoded the answers because all the counts up to 27 are known.<p>So I&#x27;m all for just jumping to the existing known solutions, but it seems like the OP is having fun while they learn a little bit. They seem to just be a college freshman.<p>[1] - <a href="https:&#x2F;&#x2F;github.com&#x2F;arcuru&#x2F;nqueens">https:&#x2F;&#x2F;github.com&#x2F;arcuru&#x2F;nqueens</a></div><br/></div></div></div></div><div id="42336814" class="c"><input type="checkbox" id="c-42336814" checked=""/><div class="controls bullet"><span class="by">accurrent</span><span>|</span><a href="#42337132">prev</a><span>|</span><a href="#42333285">next</a><span>|</span><label class="collapse" for="c-42336814">[-]</label><label class="expand" for="c-42336814">[2 more]</label></div><br/><div class="children"><div class="content">SAT shows up in a lot of problems. Im doing my PhD in multi-agent robotics after spending some time working on real life multirobot deployments. Ive been frustrated because most roboticists I talk to think SAT is a dead end, but we have been having insane advances in solver speeds over the years. I guess everyone is obsessed about the ML hypetrain right now, but where sat shines is when we need to orchestrate at a task level. I feel theres defintely work to be done to bridge both worlds.</div><br/><div id="42337251" class="c"><input type="checkbox" id="c-42337251" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#42336814">parent</a><span>|</span><a href="#42333285">next</a><span>|</span><label class="collapse" for="c-42337251">[-]</label><label class="expand" for="c-42337251">[1 more]</label></div><br/><div class="children"><div class="content">Actually quadratic programming is all the rage these days since computers have gotten fast enough that you can run QP solvers in your control loop.</div><br/></div></div></div></div><div id="42333285" class="c"><input type="checkbox" id="c-42333285" checked=""/><div class="controls bullet"><span class="by">RestartKernel</span><span>|</span><a href="#42336814">prev</a><span>|</span><a href="#42334256">next</a><span>|</span><label class="collapse" for="c-42333285">[-]</label><label class="expand" for="c-42333285">[2 more]</label></div><br/><div class="children"><div class="content">I really like the styling of this blog. It&#x27;s nice on the eyes, gets out of the way, and the collapsed containers for extra info is a nice touch. There&#x27;s a bit of layout shift though, but that&#x27;s about it.</div><br/><div id="42333352" class="c"><input type="checkbox" id="c-42333352" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#42333285">parent</a><span>|</span><a href="#42334256">next</a><span>|</span><label class="collapse" for="c-42333352">[-]</label><label class="expand" for="c-42333352">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m on mobile too, I disabled JS in my browser to test it out, the site loads fine and the expanding boxes work too (I think it&#x27;s the &lt;details&gt; tag).</div><br/></div></div></div></div><div id="42334256" class="c"><input type="checkbox" id="c-42334256" checked=""/><div class="controls bullet"><span class="by">jkaptur</span><span>|</span><a href="#42333285">prev</a><span>|</span><a href="#42332967">next</a><span>|</span><label class="collapse" for="c-42334256">[-]</label><label class="expand" for="c-42334256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As a result, in order to determine if a formula is satisfiable, first convert it to conjunctive normal form, then convert the new formula into a course catalog.<p>I know this is a consequence of NP-completeness and so on and so forth, but I also find it a funny and charming way to phrase it. Once we&#x27;ve solved the <i>fundamental problem</i> (what courses to take), we&#x27;re able to solve simple specializations and derivatives (boolean satisfiability).</div><br/></div></div><div id="42332967" class="c"><input type="checkbox" id="c-42332967" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#42334256">prev</a><span>|</span><a href="#42334007">next</a><span>|</span><label class="collapse" for="c-42332967">[-]</label><label class="expand" for="c-42332967">[10 more]</label></div><br/><div class="children"><div class="content">On a related note, anyone have any advice for getting started with something like Z3?</div><br/><div id="42334622" class="c"><input type="checkbox" id="c-42334622" checked=""/><div class="controls bullet"><span class="by">sevensor</span><span>|</span><a href="#42332967">parent</a><span>|</span><a href="#42333226">next</a><span>|</span><label class="collapse" for="c-42334622">[-]</label><label class="expand" for="c-42334622">[1 more]</label></div><br/><div class="children"><div class="content">It really helps to have a hard problem to solve in the first place. Try scheduling all the classes in a university timetable into available classrooms, subject to constraints like maximum seating and not double booking an instructor. Now try to add constraints like “art classes must be in a studio.” Then to make it really fun, “no more than one fourth of the Electrical Engineering classes may be taught outside of the EE building.”</div><br/></div></div><div id="42333226" class="c"><input type="checkbox" id="c-42333226" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#42332967">parent</a><span>|</span><a href="#42334622">prev</a><span>|</span><a href="#42334968">next</a><span>|</span><label class="collapse" for="c-42333226">[-]</label><label class="expand" for="c-42333226">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;theory.stanford.edu&#x2F;~nikolaj&#x2F;programmingz3.html" rel="nofollow">https:&#x2F;&#x2F;theory.stanford.edu&#x2F;~nikolaj&#x2F;programmingz3.html</a> - This one was useful for me to get started with it a while ago.</div><br/></div></div><div id="42334968" class="c"><input type="checkbox" id="c-42334968" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#42332967">parent</a><span>|</span><a href="#42333226">prev</a><span>|</span><a href="#42336249">next</a><span>|</span><label class="collapse" for="c-42334968">[-]</label><label class="expand" for="c-42334968">[1 more]</label></div><br/><div class="children"><div class="content">I find both z3 native syntax (smt 2, lispish) and z3py hard to use.<p>Here&#x27;s an alternative syntax that uses python3 types. Works by transpiling to smt 2.<p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;adsharma&#x2F;45fbb065a8fe793030e8360daebffba1" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;adsharma&#x2F;45fbb065a8fe793030e8360daeb...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;py2many&#x2F;py2many&#x2F;blob&#x2F;main&#x2F;tests&#x2F;cases&#x2F;demorgan.py">https:&#x2F;&#x2F;github.com&#x2F;py2many&#x2F;py2many&#x2F;blob&#x2F;main&#x2F;tests&#x2F;cases&#x2F;dem...</a></div><br/></div></div><div id="42336249" class="c"><input type="checkbox" id="c-42336249" checked=""/><div class="controls bullet"><span class="by">3eb7988a1663</span><span>|</span><a href="#42332967">parent</a><span>|</span><a href="#42334968">prev</a><span>|</span><a href="#42336547">next</a><span>|</span><label class="collapse" for="c-42336249">[-]</label><label class="expand" for="c-42336249">[2 more]</label></div><br/><div class="children"><div class="content">I wish I had something to offer, but I think there is little available but grit. The solvers are magical in what they can do, but structuring a problem into the DSL is an exercise in pain. Seemingly few available public examples of patterns you can crib.</div><br/></div></div><div id="42336547" class="c"><input type="checkbox" id="c-42336547" checked=""/><div class="controls bullet"><span class="by">cchianel</span><span>|</span><a href="#42332967">parent</a><span>|</span><a href="#42336249">prev</a><span>|</span><a href="#42333094">next</a><span>|</span><label class="collapse" for="c-42336547">[-]</label><label class="expand" for="c-42336547">[1 more]</label></div><br/><div class="children"><div class="content">For constraint programming solvers, you need to define a model (i.e. what are the variables that the solver can change). Typically, a good model naturally enforces hard constraints. For instance, consider the employee scheduling problem, where you have a list of shifts that need to be assigned a single employee. Two possible models for it are:<p>- Use a boolean variable that is true if and only if a particular employee is assigned to a particular shift. For 2 shifts (A, B) and 2 employees (Amy, Beth), the variables would be Amy_A, Amy_B, Beth_A, Beth_B<p>- Use an int variable, where each employee is mapped to a number. For 2 shifts (A, B) and 3 employees (Amy, Beth, Carl), the variables would be A, B (which will have value 0 for Amy, 1 for Beth, 2 for Carl).<p>Using an int variable is usually better, since it automatically encodes the &quot;each shift must have exactly one employee constraint&quot; which would otherwise need to be added. That being said, sometimes the boolean model is used so a SAT solver can be used instead of a Integer Linear Programming Solver.<p>Typically, for theorem based solvers (such as Z3 or OR Tools), you add a group of similar constraints in a loop where you iterate through relevant variables. For instance, to add constraints for overlapping shifts, you would have a directory mapping each shift to the shifts its overlaps, and add a not equals constraint for each pair (since if they are equal, they have the same employee, and employees usually are unable to be at two places at the same time).<p><pre><code>  for shift in shift_vars:
      for overlapping_shift in overlapping_shifts[shift]:
          solver.add(shift != overlapping_shift)
</code></pre>
There are also local search solvers, such as Timefold, which allows you use your domain objects and functions directly in your constraints. For instance, the above constraint would look like this:<p><pre><code>  @planning_entity
  @dataclass
  class Shift:
      employee: Annotated[Employee, PlanningVariable]
      start: datetime
      end: datetime
      
      def overlaps(self, other: &#x27;Shift&#x27;) -&gt; bool:
          return self.start &lt; other.end and other.start &lt; self.end
  
  def no_overlapping_shifts(constraint_factory: ConstraintFactory):
      return (constraint_factory.for_each(Shift)
                                .join(Shift,
                                      Joiners.equal(lambda shift: shift.employee))
                                .filter(lambda a, b: a.overlaps(b))
                                .penalize(HardSoftScore.ONE_HARD)
                                .as_constraint(&#x27;Overlapping Shift&#x27;))
</code></pre>
Disclosure: I work for Timefold</div><br/></div></div><div id="42333094" class="c"><input type="checkbox" id="c-42333094" checked=""/><div class="controls bullet"><span class="by">porcoda</span><span>|</span><a href="#42332967">parent</a><span>|</span><a href="#42336547">prev</a><span>|</span><a href="#42333308">next</a><span>|</span><label class="collapse" for="c-42333094">[-]</label><label class="expand" for="c-42333094">[1 more]</label></div><br/><div class="children"><div class="content">Read up on smt-lib: learning how to encode problems in that is a good way to start.  The Python z3 bindings are a good starting point to play with it too.</div><br/></div></div><div id="42333308" class="c"><input type="checkbox" id="c-42333308" checked=""/><div class="controls bullet"><span class="by">Klaus23</span><span>|</span><a href="#42332967">parent</a><span>|</span><a href="#42333094">prev</a><span>|</span><a href="#42333936">next</a><span>|</span><label class="collapse" for="c-42333308">[-]</label><label class="expand" for="c-42333308">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;smt.st&#x2F;SAT_SMT_by_example.pdf" rel="nofollow">https:&#x2F;&#x2F;smt.st&#x2F;SAT_SMT_by_example.pdf</a></div><br/></div></div><div id="42333936" class="c"><input type="checkbox" id="c-42333936" checked=""/><div class="controls bullet"><span class="by">drdrey</span><span>|</span><a href="#42332967">parent</a><span>|</span><a href="#42333308">prev</a><span>|</span><a href="#42334007">next</a><span>|</span><label class="collapse" for="c-42333936">[-]</label><label class="expand" for="c-42333936">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;microsoft.github.io&#x2F;z3guide&#x2F;docs&#x2F;logic&#x2F;intro&#x2F;" rel="nofollow">https:&#x2F;&#x2F;microsoft.github.io&#x2F;z3guide&#x2F;docs&#x2F;logic&#x2F;intro&#x2F;</a></div><br/></div></div></div></div><div id="42334007" class="c"><input type="checkbox" id="c-42334007" checked=""/><div class="controls bullet"><span class="by">efangs</span><span>|</span><a href="#42332967">prev</a><span>|</span><label class="collapse" for="c-42334007">[-]</label><label class="expand" for="c-42334007">[1 more]</label></div><br/><div class="children"><div class="content">sorry this is not fast</div><br/></div></div></div></div></div></div></div></body></html>