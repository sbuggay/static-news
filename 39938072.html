<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712307649518" as="style"/><link rel="stylesheet" href="styles.css?v=1712307649518"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.openbsd.org/75.html">OpenBSD 7.5 Released</a> <span class="domain">(<a href="https://www.openbsd.org">www.openbsd.org</a>)</span></div><div class="subtext"><span>SoftTalker</span> | <span>11 comments</span></div><br/><div><div id="39939914" class="c"><input type="checkbox" id="c-39939914" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#39938640">next</a><span>|</span><label class="collapse" for="c-39939914">[-]</label><label class="expand" for="c-39939914">[3 more]</label></div><br/><div class="children"><div class="content">The removal of generic syscall(), and introduction of pinsyscalls() which registers the precise entry location of every system call used by a program, makes me think of some kernel-level ABI issues that Linux has.<p>In particular, kernel ABI is the main stable interface that Linux exposes - and all applications can just use syscalls directly without having to interface with the libc at all. However, that means that kernel must not change its ABI lest it risks breaking compatibility, and each functionality that isn&#x27;t implemented inside of the kernel (e.g. GUI stuff) cannot be implemented completely portably.<p>However, using pinsyscalls(), a kernel can make sure that syscalls can only be called from the libc - therefore, making the libc de-facto ABI! Which allows for much more freedom in changing kernel ABI, as long as the libc follows through. Perhaps this way the system can go away from the syscall-level ABI and move over to the libc ABI &#x2F; shared library ABI?</div><br/><div id="39940130" class="c"><input type="checkbox" id="c-39940130" checked=""/><div class="controls bullet"><span class="by">newpavlov</span><span>|</span><a href="#39939914">parent</a><span>|</span><a href="#39938640">next</a><span>|</span><label class="collapse" for="c-39940130">[-]</label><label class="expand" for="c-39940130">[2 more]</label></div><br/><div class="children"><div class="content">Honestly, I think that making libc THE system interface is a mistake. Ok, I understand issues with the Linux approach of exposing raw syscalls (though it works well enough in practice and ossification could be amended by some kind of syscall versioning scheme), but why in the world can&#x27;t you introduce libsystem&#x2F;libfreebsd which would contain only &quot;syscall&quot; functions? Why you need all the C junk in a library for talking with OS?</div><br/></div></div></div></div><div id="39938640" class="c"><input type="checkbox" id="c-39938640" checked=""/><div class="controls bullet"><span class="by">Panino</span><span>|</span><a href="#39939914">prev</a><span>|</span><a href="#39939756">next</a><span>|</span><label class="collapse" for="c-39938640">[-]</label><label class="expand" for="c-39938640">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m currently switching my Go code to Rust in part because of the syscall related Go trouble:<p>&gt;  Users of syscall(2), such as Perl and the Go programming language were converted to use the libc functions.<p>I think the following may still need to be converted:<p><pre><code>  * unix.Pledge from golang.org&#x2F;x&#x2F;sys&#x2F;unix
  * unix.Unveil from golang.org&#x2F;x&#x2F;sys&#x2F;unix
  * terminal.ReadPassword from golang.org&#x2F;x&#x2F;crypto&#x2F;ssh&#x2F;terminal</code></pre></div><br/><div id="39940173" class="c"><input type="checkbox" id="c-39940173" checked=""/><div class="controls bullet"><span class="by">qweqwe14</span><span>|</span><a href="#39938640">parent</a><span>|</span><a href="#39939756">next</a><span>|</span><label class="collapse" for="c-39940173">[-]</label><label class="expand" for="c-39940173">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t Go already realize that it can&#x27;t use direct syscalls on anything other than Linux? They made some mistakes in the past but by this point I think they learned their lesson.<p>On Linux, using direct syscalls is a good idea, since it&#x27;s <i>the</i> stable userspace-kernel interface. There&#x27;s really no need for libc on Linux, each language should just implement it&#x27;s standard library on top of syscalls.</div><br/></div></div></div></div><div id="39939756" class="c"><input type="checkbox" id="c-39939756" checked=""/><div class="controls bullet"><span class="by">a-french-anon</span><span>|</span><a href="#39938640">prev</a><span>|</span><a href="#39938193">next</a><span>|</span><label class="collapse" for="c-39939756">[-]</label><label class="expand" for="c-39939756">[3 more]</label></div><br/><div class="children"><div class="content">Does anyone know if there&#x27;s any plan to reintroduce xattrs in FFS2? Probably the only modern UNIX without it in its main FS(s).<p>Or for a more standard&#x2F;modern FS like XFS (I don&#x27;t expect OpenBSD to go for ZFS bloat).</div><br/><div id="39939808" class="c"><input type="checkbox" id="c-39939808" checked=""/><div class="controls bullet"><span class="by">ByQuyzzy</span><span>|</span><a href="#39939756">parent</a><span>|</span><a href="#39938193">next</a><span>|</span><label class="collapse" for="c-39939808">[-]</label><label class="expand" for="c-39939808">[2 more]</label></div><br/><div class="children"><div class="content">They made their FFS 64-bit. That’s what you get. And FFS is <i>THE</i> standard.<p>In short no. Also they removed softupdates, code was old and slow and was holding back the quest to unlock.</div><br/><div id="39940018" class="c"><input type="checkbox" id="c-39940018" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#39939756">root</a><span>|</span><a href="#39939808">parent</a><span>|</span><a href="#39938193">next</a><span>|</span><label class="collapse" for="c-39940018">[-]</label><label class="expand" for="c-39940018">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And FFS is THE standard<p>What&#x27;s that supposed to mean? ed is the standard text editor, yet we don&#x27;t actually expect anyone to use it (let alone know it...)</div><br/></div></div></div></div></div></div><div id="39938193" class="c"><input type="checkbox" id="c-39938193" checked=""/><div class="controls bullet"><span class="by">brynet</span><span>|</span><a href="#39939756">prev</a><span>|</span><a href="#39939777">next</a><span>|</span><label class="collapse" for="c-39938193">[-]</label><label class="expand" for="c-39938193">[1 more]</label></div><br/><div class="children"><div class="content">Announcement mail: <a href="https:&#x2F;&#x2F;marc.info&#x2F;?l=openbsd-announce&amp;m=171228270018970&amp;w=2" rel="nofollow">https:&#x2F;&#x2F;marc.info&#x2F;?l=openbsd-announce&amp;m=171228270018970&amp;w=2</a></div><br/></div></div><div id="39939777" class="c"><input type="checkbox" id="c-39939777" checked=""/><div class="controls bullet"><span class="by">omnibrain</span><span>|</span><a href="#39938193">prev</a><span>|</span><label class="collapse" for="c-39939777">[-]</label><label class="expand" for="c-39939777">[1 more]</label></div><br/><div class="children"><div class="content">No song this time.</div><br/></div></div></div></div></div></div></div></body></html>