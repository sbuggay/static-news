<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737536470554" as="style"/><link rel="stylesheet" href="styles.css?v=1737536470554"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://v5.chriskrycho.com/journal/essence-of-successful-abstractions/">Isolating complexity is the essence of successful abstractions</a> <span class="domain">(<a href="https://v5.chriskrycho.com">v5.chriskrycho.com</a>)</span></div><div class="subtext"><span>chriskrycho</span> | <span>26 comments</span></div><br/><div><div id="42790243" class="c"><input type="checkbox" id="c-42790243" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#42789066">next</a><span>|</span><label class="collapse" for="c-42790243">[-]</label><label class="expand" for="c-42790243">[4 more]</label></div><br/><div class="children"><div class="content">I think &quot;types&quot; is the solution of two completely different problems:<p>1. how to specify memory layout for faster execution<p>2. how to give hint when I press . in IDEs<p>if you use typing outside these two scopes you&#x27;d probably find many troubles.</div><br/><div id="42790640" class="c"><input type="checkbox" id="c-42790640" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#42790243">parent</a><span>|</span><a href="#42790584">next</a><span>|</span><label class="collapse" for="c-42790640">[-]</label><label class="expand" for="c-42790640">[1 more]</label></div><br/><div class="children"><div class="content">3. Compile time safety.<p>That’s what I use types mostly for. I don’t care about compiler hints, well structured code with sane naming conventions solves that problem without the need for types. But I do want my program to fail to compile (or in JIT-land, fail unit tests &#x2F; CICD) when I do something stupid with a variable.<p>The former is about typing speed and I already type faster than I think. The latter is about guardrails protecting me from my own human error. And that is a far more realistic problem than my IDE performance.</div><br/></div></div><div id="42790584" class="c"><input type="checkbox" id="c-42790584" checked=""/><div class="controls bullet"><span class="by">grues-dinner</span><span>|</span><a href="#42790243">parent</a><span>|</span><a href="#42790640">prev</a><span>|</span><a href="#42790383">next</a><span>|</span><label class="collapse" for="c-42790584">[-]</label><label class="expand" for="c-42790584">[1 more]</label></div><br/><div class="children"><div class="content">Types imbue pure data with meaning. That&#x27;s pretty much it, and the other uses of types flow from that.<p>Whether you use that meaning to produce IDE hints (say, via Python type annotations, though I am aware Python typing isn&#x27;t only that), or you feed it to a compiler that promises that it will ruthlessly statically enforce the invariants you set via the types, or anything else, is up to you, your goal and the language you use.</div><br/></div></div><div id="42790383" class="c"><input type="checkbox" id="c-42790383" checked=""/><div class="controls bullet"><span class="by">acchow</span><span>|</span><a href="#42790243">parent</a><span>|</span><a href="#42790584">prev</a><span>|</span><a href="#42789066">next</a><span>|</span><label class="collapse" for="c-42790383">[-]</label><label class="expand" for="c-42790383">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if you use typing outside these two scopes you&#x27;d probably find many troubles.<p>- encoding invariants and define valid evolutions of the codebase<p>- memory safety without a garbage collector (see Rust’s Affine type system)</div><br/></div></div></div></div><div id="42789066" class="c"><input type="checkbox" id="c-42789066" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#42790243">prev</a><span>|</span><a href="#42789011">next</a><span>|</span><label class="collapse" for="c-42789066">[-]</label><label class="expand" for="c-42789066">[10 more]</label></div><br/><div class="children"><div class="content">I don’t think I agree that either typescript nor rust successfully hide the complexity in their type systems.<p>By the nature of type systems, they are tightly coupled with the code written around them.<p>Rust has rich features to handle this coupling (traits and derives), but typescript does not.</div><br/><div id="42789823" class="c"><input type="checkbox" id="c-42789823" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#42789066">parent</a><span>|</span><a href="#42789865">next</a><span>|</span><label class="collapse" for="c-42789823">[-]</label><label class="expand" for="c-42789823">[4 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t get the general idea that the author thought they hid the complexity, but rather that they exposed and codified it. They gave the complexity that would previously live in your head somewhere it could be expressed. And once expressed, it can be iterated on.</div><br/><div id="42789914" class="c"><input type="checkbox" id="c-42789914" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#42789066">root</a><span>|</span><a href="#42789823">parent</a><span>|</span><a href="#42789865">next</a><span>|</span><label class="collapse" for="c-42789914">[-]</label><label class="expand" for="c-42789914">[3 more]</label></div><br/><div class="children"><div class="content">Encoding complexity in your type system forces you to deal with that complexity throughout your codebase. It doesn’t give complexity a specific place to live.</div><br/><div id="42790058" class="c"><input type="checkbox" id="c-42790058" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#42789066">root</a><span>|</span><a href="#42789914">parent</a><span>|</span><a href="#42789865">next</a><span>|</span><label class="collapse" for="c-42790058">[-]</label><label class="expand" for="c-42790058">[2 more]</label></div><br/><div class="children"><div class="content">You were going to have to deal with that complexity either way.<p>Now it&#x27;s expressed somewhere, and if you craft it right, enforced so it&#x27;s harder to get things wrong.<p><a href="https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-validate&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-va...</a></div><br/><div id="42790212" class="c"><input type="checkbox" id="c-42790212" checked=""/><div class="controls bullet"><span class="by">BigJono</span><span>|</span><a href="#42789066">root</a><span>|</span><a href="#42790058">parent</a><span>|</span><a href="#42789865">next</a><span>|</span><label class="collapse" for="c-42790212">[-]</label><label class="expand" for="c-42790212">[1 more]</label></div><br/><div class="children"><div class="content">This view has always been bullshit. It doesn&#x27;t differentiate between the complexity of the types themselves and the complexity of representing them in a static type system.</div><br/></div></div></div></div></div></div></div></div><div id="42789865" class="c"><input type="checkbox" id="c-42789865" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#42789066">parent</a><span>|</span><a href="#42789823">prev</a><span>|</span><a href="#42789843">next</a><span>|</span><label class="collapse" for="c-42789865">[-]</label><label class="expand" for="c-42789865">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about hiding the complexity in the type system, that is, the complexity <i>of</i> the type system. At least for Rust, it&#x27;s about that (yes, complex) type system isolating the even worse complexity of tracking lifetimes and aliasing and such, for all possible control flow paths, in your head.<p>It&#x27;s harder to summarize what Typescript is isolating, except that JavaScript function signatures are the flipping wild west and the type system has to model most of that complexity. It tends to produce very leaky abstractions in my experience unless you put in a lot of work.</div><br/></div></div><div id="42789843" class="c"><input type="checkbox" id="c-42789843" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#42789066">parent</a><span>|</span><a href="#42789865">prev</a><span>|</span><a href="#42789782">next</a><span>|</span><label class="collapse" for="c-42789843">[-]</label><label class="expand" for="c-42789843">[3 more]</label></div><br/><div class="children"><div class="content">The argument isn&#x27;t that complexity is being hidden, but how it&#x27;s managed and where it shows up in your experience of solving other problems. OP mentions:<p>&gt; The complexity was always there... it merely shone a light on the existing complexity, and gave us the opportunity — and a tool with which — to start grappling with it<p>It&#x27;s not about Rust vs. TypeScript per se but uses garbage collection and borrow checker as examples of two solutions to the same problem. For whatever task you have at hand, what abstractions offer the best value that lets you finish the solution to  the satisfaction of constraints?<p>&gt; they are tightly coupled with the code written around them<p>Which is where the cost of the abstractions comes in. Part of the struggle is when the software becomes more complicated to manage than the problems solved and abstractions move from benefit to liability. The abstractions of the stack prevent solving problems in a way that isn&#x27;t bound to our dancing around them.<p>If I&#x27;m working on a high-throughput networked service shuffling bytes using Protobuf, I&#x27;m going to be fighting Node to get the most out of CPU and memory. If I&#x27;m writing CRUD code in Rust shuffling JSON into an RDBMS I&#x27;m going to spending more time writing and thinking about types than I would just shuffling around arbitrarily nested bag-of-bags in Python with compute to spare.<p>I always thought this was why microservices became popular, because it constrained the problem space of any one project so language abstractions remained net-positives.</div><br/><div id="42789900" class="c"><input type="checkbox" id="c-42789900" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#42789066">root</a><span>|</span><a href="#42789843">parent</a><span>|</span><a href="#42789782">next</a><span>|</span><label class="collapse" for="c-42789900">[-]</label><label class="expand" for="c-42789900">[2 more]</label></div><br/><div class="children"><div class="content">&gt; how it&#x27;s managed and where it shows up in your experience of solving other problems<p>That’s what I’m talking about. Encoding complexity in your types does not manage where that complexity lives or where you have to deal with it.<p>It forces you to deal with that complexity everywhere in your codebase.</div><br/><div id="42790124" class="c"><input type="checkbox" id="c-42790124" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#42789066">root</a><span>|</span><a href="#42789900">parent</a><span>|</span><a href="#42789782">next</a><span>|</span><label class="collapse" for="c-42790124">[-]</label><label class="expand" for="c-42790124">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It forces you to deal with that complexity everywhere in your codebase.<p>The alternative is fighting the abstraction. Imagine trying to write the Linux Kernel in JavaScript or Python. Lot less fighting types in your code, more time fighting the abstractions to achieve other things. Considering a big part of the kernel is types it makes sense to encode complexity within them.<p>Going &quot;low-level&quot; implies that you&#x27;re abandoning abstractions to use all the tools in the CS and compute toolbox and the baggage that entails.</div><br/></div></div></div></div></div></div><div id="42789782" class="c"><input type="checkbox" id="c-42789782" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#42789066">parent</a><span>|</span><a href="#42789843">prev</a><span>|</span><a href="#42789011">next</a><span>|</span><label class="collapse" for="c-42789782">[-]</label><label class="expand" for="c-42789782">[1 more]</label></div><br/><div class="children"><div class="content">Type systems like in Rust may introduce their own complexities, but they also help you tackle the complexity of bigger programs if wielded correctly.<p>Typesystems can be complex to use, but in the end they constrain the degrees of freedom exposed by any given piece of code. With a type systems only very specific things can happen with any part of your code, most of which the programmer may have had in mind — without a type system the number of ways any piece of code could act within the program is way larger. Reducing the possible states of your program in the case of programming error <i>is</i> a reduction of complexity.<p>Now I don&#x27;t say type systems may introduce their own complexity, but in the case of Rust the complexity exposed is what systems programmers should handle. E.g. using different String types to signify to the programmer that your OS will not allow all possible strings as file names is the appropriate amount of complexity. Knowing how your program handles these is again reducing complexity.<p>Imagine you wrote a module in a language where you don&#x27;t handle these. Every now and then the module crashes specifically because it came across a malformed filename. Or phrased differently: The program does <i>more</i> than you intended, namely crashing when it encounters certain filenames. Good luck figuring that out and preventing it from happening again. With a type system the choice had to be explicitly made during programming already. Less things you code can do, less complexity.<p>Many developers confuse complexity of the internal workings of a program with the complexity of the program exposed at the interface. These are separate properties that <i>could</i> become linked, but shouldn&#x27;t.</div><br/></div></div></div></div><div id="42789011" class="c"><input type="checkbox" id="c-42789011" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#42789066">prev</a><span>|</span><a href="#42790232">next</a><span>|</span><label class="collapse" for="c-42789011">[-]</label><label class="expand" for="c-42789011">[2 more]</label></div><br/><div class="children"><div class="content">Python showed what relaxed types could do.  And we could go a long way as it turns out without types.  But there are use cases for types, and even python admitted such when they added type annotations.<p>However, when I was a kid a would put a firecracker next to an object.  I didn&#x27;t bother running the scenario through a compiler to see if the object was of type Explodable() and had an explode() method that would be called.</div><br/><div id="42789471" class="c"><input type="checkbox" id="c-42789471" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42789011">parent</a><span>|</span><a href="#42790232">next</a><span>|</span><label class="collapse" for="c-42789471">[-]</label><label class="expand" for="c-42789471">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However, when I was a kid a would put a firecracker next to an object. I didn&#x27;t bother running the scenario through a compiler to see if the object was of type Explodable() and had an explode() method that would be called.<p>Duck typing: if it quacks like a duck, and it explodes objects next to it, it&#x27;s a firequacker</div><br/></div></div></div></div><div id="42790232" class="c"><input type="checkbox" id="c-42790232" checked=""/><div class="controls bullet"><span class="by">timewizard</span><span>|</span><a href="#42789011">prev</a><span>|</span><a href="#42788232">next</a><span>|</span><label class="collapse" for="c-42790232">[-]</label><label class="expand" for="c-42790232">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Complexity has to live somewhere. If you are lucky, it lives in well-defined places.<p>This whole section makes me think of construction which has similar abstraction and hidden complexity problems.  It strikes me that they solve it by having design be entirely separate from implementation.  Which is usually the corner where all our luck as software developers inevitably runs out.<p>Our methods are still rather &quot;cowboy.&quot;  We have cool &quot;modernized cowboy&quot; languages that make it hard to shoot your foot off,  but at the end of the day,  we&#x27;re still just riding old horses and hoping for the best.</div><br/><div id="42790661" class="c"><input type="checkbox" id="c-42790661" checked=""/><div class="controls bullet"><span class="by">wmwragg</span><span>|</span><a href="#42790232">parent</a><span>|</span><a href="#42788232">next</a><span>|</span><label class="collapse" for="c-42790661">[-]</label><label class="expand" for="c-42790661">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve often thought this. It feels like there should be two languages, one for the implementation of the parts, and another to design&#x2F;architect the software using the parts, allowing the design&#x2F;architect language to focus on the high level architecture of the software and the implementation language to focus on the parts. We currently use the same language for both, and mix the two areas as we program</div><br/></div></div></div></div><div id="42788232" class="c"><input type="checkbox" id="c-42788232" checked=""/><div class="controls bullet"><span class="by">gsf_emergency</span><span>|</span><a href="#42790232">prev</a><span>|</span><a href="#42789433">next</a><span>|</span><label class="collapse" for="c-42788232">[-]</label><label class="expand" for="c-42788232">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>The question is first of all whether we have written them down anywhere</i><p>The only hard thing in software: papers please (easily accessible  documentation)</div><br/></div></div><div id="42789433" class="c"><input type="checkbox" id="c-42789433" checked=""/><div class="controls bullet"><span class="by">PittleyDunkin</span><span>|</span><a href="#42788232">prev</a><span>|</span><a href="#42789607">next</a><span>|</span><label class="collapse" for="c-42789433">[-]</label><label class="expand" for="c-42789433">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Parameterizing complexity&quot; is probably a better way to say it. There&#x27;s no isolation when it comes to software.</div><br/><div id="42789546" class="c"><input type="checkbox" id="c-42789546" checked=""/><div class="controls bullet"><span class="by">hackit2</span><span>|</span><a href="#42789433">parent</a><span>|</span><a href="#42790196">next</a><span>|</span><label class="collapse" for="c-42789546">[-]</label><label class="expand" for="c-42789546">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it is anything to do with complexity, or grouping code&#x2F;data, its just a natural tendency of people to categorize things together that display a high degree of class inclusion. And some categories are easier to deal with than others.</div><br/></div></div><div id="42790196" class="c"><input type="checkbox" id="c-42790196" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#42789433">parent</a><span>|</span><a href="#42789546">prev</a><span>|</span><a href="#42789607">next</a><span>|</span><label class="collapse" for="c-42790196">[-]</label><label class="expand" for="c-42790196">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if I agree<p>Let&#x27;s say you have a poem program, that reads files from your drive and turns them into poems. A well isolated&#x2F;abstracted variant of that program is as simple as a blackbox with two or three inputs and a single output.<p>One of the inputs are the files, the others might be a configuration file or user adjustable parameters like length. The program is well isolated if you can&#x27;t give it <i>any</i> combination of inputs that doesn&#x27;t produce a poem or an error message related to the usage of the program.<p>A badly isolated variant of the same program would be one where the user had to think a lot about the internal behavior of the program, e.g. how file names are handled or where so many parameters of the poem generation have to be supplied as parameters, that the user essentially has to rewrite the core of program with their parameters. Or the user could supply a file that allows them to gain RCE or crash the program.</div><br/></div></div></div></div><div id="42789607" class="c"><input type="checkbox" id="c-42789607" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42789433">prev</a><span>|</span><a href="#42788202">next</a><span>|</span><label class="collapse" for="c-42789607">[-]</label><label class="expand" for="c-42789607">[1 more]</label></div><br/><div class="children"><div class="content">I have always felt that it&#x27;s better to &quot;concentrate&quot; complexity into one key component and make the rest of the codebase simple than to distribute complexity evenly everywhere in some kind of open-coded swamp.</div><br/></div></div><div id="42788202" class="c"><input type="checkbox" id="c-42788202" checked=""/><div class="controls bullet"><span class="by">picografix</span><span>|</span><a href="#42789607">prev</a><span>|</span><a href="#42788311">next</a><span>|</span><label class="collapse" for="c-42788202">[-]</label><label class="expand" for="c-42788202">[1 more]</label></div><br/><div class="children"><div class="content">complexity has to live somewhere, code anxiety was a real thing for me</div><br/></div></div></div></div></div></div></div></body></html>