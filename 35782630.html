<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683040924099" as="style"/><link rel="stylesheet" href="styles.css?v=1683040924099"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://sysprog21.github.io/lkmpg/">The Linux Kernel Module Programming Guide</a>Â <span class="domain">(<a href="https://sysprog21.github.io">sysprog21.github.io</a>)</span></div><div class="subtext"><span>asicsp</span> | <span>28 comments</span></div><br/><div><div id="35783473" class="c"><input type="checkbox" id="c-35783473" checked=""/><div class="controls bullet"><span class="by">pushedx</span><span>|</span><a href="#35782936">next</a><span>|</span><label class="collapse" for="c-35783473">[-]</label><label class="expand" for="c-35783473">[4 more]</label></div><br/><div class="children"><div class="content">Many things that you may have wanted to do with a kernel module can now be done more easily and safely with eBPF.<p><a href="https:&#x2F;&#x2F;ebpf.io&#x2F;get-started&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ebpf.io&#x2F;get-started&#x2F;</a><p>Nevertheless, the OP is a classic guide and worth a read.</div><br/><div id="35786150" class="c"><input type="checkbox" id="c-35786150" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#35783473">parent</a><span>|</span><a href="#35786095">next</a><span>|</span><label class="collapse" for="c-35786150">[-]</label><label class="expand" for="c-35786150">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Nevertheless, the OP is a classic guide and worth a read.<p>For anyone curious why a book published in 2023 is being called a &quot;classic&quot;, it appears to be a republication (possible update) of <a href="https:&#x2F;&#x2F;tldp.org&#x2F;LDP&#x2F;lkmpg&#x2F;2.6&#x2F;lkmpg.pdf" rel="nofollow">https:&#x2F;&#x2F;tldp.org&#x2F;LDP&#x2F;lkmpg&#x2F;2.6&#x2F;lkmpg.pdf</a> from 2001<p>There are 2 new authors listed so I&#x27;m assuming the content has been refreshed</div><br/></div></div><div id="35786095" class="c"><input type="checkbox" id="c-35786095" checked=""/><div class="controls bullet"><span class="by">tetris11</span><span>|</span><a href="#35783473">parent</a><span>|</span><a href="#35786150">prev</a><span>|</span><a href="#35782936">next</a><span>|</span><label class="collapse" for="c-35786095">[-]</label><label class="expand" for="c-35786095">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty tidy. Is there any noticeable overhead in listening to all kernel sockets and hooking in your code when it matches a packet filter, compared to just building it into the kernel?</div><br/><div id="35787948" class="c"><input type="checkbox" id="c-35787948" checked=""/><div class="controls bullet"><span class="by">bjackman</span><span>|</span><a href="#35783473">root</a><span>|</span><a href="#35786095">parent</a><span>|</span><a href="#35782936">next</a><span>|</span><label class="collapse" for="c-35787948">[-]</label><label class="expand" for="c-35787948">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty damm fast. Everything is JITed and there&#x27;s codegen for the &quot;trampoline&quot; logic so that there aren&#x27;t even indirect branches to get to the program code.<p>The &quot;overhead&quot; comes from the fact that writing nontrivial BPF programs is quite hard. Getting programs to pass the verifier can become a bit of an art. This does tend to get easier if your production environment has few and recent kernel versions.<p>And then of course this &quot;overhead&quot; totally pays for itself in terms of reliability. It&#x27;s really hard to accidentally break machines with BPF, while a kernel module in your prod environment is a time bomb :D<p>(Deliberately breaking machines with BPF is very easy though. This sometimes seems to surprise people but if your attacker gets CAP_BPF it&#x27;s probably game over).</div><br/></div></div></div></div></div></div><div id="35782936" class="c"><input type="checkbox" id="c-35782936" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#35783473">prev</a><span>|</span><a href="#35783110">next</a><span>|</span><label class="collapse" for="c-35782936">[-]</label><label class="expand" for="c-35782936">[4 more]</label></div><br/><div class="children"><div class="content">This... is really helpful. I&#x27;ve been trying to contribute some drivers for Pine64 devices lately and am trying to get up to speed on Linux Kernel development. There&#x27;s... a lot.<p>Does anyone know if this is up to date with current Linux best practices?</div><br/><div id="35783039" class="c"><input type="checkbox" id="c-35783039" checked=""/><div class="controls bullet"><span class="by">smashed</span><span>|</span><a href="#35782936">parent</a><span>|</span><a href="#35784083">next</a><span>|</span><label class="collapse" for="c-35783039">[-]</label><label class="expand" for="c-35783039">[1 more]</label></div><br/><div class="children"><div class="content">According to the github readme, the guide has been around since 2001 but it seems fairly up to date..<p>There are numerous discussion going on the issue tracker, about adding rust chapter, targeting linux 6.1, etc.. Very cool to see github issues and pull request actively used to keep a guide up to date.<p>The guide will walk you through the basic of a kernel module. Exposing virtual files under &#x2F;proc or &#x2F;sys or messing around with system calls. It will fall short of helping you with the nitty gritty of writing an hardware driver though.<p>The problem with writing drivers is that you are interfacing with a real-world machine for which you will have very little information about.<p>Pick a device similar to the one you want to support, but that is already supported in linux. Go look at its source code. This will tell you far more about the work involved. You might realize that there is simply not enough information available to support the driver.</div><br/></div></div><div id="35784083" class="c"><input type="checkbox" id="c-35784083" checked=""/><div class="controls bullet"><span class="by">megous</span><span>|</span><a href="#35782936">parent</a><span>|</span><a href="#35783039">prev</a><span>|</span><a href="#35783110">next</a><span>|</span><label class="collapse" for="c-35784083">[-]</label><label class="expand" for="c-35784083">[2 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s not uptodate. But it&#x27;s probably good enough to learn about basic concepts. For the devices you&#x27;re talking about, you&#x27;ll need to learn about device trees (didn&#x27;t exist in 2001 at all in Linux), power management, etc.</div><br/><div id="35787615" class="c"><input type="checkbox" id="c-35787615" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#35782936">root</a><span>|</span><a href="#35784083">parent</a><span>|</span><a href="#35783110">next</a><span>|</span><label class="collapse" for="c-35787615">[-]</label><label class="expand" for="c-35787615">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been reading up on DTS stuff already, there&#x27;s <i>some</i> resources out there, but all of the &quot;kernel developer guides&quot; seem to predate that by a fair bit. I suppose I&#x27;ll have to familiarize myself with U-Boot as well...</div><br/></div></div></div></div></div></div><div id="35783110" class="c"><input type="checkbox" id="c-35783110" checked=""/><div class="controls bullet"><span class="by">asicsp</span><span>|</span><a href="#35782936">prev</a><span>|</span><a href="#35785604">next</a><span>|</span><label class="collapse" for="c-35783110">[-]</label><label class="expand" for="c-35783110">[1 more]</label></div><br/><div class="children"><div class="content">Previous discussions:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28036619" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28036619</a> <i>(154 points | Aug 2, 2021 | 30 comments)</i><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28283030" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28283030</a> <i>(339 points | Aug 23, 2021 | 42 comments)</i><p>See also: <a href="https:&#x2F;&#x2F;0xax.gitbooks.io&#x2F;linux-insides&#x2F;content&#x2F;" rel="nofollow">https:&#x2F;&#x2F;0xax.gitbooks.io&#x2F;linux-insides&#x2F;content&#x2F;</a> (A book-in-progress about the linux kernel and its insides)</div><br/></div></div><div id="35785604" class="c"><input type="checkbox" id="c-35785604" checked=""/><div class="controls bullet"><span class="by">ejolto</span><span>|</span><a href="#35783110">prev</a><span>|</span><a href="#35783086">next</a><span>|</span><label class="collapse" for="c-35785604">[-]</label><label class="expand" for="c-35785604">[1 more]</label></div><br/><div class="children"><div class="content">Neat! will this finally replace the outdated Linux Device Drivers Third Edition as the de-facto standard reference book for building kernel modules?<p><a href="https:&#x2F;&#x2F;lwn.net&#x2F;Kernel&#x2F;LDD3&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Kernel&#x2F;LDD3&#x2F;</a></div><br/></div></div><div id="35783086" class="c"><input type="checkbox" id="c-35783086" checked=""/><div class="controls bullet"><span class="by">totetsu</span><span>|</span><a href="#35785604">prev</a><span>|</span><a href="#35786163">next</a><span>|</span><label class="collapse" for="c-35783086">[-]</label><label class="expand" for="c-35783086">[1 more]</label></div><br/><div class="children"><div class="content">I always liked the Hitchhikers Guide to Kernel module programming, with DONT PANIC on the cover.</div><br/></div></div><div id="35786163" class="c"><input type="checkbox" id="c-35786163" checked=""/><div class="controls bullet"><span class="by">lavventura</span><span>|</span><a href="#35783086">prev</a><span>|</span><a href="#35784678">next</a><span>|</span><label class="collapse" for="c-35786163">[-]</label><label class="expand" for="c-35786163">[1 more]</label></div><br/><div class="children"><div class="content">This is really helpful. Beyond that its open LaTeX format can be used for documentation, which I will do for my own work.</div><br/></div></div><div id="35784678" class="c"><input type="checkbox" id="c-35784678" checked=""/><div class="controls bullet"><span class="by">uraura</span><span>|</span><a href="#35786163">prev</a><span>|</span><a href="#35783214">next</a><span>|</span><label class="collapse" for="c-35784678">[-]</label><label class="expand" for="c-35784678">[1 more]</label></div><br/><div class="children"><div class="content">This one is also good.<p><a href="https:&#x2F;&#x2F;linux-kernel-labs.github.io&#x2F;refs&#x2F;heads&#x2F;master&#x2F;so2&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;linux-kernel-labs.github.io&#x2F;refs&#x2F;heads&#x2F;master&#x2F;so2&#x2F;in...</a></div><br/></div></div><div id="35783214" class="c"><input type="checkbox" id="c-35783214" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#35784678">prev</a><span>|</span><a href="#35783059">next</a><span>|</span><label class="collapse" for="c-35783214">[-]</label><label class="expand" for="c-35783214">[11 more]</label></div><br/><div class="children"><div class="content">Ctrl-F &quot;rust&quot;<p><a href="https:&#x2F;&#x2F;rust-for-linux.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rust-for-linux.com&#x2F;</a> links to LWN articles at <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Kernel&#x2F;Index&#x2F;#Development_tools-Rust" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Kernel&#x2F;Index&#x2F;#Development_tools-Rust</a> that suggest that only basic modules are yet possible with the rust support in Linux kernels 6.2 and 6.3.<p>Rust-for-linux links to the Android binder module though: <a href="https:&#x2F;&#x2F;rust-for-linux.com&#x2F;Android-Binder-Driver.html" rel="nofollow">https:&#x2F;&#x2F;rust-for-linux.com&#x2F;Android-Binder-Driver.html</a> :<p>&gt; Android Binder Driver: <i>This project is an effort to rewrite Android&#x27;s Binder kernel driver in Rust.</i><p>&gt; Motivation: <i>Binder is one of the most security and performance critical components of Android. Android isolates apps from each other and the system by assigning each app a unique user ID (UID). This is called &quot;application sandboxing&quot;, and is a fundamental tenet of the Android Platform Security Model.</i><p>&gt; <i>The majority of inter-process communication (IPC) on Android goes through Binder. Thus, memory unsafety vulnerabilities are especially critical when they happen in the Binder driver</i><p>... &quot;Rust in the Linux kernel&quot; (2021) <a href="https:&#x2F;&#x2F;security.googleblog.com&#x2F;2021&#x2F;04&#x2F;rust-in-linux-kernel.html?m=1" rel="nofollow">https:&#x2F;&#x2F;security.googleblog.com&#x2F;2021&#x2F;04&#x2F;rust-in-linux-kernel...</a> :<p>&gt; [...] <i>We also need designs that allow code in the two languages to interact with each other: we&#x27;re particularly interested in safe, zero-cost abstractions that allow Rust code to use kernel functionality written in C, and how to implement functionality in idiomatic Rust that can be called seamlessly from the C portions of the kernel.</i><p>&gt; <i>Since Rust is a new language for the kernel, we also have the opportunity to enforce best practices in terms of documentation and uniformity. For example, we have specific machine-checked requirements around the usage of unsafe code: for every unsafe function, the developer must document the requirements that need to be satisfied by callers to ensure that its usage is safe; additionally, for every call to unsafe functions (or usage of unsafe constructs like dereferencing a raw pointer), the developer must document the justification for why it is safe to do so.</i><p>&gt; <i>We&#x27;ll now show how such a driver would be implemented in Rust, contrasting it with a C implementation.</i> [...]<p>Is this the source for the rust port of the Android binder kernel module?: 
<a href="https:&#x2F;&#x2F;android.googlesource.com&#x2F;platform&#x2F;frameworks&#x2F;native&#x2F;+&#x2F;master&#x2F;libs&#x2F;binder&#x2F;rust&#x2F;src" rel="nofollow">https:&#x2F;&#x2F;android.googlesource.com&#x2F;platform&#x2F;frameworks&#x2F;native&#x2F;...</a><p>This guide with unsafe rust that calls into the C, and then with next gen much safer rust right next to it would be a helpful resource too.<p>What of the post-docker container support (with userspaces also written in go) should be cloned to rust first?<p>What are some good examples of non-trivial Linux kernel modules written in Rust?</div><br/><div id="35783241" class="c"><input type="checkbox" id="c-35783241" checked=""/><div class="controls bullet"><span class="by">piperswe</span><span>|</span><a href="#35783214">parent</a><span>|</span><a href="#35783783">next</a><span>|</span><label class="collapse" for="c-35783241">[-]</label><label class="expand" for="c-35783241">[1 more]</label></div><br/><div class="children"><div class="content">There aren&#x27;t really any non-trivial mainline modules, since the Rust support is so new. There&#x27;s the non-mainline Asahi M1 GPU driver though! It will eventually be mainlined, but IIRC some more Rust support code needs to be mainlined first.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;AsahiLinux&#x2F;linux&#x2F;tree&#x2F;asahi&#x2F;drivers&#x2F;gpu&#x2F;drm&#x2F;asahi">https:&#x2F;&#x2F;github.com&#x2F;AsahiLinux&#x2F;linux&#x2F;tree&#x2F;asahi&#x2F;drivers&#x2F;gpu&#x2F;d...</a></div><br/></div></div><div id="35783783" class="c"><input type="checkbox" id="c-35783783" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35783214">parent</a><span>|</span><a href="#35783241">prev</a><span>|</span><a href="#35783059">next</a><span>|</span><label class="collapse" for="c-35783783">[-]</label><label class="expand" for="c-35783783">[9 more]</label></div><br/><div class="children"><div class="content">On Android the Linux kernel is its own thing, and after Project Treble, it follows a microkernel like approach to drivers, where standard Linux drivers are considered &quot;legacy&quot; since Android 8.<p><a href="https:&#x2F;&#x2F;source.android.com&#x2F;docs&#x2F;core&#x2F;architecture&#x2F;hal" rel="nofollow">https:&#x2F;&#x2F;source.android.com&#x2F;docs&#x2F;core&#x2F;architecture&#x2F;hal</a><p>Don&#x27;t use how Linux kernel does things on Android as understanding from how upstream works.</div><br/><div id="35784121" class="c"><input type="checkbox" id="c-35784121" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#35783214">root</a><span>|</span><a href="#35783783">parent</a><span>|</span><a href="#35786389">next</a><span>|</span><label class="collapse" for="c-35784121">[-]</label><label class="expand" for="c-35784121">[2 more]</label></div><br/><div class="children"><div class="content">In your opinion, do you think that the microkernel approach is more secure? (Should processes run as separate users with separate SELinux contexts like Android 4.4+)<p>Why do you think that the Android binder module rust implementation is listed as an example of a Rust for Linux kernel module on the site?<p>&quot;Android AOSP Can Boot Off Mainline Linux 5.9 With Just One Patch&quot; (2020)
<a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Android-AOSP-Close-Linux-5.9" rel="nofollow">https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Android-AOSP-Close-Linux-5.9</a> :<p>&gt; <i>The Android open-source project &quot;AOSP&quot; with its latest code is very close to being able to boot off the mainline Linux kernel when assuming the device drivers are all upstream.</i><p>Other distros support kmods and akmods: 
<a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;PINE64official&#x2F;comments&#x2F;ijfbgl&#x2F;comment&#x2F;g3dqks6&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;PINE64official&#x2F;comments&#x2F;ijfbgl&#x2F;comm...</a> :<p>&gt; <i>How kmod &#x2F; akmod &#x2F;&#x2F; DKMS work is something that the community is maybe not real familiar with.</i></div><br/><div id="35784283" class="c"><input type="checkbox" id="c-35784283" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35783214">root</a><span>|</span><a href="#35784121">parent</a><span>|</span><a href="#35786389">next</a><span>|</span><label class="collapse" for="c-35784283">[-]</label><label class="expand" for="c-35784283">[1 more]</label></div><br/><div class="children"><div class="content">Of course microkernel approach is more secure, if a driver gets p0wned, corrupts data structures, or plain keeps crashing, it doesn&#x27;t take the whole kernel with it.<p>Naturally the issue might be as bad that the whole stack can&#x27;t recover from, but still much better than corrupting the kernel.<p>One of the SecDevOps guidelines when hardening servers is that every process should have its own user, yes.<p>Kmods and akmods run in kernel memory space and aren&#x27;t ABI stable.</div><br/></div></div></div></div><div id="35786389" class="c"><input type="checkbox" id="c-35786389" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#35783214">root</a><span>|</span><a href="#35783783">parent</a><span>|</span><a href="#35784121">prev</a><span>|</span><a href="#35784660">next</a><span>|</span><label class="collapse" for="c-35786389">[-]</label><label class="expand" for="c-35786389">[2 more]</label></div><br/><div class="children"><div class="content">I fear &quot;Project Treble&quot; may reduce incentives for vendors to upstream their drivers. Are there efforts to mainline it or the drivers currently using it?</div><br/><div id="35786755" class="c"><input type="checkbox" id="c-35786755" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35783214">root</a><span>|</span><a href="#35786389">parent</a><span>|</span><a href="#35784660">next</a><span>|</span><label class="collapse" for="c-35786755">[-]</label><label class="expand" for="c-35786755">[1 more]</label></div><br/><div class="children"><div class="content">The goal was to provide a stable ABI like non Linux OSes, with all the plus and minus it entails, not to upstream stuff.<p>Project Treble was only the begining, besides none of the PlayStore acceptance requirements forces the OEMs to update the drives.<p>Project Mainline followed Project Treble, where Android was further modularized.<p><a href="https:&#x2F;&#x2F;source.android.com&#x2F;docs&#x2F;core&#x2F;ota&#x2F;modular-system" rel="nofollow">https:&#x2F;&#x2F;source.android.com&#x2F;docs&#x2F;core&#x2F;ota&#x2F;modular-system</a><p>Followed by GSI (Generic System Images), where AOSP can be plugged alongside modular component packages, thus allowing OEMs a more Lego like experience to creating custom Android builds<p><a href="https:&#x2F;&#x2F;source.android.com&#x2F;docs&#x2F;setup&#x2F;create&#x2F;gsi" rel="nofollow">https:&#x2F;&#x2F;source.android.com&#x2F;docs&#x2F;setup&#x2F;create&#x2F;gsi</a></div><br/></div></div></div></div><div id="35784660" class="c"><input type="checkbox" id="c-35784660" checked=""/><div class="controls bullet"><span class="by">AndrzejNowak</span><span>|</span><a href="#35783214">root</a><span>|</span><a href="#35783783">parent</a><span>|</span><a href="#35786389">prev</a><span>|</span><a href="#35783059">next</a><span>|</span><label class="collapse" for="c-35784660">[-]</label><label class="expand" for="c-35784660">[4 more]</label></div><br/><div class="children"><div class="content">Binder is not a HAL, since binder is how HALs communicate with each other. It&#x27;s an actual proper Linux driver. The C version is in the upstream kernel as a module you can enable when building the kernel.</div><br/><div id="35787493" class="c"><input type="checkbox" id="c-35787493" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#35783214">root</a><span>|</span><a href="#35784660">parent</a><span>|</span><a href="#35784875">next</a><span>|</span><label class="collapse" for="c-35787493">[-]</label><label class="expand" for="c-35787493">[2 more]</label></div><br/><div class="children"><div class="content">Waydroid (Android in containers) requires binder and optionally ashmem, though ashmem is not required anymore because memfd works with vanilla kernel: <a href="https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Waydroid#Kernel_Modules" rel="nofollow">https:&#x2F;&#x2F;wiki.archlinux.org&#x2F;title&#x2F;Waydroid#Kernel_Modules</a><p>There is a Google Play Certification process for waydroid devices: <a href="https:&#x2F;&#x2F;docs.waydro.id&#x2F;faq&#x2F;google-play-certification" rel="nofollow">https:&#x2F;&#x2F;docs.waydro.id&#x2F;faq&#x2F;google-play-certification</a><p>(That manual provisioning step is not necessary for e.g. optional widevine DRM on other OSes)</div><br/><div id="35788341" class="c"><input type="checkbox" id="c-35788341" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#35783214">root</a><span>|</span><a href="#35787493">parent</a><span>|</span><a href="#35784875">next</a><span>|</span><label class="collapse" for="c-35788341">[-]</label><label class="expand" for="c-35788341">[1 more]</label></div><br/><div class="children"><div class="content">IIRC, when I tried to install LEGO Boost app (before I found pybricks and wokwi simulator) on Waydroid, I had trouble patching Bluetooth BLE on the host through to the waydroid container; due to device virtualization less than modules fwiu</div><br/></div></div></div></div><div id="35784875" class="c"><input type="checkbox" id="c-35784875" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#35783214">root</a><span>|</span><a href="#35784660">parent</a><span>|</span><a href="#35787493">prev</a><span>|</span><a href="#35783059">next</a><span>|</span><label class="collapse" for="c-35784875">[-]</label><label class="expand" for="c-35784875">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t change the fact that since Project Treble introduction, and Android 8, modern drivers live on their own processes.</div><br/></div></div></div></div></div></div></div></div><div id="35783059" class="c"><input type="checkbox" id="c-35783059" checked=""/><div class="controls bullet"><span class="by">bvan</span><span>|</span><a href="#35783214">prev</a><span>|</span><a href="#35786544">next</a><span>|</span><label class="collapse" for="c-35783059">[-]</label><label class="expand" for="c-35783059">[1 more]</label></div><br/><div class="children"><div class="content">Fantastic resource. Thanks for sharing.</div><br/></div></div></div></div></div></div></div></body></html>