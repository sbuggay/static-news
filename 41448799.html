<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725786069084" as="style"/><link rel="stylesheet" href="styles.css?v=1725786069084"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://hazelweakly.me/blog/pick-your-distributed-poison/">Pick Your Distributed Poison</a> <span class="domain">(<a href="https://hazelweakly.me">hazelweakly.me</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>14 comments</span></div><br/><div><div id="41477967" class="c"><input type="checkbox" id="c-41477967" checked=""/><div class="controls bullet"><span class="by">rubiquity</span><span>|</span><a href="#41478780">next</a><span>|</span><label class="collapse" for="c-41477967">[-]</label><label class="expand" for="c-41477967">[4 more]</label></div><br/><div class="children"><div class="content">I don’t agree with much in this writing other than that eventual consistency is a bad choice. Distributed systems are hard but in 2024 there are enough known patterns and techniques to make them less icky. Systems built on total ordering are much more tractable than weaker protocols. Mahesh Balakrishnan’s recent paper[0] on the Shared Log abstraction is a great recipe, for example.<p>As an aside, I’ve never enjoyed the defeatist culture that permeated operations and distributed systems pop culture, which this post seems to re-enforce.<p>0 - <a href="https:&#x2F;&#x2F;maheshba.bitbucket.io&#x2F;papers&#x2F;osr2024.pdf" rel="nofollow">https:&#x2F;&#x2F;maheshba.bitbucket.io&#x2F;papers&#x2F;osr2024.pdf</a></div><br/><div id="41479014" class="c"><input type="checkbox" id="c-41479014" checked=""/><div class="controls bullet"><span class="by">ffsm8</span><span>|</span><a href="#41477967">parent</a><span>|</span><a href="#41478069">next</a><span>|</span><label class="collapse" for="c-41479014">[-]</label><label class="expand" for="c-41479014">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don’t agree with much in this writing other than that eventual consistency is a bad choice<p>Does it really matter wherever is bad or not? As far as I know, every database that scales beyond a single node (for performance) is eventually consistent. Otherwise you&#x27;ve gotta wait for a sync between nodes before a response can be given, which would effectively force your cluster to have worse performance then running on single node again.</div><br/></div></div><div id="41478069" class="c"><input type="checkbox" id="c-41478069" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#41477967">parent</a><span>|</span><a href="#41479014">prev</a><span>|</span><a href="#41478780">next</a><span>|</span><label class="collapse" for="c-41478069">[-]</label><label class="expand" for="c-41478069">[2 more]</label></div><br/><div class="children"><div class="content">I think the defeatism comes from practicality. I&#x27;m at a 30 person IT org trying to do distributed systems and eventual consistency. Dont take on complexity unless you have to. And eventual consistency requires a LOT of scale before it becomes a have too.</div><br/><div id="41478776" class="c"><input type="checkbox" id="c-41478776" checked=""/><div class="controls bullet"><span class="by">delusional</span><span>|</span><a href="#41477967">root</a><span>|</span><a href="#41478069">parent</a><span>|</span><a href="#41478780">next</a><span>|</span><label class="collapse" for="c-41478776">[-]</label><label class="expand" for="c-41478776">[1 more]</label></div><br/><div class="children"><div class="content">I dont think it&#x27;s necessarily a question of scale. Where I work, we have a lost of strategic partnerships, and all those partners have their own it systems with their own master data. It&#x27;s intractable to enforce strong consistency between all of these disparate systems that don&#x27;t speak to one another, and you expressly dont want to take the whole substrate offline when a single parter has a network issue. The best you can do is really eventual consistency.</div><br/></div></div></div></div></div></div><div id="41478780" class="c"><input type="checkbox" id="c-41478780" checked=""/><div class="controls bullet"><span class="by">walterbell</span><span>|</span><a href="#41477967">prev</a><span>|</span><a href="#41478228">next</a><span>|</span><label class="collapse" for="c-41478780">[-]</label><label class="expand" for="c-41478780">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Reproducible and bootstrappable systems get a lot of love among neurodivergent people. For good reason: they’re very friendly to those with little working memory but vast amounts of working context.</i><p>This is novel yet obvious in retrospect, has it been articulated or surveyed elsewhere?</div><br/></div></div><div id="41478228" class="c"><input type="checkbox" id="c-41478228" checked=""/><div class="controls bullet"><span class="by">kukkeliskuu</span><span>|</span><a href="#41478780">prev</a><span>|</span><a href="#41477724">next</a><span>|</span><label class="collapse" for="c-41478228">[-]</label><label class="expand" for="c-41478228">[1 more]</label></div><br/><div class="children"><div class="content">Typically there are no guarantees that a distributed system with ”eventual consistency” is is in consistent state as a whole at any point in time. Downstream systems need to be built based on the assumption that the system is perpetually inconsistent.</div><br/></div></div><div id="41477724" class="c"><input type="checkbox" id="c-41477724" checked=""/><div class="controls bullet"><span class="by">tazu</span><span>|</span><a href="#41478228">prev</a><span>|</span><a href="#41477850">next</a><span>|</span><label class="collapse" for="c-41477724">[-]</label><label class="expand" for="c-41477724">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m having a hard time understanding what this is about. Is it about Kubernetes tradeoffs?</div><br/><div id="41477753" class="c"><input type="checkbox" id="c-41477753" checked=""/><div class="controls bullet"><span class="by">NAHWheatCracker</span><span>|</span><a href="#41477724">parent</a><span>|</span><a href="#41477850">next</a><span>|</span><label class="collapse" for="c-41477753">[-]</label><label class="expand" for="c-41477753">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just about tradeoffs in system design, nothing as specific as K8s.<p>I think the author just wanted to write a glib little blog post.</div><br/></div></div></div></div><div id="41477850" class="c"><input type="checkbox" id="c-41477850" checked=""/><div class="controls bullet"><span class="by">mlhpdx</span><span>|</span><a href="#41477724">prev</a><span>|</span><a href="#41478426">next</a><span>|</span><label class="collapse" for="c-41477850">[-]</label><label class="expand" for="c-41477850">[2 more]</label></div><br/><div class="children"><div class="content">That’s really the secret, isn’t it? Deciding, deliberately, what to leave out of a system so that it is possible for the people involved to maintain it. That is perhaps a good definition of software architecture.</div><br/><div id="41477903" class="c"><input type="checkbox" id="c-41477903" checked=""/><div class="controls bullet"><span class="by">ta_1138</span><span>|</span><a href="#41477850">parent</a><span>|</span><a href="#41478426">next</a><span>|</span><label class="collapse" for="c-41477903">[-]</label><label class="expand" for="c-41477903">[1 more]</label></div><br/><div class="children"><div class="content">And yet, many an architecture review is all about a group of people trying to justify their existence by adding features. I was in a design review this week where 4 different architects were involved, along with the expected assortment of managers and product people. Every single suggestion was an addition. Having written systems like the one in question for decades, I considered the initial proposal as massively overengineered in the first place: An excuse to have a project that lets someone get upleveled in the next review cycle.</div><br/></div></div></div></div><div id="41478426" class="c"><input type="checkbox" id="c-41478426" checked=""/><div class="controls bullet"><span class="by">jiveturkey</span><span>|</span><a href="#41477850">prev</a><span>|</span><a href="#41477794">next</a><span>|</span><label class="collapse" for="c-41478426">[-]</label><label class="expand" for="c-41478426">[1 more]</label></div><br/><div class="children"><div class="content">Is this a lay description of CAP theorem? Or is it actually broader than that? I&#x27;m having a hard time getting my head around it.</div><br/></div></div><div id="41477794" class="c"><input type="checkbox" id="c-41477794" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41478426">prev</a><span>|</span><a href="#41477883">next</a><span>|</span><label class="collapse" for="c-41477794">[-]</label><label class="expand" for="c-41477794">[1 more]</label></div><br/><div class="children"><div class="content">Distributed systems, like interrupts, are something you can’t bullshit and get right. The author is right though that nondeterminism makes systems easier to reason about if you have the right cognitive tools (ie, math).<p>Here[1] is an example of what rigorous reasoning about distributed systems looks like.<p><pre><code>  the non-deterministic algorithm emerges when, abstracting from their mutual differences, we concentrate on what the many algorithms of the class have in common.

 </code></pre>
[1] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~EWD&#x2F;transcriptions&#x2F;EWD06xx&#x2F;EWD687a.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~EWD&#x2F;transcriptions&#x2F;EWD06xx&#x2F;EWD687...</a></div><br/></div></div></div></div></div></div></div></body></html>