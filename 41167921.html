<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723280461035" as="style"/><link rel="stylesheet" href="styles.css?v=1723280461035"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/fukamachi/qlot">Qlot: Common Lisp Library Manager</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>ducktective</span> | <span>30 comments</span></div><br/><div><div id="41206263" class="c"><input type="checkbox" id="c-41206263" checked=""/><div class="controls bullet"><span class="by">nothrabannosir</span><span>|</span><a href="#41205077">next</a><span>|</span><label class="collapse" for="c-41206263">[-]</label><label class="expand" for="c-41206263">[6 more]</label></div><br/><div class="children"><div class="content">Funny, I did quite a deep dive on this same issue about two years back, and came to exactly the opposite conclusion: keep ASDF, and lean on Nix to do pinning. I now maintain my own Common Lisp package repository, testing daily against nightly SBCL etc, and I&#x27;ve learned that a lot of CL stability is just because test suites are never run. Nix goes a long way to shield me from the haphazard breakages that other commenters mentioned, but of course it comes with a huge downside: you need to use Nix :)<p>(just kidding)<p>Code at <a href="https:&#x2F;&#x2F;github.com&#x2F;hraban&#x2F;cl-nix-lite">https:&#x2F;&#x2F;github.com&#x2F;hraban&#x2F;cl-nix-lite</a> if someone is interested.<p>Obviously since this was written by Fukamachi you know it will be good. Much respect to the man.</div><br/><div id="41206926" class="c"><input type="checkbox" id="c-41206926" checked=""/><div class="controls bullet"><span class="by">zelcon</span><span>|</span><a href="#41206263">parent</a><span>|</span><a href="#41205077">next</a><span>|</span><label class="collapse" for="c-41206926">[-]</label><label class="expand" for="c-41206926">[5 more]</label></div><br/><div class="children"><div class="content">Really unfortunate that Guix never took off. Guile is so much nicer than Nix slop.</div><br/><div id="41207153" class="c"><input type="checkbox" id="c-41207153" checked=""/><div class="controls bullet"><span class="by">kentrado</span><span>|</span><a href="#41206263">root</a><span>|</span><a href="#41206926">parent</a><span>|</span><a href="#41207314">next</a><span>|</span><label class="collapse" for="c-41207153">[-]</label><label class="expand" for="c-41207153">[1 more]</label></div><br/><div class="children"><div class="content">The biggest issue for me is how slow guix is when doing guix pull.<p>Also, the amount of space taken is unacceptable. Several times I had my HD filled with guix garbage.</div><br/></div></div><div id="41207314" class="c"><input type="checkbox" id="c-41207314" checked=""/><div class="controls bullet"><span class="by">nothrabannosir</span><span>|</span><a href="#41206263">root</a><span>|</span><a href="#41206926">parent</a><span>|</span><a href="#41207153">prev</a><span>|</span><a href="#41207454">next</a><span>|</span><label class="collapse" for="c-41207314">[-]</label><label class="expand" for="c-41207314">[1 more]</label></div><br/><div class="children"><div class="content">At the risk of derailing the conversation (although Guix is a lisp so maybe not): I agree 100% but also maybe Nix&#x27;s pragmatism <i>is why</i> it&#x27;s more popular? &quot;Pragmatism&quot; being a programming language euphemism for &quot;untyped hacky mess&quot;.</div><br/></div></div><div id="41207454" class="c"><input type="checkbox" id="c-41207454" checked=""/><div class="controls bullet"><span class="by">ducktective</span><span>|</span><a href="#41206263">root</a><span>|</span><a href="#41206926">parent</a><span>|</span><a href="#41207314">prev</a><span>|</span><a href="#41205077">next</a><span>|</span><label class="collapse" for="c-41207454">[-]</label><label class="expand" for="c-41207454">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Guix never took off<p>Why is this in past tense? Guix development is active. It&#x27;s just Nix is more popular and it&#x27;s understandable since it&#x27;s the original idea and it&#x27;s older.</div><br/><div id="41208035" class="c"><input type="checkbox" id="c-41208035" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#41206263">root</a><span>|</span><a href="#41207454">parent</a><span>|</span><a href="#41205077">next</a><span>|</span><label class="collapse" for="c-41208035">[-]</label><label class="expand" for="c-41208035">[1 more]</label></div><br/><div class="children"><div class="content">Guix even has a very active, high-quality blog where maintainers detail major technical accomplishments, long-term goals, etc.: <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;en&#x2F;blog&#x2F;" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;en&#x2F;blog&#x2F;</a><p>From here it seems like they&#x27;re growing and advancing well. I wish I could find ready historical data on the numbers of packages and services from, say, 4 years ago vs. today, though. I could have sworn Repology used to show year over year stuff but I can&#x27;t find it now.</div><br/></div></div></div></div></div></div></div></div><div id="41205077" class="c"><input type="checkbox" id="c-41205077" checked=""/><div class="controls bullet"><span class="by">gibsonf1</span><span>|</span><a href="#41206263">prev</a><span>|</span><a href="#41205062">next</a><span>|</span><label class="collapse" for="c-41205077">[-]</label><label class="expand" for="c-41205077">[1 more]</label></div><br/><div class="children"><div class="content">This is great news. The updates to SBCL broke some libraries (that is, sbcl got more thorough in finding bugs that some libraries had) and I&#x27;ve had to load patches in for them because of the quicklisp limitation in a patch file.  This will make life much simpler as do all of Fukamachi&#x27;s libraries in general.  (His internet suite is fantastic)</div><br/></div></div><div id="41205062" class="c"><input type="checkbox" id="c-41205062" checked=""/><div class="controls bullet"><span class="by">mike_ivanov</span><span>|</span><a href="#41205077">prev</a><span>|</span><a href="#41204798">next</a><span>|</span><label class="collapse" for="c-41205062">[-]</label><label class="expand" for="c-41205062">[3 more]</label></div><br/><div class="children"><div class="content">I bet my money on <a href="https:&#x2F;&#x2F;github.com&#x2F;ocicl&#x2F;ocicl">https:&#x2F;&#x2F;github.com&#x2F;ocicl&#x2F;ocicl</a><p>Edit: as much as love fukamachi - but still</div><br/><div id="41205082" class="c"><input type="checkbox" id="c-41205082" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41205062">parent</a><span>|</span><a href="#41206372">next</a><span>|</span><label class="collapse" for="c-41205082">[-]</label><label class="expand" for="c-41205082">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Ocicl – An ASDF system distribution and management tool for Common Lisp</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35973000">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35973000</a> - May 2023 (32 comments)</div><br/></div></div><div id="41206372" class="c"><input type="checkbox" id="c-41206372" checked=""/><div class="controls bullet"><span class="by">VitoVan</span><span>|</span><a href="#41205062">parent</a><span>|</span><a href="#41205082">prev</a><span>|</span><a href="#41204798">next</a><span>|</span><label class="collapse" for="c-41206372">[-]</label><label class="expand" for="c-41206372">[1 more]</label></div><br/><div class="children"><div class="content">I also bet my money on ocicl, because of its systems.csv for locking versions of dependencies.</div><br/></div></div></div></div><div id="41204798" class="c"><input type="checkbox" id="c-41204798" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#41205062">prev</a><span>|</span><a href="#41205914">next</a><span>|</span><label class="collapse" for="c-41204798">[-]</label><label class="expand" for="c-41204798">[13 more]</label></div><br/><div class="children"><div class="content">Seems like an attempt to bring &quot;lockfiles&quot; or related concepts to Quicklisp. This is a desperately needed quality-of-life improvement for &quot;modern&quot; Common Lisp development.<p>However, I wish people in the Common Lisp community weren&#x27;t weary of using ASDF directly. It already supports versioning and many features that do not exist in Quicklisp -- despite the fact Quicklisp wraps ASDF -- such as a package that depends on a version of a library newer (or older) than what exists in the current dist.<p>It&#x27;s kind of impressive that Common Lisp is the only language I use where I can&#x27;t expect code written today to work next month due to Quicklisp lacking versioning outside of the date attached to dists.</div><br/><div id="41204964" class="c"><input type="checkbox" id="c-41204964" checked=""/><div class="controls bullet"><span class="by">g11479</span><span>|</span><a href="#41204798">parent</a><span>|</span><a href="#41206161">next</a><span>|</span><label class="collapse" for="c-41204964">[-]</label><label class="expand" for="c-41204964">[3 more]</label></div><br/><div class="children"><div class="content">faré the guy who briefly took over asdf development before quitting common lisp entirely to do scheme, or whatever he&#x27;s doing right now, spent significant amount of time turning asdf from a 10kb file into 3000kb file in order to solve problems that only he himself cared about, or possibly only google cared about because faré worked for google at the time (building portability library that ignored and force-superseded existing solutions, and trying to eliminate corners cases of SAT solving). there was a period where he was harrassing (this is a subjective interpretation of the events, but this is my side) implementors to incorporate his recent asdf changes, that were breaking left and right to the point that multiple common lisp maintainers of multiple common lisps were considering pulling asdf from their repos entirely. things have stabilized, because faré quit and there&#x27;s no longer volatility. we&#x27;re at a point where there&#x27;s just no concensus about relying on asdf for anything, and while some people go all in on 30% of available functionality (as opposed to customary 5%), equally many people, the majority, use it as a glorified (load)(load)(load). this is an unfortunate side effect of activist developers in small communities: they can have outsized long term effect on how things are done.</div><br/><div id="41205201" class="c"><input type="checkbox" id="c-41205201" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41204798">root</a><span>|</span><a href="#41204964">parent</a><span>|</span><a href="#41206161">next</a><span>|</span><label class="collapse" for="c-41205201">[-]</label><label class="expand" for="c-41205201">[2 more]</label></div><br/><div class="children"><div class="content">In the Meta-CVS project, I carried a copy of asdf.lisp in which the package was renamed to zxcv, to isolate from the ASDF churn and be able to run my version of ASDF possibly with my fixes even in a Lisp that has ASDF preloaded.<p>ASDF is the only build system I know which broke on me when I tried to fool it with a link farm (lndir command) into building in a separate directory.  It resolved the paths using the <i>truename</i> function which eliminates symbolic links, and then calculated the .fas file names from the canonicalized paths, thereby depositing compiled files into the original directory rather than in the symbolically linked tree.<p>ASDF also depends on symlinks for external organization. .asf files are often symlinks to the real location, and without these symlinks, things don&#x27;t work.</div><br/><div id="41205577" class="c"><input type="checkbox" id="c-41205577" checked=""/><div class="controls bullet"><span class="by">g11479</span><span>|</span><a href="#41204798">root</a><span>|</span><a href="#41205201">parent</a><span>|</span><a href="#41206161">next</a><span>|</span><label class="collapse" for="c-41205577">[-]</label><label class="expand" for="c-41205577">[1 more]</label></div><br/><div class="children"><div class="content">i have a patched version of asdf 1.369 which was maintained by gary king, with contributions from luminaries like nikodemus, chrodes, weitz, pvaneynd and kevin rosenburg. i&#x27;ve patched it to support the recent extensions that people seem to like (extra parameters to defsystem, like author). you can drop it into your implementation and quicklisp and it just works. asdf 2, asdf 3 happened since, they solve some kind of problems, i guess whatever google needed to do with its fleet, or maybe it&#x27;s &quot;easier to maintain&quot;, but it&#x27;s not the kind of problems that surface in like 60% of quicklisp packages.</div><br/></div></div></div></div></div></div><div id="41206161" class="c"><input type="checkbox" id="c-41206161" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#41204798">parent</a><span>|</span><a href="#41204964">prev</a><span>|</span><a href="#41205441">next</a><span>|</span><label class="collapse" for="c-41206161">[-]</label><label class="expand" for="c-41206161">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s kind of impressive that Common Lisp is the only language I use where I can&#x27;t expect code written today to work next month due to Quicklisp lacking versioning outside of the date attached to dists.<p>I think the lack of version pinning is a positive force in stability: reducing the pain of breaking changes increases the likelihood that library authors will break things.</div><br/><div id="41206462" class="c"><input type="checkbox" id="c-41206462" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#41204798">root</a><span>|</span><a href="#41206161">parent</a><span>|</span><a href="#41205441">next</a><span>|</span><label class="collapse" for="c-41206462">[-]</label><label class="expand" for="c-41206462">[1 more]</label></div><br/><div class="children"><div class="content">This seems to be the widely reported experience from people who develop in Common Lisp daily or very frequently, and even in my haphazard development I find things pretty stable. And it&#x27;s not like version pinning is all that helpful in a living project anyway, because you often <i>want</i> to update things, and I notice my JavaScript-using friends constantly suffering from breakages every time they try.<p>With Lisp, I setup my libraries in jenkins to pull the latest SBCL and quicklisp distro once a month and run tests, it&#x27;s pretty rare for things to break. Once or twice something with an SBCL release itself, once with a bug involving the interplay of two of Fukamachi&#x27;s libraries. The SBCL one was noticed by others and fixed pretty quickly, for the library one I was able to use git-bisect to easily find the breaking commit and apply a local fix while I waited for the issue I filed to get addressed. This was during Fukamachi&#x27;s life-threatening illness period, even, but an alternative maintainer did address the bug on their side. The only annoyance these days is Xach is suffering from who knows what preventing the quicklisp distro from updating since October, and there hasn&#x27;t been communication with people offering to help, so it&#x27;s forcing everyone to pull projects in locally (and qlot does help with that) for updates or use an alternative.</div><br/></div></div></div></div><div id="41205441" class="c"><input type="checkbox" id="c-41205441" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41204798">parent</a><span>|</span><a href="#41206161">prev</a><span>|</span><a href="#41207233">next</a><span>|</span><label class="collapse" for="c-41205441">[-]</label><label class="expand" for="c-41205441">[1 more]</label></div><br/><div class="children"><div class="content">The only time I&#x27;ve had CL code break due to lack of versioning was when I was depending on stuff written by the author of Qlot, so I either avoid or locally pin stuff written by him.<p>Most of my dependencies are really quite stable.<p>[edit]<p>I thought of a place where things broke that aren&#x27;t related to Fukamachi; sometimes foreign libraries have changed to the point where they won&#x27;t grovel any more, but I don&#x27;t think that&#x27;s something that Qlot aims to solve.</div><br/></div></div><div id="41207233" class="c"><input type="checkbox" id="c-41207233" checked=""/><div class="controls bullet"><span class="by">jlarocco</span><span>|</span><a href="#41204798">parent</a><span>|</span><a href="#41205441">prev</a><span>|</span><a href="#41204970">next</a><span>|</span><label class="collapse" for="c-41207233">[-]</label><label class="expand" for="c-41207233">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, I just don&#x27;t think it bothers people much.<p>When I need a specific version of a library, I clone it to my local projects directory and checkout the version I need.  Problem solved.  Quicklisp is just downloading a snapshot of the upstream repo anyway.<p>For me, if I could change anything about QuickLisp, I&#x27;d add something like Python&#x27;s `virutalenv`.  I suspect I can hack something up by messing ASDF&#x27;s source registries, but so far I haven&#x27;t wanted it bad enough to implement it.</div><br/></div></div><div id="41204970" class="c"><input type="checkbox" id="c-41204970" checked=""/><div class="controls bullet"><span class="by">redwoolf</span><span>|</span><a href="#41204798">parent</a><span>|</span><a href="#41207233">prev</a><span>|</span><a href="#41205914">next</a><span>|</span><label class="collapse" for="c-41204970">[-]</label><label class="expand" for="c-41204970">[5 more]</label></div><br/><div class="children"><div class="content">My thoughts as soon as I read the README: what’s wrong with asdf?</div><br/><div id="41205040" class="c"><input type="checkbox" id="c-41205040" checked=""/><div class="controls bullet"><span class="by">blast</span><span>|</span><a href="#41204798">root</a><span>|</span><a href="#41204970">parent</a><span>|</span><a href="#41205048">next</a><span>|</span><label class="collapse" for="c-41205040">[-]</label><label class="expand" for="c-41205040">[2 more]</label></div><br/><div class="children"><div class="content">ASDF is by far the hardest part of the CL ecosystem to work with. I find it unusably complicated. It&#x27;s the autotools of CL.<p>Thank god for quicklisp.</div><br/><div id="41205467" class="c"><input type="checkbox" id="c-41205467" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41204798">root</a><span>|</span><a href="#41205040">parent</a><span>|</span><a href="#41205048">next</a><span>|</span><label class="collapse" for="c-41205467">[-]</label><label class="expand" for="c-41205467">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting because I find it to be one of the most ergonomic build tools I&#x27;ve ever worked with.  It sits somewhere between make and autotools in terms of what it does and I find it far easier to use than either.</div><br/></div></div></div></div><div id="41205048" class="c"><input type="checkbox" id="c-41205048" checked=""/><div class="controls bullet"><span class="by">g11479</span><span>|</span><a href="#41204798">root</a><span>|</span><a href="#41204970">parent</a><span>|</span><a href="#41205040">prev</a><span>|</span><a href="#41205033">next</a><span>|</span><label class="collapse" for="c-41205048">[-]</label><label class="expand" for="c-41205048">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s fukamachi-ware, guy has a bunch of own solutions in the web development space, i suspect driven by his specific needs. they are, fwiw, not as idiosyncratic as some of the artisanal common lisp one-man solutions can be, but they are distinctly and recognizably their own thing</div><br/></div></div><div id="41205033" class="c"><input type="checkbox" id="c-41205033" checked=""/><div class="controls bullet"><span class="by">mike_ivanov</span><span>|</span><a href="#41204798">root</a><span>|</span><a href="#41204970">parent</a><span>|</span><a href="#41205048">prev</a><span>|</span><a href="#41205914">next</a><span>|</span><label class="collapse" for="c-41205033">[-]</label><label class="expand" for="c-41205033">[1 more]</label></div><br/><div class="children"><div class="content">UX</div><br/></div></div></div></div></div></div><div id="41205914" class="c"><input type="checkbox" id="c-41205914" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41204798">prev</a><span>|</span><label class="collapse" for="c-41205914">[-]</label><label class="expand" for="c-41205914">[6 more]</label></div><br/><div class="children"><div class="content">Those who still use Common Lisp or some variant of Lisp (other than Clojure), what&#x27;s your reasoning behind choosing this language over the more mainstream options? I understand that Lisp has some powerful features, but almost everyone that I&#x27;ve talked to holds reservations for those.<p>For example, Lisp macros are amazing. BUT... this is not good for communicating code in big teams.<p>Or live (image) programs are an interesting concept, but git versioning them is much more difficult than traditional source code versioning.<p>Or hot code reloading, which sounds like a powerful concept except that companies would rather log and document their codebase. It also makes it challenging to keep track of the state.<p>If you force teams not to use macros, then a great reason behind s-exps goes away. And in general, if you take these features away from Lisp, I&#x27;m just not sure what use case Lisp can serve.</div><br/><div id="41206154" class="c"><input type="checkbox" id="c-41206154" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#41205914">parent</a><span>|</span><a href="#41206431">next</a><span>|</span><label class="collapse" for="c-41206154">[-]</label><label class="expand" for="c-41206154">[1 more]</label></div><br/><div class="children"><div class="content">Lisp macros don’t actually make code harder to read and think about and, unlike the way widely used tools like Flink and Spark do code generation, it’s easy to see what the generated code looks like.<p>In practices, images are just a deployment tool in CL and most people don’t actually do “version control” by saving and restoring images or using hot code reloading. However, these features enable a development experience that I find much more pleasant than any other language I’ve tried.</div><br/></div></div><div id="41206431" class="c"><input type="checkbox" id="c-41206431" checked=""/><div class="controls bullet"><span class="by">drekipus</span><span>|</span><a href="#41205914">parent</a><span>|</span><a href="#41206154">prev</a><span>|</span><a href="#41206210">next</a><span>|</span><label class="collapse" for="c-41206431">[-]</label><label class="expand" for="c-41206431">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually learning Common lisp for working on my side projects, and those are the reasons that really make the whole thing stick out and amazing.<p>* Live image and hot-patching is great. You edit it within the code, so if you&#x27;re making a shooter game, and you&#x27;re in a &quot;draw HUD&quot; function, you can just edit the code to be what you want and send that function to the running image, to update while you play. Any time you spot a bug, you can isolate, correct, and verify, while still running the game.<p>* Macros can be thought of as a way to make the code more readable. CL is almost thought of as a &quot;programming language to make programming languages in, so you can solve the problem&quot;.<p>For instance, if you think about any amount of boilerplate. Macros allow you to write it once (because you have to) and then use it in different places at different times. CL makes boilerplate nonexistent.<p>I do this for wrapping up ncurses functions: to use colours, you must turn on and off certain bits and flags. You can imagine that there&#x27;s complications when you want to draw a box, or colours text, or coloured underlined text, and there&#x27;s all sorts of flags and state involved. To write it in C or Python would be a few multi line functions. In lisp it can be made as simple as (with-colours a-colour (draw-text) (with-underline (draw-text))).</div><br/></div></div><div id="41206210" class="c"><input type="checkbox" id="c-41206210" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#41205914">parent</a><span>|</span><a href="#41206431">prev</a><span>|</span><a href="#41208085">next</a><span>|</span><label class="collapse" for="c-41206210">[-]</label><label class="expand" for="c-41206210">[1 more]</label></div><br/><div class="children"><div class="content">The “downsides” you list are actually benefits that non–lisp users try to downplay. Especially macros. Macros give an individual the ability to write things in Lisp that would take a team in any other language. There’s nothing that says a team cannot gain the same multiplier.</div><br/></div></div><div id="41208085" class="c"><input type="checkbox" id="c-41208085" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41205914">parent</a><span>|</span><a href="#41206210">prev</a><span>|</span><a href="#41206546">next</a><span>|</span><label class="collapse" for="c-41208085">[-]</label><label class="expand" for="c-41208085">[1 more]</label></div><br/><div class="children"><div class="content">It looks good to eyes that took a few days getting over their babby duck syndrome.<p>Has a useful numerical tower containing rational and bignums and an extensive math stdlib to act on them.<p>A powerful optimizing compiler (available to the user at runtime!) despite the deep dynamism. And pragmas (declarations) much better integrated with the language than in C&#x2F;C++.<p>Gradual typing (missing recursive and user-facing parametric typing, I know...).<p>A stable standard with more than one quality implementation<p>A pretty good stdlib (missing some stuff due to its age, but well designed in what&#x27;s there) with some hidden gems like the bitwise manipulation tools or compiler-macros.<p><a href="https:&#x2F;&#x2F;iterate.common-lisp.dev" rel="nofollow">https:&#x2F;&#x2F;iterate.common-lisp.dev</a> stomps other languages&#x27; idea of imperative iteration.<p>CLOS&#x2F;MOP is so flexible the sky&#x27;s the limit (too flexible, some might say).<p>I could continue all day, especially if you want the bad and half-baked parts too, but my point is that there are other good points than the &quot;esoteric&quot; features.<p>Macros are fine and indeed part of the reason to use CL, just don&#x27;t abuse them.</div><br/></div></div><div id="41206546" class="c"><input type="checkbox" id="c-41206546" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#41205914">parent</a><span>|</span><a href="#41208085">prev</a><span>|</span><label class="collapse" for="c-41206546">[-]</label><label class="expand" for="c-41206546">[1 more]</label></div><br/><div class="children"><div class="content">Macros enable communication, rather than hinder it. From the mundane ones defined as part of the language like defun and cond, to frequently helpful patterns like with-foo, to the more expressive ones like pattern matching or even domain-specific ones that can even let non-programmers contribute usefully.<p>No one versions their save-lisp-and-die blobs like source code, they&#x27;re effectively binary releases. You could version them as releases.<p>Hot code reloading is not incompatible with logging, documentation, or normal file-based source control. You may have a misconception that we&#x27;re just raw-dogging it with typing directly in the REPL window like you&#x27;re more or less forced to with e.g. Python. Sure, sometimes, but the <i>vast</i> majority of the time no, edits are made to files in a text editor (and often saved) and <i>sent</i> to the REPL as complete forms. It&#x27;s not challenging to keep track of state, either, especially when you can inspect everything whenever you want, trivially reload an entire system (what I often do after editing more than one file at once), and define more complicated state transforms ahead of time with things like update-instance-for-redefined-class. Rather, it helps <i>avoid</i> keeping track of so much state in your head, because when you&#x27;re developing something and want to test something out, you just do it, you don&#x27;t need to restart the application and rebuild the state to just what it was before the point where you wanted to test something different. Additionally, if a company isn&#x27;t using some sort of hot reloading tool (like JRebel for Java), they&#x27;re easily wasting 20% or more of developer time. (<a href="https:&#x2F;&#x2F;www.jrebel.com&#x2F;sites&#x2F;rebel&#x2F;files&#x2F;pdfs&#x2F;rw-mythbusters-jrebel.pdf" rel="nofollow">https:&#x2F;&#x2F;www.jrebel.com&#x2F;sites&#x2F;rebel&#x2F;files&#x2F;pdfs&#x2F;rw-mythbusters...</a>)<p>Besides that: I like dynamic typing, SBCL is default-fast unlike dog-slow Python and Ruby, optional types for speed boosts are there with compiler advice and ready disassembly views to help get and verify the speed (they also add a little bit of compile-time correctness checking, and options like Coalton are readily available for a more Haskell-like experience), the experience of conditions and restarts is way better than exceptions for normal development and debugging, debugging itself is more pleasant despite missing some tools because of the conditions framework and fully dynamic no-compromises hot reloading, code I wrote years ago continues to function, code that was written before I was born continues to function, Lisp&#x27;s expression of OOP doesn&#x27;t make me want to rip my hair out, and I rather like the uniformity of s-expressions over having to remember all the l-value&#x2F;r-value&#x2F;hidden constructor&#x2F;operator&#x2F;conversion&#x2F;initializations&#x2F;etc. details of other languages.</div><br/></div></div></div></div></div></div></div></div></div></body></html>