<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733043654022" as="style"/><link rel="stylesheet" href="styles.css?v=1733043654022"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.lucasholten.com/rust-query-announcement/">Safe relational database queries using the Rust type system</a> <span class="domain">(<a href="https://blog.lucasholten.com">blog.lucasholten.com</a>)</span></div><div class="subtext"><span>lukastyrychtr</span> | <span>119 comments</span></div><br/><div><div id="42282885" class="c"><input type="checkbox" id="c-42282885" checked=""/><div class="controls bullet"><span class="by">levkk</span><span>|</span><a href="#42282172">next</a><span>|</span><label class="collapse" for="c-42282885">[-]</label><label class="expand" for="c-42282885">[43 more]</label></div><br/><div class="children"><div class="content">My main concern with application-defined schemas is that this schema is validated by the wrong system. The database is the authority on what the schema is; all other layers in your application make assumptions based on effectively hearsay.<p>The closest we came so far to bridging this gap in strictly typed language like Rust is SQLx, which creates a struct based on the database types returned by a query. This is validated at compile time  against a database, which is good, but of course there is no guarantee that the production database will have the same types. Easiest mistake to make is to design a query against your local Postgres v15 and hit a runtime error in production running Postgres v12, e.g. a function like gen_ramdom_uuid() doesn&#x27;t exist. Another is to assume a migration in production was actually executed.<p>In duck-typed languages like Ruby, the application objects are directly created from the database at runtime. They are as accurate as possible, since the schema is directly read at application startup. Then of course you see developers do something like:<p><pre><code>    if respond_to?(:column_x)
        # do something with column_x
    end
</code></pre>
To summarize, I think application-defined schemas provide a false sense of security and add another layer of work for the engineer.</div><br/><div id="42283025" class="c"><input type="checkbox" id="c-42283025" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42282885">parent</a><span>|</span><a href="#42286709">next</a><span>|</span><label class="collapse" for="c-42283025">[-]</label><label class="expand" for="c-42283025">[2 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t seem fundamentally different from any schema&#x2F;API mismatch issue. For example using the wrong header for a C library, or the wrong Protobuf schema.<p>I guess it would be good if it verified it at runtime somehow though. E.g. when you first connect to the database it checks Postgresql is the minimum required version, and the tables match what was used at compile time.</div><br/><div id="42284180" class="c"><input type="checkbox" id="c-42284180" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283025">parent</a><span>|</span><a href="#42286709">next</a><span>|</span><label class="collapse" for="c-42284180">[-]</label><label class="expand" for="c-42284180">[1 more]</label></div><br/><div class="children"><div class="content">It could be verified at runtime, but I haven&#x27;t seen anyone trying to version&#x2F;hash schemas and include that in the request.<p>The workaround in practice seems to be to keep the DB behind a server that always™ uses a compatible schema and exposes an API that&#x27;s either properly versioned or at least safe for slightly older clients.
To be fair it&#x27;s hard to get rid of the middleman and serve straight from the DB, it&#x27;s always deemed too scary for many reasons, so it&#x27;s not that bad.</div><br/></div></div></div></div><div id="42286709" class="c"><input type="checkbox" id="c-42286709" checked=""/><div class="controls bullet"><span class="by">runeks</span><span>|</span><a href="#42282885">parent</a><span>|</span><a href="#42283025">prev</a><span>|</span><a href="#42283030">next</a><span>|</span><label class="collapse" for="c-42286709">[-]</label><label class="expand" for="c-42286709">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is validated at compile time against a database, which is good, but of course there is no guarantee that the production database will have the same types. Easiest mistake to make is to design a query against your local Postgres v15 and hit a runtime error in production running Postgres v12, e.g. a function like gen_ramdom_uuid() doesn&#x27;t exist. Another is to assume a migration in production was actually executed.<p>One could have the backend fetch DB schema&#x2F;version info at startup, compare it to its own view of what the schema should look like, and fail if the two disagree. That way, a new deployment would fail before being activated, instead of being deployed successfully and queries failing down the line.</div><br/></div></div><div id="42283030" class="c"><input type="checkbox" id="c-42283030" checked=""/><div class="controls bullet"><span class="by">Hytak</span><span>|</span><a href="#42282885">parent</a><span>|</span><a href="#42286709">prev</a><span>|</span><a href="#42283096">next</a><span>|</span><label class="collapse" for="c-42283030">[-]</label><label class="expand" for="c-42283030">[28 more]</label></div><br/><div class="children"><div class="content">rust-query manages migrations and reads the schema from the database to check that it matches what was defined in the application. If at any point the database schema doesn&#x27;t match the expected schema, then rust-query will panic with an error message explaining the difference (currently this error is not very pretty).<p>Furthermore, at the start of every transaction, rust-query will check that the `schema_version` (sqlite pragma) did not change. (source: I am the author)</div><br/><div id="42284474" class="c"><input type="checkbox" id="c-42284474" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283030">parent</a><span>|</span><a href="#42286495">next</a><span>|</span><label class="collapse" for="c-42284474">[-]</label><label class="expand" for="c-42284474">[3 more]</label></div><br/><div class="children"><div class="content">In addition to the deployment-time issues and other stuff I and others have commented downthread, I thought of another problem with this.<p>I can&#x27;t see how this would even work for trivial, quick, on-line schema changes.  Let&#x27;s say I have 10 servers running the same service that talks to the database (that is, the service fronting the database is scaled out horizontally).  How would I do a migration?  Obviously I can&#x27;t deploy new code to all 10 servers simultaneously that will do the schema migration; only one server can run the migration.  So one server runs the migration, and... what, the other 9 servers immediately panic because their idea of the schema is out of date?<p>Or I deploy code to all 10 servers but somehow designate that only one of them will actually do the schema migration.  Well, now the other 9 servers are expecting the new schema, and will panic before that 1 server can finish doing the migration.<p>It seems to me that rust-query is only suitable for applications where you have to schedule downtime in order to do schema changes.  That&#x27;s just unacceptable for any business I&#x27;ve worked at.</div><br/><div id="42286687" class="c"><input type="checkbox" id="c-42286687" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42284474">parent</a><span>|</span><a href="#42286146">next</a><span>|</span><label class="collapse" for="c-42286687">[-]</label><label class="expand" for="c-42286687">[1 more]</label></div><br/><div class="children"><div class="content">I think first and foremost, if you&#x27;re going to use a tool like this, you need to do everything through the tool.<p>That said, for zero downtime migrations there are a number of techniques, but it typically boils down to splitting the migration into two steps where each step is rolled out to each server before starting the next: <a href="https:&#x2F;&#x2F;teamplify.com&#x2F;blog&#x2F;zero-downtime-DB-migrations&#x2F;" rel="nofollow">https:&#x2F;&#x2F;teamplify.com&#x2F;blog&#x2F;zero-downtime-DB-migrations&#x2F;</a> <a href="https:&#x2F;&#x2F;johnnymetz.com&#x2F;posts&#x2F;multistep-database-changes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;johnnymetz.com&#x2F;posts&#x2F;multistep-database-changes&#x2F;</a> etc<p>I&#x27;m not sure if there&#x27;s anything that automates this, but it&#x27;d probably need to involve the infrastructure layer (like terraform) too.<p>Edit: There&#x27;s one other approach I&#x27;ve heard of for zero downtime deployments:<p>Start running the new version in new instances&#x2F;services parallel to the old version, but pause it before doing any database stuff. Drain client connections to the old version and queue them. Once drained, stop the old version, perform database migrations, and start the new version, then start consuming the queue.<p>This is (I think) more general but you could get client timeouts or need to kill long requests to the old version, and requires coordination between infrastructure (load balancer?) and software versions.</div><br/></div></div><div id="42286146" class="c"><input type="checkbox" id="c-42286146" checked=""/><div class="controls bullet"><span class="by">dayjah</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42284474">parent</a><span>|</span><a href="#42286687">prev</a><span>|</span><a href="#42286495">next</a><span>|</span><label class="collapse" for="c-42286146">[-]</label><label class="expand" for="c-42286146">[1 more]</label></div><br/><div class="children"><div class="content">This isn’t unique to rust-query; this problem also exists with ActiveRecord, for example. At Twitch we just had to <i>really</i> think about our migrations and write code to handle differences.<p>Basically no free lunch!</div><br/></div></div></div></div><div id="42286495" class="c"><input type="checkbox" id="c-42286495" checked=""/><div class="controls bullet"><span class="by">theptip</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283030">parent</a><span>|</span><a href="#42284474">prev</a><span>|</span><a href="#42285078">next</a><span>|</span><label class="collapse" for="c-42286495">[-]</label><label class="expand" for="c-42286495">[1 more]</label></div><br/><div class="children"><div class="content">In all the systems I’ve built (mostly Django) you need to tolerate vN and vN+1 simultaneously; you are not going to turn off your app to upgrade the DB.<p>You’ll have some Pods on the old application version while you do your gradual upgrade.<p>How do you envision rolling upgrades working here?</div><br/></div></div><div id="42285078" class="c"><input type="checkbox" id="c-42285078" checked=""/><div class="controls bullet"><span class="by">Merad</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283030">parent</a><span>|</span><a href="#42286495">prev</a><span>|</span><a href="#42283455">next</a><span>|</span><label class="collapse" for="c-42285078">[-]</label><label class="expand" for="c-42285078">[5 more]</label></div><br/><div class="children"><div class="content">Unless you have some tricks up your sleeve that I&#x27;m not thinking of, an immediate consequence of this is that zero downtime deployments and blue&#x2F;green deployments become impossible. Those both rely on your app being able to run in a state where the schema is not an exact match for what the app expects - but it&#x27;s compatible so the app can still function.</div><br/><div id="42285140" class="c"><input type="checkbox" id="c-42285140" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42285078">parent</a><span>|</span><a href="#42285276">next</a><span>|</span><label class="collapse" for="c-42285140">[-]</label><label class="expand" for="c-42285140">[3 more]</label></div><br/><div class="children"><div class="content">Semantic versioning?</div><br/><div id="42285422" class="c"><input type="checkbox" id="c-42285422" checked=""/><div class="controls bullet"><span class="by">Merad</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42285140">parent</a><span>|</span><a href="#42285276">next</a><span>|</span><label class="collapse" for="c-42285422">[-]</label><label class="expand" for="c-42285422">[2 more]</label></div><br/><div class="children"><div class="content">If I understand the GP correctly, there&#x27;s no notion of semver involved. Any difference in the schema results in a runtime error.</div><br/><div id="42285994" class="c"><input type="checkbox" id="c-42285994" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42285422">parent</a><span>|</span><a href="#42285276">next</a><span>|</span><label class="collapse" for="c-42285994">[-]</label><label class="expand" for="c-42285994">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that’s what I gathered from the code. But I was proposing it as an “easy” solution that doesn’t involve throwing away OP’s main idea.</div><br/></div></div></div></div></div></div><div id="42285276" class="c"><input type="checkbox" id="c-42285276" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42285078">parent</a><span>|</span><a href="#42285140">prev</a><span>|</span><a href="#42283455">next</a><span>|</span><label class="collapse" for="c-42285276">[-]</label><label class="expand" for="c-42285276">[1 more]</label></div><br/><div class="children"><div class="content">And that&#x27;s okay. Most applications don&#x27;t need zero-downtime deployments, and there are already plenty of APIs that support that use case. I&#x27;d rather have more like this one.</div><br/></div></div></div></div><div id="42283455" class="c"><input type="checkbox" id="c-42283455" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283030">parent</a><span>|</span><a href="#42285078">prev</a><span>|</span><a href="#42285393">next</a><span>|</span><label class="collapse" for="c-42283455">[-]</label><label class="expand" for="c-42283455">[17 more]</label></div><br/><div class="children"><div class="content">&gt; rust-query manages migrations and reads the schema from the database to check that it matches what was defined in the application. If at any point the database schema doesn&#x27;t match the expected schema, then rust-query will panic with an error message explaining the difference (currently this error is not very pretty).<p>IMO - this sounds like &quot;tell me you&#x27;ve never operated a real production system before without telling me you&#x27;ve never operated a real production system before.&quot;<p>Shit happens in real life. Even if you have a great deployment pipeline, at some point, you&#x27;ll need to add a missing index in production <i>fast</i> because a wave of users came in and revealed a shit query. Or your on-call DBA will need to modify a table over the weekend from i32 -&gt; i64 because you ran out of primary key values, and you can&#x27;t spend the time updating all your code. (in Rust this is dicier, of course, but with something like Python shouldn&#x27;t cause issues in general.) Or you&#x27;ll just need to run some operation out of band -- that is, not relying on a migration -- because it what makes sense. Great example is using something like pt-osc[0] to create a temporary table copy and add temporary triggers to an existing table in order to do a zero-downtime copy.<p>Or maybe you just need to drop and recreate an index because it got corrupted. Shit happens!<p>Anyway, I really wouldn&#x27;t recommend a design that relies on your database <i>always</i> agreeing with your codebase <i>100% of the time</i>. What you should strive for is your codebase being <i>compatible</i> with the database 100% of the time -- that means new columns get added with a default value (or NULL) so inserts work, you don&#x27;t drop or rename columns or tables without a strict deprecation process (i.e. a rename is really add in db -&gt; add writes to code -&gt; backfill values in db -&gt; remove from code -&gt; remove from db), etc...<p>But fundamentally panicking because a table has an extra column is crazy. How else would you add a column to a running production system?<p>[0] <a href="https:&#x2F;&#x2F;docs.percona.com&#x2F;percona-toolkit&#x2F;pt-online-schema-change.html" rel="nofollow">https:&#x2F;&#x2F;docs.percona.com&#x2F;percona-toolkit&#x2F;pt-online-schema-ch...</a></div><br/><div id="42283984" class="c"><input type="checkbox" id="c-42283984" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283455">parent</a><span>|</span><a href="#42283801">next</a><span>|</span><label class="collapse" for="c-42283984">[-]</label><label class="expand" for="c-42283984">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bummer that you&#x27;ve been downvoted, because it really does seem like people here have not operated databases at scale.<p>I will never claim that we were great at managing databases at Twilio, but often a schema change would take hours, days, or even a week or two to complete.  We&#x27;re taking about tables with hundreds of millions of rows, or more.<p>We&#x27;d start the change on a DB replica. When it would finish, we would have to wait for the replica to catch up with the primary. Then we would bring up new replicas, replicating from the replica with the new schema. Finally that replica would get promoted to primary, with all the old replicas (and the old primary, of course) removed from service, and the new replicas brought in.<p>Only then could we deploy code that was aware of and used the updated schema. The previous code of course had to ignore unknown columns, and if we ever wanted to drop a column, we had to first deploy code that would stop using that column. Any column type changes would need to be backwards-compatible. If that wasn&#x27;t possible, we&#x27;d have to add a new column and backfill it.  Adding indexes would usually be fine without preparatory code changes, but if we wanted to drop an index we&#x27;d first have to make sure there were no queries still depending on it.<p>Even for a &quot;small&quot; schema change that &quot;only&quot; took minutes or a few tens of seconds to complete, we&#x27;d still have to use this process. What, do you think we&#x27;d shut part or all of a real-time communications platform down while we do a schema change? Of course not.<p>The idea that the application could or should be in control of this process, or could always be in sync with the database when it came to its understanding of the schema, is impossibly unrealistic.</div><br/><div id="42284114" class="c"><input type="checkbox" id="c-42284114" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283984">parent</a><span>|</span><a href="#42285267">next</a><span>|</span><label class="collapse" for="c-42284114">[-]</label><label class="expand" for="c-42284114">[2 more]</label></div><br/><div class="children"><div class="content">Yep, sounds like we have similar experiences! I first had to start thinking about this stuff at Hootsuite, back in the exciting 1million+ DAU days a decade ago. Before then, to me databases were just a thing that got deployed along with the application, and deploys only happened on a Friday night so who cares about downtime? By the time anyone tries logging into the app on Monday morning, the code and database will all be up to date. Going to a place where deploys were happening constantly <i>and</i> nonzero downtime was unacceptable was eye-opening.<p>&gt; The idea that the application could or should be in control of this process, or could always be in sync with the database when it came to its understanding of the schema, is impossibly unrealistic.<p>These days my attitude is to treat databases as a <i>completely separate service</i> from the application code, which they effectively are. They&#x27;re on a different set of servers, and the interface they provide is the columns&#x2F;tables&#x2F;views&#x2F;etc, accessed through SQL. So yeah, no breaking changes, and the only thing application code should care about is if the queries it tries to execute return the expected sets of data, not if the schema itself matches. And certainly not about things like views, triggers or indexes.<p>This does end up being more overhead than migrations alongside the application code, which I know a lot of developers prefer because they&#x27;re easier to use, but the approach just doesn&#x27;t work after a certain scale.<p>(to be clear, I still use Liquibase etc to manage migrations, the process for applying those changes is just completely separate from deploying application code.)</div><br/><div id="42284434" class="c"><input type="checkbox" id="c-42284434" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42284114">parent</a><span>|</span><a href="#42285267">next</a><span>|</span><label class="collapse" for="c-42284434">[-]</label><label class="expand" for="c-42284434">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>These days my attitude is to treat databases as a completely separate service from the application code, which they effectively are. They&#x27;re on a different set of servers, and the interface they provide is the columns&#x2F;tables&#x2F;views&#x2F;etc, accessed through SQL.</i><p>I&#x27;ve never thought of it this way, but I think this is really smart.  If I have a service that exposes a REST API, I can, say, add a new field to a JSON object that&#x27;s returned from an API endpoint without telling clients about it.  Those clients can update later in order to take advantage of the information returned in the new field.<p>Same thing with a database: I can add a new column, and clients can learn about the new column later in the future, no problem.  The database schema is just a part of the database&#x27;s API, and it can be evolved in a backwards-compatible manner just like any other API.<p>&gt; <i>to be clear, I still use Liquibase etc to manage migrations, the process for applying those changes is just completely separate from deploying application code.</i><p>Right, the schema needs to be managed and there needs to be a source of truth for it, with tooling to do migrations, but coupling that so closely with the application so the schema and application always must be in sync (like some others seem to think is the One True Way) is a mistake, and would be a complete non-starter for my past professional needs.</div><br/></div></div></div></div><div id="42285267" class="c"><input type="checkbox" id="c-42285267" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283984">parent</a><span>|</span><a href="#42284114">prev</a><span>|</span><a href="#42283801">next</a><span>|</span><label class="collapse" for="c-42285267">[-]</label><label class="expand" for="c-42285267">[1 more]</label></div><br/><div class="children"><div class="content">I had to realize that at least in start up world most (non db focused) devs thing they might not be experts in SQL but have a very solid understanding<p>... and then don&#x27;t know about a lot of very fundamental important parts and are blissfully unaware about that, too.<p>And to be clear I&#x27;m not saying they don&#x27;t remember the exact details of something.<p>What I mean they don&#x27;t even know that there are things they have to look up, nor any experience or willingness to understand what they did wrong by consulting the official documentation instead of just randomly googling and trying out &quot;solutions&quot; until one seem to happen to work.<p>The most common example would be having so little understanding about transaction that they believe transactions are just magically fixing all race conditions, and then then being very surprised that they don&#x27;t. Or believing that transactions in SQL are fundamentally broken after realizing that somehow their databases got corrupted.<p>And again I don&#x27;t mean junior deves, but people with 10+ years of backend or &quot;fullstack&quot; experience, i.e. people which at least should know that when to consult documentation&#x2F;lookup protections transactions provide etc.<p>I have seen more then one time a (final state of) the situation where people started with believing SQL transaction magically fix everything, then get &quot;corrupted&quot; data then blame SQL for being broken and move to NoSql.<p>The joke here is all the concurrency problem are very fundamental and independent of SQL vs. NoSQL.<p>And SQL often gives you more powerful&#x2F;easy to use (at small scale) tools to enforce synchronization, but at a cost. While NoSQL often gives you harder to use primitives where you have to do much more outside of the database to guarantee correctness, but then at least you will more likely blame you code instead of the db for things not working.<p>The most ironic thing here is I&#x27;m not a db expert, I just know where my knowledge stops and where I can lookup the missing parts and can&#x27;t even give you much tips about huge dbs in production luckily surprisingly many companies have comparatively &quot;small&quot; db needs.<p>And honest where I see race condition related issues in SQL quite often I&#x27;m rarely not seeing them in NoSQL code. Where this issues in SQL make me sad as they are often very avoidable in NoSQL I often feel like giving up in resignation.<p>Through that experience is for &quot;smallish&quot; databases not Twillo scale. But a surprising large amount of companies have surprisingly &quot;smallish&quot; databases. Like no joke I have seen companies being very vocal about their &quot;huge database&quot; and then you realize it&#x27;s like 5GiB ;=)<p>Honestly I (metaphorically speaking) don&#x27;t even want to know how db experts feel about this, I&#x27;m not a db expert and just have a solid enough foundation to know where my knowledge stops and when I have to look things up (which is all the time, because I&#x27;m not writing that much SQL).</div><br/></div></div></div></div><div id="42283801" class="c"><input type="checkbox" id="c-42283801" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283455">parent</a><span>|</span><a href="#42283984">prev</a><span>|</span><a href="#42285393">next</a><span>|</span><label class="collapse" for="c-42283801">[-]</label><label class="expand" for="c-42283801">[12 more]</label></div><br/><div class="children"><div class="content">&gt; Even if you have a great deployment pipeline, at some point, you&#x27;ll need to add a missing index in production fast because a wave of users came in and revealed a shit query.<p>This sounds more like a CI&#x2F;CD and process issue.<p>There is no reason why adding a new index in code and deploying it into Production should be more complex or error prone than modifying it on the database itself.</div><br/><div id="42283850" class="c"><input type="checkbox" id="c-42283850" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283801">parent</a><span>|</span><a href="#42285393">next</a><span>|</span><label class="collapse" for="c-42283850">[-]</label><label class="expand" for="c-42283850">[11 more]</label></div><br/><div class="children"><div class="content">Direct execution of `CREATE INDEX...` on a database table is always going to be faster than going through a normal deployment pipeline. Even if we assume your pipeline is <i>really</i> fast, which is probably not the case at most orgs, you are still comparing a single SQL statement execution, to a single SQL statement execution + git push + code reviews + merge + running through Jenkins&#x2F;Circle&#x2F;whatever. How long does that overhead take? How much money have you lost because your website won&#x27;t load when your post is on the frontpage of HN? Seconds and minutes count. I don&#x27;t want my code crashing because an unexpected index exists in this scenario.</div><br/><div id="42283878" class="c"><input type="checkbox" id="c-42283878" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283850">parent</a><span>|</span><a href="#42285393">next</a><span>|</span><label class="collapse" for="c-42283878">[-]</label><label class="expand" for="c-42283878">[10 more]</label></div><br/><div class="children"><div class="content">You should be able to deploy end to end to Production in less than a minute.<p>Companies should be focused on solving that problem first before doing insanely short-sighted workarounds like skipping pushing to Git and code reviews.</div><br/><div id="42283908" class="c"><input type="checkbox" id="c-42283908" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283878">parent</a><span>|</span><a href="#42283965">next</a><span>|</span><label class="collapse" for="c-42283908">[-]</label><label class="expand" for="c-42283908">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You should be able to deploy end to end to Production in less than a minute.<p>When I was at AWS (RDS) our end-to-end production deployment process was 7 days. We were also pulling $25million&#x2F;day or so in profit. I&#x27;m sure that number is much higher now.<p>There&#x27;s a large difference between what the theoretical &quot;right&quot; thing is from a textbook perspective, and what successful engineering teams do in reality.<p>edit: besides, it doesn&#x27;t even make sense in this context. I have 100 servers talking to the database. I need to create an index, ok, add it to the code. Deploy to server 1. Server 1 adds the index as part of the migration process, and let&#x27;s say it&#x27;s instant-ish (not realistic but whatever). Do the other 99 servers now panic because there&#x27;s an unexpected index on the table?</div><br/></div></div><div id="42283965" class="c"><input type="checkbox" id="c-42283965" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283878">parent</a><span>|</span><a href="#42283908">prev</a><span>|</span><a href="#42284316">next</a><span>|</span><label class="collapse" for="c-42283965">[-]</label><label class="expand" for="c-42283965">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think I have ever seen a non-toy project where that was the case.</div><br/></div></div><div id="42284316" class="c"><input type="checkbox" id="c-42284316" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283878">parent</a><span>|</span><a href="#42283965">prev</a><span>|</span><a href="#42283953">next</a><span>|</span><label class="collapse" for="c-42284316">[-]</label><label class="expand" for="c-42284316">[2 more]</label></div><br/><div class="children"><div class="content">You do code review in less than a minute?</div><br/><div id="42284932" class="c"><input type="checkbox" id="c-42284932" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42284316">parent</a><span>|</span><a href="#42283953">next</a><span>|</span><label class="collapse" for="c-42284932">[-]</label><label class="expand" for="c-42284932">[1 more]</label></div><br/><div class="children"><div class="content">You do code reviews&#x2F;automated testing in lower environments <i>before</i> you make changes directly to Production.<p>And in this case if it&#x27;s an emergency hot fix then it&#x27;s still better to do this through a managed, tracked, tested pipeline.</div><br/></div></div></div></div><div id="42283953" class="c"><input type="checkbox" id="c-42283953" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283878">parent</a><span>|</span><a href="#42284316">prev</a><span>|</span><a href="#42285393">next</a><span>|</span><label class="collapse" for="c-42283953">[-]</label><label class="expand" for="c-42283953">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a lovely ideal, but I&#x27;m the real world, there are relatively few companies that meet that metric.</div><br/><div id="42284005" class="c"><input type="checkbox" id="c-42284005" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283953">parent</a><span>|</span><a href="#42285393">next</a><span>|</span><label class="collapse" for="c-42284005">[-]</label><label class="expand" for="c-42284005">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked at FAANG and enterprise companies and we managed to do it.<p>There are no technical reasons why it can&#x27;t be done. Only process and will.</div><br/><div id="42284391" class="c"><input type="checkbox" id="c-42284391" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42284005">parent</a><span>|</span><a href="#42285284">next</a><span>|</span><label class="collapse" for="c-42284391">[-]</label><label class="expand" for="c-42284391">[2 more]</label></div><br/><div class="children"><div class="content">Yes, and that&#x27;s exactly the point.  The reality doesn&#x27;t usually match the ideals, and many orgs do not have good process, and do not have the political will to get good process implemented.  Part of being a professional is recognizing where reality falls short of the ideals (an all-too-common occurrence), and doing the best you can to successfully get your work done in that environment.<p>And of course I don&#x27;t know which FAANGs you worked at, but I know folks at FAANGs who have complained to me about CI and deployment times.  Hell, these are huge companies; while they try to harmonize tooling, deployment times (especially when test suites of varying quality are involved) can vary a lot across a company.  I wouldn&#x27;t be surprised if there were people at the companies you worked at that were upset with deployment times, even if the teams you worked on were in good shape.<p>Honestly, when someone suggests something like you&#x27;ve suggested (that everyone should be able to get their deployment times to under a minute), I really do wonder if they&#x27;re intentionally arguing in bad faith or are trolling.  I know for a fact that things are not that rosy, and are rarely that rosy, even at the companies you claim to have worked at, and it&#x27;s hard to believe that anyone could genuinely think that this is a broadly-attainable target.  That doesn&#x27;t mean that <i>no one</i> can do it, but that does mean that designing tooling that assumes everyone can do it is... well, just kinda naive and not very useful.</div><br/><div id="42284927" class="c"><input type="checkbox" id="c-42284927" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42284391">parent</a><span>|</span><a href="#42285284">next</a><span>|</span><label class="collapse" for="c-42284927">[-]</label><label class="expand" for="c-42284927">[1 more]</label></div><br/><div class="children"><div class="content">You have two choices: (1) try and solve your deployment issues or (2) make unmanaged, untested, unreviewed changes directly in Production.<p>Now you may say I&#x27;m just trolling but option (1) seems better to me for the long-term health of the project&#x2F;company. And I don&#x27;t believe it&#x27;s correct to say it is an unrealistic goal.</div><br/></div></div></div></div><div id="42285284" class="c"><input type="checkbox" id="c-42285284" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42284005">parent</a><span>|</span><a href="#42284391">prev</a><span>|</span><a href="#42285393">next</a><span>|</span><label class="collapse" for="c-42285284">[-]</label><label class="expand" for="c-42285284">[1 more]</label></div><br/><div class="children"><div class="content">There are lots of reasons to do slow rollouts. You should be rolling out in stages anyway.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42285393" class="c"><input type="checkbox" id="c-42285393" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283030">parent</a><span>|</span><a href="#42283455">prev</a><span>|</span><a href="#42283096">next</a><span>|</span><label class="collapse" for="c-42285393">[-]</label><label class="expand" for="c-42285393">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m so glad you made this. I&#x27;ve been searching for a decent Rust database library for half a year already, and this ticks all the boxes.<p>I haven&#x27;t tried it yet, so I might have to eat my words later, but- great job! It&#x27;s going to save tons of effort.</div><br/></div></div></div></div><div id="42283096" class="c"><input type="checkbox" id="c-42283096" checked=""/><div class="controls bullet"><span class="by">sobellian</span><span>|</span><a href="#42282885">parent</a><span>|</span><a href="#42283030">prev</a><span>|</span><a href="#42283893">next</a><span>|</span><label class="collapse" for="c-42283096">[-]</label><label class="expand" for="c-42283096">[1 more]</label></div><br/><div class="children"><div class="content">Surely it is easier to just check that all migrations have run before you start serving requests? Column existence is insufficient to verify that the database conforms to what the application expects (existence of indices, foreign key relationships with the right delete&#x2F;update rules, etc).</div><br/></div></div><div id="42283893" class="c"><input type="checkbox" id="c-42283893" checked=""/><div class="controls bullet"><span class="by">ris</span><span>|</span><a href="#42282885">parent</a><span>|</span><a href="#42283096">prev</a><span>|</span><a href="#42283460">next</a><span>|</span><label class="collapse" for="c-42283893">[-]</label><label class="expand" for="c-42283893">[2 more]</label></div><br/><div class="children"><div class="content">And you end up with no canonical declaration of the schema in your application code, leaving developers to mentally apply potentially tens, hundreds of migrations to build up an idea of what the tables are expected to look like.</div><br/><div id="42284460" class="c"><input type="checkbox" id="c-42284460" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283893">parent</a><span>|</span><a href="#42283460">next</a><span>|</span><label class="collapse" for="c-42284460">[-]</label><label class="expand" for="c-42284460">[1 more]</label></div><br/><div class="children"><div class="content">No matter how you define your schemas, you still have a series of migrations as data evolves. This is not an issue of schema definition.</div><br/></div></div></div></div><div id="42283460" class="c"><input type="checkbox" id="c-42283460" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#42282885">parent</a><span>|</span><a href="#42283893">prev</a><span>|</span><a href="#42284497">next</a><span>|</span><label class="collapse" for="c-42283460">[-]</label><label class="expand" for="c-42283460">[6 more]</label></div><br/><div class="children"><div class="content">The application is necessarily the authority on its expectations of the database.</div><br/><div id="42283506" class="c"><input type="checkbox" id="c-42283506" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283460">parent</a><span>|</span><a href="#42284591">next</a><span>|</span><label class="collapse" for="c-42283506">[-]</label><label class="expand" for="c-42283506">[1 more]</label></div><br/><div class="children"><div class="content">You can see my sibling comment, but in the real world of operating databases at any sort of scale, you need to have databases in transitory states where the application can continue to function even though the underlying database has changed.<p>The quintessential example is adding a column. If you want to deploy with zero downtime, you have to square with the reality that a database schema change and deployment of application code is not an atomic operation. One must happen before the other. Particularly when you deal with fleets of servers with blue&#x2F;green deploys where server 1 gets deployed at t=0minutes but server N doesn&#x27;t get deployed until t=60minutes. Your application code will straight up fail if it tries to insert a column that doesn&#x27;t exist, so it&#x27;s necessary to change the database first. This normally means adding a column that&#x27;s either nullable or has a default value, to allow the application to function as normal, without knowing the column exists.<p>So in a way, yes, the application is still the authority, but it&#x27;s an authority on the <i>interface</i> it expects from the database. It can define which columns <i>should</i> exist, but not which columns <i>should not</i> exist.</div><br/></div></div><div id="42284591" class="c"><input type="checkbox" id="c-42284591" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283460">parent</a><span>|</span><a href="#42283506">prev</a><span>|</span><a href="#42287017">next</a><span>|</span><label class="collapse" for="c-42284591">[-]</label><label class="expand" for="c-42284591">[2 more]</label></div><br/><div class="children"><div class="content">Absolutely not.  Certainly it&#x27;s necessary that the database schema be <i>compatible</i> with whatever the application believes the schema to be, but the application need not be in control of it, and at the orgs I&#x27;ve worked at, there&#x27;s no way we could build zero-downtime systems if the application had to be in charge of schema.<p>Consider even a very simple case: let&#x27;s say I have a database with two (identical) application servers talking to it (that is, I&#x27;ve horizontally scaled my application due to load and availability requirements).  If I need to do a schema change, and the application needs to be in charge of schema, how would that even work?  If I deploy the change &amp; migration to one of the two servers, once the migration is complete, the second server will freak out because the schema doesn&#x27;t match its &quot;authoritative&quot; view anymore.  If I deploy the change to both servers at the same time, and somehow designate one of them to actually run the migration, then the other one will immediately panic on startup because the first server hasn&#x27;t completed the migration yet.<p>Not to mention this setup breaks red&#x2F;black deployments: even in the case where I only have one application server in front of the database, how do I bring up a new deployment, allow both servers to run while the new one is passing health checks, and then bring down the original server?  They would both have different &quot;authoritative&quot; views of what the schema should be.<p>This also completely breaks the ability to roll back, at least without also rolling the schema back too.  That&#x27;s risky; I don&#x27;t want to have my service rollback depend on schema rollback also working properly.<p>This kind of &quot;application is authoritative about schema&quot; only works when you can schedule downtime to do schema changes.  That would be a non-starter for any company I&#x27;ve worked at.</div><br/><div id="42286307" class="c"><input type="checkbox" id="c-42286307" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42284591">parent</a><span>|</span><a href="#42287017">next</a><span>|</span><label class="collapse" for="c-42286307">[-]</label><label class="expand" for="c-42286307">[1 more]</label></div><br/><div class="children"><div class="content">The application can ensure that its assumptions hold without asserting the exact state of the database.<p>Almost all migrations are idempotent and backwards-compatible, and almost all of the rest of them can be made to be by splitting into multiple changes and waiting for old versions of the application to be shut down.</div><br/></div></div></div></div><div id="42287017" class="c"><input type="checkbox" id="c-42287017" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283460">parent</a><span>|</span><a href="#42284591">prev</a><span>|</span><a href="#42283525">next</a><span>|</span><label class="collapse" for="c-42287017">[-]</label><label class="expand" for="c-42287017">[1 more]</label></div><br/><div class="children"><div class="content">How does that work in the case where you have one database and n applications using it? Are they all somehow the authority, or do you have a way to pick one?</div><br/></div></div><div id="42283525" class="c"><input type="checkbox" id="c-42283525" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#42282885">root</a><span>|</span><a href="#42283460">parent</a><span>|</span><a href="#42287017">prev</a><span>|</span><a href="#42284497">next</a><span>|</span><label class="collapse" for="c-42283525">[-]</label><label class="expand" for="c-42283525">[1 more]</label></div><br/><div class="children"><div class="content">You might have more than one application hitting the same database</div><br/></div></div></div></div><div id="42284497" class="c"><input type="checkbox" id="c-42284497" checked=""/><div class="controls bullet"><span class="by">ojkelly</span><span>|</span><a href="#42282885">parent</a><span>|</span><a href="#42283460">prev</a><span>|</span><a href="#42283508">next</a><span>|</span><label class="collapse" for="c-42284497">[-]</label><label class="expand" for="c-42284497">[1 more]</label></div><br/><div class="children"><div class="content">Would it make more sense to consider the response from the DB, like a response from any other system or user input, and take the parse don’t validate approach?<p>After all, the DB is another system, and its state can be different to what you expected.<p>At compile time we have a best guess. Unless there was a way to tell the DB what version of the schema we think it has, it could always be wrong.</div><br/></div></div><div id="42283508" class="c"><input type="checkbox" id="c-42283508" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42282885">parent</a><span>|</span><a href="#42284497">prev</a><span>|</span><a href="#42282172">next</a><span>|</span><label class="collapse" for="c-42283508">[-]</label><label class="expand" for="c-42283508">[1 more]</label></div><br/><div class="children"><div class="content">agreed. Maybe having a schema check on the build step of the application will solve this. If the schema doesn&#x27;t match then it doesn&#x27;t compile. Most orms of course do the opposite. They generate a migration for the database from the code.</div><br/></div></div></div></div><div id="42282172" class="c"><input type="checkbox" id="c-42282172" checked=""/><div class="controls bullet"><span class="by">Diggsey</span><span>|</span><a href="#42282885">prev</a><span>|</span><a href="#42282518">next</a><span>|</span><label class="collapse" for="c-42282172">[-]</label><label class="expand" for="c-42282172">[10 more]</label></div><br/><div class="children"><div class="content">SQL, while not great, does have some advantages that are hard to beat:<p>- Everyone knows at least some basic SQL, even non-technical users have often encountered it in some form.<p>- The documentation for eg. PostgreSQL is for SQL, so if you write queries in anything else you have to mentally translate back and forth, and so you need to know SQL anyway.<p>- Any external tools you use to interact with the database will use SQL.<p>- Changing the queries doesn&#x27;t require an expensive compilation step - `sqlx` gets the best of both worlds in this respect, in that it is able to type-check the parameters and rely on the database itself to validate the query, so you don&#x27;t end up with a ton of type-system shenanigans that increase compilation times.<p>Maybe for a brand new database, a better query language could win out, but having used sqlx I can&#x27;t imagine going back to a query-builder style interface for existing SQL databases.</div><br/><div id="42282484" class="c"><input type="checkbox" id="c-42282484" checked=""/><div class="controls bullet"><span class="by">unshavedyak</span><span>|</span><a href="#42282172">parent</a><span>|</span><a href="#42282413">next</a><span>|</span><label class="collapse" for="c-42282484">[-]</label><label class="expand" for="c-42282484">[1 more]</label></div><br/><div class="children"><div class="content">I am toying with spreadsheet backends these days and it&#x27;s had me wondering - do spreadsheet query languages offer value that SQL is missing? Beyond &quot;people are used to it&quot; of course.<p>One thing i am wanting beyond SQL though is a more Object oriented language. Ie i want something SQL-like (or more specifically PRQL, which i find very nice), but without the being so tailored towards a flat data structure. I want to use it on JSON&#x2F;etc.</div><br/></div></div><div id="42282413" class="c"><input type="checkbox" id="c-42282413" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#42282172">parent</a><span>|</span><a href="#42282484">prev</a><span>|</span><a href="#42282609">next</a><span>|</span><label class="collapse" for="c-42282413">[-]</label><label class="expand" for="c-42282413">[6 more]</label></div><br/><div class="children"><div class="content">Yeah, I am using sqlx and it is amazing. The only thing it cannot do is help you in the case when you actually need a query builder, e.g. when you need support for queries with dynamic filters and sort orders. But other than that it is much nicer to work with than every other query library I have used.</div><br/><div id="42282896" class="c"><input type="checkbox" id="c-42282896" checked=""/><div class="controls bullet"><span class="by">Diggsey</span><span>|</span><a href="#42282172">root</a><span>|</span><a href="#42282413">parent</a><span>|</span><a href="#42282609">next</a><span>|</span><label class="collapse" for="c-42282896">[-]</label><label class="expand" for="c-42282896">[5 more]</label></div><br/><div class="children"><div class="content">FWIW, you very rarely need to make the query itself dynamic. After all, SQL alone is powerful enough to do conditionals.<p>For example:<p><pre><code>    SELECT * FROM example
    WHERE ($1 IS NULL OR field1 = $1)
    AND ($2 IS NULL OR field2 = $2)
    ...

</code></pre>
When you supply the parameters to this prepared statement, the constant conditions should be optimized away by the query planner if you&#x27;re using a decent database.</div><br/><div id="42283967" class="c"><input type="checkbox" id="c-42283967" checked=""/><div class="controls bullet"><span class="by">ris</span><span>|</span><a href="#42282172">root</a><span>|</span><a href="#42282896">parent</a><span>|</span><a href="#42282609">next</a><span>|</span><label class="collapse" for="c-42283967">[-]</label><label class="expand" for="c-42283967">[4 more]</label></div><br/><div class="children"><div class="content">Those tricks cover a very small subset of dynamic queries, and if you don&#x27;t give your developers a proper tool to do dynamic queries in, your code will start growing these funny string-formatting-based query-mangling functions that have god-knows-what escaping problems behind them.</div><br/><div id="42284138" class="c"><input type="checkbox" id="c-42284138" checked=""/><div class="controls bullet"><span class="by">Diggsey</span><span>|</span><a href="#42282172">root</a><span>|</span><a href="#42283967">parent</a><span>|</span><a href="#42282609">next</a><span>|</span><label class="collapse" for="c-42284138">[-]</label><label class="expand" for="c-42284138">[3 more]</label></div><br/><div class="children"><div class="content">That has not been my experience. SQL is a fully fledged programming language so there&#x27;s very little that you can&#x27;t express this way.<p>What are you doing that <i>requires</i> dynamically building a query?</div><br/><div id="42284620" class="c"><input type="checkbox" id="c-42284620" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282172">root</a><span>|</span><a href="#42284138">parent</a><span>|</span><a href="#42284629">next</a><span>|</span><label class="collapse" for="c-42284620">[-]</label><label class="expand" for="c-42284620">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>That has not been my experience</i><p>Well, it <i>has</i> been mine.  That trick you suggested works for the simple binary &quot;either include this WHERE clause filter or don&#x27;t&quot; -- which, agreed, is something that comes up often enough -- but it&#x27;s only in the simplest of CRUD apps where that&#x27;s all I&#x27;ve needed.<p>A quick example: I have a REST endpoint that updates a resource.  The JSON fields that map to the DB columns can be missing (leave the column value unchanged), null (set the column value to NULL), or have a value (set the new provided value).  The list of assignments in the UPDATE needs to be dynamic; sometimes there might be only one column being updated, sometimes two, three, four five...</div><br/></div></div><div id="42284629" class="c"><input type="checkbox" id="c-42284629" checked=""/><div class="controls bullet"><span class="by">LinXitoW</span><span>|</span><a href="#42282172">root</a><span>|</span><a href="#42284138">parent</a><span>|</span><a href="#42284620">prev</a><span>|</span><a href="#42282609">next</a><span>|</span><label class="collapse" for="c-42284629">[-]</label><label class="expand" for="c-42284629">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a fully fledged, horrible language. Anything beyond basic queries is unreadable, ESPECIALLY when it&#x27;s done in plain strings in another language. There&#x27;s not even a way to not have to repeat values EVERY SINGLE TIME (think variables or constants in every other language).<p>Oh, but what about &lt;feature&gt;? Well, is that SQL, or a frankensteined version of SQL, aka a &quot;dialect&quot;?<p>SQL is the JavaScript of databases, and we&#x27;ll be better for it once we admit this.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42282609" class="c"><input type="checkbox" id="c-42282609" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#42282172">parent</a><span>|</span><a href="#42282413">prev</a><span>|</span><a href="#42282518">next</a><span>|</span><label class="collapse" for="c-42282609">[-]</label><label class="expand" for="c-42282609">[2 more]</label></div><br/><div class="children"><div class="content">BTW, do you suggest a LINQ kind of integration in Rust? I just found the Microsoft has a Rust for C#&#x2F;.NET developers resource [1][2] which is more about integration I think. It is a little weird that there is not Rust.NET yet. .NET is not a garbage collection only platform. I guess Microsoft is working internally on this.<p>[1] <a href="https:&#x2F;&#x2F;microsoft.github.io&#x2F;rust-for-dotnet-devs&#x2F;latest&#x2F;linq&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;microsoft.github.io&#x2F;rust-for-dotnet-devs&#x2F;latest&#x2F;linq...</a>
[2] <a href="https:&#x2F;&#x2F;microsoft.github.io&#x2F;rust-for-dotnet-devs&#x2F;latest&#x2F;" rel="nofollow">https:&#x2F;&#x2F;microsoft.github.io&#x2F;rust-for-dotnet-devs&#x2F;latest&#x2F;</a></div><br/><div id="42283526" class="c"><input type="checkbox" id="c-42283526" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#42282172">root</a><span>|</span><a href="#42282609">parent</a><span>|</span><a href="#42282518">next</a><span>|</span><label class="collapse" for="c-42283526">[-]</label><label class="expand" for="c-42283526">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m impressed by this individual&#x27;s effort to bring rust to the clr: <a href="https:&#x2F;&#x2F;github.com&#x2F;FractalFir&#x2F;rustc_codegen_clr">https:&#x2F;&#x2F;github.com&#x2F;FractalFir&#x2F;rustc_codegen_clr</a><p>It is already way more complete given it&#x27;s age than I would have expected.<p>I agree that the clr is a more natural target than, let&#x27;s say, the JVM (at least until Project Valhalla comes out).</div><br/></div></div></div></div></div></div><div id="42282518" class="c"><input type="checkbox" id="c-42282518" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42282172">prev</a><span>|</span><a href="#42286773">next</a><span>|</span><label class="collapse" for="c-42282518">[-]</label><label class="expand" for="c-42282518">[22 more]</label></div><br/><div class="children"><div class="content">&gt;My opinion is that SQL should be for computers to write. This would put it firmly in the same category as LLVM IR.<p>This is nuts.<p>SQL is a high level language. It&#x27;s higher level than python or rust. It&#x27;s basically a declarative statement that&#x27;s almost english-like and it&#x27;s specifically DESIGNED to be more readable and easier to use by humans. It compiles down into many procedures that don&#x27;t easily map to the SQL statement itself. You can&#x27;t get any higher level than SQL.<p>The issue here is that the database exists at the bottleneck of web dev. It&#x27;s where state mutation happens and it&#x27;s essentially usually the slowest part of the pipeline in a computer. Yet instead of having fine grained low level control over this part of the pipeline, we have a high level language on top of it. So if we want to optimize this part of the pipeline we have to HACK the query. We have to make the abstraction layer leaky in the API itself with EXPLAIN. We can&#x27;t do direct optimizations because SQL is so high level. It is a bit of a problem but the industry is so entrenched in SQL that it&#x27;s actually 10x more efficient to just use it then to develop an API that&#x27;s more appropriate for this level. SQL is tech debt we are sort of stuck with. The ideal API would be one that is both high level but allows fine grained control... but we don&#x27;t have one yet.<p>To use machine learning analogies. SQL is a local optima. There&#x27;s a much more optimal language somewhere in this space but we are stuck in the local optima and it&#x27;s likely we will never end up finding the actual optimal api.<p>In short SQL is the furthest thing from LLVM IR. It&#x27;s crazy. You cannot treat it as the same thing. If you do there are huge problems.<p>The problem with rust query and the problem with ORMs in general is that the API for these libraries are in itself high level. They are HIGH level abstractions ON TOP of high level abstractions. You want to optimize a query now? Well you need to hack the first high level abstraction in such a way that it hacks the second high level abstraction such that it produces optimized compiled procedures. That&#x27;s the problem here.<p>All this ORM stuff is just programmer OCD. We don&#x27;t want to do meta programming where we have another language living as a string in our web app. We want everything fully integrated so we create an abstraction in attempt to get rid of an abstraction that was intended to be an abstraction in itself. It&#x27;s aesthetics and the aesthetics actually makes life harder.</div><br/><div id="42287115" class="c"><input type="checkbox" id="c-42287115" checked=""/><div class="controls bullet"><span class="by">Seb-C</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42283200">next</a><span>|</span><label class="collapse" for="c-42287115">[-]</label><label class="expand" for="c-42287115">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The ideal API would be one that is both high level but allows fine grained control... but we don&#x27;t have one yet.<p>What kind of fine grained control are you talking about here? I never felt like I was missing anything when doing even complex SQL (unless I am forced to use a crappy MySQL, which problems are not inherent to SQL itself).<p>Quite the contrary actually: despite having this amazing high level of abstaction, most developers are ignorant or don&#x27;t care to properly index the data, add integrity constraints, manage the locks or think about transactions.<p>In 99% of the non-SQL code that I see, developers don&#x27;t even go further than nested loops containing IOs, so I don&#x27;t think that letting them decide which tree&#x2F;trie is appropriate for a user case (for example) would help in any way.</div><br/></div></div><div id="42283200" class="c"><input type="checkbox" id="c-42283200" checked=""/><div class="controls bullet"><span class="by">habitue</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42287115">prev</a><span>|</span><a href="#42282654">next</a><span>|</span><label class="collapse" for="c-42283200">[-]</label><label class="expand" for="c-42283200">[1 more]</label></div><br/><div class="children"><div class="content">I see your point for one part, which is that `select([id]).from(Users)` is maybe in the best case as readable as `select id from users`, and in many common cases it&#x27;ll be less readable than sql. Plus, it&#x27;s not quite sql, you&#x27;ll have to look up how to do things a lot of times.<p>But we aren&#x27;t just talking about SQL the high level language that you might execute when you are poking the data live. In a web app dynamically constructing sql, we have multiple issues:<p>1. Deserialization: we need to know what the query returns and plug it into data structures we want to use in our program<p>2. SQL is dynamically typed, and if you construct queries dynamically you&#x27;re even more dynamically up a creek. Maybe even &quot;sql injection vulnerability&quot; up a creek.<p>1 and 2 are solved by strongly typed query builders like this: the type system has a proof that the ways you will construct queries in your program actually result in valid sql queries and that they return the right data shape.<p>It&#x27;s actually solving a real problem</div><br/></div></div><div id="42282654" class="c"><input type="checkbox" id="c-42282654" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42283200">prev</a><span>|</span><a href="#42283586">next</a><span>|</span><label class="collapse" for="c-42282654">[-]</label><label class="expand" for="c-42282654">[2 more]</label></div><br/><div class="children"><div class="content">I hear you and I 70% agree.<p>I’ve also been using Prisma for a project recently and I’ve been finding it quite good. It layers several useful features on top of sql, like schema management (checked in to git), code gen (incl typescript types), db connection management, serialization &#x2F; deserialization from JavaScript objects to sql rows and back, and it lets you follow foreign keys. If you want, you can also easily just make raw sql queries. That works fine too.<p>Sql is a very old programming language, and it’s showing its age. The design is wacky - does GROUP BY go before or after ORDER BY in the query? Every command has custom, seemingly random words which are actually parameters. They are placed at totally arbitrary, hard to remember spots in the command. And what, we make our program output a string that gets immediately parsed by the sql server? What a horrible, stupid way to do RPC. It also gives terrible error messages if you get it wrong. And it’s awful to learn and debug.<p>All of that is a huge pity, because modern databases can do so, so much. Doing logic inside the database can often be an order of magnitude faster than doing it in client code. SQL is a fantastic way to represent your data.<p>One path for fixing this would be to move the sql query parser inside the client library. Then internally, have the client library send optimized RPC instructions to the database. This would take cpu load off the database (usually a good move - databases are harder to scale). And it would open the door for the client library to provide other better, lighter and faster ways to programmatically construct database queries. Ideally without the totally unnecessary loop of constructing then parsing sql.</div><br/><div id="42282768" class="c"><input type="checkbox" id="c-42282768" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42282654">parent</a><span>|</span><a href="#42283586">next</a><span>|</span><label class="collapse" for="c-42282768">[-]</label><label class="expand" for="c-42282768">[1 more]</label></div><br/><div class="children"><div class="content">&gt;One path for fixing this would be to move the sql query parser inside the client library. Then internally, have the client library send optimized RPC instructions to the database. This would take cpu load off the database (usually a good move - databases are harder to scale). And it would open the door for the client library to provide other better, lighter and faster ways to programmatically construct database queries. Ideally without the totally unnecessary loop of constructing then parsing sql.<p>The problem here is these low level optimizations that the database is doing is freaking complicated. There&#x27;s a lot of intelligence going on in the background and it&#x27;s different depending on the database. We can solve it with a low level common IR but that IR will be extremely complex. And that IR will likely give different performance profiles for the same code on different databases.<p>I can see this being solved for one database. But not across all databases and a common api. We sort of do have a common api and we paid for it with the trade off of it being a easier high level language on top of the part of the web that needs to be most optimized.</div><br/></div></div></div></div><div id="42283586" class="c"><input type="checkbox" id="c-42283586" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42282654">prev</a><span>|</span><a href="#42283189">next</a><span>|</span><label class="collapse" for="c-42283586">[-]</label><label class="expand" for="c-42283586">[1 more]</label></div><br/><div class="children"><div class="content">I call it &quot;SQL fear&quot;, and I agree: people need to get over it. We used EFCore at my previous job, and I don&#x27;t know how much time figuring out how poorly performing queries are happening. The abstraction leaks like a sieve and isn&#x27;t worth it.<p>Now, if we could replace SQL with a purpose-built language, that I would be interested in. I have to concede that SQL doesn&#x27;t have great ergonomics (e.g. if FROM was first then auto-complete would be better, trailing commas would eliminate much formatting bike shedding, why are INSERT and UPDATE so different).</div><br/></div></div><div id="42283189" class="c"><input type="checkbox" id="c-42283189" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42283586">prev</a><span>|</span><a href="#42283036">next</a><span>|</span><label class="collapse" for="c-42283189">[-]</label><label class="expand" for="c-42283189">[1 more]</label></div><br/><div class="children"><div class="content">Every time I&#x27;ve found myself frustrated with a SQL query, there was some horrible misstep in how the underlying schema was designed.<p>Having the wisdom to craft a high quality schema can be the biggest unlock in the whole enterprise. If the tables, columns &amp; relations are ~1:1 with the actual business (i.e., you went and talked to real, live stakeholders at design time), then it should be deeply intuitive for a non-technical domain expert to interact with.<p>Often, you don&#x27;t get a chance to redo the whole thing, but that doesn&#x27;t mean you can&#x27;t still design an ideal schema and then shim it with views, CTEs, replicas, ETL, etc.<p>SQL is a <i>domain specific</i> language. It would be like complaining about how horrible it is to write Lua scripts. The criticism is baseless without understanding the underlying schema&#x2F;bindings.</div><br/></div></div><div id="42283036" class="c"><input type="checkbox" id="c-42283036" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42283189">prev</a><span>|</span><a href="#42284142">next</a><span>|</span><label class="collapse" for="c-42283036">[-]</label><label class="expand" for="c-42283036">[1 more]</label></div><br/><div class="children"><div class="content">I think the sweet spot is a query builder that just ensures you emit syntactically valid SQL to send to the database.  So there are no surprises about what the database is executing.  But protects against typos and security issues from building SQL through string concatenation.</div><br/></div></div><div id="42284142" class="c"><input type="checkbox" id="c-42284142" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42283036">prev</a><span>|</span><a href="#42282872">next</a><span>|</span><label class="collapse" for="c-42284142">[-]</label><label class="expand" for="c-42284142">[4 more]</label></div><br/><div class="children"><div class="content">I tend to agree.<p>The main trouble with SQL is that the query parameters are mixed in with the query, which results in string escape problems. That dates from when people were expected to query a database by hand from SQL, which is sometimes useful.<p>For machine generated use, SQL queries should consist of a well defined fill-in-the-blanks system, with a text SQL query and a machine data structure. Something like this:<p>Query in SQL text as a constant string:<p><pre><code>    &quot;SELECT foo FROM BAR WHERE name=NAME1&quot;
</code></pre>
Parameters: key&#x2F;value pairs in a safe native format for the language in use.<p><pre><code>    {&quot;NAME1&quot; : &quot;Smith&quot;}
</code></pre>
That gets you out of the curse of character escaping and SQL injection, 
the only real problem. It avoids trying to rewrite SQL in yet another ORM.<p>Microsoft has something which works this way, but it&#x27;s unnecessarily clunky.[1]<p>[1] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;native-client-odbc-queries&#x2F;using-statement-parameters-binding-parameters?view=sql-server-ver15" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;sql&#x2F;relational-databases&#x2F;n...</a></div><br/><div id="42284677" class="c"><input type="checkbox" id="c-42284677" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42284142">parent</a><span>|</span><a href="#42284511">next</a><span>|</span><label class="collapse" for="c-42284677">[-]</label><label class="expand" for="c-42284677">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really think SQL injection bugs are the main driver.  Certainly everyone should be using a query builder that protects them from this (and yes, I know, there are still people who screw this up), but I think the issues with SQL go far beyond that.<p>Personally I would much rather deal with a database table as a collection of objects with various fields in them.  In a language with a reasonable collections library, I want to be operating on that data using functional combinators like filter, map, group_by, sort&#x2F;order_by, etc.  That feels much more natural to me than writing out stringly-typed SQL by hand.  This is sorta an ORM, but not quite: it&#x27;s somewhere in between writing raw queries, and using a full-fledged (usually inefficient) ORM.<p>The downside, of course, is that the performance of my queries is at the mercy of whatever the query generator underneath it is doing.  But the nice thing is that if I need to optimize a query, I can always bypass the generator and write it by hand.  But I wouldn&#x27;t do that until I&#x27;ve measured things; no reason to prematurely optimize.</div><br/></div></div><div id="42284511" class="c"><input type="checkbox" id="c-42284511" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42284142">parent</a><span>|</span><a href="#42284677">prev</a><span>|</span><a href="#42282872">next</a><span>|</span><label class="collapse" for="c-42284511">[-]</label><label class="expand" for="c-42284511">[2 more]</label></div><br/><div class="children"><div class="content">This suggests a simple API using a Rust macro:<p><pre><code>    fill_in_sql!(query_string, query_params)
</code></pre>
Where query_params is a structure containing the parameters:<p><pre><code>    struct some query {
        name: &amp;str,
        id: u32,
    }
</code></pre>
The macro would parse the query string, find the variables to be filled in, match them to fields in the &quot;params&quot; structure, and generate the code to safely escape and fill in the params.
Any matching failures are found at compile time.<p>This is similar to what the usual &quot;derive&quot; macros do - examine a data structure at compile time and generate appropriate code.</div><br/><div id="42284704" class="c"><input type="checkbox" id="c-42284704" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42284511">parent</a><span>|</span><a href="#42282872">next</a><span>|</span><label class="collapse" for="c-42284704">[-]</label><label class="expand" for="c-42284704">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used systems like this in Scala.  It&#x27;s actually pretty magical to write something like:<p><pre><code>    val foos = sql&quot;SELECT * from foos WHERE status = &#x27;frobbed&#x27;&quot;.as[List[Foo]]
</code></pre>
... and have the macro system parse the query at compile time and verify that the query will indeed return a `List[Foo]`.<p>I think this is a nice middle ground, but constructing dynamic queries often can&#x27;t be checked at compile-time.<p>(I&#x27;m probably getting the syntax somewhat wrong; I haven&#x27;t done Scala in quite a few years at this point.)</div><br/></div></div></div></div></div></div><div id="42282872" class="c"><input type="checkbox" id="c-42282872" checked=""/><div class="controls bullet"><span class="by">9rx</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42284142">prev</a><span>|</span><a href="#42283781">next</a><span>|</span><label class="collapse" for="c-42282872">[-]</label><label class="expand" for="c-42282872">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; We don&#x27;t want to do meta programming where we have another language living as a string in our web app.</i><p>Strings are fine in theory, but the trouble with SQL is that, while too high-level in all the wrong places, it is also too low-level in all the wrong places. Developers want to be able to do things like define the shape of the data beyond tables and compose queries, which SQL fails hard at. In order to accomplish what developers need, you either end up extending SQL into a new language, or you can use the programming constructs you already have, treating SQL as a compiler target, where necessary. The latter is considerably easier to implement.</div><br/></div></div><div id="42283781" class="c"><input type="checkbox" id="c-42283781" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42282872">prev</a><span>|</span><a href="#42282606">next</a><span>|</span><label class="collapse" for="c-42283781">[-]</label><label class="expand" for="c-42283781">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s basically a declarative statement that&#x27;s almost english-like and it&#x27;s specifically DESIGNED to be more readable and easier to use by humans<p>It has categorically failed at this task. That is what we have an entire ecosystem of tools to allow people to query and interact with databases without using SQL.<p>Developers need to understand that SQL is an abstraction for developers, analysts, data engineers etc not end users.<p>And only basic SQL statements are English like.</div><br/></div></div><div id="42282606" class="c"><input type="checkbox" id="c-42282606" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42283781">prev</a><span>|</span><a href="#42282562">next</a><span>|</span><label class="collapse" for="c-42282606">[-]</label><label class="expand" for="c-42282606">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a good point.<p>It would be very nice to have a LLVM IR-style language for database queries, though. As a language, SQL is... well, a little behind times. ORMs explore lots of interesting design choices, but as you mention, by piling up high-level decisions on top of something that, by many aspects, are even higher decisions.<p>I wonder what an LLVM IR-like would look like in this space.</div><br/><div id="42282662" class="c"><input type="checkbox" id="c-42282662" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42282606">parent</a><span>|</span><a href="#42282562">next</a><span>|</span><label class="collapse" for="c-42282662">[-]</label><label class="expand" for="c-42282662">[2 more]</label></div><br/><div class="children"><div class="content">I agree there should be a common api. The sheer number of dialects with SQL contributes to a lot of issues with ORMs.<p>But SQL is definitely not something designed for computers to only write or compile another language into (which is what the OP is promoting).</div><br/><div id="42286781" class="c"><input type="checkbox" id="c-42286781" checked=""/><div class="controls bullet"><span class="by">Yoric</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42282662">parent</a><span>|</span><a href="#42282562">next</a><span>|</span><label class="collapse" for="c-42286781">[-]</label><label class="expand" for="c-42286781">[1 more]</label></div><br/><div class="children"><div class="content">Yeah.<p>I wonder if something like GlueSQL or the IndexedDB layer of most browsers could be used as such an API.</div><br/></div></div></div></div></div></div><div id="42282562" class="c"><input type="checkbox" id="c-42282562" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42282518">parent</a><span>|</span><a href="#42282606">prev</a><span>|</span><a href="#42286773">next</a><span>|</span><label class="collapse" for="c-42282562">[-]</label><label class="expand" for="c-42282562">[5 more]</label></div><br/><div class="children"><div class="content">&gt; You can&#x27;t get any higher level than SQL.<p>Can’t you? Wouldn’t higher level be a goal oriented natural language like “what’s the most popular music file in the database” and an AI agent just figured out how to give you the answer?</div><br/><div id="42282580" class="c"><input type="checkbox" id="c-42282580" checked=""/><div class="controls bullet"><span class="by">ninetyninenine</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42282562">parent</a><span>|</span><a href="#42286773">next</a><span>|</span><label class="collapse" for="c-42282580">[-]</label><label class="expand" for="c-42282580">[4 more]</label></div><br/><div class="children"><div class="content">Well. You know what I mean.<p>AI is also unreliable. Place chatGPT over a database and it&#x27;s going to start lying about what is in it eventually.<p>That being said my statement likely isn&#x27;t strictly true even when you account for ML. I&#x27;m sure there are even higher level languages that are not probability based and thus deterministic with expected results. But in terms of a software developers average experience, SQL is the highest level you can get without getting into the minefield that is LLMs.</div><br/><div id="42284747" class="c"><input type="checkbox" id="c-42284747" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42282580">parent</a><span>|</span><a href="#42284019">next</a><span>|</span><label class="collapse" for="c-42284747">[-]</label><label class="expand" for="c-42284747">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>SQL is the highest level you can get without getting into the minefield that is LLMs</i><p>That&#x27;s trivially false.<p>I&#x27;m currently playing with sea-orm[0], and I can write things like:<p><pre><code>    let db = Database::connect(...).await?;
    let yesterday: chrono::DateTime&lt;chrono::Utc&gt; = ...;
    let foos: Vec&lt;foos::Model&gt; = Foos::find()
        .filter(foos::Column::Status.eq(FooStatus::Frobbed))
        .filter(foos::Column::UpdatedAt.gt(yesterday))
        .left_join(Bars)
        .also_select(Bars)
        .all(&amp;db)
        .await?;
</code></pre>
How is that not higher-level than SQL?<p>[0] <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;sea-orm" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;sea-orm</a></div><br/></div></div><div id="42284019" class="c"><input type="checkbox" id="c-42284019" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42282580">parent</a><span>|</span><a href="#42284747">prev</a><span>|</span><a href="#42286342">next</a><span>|</span><label class="collapse" for="c-42284019">[-]</label><label class="expand" for="c-42284019">[1 more]</label></div><br/><div class="children"><div class="content">&gt; SQL is the highest level you can get without getting into the minefield that is LLMs<p>You can use NLPs to safely write SQL in more business language.<p>And of course there are GUIs.</div><br/></div></div><div id="42286342" class="c"><input type="checkbox" id="c-42286342" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#42282518">root</a><span>|</span><a href="#42282580">parent</a><span>|</span><a href="#42284019">prev</a><span>|</span><a href="#42286773">next</a><span>|</span><label class="collapse" for="c-42286342">[-]</label><label class="expand" for="c-42286342">[1 more]</label></div><br/><div class="children"><div class="content">&gt; SQL is the highest level you can get without getting into the minefield that is LLMs.<p>I mean, not really true. Datalog is relational, like SQL, but gives you a higher level rule-oriented mechanism for querying that can avoid a lot of the mechanics of explicitly joining things, for example.</div><br/></div></div></div></div></div></div></div></div><div id="42286773" class="c"><input type="checkbox" id="c-42286773" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#42282518">prev</a><span>|</span><a href="#42284060">next</a><span>|</span><label class="collapse" for="c-42286773">[-]</label><label class="expand" for="c-42286773">[1 more]</label></div><br/><div class="children"><div class="content">This is awesome, but also kind of hurts since I was working on something similar here: <a href="https:&#x2F;&#x2F;github.com&#x2F;andrewbaxter&#x2F;good-ormning">https:&#x2F;&#x2F;github.com&#x2F;andrewbaxter&#x2F;good-ormning</a><p>They&#x27;re very similar: Both define schema version &quot;snapshots&quot; not &quot;diffs&quot;, with diffing happening automatically, and check queries based on the latest defined version, don&#x27;t require a running database, etc.<p>The main difference seems to be about queries. My approach was to try to replicate sql query structure directly with the query builders, rather than abstract away from sql, whereas this appears to aim for something that&#x27;s less similar to the original sql.  I don&#x27;t consider myself an sql expert and I&#x27;ve seen sql abstractions that aren&#x27;t able to replicate all functionality, but seeing the reddit debate with the diesel author this seems fairly thorough.<p>FWIW in `good-ormning` I was thinking of getting rid of the query builders&#x2F;my own query ast and having a macro that parses with `datafusion-sqlparser-rs` and checks that ast instead, but it&#x27;s a significant change.<p>FWIW I think SQL is awful too, so I&#x27;m really happy to see the support here and I hope rust-query takes off.</div><br/></div></div><div id="42284060" class="c"><input type="checkbox" id="c-42284060" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42286773">prev</a><span>|</span><a href="#42282125">next</a><span>|</span><label class="collapse" for="c-42284060">[-]</label><label class="expand" for="c-42284060">[4 more]</label></div><br/><div class="children"><div class="content">When this was posted on reddit, I saw someone [0] ask how it was different from diesel-rs (and diesel-async, the officially supported add-on crate, lest someone says diesel doesn&#x27;t have async).<p>I saw some replies by the diesel maintainer about how the creator of this Rust-Query might not have really understood in-depth how diesel worked and wanted to write their own solution, and there&#x27;s nothing wrong with that, of course, but this thread might be some good context for others asking themselves similar questions.<p>[0] <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;s&#x2F;6midd79iDo" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;s&#x2F;6midd79iDo</a></div><br/><div id="42286740" class="c"><input type="checkbox" id="c-42286740" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#42284060">parent</a><span>|</span><a href="#42284348">next</a><span>|</span><label class="collapse" for="c-42286740">[-]</label><label class="expand" for="c-42286740">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m (was? not sure after seeing this) working on a similar thing to this, and the most significant difference between this and diesel is that this has stronger safety guarantees by controlling migrations as well, whereas diesel just trusts the database is in the state you claim it is.</div><br/><div id="42287135" class="c"><input type="checkbox" id="c-42287135" checked=""/><div class="controls bullet"><span class="by">weiznich</span><span>|</span><a href="#42284060">root</a><span>|</span><a href="#42286740">parent</a><span>|</span><a href="#42284348">next</a><span>|</span><label class="collapse" for="c-42287135">[-]</label><label class="expand" for="c-42287135">[1 more]</label></div><br/><div class="children"><div class="content">You get the same safety guarantees with diesel by using the [`embed_migration!`](<a href="https:&#x2F;&#x2F;docs.diesel.rs&#x2F;2.2.x&#x2F;diesel_migrations&#x2F;macro.embed_migrations.html" rel="nofollow">https:&#x2F;&#x2F;docs.diesel.rs&#x2F;2.2.x&#x2F;diesel_migrations&#x2F;macro.embed_m...</a>) macro and running your applications on startup. Diesel decouples that as there are situations where you might want to work with a slightly different database as defined, for example if you don&#x27;t control the database.</div><br/></div></div></div></div><div id="42284348" class="c"><input type="checkbox" id="c-42284348" checked=""/><div class="controls bullet"><span class="by">pstoll</span><span>|</span><a href="#42284060">parent</a><span>|</span><a href="#42286740">prev</a><span>|</span><a href="#42282125">next</a><span>|</span><label class="collapse" for="c-42284348">[-]</label><label class="expand" for="c-42284348">[1 more]</label></div><br/><div class="children"><div class="content">When a sample showing a new SQL thing has eg<p>a) no id types eg for User, just a string
b) uses i64 for “stars” 
C) any other of a million things…<p>I quickly conclude it’s likely a cute toy by someone who wanted to write a thing, not ever likely to be a battle-hardened effort brought forth by a high performance &#x2F; scale database tortured soul. And I move on.</div><br/></div></div></div></div><div id="42282125" class="c"><input type="checkbox" id="c-42282125" checked=""/><div class="controls bullet"><span class="by">davidatbu</span><span>|</span><a href="#42284060">prev</a><span>|</span><a href="#42282031">next</a><span>|</span><label class="collapse" for="c-42282125">[-]</label><label class="expand" for="c-42282125">[4 more]</label></div><br/><div class="children"><div class="content">I am really happy to see some more exploration in the typesafe-db-access-in-Rust space.<p>&gt; The existing libraries don&#x27;t provide the compile time guarantees that I want and are verbose or awkward like SQL.<p>Worth noting: diesel definitely fulfills the &quot;providing compile time guarantees&quot; criteria.<p>Here&#x27;s where I stand on the inevitable ORM-vs-no-ORM debate that&#x27;s about to erupt: I like typesafe query builders that don&#x27;t abstract over sql ( I&#x27;d put diesel in this category, and i would not put activerecord or djangos orm or sealORM in this category).<p>It looks like rust-query will lean towards the full-ORM side  of that spectrum. Not my cup of tea, but the tea industry can accommodate many flavors :)</div><br/><div id="42282503" class="c"><input type="checkbox" id="c-42282503" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#42282125">parent</a><span>|</span><a href="#42282506">next</a><span>|</span><label class="collapse" for="c-42282503">[-]</label><label class="expand" for="c-42282503">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Worth noting: diesel definitely fulfills the &quot;providing compile time guarantees&quot; criteria.</i><p>Also sqlx.<p>I liked the article and I bookmarked the library but this statement from the author confused me a bit. At least two libraries give you pretty good compile-time guarantees. sqlx even gives you the option to specify a DB where it can check whether your queries will succeed at runtime.</div><br/><div id="42287143" class="c"><input type="checkbox" id="c-42287143" checked=""/><div class="controls bullet"><span class="by">weiznich</span><span>|</span><a href="#42282125">root</a><span>|</span><a href="#42282503">parent</a><span>|</span><a href="#42282506">next</a><span>|</span><label class="collapse" for="c-42287143">[-]</label><label class="expand" for="c-42287143">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also sqlx.<p>The guarantees provides by sqlx are less strong than what&#x27;s provided by diesel due to the fact that sqlx needs to know the complete query statically at compile time. This excludes dynamic constructs like `IN` expressions or dynamic where clauses from the set of checked queries. Diesel also verifies that these queries are correct at compile time.</div><br/></div></div></div></div><div id="42282506" class="c"><input type="checkbox" id="c-42282506" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#42282125">parent</a><span>|</span><a href="#42282503">prev</a><span>|</span><a href="#42282031">next</a><span>|</span><label class="collapse" for="c-42282506">[-]</label><label class="expand" for="c-42282506">[1 more]</label></div><br/><div class="children"><div class="content">Agree. SQL libraries should aim to make any valid query possible to express (though semantic equivalents are fine) while integrating query building into the rest of the language as seamlessly as possible.</div><br/></div></div></div></div><div id="42282031" class="c"><input type="checkbox" id="c-42282031" checked=""/><div class="controls bullet"><span class="by">typicalset</span><span>|</span><a href="#42282125">prev</a><span>|</span><a href="#42286750">next</a><span>|</span><label class="collapse" for="c-42282031">[-]</label><label class="expand" for="c-42282031">[2 more]</label></div><br/><div class="children"><div class="content">This looks interesting as an approach to relating schema to data types. One aspect that feels very counter-intuitive&#x2F;unidiomatic is that, if I understand correctly, in your example there is no Schema enum. Usually this sort of macro does not erase the type defined, and I would find it extremely confusing that I cannot reference, say, Schema::User{..}. It would be clearer to me if this were defined inside of a macro_rules macro, more like lazy_static e.g.<p>```
schema!{
User {
    name: String,
},
Story {
    author: User,
    title: String,
    content: String,
},
}
```</div><br/><div id="42282385" class="c"><input type="checkbox" id="c-42282385" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishz</span><span>|</span><a href="#42282031">parent</a><span>|</span><a href="#42286750">next</a><span>|</span><label class="collapse" for="c-42282385">[-]</label><label class="expand" for="c-42282385">[1 more]</label></div><br/><div class="children"><div class="content">I was just about to ask WTF is a Schema-typed value supposed to represent.</div><br/></div></div></div></div><div id="42286750" class="c"><input type="checkbox" id="c-42286750" checked=""/><div class="controls bullet"><span class="by">runeks</span><span>|</span><a href="#42282031">prev</a><span>|</span><a href="#42284161">next</a><span>|</span><label class="collapse" for="c-42286750">[-]</label><label class="expand" for="c-42286750">[1 more]</label></div><br/><div class="children"><div class="content">Nit: a DB query can never be made type safe (avoiding runtime failure) because its correctness depends on the state of an external service, which may change at any point in time.</div><br/></div></div><div id="42284161" class="c"><input type="checkbox" id="c-42284161" checked=""/><div class="controls bullet"><span class="by">mijoharas</span><span>|</span><a href="#42286750">prev</a><span>|</span><a href="#42283959">next</a><span>|</span><label class="collapse" for="c-42284161">[-]</label><label class="expand" for="c-42284161">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The actual row numbers are never exposed from the library API. Application logic should not need to know about them.<p>This point confuses me. If we&#x27;re thinking about a web server, you&#x27;ll pass your data to the frontend with a row ID, so that they can refer to and modify that data in another request? How would it work otherwise?<p>Am I missing something? I can think of some use cases, but this limitation cuts down on the uses I&#x27;d have for this massively.</div><br/><div id="42284279" class="c"><input type="checkbox" id="c-42284279" checked=""/><div class="controls bullet"><span class="by">twiss</span><span>|</span><a href="#42284161">parent</a><span>|</span><a href="#42283959">next</a><span>|</span><label class="collapse" for="c-42284279">[-]</label><label class="expand" for="c-42284279">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing they&#x27;re talking about <a href="https:&#x2F;&#x2F;www.complexsql.com&#x2F;rowid-rownum&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.complexsql.com&#x2F;rowid-rownum&#x2F;</a>, i.e. the row numbers defined by the database, rather than the value of the ID column you typically create in each table.<p>I.e., it should still be possible to create a column with a public identifier by which you can refer to the row, I assume.</div><br/></div></div></div></div><div id="42283959" class="c"><input type="checkbox" id="c-42283959" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#42284161">prev</a><span>|</span><a href="#42282314">next</a><span>|</span><label class="collapse" for="c-42283959">[-]</label><label class="expand" for="c-42283959">[1 more]</label></div><br/><div class="children"><div class="content">&gt;My opinion is that SQL should be for computers to write. This would put it firmly in the same category as LLVM IR.<p>Although I partially agree with the high level idea of this statement (let&#x27;s accept the reality; no mature database is going to support your new shiny query language anytime soon), SQL is not the most convenient language to be written by code generator. Actually this is a sort of nightmare; a seemingly simple plan optimization would completely change the layout of the query so you&#x27;re going to have a decent chance to write a full query rewrite stage just for the sake of workaround for a specific query engine. Google&#x27;s SQL pipe proposal seems to make it a bit better but it has the same problem of new query languages unless it&#x27;s broadly adopted.</div><br/></div></div><div id="42282314" class="c"><input type="checkbox" id="c-42282314" checked=""/><div class="controls bullet"><span class="by">mattrighetti</span><span>|</span><a href="#42283959">prev</a><span>|</span><a href="#42282465">next</a><span>|</span><label class="collapse" for="c-42282314">[-]</label><label class="expand" for="c-42282314">[2 more]</label></div><br/><div class="children"><div class="content">Looks nice! I’ve been using SeaQuery for a while now but documentation is not that great if you’re looking to create some more advanced queries.<p>While I liked the idea of having strongly typed queries I’ve lately found out that sometimes they unnecessarily slow me down during the development process, I’m considering going back to the good old prep statements and binding values manually.</div><br/><div id="42284406" class="c"><input type="checkbox" id="c-42284406" checked=""/><div class="controls bullet"><span class="by">giovannibonetti</span><span>|</span><a href="#42282314">parent</a><span>|</span><a href="#42282465">next</a><span>|</span><label class="collapse" for="c-42284406">[-]</label><label class="expand" for="c-42284406">[1 more]</label></div><br/><div class="children"><div class="content">You might be interested in SQLx, since you write the SQL but the library generates the tedious bindings for you.</div><br/></div></div></div></div><div id="42282465" class="c"><input type="checkbox" id="c-42282465" checked=""/><div class="controls bullet"><span class="by">ocschwar</span><span>|</span><a href="#42282314">prev</a><span>|</span><a href="#42282878">next</a><span>|</span><label class="collapse" for="c-42282465">[-]</label><label class="expand" for="c-42282465">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this! I am looking forward to putting this together with the Zola CMS for some hobby applications.</div><br/></div></div><div id="42282878" class="c"><input type="checkbox" id="c-42282878" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#42282465">prev</a><span>|</span><a href="#42282288">next</a><span>|</span><label class="collapse" for="c-42282878">[-]</label><label class="expand" for="c-42282878">[3 more]</label></div><br/><div class="children"><div class="content">It seems that migrations with individual row level manipulation would be <i>tragically</i> slow to execute to me? Like, I have a table with a billion rows, and any normal update statement takes up to an hour. I don’t want to think what an update per row would take.</div><br/><div id="42283055" class="c"><input type="checkbox" id="c-42283055" checked=""/><div class="controls bullet"><span class="by">Hytak</span><span>|</span><a href="#42282878">parent</a><span>|</span><a href="#42282288">next</a><span>|</span><label class="collapse" for="c-42283055">[-]</label><label class="expand" for="c-42283055">[2 more]</label></div><br/><div class="children"><div class="content">Hi, migrations are 1 select statement + `n` insert statement for `n` rows right now.<p>This might be improved to insert in batches in the future without changing the API.</div><br/><div id="42284369" class="c"><input type="checkbox" id="c-42284369" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#42282878">root</a><span>|</span><a href="#42283055">parent</a><span>|</span><a href="#42282288">next</a><span>|</span><label class="collapse" for="c-42284369">[-]</label><label class="expand" for="c-42284369">[1 more]</label></div><br/><div class="children"><div class="content">I imagine a select on 1B rows will be equally problematic :)<p>But you are right, it’s not something you necessarily have to worry about now. It just means it doesn’t work for our use case.<p>Just figured I should point it out.</div><br/></div></div></div></div></div></div><div id="42282288" class="c"><input type="checkbox" id="c-42282288" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42282878">prev</a><span>|</span><a href="#42285192">next</a><span>|</span><label class="collapse" for="c-42282288">[-]</label><label class="expand" for="c-42282288">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for releasing this! More ideas are great and welcome, and even I don’t use this directly, maybe the ORM I use will like some of the features and add them.<p>But I have to admit, this one bit almost made me stop reading:<p>&gt; For those who don&#x27;t know, SQL is the standard when it comes to interacting with databases.<p>I can scarcely imagine anyone who both 1. would want to use this and 2. doesn’t know what SQL is. So if I’m reading this, and you’re telling me what a database is, I assume you assume I’m an idiot. This makes me wonder if it has design choices to protect hypothetical Rust-using, DB-using idiots from themselves at the expense of making it hard to handle edge cases.<p>I’m sure you didn’t mean it that way, but that’s how it rubbed me. Maybe consider leaving out the extremely basic introductory bits.</div><br/><div id="42282741" class="c"><input type="checkbox" id="c-42282741" checked=""/><div class="controls bullet"><span class="by">davidatbu</span><span>|</span><a href="#42282288">parent</a><span>|</span><a href="#42285192">next</a><span>|</span><label class="collapse" for="c-42282741">[-]</label><label class="expand" for="c-42282741">[2 more]</label></div><br/><div class="children"><div class="content">A more charitable take is that OP tried to make his blogpost more accessible to newbies at a very small verbosity cost for non-newbies.<p>Fwiw: i&#x27;m totally fine with that.<p>&gt; This makes me wonder if it has design choices to ...<p>I personally felt that the relevant design choices were explicitly enumerated, and so one needs not to deduce them from the rest of the text.</div><br/><div id="42283241" class="c"><input type="checkbox" id="c-42283241" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42282288">root</a><span>|</span><a href="#42282741">parent</a><span>|</span><a href="#42285192">next</a><span>|</span><label class="collapse" for="c-42283241">[-]</label><label class="expand" for="c-42283241">[1 more]</label></div><br/><div class="children"><div class="content">That’s fair, and I offered that mainly in the spirit of feedback. <i>To me</i>, and perhaps to no one else, but just <i>to me</i>, it was a little off putting. Like, “yeah, yeah, I know what SQL is. Do you think I don’t? Or did you just learn about it last month and you’re eager to share?”<p>I’m certainly not gonna lose sleep over it. Someone came on HN to show us their neat new project. I wanted to give them my first impression to help them craft their future messaging. If they disagree, fine with me! They don’t owe me anything.</div><br/></div></div></div></div></div></div><div id="42285192" class="c"><input type="checkbox" id="c-42285192" checked=""/><div class="controls bullet"><span class="by">skeptrune</span><span>|</span><a href="#42282288">prev</a><span>|</span><a href="#42282017">next</a><span>|</span><label class="collapse" for="c-42285192">[-]</label><label class="expand" for="c-42285192">[1 more]</label></div><br/><div class="children"><div class="content">Diesel basically being the same as Postgres SQL is an awesome feature. I&#x27;d much rather than then an abstracted query language which is difficult to understand.</div><br/></div></div><div id="42282017" class="c"><input type="checkbox" id="c-42282017" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#42285192">prev</a><span>|</span><a href="#42282629">next</a><span>|</span><label class="collapse" for="c-42282017">[-]</label><label class="expand" for="c-42282017">[14 more]</label></div><br/><div class="children"><div class="content">Good luck with this, Lucas! We need all of the innovation in the Rust DB space we can get.<p>I can&#x27;t use yours in production yet as it only supports SQLite, but I&#x27;ll keep my eyes peeled for updates.<p>We&#x27;re using Sqlx and Diesel in production currently.<p>Sqlx is great because it&#x27;s not an ORM and lets you write &quot;type checked&quot; raw SQL. It frustrates us in the fact that you can&#x27;t write dynamic queries and have them be type checked, though. No `IN` clauses or conditional predicates, only static queries with simple bindings get type checked.<p>Love to see more ORMs like yours! Diesel isn&#x27;t our favorite.</div><br/><div id="42282130" class="c"><input type="checkbox" id="c-42282130" checked=""/><div class="controls bullet"><span class="by">written-beyond</span><span>|</span><a href="#42282017">parent</a><span>|</span><a href="#42282088">next</a><span>|</span><label class="collapse" for="c-42282130">[-]</label><label class="expand" for="c-42282130">[2 more]</label></div><br/><div class="children"><div class="content">My first Rust PR was for a Diesel Plugin crate, their macros weren&#x27;t updated with Rusts newer spec.<p>I honestly really enjoyed Diesel but it&#x27;s extremely slow migration to async really made it lose traction.<p>I&#x27;ve used SQLx extensively for projects after that and it was pretty decent.</div><br/><div id="42287173" class="c"><input type="checkbox" id="c-42287173" checked=""/><div class="controls bullet"><span class="by">weiznich</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42282130">parent</a><span>|</span><a href="#42282088">next</a><span>|</span><label class="collapse" for="c-42287173">[-]</label><label class="expand" for="c-42287173">[1 more]</label></div><br/><div class="children"><div class="content">Please note that up until today an async rust database library does not give you any measurable performance advantage compared to a sync database library. In addition to that it won&#x27;t even matter for most applications as they don&#x27;t reach the required scale to even hit that bottleneck. As a matter of facts crates.io just run well on sync diesel up until maybe a month ago. They have now switched to diesel-async, for certain specific not-performance related reasons. The lead developer there told me specifically that from a performance point of view the service would have been fine with sync diesel for quite a while without problems, and that&#x27;s with somewhat exponential growth of requests.<p>Other than that the async rust ecosystem is still in a place that makes it literally impossible to provide strong guarantees around handling transactions and make sure that they ended, which is a main reason why diesel-async is not considered stable from my side yet. This problem exists in all other async rust database libraries as well, as it&#x27;s an language level problem. They just do not document this correctly.</div><br/></div></div></div></div><div id="42282088" class="c"><input type="checkbox" id="c-42282088" checked=""/><div class="controls bullet"><span class="by">Simpliplant</span><span>|</span><a href="#42282017">parent</a><span>|</span><a href="#42282130">prev</a><span>|</span><a href="#42282183">next</a><span>|</span><label class="collapse" for="c-42282088">[-]</label><label class="expand" for="c-42282088">[9 more]</label></div><br/><div class="children"><div class="content">After being frustrated with Diesel, I gave a try to SeaORM and I couldn’t be happier (have been using it for more than a year). It is not perfect but certainly the best ORM I have ever used myself (vs Diesel, ActiveRecord, SQLAlchemy)</div><br/><div id="42282301" class="c"><input type="checkbox" id="c-42282301" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42282088">parent</a><span>|</span><a href="#42284105">next</a><span>|</span><label class="collapse" for="c-42282301">[-]</label><label class="expand" for="c-42282301">[5 more]</label></div><br/><div class="children"><div class="content">How come? I’m new to the space and picked Diesel a couple weeks ago for a new project because it seemed the most recommended. What do you prefer about SeaORM?</div><br/><div id="42282788" class="c"><input type="checkbox" id="c-42282788" checked=""/><div class="controls bullet"><span class="by">Simpliplant</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42282301">parent</a><span>|</span><a href="#42284105">next</a><span>|</span><label class="collapse" for="c-42282788">[-]</label><label class="expand" for="c-42282788">[4 more]</label></div><br/><div class="children"><div class="content">To me, SeaORM feels like a well-designed library while many things in Diesel feel like an afterthought or a hack. Which mostly manifests itself when doing something complex and debugging it.<p>Also recommend reading <a href="https:&#x2F;&#x2F;www.sea-ql.org&#x2F;SeaORM&#x2F;docs&#x2F;internal-design&#x2F;diesel&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.sea-ql.org&#x2F;SeaORM&#x2F;docs&#x2F;internal-design&#x2F;diesel&#x2F;</a></div><br/><div id="42287150" class="c"><input type="checkbox" id="c-42287150" checked=""/><div class="controls bullet"><span class="by">weiznich</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42282788">parent</a><span>|</span><a href="#42283242">next</a><span>|</span><label class="collapse" for="c-42287150">[-]</label><label class="expand" for="c-42287150">[1 more]</label></div><br/><div class="children"><div class="content">Please note that this comparison is outdated since at least 2 years, given that diesel-async exists for more than 2 years now and this page completely forgets to mention it.</div><br/></div></div><div id="42283242" class="c"><input type="checkbox" id="c-42283242" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42282788">parent</a><span>|</span><a href="#42287150">prev</a><span>|</span><a href="#42283453">next</a><span>|</span><label class="collapse" for="c-42283242">[-]</label><label class="expand" for="c-42283242">[1 more]</label></div><br/><div class="children"><div class="content">I’ll check it out. Thanks!</div><br/></div></div><div id="42283453" class="c"><input type="checkbox" id="c-42283453" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42282788">parent</a><span>|</span><a href="#42283242">prev</a><span>|</span><a href="#42284105">next</a><span>|</span><label class="collapse" for="c-42283453">[-]</label><label class="expand" for="c-42283453">[1 more]</label></div><br/><div class="children"><div class="content">sea-query looks a lot like jOOQ!</div><br/></div></div></div></div></div></div><div id="42284105" class="c"><input type="checkbox" id="c-42284105" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42282088">parent</a><span>|</span><a href="#42282301">prev</a><span>|</span><a href="#42282183">next</a><span>|</span><label class="collapse" for="c-42284105">[-]</label><label class="expand" for="c-42284105">[3 more]</label></div><br/><div class="children"><div class="content">SeaORM is not compile time safe by their own admission so it&#x27;s automatically out of the running, personally speaking.</div><br/><div id="42284787" class="c"><input type="checkbox" id="c-42284787" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42284105">parent</a><span>|</span><a href="#42282183">next</a><span>|</span><label class="collapse" for="c-42284787">[-]</label><label class="expand" for="c-42284787">[2 more]</label></div><br/><div class="children"><div class="content">That feels like a weird requirement to me; an ORM is by its very nature not going to be able to validate queries at compile-time.<p>And even if you&#x27;re writing queries directly, any time you need to write something dynamic, you&#x27;re not going to be able to verify those at compile-time either.</div><br/><div id="42284935" class="c"><input type="checkbox" id="c-42284935" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42284787">parent</a><span>|</span><a href="#42282183">next</a><span>|</span><label class="collapse" for="c-42284935">[-]</label><label class="expand" for="c-42284935">[1 more]</label></div><br/><div class="children"><div class="content">&gt; an ORM is by its very nature not going to be able to validate queries at compile-time.<p>I don&#x27;t see why this is by its &quot;very nature&quot; when libraries like diesel or Prisma already do this.<p>&gt; any time you need to write something dynamic, you&#x27;re not going to be able to verify those at compile-time either.<p>Diesel can validate dynamic queries at compile time too, sqlx too to some extent.</div><br/></div></div></div></div></div></div></div></div><div id="42282183" class="c"><input type="checkbox" id="c-42282183" checked=""/><div class="controls bullet"><span class="by">k972</span><span>|</span><a href="#42282017">parent</a><span>|</span><a href="#42282088">prev</a><span>|</span><a href="#42282629">next</a><span>|</span><label class="collapse" for="c-42282183">[-]</label><label class="expand" for="c-42282183">[2 more]</label></div><br/><div class="children"><div class="content">Depending on what database you&#x27;re using, you might be able to restructure your dynamic queries to fit a static form...<p>WHERE
  ...
  AND CASE WHEN ? IS NULL THEN TRUE ELSE col ILIKE ? || &#x27;%&#x27; END
  AND CASE WHEN ? IS NULL THEN TRUE ELSE col2 IN (?) END<p>Each &quot;dynamic&quot; parameter is then bound twice. (My personal preference is to use a CTE to bind and name my parameter values in the query instead of binding multiple times whenever possible).</div><br/><div id="42284794" class="c"><input type="checkbox" id="c-42284794" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42282017">root</a><span>|</span><a href="#42282183">parent</a><span>|</span><a href="#42282629">next</a><span>|</span><label class="collapse" for="c-42284794">[-]</label><label class="expand" for="c-42284794">[1 more]</label></div><br/><div class="children"><div class="content">That only works when the dynamic portion is in the WHERE clause, though.  I often need to dynamically generate UPDATEs and even sometimes INSERTs.</div><br/></div></div></div></div></div></div><div id="42282629" class="c"><input type="checkbox" id="c-42282629" checked=""/><div class="controls bullet"><span class="by">tyleo</span><span>|</span><a href="#42282017">prev</a><span>|</span><a href="#42283231">next</a><span>|</span><label class="collapse" for="c-42282629">[-]</label><label class="expand" for="c-42282629">[1 more]</label></div><br/><div class="children"><div class="content">It looks like you just got this blog set up. Congratulations!</div><br/></div></div><div id="42283231" class="c"><input type="checkbox" id="c-42283231" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#42282629">prev</a><span>|</span><a href="#42284044">next</a><span>|</span><label class="collapse" for="c-42283231">[-]</label><label class="expand" for="c-42283231">[1 more]</label></div><br/><div class="children"><div class="content">This is close to something I&#x27;ve wanted to see for a long time: a language where relational models are first class citizens and the engine for data storage is abstracted away.<p>Tables, joins, etc. should all be representable within the language&#x27;s type system and standard libraries. Connectivity to a database should be handled by plugins&#x2F;implementations of storage engines. If no storage engine is used, the relational data just lives in RAM like any other variable, collection, etc.<p>It&#x27;s kind of the opposite of an ORM. An ORM tries to bolt a relational database into an OOP or other language model. This wraps the language around relational database concepts, fixing the impedance mismatch in the language rather than with a translation layer.<p>It also means one does not have to reinvent relational concepts (badly) in every application with a complex data model even if that application is <i>not</i> backed by a database.</div><br/></div></div><div id="42284044" class="c"><input type="checkbox" id="c-42284044" checked=""/><div class="controls bullet"><span class="by">omani</span><span>|</span><a href="#42283231">prev</a><span>|</span><label class="collapse" for="c-42284044">[-]</label><label class="expand" for="c-42284044">[2 more]</label></div><br/><div class="children"><div class="content">everytime I see something like this I question myself why I would want or need this over postgREST.<p>I mean why reinvent the wheel? we live in a time where the DB itself is a REST API with postgREST.<p><a href="https:&#x2F;&#x2F;postgrest.com" rel="nofollow">https:&#x2F;&#x2F;postgrest.com</a></div><br/><div id="42284099" class="c"><input type="checkbox" id="c-42284099" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42284044">parent</a><span>|</span><label class="collapse" for="c-42284099">[-]</label><label class="expand" for="c-42284099">[1 more]</label></div><br/><div class="children"><div class="content">Why would I want to interact with my database over the network when I can just...do it locally? It&#x27;s orders of magnitudes slower and more wasteful and it doesn&#x27;t even provide all the guarantees that using actual SQL or an ORM does.</div><br/></div></div></div></div></div></div></div></div></div></body></html>