<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685005259881" as="style"/><link rel="stylesheet" href="styles.css?v=1685005259881"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.acm.org/media-center/2023/may/dissertation-award-2022">UCLA computer grad constructs “crown jewel of cryptography”</a> <span class="domain">(<a href="https://www.acm.org">www.acm.org</a>)</span></div><div class="subtext"><span>geox</span> | <span>75 comments</span></div><br/><div><div id="36067855" class="c"><input type="checkbox" id="c-36067855" checked=""/><div class="controls bullet"><span class="by">hkopp</span><span>|</span><a href="#36065179">next</a><span>|</span><label class="collapse" for="c-36067855">[-]</label><label class="expand" for="c-36067855">[1 more]</label></div><br/><div class="children"><div class="content">The precise mathematical definition of obfuscation and what is considered obfuscation for an average software engineer are two very different things.<p>In fact, the article is only about indistinguishability obfuscation. What is mostly discussed in this thread is the notion of virtual black box obfuscation (VBB).
VBB has been proven to be impossible in the general case (see <a href="https:&#x2F;&#x2F;www.wisdom.weizmann.ac.il&#x2F;~oded&#x2F;PS&#x2F;obf4.pdf" rel="nofollow">https:&#x2F;&#x2F;www.wisdom.weizmann.ac.il&#x2F;~oded&#x2F;PS&#x2F;obf4.pdf</a>). There are a few special programs where VBB is feasible, such as point functions, but in general in cannot be achieved.<p>Indistinguishability obfuscation (iO) means that if you obfuscate two programs that compute the same function, then you cannot distinguish them. Or put in different words, if you get two obfuscated programs, then there is no better way than random guessing (except for a factor that is negligible in some security parameter) to find out if they stem from the same original program.</div><br/></div></div><div id="36065179" class="c"><input type="checkbox" id="c-36065179" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36067855">prev</a><span>|</span><a href="#36065445">next</a><span>|</span><label class="collapse" for="c-36065179">[-]</label><label class="expand" for="c-36065179">[45 more]</label></div><br/><div class="children"><div class="content">That is a fascinating result. A remarkable mathematical achievement. And a nightmare.<p>This thesis says that it&#x27;s possible to obfuscate code in such a way that there is a lower bound on the level of effort needed to de-obfuscate it. That lower bound can apparently be comparable to the level of effort required to break a cryptosystem.<p>So, coming soon, viruses and worms nobody can figure out. Code where no one can tell if it has a backdoor. ML classifiers where no one can be sure what they really do.</div><br/><div id="36068214" class="c"><input type="checkbox" id="c-36068214" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36065260">next</a><span>|</span><label class="collapse" for="c-36068214">[-]</label><label class="expand" for="c-36068214">[1 more]</label></div><br/><div class="children"><div class="content">Just don&#x27;t trust that code, and don&#x27;t run it?<p>You should require positive proof that code does what you want.<p>Similar to how eg Haskell&#x27;s type systems doesn&#x27;t have to solve the halting problem [0]: it just rejects some programs that would be ok, but don&#x27;t conform to the type system.<p>See also proof-carrying code. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proof-carrying_code" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proof-carrying_code</a><p>[0] Ok, unless you use undecidable instances or something like that.</div><br/></div></div><div id="36065260" class="c"><input type="checkbox" id="c-36065260" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36068214">prev</a><span>|</span><a href="#36067623">next</a><span>|</span><label class="collapse" for="c-36065260">[-]</label><label class="expand" for="c-36065260">[16 more]</label></div><br/><div class="children"><div class="content">Is it just an existence proof or is it actually constructive? (I haven&#x27;t read the dissertation.)</div><br/><div id="36065515" class="c"><input type="checkbox" id="c-36065515" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065260">parent</a><span>|</span><a href="#36065467">next</a><span>|</span><label class="collapse" for="c-36065515">[-]</label><label class="expand" for="c-36065515">[12 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure. It seems to be applied to &quot;circuits&quot;, which in this context seems to mean a one-way set of logic gates (such as AND, OR, NOT, NAND) which map a set of boolean inputs to a set of boolean outputs. In theory you can construct any finite digital function that way. It&#x27;s a useful abstraction, like a Turing machine.<p>Unlike a Turing machine, a circuit is finite. All circuits are &quot;solveable&quot; (given a outputs, compute an input which yields them) by trying all the input patterns..
There&#x27;s no undecidability and no halting problem. There&#x27;s just difficulty.
&quot;Difficult&quot; here means there&#x27;s no way easier than trying all the patterns.
This is the same property sound cryptosystems are supposed to have - there&#x27;s no easier way than trying all the keys.<p>Whether this result can be extended to programs with iteration I&#x27;m not sure. The paper doesn&#x27;t seem to mention iteration or storage.</div><br/><div id="36066860" class="c"><input type="checkbox" id="c-36066860" checked=""/><div class="controls bullet"><span class="by">jhanschoo</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065515">parent</a><span>|</span><a href="#36066780">next</a><span>|</span><label class="collapse" for="c-36066860">[-]</label><label class="expand" for="c-36066860">[1 more]</label></div><br/><div class="children"><div class="content">A (polynomial-sized) circuit in this context is a sequence of DAGs whose nodes are binary logic gates where the nth DAG infers 1 output bit from n input bits, such that some polynomial bounds the size of the graphs of the sequence. See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Circuit_complexity" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Circuit_complexity</a><p>The class of circuits in question is P&#x2F;poly which includes BPP (which includes P, the class of polynomial-time programs). So the result is quite general, since most practical programs are in P.<p>For an introduction to complexity theory, see Arora, Barak (2009) (Draft available here <a href="https:&#x2F;&#x2F;theory.cs.princeton.edu&#x2F;complexity&#x2F;book.pdf" rel="nofollow">https:&#x2F;&#x2F;theory.cs.princeton.edu&#x2F;complexity&#x2F;book.pdf</a> ); same Barak that did the presentation &quot;On the (Im)Possibility of Obfuscating Programs&quot; (2001) mentioned in the abstract.</div><br/></div></div><div id="36066780" class="c"><input type="checkbox" id="c-36066780" checked=""/><div class="controls bullet"><span class="by">x-complexity</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065515">parent</a><span>|</span><a href="#36066860">prev</a><span>|</span><a href="#36066464">next</a><span>|</span><label class="collapse" for="c-36066780">[-]</label><label class="expand" for="c-36066780">[2 more]</label></div><br/><div class="children"><div class="content">IMO: Paranoid about the implications, slightly less worried about it applying in practice.<p>As shown by the DRM schemes used in modern games, this type of obfuscation comes at the cost of performance: Unless you want to compute a sensitive function at the user&#x27;s end in an obfuscated manner, it&#x27;d be much simpler to just run that function on your end and optimize it in terms of running costs &amp; performance.<p>Such a design would also runs counter to the everything-as-a-service model that companies are trending towards, as it places more power back at the user&#x27;s end, even if the user can&#x27;t decipher the obfuscated function&#x27;s inner mechanisms. Such a design would reduce the need to phone home, and thus the need for EaaS.</div><br/><div id="36067353" class="c"><input type="checkbox" id="c-36067353" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066780">parent</a><span>|</span><a href="#36066464">next</a><span>|</span><label class="collapse" for="c-36067353">[-]</label><label class="expand" for="c-36067353">[1 more]</label></div><br/><div class="children"><div class="content">Would it be possible to use this to obfuscate other cryptographic primitives (e.g. a hash function or a simple program that checks whether the hash of some input equals a hardcoded value)?</div><br/></div></div></div></div><div id="36066464" class="c"><input type="checkbox" id="c-36066464" checked=""/><div class="controls bullet"><span class="by">dmix</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065515">parent</a><span>|</span><a href="#36066780">prev</a><span>|</span><a href="#36066034">next</a><span>|</span><label class="collapse" for="c-36066464">[-]</label><label class="expand" for="c-36066464">[4 more]</label></div><br/><div class="children"><div class="content">The next question is why didn’t the high end shops spending a ton of money and recruiting effort on crypto and state malware like NSA .. or Russia(?) figure this out already or did they</div><br/><div id="36066592" class="c"><input type="checkbox" id="c-36066592" checked=""/><div class="controls bullet"><span class="by">whatshisface</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066464">parent</a><span>|</span><a href="#36067390">next</a><span>|</span><label class="collapse" for="c-36066592">[-]</label><label class="expand" for="c-36066592">[2 more]</label></div><br/><div class="children"><div class="content">Because figuring out what a worm does doesn&#x27;t help if it has already done it, and for that matter they&#x27;re supposed to remain undetected. Furthermore people already cannot tell whether code has backdoors, or what ML classifiers do for that matter.<p>Unfortunately, the biggest industrial use case is making wi-fi routers that are absolutely impossible to install OpenWRT on, etc...</div><br/><div id="36066815" class="c"><input type="checkbox" id="c-36066815" checked=""/><div class="controls bullet"><span class="by">whitemary</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066592">parent</a><span>|</span><a href="#36067390">next</a><span>|</span><label class="collapse" for="c-36066815">[-]</label><label class="expand" for="c-36066815">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>people already cannot tell whether code has backdoors</i><p>I was feeling crazy after reading that.</div><br/></div></div></div></div><div id="36067390" class="c"><input type="checkbox" id="c-36067390" checked=""/><div class="controls bullet"><span class="by">tivert</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066464">parent</a><span>|</span><a href="#36066592">prev</a><span>|</span><a href="#36066034">next</a><span>|</span><label class="collapse" for="c-36067390">[-]</label><label class="expand" for="c-36067390">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The next question is why didn’t the high end shops spending a ton of money and recruiting effort on crypto and state malware like NSA .. or Russia(?) figure this out already or did they<p>There&#x27;s no way to know.  But the NSA (at least) has a documented history of making crypto breakthroughs and keeping them secret (e.g. public key crypto: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Public-key_cryptography#Classified_discovery" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Public-key_cryptography#Classi...</a>, differential cryptanalysis: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Differential_cryptanalysis#History" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Differential_cryptanalysis#His...</a>).</div><br/></div></div></div></div><div id="36066034" class="c"><input type="checkbox" id="c-36066034" checked=""/><div class="controls bullet"><span class="by">scarmig</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065515">parent</a><span>|</span><a href="#36066464">prev</a><span>|</span><a href="#36065467">next</a><span>|</span><label class="collapse" for="c-36066034">[-]</label><label class="expand" for="c-36066034">[4 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t finite iteration and recursion just be unrolled? And storage just considered another part of the input?</div><br/><div id="36066461" class="c"><input type="checkbox" id="c-36066461" checked=""/><div class="controls bullet"><span class="by">jahewson</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066034">parent</a><span>|</span><a href="#36066289">next</a><span>|</span><label class="collapse" for="c-36066461">[-]</label><label class="expand" for="c-36066461">[1 more]</label></div><br/><div class="children"><div class="content">This is how SMT solvers deal with bounded quantifiers.</div><br/></div></div><div id="36066289" class="c"><input type="checkbox" id="c-36066289" checked=""/><div class="controls bullet"><span class="by">grayhatter</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066034">parent</a><span>|</span><a href="#36066461">prev</a><span>|</span><a href="#36065467">next</a><span>|</span><label class="collapse" for="c-36066289">[-]</label><label class="expand" for="c-36066289">[2 more]</label></div><br/><div class="children"><div class="content">In theory? Absolutely; unrolling a loop is exactly what it sounds like. Recursion is just a fancy loop. But there&#x27;s a reason no one does that, and why no compilers emit that as code.</div><br/><div id="36067206" class="c"><input type="checkbox" id="c-36067206" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066289">parent</a><span>|</span><a href="#36065467">next</a><span>|</span><label class="collapse" for="c-36067206">[-]</label><label class="expand" for="c-36067206">[1 more]</label></div><br/><div class="children"><div class="content">Fancy in the sense of being a loop with an implicit stack. Or maybe just some registers if TCO.<p>And yet the machines we can actually build are far closer to LBAs than TMs.</div><br/></div></div></div></div></div></div></div></div><div id="36065467" class="c"><input type="checkbox" id="c-36065467" checked=""/><div class="controls bullet"><span class="by">matthewdgreen</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065260">parent</a><span>|</span><a href="#36065515">prev</a><span>|</span><a href="#36065457">next</a><span>|</span><label class="collapse" for="c-36065467">[-]</label><label class="expand" for="c-36065467">[1 more]</label></div><br/><div class="children"><div class="content">It is not efficient enough that you need to worry about exciting developments using this scheme. But it’s a step towards more reasonable mathematical assumptions than previous constructions, assumptions that may actually be true. Give it a few more years and we might be able to use this stuff.</div><br/></div></div><div id="36065457" class="c"><input type="checkbox" id="c-36065457" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065260">parent</a><span>|</span><a href="#36065467">prev</a><span>|</span><a href="#36066210">next</a><span>|</span><label class="collapse" for="c-36065457">[-]</label><label class="expand" for="c-36065457">[1 more]</label></div><br/><div class="children"><div class="content">Looks like constructive but my math knowledge is probably equivalent to a freshman’s at best.</div><br/></div></div></div></div><div id="36067623" class="c"><input type="checkbox" id="c-36067623" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36065260">prev</a><span>|</span><a href="#36065270">next</a><span>|</span><label class="collapse" for="c-36067623">[-]</label><label class="expand" for="c-36067623">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t this also be a field day for encryption maximalists?<p>I&#x27;d imagine if all code were to be perfectly obscured then to the public it wouldn&#x27;t matter, but many would demand for more open source and that&#x27;d be the only way to trust.</div><br/></div></div><div id="36065270" class="c"><input type="checkbox" id="c-36065270" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36067623">prev</a><span>|</span><a href="#36067666">next</a><span>|</span><label class="collapse" for="c-36065270">[-]</label><label class="expand" for="c-36065270">[1 more]</label></div><br/><div class="children"><div class="content">I’m sure DRM companies like Denuvo are having a field day.</div><br/></div></div><div id="36067666" class="c"><input type="checkbox" id="c-36067666" checked=""/><div class="controls bullet"><span class="by">amoss</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36065270">prev</a><span>|</span><a href="#36066805">next</a><span>|</span><label class="collapse" for="c-36067666">[-]</label><label class="expand" for="c-36067666">[2 more]</label></div><br/><div class="children"><div class="content">Ah, &quot;code is law&quot;. Good luck with that.</div><br/><div id="36067989" class="c"><input type="checkbox" id="c-36067989" checked=""/><div class="controls bullet"><span class="by">macawfish</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36067666">parent</a><span>|</span><a href="#36066805">next</a><span>|</span><label class="collapse" for="c-36067989">[-]</label><label class="expand" for="c-36067989">[1 more]</label></div><br/><div class="children"><div class="content">Just wait until the legislators catch wind of this.</div><br/></div></div></div></div><div id="36065307" class="c"><input type="checkbox" id="c-36065307" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36066805">prev</a><span>|</span><a href="#36065518">next</a><span>|</span><label class="collapse" for="c-36065307">[-]</label><label class="expand" for="c-36065307">[6 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that where we&#x27;re already at with ML classifiers?</div><br/><div id="36065495" class="c"><input type="checkbox" id="c-36065495" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065307">parent</a><span>|</span><a href="#36065518">next</a><span>|</span><label class="collapse" for="c-36065495">[-]</label><label class="expand" for="c-36065495">[5 more]</label></div><br/><div class="children"><div class="content">Well, we know they&#x27;re ML classifiers and they&#x27;re not making syscalls. So there&#x27;s obviously a limit to &quot;we don&#x27;t know what they do&quot;.</div><br/><div id="36066178" class="c"><input type="checkbox" id="c-36066178" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065495">parent</a><span>|</span><a href="#36065518">next</a><span>|</span><label class="collapse" for="c-36066178">[-]</label><label class="expand" for="c-36066178">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;d still know what syscalls a cryptographically obfuscated userland program was making.</div><br/><div id="36066577" class="c"><input type="checkbox" id="c-36066577" checked=""/><div class="controls bullet"><span class="by">sbierwagen</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066178">parent</a><span>|</span><a href="#36066881">next</a><span>|</span><label class="collapse" for="c-36066577">[-]</label><label class="expand" for="c-36066577">[2 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s a total black box, wouldn&#x27;t the NOBUS thing to do would be to have some large key that it&#x27;s watching input for that flips it into a malicious mode?<p>If BB(6) took years to execute, how long would you have to spend feeding random input to a suspected-hostile 10000 symbol Turing machine (whose source code and state you can&#x27;t examine) in a sandbox before you decided it was safe?</div><br/><div id="36067707" class="c"><input type="checkbox" id="c-36067707" checked=""/><div class="controls bullet"><span class="by">rini17</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066577">parent</a><span>|</span><a href="#36066881">next</a><span>|</span><label class="collapse" for="c-36067707">[-]</label><label class="expand" for="c-36067707">[1 more]</label></div><br/><div class="children"><div class="content">Easy, have all executable segments read-only with none (or fixed) syscall instructions.</div><br/></div></div></div></div><div id="36066881" class="c"><input type="checkbox" id="c-36066881" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066178">parent</a><span>|</span><a href="#36066577">prev</a><span>|</span><a href="#36065518">next</a><span>|</span><label class="collapse" for="c-36066881">[-]</label><label class="expand" for="c-36066881">[1 more]</label></div><br/><div class="children"><div class="content">Think it&#x27;d be a bit dangerous to let them make any though, unless you were single stepping.</div><br/></div></div></div></div></div></div></div></div><div id="36065518" class="c"><input type="checkbox" id="c-36065518" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36065307">prev</a><span>|</span><a href="#36065374">next</a><span>|</span><label class="collapse" for="c-36065518">[-]</label><label class="expand" for="c-36065518">[9 more]</label></div><br/><div class="children"><div class="content">Obfuscation is itself a malware signature.</div><br/><div id="36066570" class="c"><input type="checkbox" id="c-36066570" checked=""/><div class="controls bullet"><span class="by">Vervious</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065518">parent</a><span>|</span><a href="#36065928">next</a><span>|</span><label class="collapse" for="c-36066570">[-]</label><label class="expand" for="c-36066570">[5 more]</label></div><br/><div class="children"><div class="content">I mean, the same argument has been applied to other cryptographic tools. Why encrypt your messages, unless you&#x27;re sending something sketchy? Why obfuscate programs, unless you&#x27;re hiding something?<p>Yet I think the utility of encryption is well-demonstrated, and not just theoretical. It can be used by good people to defend against adversarial intent. And it may well be that obfuscation (in its most direct application) has the same effect. (e.g. companies sharing proprietary algorithms for you to run at home, without revealing the secret sauce; or me delegating computation to AWS without revealing secrets)<p>Note that this is not why indistinguishability obfuscation (iO) is a crown jewel, here. Practically, iO is nowhere close to obfuscating anything larger than a tiny circuit. But it can still be useful to do things like obfuscate secret keys when designing cryptographic protocols. Theoretically, iO allows us to derive essentially every cryptographic primitive, which is why this paper is interesting, and why iO is called a crown jewel. And now, we can build iO for the first time from well-studied hardness assumptions.</div><br/><div id="36067564" class="c"><input type="checkbox" id="c-36067564" checked=""/><div class="controls bullet"><span class="by">moring</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066570">parent</a><span>|</span><a href="#36067319">next</a><span>|</span><label class="collapse" for="c-36067564">[-]</label><label class="expand" for="c-36067564">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I mean, the same argument has been applied to other cryptographic tools. Why encrypt your messages, unless you&#x27;re sending something sketchy? Why obfuscate programs, unless you&#x27;re hiding something?<p>There is a huge difference: Encryption is used to hide something from a third party, while obfuscation is used to hide something from the intended recipient.<p>Or, if you&#x27;d like to argue that the intended recipient is the computer, not the user: To turn that computer into a deputy of the sender, while still formally belonging to the recipient.</div><br/><div id="36067642" class="c"><input type="checkbox" id="c-36067642" checked=""/><div class="controls bullet"><span class="by">consp</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36067564">parent</a><span>|</span><a href="#36067319">next</a><span>|</span><label class="collapse" for="c-36067642">[-]</label><label class="expand" for="c-36067642">[1 more]</label></div><br/><div class="children"><div class="content">&gt; while obfuscation is used to hide something from the intended recipient.<p>No. Most obfuscation is done to increase the time needed to reverse the source of publicly available programs. Not the user (99% of the recipients) but the adversary is the intended target. The users are just cought in the crossfire.<p>Unless you consider every user of apps as someone who has both the skill and the need to reverse engineer your app.</div><br/></div></div></div></div><div id="36067319" class="c"><input type="checkbox" id="c-36067319" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066570">parent</a><span>|</span><a href="#36067564">prev</a><span>|</span><a href="#36065928">next</a><span>|</span><label class="collapse" for="c-36067319">[-]</label><label class="expand" for="c-36067319">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  I mean, the same argument has been applied to other cryptographic tools. Why encrypt your messages, unless you&#x27;re sending something sketchy? Why obfuscate programs, unless you&#x27;re hiding something?<p>It&#x27;s easy to argue that everyone has legitimate interest in hiding some things in data, but what would be a legitimate case for hiding things in code?</div><br/><div id="36067669" class="c"><input type="checkbox" id="c-36067669" checked=""/><div class="controls bullet"><span class="by">Brotkrumen</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36067319">parent</a><span>|</span><a href="#36065928">next</a><span>|</span><label class="collapse" for="c-36067669">[-]</label><label class="expand" for="c-36067669">[1 more]</label></div><br/><div class="children"><div class="content">&quot;This is a trade secret. We have not patented it, because it&#x27;s so clever and valuable that it needs to be protected longer than a patent lasts&quot;</div><br/></div></div></div></div></div></div><div id="36065928" class="c"><input type="checkbox" id="c-36065928" checked=""/><div class="controls bullet"><span class="by">Hnaomyiph</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065518">parent</a><span>|</span><a href="#36066570">prev</a><span>|</span><a href="#36065374">next</a><span>|</span><label class="collapse" for="c-36065928">[-]</label><label class="expand" for="c-36065928">[3 more]</label></div><br/><div class="children"><div class="content">Until it’s standard practice by all companies to protect up under the guise of consumer protection with all closed sourced software.</div><br/><div id="36066242" class="c"><input type="checkbox" id="c-36066242" checked=""/><div class="controls bullet"><span class="by">hulahoof</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065928">parent</a><span>|</span><a href="#36065374">next</a><span>|</span><label class="collapse" for="c-36066242">[-]</label><label class="expand" for="c-36066242">[2 more]</label></div><br/><div class="children"><div class="content">like that time sony gave everyone a rootkit: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sony_BMG_copy_protection_rootkit_scandal" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sony_BMG_copy_protection_rootk...</a></div><br/><div id="36067899" class="c"><input type="checkbox" id="c-36067899" checked=""/><div class="controls bullet"><span class="by">RockRobotRock</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36066242">parent</a><span>|</span><a href="#36065374">next</a><span>|</span><label class="collapse" for="c-36067899">[-]</label><label class="expand" for="c-36067899">[1 more]</label></div><br/><div class="children"><div class="content">similar to starforce for those that don&#x27;t know: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=p-wyIalhdPU">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=p-wyIalhdPU</a></div><br/></div></div></div></div></div></div></div></div><div id="36065374" class="c"><input type="checkbox" id="c-36065374" checked=""/><div class="controls bullet"><span class="by">NoMoreNicksLeft</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36065518">prev</a><span>|</span><a href="#36067042">next</a><span>|</span><label class="collapse" for="c-36065374">[-]</label><label class="expand" for="c-36065374">[3 more]</label></div><br/><div class="children"><div class="content">Even if the vendor is willing to provide source, you can&#x27;t be sure that the binary matches. Nice.<p>I think Saberhagen&#x27;s Berserkers actually had this feature.</div><br/><div id="36066545" class="c"><input type="checkbox" id="c-36066545" checked=""/><div class="controls bullet"><span class="by">schoen</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065374">parent</a><span>|</span><a href="#36065526">next</a><span>|</span><label class="collapse" for="c-36066545">[-]</label><label class="expand" for="c-36066545">[1 more]</label></div><br/><div class="children"><div class="content">You can be sure that it matches if the vendor (1) doesn&#x27;t use an obfuscated binary, or (2) provides exact details of how the obfuscated binary was constructed (presumably including some kind of seed for the obfuscator).</div><br/></div></div><div id="36065526" class="c"><input type="checkbox" id="c-36065526" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36065374">parent</a><span>|</span><a href="#36066545">prev</a><span>|</span><a href="#36067042">next</a><span>|</span><label class="collapse" for="c-36065526">[-]</label><label class="expand" for="c-36065526">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think Saberhagen&#x27;s Berserkers actually had this feature.<p>Yes. Code decoded other code, etc. So if the code wasn&#x27;t running normally, it couldn&#x27;t be analyzed.
It was handwaving back then, but it may become real.</div><br/></div></div></div></div><div id="36067042" class="c"><input type="checkbox" id="c-36067042" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36065374">prev</a><span>|</span><a href="#36065801">next</a><span>|</span><label class="collapse" for="c-36067042">[-]</label><label class="expand" for="c-36067042">[3 more]</label></div><br/><div class="children"><div class="content">Could you steal source code, obfuscate it, and sell it as your own?</div><br/><div id="36067190" class="c"><input type="checkbox" id="c-36067190" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36067042">parent</a><span>|</span><a href="#36065801">next</a><span>|</span><label class="collapse" for="c-36067190">[-]</label><label class="expand" for="c-36067190">[2 more]</label></div><br/><div class="children"><div class="content">Does it run at the same speed as the original?</div><br/><div id="36067291" class="c"><input type="checkbox" id="c-36067291" checked=""/><div class="controls bullet"><span class="by">omgwtfbyobbq</span><span>|</span><a href="#36065179">root</a><span>|</span><a href="#36067190">parent</a><span>|</span><a href="#36065801">next</a><span>|</span><label class="collapse" for="c-36067291">[-]</label><label class="expand" for="c-36067291">[1 more]</label></div><br/><div class="children"><div class="content">Across the same universe of discourse.</div><br/></div></div></div></div></div></div><div id="36065801" class="c"><input type="checkbox" id="c-36065801" checked=""/><div class="controls bullet"><span class="by">elefanten</span><span>|</span><a href="#36065179">parent</a><span>|</span><a href="#36067042">prev</a><span>|</span><a href="#36065445">next</a><span>|</span><label class="collapse" for="c-36065801">[-]</label><label class="expand" for="c-36065801">[1 more]</label></div><br/><div class="children"><div class="content">Seems some of those cases (backdoors and classifiers) could be prevented by regulation and&#x2F;or social convention (eg- don’t use programs&#x2F;services obfuscated in this way).<p>The malware seems trickier. Maybe systems will need to require proof of unobfuscated source to run code?</div><br/></div></div></div></div><div id="36065445" class="c"><input type="checkbox" id="c-36065445" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#36065179">prev</a><span>|</span><a href="#36066389">next</a><span>|</span><label class="collapse" for="c-36065445">[-]</label><label class="expand" for="c-36065445">[3 more]</label></div><br/><div class="children"><div class="content">If I’m reading Wikipedia [1] correctly, a program that does an AND of 32 booleans when obfuscated is 32 GiB. No indication of runtime overhead but something tells me it’s a large constant overhead (if I skimmed the paper correctly, the complexity class must be the same).<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Indistinguishability_obfuscation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Indistinguishability_obfuscati...</a></div><br/><div id="36065906" class="c"><input type="checkbox" id="c-36065906" checked=""/><div class="controls bullet"><span class="by">sn_master</span><span>|</span><a href="#36065445">parent</a><span>|</span><a href="#36066389">next</a><span>|</span><label class="collapse" for="c-36065906">[-]</label><label class="expand" for="c-36065906">[2 more]</label></div><br/><div class="children"><div class="content">But can it be compressed with something like UPX?</div><br/><div id="36066925" class="c"><input type="checkbox" id="c-36066925" checked=""/><div class="controls bullet"><span class="by">arsome</span><span>|</span><a href="#36065445">root</a><span>|</span><a href="#36065906">parent</a><span>|</span><a href="#36066389">next</a><span>|</span><label class="collapse" for="c-36066925">[-]</label><label class="expand" for="c-36066925">[1 more]</label></div><br/><div class="children"><div class="content">And can you tell where an operation begins and ends, for example, determine inputs and outputs?</div><br/></div></div></div></div></div></div><div id="36066389" class="c"><input type="checkbox" id="c-36066389" checked=""/><div class="controls bullet"><span class="by">Sophistifunk</span><span>|</span><a href="#36065445">prev</a><span>|</span><a href="#36066250">next</a><span>|</span><label class="collapse" for="c-36066389">[-]</label><label class="expand" for="c-36066389">[3 more]</label></div><br/><div class="children"><div class="content">If mankind can&#x27;t stomach 10% overhead to check array bounds and collect unused memory, what makes anybody think they can sell 1,000,000% overhead to make your DRM driver (and viruses) harder to reverse?</div><br/><div id="36067358" class="c"><input type="checkbox" id="c-36067358" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#36066389">parent</a><span>|</span><a href="#36066485">next</a><span>|</span><label class="collapse" for="c-36067358">[-]</label><label class="expand" for="c-36067358">[1 more]</label></div><br/><div class="children"><div class="content">We already accept something on the order of 1000% overhead for video DRM (software vs hardware decoding)</div><br/></div></div><div id="36066485" class="c"><input type="checkbox" id="c-36066485" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#36066389">parent</a><span>|</span><a href="#36067358">prev</a><span>|</span><a href="#36066250">next</a><span>|</span><label class="collapse" for="c-36066485">[-]</label><label class="expand" for="c-36066485">[1 more]</label></div><br/><div class="children"><div class="content">Same reason. Money.</div><br/></div></div></div></div><div id="36066250" class="c"><input type="checkbox" id="c-36066250" checked=""/><div class="controls bullet"><span class="by">kevinwang</span><span>|</span><a href="#36066389">prev</a><span>|</span><a href="#36067501">next</a><span>|</span><label class="collapse" for="c-36066250">[-]</label><label class="expand" for="c-36066250">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the quanta article referenced by the title: <a href="https:&#x2F;&#x2F;www.quantamagazine.org&#x2F;computer-scientists-achieve-crown-jewel-of-cryptography-20201110&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.quantamagazine.org&#x2F;computer-scientists-achieve-c...</a></div><br/><div id="36067851" class="c"><input type="checkbox" id="c-36067851" checked=""/><div class="controls bullet"><span class="by">bertman</span><span>|</span><a href="#36066250">parent</a><span>|</span><a href="#36067501">next</a><span>|</span><label class="collapse" for="c-36067851">[-]</label><label class="expand" for="c-36067851">[1 more]</label></div><br/><div class="children"><div class="content">And its discussion from 3 years ago:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25046738" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25046738</a></div><br/></div></div></div></div><div id="36067501" class="c"><input type="checkbox" id="c-36067501" checked=""/><div class="controls bullet"><span class="by">7to2</span><span>|</span><a href="#36066250">prev</a><span>|</span><a href="#36066607">next</a><span>|</span><label class="collapse" for="c-36067501">[-]</label><label class="expand" for="c-36067501">[2 more]</label></div><br/><div class="children"><div class="content">Does this mean we will be able to embed private keys and API keys in deliverables? (i.e. to cryptographicaly sign artifacts, APIs tokens, and other niceties).<p>Sucks that DRM and user rights violations is about to get much much worse.</div><br/><div id="36068334" class="c"><input type="checkbox" id="c-36068334" checked=""/><div class="controls bullet"><span class="by">throwawayadvsec</span><span>|</span><a href="#36067501">parent</a><span>|</span><a href="#36066607">next</a><span>|</span><label class="collapse" for="c-36068334">[-]</label><label class="expand" for="c-36068334">[1 more]</label></div><br/><div class="children"><div class="content">your API tokens could still probably get sniffed in the requests?</div><br/></div></div></div></div><div id="36066607" class="c"><input type="checkbox" id="c-36066607" checked=""/><div class="controls bullet"><span class="by">yalogin</span><span>|</span><a href="#36067501">prev</a><span>|</span><a href="#36068188">next</a><span>|</span><label class="collapse" for="c-36066607">[-]</label><label class="expand" for="c-36066607">[6 more]</label></div><br/><div class="children"><div class="content">DRM implementations already use code obfuscation heavily. Can someone with knowledge of the math clarify why this is a big deal? Why would it matter that there is mathematical proof that someone cannot figure out what the code is doing? How does it apply to crypto?</div><br/><div id="36067832" class="c"><input type="checkbox" id="c-36067832" checked=""/><div class="controls bullet"><span class="by">kybernetikos</span><span>|</span><a href="#36066607">parent</a><span>|</span><a href="#36066748">next</a><span>|</span><label class="collapse" for="c-36067832">[-]</label><label class="expand" for="c-36067832">[1 more]</label></div><br/><div class="children"><div class="content">Imagine you wrote a decoder program with the key embedded in it. From looking at the program you can&#x27;t work out what the key is, but you can use it to decode a secret message.  You can have a secret encoder program too. Effectively blackbox obfuscation among other things allows you to turn symmetric encryption into asymmetric encryption.<p>Another possible use is in cloud computing. You could prepare a program with private information in it and still safely submit it to a third party to execute. This would also be very useful with smartcontracts. Since the smart contract code is public it can&#x27;t contain any secrets unless it&#x27;s safely obfuscated.<p>As I understand it we are still quite a way off from any of these techniques being feasible, since the overhead at the moment is huge.</div><br/></div></div><div id="36066748" class="c"><input type="checkbox" id="c-36066748" checked=""/><div class="controls bullet"><span class="by">Vervious</span><span>|</span><a href="#36066607">parent</a><span>|</span><a href="#36067832">prev</a><span>|</span><a href="#36068188">next</a><span>|</span><label class="collapse" for="c-36066748">[-]</label><label class="expand" for="c-36066748">[4 more]</label></div><br/><div class="children"><div class="content">The code obfuscation that DRM implementations use is not provably secure. I don&#x27;t think anyone would (or should) hide a bitcoin secret key inside of an obfuscated program. There&#x27;s no formal guarantee of security.<p>This work, on the other hand, shows a provably secure construction for obfuscation (assuming that some assumptions about the hardness of various well-studied mathematical problems are true). In other words, extracting a bitcoin secret key from an obfuscated algorithm is as hard as <i>insert math problem here</i>. (This is how all cryptography works; e.g. breaking RSA encryption is as hard as factoring large products of primes.) This paper is special because, for the first time, the hard math problem they use (to build the obfuscation) is &quot;reasonable&quot;: they&#x27;ve been studied for decades, and no one knows how to break them. (Indeed, a lot of cryptography is built on top of the same assumptions&#x2F;problems.)<p>Thus, we would be surprised if someone extracted our bitcoin secret key from our obfuscated program, because it means they solved some &quot;thought-to-be-unsolvable&quot; mathematical problem. This is a much nicer guarantee than the alternative, e.g. with current obfuscation, where we say &quot;oh, it looks pretty random, let&#x27;s stick my key in&quot; and then trusting that no one will break it. (That&#x27;s a lot of trust, when you might have a 100,000 Bitcoin at stake.)<p>Of course, none of this is really feasible; at best, we can securely obfuscate tiny circuits (in the present time). So the main utility is probably to hide keys and the such, not to obfuscate entire programs. This might enable better secure MPC schemes, NIZKs, etc. So I guess, per your question, it&#x27;s also targeted towards a different use case.<p>Now, as to why theoretical cryptographers care about obfuscation in general: it&#x27;s not so much about the direct application of obfuscating programs. (It&#x27;s not obvious why obfuscation is more interesting than encryption, etc, from an applied point of view.) Instead, from a theoretical point of view, if we can build indistinguishability obfuscation, we can directly build public key encryption, non-interactive zero knowledge proofs, Multiparty computation, etc. etc. (assuming one-way functions). So really, this is a primitive that somehow connects all of the other primitives, which is why theoreticians think it is a big deal.</div><br/><div id="36067367" class="c"><input type="checkbox" id="c-36067367" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#36066607">root</a><span>|</span><a href="#36066748">parent</a><span>|</span><a href="#36067455">next</a><span>|</span><label class="collapse" for="c-36067367">[-]</label><label class="expand" for="c-36067367">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t think anyone would (or should) hide a bitcoin secret key inside of an obfuscated program.<p>I can&#x27;t remember where I read this, or if it was just a hypothetical, but I think I heard of people doing this deliberately as a sort of canary. If the wallet gets drained, then you know someone cracked your obfuscation.</div><br/></div></div><div id="36067455" class="c"><input type="checkbox" id="c-36067455" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#36066607">root</a><span>|</span><a href="#36066748">parent</a><span>|</span><a href="#36067367">prev</a><span>|</span><a href="#36068188">next</a><span>|</span><label class="collapse" for="c-36067455">[-]</label><label class="expand" for="c-36067455">[2 more]</label></div><br/><div class="children"><div class="content">How does obfuscating a key differ from encrypting it?</div><br/><div id="36067788" class="c"><input type="checkbox" id="c-36067788" checked=""/><div class="controls bullet"><span class="by">Vervious</span><span>|</span><a href="#36066607">root</a><span>|</span><a href="#36067455">parent</a><span>|</span><a href="#36068188">next</a><span>|</span><label class="collapse" for="c-36067788">[-]</label><label class="expand" for="c-36067788">[1 more]</label></div><br/><div class="children"><div class="content">For example, we could write a program that hard-codes a secret key, and then signs bitcoin transactions with that secret key, but only if the transaction has value less than 0.5 bitcoin. Then anyone who has the program can sign things of small value on our behalf; if the program is indistinguishably-obfuscated, they won&#x27;t be able to get any additional information about the key itself, or use it in any other way.<p>I guess just encrypting the key won&#x27;t let you use it to sign things.</div><br/></div></div></div></div></div></div></div></div><div id="36068188" class="c"><input type="checkbox" id="c-36068188" checked=""/><div class="controls bullet"><span class="by">gmerc</span><span>|</span><a href="#36066607">prev</a><span>|</span><a href="#36066596">next</a><span>|</span><label class="collapse" for="c-36068188">[-]</label><label class="expand" for="c-36068188">[1 more]</label></div><br/><div class="children"><div class="content">But does it withstand a powerful LLM attack? Because cursory tests on existing commercial code obfuscation solutions so far look like it’s clubby baby seals for them LLM</div><br/></div></div><div id="36066596" class="c"><input type="checkbox" id="c-36066596" checked=""/><div class="controls bullet"><span class="by">marktangotango</span><span>|</span><a href="#36068188">prev</a><span>|</span><a href="#36067088">next</a><span>|</span><label class="collapse" for="c-36066596">[-]</label><label class="expand" for="c-36066596">[1 more]</label></div><br/><div class="children"><div class="content">For those, like me, wondering what this is about;<p>&gt; Program obfuscation would enable a host of useful applications: For instance, you could use an obfuscated program to delegate particular tasks within your bank or email accounts to other individuals, without worrying that someone could use the program in a way it wasn’t intended for or read off your account passwords (unless the program was designed to output them).<p>I relate this to cracking; run a program and watch the memory, see where the password is checked and edit the binary at that location to bypass. So this level obfuscation would make that impossible? Seems like magic honestly.</div><br/></div></div><div id="36067088" class="c"><input type="checkbox" id="c-36067088" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#36066596">prev</a><span>|</span><a href="#36068242">next</a><span>|</span><label class="collapse" for="c-36067088">[-]</label><label class="expand" for="c-36067088">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how this compares to homomorphic encryption? If I understand correctly, I could give someone a computation with an embedded key that operates over encrypted data, and they wouldn&#x27;t be able to decrypt the data other than for the computation I gave them, right?</div><br/><div id="36067135" class="c"><input type="checkbox" id="c-36067135" checked=""/><div class="controls bullet"><span class="by">noam_k</span><span>|</span><a href="#36067088">parent</a><span>|</span><a href="#36068242">next</a><span>|</span><label class="collapse" for="c-36067135">[-]</label><label class="expand" for="c-36067135">[1 more]</label></div><br/><div class="children"><div class="content">I think it compares more to a One Time Program or Functional Encryption.<p>Homomorphic Encryption won&#x27;t prevent you from decrypting other outputs (if you have a decryption key), and with Functional Encryption it&#x27;s assumed both parties know the function being evaluated, so OTP is really the closest.</div><br/></div></div></div></div><div id="36068242" class="c"><input type="checkbox" id="c-36068242" checked=""/><div class="controls bullet"><span class="by">derrida</span><span>|</span><a href="#36067088">prev</a><span>|</span><a href="#36066735">next</a><span>|</span><label class="collapse" for="c-36068242">[-]</label><label class="expand" for="c-36068242">[1 more]</label></div><br/><div class="children"><div class="content">1 year old</div><br/></div></div><div id="36065493" class="c"><input type="checkbox" id="c-36065493" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#36066227">prev</a><span>|</span><label class="collapse" for="c-36065493">[-]</label><label class="expand" for="c-36065493">[4 more]</label></div><br/><div class="children"><div class="content">Trash title.<p>&gt; established the feasibility of mathematically rigorous software obfuscation from well-studied hardness conjectures</div><br/><div id="36066084" class="c"><input type="checkbox" id="c-36066084" checked=""/><div class="controls bullet"><span class="by">y7</span><span>|</span><a href="#36065493">parent</a><span>|</span><a href="#36066194">next</a><span>|</span><label class="collapse" for="c-36066084">[-]</label><label class="expand" for="c-36066084">[2 more]</label></div><br/><div class="children"><div class="content">This is not about software obfuscation, this is about cryptographic indistinguishability obfuscation (iO). It&#x27;s targeting a different problem -- software obfuscation is more about hiding program behavior, whereas iO is more useful for white box cryptography, like hiding an AES key.<p>Maybe you could obfuscate software eventually, but we don&#x27;t have practical efficiency  even for tiny circuits. It&#x27;s a bit like saying how fully homomorphic encryption allows you to securely run &quot;software&quot; on someone else&#x27;s computer: theoretically maybe yes, but in practice it&#x27;s used <i>within software</i> to run very specific computations.</div><br/></div></div><div id="36066194" class="c"><input type="checkbox" id="c-36066194" checked=""/><div class="controls bullet"><span class="by">Vervious</span><span>|</span><a href="#36065493">parent</a><span>|</span><a href="#36066084">prev</a><span>|</span><label class="collapse" for="c-36066194">[-]</label><label class="expand" for="c-36066194">[1 more]</label></div><br/><div class="children"><div class="content">Why? It&#x27;s not a trash title. Explain yourself, and give us some substance instead of being inflammatory.<p>Indistinguishability obfuscation (plus one-way functions) implies basically every cryptographic primitive there is, including public key encryption, NIZKs, and MPC. It gets close to giving us FHE (open question, I think). In some sense it is a &quot;unifying primitive&quot;. Absolutely a holy grail to cryptographers, even if it isn&#x27;t for you.</div><br/></div></div></div></div></div></div></div></div></div></body></html>