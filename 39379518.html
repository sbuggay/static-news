<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708160453223" as="style"/><link rel="stylesheet" href="styles.css?v=1708160453223"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://web.eecs.umich.edu/~taustin/papers/IJPP-mren.pdf">Memory Renaming: Fast and Accurate Processing of Memory Communication (1999) [pdf]</a>Â <span class="domain">(<a href="https://web.eecs.umich.edu">web.eecs.umich.edu</a>)</span></div><div class="subtext"><span>mfiguiere</span> | <span>5 comments</span></div><br/><div><div id="39404246" class="c"><input type="checkbox" id="c-39404246" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#39403591">next</a><span>|</span><label class="collapse" for="c-39404246">[-]</label><label class="expand" for="c-39404246">[1 more]</label></div><br/><div class="children"><div class="content">I tried to characterize this on Zen 2 a little while ago[^1], although I don&#x27;t think that implementation has anything to do with  unused physical registers: it ultimately relies on the idea that the store queue (48 entries on Zen 2) is an extra set of storage locations. During renaming, you try to look up a store queue entry with some of the operands (ie. a register and some of the displacement bits).<p>It seems like only the youngest six stores are ever eligible for renaming on Zen 2. I&#x27;d love to know how this has changed on Zen 3&#x2F;4, but I don&#x27;t have any newer machines to play with.<p>[^1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;eigenform&#x2F;perfect&#x2F;blob&#x2F;main&#x2F;src&#x2F;bin&#x2F;stlf.rs">https:&#x2F;&#x2F;github.com&#x2F;eigenform&#x2F;perfect&#x2F;blob&#x2F;main&#x2F;src&#x2F;bin&#x2F;stlf....</a></div><br/></div></div><div id="39403591" class="c"><input type="checkbox" id="c-39403591" checked=""/><div class="controls bullet"><span class="by">KMag</span><span>|</span><a href="#39404246">prev</a><span>|</span><label class="collapse" for="c-39403591">[-]</label><label class="expand" for="c-39403591">[3 more]</label></div><br/><div class="children"><div class="content">The basic idea here is to use unused physical registers in a register-renaming processor as a level-0 cache.  I imagine this is much easier to get good performance out of this technique on architectures with weaker memory models than x86.</div><br/><div id="39403955" class="c"><input type="checkbox" id="c-39403955" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#39403591">parent</a><span>|</span><a href="#39404270">next</a><span>|</span><label class="collapse" for="c-39403955">[-]</label><label class="expand" for="c-39403955">[1 more]</label></div><br/><div class="children"><div class="content">I believe AMD implements this since Zen2.</div><br/></div></div><div id="39404270" class="c"><input type="checkbox" id="c-39404270" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39403591">parent</a><span>|</span><a href="#39403955">prev</a><span>|</span><label class="collapse" for="c-39404270">[-]</label><label class="expand" for="c-39404270">[1 more]</label></div><br/><div class="children"><div class="content">isn&#x27;t it a little more? I admit to just skimming and having a pretty incomplete grasp. but rather than implementing a spacio-temporal cache (lines over usage), this is explicitly trying to match producers and consumers of individual words.<p>so yes, like a cache, but it approached naming of values in a slightly different way.<p>two things bother me here. one is that we have the space for more registers, but we can&#x27;t afford to pay for them in the instruction encoding. the other of course is the sad truth that hardware people need to innovate under the compiler instead of in cooperation with it.<p>on the first point, it seems like there may be other approaches to solving the naming issue. register windows was one. but maybe we can wire up producers and consumers more explicitly in the ISA?</div><br/></div></div></div></div></div></div></div></div></div></body></html>