<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693645255709" as="style"/><link rel="stylesheet" href="styles.css?v=1693645255709"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tembo.io/blog/optimizing-postgres-auto-vacuum/">Optimizing Postgres&#x27;s autovacuum for high-churn tables</a>Â <span class="domain">(<a href="https://tembo.io">tembo.io</a>)</span></div><div class="subtext"><span>chuckhend</span> | <span>10 comments</span></div><br/><div><div id="37356172" class="c"><input type="checkbox" id="c-37356172" checked=""/><div class="controls bullet"><span class="by">abalashov</span><span>|</span><a href="#37358975">next</a><span>|</span><label class="collapse" for="c-37356172">[-]</label><label class="expand" for="c-37356172">[2 more]</label></div><br/><div class="children"><div class="content">Very helpful article! It jives with the evolution of my own understanding of autovacuum tuning over a decade and a half of writing high-performance Postgres-backed VoIP routing systems.<p>I would add to this that if you truly have a high-churn table, perhaps a traditional RDBM is not the best choice. Ask me how I learned that lesson the hard way. There are many things that, in hindsight, really should have gone into ELK or Splunk or Redis or something more suited to ephemeral or short-lived data sets that also turn over constantly.<p>But, sometimes there is no choice, or the churn is high but not quite high enough to rule out the use of an RDBM altogether. For those scenarios, the tips in this article really shine.</div><br/><div id="37356255" class="c"><input type="checkbox" id="c-37356255" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#37356172">parent</a><span>|</span><a href="#37358975">next</a><span>|</span><label class="collapse" for="c-37356255">[-]</label><label class="expand" for="c-37356255">[1 more]</label></div><br/><div class="children"><div class="content">How&#x27;d you learn that lesson the hard way?</div><br/></div></div></div></div><div id="37358975" class="c"><input type="checkbox" id="c-37358975" checked=""/><div class="controls bullet"><span class="by">cett</span><span>|</span><a href="#37356172">prev</a><span>|</span><a href="#37357741">next</a><span>|</span><label class="collapse" for="c-37358975">[-]</label><label class="expand" for="c-37358975">[1 more]</label></div><br/><div class="children"><div class="content">I found that partitioning the table to allow parallel auto vacuuming was necessary to scale.</div><br/></div></div><div id="37357741" class="c"><input type="checkbox" id="c-37357741" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#37358975">prev</a><span>|</span><label class="collapse" for="c-37357741">[-]</label><label class="expand" for="c-37357741">[6 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t had much success with finding an answer to this: what flags should be set to allow postgres to run as fast as possible without caring about data loss <i>at all?</i> This is for integration tests where the database is thrown away at the end of the run anyway.<p>I&#x27;ll definitely be looking at further tweaking vacuuming based on this article.</div><br/><div id="37359476" class="c"><input type="checkbox" id="c-37359476" checked=""/><div class="controls bullet"><span class="by">cxcorp</span><span>|</span><a href="#37357741">parent</a><span>|</span><a href="#37359379">next</a><span>|</span><label class="collapse" for="c-37359476">[-]</label><label class="expand" for="c-37359476">[1 more]</label></div><br/><div class="children"><div class="content">For the postgres config, set fsync=off and full_page_writes=false, and increase min_wal_size, max_wal_size and checkpoint interval with the hope that your tests pass before having to flush the WAL. Maybe slap in some tunings from PGTune.<p>If you&#x27;re using docker&#x2F;podman or docker-compose and your db size is small, a major speedup on linux is to just mount the entire data dir into memory with --tmpfs &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data (or tmpfs: - &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data in docker-compose)<p>Additionally, if you constantly reset your db in the tests, consider making a template db at the start and later just doing CREATE DATABASE ... TEMPLATE foo; to copy the pages from that template instead of running migrations that produce WAL log. In fact, consider making a db for every test suite from that template at the start - then you can run each suite in parallel (if your app&#x27;s only state is the db and a single backend).</div><br/></div></div><div id="37359379" class="c"><input type="checkbox" id="c-37359379" checked=""/><div class="controls bullet"><span class="by">nicolaslem</span><span>|</span><a href="#37357741">parent</a><span>|</span><a href="#37359476">prev</a><span>|</span><a href="#37358308">next</a><span>|</span><label class="collapse" for="c-37359379">[-]</label><label class="expand" for="c-37359379">[1 more]</label></div><br/><div class="children"><div class="content">I would be interested if anyone had similar tweaks for MySQL. I used to mount the directory where MySQL stores data into memory, this used to be very effective until upgrading to MySQL 8. Now my test suite takes three times as long to run and I never really figured out why.</div><br/></div></div><div id="37358308" class="c"><input type="checkbox" id="c-37358308" checked=""/><div class="controls bullet"><span class="by">chuckhend</span><span>|</span><a href="#37357741">parent</a><span>|</span><a href="#37359379">prev</a><span>|</span><a href="#37358135">next</a><span>|</span><label class="collapse" for="c-37358308">[-]</label><label class="expand" for="c-37358308">[1 more]</label></div><br/><div class="children"><div class="content">Check out unlogged tables!<p><a href="https:&#x2F;&#x2F;www.crunchydata.com&#x2F;blog&#x2F;postgresl-unlogged-tables" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.crunchydata.com&#x2F;blog&#x2F;postgresl-unlogged-tables</a></div><br/></div></div><div id="37358135" class="c"><input type="checkbox" id="c-37358135" checked=""/><div class="controls bullet"><span class="by">brianwawok</span><span>|</span><a href="#37357741">parent</a><span>|</span><a href="#37358308">prev</a><span>|</span><a href="#37358990">next</a><span>|</span><label class="collapse" for="c-37358135">[-]</label><label class="expand" for="c-37358135">[1 more]</label></div><br/><div class="children"><div class="content">You get rid of fsync and a few smiliar flags. Made my tests about 50% faster<p><a href="https:&#x2F;&#x2F;postgresqlco.nf&#x2F;doc&#x2F;en&#x2F;param&#x2F;fsync&#x2F;#:~:text=Setting%20fsync%3Doff%20is%20the,a%20performance%20concern%2C%20see%20synchronous_commit" rel="nofollow noreferrer">https:&#x2F;&#x2F;postgresqlco.nf&#x2F;doc&#x2F;en&#x2F;param&#x2F;fsync&#x2F;#:~:text=Setting%...</a>.</div><br/></div></div></div></div></div></div></div></div></div></body></html>