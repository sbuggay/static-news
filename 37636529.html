<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1695632463156" as="style"/><link rel="stylesheet" href="styles.css?v=1695632463156"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://underjord.io/unpacking-elixir-resilience.html">Unpacking Elixir: Resilience</a> <span class="domain">(<a href="https://underjord.io">underjord.io</a>)</span></div><div class="subtext"><span>lawik</span> | <span>41 comments</span></div><br/><div><div id="37639503" class="c"><input type="checkbox" id="c-37639503" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#37636994">next</a><span>|</span><label class="collapse" for="c-37639503">[-]</label><label class="expand" for="c-37639503">[1 more]</label></div><br/><div class="children"><div class="content">A very nice description of Erlang&#x2F;Elixir resilience.<p>&gt; Fundamentally, if there is nothing useful your code can do on a failure, no mitigation, no meaningful fallback, then you might as well have it blow up and rely on the underlying tree to make whatever is most useful out of it.<p>I would add this is possible only because process heaps are isolated. Other systems with traditional threads&#x2F;co-routines&#x2F;green threads can mimic supervision trees, but unless they have isolated heaps and can safely crash at any time never affecting any other processes, it would be hard to achieve the same safety properties.<p>&gt;  Scheduling and preempting was intended to produce consistently low latencies but it also protects you from heavy workloads bogging things down, it prevents infinitely looping bugs from slowing the system to a crawl and in general makes things resilient to things not being ideal all the time.<p>Well put. Reliability was one of the initial requirements of Erlang, but soft real-time properties was another one. This is hard to do, but BEAM VM does a great job there. To get this right the VM has to be able to preempt processes, even if they run a tight CPU bound loop. A misbehaving process may not just crash, it could just endlessly recurse, burning CPU cycles, but still shouldn&#x27;t bring the system down.<p>&gt; The strategies are normally one_for_one, one_for_all and one_for_rest<p>Minor correction, the last one is rest_for_one <a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;man&#x2F;supervisor.html#supervision-principles" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;man&#x2F;supervisor.html#supervision-p...</a></div><br/></div></div><div id="37636994" class="c"><input type="checkbox" id="c-37636994" checked=""/><div class="controls bullet"><span class="by">thruflo</span><span>|</span><a href="#37639503">prev</a><span>|</span><a href="#37637238">next</a><span>|</span><label class="collapse" for="c-37636994">[-]</label><label class="expand" for="c-37636994">[10 more]</label></div><br/><div class="children"><div class="content">One of the great things about the Elixir ecosystem is that, in so many cases, the libraries you’re using make the appropriate use of supervision trees so you don’t have to.<p>Obviously it depends on what you’re building and you can craft your own supervision structures if you want to. But most of the time you can get the benefits of BEAM resiliency without having to drop down into the details.</div><br/><div id="37637483" class="c"><input type="checkbox" id="c-37637483" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37636994">parent</a><span>|</span><a href="#37637238">next</a><span>|</span><label class="collapse" for="c-37637483">[-]</label><label class="expand" for="c-37637483">[9 more]</label></div><br/><div class="children"><div class="content">The one thing I dislike about Elixir is the confusion caused by how some libraries execute their functionality in-process and others spawn a supervision tree and message pass - putting your work in a possible queue that can get overloaded.<p>Its a common pitfall for more inexperienced devs and I think its just a symptom of the language conventions.<p>Everyone is taught genservers with a client-side API existing inside the same module as handle_ functions and it blurs the distiction some.<p>I think if the convention was to create a separate module to implement the client-side convenience functions then the client-server split would be more obvious.</div><br/><div id="37640868" class="c"><input type="checkbox" id="c-37640868" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#37636994">root</a><span>|</span><a href="#37637483">parent</a><span>|</span><a href="#37639609">next</a><span>|</span><label class="collapse" for="c-37640868">[-]</label><label class="expand" for="c-37640868">[1 more]</label></div><br/><div class="children"><div class="content">When you say &#x27;execute their functionality in-process&#x27;, what exactly do you mean? In the context of the current process? Are there any good resources explaining when it is more appropriate to do one over the other?</div><br/></div></div><div id="37639609" class="c"><input type="checkbox" id="c-37639609" checked=""/><div class="controls bullet"><span class="by">lawik</span><span>|</span><a href="#37636994">root</a><span>|</span><a href="#37637483">parent</a><span>|</span><a href="#37640868">prev</a><span>|</span><a href="#37637692">next</a><span>|</span><label class="collapse" for="c-37639609">[-]</label><label class="expand" for="c-37639609">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, there are a few common mistakes that can get really troublesome when library authors make them. Assuming how you want to structure execution (by using GenServers in the library usually). Another one is only one instance of config. Meaning if you have a plan to use the library for multiple distinct activities or with multiple accounts, you have trouble.<p>Both simple config and GenServers have their place in libraries. But if a library doesn&#x27;t expose the fundamentals it gets gnarly quickly.</div><br/></div></div><div id="37637692" class="c"><input type="checkbox" id="c-37637692" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#37636994">root</a><span>|</span><a href="#37637483">parent</a><span>|</span><a href="#37639609">prev</a><span>|</span><a href="#37637614">next</a><span>|</span><label class="collapse" for="c-37637692">[-]</label><label class="expand" for="c-37637692">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The one thing I dislike about Elixir is the confusion caused by how some libraries execute their functionality in-process and others spawn a supervision tree and message pass.<p>It&#x27;s my assumption that needless process-starting is from classic OO developers trying to get something closer to the objects they&#x27;re used to.  I&#x27;m not sure separating the client and API logic in tutorials would necessarily stop them from doing this.  People who are hellbent on shoehorning familiar idioms into an unfamiliar language are going to do so regardless.  But I see what you&#x27;re saying.<p>I think it&#x27;s more important to drill home that modules and processes have nothing to do with each other.  I still catch myself conflating them once in a while three years in and it&#x27;s caused the most confusion while trying to teach friends (although I&#x27;m not a particularly good teacher).</div><br/></div></div><div id="37637614" class="c"><input type="checkbox" id="c-37637614" checked=""/><div class="controls bullet"><span class="by">cgio</span><span>|</span><a href="#37636994">root</a><span>|</span><a href="#37637483">parent</a><span>|</span><a href="#37637692">prev</a><span>|</span><a href="#37637238">next</a><span>|</span><label class="collapse" for="c-37637614">[-]</label><label class="expand" for="c-37637614">[5 more]</label></div><br/><div class="children"><div class="content">This is an allowed practice, just not idiomatic, mostly following on Erlang convention I think. If you do the coding gnome elixir course, he quite explicitly has a section on this and proceeds with separating API from server. At the end of the day, it is equivalent and all it takes is getting used to one or the other. I would argue spending the time to get used to the idiomatic way a community establishes is to your benefit in the end.</div><br/><div id="37637747" class="c"><input type="checkbox" id="c-37637747" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37636994">root</a><span>|</span><a href="#37637614">parent</a><span>|</span><a href="#37637238">next</a><span>|</span><label class="collapse" for="c-37637747">[-]</label><label class="expand" for="c-37637747">[4 more]</label></div><br/><div class="children"><div class="content">I agree and love Elixir and use it daily. I think my downvotes above is really strange lmao. This is just a common footgun I see new developers struggle with.</div><br/><div id="37637962" class="c"><input type="checkbox" id="c-37637962" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#37636994">root</a><span>|</span><a href="#37637747">parent</a><span>|</span><a href="#37639189">next</a><span>|</span><label class="collapse" for="c-37637962">[-]</label><label class="expand" for="c-37637962">[1 more]</label></div><br/><div class="children"><div class="content">My guess re: downvotes is the wording.  The opening sort of reads like you have written-off Elixir entirely because of this one issue.  That was the impression I got, at least, though I was able to figure out that wasn&#x27;t the case before I responded.</div><br/></div></div><div id="37639189" class="c"><input type="checkbox" id="c-37639189" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#37636994">root</a><span>|</span><a href="#37637747">parent</a><span>|</span><a href="#37637962">prev</a><span>|</span><a href="#37637238">next</a><span>|</span><label class="collapse" for="c-37639189">[-]</label><label class="expand" for="c-37639189">[2 more]</label></div><br/><div class="children"><div class="content">I feel like Elixir get pushed too hard on people. Makes me skeptical. Same way I feel about TypeScript community. Calm down, it&#x27;s just a programming language.<p>I don&#x27;t believe the programming language matters much. What matters is one&#x27;s familiarity with it. There are good tools and frameworks available for just about any moderately popular language. Every language has caveats. Every language has lots of pros and cons and when you average them out, they&#x27;re essentially all the same.<p>Just a matter of personal preferences and habits.</div><br/><div id="37639656" class="c"><input type="checkbox" id="c-37639656" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#37636994">root</a><span>|</span><a href="#37639189">parent</a><span>|</span><a href="#37637238">next</a><span>|</span><label class="collapse" for="c-37639656">[-]</label><label class="expand" for="c-37639656">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just a programming language—it&#x27;s an entire philosophy centered around fault tolerance and concurrency, thanks to its foundation on the Erlang VM. While Elixir&#x27;s syntax and features are certainly appealing, the real power lies in its integration with the Erlang VM. When people praise Elixir, a significant portion of that praise is directed at the capabilities you get with OTP&#x2F;BEAM right out of the box. These include robustness, distribution, and real-time processing, which are not as readily available or as mature in other ecosystems. the Erlang VM is 38+ years old.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37637238" class="c"><input type="checkbox" id="c-37637238" checked=""/><div class="controls bullet"><span class="by">sriram_sun</span><span>|</span><a href="#37636994">prev</a><span>|</span><a href="#37640721">next</a><span>|</span><label class="collapse" for="c-37637238">[-]</label><label class="expand" for="c-37637238">[3 more]</label></div><br/><div class="children"><div class="content">Nice article! FTA: &quot;One for one indicates that if a child crashes it, it and only it should be considered when restarting.&quot;
What is &quot;it&quot; in this context?</div><br/><div id="37637366" class="c"><input type="checkbox" id="c-37637366" checked=""/><div class="controls bullet"><span class="by">amilner42</span><span>|</span><a href="#37637238">parent</a><span>|</span><a href="#37637666">next</a><span>|</span><label class="collapse" for="c-37637366">[-]</label><label class="expand" for="c-37637366">[1 more]</label></div><br/><div class="children"><div class="content">“It” is the child.<p>So if the supervisor (“parent”) has other children, they won’t be restarted</div><br/></div></div><div id="37637666" class="c"><input type="checkbox" id="c-37637666" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#37637238">parent</a><span>|</span><a href="#37637366">prev</a><span>|</span><a href="#37640721">next</a><span>|</span><label class="collapse" for="c-37637666">[-]</label><label class="expand" for="c-37637666">[1 more]</label></div><br/><div class="children"><div class="content">The should be a first comma after “crashes” IMHO.</div><br/></div></div></div></div><div id="37640721" class="c"><input type="checkbox" id="c-37640721" checked=""/><div class="controls bullet"><span class="by">ecmascript</span><span>|</span><a href="#37637238">prev</a><span>|</span><a href="#37637034">next</a><span>|</span><label class="collapse" for="c-37640721">[-]</label><label class="expand" for="c-37640721">[1 more]</label></div><br/><div class="children"><div class="content">The thing about Elixir resilience is that it takes experience to fully appreciate what it does and realize that in a web app, the actual use case when this becomes important is not that often to be totally honest.<p>I can give an example where this could be useful, I once worked on a node-app that couldn&#x27;t use clustering mode because reasons and we only had 1 server running this particular piece of code. It turned out that we had a bug that made the node app crash whenever a user posted some invalid data. The problem here was that the app itself was a SPA and the users could just keep on posting even if it failed and they did in frustration.<p>So then app crashed and took a few seconds to reload, then crashed again. This mean that the entire api went down while the user was posting and thus could not respond to any other requests. This would never happen in Elixir and the load would just continue being ok even if 100 users at the same time would keep posting bad data.<p>The bad thing about Elixir resilience is that it is only applied to application logic. The rest of the time shit can go wrong is just the same as any other app since most elixir projects use the same kind of tooling (postgres, some web server in front etc). Not that many seems to use the built in mnesia database, no downtime deployment etc. The BEAM comes with many cool feature in theory but very few actually utilizes them so this 99.99999% uptime rarely comes into effect. The amount of time I&#x27;ve had downtime on apps because of things in the application logic like the first story I mentioned has been very, very few and most of the time it&#x27;s something else entirely and that thing does Elixir not really help with most of the time.<p>Sure you could utilize all the cool features of the BEAM but it seems like in the absolute majority of cases the amount of work is simply too great for it to be worth the time investment required.</div><br/></div></div><div id="37637034" class="c"><input type="checkbox" id="c-37637034" checked=""/><div class="controls bullet"><span class="by">nighmi</span><span>|</span><a href="#37640721">prev</a><span>|</span><label class="collapse" for="c-37637034">[-]</label><label class="expand" for="c-37637034">[25 more]</label></div><br/><div class="children"><div class="content">Elixir seems to be picking up insane steam right now. Every day or two there is a fascinating Elixir post here and its promise seems too good to resist. Has anyone else latched their cart onto this horse?</div><br/><div id="37639833" class="c"><input type="checkbox" id="c-37639833" checked=""/><div class="controls bullet"><span class="by">lawik</span><span>|</span><a href="#37637034">parent</a><span>|</span><a href="#37638746">next</a><span>|</span><label class="collapse" for="c-37639833">[-]</label><label class="expand" for="c-37639833">[1 more]</label></div><br/><div class="children"><div class="content">As someone active in the community I wouldn&#x27;t say there has been any particularly massive ramp up recently.<p>Someone refernced ElixirConf US and some of the news-flow is certainly from that.<p>Elixir has been building a steady steam pressure for a long time and I think steady is still the case.<p>As someone writing about Elixir I will say that it has good traction here as a general rule. I think Erlang appeals to the CS-interested, Elixir appeals to a lot of Ruby and startup folks. The ecosystem also innovates a decent bit. I think it punches above its weight on the HN front page.<p>It is a healthy ecosystem and seems to grow.<p>(edit: a spelling)</div><br/></div></div><div id="37638746" class="c"><input type="checkbox" id="c-37638746" checked=""/><div class="controls bullet"><span class="by">bicx</span><span>|</span><a href="#37637034">parent</a><span>|</span><a href="#37639833">prev</a><span>|</span><a href="#37637229">next</a><span>|</span><label class="collapse" for="c-37638746">[-]</label><label class="expand" for="c-37638746">[2 more]</label></div><br/><div class="children"><div class="content">I built a fintech backend system using Eljxir a few years ago, and I loved it. However, I had to use Go and Python as a sort of escape hatch when companies offered massively time-saving SDKs in those languages but not Elixir. The ecosystem doesn’t seem to have really grown much since then. Looking around at the state of things, lots of important OSS packages have not been maintained, and that’s concerning. I absolutely love Elixir and the careful thought put into so much of the language and primary frameworks. However, I have become more skeptical that the actual ecosystem will hit critical mass. I really wish it would. I see a lot of articles on HN about Elixir, but my feeling is that it’s just more interesting than the constant stream of JS and Python we’ve had for decades now.</div><br/><div id="37639641" class="c"><input type="checkbox" id="c-37639641" checked=""/><div class="controls bullet"><span class="by">ch4s3</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37638746">parent</a><span>|</span><a href="#37637229">next</a><span>|</span><label class="collapse" for="c-37639641">[-]</label><label class="expand" for="c-37639641">[1 more]</label></div><br/><div class="children"><div class="content">In my experience a lot of OSS elixir libraries are basically done. They get updated if the language changes, but otherwise they just do what they do well and they resist feature creep.</div><br/></div></div></div></div><div id="37637229" class="c"><input type="checkbox" id="c-37637229" checked=""/><div class="controls bullet"><span class="by">plondon514</span><span>|</span><a href="#37637034">parent</a><span>|</span><a href="#37638746">prev</a><span>|</span><a href="#37637175">next</a><span>|</span><label class="collapse" for="c-37637229">[-]</label><label class="expand" for="c-37637229">[9 more]</label></div><br/><div class="children"><div class="content">The company I started working for a few months ago wrote their whole web app with Elixir&#x2F;Phoenix LiveView. It&#x27;s been a real pleasure to work with after years of React and Next.js. The main thing I miss are types though.</div><br/><div id="37637684" class="c"><input type="checkbox" id="c-37637684" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37637229">parent</a><span>|</span><a href="#37637175">next</a><span>|</span><label class="collapse" for="c-37637684">[-]</label><label class="expand" for="c-37637684">[8 more]</label></div><br/><div class="children"><div class="content">Are there no typed languages on BEAM?<p>Or some Typescript style front for Elixir?</div><br/><div id="37638312" class="c"><input type="checkbox" id="c-37638312" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37637684">parent</a><span>|</span><a href="#37637893">next</a><span>|</span><label class="collapse" for="c-37638312">[-]</label><label class="expand" for="c-37638312">[1 more]</label></div><br/><div class="children"><div class="content">BEAM is pretty deeply untyped due to its fundamentally untyped [1] communication protocol. There&#x27;s some logical reasoning behind this choice, which is that by not having a typed communication protocol, it can defer handling mismatched types to the application layer. Since it is deeply designed with the knowledge that it will be used in a clustered context and that it is inevitable that there will be version mismatches within a cluster (during upgrade if nothing else since simultaneous anything is impossible within a cluster, including upgrades), this is a somewhat reasonable compromise approach to the problem. If you do add typing on top of BEAM you still need some sort of solution to this problem with will probably have some sort &quot;unsafe&quot; equivalent.<p>[1]: In the sense you mean here, anyhow. It has a selection of atomic types, int, list, tuple, etc., but there&#x27;s no &quot;user&quot; types as one would have a strong typing system for. It&#x27;s not an exact match but if you imagined a programming language that had nothing but JSON, not Javascript, Javascript has user types, literally just JSON as your underlying data model, you get pretty close to BEAM&#x2F;Erlang.</div><br/></div></div><div id="37637893" class="c"><input type="checkbox" id="c-37637893" checked=""/><div class="controls bullet"><span class="by">pawelduda</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37637684">parent</a><span>|</span><a href="#37638312">prev</a><span>|</span><a href="#37637702">next</a><span>|</span><label class="collapse" for="c-37637893">[-]</label><label class="expand" for="c-37637893">[1 more]</label></div><br/><div class="children"><div class="content">Types in Elixir are on the roadmap [1] but 
I don&#x27;t think there&#x27;s concrete ETA<p>For now you have typespecs and dialyzer that tries to infer types and detect incorrect assumptions in code but I found it cumbersome to work with. Testing in Elixir is first class so I prefer that for now. You get doctests (documentation that is also a runnable test), like in Python, which I find very useful when looking at some package source.<p>[1] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;giYbq4HmfGA?si=BjNyOc5cjWWA7ER6" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;giYbq4HmfGA?si=BjNyOc5cjWWA7ER6</a></div><br/></div></div><div id="37637702" class="c"><input type="checkbox" id="c-37637702" checked=""/><div class="controls bullet"><span class="by">lkurusa</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37637684">parent</a><span>|</span><a href="#37637893">prev</a><span>|</span><a href="#37638176">next</a><span>|</span><label class="collapse" for="c-37637702">[-]</label><label class="expand" for="c-37637702">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;gleam.run&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;gleam.run&#x2F;</a> Gleam is super promising.</div><br/></div></div><div id="37638176" class="c"><input type="checkbox" id="c-37638176" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37637684">parent</a><span>|</span><a href="#37637702">prev</a><span>|</span><a href="#37638255">next</a><span>|</span><label class="collapse" for="c-37638176">[-]</label><label class="expand" for="c-37638176">[1 more]</label></div><br/><div class="children"><div class="content">I’ve found that function head pattern matching and guards get you very close to the benefits of types.</div><br/></div></div><div id="37638255" class="c"><input type="checkbox" id="c-37638255" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37637684">parent</a><span>|</span><a href="#37638176">prev</a><span>|</span><a href="#37637175">next</a><span>|</span><label class="collapse" for="c-37638255">[-]</label><label class="expand" for="c-37638255">[3 more]</label></div><br/><div class="children"><div class="content">Elixir gets a lot of praise but very rarely mention that is&#x27;t a dynamically typed language, people will talk about Dialyzer&#x2F;type hints but it&#x27;s vastly inferior to strongly typed language.</div><br/><div id="37638442" class="c"><input type="checkbox" id="c-37638442" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37638255">parent</a><span>|</span><a href="#37638494">next</a><span>|</span><label class="collapse" for="c-37638442">[-]</label><label class="expand" for="c-37638442">[1 more]</label></div><br/><div class="children"><div class="content">I know people mean different things when they say this but Elixir is strongly typed in that it doesn&#x27;t auto-cast.  Furthermore, it goes farther than most languages in that it doesn&#x27;t overload many operators.  For example, string concatenation is done with `&lt;&gt;`, not `+`.  This rules out many of those &quot;subtle bugs&quot; you would get in many other dynamic langues.  For instance: `def compound_word(left, right), do: left &lt;&gt; right`.  Even though there are no types specified (or even patterns of guards) this function can only every succeed with strings.  Yes, it&#x27;s still dynamic and will only be caught at runtime, but there are things about Elixir that make it a really nice dynamic language.</div><br/></div></div><div id="37638494" class="c"><input type="checkbox" id="c-37638494" checked=""/><div class="controls bullet"><span class="by">impulser_</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37638255">parent</a><span>|</span><a href="#37638442">prev</a><span>|</span><a href="#37637175">next</a><span>|</span><label class="collapse" for="c-37638494">[-]</label><label class="expand" for="c-37638494">[1 more]</label></div><br/><div class="children"><div class="content">Python gets a lot of praise too despite being a dynamically typed language. People will talk about MyPy&#x2F;type hints but it vastly inferior to statically typed language.<p>(Elixir is strongly typed btw)<p>Elixir is essentially the functional python.</div><br/></div></div></div></div></div></div></div></div><div id="37637175" class="c"><input type="checkbox" id="c-37637175" checked=""/><div class="controls bullet"><span class="by">lkurusa</span><span>|</span><a href="#37637034">parent</a><span>|</span><a href="#37637229">prev</a><span>|</span><a href="#37637286">next</a><span>|</span><label class="collapse" for="c-37637175">[-]</label><label class="expand" for="c-37637175">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been running a large web application backend written in Elixir for over three years now. It&#x27;s awesome and we&#x27;ve also rewritten some of our microservices to utilize Distributed Erlang. No need for a service mesh this way. :-)</div><br/></div></div><div id="37637286" class="c"><input type="checkbox" id="c-37637286" checked=""/><div class="controls bullet"><span class="by">Arubis</span><span>|</span><a href="#37637034">parent</a><span>|</span><a href="#37637175">prev</a><span>|</span><a href="#37637913">next</a><span>|</span><label class="collapse" for="c-37637286">[-]</label><label class="expand" for="c-37637286">[2 more]</label></div><br/><div class="children"><div class="content">Part of this is that ElixirConf 2023 just finished up, so we’re getting the news output of the talks given and libraries released.</div><br/><div id="37638960" class="c"><input type="checkbox" id="c-37638960" checked=""/><div class="controls bullet"><span class="by">anoy8888</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37637286">parent</a><span>|</span><a href="#37637913">next</a><span>|</span><label class="collapse" for="c-37638960">[-]</label><label class="expand" for="c-37638960">[1 more]</label></div><br/><div class="children"><div class="content">Seeing a lot of rust , elixir, JavaScript but not seeing much clojure . Wonder how clojure compares to elixir in terms of developer productivity</div><br/></div></div></div></div><div id="37637913" class="c"><input type="checkbox" id="c-37637913" checked=""/><div class="controls bullet"><span class="by">julienmarie</span><span>|</span><a href="#37637034">parent</a><span>|</span><a href="#37637286">prev</a><span>|</span><a href="#37640323">next</a><span>|</span><label class="collapse" for="c-37637913">[-]</label><label class="expand" for="c-37637913">[6 more]</label></div><br/><div class="children"><div class="content">Been running our tech stack on Elixir for the last 3 years. I&#x27;m the owner of a small e-commerce company where I&#x27;m the only tech person (and also the ceo so I can only spend 20% of my time on tech).<p>Why I love it:<p>- The mental model just clicks for me. The syntax is really simple and the semantics are consistent. There is no abstraction. It&#x27;s all about processing data.<p>- The REPL (IEX) is way more than a REPL. It&#x27;s &quot;you inside your running program&quot;. You can poke around your code, draft it, debug it, right there. You can fire it on prod to understand a bug. Or use LiveBook, think of it like the Elixir version of Jupyter notebooks that can connect to your application.<p>- Real life performance is great, not because of speed but because of concurrency.<p>- The whole developer experience is great. Mix (the build tool, dependency manager, etc.) is simple, awesome. Dependencies are really rarely an issue.<p>- It&#x27;s rock solid. In 3 years, I never had one downtime.<p>- LiveView is a god send. Not having to switch language for UI work is amazing, performance is great, and it&#x27;s server side HTML which is amazing for SEO. My website is 99 on lighthouse without any crazy work.<p>- You need heavy computation and performance on some parts? Use rust, via rustler.<p>- You need to scale to multiple servers? It is distributed. Already. Just make sure to not have anti-patterns in your code.<p>- But the real kicker it&#x27;s in its power due to the OTP platform. I think it&#x27;s quite complex to grasp how much it&#x27;s powerful when you haven&#x27;t experienced it. Need to batch insert statements or rate limit api calls to a 3rd party service who can only accept one call per second per channel? A working simple solution is only 20 lines of code. Need to launch many different workflows running concurrently, keeping their state, recovering when crashing? 100 lines.<p>The exciting developments:<p>- Elixir NX ecosystem (NX, Bumblebee, etc): running and training AI models directly in Elixir, in a distributed way.<p>- Liveview Native and Elixir Desktop: two big initiative to bring Elixir to Desktop and Mobile applications.<p>- Gradual Typesystem. Jose Valim, the creator of Elixir, is working on that right now. I really liked the approach of set-theoretic types and the pragmatism of the approach. Hopefully it will be released in the not too distant future.<p>The &quot;to improve&quot;:<p>I have the feeling that the platform (OTP) being the killer app per se of Elixir, the whole marketing of the ecosystem if 100% targeted towards developers. Which is good in many ways. But for the ecosystem to grow I think more initiatives towards business-type applications would be welcome. By example, there is only a few payment gateways libraries existing which is for me a sign of the lack of business audience.<p>Conclusion:
Elixir made me a better developer, but most importantly a really productive one.</div><br/><div id="37638931" class="c"><input type="checkbox" id="c-37638931" checked=""/><div class="controls bullet"><span class="by">anoy8888</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37637913">parent</a><span>|</span><a href="#37638190">next</a><span>|</span><label class="collapse" for="c-37638931">[-]</label><label class="expand" for="c-37638931">[2 more]</label></div><br/><div class="children"><div class="content">Some dumb questions: for liveview web &#x2F; liveview native, is it possible to save rendered code offline and every time it connects to server , it will first check a defined version number ,if the version changes , it will update the code. If the the version is the same or if there is no internet connection, it will use stored code. Perhaps Elixi can be used this way for offline apps while maintaining the dynamic server rendering feature</div><br/><div id="37639258" class="c"><input type="checkbox" id="c-37639258" checked=""/><div class="controls bullet"><span class="by">abrookewood</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37638931">parent</a><span>|</span><a href="#37638190">next</a><span>|</span><label class="collapse" for="c-37639258">[-]</label><label class="expand" for="c-37639258">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that would work - with Liveview the code is on the server and only the rendered HTML (or the dynamic changes) are sent to the client. Based on what you are suggesting, you&#x27;d need JS to to the processing or maybe WASM.</div><br/></div></div></div></div><div id="37638190" class="c"><input type="checkbox" id="c-37638190" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37637913">parent</a><span>|</span><a href="#37638931">prev</a><span>|</span><a href="#37640323">next</a><span>|</span><label class="collapse" for="c-37638190">[-]</label><label class="expand" for="c-37638190">[3 more]</label></div><br/><div class="children"><div class="content">This is very inspiring.  I&#x27;m in a similar situation!  I&#x27;m also the only tech person for a small ecomm company, I&#x27;m just not the owner :)<p>I obviously have lots of questions but biggest one that relates to other convos I had on HN recently: did you use an off-the-shelf ecomm solution or roll your own?</div><br/><div id="37638603" class="c"><input type="checkbox" id="c-37638603" checked=""/><div class="controls bullet"><span class="by">julienmarie</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37638190">parent</a><span>|</span><a href="#37640323">next</a><span>|</span><label class="collapse" for="c-37638603">[-]</label><label class="expand" for="c-37638603">[2 more]</label></div><br/><div class="children"><div class="content">It started with an off the shelf solution initially, but it didn&#x27;t scale.
I replaced 90% of it with our Elixir solution. The remaining 10% is the one that takes the longer to kill!</div><br/><div id="37638846" class="c"><input type="checkbox" id="c-37638846" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37638603">parent</a><span>|</span><a href="#37640323">next</a><span>|</span><label class="collapse" for="c-37638846">[-]</label><label class="expand" for="c-37638846">[1 more]</label></div><br/><div class="children"><div class="content">What was the off-the-shelf one if you don&#x27;t mind my asking?  It&#x27;s total curiosity as I&#x27;m wondering what people go for in the Elixir space.  Although it sounds like you started without Elixir?</div><br/></div></div></div></div></div></div></div></div><div id="37640323" class="c"><input type="checkbox" id="c-37640323" checked=""/><div class="controls bullet"><span class="by">passion__desire</span><span>|</span><a href="#37637034">parent</a><span>|</span><a href="#37637913">prev</a><span>|</span><a href="#37637048">next</a><span>|</span><label class="collapse" for="c-37640323">[-]</label><label class="expand" for="c-37640323">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because HN actively promotes Elixir. Even simple posts with 3 points hit front page.</div><br/><div id="37640338" class="c"><input type="checkbox" id="c-37640338" checked=""/><div class="controls bullet"><span class="by">justusw</span><span>|</span><a href="#37637034">root</a><span>|</span><a href="#37640323">parent</a><span>|</span><a href="#37637048">next</a><span>|</span><label class="collapse" for="c-37640338">[-]</label><label class="expand" for="c-37640338">[1 more]</label></div><br/><div class="children"><div class="content">That sounds somewhat similar to the “I rewrote X - in Rust”, or “Why isn’t Linux rewritten in Rust?!” posts that get upvoted quite a lot, or used to.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>