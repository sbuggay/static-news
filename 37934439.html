<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1697706062620" as="style"/><link rel="stylesheet" href="styles.css?v=1697706062620"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/konigsoftware/konig-kontext">gRPC request context which caries values across microservice boundaries</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>reidbuzby</span> | <span>40 comments</span></div><br/><div><div id="37935724" class="c"><input type="checkbox" id="c-37935724" checked=""/><div class="controls bullet"><span class="by">zinodaur</span><span>|</span><a href="#37934440">next</a><span>|</span><label class="collapse" for="c-37935724">[-]</label><label class="expand" for="c-37935724">[2 more]</label></div><br/><div class="children"><div class="content">&quot;You can only call this RPC while standing on one foot, with your hat cocked to the side. There&#x27;s no way for you to find this out except calling it in a test and getting a weird error&quot;</div><br/><div id="37936991" class="c"><input type="checkbox" id="c-37936991" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#37935724">parent</a><span>|</span><a href="#37934440">next</a><span>|</span><label class="collapse" for="c-37936991">[-]</label><label class="expand" for="c-37936991">[1 more]</label></div><br/><div class="children"><div class="content">This is a direct consequence of Hyrum&#x27;s Law</div><br/></div></div></div></div><div id="37934440" class="c"><input type="checkbox" id="c-37934440" checked=""/><div class="controls bullet"><span class="by">reidbuzby</span><span>|</span><a href="#37935724">prev</a><span>|</span><a href="#37939230">next</a><span>|</span><label class="collapse" for="c-37934440">[-]</label><label class="expand" for="c-37934440">[11 more]</label></div><br/><div class="children"><div class="content">Hey everyone, I&#x27;ve recently created an open source library on top of grpc-kotlin and grpc-java that allows you to propagate a context across microservice boundaries throughout an entire request lifetime. The existing io.grpc.Context (<a href="https:&#x2F;&#x2F;grpc.github.io&#x2F;grpc-java&#x2F;javadoc&#x2F;io&#x2F;grpc&#x2F;Context.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;grpc.github.io&#x2F;grpc-java&#x2F;javadoc&#x2F;io&#x2F;grpc&#x2F;Context.htm...</a>) only propagates a context across API boundaries within the same container and does not cross microservice boundaries.<p>It&#x27;s called KonigKontext, check it out here: <a href="https:&#x2F;&#x2F;github.com&#x2F;konigsoftware&#x2F;konig-kontext">https:&#x2F;&#x2F;github.com&#x2F;konigsoftware&#x2F;konig-kontext</a>!<p>Example use cases include:<p>Propagating security principals, or user credentials and identifiers throughout an entire request lifetime across all of your microservices.
Propogating distributed tracing information. Set a request trace id upon receiving a request and later access that id in any downstream microservice.
However, Konig Kontext is built to support any type of context value, so it can be extended to fit any specific use cases as well.<p>Let me know what you think!</div><br/><div id="37935387" class="c"><input type="checkbox" id="c-37935387" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#37934440">parent</a><span>|</span><a href="#37937115">next</a><span>|</span><label class="collapse" for="c-37935387">[-]</label><label class="expand" for="c-37935387">[9 more]</label></div><br/><div class="children"><div class="content">Why not just add this stuff to the request itself?</div><br/><div id="37935477" class="c"><input type="checkbox" id="c-37935477" checked=""/><div class="controls bullet"><span class="by">rossjudson</span><span>|</span><a href="#37934440">root</a><span>|</span><a href="#37935387">parent</a><span>|</span><a href="#37935519">next</a><span>|</span><label class="collapse" for="c-37935477">[-]</label><label class="expand" for="c-37935477">[5 more]</label></div><br/><div class="children"><div class="content">It avoids polluting your request classes with side channel details that your service may not even be concerned with at all; it makes for nice abstractions.<p>It allows for the opaque propagation of side channel information, where intermediates don&#x27;t need to know what&#x27;s there.<p>side-channel-with-well-defined-propagation-rules is pretty useful.</div><br/><div id="37935723" class="c"><input type="checkbox" id="c-37935723" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#37934440">root</a><span>|</span><a href="#37935477">parent</a><span>|</span><a href="#37935519">next</a><span>|</span><label class="collapse" for="c-37935723">[-]</label><label class="expand" for="c-37935723">[4 more]</label></div><br/><div class="children"><div class="content">Adding hidden data to the request seems counter to the desire for a schema driven rpc.  I guess it&#x27;s a matter of taste whether some data is pollution or simply explicit.  You&#x27;re sending data that the service may or may not be concerned with whether its in the header or the body or some other side channel.<p>Maybe my reaction is a question of purity.  I don&#x27;t really see why one would think a request body should be in the schema but we should leave other data out of the schema.  Wouldn&#x27;t every single argument point to consistency?<p>I like gRPC and what it gives you.  I personally would like that same explicit schema and type safety to apply to my tracing as well. Its interesting to me that others would draw a line.</div><br/><div id="37935806" class="c"><input type="checkbox" id="c-37935806" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#37934440">root</a><span>|</span><a href="#37935723">parent</a><span>|</span><a href="#37936958">next</a><span>|</span><label class="collapse" for="c-37935806">[-]</label><label class="expand" for="c-37935806">[1 more]</label></div><br/><div class="children"><div class="content">Debug&#x2F;tracing data is a great use case for context, for example. If propagating trace information has to be done manually, then you significantly weaken the utility of cross-service tracing. You&#x27;ll always be questioning if lack of a trace means it didn&#x27;t happen, or if it means someone forgot to pass along the trace context.<p>This applies especially to grpc, where everything is optional.<p>To be clear, I prefer explicit over implicit. But that doesn&#x27;t always scale well to large orgs.</div><br/></div></div><div id="37936958" class="c"><input type="checkbox" id="c-37936958" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37934440">root</a><span>|</span><a href="#37935723">parent</a><span>|</span><a href="#37935806">prev</a><span>|</span><a href="#37935772">next</a><span>|</span><label class="collapse" for="c-37936958">[-]</label><label class="expand" for="c-37936958">[1 more]</label></div><br/><div class="children"><div class="content">While I agree, gRPC is based on protobufs, which are incredibly weakly typed.  They specifically include mechanisms for passing through mysterious (not in the schema and of unknown type) data intact.<p>So, I’d argue the OP is using gRPC correctly, and I’d be using it wrong if I hadn’t given up on it long ago.  I appreciate things like static type checking, and services that err on the side of rejecting unparsable requests in order to avoid data corruption.  Protobufs&#x2F;gRPC require heroic effort on the part of the RPC handler implementation if you want those things.  In particular, it is easier to implement your own serialization format than typecheck the results returned by the APIs protoc emits.</div><br/></div></div><div id="37935772" class="c"><input type="checkbox" id="c-37935772" checked=""/><div class="controls bullet"><span class="by">reidbuzby</span><span>|</span><a href="#37934440">root</a><span>|</span><a href="#37935723">parent</a><span>|</span><a href="#37936958">prev</a><span>|</span><a href="#37935519">next</a><span>|</span><label class="collapse" for="c-37935772">[-]</label><label class="expand" for="c-37935772">[1 more]</label></div><br/><div class="children"><div class="content">You do get the same explicit schema and type safety with this library. The context values can be typed using a protobuf message: <a href="https:&#x2F;&#x2F;github.com&#x2F;konigsoftware&#x2F;konig-kontext#protobuf-message-based-type">https:&#x2F;&#x2F;github.com&#x2F;konigsoftware&#x2F;konig-kontext#protobuf-mess...</a>, or any other type you&#x27;d like. Although you are right, it is not explicitly in the request schema but that&#x27;s kinda the point.</div><br/></div></div></div></div></div></div><div id="37935519" class="c"><input type="checkbox" id="c-37935519" checked=""/><div class="controls bullet"><span class="by">zeroxfe</span><span>|</span><a href="#37934440">root</a><span>|</span><a href="#37935387">parent</a><span>|</span><a href="#37935477">prev</a><span>|</span><a href="#37935663">next</a><span>|</span><label class="collapse" for="c-37935519">[-]</label><label class="expand" for="c-37935519">[2 more]</label></div><br/><div class="children"><div class="content">Because every single handler in a long chain of requests will have to explicitly support and propagate this data. The whole idea of a request context is to let you plumb low-cost metadata transparently through a call tree, and decouple your code from that metadata.</div><br/><div id="37936831" class="c"><input type="checkbox" id="c-37936831" checked=""/><div class="controls bullet"><span class="by">jarym</span><span>|</span><a href="#37934440">root</a><span>|</span><a href="#37935519">parent</a><span>|</span><a href="#37935663">next</a><span>|</span><label class="collapse" for="c-37936831">[-]</label><label class="expand" for="c-37936831">[1 more]</label></div><br/><div class="children"><div class="content">Very well articulated and agree.<p>It’s one of those things you eventually wish you had.</div><br/></div></div></div></div><div id="37935663" class="c"><input type="checkbox" id="c-37935663" checked=""/><div class="controls bullet"><span class="by">reidbuzby</span><span>|</span><a href="#37934440">root</a><span>|</span><a href="#37935387">parent</a><span>|</span><a href="#37935519">prev</a><span>|</span><a href="#37937115">next</a><span>|</span><label class="collapse" for="c-37935663">[-]</label><label class="expand" for="c-37935663">[1 more]</label></div><br/><div class="children"><div class="content">Ditto whats been said before. It can be very cumbersome to update multiple request&#x2F;response types with new data especially if an intermediary service has no use for the data and is simply passing it through.</div><br/></div></div></div></div><div id="37937115" class="c"><input type="checkbox" id="c-37937115" checked=""/><div class="controls bullet"><span class="by">no_circuit</span><span>|</span><a href="#37934440">parent</a><span>|</span><a href="#37935387">prev</a><span>|</span><a href="#37939230">next</a><span>|</span><label class="collapse" for="c-37937115">[-]</label><label class="expand" for="c-37937115">[1 more]</label></div><br/><div class="children"><div class="content">The header is fixed as konig-kontext-grpc-context [1]. Does that mean that you can only propagate one gRPC context object? Would it be possible to specify your own header string for the key, and have the interceptors support multiple keys? That sounds safer since the header name could both imply both the serialization and content-type, and Protobuf type_uri, etc. And sounds more useful since developers wouldn&#x27;t need a catch-all type.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;konigsoftware&#x2F;konig-kontext&#x2F;blob&#x2F;84faa627f43445c7a3e0cad8b96f1fb768eac0ad&#x2F;lib&#x2F;src&#x2F;main&#x2F;kotlin&#x2F;com&#x2F;konigsoftware&#x2F;kontext&#x2F;KonigKontextKey.kt#L12">https:&#x2F;&#x2F;github.com&#x2F;konigsoftware&#x2F;konig-kontext&#x2F;blob&#x2F;84faa627...</a></div><br/></div></div></div></div><div id="37939230" class="c"><input type="checkbox" id="c-37939230" checked=""/><div class="controls bullet"><span class="by">cmeiklejohn</span><span>|</span><a href="#37934440">prev</a><span>|</span><a href="#37935622">next</a><span>|</span><label class="collapse" for="c-37939230">[-]</label><label class="expand" for="c-37939230">[2 more]</label></div><br/><div class="children"><div class="content">OpenTelemetry&#x27;s Java implementation does this, but it actually does it in a way that non-GRPC things can access this context as well by ensuring that it propagates throughout both the CoroutineContext and the thread-local state that&#x27;s used by OpenTelemetry itself to propagate tracing information into Java code that is used by a Kotlin coroutine that happens to execute code that was written in Java.<p>e.g., I handle a request, get the incoming context, have to stash it because I might execute a coroutine that is suspended&#x2F;resumed across different threads, and subsequently then execute another GRPC call in a Java library, that happens to start, get rescheduled and resume on receiving the response on a different thread, in a possibly different thread pool.<p>The OpenTelemetry handling for this is quite complex: it must be used as a javaagent so it can actually instrument underlying libraries with the necessary code for handling thread scheduling&#x2F;context switches in both thread pools (e.g., ForkJoinPool), threads themselves, with cooperative scheduling in application code (e.g., Thread) and Kotlin&#x27;s coroutine handling with is mostly codegen (e.g., async, suspend fun.)<p>Finally, in my own Ph.D. work, we did a similar thing to propagate trace identifiers for a dynamic analysis for fault injection, and we quickly ran into a problem that --- not only is the propagation difficult in itself --- but, you also run the risk of running out of header space if you store any (longish?) information when GRPC is run over HTTP2 because of the maximum allowed header size.</div><br/><div id="37939317" class="c"><input type="checkbox" id="c-37939317" checked=""/><div class="controls bullet"><span class="by">cmeiklejohn</span><span>|</span><a href="#37939230">parent</a><span>|</span><a href="#37935622">next</a><span>|</span><label class="collapse" for="c-37939317">[-]</label><label class="expand" for="c-37939317">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also not sure what you mean by the context doesn&#x27;t propagate between containers and&#x2F;or pods -- GRPC isn&#x27;t aware of these Docker&#x2F;Kubernetes aspects at all.<p>Do you actually mean that <i>unless explicitly propagated to a subsequent downstream RPC</i> the data is dropped?  If so, that&#x27;s by design.<p>However, most large-scale organizations that are doing distributed tracing (e.g., Twitter, Uber) have either invented, reproduced, or leveraged OpenTelemetry&#x27;s design for this precise thing.<p>Naive context propagation isn&#x27;t (really) the difficult part with most of these designs -- it&#x27;s what you&#x27;ve done, using an interceptor, reading the data and assigning it automatically on subsequent requests -- the challenge is dealing with this under many different, real world conditions: a.) concurrency and thread scheduling; b.) not all services use the same version of downstream RPC libraries; c.) not all calls are GRPC, and some use HTTP (and, different HTTP libraries, at that.); and d.) you cross message passing boundaries: i.e., I receive request, write to Kafka queue&#x2F;reliable workflow backend (e.g., Cadence, Temporal) and re-read the request and then execute a subsequent RPC as a result of that message.<p>If you&#x27;re using Kotlin, I suspect you will run into these challenges.  Tune your thread pools up&#x2F;down, restrict your JVM&#x27;s resources, and you&#x27;ll suddenly see that if the thing that handles the request uses different threads&#x2F;coroutines&#x2F;etc. then the code block that issues the downstream RPC, you&#x27;ll start dropping the context <i>without explicit handling of that case.</i><p>In fact, a very simple test case in Java where you use several, concurrently executed CompleteableFuture&#x27;s that each issue RPCs, in a very small thread pool should be enough to see the issue.</div><br/></div></div></div></div><div id="37935622" class="c"><input type="checkbox" id="c-37935622" checked=""/><div class="controls bullet"><span class="by">nepthar</span><span>|</span><a href="#37939230">prev</a><span>|</span><a href="#37935625">next</a><span>|</span><label class="collapse" for="c-37935622">[-]</label><label class="expand" for="c-37935622">[3 more]</label></div><br/><div class="children"><div class="content">I am blown away that this is not already part of gRPC. A lifetime ago, I worked on twitter&#x27;s version of this sort of thing (thrift&#x2F;finagle) and I assumed it was standard.</div><br/><div id="37936979" class="c"><input type="checkbox" id="c-37936979" checked=""/><div class="controls bullet"><span class="by">no_circuit</span><span>|</span><a href="#37935622">parent</a><span>|</span><a href="#37936582">next</a><span>|</span><label class="collapse" for="c-37936979">[-]</label><label class="expand" for="c-37936979">[1 more]</label></div><br/><div class="children"><div class="content">Both the context and message metadata are already part of gRPC. The gRPC system also allows for server [2] and client message interceptors. Essentially this konig-kontext library provides a interceptor implementations, e.g., [3], that uses their hard-coded key for your serializable context that gets read&#x2F;written from a gRPC header. The context provided by konig-kontext within your code is a wrapper around the existing gRPC Context [1].<p>The library is convenient for sure, but I feel that if you had a need to propagate context within gRPC, you&#x27;d probably already discovered the API and implemented propagation with your own header keys.<p>[1] <a href="https:&#x2F;&#x2F;grpc.github.io&#x2F;grpc-java&#x2F;javadoc&#x2F;io&#x2F;grpc&#x2F;Context.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;grpc.github.io&#x2F;grpc-java&#x2F;javadoc&#x2F;io&#x2F;grpc&#x2F;Context.htm...</a><p>[2] <a href="https:&#x2F;&#x2F;grpc.github.io&#x2F;grpc-java&#x2F;javadoc&#x2F;io&#x2F;grpc&#x2F;ServerInterceptor.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;grpc.github.io&#x2F;grpc-java&#x2F;javadoc&#x2F;io&#x2F;grpc&#x2F;ServerInter...</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;konigsoftware&#x2F;konig-kontext&#x2F;blob&#x2F;84faa627f43445c7a3e0cad8b96f1fb768eac0ad&#x2F;lib&#x2F;src&#x2F;main&#x2F;kotlin&#x2F;com&#x2F;konigsoftware&#x2F;kontext&#x2F;KonigKontextClientInterceptor.kt">https:&#x2F;&#x2F;github.com&#x2F;konigsoftware&#x2F;konig-kontext&#x2F;blob&#x2F;84faa627...</a></div><br/></div></div><div id="37936582" class="c"><input type="checkbox" id="c-37936582" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#37935622">parent</a><span>|</span><a href="#37936979">prev</a><span>|</span><a href="#37935625">next</a><span>|</span><label class="collapse" for="c-37936582">[-]</label><label class="expand" for="c-37936582">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s HTTP&#x2F;2, so has headers and trailers.  That&#x27;s where most people put the metadata.</div><br/></div></div></div></div><div id="37935625" class="c"><input type="checkbox" id="c-37935625" checked=""/><div class="controls bullet"><span class="by">menzoic</span><span>|</span><a href="#37935622">prev</a><span>|</span><a href="#37935623">next</a><span>|</span><label class="collapse" for="c-37935625">[-]</label><label class="expand" for="c-37935625">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of data extensions at Uber <a href="https:&#x2F;&#x2F;www.uber.com&#x2F;blog&#x2F;microservice-architecture&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.uber.com&#x2F;blog&#x2F;microservice-architecture&#x2F;</a></div><br/></div></div><div id="37935623" class="c"><input type="checkbox" id="c-37935623" checked=""/><div class="controls bullet"><span class="by">hkon</span><span>|</span><a href="#37935625">prev</a><span>|</span><a href="#37935199">next</a><span>|</span><label class="collapse" for="c-37935623">[-]</label><label class="expand" for="c-37935623">[4 more]</label></div><br/><div class="children"><div class="content">I would imagine if you find yourself needing this a lot, your microservices are too granular.</div><br/><div id="37939732" class="c"><input type="checkbox" id="c-37939732" checked=""/><div class="controls bullet"><span class="by">cmeiklejohn</span><span>|</span><a href="#37935623">parent</a><span>|</span><a href="#37936931">next</a><span>|</span><label class="collapse" for="c-37939732">[-]</label><label class="expand" for="c-37939732">[2 more]</label></div><br/><div class="children"><div class="content">Microservices require distributed debugging; distributed debugging requires distributed tracing.  Just imagine, as I&#x27;ve been trying to push forwards in my own Ph.D. work, that you could debug a process across microservices.  This is why we want this; possibly, done a bit more resiliently and thoroughly than the original OP.</div><br/><div id="37939855" class="c"><input type="checkbox" id="c-37939855" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#37935623">root</a><span>|</span><a href="#37939732">parent</a><span>|</span><a href="#37936931">next</a><span>|</span><label class="collapse" for="c-37939855">[-]</label><label class="expand" for="c-37939855">[1 more]</label></div><br/><div class="children"><div class="content">I cannot help but feel that &quot;distributed debugging&quot; would already be a solved problem in Plan 9 operating system...</div><br/></div></div></div></div><div id="37936931" class="c"><input type="checkbox" id="c-37936931" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37935623">parent</a><span>|</span><a href="#37939732">prev</a><span>|</span><a href="#37935199">next</a><span>|</span><label class="collapse" for="c-37936931">[-]</label><label class="expand" for="c-37936931">[1 more]</label></div><br/><div class="children"><div class="content">The two examples they give are relevant irrespective of micro service granularity:<p>- User credentials e.g. JWT<p>- Distributed tracing identifier</div><br/></div></div></div></div><div id="37935199" class="c"><input type="checkbox" id="c-37935199" checked=""/><div class="controls bullet"><span class="by">jddj</span><span>|</span><a href="#37935623">prev</a><span>|</span><a href="#37937904">next</a><span>|</span><label class="collapse" for="c-37935199">[-]</label><label class="expand" for="c-37935199">[13 more]</label></div><br/><div class="children"><div class="content">Ah. The great recoupling.<p>Soon someone will find a way to keep it in the same process.</div><br/><div id="37935522" class="c"><input type="checkbox" id="c-37935522" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#37935199">parent</a><span>|</span><a href="#37936447">next</a><span>|</span><label class="collapse" for="c-37935522">[-]</label><label class="expand" for="c-37935522">[2 more]</label></div><br/><div class="children"><div class="content">Hmm, it&#x27;s transparent data that&#x27;s passed to the callee.  Are you saying it&#x27;s more coupling because it&#x27;s not explicit in the gRPC schema?</div><br/><div id="37940137" class="c"><input type="checkbox" id="c-37940137" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#37935199">root</a><span>|</span><a href="#37935522">parent</a><span>|</span><a href="#37936447">next</a><span>|</span><label class="collapse" for="c-37940137">[-]</label><label class="expand" for="c-37940137">[1 more]</label></div><br/><div class="children"><div class="content">Exactly that. The beauty of gRPC (and similar) is that you can look at the schema and know exactly what the necessary inputs and outputs are. With this addition, you no longer have any idea.<p>What if you have a nested stack of calls where microservice A calls microservice B which calls ... etc. Then you&#x27;re looking at the schema of microservice F, and even the source code where it&#x27;s called in microservice E, and can&#x27;t figure out how to you can call it to get it to do the same thing. Little do you know, you need to set some things up that currently only A knows how to do.</div><br/></div></div></div></div><div id="37936447" class="c"><input type="checkbox" id="c-37936447" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#37935199">parent</a><span>|</span><a href="#37935522">prev</a><span>|</span><a href="#37935596">next</a><span>|</span><label class="collapse" for="c-37936447">[-]</label><label class="expand" for="c-37936447">[9 more]</label></div><br/><div class="children"><div class="content">Imo microservices should be a logical boundary only. Whether they&#x27;re in the same process&#x2F;server&#x2F;cluster etc ideally should be purely based on throughput&#x2F;latency&#x2F;scale concerns. Even more ideally the services should be dynamically shuffled around hosts based on load at runtime.</div><br/><div id="37939714" class="c"><input type="checkbox" id="c-37939714" checked=""/><div class="controls bullet"><span class="by">cmeiklejohn</span><span>|</span><a href="#37935199">root</a><span>|</span><a href="#37936447">parent</a><span>|</span><a href="#37936732">next</a><span>|</span><label class="collapse" for="c-37939714">[-]</label><label class="expand" for="c-37939714">[1 more]</label></div><br/><div class="children"><div class="content">Academics have tried to make this a reality for years.  I suggest revisiting Waldo&#x27;s &quot;A Note on Distributed Computing&quot; and working forwards from there.  If you want to go back further, look at Argus, Emerald, and the original Hermes (from DEC.)</div><br/></div></div><div id="37936732" class="c"><input type="checkbox" id="c-37936732" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#37935199">root</a><span>|</span><a href="#37936447">parent</a><span>|</span><a href="#37939714">prev</a><span>|</span><a href="#37936740">next</a><span>|</span><label class="collapse" for="c-37936732">[-]</label><label class="expand" for="c-37936732">[5 more]</label></div><br/><div class="children"><div class="content">Microservices are only used to scale engineering teams, not software. You can have a monolith that is still deployed in many different capacities or roles to get any optimization benefits. Microservices are needed because large groups aren&#x27;t good at working together on software without very rigid and well-defined boundaries.</div><br/><div id="37939647" class="c"><input type="checkbox" id="c-37939647" checked=""/><div class="controls bullet"><span class="by">cmeiklejohn</span><span>|</span><a href="#37935199">root</a><span>|</span><a href="#37936732">parent</a><span>|</span><a href="#37938187">next</a><span>|</span><label class="collapse" for="c-37939647">[-]</label><label class="expand" for="c-37939647">[1 more]</label></div><br/><div class="children"><div class="content">This is the correct answer.  Microservices are a software engineering optimization from the socio-technical perspective primarily.  100%.</div><br/></div></div><div id="37938187" class="c"><input type="checkbox" id="c-37938187" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37935199">root</a><span>|</span><a href="#37936732">parent</a><span>|</span><a href="#37939647">prev</a><span>|</span><a href="#37936740">next</a><span>|</span><label class="collapse" for="c-37938187">[-]</label><label class="expand" for="c-37938187">[3 more]</label></div><br/><div class="children"><div class="content">It would be nice to be able to make rigid and well-defined boundaries without having to add the overhead of serialization and network boundaries.</div><br/><div id="37939859" class="c"><input type="checkbox" id="c-37939859" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#37935199">root</a><span>|</span><a href="#37938187">parent</a><span>|</span><a href="#37939103">next</a><span>|</span><label class="collapse" for="c-37939859">[-]</label><label class="expand" for="c-37939859">[1 more]</label></div><br/><div class="children"><div class="content">&gt; well-defined boundaries without having to add the overhead of serialization and network boundaries<p>Type systems and APIs do that, but only within a single language.</div><br/></div></div><div id="37939103" class="c"><input type="checkbox" id="c-37939103" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#37935199">root</a><span>|</span><a href="#37938187">parent</a><span>|</span><a href="#37939859">prev</a><span>|</span><a href="#37936740">next</a><span>|</span><label class="collapse" for="c-37939103">[-]</label><label class="expand" for="c-37939103">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    public interface MyWellDefinedBoundary {
        ...
    }
</code></pre>
;)<p>Edit: I should say this is what OSGi was good for. Now it&#x27;s been replaced, its need is greater than ever.</div><br/></div></div></div></div></div></div><div id="37936740" class="c"><input type="checkbox" id="c-37936740" checked=""/><div class="controls bullet"><span class="by">ilyt</span><span>|</span><a href="#37935199">root</a><span>|</span><a href="#37936447">parent</a><span>|</span><a href="#37936732">prev</a><span>|</span><a href="#37935596">next</a><span>|</span><label class="collapse" for="c-37936740">[-]</label><label class="expand" for="c-37936740">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  Whether they&#x27;re in the same process&#x2F;server&#x2F;cluster etc ideally should be purely based on throughput&#x2F;latency&#x2F;scale concerns. Even more ideally the services should be dynamically shuffled around hosts based on load at runtime.<p>Think that&#x27;s called Erlang.<p>&gt; Imo microservices should be a logical boundary only.<p>Having option to split it freely is a costly abstraction to deal with, especially if it is cross-language.<p>I prefer to just leave &quot;cutting lines&quot; in monolith. Well defined modules and relations between them so if some feature needs to be spun off it&#x27;s not too hard.</div><br/><div id="37939688" class="c"><input type="checkbox" id="c-37939688" checked=""/><div class="controls bullet"><span class="by">cmeiklejohn</span><span>|</span><a href="#37935199">root</a><span>|</span><a href="#37936740">parent</a><span>|</span><a href="#37935596">next</a><span>|</span><label class="collapse" for="c-37939688">[-]</label><label class="expand" for="c-37939688">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Think that&#x27;s called Erlang.<p>No, it&#x27;s not.<p>As someone who programmed Erlang both professionally and published academically at Erlang venues for a long time, no.<p>These optimizations &quot;for runtime&quot; are not well supported by Erlang (i.e., cluster performance changes dramatically when behavioral characteristics of message passing switch from local to remote to remote cluster very quickly) and were long discussed in Waldo&#x27;s paper back in the 90s, dynamic relocation is not supported well (i.e., unless you use global, which falls apart quickly under network anomalies, of which I, and several others, wrote paper(s) about), and the runtime hardly provides any information on introspection on cluster performance.<p>Sadly, distributed Erlang had the edge on programming distributed systems almost 20 years before they became pervasive, but has since been left to atrophy and hasn&#x27;t seen any real innovation in quite a long time.</div><br/></div></div></div></div></div></div><div id="37935596" class="c"><input type="checkbox" id="c-37935596" checked=""/><div class="controls bullet"><span class="by">menzoic</span><span>|</span><a href="#37935199">parent</a><span>|</span><a href="#37936447">prev</a><span>|</span><a href="#37937904">next</a><span>|</span><label class="collapse" for="c-37935596">[-]</label><label class="expand" for="c-37935596">[1 more]</label></div><br/><div class="children"><div class="content">Coupling to context?</div><br/></div></div></div></div><div id="37937904" class="c"><input type="checkbox" id="c-37937904" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#37935199">prev</a><span>|</span><label class="collapse" for="c-37937904">[-]</label><label class="expand" for="c-37937904">[3 more]</label></div><br/><div class="children"><div class="content">I am blown away that people still use gRPC. It&#x27;s like finding somebody using CORBA or SOAP.</div><br/><div id="37939702" class="c"><input type="checkbox" id="c-37939702" checked=""/><div class="controls bullet"><span class="by">cmeiklejohn</span><span>|</span><a href="#37937904">parent</a><span>|</span><a href="#37938926">next</a><span>|</span><label class="collapse" for="c-37939702">[-]</label><label class="expand" for="c-37939702">[1 more]</label></div><br/><div class="children"><div class="content">This is a joke, right?  I appreciate a good joke.</div><br/></div></div><div id="37938926" class="c"><input type="checkbox" id="c-37938926" checked=""/><div class="controls bullet"><span class="by">danappelxx</span><span>|</span><a href="#37937904">parent</a><span>|</span><a href="#37939702">prev</a><span>|</span><label class="collapse" for="c-37938926">[-]</label><label class="expand" for="c-37938926">[1 more]</label></div><br/><div class="children"><div class="content">What do you use instead?</div><br/></div></div></div></div></div></div></div></div></div></body></html>