<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698742865399" as="style"/><link rel="stylesheet" href="styles.css?v=1698742865399"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://datenlord.github.io/xline-home/#/blog/2023-08-18-Introduction-to-CURP-Protocol">Introduction to CURP Protocol</a> <span class="domain">(<a href="https://datenlord.github.io">datenlord.github.io</a>)</span></div><div class="subtext"><span>SandmanDZ</span> | <span>14 comments</span></div><br/><div><div id="38077006" class="c"><input type="checkbox" id="c-38077006" checked=""/><div class="controls bullet"><span class="by">toomim</span><span>|</span><a href="#38076356">next</a><span>|</span><label class="collapse" for="c-38077006">[-]</label><label class="expand" for="c-38077006">[5 more]</label></div><br/><div class="children"><div class="content">Or you could just use a CRDT.<p>You don&#x27;t need PAXOS, RAFT, or CURP to implement a key-value store. Those are <i>distributed state machines</i>, all you need is <i>distributed state.</i><p>That means you don&#x27;t need a leader election. You don&#x27;t need a leader. You don&#x27;t need any round trips. You don&#x27;t need coordination.<p>PAXOS was the only game in town for many decades, but there are better ways to do this now.</div><br/><div id="38077701" class="c"><input type="checkbox" id="c-38077701" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#38077006">parent</a><span>|</span><a href="#38077062">next</a><span>|</span><label class="collapse" for="c-38077701">[-]</label><label class="expand" for="c-38077701">[1 more]</label></div><br/><div class="children"><div class="content">CRDTs are eventually consistent whereas Raft&#x2F;Paxos consensus enables strict consistency with high availability. If you don&#x27;t need strict consistency or you don&#x27;t need high availability, then yeah, you don&#x27;t need consensus.</div><br/></div></div><div id="38077062" class="c"><input type="checkbox" id="c-38077062" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#38077006">parent</a><span>|</span><a href="#38077701">prev</a><span>|</span><a href="#38076356">next</a><span>|</span><label class="collapse" for="c-38077062">[-]</label><label class="expand" for="c-38077062">[3 more]</label></div><br/><div class="children"><div class="content">CRDTs don’t magically solve the ordering problem, though they do solve a bunch of other problems around merge conflicts.</div><br/><div id="38080084" class="c"><input type="checkbox" id="c-38080084" checked=""/><div class="controls bullet"><span class="by">toomim</span><span>|</span><a href="#38077006">root</a><span>|</span><a href="#38077062">parent</a><span>|</span><a href="#38076356">next</a><span>|</span><label class="collapse" for="c-38080084">[-]</label><label class="expand" for="c-38080084">[2 more]</label></div><br/><div class="children"><div class="content">They completely solve the ordering problem of a key-value store as described in this article.<p>What they don&#x27;t do is give you a global linear ordering.  But you don&#x27;t need that in a key-value store, and you don&#x27;t need that in most distributed computing.<p>People keep reaching for PAXOS and RAFT when they don&#x27;t need it. It&#x27;s pretty rare that you need a distributed linearization.</div><br/><div id="38080788" class="c"><input type="checkbox" id="c-38080788" checked=""/><div class="controls bullet"><span class="by">enos_feedler</span><span>|</span><a href="#38077006">root</a><span>|</span><a href="#38080084">parent</a><span>|</span><a href="#38076356">next</a><span>|</span><label class="collapse" for="c-38080788">[-]</label><label class="expand" for="c-38080788">[1 more]</label></div><br/><div class="children"><div class="content">What are the rare cases where its generally the right choice? Just curious</div><br/></div></div></div></div></div></div></div></div><div id="38076356" class="c"><input type="checkbox" id="c-38076356" checked=""/><div class="controls bullet"><span class="by">carterschonwald</span><span>|</span><a href="#38077006">prev</a><span>|</span><a href="#38076967">next</a><span>|</span><label class="collapse" for="c-38076356">[-]</label><label class="expand" for="c-38076356">[4 more]</label></div><br/><div class="children"><div class="content">So this seems to be talking about consensus algorithms that have a fast path when a new transaction doesn’t conflict with in flight transactions and a slow path when there is a conflict.  I think this idea is very nicely explored&#x2F;articulated in the egalitarian paxos paper. Though perhaps there’s additional nuance im missing related to the semantics of the transactions in a kv store context</div><br/><div id="38079245" class="c"><input type="checkbox" id="c-38079245" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#38076356">parent</a><span>|</span><a href="#38079227">next</a><span>|</span><label class="collapse" for="c-38079245">[-]</label><label class="expand" for="c-38079245">[1 more]</label></div><br/><div class="children"><div class="content">It looks like the improvement of their protocol is that the client talks to all nodes immediately, rather than talking to the leader who then talks to the rest of the cluster. Depending on the location of the client relative to the rest of the cluster, that can be faster.</div><br/></div></div><div id="38076450" class="c"><input type="checkbox" id="c-38076450" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#38076356">parent</a><span>|</span><a href="#38079227">prev</a><span>|</span><a href="#38076967">next</a><span>|</span><label class="collapse" for="c-38076450">[-]</label><label class="expand" for="c-38076450">[1 more]</label></div><br/><div class="children"><div class="content">A difference seems to be that there still is a leader in this protocol whereas in epaxos there is not a (stable) leader.</div><br/></div></div></div></div><div id="38076643" class="c"><input type="checkbox" id="c-38076643" checked=""/><div class="controls bullet"><span class="by">eatonphil</span><span>|</span><a href="#38076967">prev</a><span>|</span><a href="#38076440">next</a><span>|</span><label class="collapse" for="c-38076643">[-]</label><label class="expand" for="c-38076643">[2 more]</label></div><br/><div class="children"><div class="content">Nice to have the TLA+ spec in the repo. Though it doesn&#x27;t have the details on leader election.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;xline-kv&#x2F;Xline&#x2F;blob&#x2F;master&#x2F;curp&#x2F;tla%2B&#x2F;curp.tla">https:&#x2F;&#x2F;github.com&#x2F;xline-kv&#x2F;Xline&#x2F;blob&#x2F;master&#x2F;curp&#x2F;tla%2B&#x2F;cu...</a></div><br/><div id="38077562" class="c"><input type="checkbox" id="c-38077562" checked=""/><div class="controls bullet"><span class="by">thamer</span><span>|</span><a href="#38076643">parent</a><span>|</span><a href="#38076440">next</a><span>|</span><label class="collapse" for="c-38077562">[-]</label><label class="expand" for="c-38077562">[1 more]</label></div><br/><div class="children"><div class="content">For those interested in this sort of thing, see also Raft&#x27;s TLA+ specification: <a href="https:&#x2F;&#x2F;github.com&#x2F;ongardie&#x2F;raft.tla">https:&#x2F;&#x2F;github.com&#x2F;ongardie&#x2F;raft.tla</a></div><br/></div></div></div></div><div id="38076440" class="c"><input type="checkbox" id="c-38076440" checked=""/><div class="controls bullet"><span class="by">sargun</span><span>|</span><a href="#38076643">prev</a><span>|</span><label class="collapse" for="c-38076440">[-]</label><label class="expand" for="c-38076440">[1 more]</label></div><br/><div class="children"><div class="content">So, I don&#x27;t think that this optimization is new (fast path for commutative operations), but it&#x27;s very difficult to get correct AFAICT, because in order to garner full optimizations, you must know about the invariants being preserved. For example, adds can always be non-conflicting for a bank account, if say, the invariant is that a bank account balance must never go below 0, but withdrawals need global consensus.<p>The earliest knowledge I have of this is Generalized Paxos, but I believe there&#x27;s more recent work with the likes of Egalatarian Paxos. I think there were even some CRDTs that mixed strong consistency and weak consistency.</div><br/></div></div></div></div></div></div></div></body></html>