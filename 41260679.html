<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723798872370" as="style"/><link rel="stylesheet" href="styles.css?v=1723798872370"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/Wren6991/PicoDVI/commit/ca941baf37e3f04738b8e641896d85feb3430385">RP2350 PicoDVI Preview</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>fidotron</span> | <span>47 comments</span></div><br/><div><div id="41261173" class="c"><input type="checkbox" id="c-41261173" checked=""/><div class="controls bullet"><span class="by">typeiierror</span><span>|</span><a href="#41261366">next</a><span>|</span><label class="collapse" for="c-41261173">[-]</label><label class="expand" for="c-41261173">[6 more]</label></div><br/><div class="children"><div class="content">The new HSTX interface on the RP2350 seems to be squarely targeted at this use case (video output) and doesn&#x27;t require the use of PIO or consuming a ton of CPU cycles. There&#x27;s a nice write up on the capability here: <a href="https:&#x2F;&#x2F;www.cnx-software.com&#x2F;2024&#x2F;08&#x2F;15&#x2F;raspberry-pi-rp2350-hstx-high-speed-serial-transmit-interface&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cnx-software.com&#x2F;2024&#x2F;08&#x2F;15&#x2F;raspberry-pi-rp2350-...</a></div><br/><div id="41261368" class="c"><input type="checkbox" id="c-41261368" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#41261173">parent</a><span>|</span><a href="#41261897">next</a><span>|</span><label class="collapse" for="c-41261368">[-]</label><label class="expand" for="c-41261368">[1 more]</label></div><br/><div class="children"><div class="content">The main advantage of the SIO TMDS encoder, is that it allows you to output TMDS on any GPIO, instead of the eight that the HSTX is restricted to.<p>And they allow an easy upgrade path for projects that were already bit-banging DVI on the rp2040. Other than those two advantages, I don&#x27;t think there is any advantage to the SIO TMDS encoder over the HSTX TMDS encoder.<p>I get the impression that the SIO TMDS encoder was added to the design first, and there wasn&#x27;t a good reason to remove them after the introduction of HSTX.</div><br/></div></div><div id="41261897" class="c"><input type="checkbox" id="c-41261897" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41261173">parent</a><span>|</span><a href="#41261368">prev</a><span>|</span><a href="#41261366">next</a><span>|</span><label class="collapse" for="c-41261897">[-]</label><label class="expand" for="c-41261897">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t hstx mainly good for streaming out? My naive guess would be that it wouldn&#x27;t have as much transceiver offload capabilities, like what the SIO I naively guess would be good for.<p>The nice part about using SIO seems to be that you can do the tdms encoding there. With hstx you need the output bitstream in the right format already which seems like you might be back to needing the CPU to do the encoding.</div><br/><div id="41262264" class="c"><input type="checkbox" id="c-41262264" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#41261173">root</a><span>|</span><a href="#41261897">parent</a><span>|</span><a href="#41261366">next</a><span>|</span><label class="collapse" for="c-41262264">[-]</label><label class="expand" for="c-41262264">[3 more]</label></div><br/><div class="children"><div class="content">HSTX has a built in TMDS encoder, and as far as I can tell, it has all the functionality of the SIO TMDS encoder.<p>You can configure it to directly consume any line buffer with any pixel format, from 1 to 8 bits per color channel. It even supports formats with different numbers of bits per channel like 8-bit RGB322 and 16-bit RGB565.</div><br/><div id="41262950" class="c"><input type="checkbox" id="c-41262950" checked=""/><div class="controls bullet"><span class="by">onetom</span><span>|</span><a href="#41261173">root</a><span>|</span><a href="#41262264">parent</a><span>|</span><a href="#41261366">next</a><span>|</span><label class="collapse" for="c-41262950">[-]</label><label class="expand" for="c-41262950">[2 more]</label></div><br/><div class="children"><div class="content">what&#x27;s the fun in that though?<p>i have the impression, that the main motivation for this project was learning the intricacies of TMDS encoding and providing an open implementation as reference for other ppl, who want to learn too.<p>there are too many black box electronics these days, so it&#x27;s very much welcome to virtually open them up, by providing software equivalents of their operation.</div><br/><div id="41263870" class="c"><input type="checkbox" id="c-41263870" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#41261173">root</a><span>|</span><a href="#41262950">parent</a><span>|</span><a href="#41261366">next</a><span>|</span><label class="collapse" for="c-41263870">[-]</label><label class="expand" for="c-41263870">[1 more]</label></div><br/><div class="children"><div class="content">Fun is to proceed to the next fun faster</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41261366" class="c"><input type="checkbox" id="c-41261366" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41261173">prev</a><span>|</span><a href="#41261844">next</a><span>|</span><label class="collapse" for="c-41261366">[-]</label><label class="expand" for="c-41261366">[3 more]</label></div><br/><div class="children"><div class="content">This is amazing, not only did they port from the 2040 to the 2350, but they also ported all the functionality they could support over to the RV32 cores as well. PicoDVI is usable no matter what cores one chooses to use on the RP2350. Well done!</div><br/><div id="41261458" class="c"><input type="checkbox" id="c-41261458" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41261366">parent</a><span>|</span><a href="#41261844">next</a><span>|</span><label class="collapse" for="c-41261458">[-]</label><label class="expand" for="c-41261458">[2 more]</label></div><br/><div class="children"><div class="content">The author is also the creator of the RISC-V core found in the RP2350, you don&#x27;t get your own core design taped out as an ASIC and then not show it off :p<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Wren6991&#x2F;Hazard3">https:&#x2F;&#x2F;github.com&#x2F;Wren6991&#x2F;Hazard3</a></div><br/><div id="41262821" class="c"><input type="checkbox" id="c-41262821" checked=""/><div class="controls bullet"><span class="by">jakobson14</span><span>|</span><a href="#41261366">root</a><span>|</span><a href="#41261458">parent</a><span>|</span><a href="#41261844">next</a><span>|</span><label class="collapse" for="c-41262821">[-]</label><label class="expand" for="c-41262821">[1 more]</label></div><br/><div class="children"><div class="content">Guy is an employee of raspi, so of course he&#x27;s going to write code that ships chips.</div><br/></div></div></div></div></div></div><div id="41261844" class="c"><input type="checkbox" id="c-41261844" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#41261366">prev</a><span>|</span><a href="#41263833">next</a><span>|</span><label class="collapse" for="c-41261844">[-]</label><label class="expand" for="c-41261844">[1 more]</label></div><br/><div class="children"><div class="content">In case anyone missed the blog post about the Raspberry Pi Pico 2, here it is:<p><a href="https:&#x2F;&#x2F;www.raspberrypi.com&#x2F;news&#x2F;raspberry-pi-pico-2-our-new-5-microcontroller-board-on-sale-now&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.raspberrypi.com&#x2F;news&#x2F;raspberry-pi-pico-2-our-new...</a><p>It has quite a list of products already created by their partners.</div><br/></div></div><div id="41263833" class="c"><input type="checkbox" id="c-41263833" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41261844">prev</a><span>|</span><a href="#41263316">next</a><span>|</span><label class="collapse" for="c-41263833">[-]</label><label class="expand" for="c-41263833">[3 more]</label></div><br/><div class="children"><div class="content">Is there any way to select between two HDMI signals?<p>I have an nVidia Jetson but its boot sequence turns off the HDMI output at some point. It would be nice if I could show a placeholder screen while the Jetson is booting. Would something like that be possible by using this RP2350 board?</div><br/><div id="41263880" class="c"><input type="checkbox" id="c-41263880" checked=""/><div class="controls bullet"><span class="by">ale42</span><span>|</span><a href="#41263833">parent</a><span>|</span><a href="#41264432">next</a><span>|</span><label class="collapse" for="c-41263880">[-]</label><label class="expand" for="c-41263880">[1 more]</label></div><br/><div class="children"><div class="content">Not directly because it can&#x27;t handle retransmitting the existing HDMI signal. You probably need to add a HDMI&#x2F;DVI switch IC like this one: <a href="https:&#x2F;&#x2F;www.analog.com&#x2F;en&#x2F;products&#x2F;ad8196.html" rel="nofollow">https:&#x2F;&#x2F;www.analog.com&#x2F;en&#x2F;products&#x2F;ad8196.html</a></div><br/></div></div><div id="41264432" class="c"><input type="checkbox" id="c-41264432" checked=""/><div class="controls bullet"><span class="by">dezgeg</span><span>|</span><a href="#41263833">parent</a><span>|</span><a href="#41263880">prev</a><span>|</span><a href="#41263316">next</a><span>|</span><label class="collapse" for="c-41264432">[-]</label><label class="expand" for="c-41264432">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be surprised if that was not fixable in the Jetson with pure software changes.</div><br/></div></div></div></div><div id="41263316" class="c"><input type="checkbox" id="c-41263316" checked=""/><div class="controls bullet"><span class="by">peterburkimsher</span><span>|</span><a href="#41263833">prev</a><span>|</span><a href="#41261409">next</a><span>|</span><label class="collapse" for="c-41263316">[-]</label><label class="expand" for="c-41263316">[1 more]</label></div><br/><div class="children"><div class="content">If anyone wants a PicoDVI sock or 4, I had 5 PCBs manufactured and am only using one.<p>I wanted to put the HDMI connector onto the PCB itself, so I could avoid soldering the very small pin pitch. So I took some measurements and did my first KiCad project!<p><a href="https:&#x2F;&#x2F;forum.kicad.info&#x2F;t&#x2F;hdmi-pcb-edge-connector&#x2F;48358&#x2F;9" rel="nofollow">https:&#x2F;&#x2F;forum.kicad.info&#x2F;t&#x2F;hdmi-pcb-edge-connector&#x2F;48358&#x2F;9</a><p>Just send me an email if you&#x27;re interested in having one, and I&#x27;d be happy to post it to you. The resistors are already populated, too, you just need to solder on the Pico using the through-hole connections.</div><br/></div></div><div id="41261409" class="c"><input type="checkbox" id="c-41261409" checked=""/><div class="controls bullet"><span class="by">transpute</span><span>|</span><a href="#41263316">prev</a><span>|</span><a href="#41260972">next</a><span>|</span><label class="collapse" for="c-41261409">[-]</label><label class="expand" for="c-41261409">[13 more]</label></div><br/><div class="children"><div class="content">Is it theoretically possible to have 2-way HID (keyboard, mouse) and 1-way video output on a single USB-c cable? It would simplify connection to a KVM or software-emulated display&#x2F;keyboard&#x2F;mouse. Low FPS would be enough for dashboards and CLI.</div><br/><div id="41264485" class="c"><input type="checkbox" id="c-41264485" checked=""/><div class="controls bullet"><span class="by">u8080</span><span>|</span><a href="#41261409">parent</a><span>|</span><a href="#41263660">next</a><span>|</span><label class="collapse" for="c-41264485">[-]</label><label class="expand" for="c-41264485">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this theoretically could be done using DP Alt-mode for type-c. It allows up to 4 lanes(commonly 2 lanes) DP signal over typically USB3 assigned lanes. USB2 data lanes are still functional in this mode. 
<a href="https:&#x2F;&#x2F;newnex.com&#x2F;technology-articles-dp-alt-mode-over-usb-c.php" rel="nofollow">https:&#x2F;&#x2F;newnex.com&#x2F;technology-articles-dp-alt-mode-over-usb-...</a></div><br/></div></div><div id="41263660" class="c"><input type="checkbox" id="c-41263660" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#41261409">parent</a><span>|</span><a href="#41264485">prev</a><span>|</span><a href="#41263704">next</a><span>|</span><label class="collapse" for="c-41263660">[-]</label><label class="expand" for="c-41263660">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you can do it direcly.<p>I recently found the Openterface Mini-KVM [1], which is supposed to allow you plug it into your laptop over USB-C, and some arbitrary system with USB+HDMI. Then, using their host software, view the HDMI display output and send mouse and keyboard inputs with ease.<p>I haven&#x27;t tried it, so I can&#x27;t speak to how well it works, but it sounds promising.<p>It is a crowdfunded project, so the usual caveats apply<p>[1] <a href="https:&#x2F;&#x2F;openterface.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;openterface.com&#x2F;</a></div><br/><div id="41263916" class="c"><input type="checkbox" id="c-41263916" checked=""/><div class="controls bullet"><span class="by">transpute</span><span>|</span><a href="#41261409">root</a><span>|</span><a href="#41263660">parent</a><span>|</span><a href="#41263704">next</a><span>|</span><label class="collapse" for="c-41263916">[-]</label><label class="expand" for="c-41263916">[1 more]</label></div><br/><div class="children"><div class="content">This thread has gone from:<p><pre><code>  could exist?
   not possible
    specs imply yes?
     exists as open hw&#x2F;sw
</code></pre>
Thanks so much for the pointer! <a href="https:&#x2F;&#x2F;www.crowdsupply.com&#x2F;techxartisan&#x2F;openterface-mini-kvm" rel="nofollow">https:&#x2F;&#x2F;www.crowdsupply.com&#x2F;techxartisan&#x2F;openterface-mini-kv...</a><p><i>&gt; KVM-over-USB .. macOS, Windows, and Linux [clients], with Android support in development.. 
HDMI and emulated keyboard&#x2F;mouse (HID) input..  video up to 1920x1080@30Hz with under 140ms latency.. play target device&#x27;s audio directly on the host computer.. [send text] from the host to the target device, ideal for copying usernames, passwords.. Switchable USB-A Port.. for transferring files.. or sharing other USB devices.</i><p>With USB storage emulation, this approaches BMC remote mgmt, minus network attack surface.</div><br/></div></div></div></div><div id="41263704" class="c"><input type="checkbox" id="c-41263704" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#41261409">parent</a><span>|</span><a href="#41263660">prev</a><span>|</span><a href="#41261932">next</a><span>|</span><label class="collapse" for="c-41263704">[-]</label><label class="expand" for="c-41263704">[1 more]</label></div><br/><div class="children"><div class="content">You can get the RP2XX0 PIO to control an extra USB host port. I&#x27;ve been keeping tabs on RP2040 resources: <a href="https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;hw&#x2F;rp2040" rel="nofollow">https:&#x2F;&#x2F;taoofmac.com&#x2F;space&#x2F;hw&#x2F;rp2040</a></div><br/></div></div><div id="41262840" class="c"><input type="checkbox" id="c-41262840" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#41261409">parent</a><span>|</span><a href="#41261932">prev</a><span>|</span><a href="#41261926">next</a><span>|</span><label class="collapse" for="c-41262840">[-]</label><label class="expand" for="c-41262840">[1 more]</label></div><br/><div class="children"><div class="content">Can someone explain the downvotes?</div><br/></div></div><div id="41261926" class="c"><input type="checkbox" id="c-41261926" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41261409">parent</a><span>|</span><a href="#41262840">prev</a><span>|</span><a href="#41260972">next</a><span>|</span><label class="collapse" for="c-41261926">[-]</label><label class="expand" for="c-41261926">[6 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no current specs for dual directional USB over any cable, afaik. There very well should be.<p>You could present as a device and offer networking and have usb-ip advertised over multicast on that port. Easy, weekend project at most, would be dead obvious to any practitioner.<p>USB4 as a packetized protocol really should offer something. I do wish there were like a half speed 2.5Gbit usb4 option, that microcontrollers could have some hope of accelerated bit banging.</div><br/><div id="41262871" class="c"><input type="checkbox" id="c-41262871" checked=""/><div class="controls bullet"><span class="by">transpute</span><span>|</span><a href="#41261409">root</a><span>|</span><a href="#41261926">parent</a><span>|</span><a href="#41262004">next</a><span>|</span><label class="collapse" for="c-41262871">[-]</label><label class="expand" for="c-41262871">[1 more]</label></div><br/><div class="children"><div class="content">According to Wikipedia, DisplayPort 2.0+ can coexist with USB data on the same cable, <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DisplayPort" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DisplayPort</a><p>[2.0] .. using only two lanes on the USB-C connector via DP Alt Mode to allow for simultaneous SuperSpeed USB data and video<p>[2.1] .. tightened its alignment with the USB Type-C specification as well as the USB4 PHY specification to facilitate a common PHY servicing both DisplayPort and USB4. In addition, DisplayPort 2.1 has added a new DisplayPort bandwidth management feature to enable DisplayPort tunnelling to coexist with other I&#x2F;O data traffic more efficiently over the USB4 link.</div><br/></div></div><div id="41262004" class="c"><input type="checkbox" id="c-41262004" checked=""/><div class="controls bullet"><span class="by">FlyingAvatar</span><span>|</span><a href="#41261409">root</a><span>|</span><a href="#41261926">parent</a><span>|</span><a href="#41262871">prev</a><span>|</span><a href="#41262566">next</a><span>|</span><label class="collapse" for="c-41262004">[-]</label><label class="expand" for="c-41262004">[2 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t USB hubs done this since USB 1.1?</div><br/><div id="41263641" class="c"><input type="checkbox" id="c-41263641" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#41261409">root</a><span>|</span><a href="#41262004">parent</a><span>|</span><a href="#41262566">next</a><span>|</span><label class="collapse" for="c-41263641">[-]</label><label class="expand" for="c-41263641">[1 more]</label></div><br/><div class="children"><div class="content">I believe that the author is talking about plugging in a USB-C cable between your laptop and some headless system, and having your laptop send HID data, while also capturing a display output from the headless system</div><br/></div></div></div></div><div id="41262566" class="c"><input type="checkbox" id="c-41262566" checked=""/><div class="controls bullet"><span class="by">BenjiWiebe</span><span>|</span><a href="#41261409">root</a><span>|</span><a href="#41261926">parent</a><span>|</span><a href="#41262004">prev</a><span>|</span><a href="#41260972">next</a><span>|</span><label class="collapse" for="c-41262566">[-]</label><label class="expand" for="c-41262566">[2 more]</label></div><br/><div class="children"><div class="content">Afaik this is 100% allowed by the spec. Flash drives are bidirectional (in and out). Hubs present multiple devices to the host through one cable.<p>IDK why it isn&#x27;t done more often in one device though.</div><br/><div id="41262896" class="c"><input type="checkbox" id="c-41262896" checked=""/><div class="controls bullet"><span class="by">transpute</span><span>|</span><a href="#41261409">root</a><span>|</span><a href="#41262566">parent</a><span>|</span><a href="#41260972">next</a><span>|</span><label class="collapse" for="c-41262896">[-]</label><label class="expand" for="c-41262896">[1 more]</label></div><br/><div class="children"><div class="content">Looks like Belkin has a USB-C cable for VR headsets, which breaks out to DisplayPort (video) and USB-A (data) connectors, <a href="https:&#x2F;&#x2F;www.belkin.com&#x2F;support-article&#x2F;?articleNum=316883" rel="nofollow">https:&#x2F;&#x2F;www.belkin.com&#x2F;support-article&#x2F;?articleNum=316883</a></div><br/></div></div></div></div></div></div></div></div><div id="41260972" class="c"><input type="checkbox" id="c-41260972" checked=""/><div class="controls bullet"><span class="by">tony-allan</span><span>|</span><a href="#41261409">prev</a><span>|</span><a href="#41261254">next</a><span>|</span><label class="collapse" for="c-41260972">[-]</label><label class="expand" for="c-41260972">[1 more]</label></div><br/><div class="children"><div class="content">The RP2040 discussion -- <a href="https:&#x2F;&#x2F;github.com&#x2F;Wren6991&#x2F;PicoDVI">https:&#x2F;&#x2F;github.com&#x2F;Wren6991&#x2F;PicoDVI</a></div><br/></div></div><div id="41261254" class="c"><input type="checkbox" id="c-41261254" checked=""/><div class="controls bullet"><span class="by">Palomides</span><span>|</span><a href="#41260972">prev</a><span>|</span><a href="#41261329">next</a><span>|</span><label class="collapse" for="c-41261254">[-]</label><label class="expand" for="c-41261254">[9 more]</label></div><br/><div class="children"><div class="content">can the RP2350 do a higher resolution? it would be a neat option for some retrocomputing stuff if so</div><br/><div id="41261634" class="c"><input type="checkbox" id="c-41261634" checked=""/><div class="controls bullet"><span class="by">raphlinus</span><span>|</span><a href="#41261254">parent</a><span>|</span><a href="#41261748">next</a><span>|</span><label class="collapse" for="c-41261634">[-]</label><label class="expand" for="c-41261634">[3 more]</label></div><br/><div class="children"><div class="content">My understanding is that the HSTX can do twice the bit clock as the frequency of the CPU, as opposed to 1x for RP2040. So 800x480 (60Hz) is possible with no overclocking (295MHz bit clock) and Luke said [1] he got 1280x720 50Hz with overclocking (530MHz using CVT-R according to the video timings calculator [2]).<p>[1]: <a href="https:&#x2F;&#x2F;mastodon.online&#x2F;@wren6991@types.pl&#x2F;112928551221457525" rel="nofollow">https:&#x2F;&#x2F;mastodon.online&#x2F;@wren6991@types.pl&#x2F;11292855122145752...</a><p>[2]: <a href="https:&#x2F;&#x2F;tomverbeure.github.io&#x2F;video_timings_calculator" rel="nofollow">https:&#x2F;&#x2F;tomverbeure.github.io&#x2F;video_timings_calculator</a></div><br/><div id="41261935" class="c"><input type="checkbox" id="c-41261935" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41261254">root</a><span>|</span><a href="#41261634">parent</a><span>|</span><a href="#41261748">next</a><span>|</span><label class="collapse" for="c-41261935">[-]</label><label class="expand" for="c-41261935">[2 more]</label></div><br/><div class="children"><div class="content">I wonder what res&#x2F;refresh Display Stream Compression (DSC) would bring this up to, if this were DisplayPort (instead of DVI)?</div><br/><div id="41263088" class="c"><input type="checkbox" id="c-41263088" checked=""/><div class="controls bullet"><span class="by">tverbeure</span><span>|</span><a href="#41261254">root</a><span>|</span><a href="#41261935">parent</a><span>|</span><a href="#41261748">next</a><span>|</span><label class="collapse" for="c-41263088">[-]</label><label class="expand" for="c-41263088">[1 more]</label></div><br/><div class="children"><div class="content">The lowest you can go with DSC 1.2 is 8 bits per pixel.</div><br/></div></div></div></div></div></div><div id="41261748" class="c"><input type="checkbox" id="c-41261748" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#41261254">parent</a><span>|</span><a href="#41261634">prev</a><span>|</span><a href="#41261887">next</a><span>|</span><label class="collapse" for="c-41261748">[-]</label><label class="expand" for="c-41261748">[4 more]</label></div><br/><div class="children"><div class="content">Probably.<p>Especially with the HSTX block which can apparently output at double the system clock (while the rp2040 was limited to 1&#x2F;10th of the system)<p>If my rough math is correct, it should be possible to do output 720p 60hz video with an overclock to ~320Mhz. Though, actually generating that many pixels might be hard when you have nowhere near enough memory.<p>I would love to see some solid infomation about how well the rp2350 overclocks, apparently 300mhz is easy. 60hz 1080p is almost certainly out of reach, it would require something like a 700mhz overclock, but 30hz 1080p is probably viable.</div><br/><div id="41261888" class="c"><input type="checkbox" id="c-41261888" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41261254">root</a><span>|</span><a href="#41261748">parent</a><span>|</span><a href="#41263747">next</a><span>|</span><label class="collapse" for="c-41261888">[-]</label><label class="expand" for="c-41261888">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Though, actually generating that many pixels might be hard when you have nowhere near enough memory.<p>Even if you don&#x27;t have enough memory or CPU time to render true 720p, it&#x27;s nice to be able to output 360p or 240p inside a 720p container with each pixel and line duplicated two or three times. Doing it that way gives you nice crisp pixels rather than the blurry mess the displays internal upscaler would probably produce. You can even insert blank lines to get a faux-CRT-scanline effect.</div><br/><div id="41262232" class="c"><input type="checkbox" id="c-41262232" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#41261254">root</a><span>|</span><a href="#41261888">parent</a><span>|</span><a href="#41263747">next</a><span>|</span><label class="collapse" for="c-41262232">[-]</label><label class="expand" for="c-41262232">[1 more]</label></div><br/><div class="children"><div class="content">And HSTX is actually pretty flexible. Nowhere near as flexible as PIO, but it can repeat pixels by itself (though, it uses the shift, so you can either pack multiple pixels per 32-bit word, or repeat pixels, not both).<p>Scanline doubling&#x2F;tripping and blank line inserting can be done with nothing more than DMA chaining.</div><br/></div></div></div></div><div id="41263747" class="c"><input type="checkbox" id="c-41263747" checked=""/><div class="controls bullet"><span class="by">vardump</span><span>|</span><a href="#41261254">root</a><span>|</span><a href="#41261748">parent</a><span>|</span><a href="#41261888">prev</a><span>|</span><a href="#41261887">next</a><span>|</span><label class="collapse" for="c-41263747">[-]</label><label class="expand" for="c-41263747">[1 more]</label></div><br/><div class="children"><div class="content">&gt; while the rp2040 was limited to 1&#x2F;10th of the system<p>Isn&#x27;t RP2040 capable of outputting at system clock rate?</div><br/></div></div></div></div><div id="41261887" class="c"><input type="checkbox" id="c-41261887" checked=""/><div class="controls bullet"><span class="by">ironhaven</span><span>|</span><a href="#41261254">parent</a><span>|</span><a href="#41261748">prev</a><span>|</span><a href="#41261329">next</a><span>|</span><label class="collapse" for="c-41261887">[-]</label><label class="expand" for="c-41261887">[1 more]</label></div><br/><div class="children"><div class="content">What kind of retro computing are you doing that would work well with high definition (720p). Standard definition I believe only started to be limited around 2007 when Xbox games like Dead Rising had captions that where too small to be legible on SD tvs</div><br/></div></div></div></div><div id="41261329" class="c"><input type="checkbox" id="c-41261329" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41261254">prev</a><span>|</span><a href="#41261734">next</a><span>|</span><label class="collapse" for="c-41261329">[-]</label><label class="expand" for="c-41261329">[2 more]</label></div><br/><div class="children"><div class="content">I think a link to the repo instead of the change set might be better.</div><br/><div id="41261510" class="c"><input type="checkbox" id="c-41261510" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41261329">parent</a><span>|</span><a href="#41261734">next</a><span>|</span><label class="collapse" for="c-41261510">[-]</label><label class="expand" for="c-41261510">[1 more]</label></div><br/><div class="children"><div class="content">I had no idea what this was, ended up clicking around to the README, and found it quite the enjoyable read.</div><br/></div></div></div></div><div id="41261734" class="c"><input type="checkbox" id="c-41261734" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#41261329">prev</a><span>|</span><a href="#41261466">next</a><span>|</span><label class="collapse" for="c-41261734">[-]</label><label class="expand" for="c-41261734">[6 more]</label></div><br/><div class="children"><div class="content">I wish the RP2350 would include a fuse to disable for good the ARM cores for those who want only the risc-v cores (and maybe not pay ARM royalties on those chips).</div><br/><div id="41261789" class="c"><input type="checkbox" id="c-41261789" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41261734">parent</a><span>|</span><a href="#41262496">next</a><span>|</span><label class="collapse" for="c-41261789">[-]</label><label class="expand" for="c-41261789">[4 more]</label></div><br/><div class="children"><div class="content">See pg.1259 in the datasheet, the ARM_DISABLE fuse does exactly that. Putting that in was a smart move because it means they can always make a RISC-V-only variant of the chip without having to tape out new silicon - they just have to blow that fuse at the factory.</div><br/><div id="41262483" class="c"><input type="checkbox" id="c-41262483" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#41261734">root</a><span>|</span><a href="#41261789">parent</a><span>|</span><a href="#41262496">next</a><span>|</span><label class="collapse" for="c-41262483">[-]</label><label class="expand" for="c-41262483">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure &quot;arm-core-disabled-by-fuse&quot; is gonna be sufficient to persuade arms legal department to stop charging royalties...</div><br/><div id="41262627" class="c"><input type="checkbox" id="c-41262627" checked=""/><div class="controls bullet"><span class="by">axoltl</span><span>|</span><a href="#41261734">root</a><span>|</span><a href="#41262483">parent</a><span>|</span><a href="#41262496">next</a><span>|</span><label class="collapse" for="c-41262627">[-]</label><label class="expand" for="c-41262627">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually a super common way to handle licensing in hard IP. You don&#x27;t want to spin different revisions of a chip with and without the IP, that&#x27;s expensive. So you build in fuses to permanently disable the IP. This happens a lot with hardware video encoder&#x2F;decoder blocks.</div><br/><div id="41263921" class="c"><input type="checkbox" id="c-41263921" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#41261734">root</a><span>|</span><a href="#41262627">parent</a><span>|</span><a href="#41262496">next</a><span>|</span><label class="collapse" for="c-41263921">[-]</label><label class="expand" for="c-41263921">[1 more]</label></div><br/><div class="children"><div class="content">Or you do it the other way around in software - remember the Pi 1&#x2F;2 era where you had to buy separate licenses for MPEG&#x2F;h264 HW decoders, tied to the Pi&#x27;s serial number?</div><br/></div></div></div></div></div></div></div></div><div id="41262496" class="c"><input type="checkbox" id="c-41262496" checked=""/><div class="controls bullet"><span class="by">TaylorAlexander</span><span>|</span><a href="#41261734">parent</a><span>|</span><a href="#41261789">prev</a><span>|</span><a href="#41261466">next</a><span>|</span><label class="collapse" for="c-41262496">[-]</label><label class="expand" for="c-41262496">[1 more]</label></div><br/><div class="children"><div class="content">One imagines that at some point they will release a pure risc-v chip, once community adoption of the new RP2350 cores is widespread.</div><br/></div></div></div></div><div id="41261466" class="c"><input type="checkbox" id="c-41261466" checked=""/><div class="controls bullet"><span class="by">wrycoder</span><span>|</span><a href="#41261734">prev</a><span>|</span><label class="collapse" for="c-41261466">[-]</label><label class="expand" for="c-41261466">[1 more]</label></div><br/><div class="children"><div class="content"><i>Bitbanged DVI on the RP2040 Microcontroller</i></div><br/></div></div></div></div></div></div></div></body></html>