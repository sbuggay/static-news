<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730710881540" as="style"/><link rel="stylesheet" href="styles.css?v=1730710881540"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/Gandalf-/coreutils">Unix core utilities implemented in Haskell</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>ocean_moist</span> | <span>85 comments</span></div><br/><div><div id="42033718" class="c"><input type="checkbox" id="c-42033718" checked=""/><div class="controls bullet"><span class="by">Maro</span><span>|</span><a href="#42032718">next</a><span>|</span><label class="collapse" for="c-42033718">[-]</label><label class="expand" for="c-42033718">[29 more]</label></div><br/><div class="children"><div class="content">I looked at the wc implementation, there&#x27;s no way it&#x27;s compatible with the GNU tools, how it handles wide characters, which is heavily ties to the idiosyncratic C implementation. I know because I once wrote a wc implementation in modern C++ for my own education, and that&#x27;s where most of my time and code complexity went. Also, the C versions are devilishly fast, with all flags, with optimized code branches.<p><a href="https:&#x2F;&#x2F;bytepawn.com&#x2F;tag&#x2F;wc.html" rel="nofollow">https:&#x2F;&#x2F;bytepawn.com&#x2F;tag&#x2F;wc.html</a></div><br/><div id="42033961" class="c"><input type="checkbox" id="c-42033961" checked=""/><div class="controls bullet"><span class="by">anardil</span><span>|</span><a href="#42033718">parent</a><span>|</span><a href="#42034143">next</a><span>|</span><label class="collapse" for="c-42033961">[-]</label><label class="expand" for="c-42033961">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right! Data.ByteString.Lazy is Word8 under the covers, so wide characters are truncated. tr takes a similar short cut. Swapping to Data.Text would fix that.<p>Where simplicity conflicted with compatibility, I&#x27;ve chosen the former so far. Targeting the BSD options and behavior is another example of that. The primary goal is to feel out the data flow for each utility, rather than dig into all the edges.</div><br/></div></div><div id="42034143" class="c"><input type="checkbox" id="c-42034143" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42033718">parent</a><span>|</span><a href="#42033961">prev</a><span>|</span><a href="#42033759">next</a><span>|</span><label class="collapse" for="c-42034143">[-]</label><label class="expand" for="c-42034143">[2 more]</label></div><br/><div class="children"><div class="content">Speaking of fast: <a href="https:&#x2F;&#x2F;redman.xyz&#x2F;git&#x2F;turbowc&#x2F;tree&#x2F;turbowc.c" rel="nofollow">https:&#x2F;&#x2F;redman.xyz&#x2F;git&#x2F;turbowc&#x2F;tree&#x2F;turbowc.c</a> seems to be really fast (it is not a replacement for wc, however).</div><br/><div id="42039756" class="c"><input type="checkbox" id="c-42039756" checked=""/><div class="controls bullet"><span class="by">stabbles</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42034143">parent</a><span>|</span><a href="#42033759">next</a><span>|</span><label class="collapse" for="c-42039756">[-]</label><label class="expand" for="c-42039756">[1 more]</label></div><br/><div class="children"><div class="content">AVX2 is pretty much ubiquitous, the implementation above is only SSE2.<p>I wrote a blog post with the main AVX2 tricks [1]<p>[1] <a href="https:&#x2F;&#x2F;stoppels.ch&#x2F;2022&#x2F;11&#x2F;30&#x2F;io-is-no-longer-the-bottleneck-part-2.html" rel="nofollow">https:&#x2F;&#x2F;stoppels.ch&#x2F;2022&#x2F;11&#x2F;30&#x2F;io-is-no-longer-the-bottlenec...</a></div><br/></div></div></div></div><div id="42033759" class="c"><input type="checkbox" id="c-42033759" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42033718">parent</a><span>|</span><a href="#42034143">prev</a><span>|</span><a href="#42034288">next</a><span>|</span><label class="collapse" for="c-42033759">[-]</label><label class="expand" for="c-42033759">[24 more]</label></div><br/><div class="children"><div class="content">Poking at the rust coreutils project it seems like they all faster than the c versions. The issue is the decades of features that have accumulated that someone somewhere uses but seem safe to disregard because so few do.</div><br/><div id="42034148" class="c"><input type="checkbox" id="c-42034148" checked=""/><div class="controls bullet"><span class="by">Arcuru</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42033759">parent</a><span>|</span><a href="#42033855">next</a><span>|</span><label class="collapse" for="c-42034148">[-]</label><label class="expand" for="c-42034148">[3 more]</label></div><br/><div class="children"><div class="content">They&#x27;re faster? They must have been working on performance then, maybe I should take another look at how that project has been maturing.<p>When I last looked &#x27;dd&#x27; was significantly slower, though I did make it a bit closer a while back - <a href="https:&#x2F;&#x2F;jackson.dev&#x2F;post&#x2F;rust-coreutils-dd&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jackson.dev&#x2F;post&#x2F;rust-coreutils-dd&#x2F;</a><p>A lot of the Rust coreutils were written by people learning the language, and the code is often _more_ complicated than the corresponding code for the Unix utils. They don&#x27;t seem to get enough experienced programmers fixing them up or usage for me to actually recommend anybody use them, but maybe that&#x27;s changing.</div><br/><div id="42036728" class="c"><input type="checkbox" id="c-42036728" checked=""/><div class="controls bullet"><span class="by">mustache_kimono</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42034148">parent</a><span>|</span><a href="#42033855">next</a><span>|</span><label class="collapse" for="c-42036728">[-]</label><label class="expand" for="c-42036728">[2 more]</label></div><br/><div class="children"><div class="content">&gt; When I last looked &#x27;dd&#x27; was significantly slower, though I did make it a bit closer a while back - <a href="https:&#x2F;&#x2F;jackson.dev&#x2F;post&#x2F;rust-coreutils-dd&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jackson.dev&#x2F;post&#x2F;rust-coreutils-dd&#x2F;</a><p>I read your blog.  Maybe you should take a look at some of the other utils.  I worked on sort and ls and both have long been faster than their GNU equivalents.<p>&gt; They don&#x27;t seem to get enough experienced programmers fixing them up or usage for me to actually recommend anybody use them, but maybe that&#x27;s changing.<p>The issue is obviously compatibility and the uutils won&#x27;t be broadly &quot;usable&quot; or stable until is hits 100% PASS&#x2F;0% FAIL on the GNU test coverage, although the numbers are getting better and better.  See: <a href="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;uutils&#x2F;coreutils-tracking&#x2F;refs&#x2F;heads&#x2F;main&#x2F;gnu-results.png" rel="nofollow">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;uutils&#x2F;coreutils-tracking&#x2F;...</a><p>&gt; A lot of the Rust coreutils were written by people learning the language,<p>I really, really hate this way of framing the project -- which implicitly sounds like GNU is full of pros.  Yes, lots of code was written by people just learning Rust and systems programming.  Once it reaches parity on GNU test coverage, which it is rapidly approaching, GNU coreutils would wish it had this kind of enthusiasm behind it.<p>&gt; and the code is often _more_ complicated than the corresponding code for the Unix utils.<p>I think it really depends.  Much of the code is much simpler.  For instance -- I think it&#x27;s much easier to generically do hashing in Rust, and it shows.</div><br/><div id="42038066" class="c"><input type="checkbox" id="c-42038066" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42036728">parent</a><span>|</span><a href="#42033855">next</a><span>|</span><label class="collapse" for="c-42038066">[-]</label><label class="expand" for="c-42038066">[1 more]</label></div><br/><div class="children"><div class="content">Yeah just two more weeks</div><br/></div></div></div></div></div></div><div id="42033855" class="c"><input type="checkbox" id="c-42033855" checked=""/><div class="controls bullet"><span class="by">Maro</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42033759">parent</a><span>|</span><a href="#42034148">prev</a><span>|</span><a href="#42034638">next</a><span>|</span><label class="collapse" for="c-42033855">[-]</label><label class="expand" for="c-42033855">[4 more]</label></div><br/><div class="children"><div class="content">There are millions of lines of shell scripts relying on those flags.</div><br/><div id="42036348" class="c"><input type="checkbox" id="c-42036348" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42033855">parent</a><span>|</span><a href="#42035054">next</a><span>|</span><label class="collapse" for="c-42036348">[-]</label><label class="expand" for="c-42036348">[1 more]</label></div><br/><div class="children"><div class="content">And those scripts should check they are indeed calling the gnu coreutils version before they proceed.</div><br/></div></div><div id="42035054" class="c"><input type="checkbox" id="c-42035054" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42033855">parent</a><span>|</span><a href="#42036348">prev</a><span>|</span><a href="#42034638">next</a><span>|</span><label class="collapse" for="c-42035054">[-]</label><label class="expand" for="c-42035054">[2 more]</label></div><br/><div class="children"><div class="content">I would place the blame for that on the GNU coreutils project. At best, it’s feature creep. At worst, it’s embrace and extend on the POSIX standard.</div><br/><div id="42036454" class="c"><input type="checkbox" id="c-42036454" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42035054">parent</a><span>|</span><a href="#42034638">next</a><span>|</span><label class="collapse" for="c-42036454">[-]</label><label class="expand" for="c-42036454">[1 more]</label></div><br/><div class="children"><div class="content">POSIX doesn&#x27;t forbid new flags or options. It&#x27;s up to the author to read the spec and test his portability, or else willingly rely on certain distros. Some GNU tools have had strict modes as a courtesy (they used to jokingly call it POSIX_ME_HARDER).</div><br/></div></div></div></div></div></div><div id="42034638" class="c"><input type="checkbox" id="c-42034638" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42033759">parent</a><span>|</span><a href="#42033855">prev</a><span>|</span><a href="#42034230">next</a><span>|</span><label class="collapse" for="c-42034638">[-]</label><label class="expand" for="c-42034638">[1 more]</label></div><br/><div class="children"><div class="content">Faster? I do not know, what I do know is that there has been some really crazy vulnerabilities in one (or some) of these utilities (logic errors).</div><br/></div></div><div id="42034230" class="c"><input type="checkbox" id="c-42034230" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42033759">parent</a><span>|</span><a href="#42034638">prev</a><span>|</span><a href="#42034288">next</a><span>|</span><label class="collapse" for="c-42034230">[-]</label><label class="expand" for="c-42034230">[15 more]</label></div><br/><div class="children"><div class="content">...and that&#x27;s precisely why they are faster, if you can throw out decades of compatibility flags you can avoid expensive branching and such to make them faster. That&#x27;s why such projects should be called alternatives, and not replacements, it&#x27;s not a replacement if it cannot be seamlessly replaced and decades worth of scripts can continue working.</div><br/><div id="42034968" class="c"><input type="checkbox" id="c-42034968" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42034230">parent</a><span>|</span><a href="#42034609">next</a><span>|</span><label class="collapse" for="c-42034968">[-]</label><label class="expand" for="c-42034968">[1 more]</label></div><br/><div class="children"><div class="content">No problem. Don’t branch in the middle of the algorithm, choose the appropriate optimized algorithm based on the task. That’s why we haven’t had a separate fgrep binary for decades.</div><br/></div></div><div id="42034609" class="c"><input type="checkbox" id="c-42034609" checked=""/><div class="controls bullet"><span class="by">7bit</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42034230">parent</a><span>|</span><a href="#42034968">prev</a><span>|</span><a href="#42034288">next</a><span>|</span><label class="collapse" for="c-42034609">[-]</label><label class="expand" for="c-42034609">[13 more]</label></div><br/><div class="children"><div class="content">When is it the time to talk about alternatives replacing the current apps in favor of faster apps? 10 years or rare usage? Twenty? At some point the edge cases should be covered by the scripts not by the app, only to make it slower for everyone.<p>I get what you&#x27;re saying, but I don&#x27;t care how it&#x27;s called. Some things must die. Eg. Python 3 and the depreciation of was a very controversial step, but ultimately the right choice at the right time.</div><br/><div id="42037494" class="c"><input type="checkbox" id="c-42037494" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42034609">parent</a><span>|</span><a href="#42035240">next</a><span>|</span><label class="collapse" for="c-42037494">[-]</label><label class="expand" for="c-42037494">[1 more]</label></div><br/><div class="children"><div class="content">python3 was practically the reason I&#x27;ll never rely on it for anything.<p>But it&#x27;s not even just that. Even within a major version it changes so much every few months and between different distros and platforms that random non-packaged scripts never work when moved from the authors fedora box to someone else&#x27;s debian box, or god forbid bsd or sco or windows, or the same box a year later due to any number of random library&#x2F;module differences.<p>It&#x27;s great for the author and miserable for every other user.<p>It&#x27;s ok for writing and using today and not at all for writing to keep.<p>It&#x27;s ok for packaged apps where the package manager ensures that the script has exactly the environment it expects.<p>It&#x27;s ok for controlled environments where the gods at the top have decreed that it is just part of the environment, so, large companies with IT departments and static published environments that everyone must use the same.<p>That&#x27;s a lot of &quot;it&#x27;s ok&quot;&#x27;s and so that&#x27;s why it exists and is used in many places, but none of those changes why it&#x27;s quite terrible.</div><br/></div></div><div id="42035240" class="c"><input type="checkbox" id="c-42035240" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42034609">parent</a><span>|</span><a href="#42037494">prev</a><span>|</span><a href="#42034782">next</a><span>|</span><label class="collapse" for="c-42035240">[-]</label><label class="expand" for="c-42035240">[6 more]</label></div><br/><div class="children"><div class="content">Python 3 created a huge amount of unnecessary effort and made a lot of people hesitant about using python again</div><br/><div id="42035774" class="c"><input type="checkbox" id="c-42035774" checked=""/><div class="controls bullet"><span class="by">jhayward</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42035240">parent</a><span>|</span><a href="#42035467">next</a><span>|</span><label class="collapse" for="c-42035774">[-]</label><label class="expand" for="c-42035774">[4 more]</label></div><br/><div class="children"><div class="content">Not a mainstream view.<p>Python 3 is a hugely successful language and implementation, and almost no one regrets that it exists aside from a few noisy holdouts, and people who never liked any Python anywhere at any time.</div><br/><div id="42038471" class="c"><input type="checkbox" id="c-42038471" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42035774">parent</a><span>|</span><a href="#42036229">next</a><span>|</span><label class="collapse" for="c-42038471">[-]</label><label class="expand" for="c-42038471">[1 more]</label></div><br/><div class="children"><div class="content">I saw a solid dozen Python 2 projects leave Python entirely across a couple companies back during that timeframe.<p>The Python ecosystem has been growing overall especially because of the success of things like Pandas, but a lot of backend&#x2F;fullstack web app programming did move away from it and never looked back.<p>(Though you might say the more interesting question is: would they have moved away to things like Node for async&#x2F;perf or JVM-stuff for &quot;maintainability of old large codebase with lots of devs&quot; issues? Maybe? But at this point Python has added in a lot of things from those languages; but maybe if they&#x27;d been there five years earlier with a cleaner upgrade story the migrations wouldn&#x27;t have happened.)</div><br/></div></div><div id="42036229" class="c"><input type="checkbox" id="c-42036229" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42035774">parent</a><span>|</span><a href="#42038471">prev</a><span>|</span><a href="#42036496">next</a><span>|</span><label class="collapse" for="c-42036229">[-]</label><label class="expand" for="c-42036229">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree that python3 is hugely successful, but that doesn&#x27;t mean the Python 2-&gt;3 pain was necessary. Certainly many Python users started using it too recently to remember it though.</div><br/></div></div><div id="42036496" class="c"><input type="checkbox" id="c-42036496" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42035774">parent</a><span>|</span><a href="#42036229">prev</a><span>|</span><a href="#42035467">next</a><span>|</span><label class="collapse" for="c-42036496">[-]</label><label class="expand" for="c-42036496">[1 more]</label></div><br/><div class="children"><div class="content">python3 had no compatibility mode, so everyone needed 100% of their dependencies to migrate. This was so painful that some teams abandoned their legacy python2 code and reimplemented in languages with better back compat stories.</div><br/></div></div></div></div><div id="42035467" class="c"><input type="checkbox" id="c-42035467" checked=""/><div class="controls bullet"><span class="by">andrepd</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42035240">parent</a><span>|</span><a href="#42035774">prev</a><span>|</span><a href="#42034782">next</a><span>|</span><label class="collapse" for="c-42035467">[-]</label><label class="expand" for="c-42035467">[1 more]</label></div><br/><div class="children"><div class="content">Well it&#x27;s one of the most popular languages in the planet so it cannot have gone that bad.</div><br/></div></div></div></div><div id="42034782" class="c"><input type="checkbox" id="c-42034782" checked=""/><div class="controls bullet"><span class="by">kanbankaren</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42034609">parent</a><span>|</span><a href="#42035240">prev</a><span>|</span><a href="#42034288">next</a><span>|</span><label class="collapse" for="c-42034782">[-]</label><label class="expand" for="c-42034782">[5 more]</label></div><br/><div class="children"><div class="content">&gt; When is it the time to talk about alternatives<p>When all standards bodies and governments decide that POSIX is a hindrance which might take a few decades. And that is if they decide.</div><br/><div id="42035515" class="c"><input type="checkbox" id="c-42035515" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42034782">parent</a><span>|</span><a href="#42034288">next</a><span>|</span><label class="collapse" for="c-42035515">[-]</label><label class="expand" for="c-42035515">[4 more]</label></div><br/><div class="children"><div class="content">The FBI just said everyone needs a roadmap by 2026 to eliminate c&#x2F;c++ from critical infrastructure.</div><br/><div id="42039407" class="c"><input type="checkbox" id="c-42039407" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42035515">parent</a><span>|</span><a href="#42037117">next</a><span>|</span><label class="collapse" for="c-42039407">[-]</label><label class="expand" for="c-42039407">[1 more]</label></div><br/><div class="children"><div class="content">That document does not have the 2026 deadline. Instead, &quot;At the same time, the authoring agencies acknowledge the commercial reality that
transitioning to MSLs will involve significant investments and executive attention. Further,
any such transition will take careful planning over a period of years.&quot; Also for the roadmap &quot;agencies urge executives of software manufacturers to prioritize using MSLs in their products&quot;, not eliminate C. And a lot is about accountability: &quot;The authoring agencies encourage software manufacturers to lead from the
top by publicly naming a business executive who will personally drive the elimination of
memory safety vulnerabilities from the product line.&quot;<p><a href="https:&#x2F;&#x2F;www.cisa.gov&#x2F;sites&#x2F;default&#x2F;files&#x2F;2023-12&#x2F;The-Case-for-Memory-Safe-Roadmaps-508c.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cisa.gov&#x2F;sites&#x2F;default&#x2F;files&#x2F;2023-12&#x2F;The-Case-fo...</a></div><br/></div></div><div id="42037117" class="c"><input type="checkbox" id="c-42037117" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42035515">parent</a><span>|</span><a href="#42039407">prev</a><span>|</span><a href="#42034288">next</a><span>|</span><label class="collapse" for="c-42037117">[-]</label><label class="expand" for="c-42037117">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps by 2126, Linux will no longer have C in it, but that&#x27;s probably hugely optimistic.</div><br/><div id="42037342" class="c"><input type="checkbox" id="c-42037342" checked=""/><div class="controls bullet"><span class="by">niobe</span><span>|</span><a href="#42033718">root</a><span>|</span><a href="#42037117">parent</a><span>|</span><a href="#42034288">next</a><span>|</span><label class="collapse" for="c-42037342">[-]</label><label class="expand" for="c-42037342">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ll all have uploaded to the Metaverse by then, running purely on beams of light and upvotes.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42034288" class="c"><input type="checkbox" id="c-42034288" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#42033718">parent</a><span>|</span><a href="#42033759">prev</a><span>|</span><a href="#42032718">next</a><span>|</span><label class="collapse" for="c-42034288">[-]</label><label class="expand" for="c-42034288">[1 more]</label></div><br/><div class="children"><div class="content">The readme mentions feature parity with the BSD coreutils, so I’m assuming that’s the target. Not GNU.</div><br/></div></div></div></div><div id="42032718" class="c"><input type="checkbox" id="c-42032718" checked=""/><div class="controls bullet"><span class="by">anardil</span><span>|</span><a href="#42033718">prev</a><span>|</span><a href="#42032996">next</a><span>|</span><label class="collapse" for="c-42032718">[-]</label><label class="expand" for="c-42032718">[19 more]</label></div><br/><div class="children"><div class="content">Wow, hello! This is my repository. I&#x27;m happy to answer any questions.</div><br/><div id="42033161" class="c"><input type="checkbox" id="c-42033161" checked=""/><div class="controls bullet"><span class="by">bts</span><span>|</span><a href="#42032718">parent</a><span>|</span><a href="#42033068">next</a><span>|</span><label class="collapse" for="c-42033161">[-]</label><label class="expand" for="c-42033161">[2 more]</label></div><br/><div class="children"><div class="content">Hi! A few years ago I found myself wanting an equivalent of `column` that didn’t strip color codes. After I implemented it in Haskell, I found it was useful to use Nix to force statically linking against libraries like gmp to reduce startup time. Perhaps what I ended up doing might be helpful for you too: <a href="https:&#x2F;&#x2F;github.com&#x2F;bts&#x2F;columnate&#x2F;blob&#x2F;master&#x2F;default.nix">https:&#x2F;&#x2F;github.com&#x2F;bts&#x2F;columnate&#x2F;blob&#x2F;master&#x2F;default.nix</a></div><br/><div id="42034111" class="c"><input type="checkbox" id="c-42034111" checked=""/><div class="controls bullet"><span class="by">anardil</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42033161">parent</a><span>|</span><a href="#42033068">next</a><span>|</span><label class="collapse" for="c-42034111">[-]</label><label class="expand" for="c-42034111">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the suggestion, I&#x27;ll give this a whirl! I&#x27;ve fussed around with `--ghc-options &#x27;-optl-static -fPIC&#x27;` and the like in years past without success.</div><br/></div></div></div></div><div id="42033068" class="c"><input type="checkbox" id="c-42033068" checked=""/><div class="controls bullet"><span class="by">cosmic_quanta</span><span>|</span><a href="#42032718">parent</a><span>|</span><a href="#42033161">prev</a><span>|</span><a href="#42032750">next</a><span>|</span><label class="collapse" for="c-42033068">[-]</label><label class="expand" for="c-42033068">[9 more]</label></div><br/><div class="children"><div class="content">Could you speak to the advantages of Haskell&#x27;s lazy IO? I only hear about its disadvantages usually</div><br/><div id="42033449" class="c"><input type="checkbox" id="c-42033449" checked=""/><div class="controls bullet"><span class="by">habitue</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42033068">parent</a><span>|</span><a href="#42033774">next</a><span>|</span><label class="collapse" for="c-42033449">[-]</label><label class="expand" for="c-42033449">[2 more]</label></div><br/><div class="children"><div class="content">I imagine for streaming tools like these it&#x27;s pretty convenient. You don&#x27;t have to manage buffers etc, just write code against a massive string and haskell takes care of streaming it for you and pulling in more data when needed.<p>There are libraries that handle it, but they probably have weird types, you can just use functions in the prelude to write a lot of these basic utilities.</div><br/><div id="42037998" class="c"><input type="checkbox" id="c-42037998" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42033449">parent</a><span>|</span><a href="#42033774">next</a><span>|</span><label class="collapse" for="c-42037998">[-]</label><label class="expand" for="c-42037998">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, while that may be the dream, it doesn&#x27;t work out that way if you want good performance. If you look at the source you&#x27;ll see that it uses things like <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;streaming-bytestring-0.3.3&#x2F;docs&#x2F;Streaming-ByteString-Char8.html" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;streaming-bytestring-0.3...</a> a lot.<p>For one thing, a &quot;string&quot; in Haskell by default is a linked list of unicode characters, so right out of the gate you&#x27;ve got big performance problems if you want to use strings. The exact way laziness is done also has serious performance consequences as well; when dealing with things as small as individual characters all the overhead looms large as a percentage basis. One of the major purposes of any of the several variants of ByteString is to bundle the bytes together, but that means you&#x27;re back to dealing with chunks. Haskell does end up with a nice API that can abstract over the chunks but it still means you sometimes have to deal with chunks as chunks; if you turn them back into a normal Haskell &quot;string&quot; you lose all the performance advantages.<p>It can still come out <i>fairly</i> nice, but if you want performance it is definitely not just a matter of opening a file and pretending you&#x27;ve just got one big lazy string and you can just ignore all the details; some of the details still poke out.</div><br/></div></div></div></div><div id="42033774" class="c"><input type="checkbox" id="c-42033774" checked=""/><div class="controls bullet"><span class="by">anardil</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42033068">parent</a><span>|</span><a href="#42033449">prev</a><span>|</span><a href="#42033816">next</a><span>|</span><label class="collapse" for="c-42033774">[-]</label><label class="expand" for="c-42033774">[1 more]</label></div><br/><div class="children"><div class="content">It definitely has some sharp edges. One advantage is skipping computations (and the IO they&#x27;d need) that don&#x27;t end up getting used, which let&#x27;s you do some clever looking things&#x2F; ignore some details. That&#x27;s hard to take advantage of in practice, I think.<p>The other advantage is just deferring IO. For instance in split or tee, you could decide that you need 500 output files and open all the handles together in order to pass them to another function that will consume them. I&#x27;d squint at someone who wrote `void process_fds(int fds[500]);`, but here it doesn&#x27;t matter.</div><br/></div></div><div id="42033816" class="c"><input type="checkbox" id="c-42033816" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42033068">parent</a><span>|</span><a href="#42033774">prev</a><span>|</span><a href="#42032750">next</a><span>|</span><label class="collapse" for="c-42033816">[-]</label><label class="expand" for="c-42033816">[5 more]</label></div><br/><div class="children"><div class="content">If your language doesn&#x27;t give you laziness, you&#x27;re reinventing it yourself with strict primitives each time.</div><br/><div id="42034364" class="c"><input type="checkbox" id="c-42034364" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42033816">parent</a><span>|</span><a href="#42032750">next</a><span>|</span><label class="collapse" for="c-42034364">[-]</label><label class="expand" for="c-42034364">[4 more]</label></div><br/><div class="children"><div class="content">On the other hand, when you don&#x27;t want laziness you really won&#x27;t like if it&#x27;s present anyways.</div><br/><div id="42034480" class="c"><input type="checkbox" id="c-42034480" checked=""/><div class="controls bullet"><span class="by">weebull</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42034364">parent</a><span>|</span><a href="#42034479">next</a><span>|</span><label class="collapse" for="c-42034480">[-]</label><label class="expand" for="c-42034480">[1 more]</label></div><br/><div class="children"><div class="content">Lazy to strict is reasonably easy to do though. The problem is normally that once one bit goes strict, most other things implicitly do too.<p>Strict to lazy is normally a rewrite.</div><br/></div></div><div id="42034479" class="c"><input type="checkbox" id="c-42034479" checked=""/><div class="controls bullet"><span class="by">weebull</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42034364">parent</a><span>|</span><a href="#42034480">prev</a><span>|</span><a href="#42032750">next</a><span>|</span><label class="collapse" for="c-42034479">[-]</label><label class="expand" for="c-42034479">[2 more]</label></div><br/><div class="children"><div class="content">Lazy to strict is reasonably easy to do though. The problem is normally that once one bit goes strict, most other things implicitly do too.<p>Strict to lazy is normally a rewrite.</div><br/><div id="42036926" class="c"><input type="checkbox" id="c-42036926" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42034479">parent</a><span>|</span><a href="#42032750">next</a><span>|</span><label class="collapse" for="c-42036926">[-]</label><label class="expand" for="c-42036926">[1 more]</label></div><br/><div class="children"><div class="content">I think the scope of lazy constructs should usually be far less than that of strict constructs, so it&#x27;s only in the cases where the librarified lazy abstractions don&#x27;t fit that you need a rewrite. Lazy to strict isn&#x27;t hard, but I don&#x27;t want the performance and cognitive overhead of lazy-by-default.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42032750" class="c"><input type="checkbox" id="c-42032750" checked=""/><div class="controls bullet"><span class="by">aeonik</span><span>|</span><a href="#42032718">parent</a><span>|</span><a href="#42033068">prev</a><span>|</span><a href="#42033050">next</a><span>|</span><label class="collapse" for="c-42032750">[-]</label><label class="expand" for="c-42032750">[3 more]</label></div><br/><div class="children"><div class="content">You specify &quot;fast&quot;, can you elaborate on the performance of the collection? How does it compare to the standard core utils?<p>Great work, looks amazing.</div><br/><div id="42033731" class="c"><input type="checkbox" id="c-42033731" checked=""/><div class="controls bullet"><span class="by">anardil</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42032750">parent</a><span>|</span><a href="#42033046">next</a><span>|</span><label class="collapse" for="c-42033731">[-]</label><label class="expand" for="c-42033731">[1 more]</label></div><br/><div class="children"><div class="content">Performance (execution, memory) is generally in the same ballpark as the BSD versions, with some caveats specific to utils that do lots of in place data manipulation.<p>cut comes to mind as an example, slicing and dicing lines into fields quickly without a ton of copies isn&#x27;t easy. Using Streaming.ByteString generally makes a huge difference, but it&#x27;s extremely difficult to use unless you get can your mind to meld with the types it wants. Picking it up again months later takes some serious effort.</div><br/></div></div></div></div><div id="42033050" class="c"><input type="checkbox" id="c-42033050" checked=""/><div class="controls bullet"><span class="by">faragon</span><span>|</span><a href="#42032718">parent</a><span>|</span><a href="#42032750">prev</a><span>|</span><a href="#42035397">next</a><span>|</span><label class="collapse" for="c-42033050">[-]</label><label class="expand" for="c-42033050">[3 more]</label></div><br/><div class="children"><div class="content">Very beautiful implementation of the awk interpreter in less than 600 lines!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Gandalf-&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;Coreutils&#x2F;Awk.hs">https:&#x2F;&#x2F;github.com&#x2F;Gandalf-&#x2F;coreutils&#x2F;blob&#x2F;master&#x2F;Coreutils&#x2F;...</a></div><br/><div id="42033734" class="c"><input type="checkbox" id="c-42033734" checked=""/><div class="controls bullet"><span class="by">anardil</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42033050">parent</a><span>|</span><a href="#42035397">next</a><span>|</span><label class="collapse" for="c-42033734">[-]</label><label class="expand" for="c-42033734">[2 more]</label></div><br/><div class="children"><div class="content">Thank you! This is one of my favorites. User declared variables are next on the todo list, when I get back to it.</div><br/><div id="42034877" class="c"><input type="checkbox" id="c-42034877" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#42032718">root</a><span>|</span><a href="#42033734">parent</a><span>|</span><a href="#42035397">next</a><span>|</span><label class="collapse" for="c-42034877">[-]</label><label class="expand" for="c-42034877">[1 more]</label></div><br/><div class="children"><div class="content">It is really gorgeously written Haskell. I’ve only dabbled in Haskell, but you’re really shetting my appetite for digging in deeper.</div><br/></div></div></div></div></div></div><div id="42035397" class="c"><input type="checkbox" id="c-42035397" checked=""/><div class="controls bullet"><span class="by">Vosporos</span><span>|</span><a href="#42032718">parent</a><span>|</span><a href="#42033050">prev</a><span>|</span><a href="#42032996">next</a><span>|</span><label class="collapse" for="c-42035397">[-]</label><label class="expand" for="c-42035397">[1 more]</label></div><br/><div class="children"><div class="content">Fantastic work, thank you so much!</div><br/></div></div></div></div><div id="42032996" class="c"><input type="checkbox" id="c-42032996" checked=""/><div class="controls bullet"><span class="by">wizerno</span><span>|</span><a href="#42032718">prev</a><span>|</span><a href="#42033674">next</a><span>|</span><label class="collapse" for="c-42032996">[-]</label><label class="expand" for="c-42032996">[1 more]</label></div><br/><div class="children"><div class="content">The author has a few blog posts covering the tee, split, which, and cat commands [1].<p>[1] <a href="https:&#x2F;&#x2F;www.anardil.net&#x2F;tag&#x2F;coreutils.html" rel="nofollow">https:&#x2F;&#x2F;www.anardil.net&#x2F;tag&#x2F;coreutils.html</a></div><br/></div></div><div id="42033674" class="c"><input type="checkbox" id="c-42033674" checked=""/><div class="controls bullet"><span class="by">mytec</span><span>|</span><a href="#42032996">prev</a><span>|</span><a href="#42038592">next</a><span>|</span><label class="collapse" for="c-42033674">[-]</label><label class="expand" for="c-42033674">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m used to reading about a given C&#x2F;C++ program being implemented in Rust, and was delighted to see such an effort in a functional programming language.<p>I know little about functional programming languages but I&#x27;ve always been interested in how languages like Ada and now Rust can help programmers write safer code. I&#x27;m curious what advantages a rewrite of a C&#x2F;C++ app in a FP language provides and also what advantages a FP language brings in comparison to a language like Rust.</div><br/></div></div><div id="42038592" class="c"><input type="checkbox" id="c-42038592" checked=""/><div class="controls bullet"><span class="by">haskman</span><span>|</span><a href="#42033674">prev</a><span>|</span><a href="#42035964">next</a><span>|</span><label class="collapse" for="c-42038592">[-]</label><label class="expand" for="c-42038592">[1 more]</label></div><br/><div class="children"><div class="content">Great work! As a nitpick, I noticed that there is some contrived indirection going on inside `Coreutils.Util`. Instead of the Utility class they could have just used an datatype. The current way could be confusing to newcomers looking to learn from this repo (if that was the goal).</div><br/></div></div><div id="42035964" class="c"><input type="checkbox" id="c-42035964" checked=""/><div class="controls bullet"><span class="by">mhd</span><span>|</span><a href="#42038592">prev</a><span>|</span><a href="#42033009">next</a><span>|</span><label class="collapse" for="c-42035964">[-]</label><label class="expand" for="c-42035964">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of a similar attempt with Perl[0], done a few… erm, twenty years ago. Might be interesting to do a three-way comparison for a few well-covered cases.<p>[0]: <a href="https:&#x2F;&#x2F;metacpan.org&#x2F;release&#x2F;CWEST&#x2F;ppt-0.14" rel="nofollow">https:&#x2F;&#x2F;metacpan.org&#x2F;release&#x2F;CWEST&#x2F;ppt-0.14</a></div><br/></div></div><div id="42033009" class="c"><input type="checkbox" id="c-42033009" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#42035964">prev</a><span>|</span><a href="#42033143">next</a><span>|</span><label class="collapse" for="c-42033009">[-]</label><label class="expand" for="c-42033009">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Symlinking doesn&#x27;t appear to change the name reported by System.Environment.getProgName, so you&#x27;ll need to create copies of the binary with different names<p>Would hardlinks help (would avoid multiple copies)?</div><br/><div id="42033776" class="c"><input type="checkbox" id="c-42033776" checked=""/><div class="controls bullet"><span class="by">anardil</span><span>|</span><a href="#42033009">parent</a><span>|</span><a href="#42033143">next</a><span>|</span><label class="collapse" for="c-42033776">[-]</label><label class="expand" for="c-42033776">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll have to give this a try, thank you for the suggestion!</div><br/></div></div></div></div><div id="42033143" class="c"><input type="checkbox" id="c-42033143" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42033009">prev</a><span>|</span><a href="#42034260">next</a><span>|</span><label class="collapse" for="c-42033143">[-]</label><label class="expand" for="c-42033143">[12 more]</label></div><br/><div class="children"><div class="content">It would be cool if RFCs would be turned into Haskell, so we could use __that__ as the specification instead.<p>Same for all the remaining web standards.</div><br/><div id="42034170" class="c"><input type="checkbox" id="c-42034170" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42033143">parent</a><span>|</span><a href="#42033355">next</a><span>|</span><label class="collapse" for="c-42034170">[-]</label><label class="expand" for="c-42034170">[10 more]</label></div><br/><div class="children"><div class="content">Opinion: I would rather prefer OCaml or just C (instead of say, Rust or Python).</div><br/><div id="42034334" class="c"><input type="checkbox" id="c-42034334" checked=""/><div class="controls bullet"><span class="by">bionade24</span><span>|</span><a href="#42033143">root</a><span>|</span><a href="#42034170">parent</a><span>|</span><a href="#42036407">next</a><span>|</span><label class="collapse" for="c-42034334">[-]</label><label class="expand" for="c-42034334">[8 more]</label></div><br/><div class="children"><div class="content">C is way too ambiguous to serve for that purpose.</div><br/><div id="42034352" class="c"><input type="checkbox" id="c-42034352" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42033143">root</a><span>|</span><a href="#42034334">parent</a><span>|</span><a href="#42036407">next</a><span>|</span><label class="collapse" for="c-42034352">[-]</label><label class="expand" for="c-42034352">[7 more]</label></div><br/><div class="children"><div class="content">Are we referring to reference implementations? I have always found it easier to understand the C code, as Rust and Python tend to obscure too many details behind high-level abstractions.<p>C is simple enough to know what is going on, IMO.<p>For example:<p><pre><code>    numbers = [1, 2, 3, 4, 5]
    squared_numbers = [num * num for num in numbers]
    print(squared_numbers)
</code></pre>
vs.<p><pre><code>    fn main() {
        let numbers = vec![1, 2, 3, 4, 5];
        let squared_numbers: Vec&lt;i32&gt; = numbers.iter().map(|&amp;num| num * num).collect();

        println!(&quot;{:?}&quot;, squared_numbers);
    }
</code></pre>
vs.<p><pre><code>    #include &lt;stdio.h&gt;

    int main() {
        int numbers[] = {1, 2, 3, 4, 5};
        int squared_numbers[5];
    
        &#x2F;&#x2F; Squaring each number
        for (int i = 0; i &lt; 5; i++) {
            squared_numbers[i] = numbers[i] * numbers[i];
        }
    
        &#x2F;&#x2F; Printing the squared numbers
        printf(&quot;[&quot;);
        for (int i = 0; i &lt; 5; i++) {
            printf(&quot;%d&quot;, squared_numbers[i]);
            if (i &lt; 4) printf(&quot;, &quot;);
        }
        printf(&quot;]\n&quot;);

        return 0;
    }
</code></pre>
Python and Rust here seem concise and elegant, but can be more difficult to follow to the unaccustomed due to obscurity. I am sure there are examples that involve more higher-level abstractions, and reference implementations typically seem to use a lot of said abstractions. In case of this Rust code, abstractions (like iterators and closures) can also make the code more challenging to follow for those who are not accustomed to functional programming paradigms.<p>What I am trying to say is that the C implementation is more straightforward, IMO.</div><br/><div id="42035987" class="c"><input type="checkbox" id="c-42035987" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#42033143">root</a><span>|</span><a href="#42034352">parent</a><span>|</span><a href="#42034593">next</a><span>|</span><label class="collapse" for="c-42035987">[-]</label><label class="expand" for="c-42035987">[2 more]</label></div><br/><div class="children"><div class="content">People who write C nowadays generally try to write it in the most &quot;boring&quot; and easy-to-read way possible, I think. But C can also be hard to understand if it uses a lot of side-effectful expressions and pointer arithmetic. Just look at &quot;How Old School C Programmers Process Arguments&quot;, which looks over an excerpt from K&amp;R [0]. To make your code slightly harder to read, while still being plausible, you could change it to use pointer arithmetic, like so:<p><pre><code>  &#x2F;&#x2F; Printing the squared numbers
  printf(&quot;[&quot;);
  for (int n = 5, *p = squared_numbers; --n &gt;= 0; p++)
      printf(&quot;%d%s&quot;, *p, n &gt; 0 ? &quot;, &quot; : &quot;]\n&quot;);

</code></pre>
[0]: <a href="https:&#x2F;&#x2F;www.usrsb.in&#x2F;How-Old-School-C-Programmers-Process-Arguments.html" rel="nofollow">https:&#x2F;&#x2F;www.usrsb.in&#x2F;How-Old-School-C-Programmers-Process-Ar...</a></div><br/><div id="42037995" class="c"><input type="checkbox" id="c-42037995" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#42033143">root</a><span>|</span><a href="#42035987">parent</a><span>|</span><a href="#42034593">next</a><span>|</span><label class="collapse" for="c-42037995">[-]</label><label class="expand" for="c-42037995">[1 more]</label></div><br/><div class="children"><div class="content">&gt;--n &gt;= 0<p>But n--&gt;0 is prettier.</div><br/></div></div></div></div><div id="42034593" class="c"><input type="checkbox" id="c-42034593" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42033143">root</a><span>|</span><a href="#42034352">parent</a><span>|</span><a href="#42035987">prev</a><span>|</span><a href="#42034454">next</a><span>|</span><label class="collapse" for="c-42034593">[-]</label><label class="expand" for="c-42034593">[2 more]</label></div><br/><div class="children"><div class="content">&gt; as Rust and Python tend to obscure too many details behind high-level abstractions.<p>C on the other hand forces handling too many low level details for a reference implementation IMO. Rust also isn&#x27;t really good in that regard.<p>In a reference implementation what needs to be made explicit is the logic that needs to be implemented, rather than details like memory management. For that I would prefer something like Datalog instead.</div><br/><div id="42034613" class="c"><input type="checkbox" id="c-42034613" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42033143">root</a><span>|</span><a href="#42034593">parent</a><span>|</span><a href="#42034454">next</a><span>|</span><label class="collapse" for="c-42034613">[-]</label><label class="expand" for="c-42034613">[1 more]</label></div><br/><div class="children"><div class="content">&gt; what needs to be made explicit is the logic that needs to be implemented, rather than details like memory management<p>I agree.</div><br/></div></div></div></div><div id="42034454" class="c"><input type="checkbox" id="c-42034454" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#42033143">root</a><span>|</span><a href="#42034352">parent</a><span>|</span><a href="#42034593">prev</a><span>|</span><a href="#42036407">next</a><span>|</span><label class="collapse" for="c-42034454">[-]</label><label class="expand" for="c-42034454">[2 more]</label></div><br/><div class="children"><div class="content">[num**2 for num in numbers]<p>There&#x27;s no way that C implementation is easier to read than the Python one. There&#x27;s no high-level abstraction going on there and the list comprehension reads like natural language.<p>I agree Rust often gets distracting with unwrapping and lifetime notation.</div><br/><div id="42034493" class="c"><input type="checkbox" id="c-42034493" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#42033143">root</a><span>|</span><a href="#42034454">parent</a><span>|</span><a href="#42036407">next</a><span>|</span><label class="collapse" for="c-42034493">[-]</label><label class="expand" for="c-42034493">[1 more]</label></div><br/><div class="children"><div class="content">I know it is easier to read, and it is not difficult to figure out what is going on (in this case), but many languages do not support list comprehensions (for example), so you have to implement it in a way that is similar to the C version, making the C version more helpful.<p>The example above may not highlight what I was trying to, however.<p>Perhaps Ada could work even better than C? It is verbose, yes, but you will immediately know what is going on.<p>My point is, that in my opinion verbosity is better than conciseness in cases of reference implementations.</div><br/></div></div></div></div></div></div></div></div><div id="42036407" class="c"><input type="checkbox" id="c-42036407" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42033143">root</a><span>|</span><a href="#42034170">parent</a><span>|</span><a href="#42034334">prev</a><span>|</span><a href="#42033355">next</a><span>|</span><label class="collapse" for="c-42036407">[-]</label><label class="expand" for="c-42036407">[1 more]</label></div><br/><div class="children"><div class="content">I personally think Haskell is a better choice because it is purely functional.</div><br/></div></div></div></div><div id="42033355" class="c"><input type="checkbox" id="c-42033355" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42033143">parent</a><span>|</span><a href="#42034170">prev</a><span>|</span><a href="#42034260">next</a><span>|</span><label class="collapse" for="c-42033355">[-]</label><label class="expand" for="c-42033355">[1 more]</label></div><br/><div class="children"><div class="content">executable specs?</div><br/></div></div></div></div><div id="42034260" class="c"><input type="checkbox" id="c-42034260" checked=""/><div class="controls bullet"><span class="by">parasti</span><span>|</span><a href="#42033143">prev</a><span>|</span><a href="#42035421">next</a><span>|</span><label class="collapse" for="c-42034260">[-]</label><label class="expand" for="c-42034260">[2 more]</label></div><br/><div class="children"><div class="content">Ive seen several coreutils reimplementations just using the name &quot;coreutils&quot; for themselves. I doubt anyone in the original project cares, but seems in bad taste to me.</div><br/><div id="42035610" class="c"><input type="checkbox" id="c-42035610" checked=""/><div class="controls bullet"><span class="by">bqmjjx0kac</span><span>|</span><a href="#42034260">parent</a><span>|</span><a href="#42035421">next</a><span>|</span><label class="collapse" for="c-42035610">[-]</label><label class="expand" for="c-42035610">[1 more]</label></div><br/><div class="children"><div class="content">I mean, it gets the point across and they&#x27;re not claiming to be &quot;GNU coreutils&quot;. Maybe some derivative name would be better for uniqueness.</div><br/></div></div></div></div><div id="42035421" class="c"><input type="checkbox" id="c-42035421" checked=""/><div class="controls bullet"><span class="by">xolve</span><span>|</span><a href="#42034260">prev</a><span>|</span><a href="#42033104">next</a><span>|</span><label class="collapse" for="c-42035421">[-]</label><label class="expand" for="c-42035421">[2 more]</label></div><br/><div class="children"><div class="content">TIL that GitHub usernames can end with a `-`</div><br/><div id="42035593" class="c"><input type="checkbox" id="c-42035593" checked=""/><div class="controls bullet"><span class="by">anardil</span><span>|</span><a href="#42035421">parent</a><span>|</span><a href="#42033104">next</a><span>|</span><label class="collapse" for="c-42035593">[-]</label><label class="expand" for="c-42035593">[1 more]</label></div><br/><div class="children"><div class="content">The rules were different in 2014 when I made my account! It&#x27;s actually quite annoying because lots of 3rd party GitHub integrations puke immediately saying I have an invalid username.</div><br/></div></div></div></div><div id="42033104" class="c"><input type="checkbox" id="c-42033104" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#42035421">prev</a><span>|</span><a href="#42033349">next</a><span>|</span><label class="collapse" for="c-42033104">[-]</label><label class="expand" for="c-42033104">[6 more]</label></div><br/><div class="children"><div class="content">I’m curious if there are any that were especially uncomfortable to implement in Haskell.<p>I’m a <i>very very</i> novice “functional programmer” but on occasion I find problems that feel just ridiculous to implement FP style.</div><br/><div id="42033871" class="c"><input type="checkbox" id="c-42033871" checked=""/><div class="controls bullet"><span class="by">anardil</span><span>|</span><a href="#42033104">parent</a><span>|</span><a href="#42033139">next</a><span>|</span><label class="collapse" for="c-42033871">[-]</label><label class="expand" for="c-42033871">[2 more]</label></div><br/><div class="children"><div class="content">Definitely. Depending on how long you&#x27;ve spent staring at the contents of &#x2F;bin&#x2F; and &#x2F;usr&#x2F;bin&#x2F; you&#x27;ll notice there are definitely some array or matrix oriented utils (or options) missing like column.<p>cut comes to mind as a difficult one. In C, you can just hop around the char buffer[] and drop nulls in place for fields, etc before printing. You <i>could</i> go that way a Data.Array Char, but that&#x27;s hard to justify as functional.</div><br/><div id="42035075" class="c"><input type="checkbox" id="c-42035075" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42033104">root</a><span>|</span><a href="#42033871">parent</a><span>|</span><a href="#42033139">next</a><span>|</span><label class="collapse" for="c-42035075">[-]</label><label class="expand" for="c-42035075">[1 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t cut but the easiest one to do in functional style?<p>You basicaly map one line of a stream to another with some filtering and joining. Do I miss the part where it&#x27;s terribly slow and&#x2F;or not doable in Haskell or something?</div><br/></div></div></div></div><div id="42033139" class="c"><input type="checkbox" id="c-42033139" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#42033104">parent</a><span>|</span><a href="#42033871">prev</a><span>|</span><a href="#42033349">next</a><span>|</span><label class="collapse" for="c-42033139">[-]</label><label class="expand" for="c-42033139">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not much of a functional programmer either, but generally in the beginning you&#x27;ll feel this way because you&#x27;re not used to thinking about problems in a functional way. You&#x27;re used to solving problems with imperative structures. So you try to implement that in a functional language and it turns out completely stupid because the language isn&#x27;t made to solve problems that way. But it usually has good ways to solve things.</div><br/><div id="42033664" class="c"><input type="checkbox" id="c-42033664" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#42033104">root</a><span>|</span><a href="#42033139">parent</a><span>|</span><a href="#42033242">next</a><span>|</span><label class="collapse" for="c-42033664">[-]</label><label class="expand" for="c-42033664">[1 more]</label></div><br/><div class="children"><div class="content">I like fp and array programming and logic programming (and the overlap) to solve problems that are (considered or for real; I don&#x27;t usually know going in) really a bad fit for those and then implement them shorter and faster than in their imperative implementation. For some things it does not work obviously, but it&#x27;s a really nice exercise for when in the gym, walking, cooking, driving and such; the performant or LoC optimising parts fit in my head so I can do the rewrites there and find ways to make them fit. For instance; going from an imperative piece of code to array programming (k&#x2F;j), you have to find a way to translate the problem to a vector&#x2F;matrix manipulation problem and that you can do while doing something else entirely. When you find a good one fit, it can be many, many times faster than the original just like that.</div><br/></div></div><div id="42033242" class="c"><input type="checkbox" id="c-42033242" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#42033104">root</a><span>|</span><a href="#42033139">parent</a><span>|</span><a href="#42033664">prev</a><span>|</span><a href="#42033349">next</a><span>|</span><label class="collapse" for="c-42033242">[-]</label><label class="expand" for="c-42033242">[1 more]</label></div><br/><div class="children"><div class="content">I got stuck trying to have an intuition about what would explode my memory usage due to lazy eval, I never got a grip on the transition from pseudofunctional at the io boundaries into real functional internally either.</div><br/></div></div></div></div></div></div><div id="42033349" class="c"><input type="checkbox" id="c-42033349" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#42033104">prev</a><span>|</span><a href="#42037318">next</a><span>|</span><label class="collapse" for="c-42033349">[-]</label><label class="expand" for="c-42033349">[1 more]</label></div><br/><div class="children"><div class="content">Awesome work!<p>I noticed that they are about as long and complex as the C versions. In early C++&#x2F;STL days part of the pitch was reimplementing core utils in a much more concise way. In wonder if the is a result of focusing on that application, or a coincidence of design decisions.</div><br/></div></div><div id="42037318" class="c"><input type="checkbox" id="c-42037318" checked=""/><div class="controls bullet"><span class="by">niobe</span><span>|</span><a href="#42033349">prev</a><span>|</span><a href="#42035649">next</a><span>|</span><label class="collapse" for="c-42037318">[-]</label><label class="expand" for="c-42037318">[1 more]</label></div><br/><div class="children"><div class="content">Read the readme, only one question, why?</div><br/></div></div><div id="42035649" class="c"><input type="checkbox" id="c-42035649" checked=""/><div class="controls bullet"><span class="by">hello_computer</span><span>|</span><a href="#42037318">prev</a><span>|</span><a href="#42033004">next</a><span>|</span><label class="collapse" for="c-42035649">[-]</label><label class="expand" for="c-42035649">[3 more]</label></div><br/><div class="children"><div class="content">The original coreutils are very weak on wide-char formatting, item delimiting (i.e. -null &#x2F; -print0), flag name consistency, discoverability, and overall input&#x2F;output uniformity.  Solving the edge cases rigorously would probably require minor breakages, but would be worthwhile.<p>Most coreutil re-workings i’ve seen either double-down on JSON output, 24-bit color, sixels, &amp; other lipsticks on the pig—without addressing any of the basic breakages we’ve become accustomed to—or they go off into an entirely different direction like nushell.<p>There is definitely room for improvement, but it is a thankless job.</div><br/><div id="42036510" class="c"><input type="checkbox" id="c-42036510" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42035649">parent</a><span>|</span><a href="#42033004">next</a><span>|</span><label class="collapse" for="c-42036510">[-]</label><label class="expand" for="c-42036510">[2 more]</label></div><br/><div class="children"><div class="content">Why not have bug to bug compatible vetsion of coreutils, but in rust and then have a nice thing too?</div><br/><div id="42036618" class="c"><input type="checkbox" id="c-42036618" checked=""/><div class="controls bullet"><span class="by">hello_computer</span><span>|</span><a href="#42035649">root</a><span>|</span><a href="#42036510">parent</a><span>|</span><a href="#42033004">next</a><span>|</span><label class="collapse" for="c-42036618">[-]</label><label class="expand" for="c-42036618">[1 more]</label></div><br/><div class="children"><div class="content">Most are simple programs.  If bug-per-bug compat + memory safety is the goal, carefully reviewing the C would have been a vastly better investment of time compared to making 13,498 commits.<p><a href="https:&#x2F;&#x2F;www.cvedetails.com&#x2F;product&#x2F;5075&#x2F;GNU-Coreutils.html?vendor_id=72" rel="nofollow">https:&#x2F;&#x2F;www.cvedetails.com&#x2F;product&#x2F;5075&#x2F;GNU-Coreutils.html?v...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;uutils&#x2F;coreutils">https:&#x2F;&#x2F;github.com&#x2F;uutils&#x2F;coreutils</a></div><br/></div></div></div></div></div></div><div id="42033004" class="c"><input type="checkbox" id="c-42033004" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#42035649">prev</a><span>|</span><label class="collapse" for="c-42033004">[-]</label><label class="expand" for="c-42033004">[3 more]</label></div><br/><div class="children"><div class="content">&quot;On Windows - Symlinking doesn&#x27;t appear to change the name reported by System.Environment.getProgName, so you&#x27;ll need to create copies of the binary with different names.&quot;<p>I have not found this to be the case with &quot;mklink &#x2F;h&quot;.</div><br/><div id="42033572" class="c"><input type="checkbox" id="c-42033572" checked=""/><div class="controls bullet"><span class="by">zanie</span><span>|</span><a href="#42033004">parent</a><span>|</span><a href="#42033062">next</a><span>|</span><label class="collapse" for="c-42033572">[-]</label><label class="expand" for="c-42033572">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;d be a hard link though</div><br/></div></div></div></div></div></div></div></div></div></body></html>