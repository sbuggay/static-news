<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699347658365" as="style"/><link rel="stylesheet" href="styles.css?v=1699347658365"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.peerdb.io/building-a-streaming-platform-in-go-for-postgres">Building a Streaming Platform in Go for Postgres</a> <span class="domain">(<a href="https://blog.peerdb.io">blog.peerdb.io</a>)</span></div><div class="subtext"><span>saisrirampur</span> | <span>48 comments</span></div><br/><div><div id="38169310" class="c"><input type="checkbox" id="c-38169310" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#38169943">next</a><span>|</span><label class="collapse" for="c-38169310">[-]</label><label class="expand" for="c-38169310">[21 more]</label></div><br/><div class="children"><div class="content">Moving to channels seems like a weird choice. Channels should basically always be an implementation detail not exposed in public APIs.</div><br/><div id="38169717" class="c"><input type="checkbox" id="c-38169717" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#38169310">parent</a><span>|</span><a href="#38169440">next</a><span>|</span><label class="collapse" for="c-38169717">[-]</label><label class="expand" for="c-38169717">[6 more]</label></div><br/><div class="children"><div class="content">Using channels to talk between goroutines is the perfect choice. There’s plenty of go API’s that require a chan of a type.</div><br/><div id="38170095" class="c"><input type="checkbox" id="c-38170095" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38169717">parent</a><span>|</span><a href="#38169440">next</a><span>|</span><label class="collapse" for="c-38170095">[-]</label><label class="expand" for="c-38170095">[5 more]</label></div><br/><div class="children"><div class="content">Go&#x27;s channels also have a lot of footguns and should be abstracted in a handle type in a public API.</div><br/><div id="38171343" class="c"><input type="checkbox" id="c-38171343" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38170095">parent</a><span>|</span><a href="#38173235">next</a><span>|</span><label class="collapse" for="c-38171343">[-]</label><label class="expand" for="c-38171343">[3 more]</label></div><br/><div class="children"><div class="content">Except it itself is exposed via a public API. Context interface also exposes a chan<p><pre><code>   Done() &lt;- chan struct{}
</code></pre>
What are you trying to say? That using a chan as a function argument can shoot yourself in the foot? The whole idea behind channels is to <i>not</i> shoot yourself in the foot with mutex&#x27;s, deadlocks, etc. What are you trying to say? Wrapping a chan in a type handle is safer than passing a chan of a type? Nope.</div><br/><div id="38172253" class="c"><input type="checkbox" id="c-38172253" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38171343">parent</a><span>|</span><a href="#38172073">next</a><span>|</span><label class="collapse" for="c-38172253">[-]</label><label class="expand" for="c-38172253">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not at all what I was referring to.  It&#x27;s not merely having channels as function arguments.  Channels <i>broadly</i> have footguns around how closed and nil channels are treated and you can run into work contention&#x2F;starvation issues accidentally, since they <i>do</i> have their own throughput limits.  And wrapping them in your own handle types that&#x27;s specific to the library&#x27;s use case allows you to deal with those issues and swap out the implementation of the cross-goroutine bits without breaking the downstream API.</div><br/></div></div><div id="38172073" class="c"><input type="checkbox" id="c-38172073" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38171343">parent</a><span>|</span><a href="#38172253">prev</a><span>|</span><a href="#38173235">next</a><span>|</span><label class="collapse" for="c-38172073">[-]</label><label class="expand" for="c-38172073">[1 more]</label></div><br/><div class="children"><div class="content">exactly.<p>you <i>can&#x27;t</i> abstract over channels easily unless you&#x27;re missing the point of channels.</div><br/></div></div></div></div><div id="38173235" class="c"><input type="checkbox" id="c-38173235" checked=""/><div class="controls bullet"><span class="by">tw1984</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38170095">parent</a><span>|</span><a href="#38171343">prev</a><span>|</span><a href="#38169440">next</a><span>|</span><label class="collapse" for="c-38173235">[-]</label><label class="expand" for="c-38173235">[1 more]</label></div><br/><div class="children"><div class="content">No. Being the first class element in the go language, channel is nothing different from a []byte or a regular struct.<p>The whole purposes of having such built-in channel as a part of the core language is to encourage everyone to use it whenever possible, the reason is dead simple - it is much less likely to shoot yourself in the foot.</div><br/></div></div></div></div></div></div><div id="38169440" class="c"><input type="checkbox" id="c-38169440" checked=""/><div class="controls bullet"><span class="by">cauchyk</span><span>|</span><a href="#38169310">parent</a><span>|</span><a href="#38169717">prev</a><span>|</span><a href="#38172834">next</a><span>|</span><label class="collapse" for="c-38169440">[-]</label><label class="expand" for="c-38169440">[10 more]</label></div><br/><div class="children"><div class="content">Author of the blog here, curious what a better alternative would be in this context. The channel has to be passed around for the producer and consumer to interface with each other. Are there better patterns for this?</div><br/><div id="38170113" class="c"><input type="checkbox" id="c-38170113" checked=""/><div class="controls bullet"><span class="by">atombender</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38169440">parent</a><span>|</span><a href="#38170207">next</a><span>|</span><label class="collapse" for="c-38170113">[-]</label><label class="expand" for="c-38170113">[4 more]</label></div><br/><div class="children"><div class="content">Not the parent, but I personally dislike it when Go libraries use channels in their public APIs, as it forces a specific concurrency model on the consumer; in particular, channels are quite slow, being protected by an internal mutex, so you&#x27;re always paying for the overhead no matter if you need it or not.<p>You also have to be very careful about managing the channel lifecycle. If you&#x27;re not pulling (selecting from) the channel, the library will be permanently stuck. So you must now have a way to tell the library to stop sending, and it must cancel any in-flight send operations if you call producer.Stop() or whatever. In my experience libraries often have bugs in their channel code. It&#x27;s far too easy to get deadlocks with channels that have interdependencies, and you have to be very careful about buffered versus unbuffered channels, as they behave differently.<p>A better API, in my opinion, is to offer a callback or single-method interface. Then the implementer of that callback or interface can choose to use channels internally if they desire, or they can use something else. You get the same backpressure support since you can treat it as synchronous.<p>After all, a channel&#x27;s send interface is essentially just:<p><pre><code>    type Channel[T any] interface {
        Send(T)
    }
</code></pre>
But a &quot;chan T&quot; doesn&#x27;t offer this flexibility.<p>My rule of thumb for channels is that they&#x27;re goroutine glue, not an API primitive. Build APIs out of interfaces, not channels. The only thing that uses channels should be the one that&#x27;s controlling the goroutines, because it&#x27;s the thing that orchestrates them.<p>That said, it&#x27;s not a hard rule. There are places where channels may have their place in a public API, though I&#x27;m not sure I can think of any examples off-hand.</div><br/><div id="38172077" class="c"><input type="checkbox" id="c-38172077" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38170113">parent</a><span>|</span><a href="#38173189">next</a><span>|</span><label class="collapse" for="c-38172077">[-]</label><label class="expand" for="c-38172077">[2 more]</label></div><br/><div class="children"><div class="content">this breaks select to send and is a terrible reduction in capability.<p>you can always wrap channels to make them worse and less capable, but your API should expose the more capable option.</div><br/><div id="38172474" class="c"><input type="checkbox" id="c-38172474" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38172077">parent</a><span>|</span><a href="#38173189">next</a><span>|</span><label class="collapse" for="c-38172474">[-]</label><label class="expand" for="c-38172474">[1 more]</label></div><br/><div class="children"><div class="content">I think it is a matter of preference. For me personally I use raw channels and goroutines all day every day and I really like using them. Channels are a core primitive in golang so I think it is worth getting familiar with them.<p>As you say being able to select is really nice too.</div><br/></div></div></div></div><div id="38173189" class="c"><input type="checkbox" id="c-38173189" checked=""/><div class="controls bullet"><span class="by">tw1984</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38170113">parent</a><span>|</span><a href="#38172077">prev</a><span>|</span><a href="#38170207">next</a><span>|</span><label class="collapse" for="c-38173189">[-]</label><label class="expand" for="c-38173189">[1 more]</label></div><br/><div class="children"><div class="content">&gt; as it forces a specific concurrency model on the consumer<p>I found your excuse above is really nonsense. when your program is in Golang, you&#x27;ve already picked side, the concerned concurrency model has already been chosen by the user.<p>we are not talking about one of random concurrency models, we are talking about channel based sychnronization and communication in golang, if you don&#x27;t want that and consider it as an issue, you shouldn&#x27;t be using golang in the first place.</div><br/></div></div></div></div><div id="38170207" class="c"><input type="checkbox" id="c-38170207" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38169440">parent</a><span>|</span><a href="#38170113">prev</a><span>|</span><a href="#38170356">next</a><span>|</span><label class="collapse" for="c-38170207">[-]</label><label class="expand" for="c-38170207">[1 more]</label></div><br/><div class="children"><div class="content">Looks like the channel field is private in CDCRecordStream, but exposed by GetRecords. The callers mostly loop over Record objects. [1]<p>If I wanted to encapsulate iterating over a channel of Records, maybe it would be something like Go&#x27;s io.Pipe function [2], which returns a PipeReader and PipeWriter? Except that it would work on Records rather than byte streams.<p>I don&#x27;t have enough context to know if the extra encapsulation is a good idea in this case, though.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;search?q=repo%3APeerDB-io%2Fpeerdb%20GetRecords&amp;type=code">https:&#x2F;&#x2F;github.com&#x2F;search?q=repo%3APeerDB-io%2Fpeerdb%20GetR...</a>
[2] <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;io#Pipe" rel="nofollow noreferrer">https:&#x2F;&#x2F;pkg.go.dev&#x2F;io#Pipe</a></div><br/></div></div><div id="38170356" class="c"><input type="checkbox" id="c-38170356" checked=""/><div class="controls bullet"><span class="by">JyB</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38169440">parent</a><span>|</span><a href="#38170207">prev</a><span>|</span><a href="#38169597">next</a><span>|</span><label class="collapse" for="c-38170356">[-]</label><label class="expand" for="c-38170356">[1 more]</label></div><br/><div class="children"><div class="content">Please see this great talk by Bryan C. Mills touching on the subject:
<a href="https:&#x2F;&#x2F;youtu.be&#x2F;5zXAHh5tJqQ?t=421" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;5zXAHh5tJqQ?t=421</a></div><br/></div></div><div id="38169597" class="c"><input type="checkbox" id="c-38169597" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38169440">parent</a><span>|</span><a href="#38170356">prev</a><span>|</span><a href="#38172834">next</a><span>|</span><label class="collapse" for="c-38169597">[-]</label><label class="expand" for="c-38169597">[3 more]</label></div><br/><div class="children"><div class="content">Why have consumers and producers vs doing it all in one goroutine, utilizing some kind of connection pool?</div><br/><div id="38169750" class="c"><input type="checkbox" id="c-38169750" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38169597">parent</a><span>|</span><a href="#38169652">next</a><span>|</span><label class="collapse" for="c-38169750">[-]</label><label class="expand" for="c-38169750">[1 more]</label></div><br/><div class="children"><div class="content">Because then you are consuming, or producing, you can’t do both at the same time. You are either reading from a stream of data, or you are writing it. Using goroutines to separate these allows you to do both at the same time, as soon as data is available on the channel or you receive the signal to stop.</div><br/></div></div><div id="38169652" class="c"><input type="checkbox" id="c-38169652" checked=""/><div class="controls bullet"><span class="by">cauchyk</span><span>|</span><a href="#38169310">root</a><span>|</span><a href="#38169597">parent</a><span>|</span><a href="#38169750">prev</a><span>|</span><a href="#38172834">next</a><span>|</span><label class="collapse" for="c-38169652">[-]</label><label class="expand" for="c-38169652">[1 more]</label></div><br/><div class="children"><div class="content">To get higher throughput we would need one goroutine to pull from the replication slot while the other is pushing to the target. The idea is to keep the Postgres connection useful and reading the slot while also pushing to the target asynchronously.</div><br/></div></div></div></div></div></div><div id="38172834" class="c"><input type="checkbox" id="c-38172834" checked=""/><div class="controls bullet"><span class="by">AlphaSite</span><span>|</span><a href="#38169310">parent</a><span>|</span><a href="#38169440">prev</a><span>|</span><a href="#38171991">next</a><span>|</span><label class="collapse" for="c-38172834">[-]</label><label class="expand" for="c-38172834">[1 more]</label></div><br/><div class="children"><div class="content">I think there are exceptions, for example Gos contexts expose a channel.</div><br/></div></div><div id="38171991" class="c"><input type="checkbox" id="c-38171991" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#38169310">parent</a><span>|</span><a href="#38172834">prev</a><span>|</span><a href="#38169365">next</a><span>|</span><label class="collapse" for="c-38171991">[-]</label><label class="expand" for="c-38171991">[1 more]</label></div><br/><div class="children"><div class="content">channels seemed to fit very nicely in a gRPC streaming API call.  But gRPC is not for everyone.</div><br/></div></div><div id="38169365" class="c"><input type="checkbox" id="c-38169365" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#38169310">parent</a><span>|</span><a href="#38171991">prev</a><span>|</span><a href="#38171362">next</a><span>|</span><label class="collapse" for="c-38169365">[-]</label><label class="expand" for="c-38169365">[1 more]</label></div><br/><div class="children"><div class="content">Seems fine to me. What&#x27;s the problem?</div><br/></div></div></div></div><div id="38169382" class="c"><input type="checkbox" id="c-38169382" checked=""/><div class="controls bullet"><span class="by">DonnyV</span><span>|</span><a href="#38169943">prev</a><span>|</span><a href="#38173203">next</a><span>|</span><label class="collapse" for="c-38169382">[-]</label><label class="expand" for="c-38169382">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if they have a setup without Docker. Not a fan, wonder why they even bother with Docker if they&#x27;re using GO. Thats one of the great things about GO. Easy distributable that works on all platforms.</div><br/><div id="38169464" class="c"><input type="checkbox" id="c-38169464" checked=""/><div class="controls bullet"><span class="by">cauchyk</span><span>|</span><a href="#38169382">parent</a><span>|</span><a href="#38173203">next</a><span>|</span><label class="collapse" for="c-38169464">[-]</label><label class="expand" for="c-38169464">[1 more]</label></div><br/><div class="children"><div class="content">Not all of our code is in Go. PeerDB has multiple components: the workers, the UI and the query layer. Some of which is in Rust, Go and Typescript.<p>While it would certainly be possible to package them into individual binaries, I found it significantly easier to define the stack in a docker compose file with the requisite environment setup.</div><br/></div></div></div></div><div id="38173203" class="c"><input type="checkbox" id="c-38173203" checked=""/><div class="controls bullet"><span class="by">tw1984</span><span>|</span><a href="#38169382">prev</a><span>|</span><label class="collapse" for="c-38173203">[-]</label><label class="expand" for="c-38173203">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think choosing channel itself is an issue, if it works for the said platform, that is great.<p>What I don&#x27;t understand is why there should be such a blog article telling people that you decided to use channel in your go based program? This is like writing an article telling people that you decided to use the MMU when building an OS.</div><br/><div id="38173351" class="c"><input type="checkbox" id="c-38173351" checked=""/><div class="controls bullet"><span class="by">saisrirampur</span><span>|</span><a href="#38173203">parent</a><span>|</span><label class="collapse" for="c-38173351">[-]</label><label class="expand" for="c-38173351">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for posting this question. As explained in the article we started off with pull&#x2F;push model (with configurable batching) and it worked well for streaming to data warehouses, where 30s+ was acceptable latency.<p>We added Queues as a supported target, where one of our users wanted single digit second latency. This is when we introduced channels. We agree that it is a small change. But the latency improvements were significant and wanted to share it with broader programming&#x2F;Go community of Go Channels and the objective impact they can have.</div><br/><div id="38173782" class="c"><input type="checkbox" id="c-38173782" checked=""/><div class="controls bullet"><span class="by">tw1984</span><span>|</span><a href="#38173203">root</a><span>|</span><a href="#38173351">parent</a><span>|</span><label class="collapse" for="c-38173782">[-]</label><label class="expand" for="c-38173782">[2 more]</label></div><br/><div class="children"><div class="content">Pull&#x2F;Push itself is not the problem unless you have stats to back such implied claims. It is far more likely that your highly inefficient Pull&#x2F;Push implementation caused the problem. Without any real insight on why the pull&#x2F;push based approach is slower, there is nothing the &quot;Go community&quot; can get.<p>All valuable details were omitted, e.g. 1) how much data is being moved? a few megabytes? what is the state of art latency? maybe 0.001 second for that? when latency is still seconds huge, what can be further improved, in the go runtime or in the apps? etc<p>A highly efficient pull&#x2F;push model without using go channel can easily beat your 1-5 <i>seconds</i> latency. A crappy implementation using channel can get worse.<p>Delay of several seconds is when you pass on information mouth to mouth, in 2023, that kind of delay doesn&#x27;t justify a blog article on such fancy implementation. I&#x27;d suggest you to delete the implementation to rebuild from ground zero.</div><br/><div id="38174059" class="c"><input type="checkbox" id="c-38174059" checked=""/><div class="controls bullet"><span class="by">saisrirampur</span><span>|</span><a href="#38173203">root</a><span>|</span><a href="#38173782">parent</a><span>|</span><label class="collapse" for="c-38174059">[-]</label><label class="expand" for="c-38174059">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the comment. We will aim to write a more deeper blog on this in the future.<p>We were observing 60&lt;&gt;40 ratio for Pull&#x2F;Push, as specified in the blog and majority of the Push was target data-store (network) bound. So there was less room of optimization on the Go side.<p>The test was done with ~10-15K TPS on Postgres and the target was Azure Event Hubs, which has a limit of 1MB write batch size.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>