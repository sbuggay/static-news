<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719392515377" as="style"/><link rel="stylesheet" href="styles.css?v=1719392515377"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://buttondown.email/hillelwayne/archive/a-brief-introduction-to-interval-arithmetic/">A brief introduction to interval arithmetic</a> <span class="domain">(<a href="https://buttondown.email">buttondown.email</a>)</span></div><div class="subtext"><span>zdw</span> | <span>42 comments</span></div><br/><div><div id="40795964" class="c"><input type="checkbox" id="c-40795964" checked=""/><div class="controls bullet"><span class="by">memalign</span><span>|</span><a href="#40797861">next</a><span>|</span><label class="collapse" for="c-40795964">[-]</label><label class="expand" for="c-40795964">[3 more]</label></div><br/><div class="children"><div class="content">Interval arithmetic powers this graphing calculator I made.<p>The user can enter a formula without solving for y, like “y^y = x^x”. I rearrange into “0 = x^x - y^y”. Then I use interval arithmetic to calculate the result interval of “x^x - y^y” for x = the x-axis range of the graph’s view, y = the y-axis range of the graph’s view. If the result interval contains 0 then I have something to draw. I recursively divide the ranges in half and do a binary search until I find very tiny intervals that contain solutions. I draw those as points on the graph.<p>Example formulas this can handle:<p><a href="https:&#x2F;&#x2F;memalign.github.io&#x2F;m&#x2F;formulagraph&#x2F;index.html?f1(x,t)=r%20=%203&amp;v1=true&amp;f2(x,t)=y%5Ey%20=%20x%5Ex&amp;v2=true&amp;f3(x,t)=(x+5)%5E2+(y-((x+5)%5E2)%5E(1&#x2F;3))%5E2%20%3C%201&amp;v3=true&amp;f4(x,t)=r%20=%202*sin(2*theta)&amp;v4=true&amp;f5(x,t)=(x-5)%5E100%20+%20(y+5)%5E100%20%3C=%202&amp;v5=true&amp;f6(x,t)=-(x-floor(x))%20+%205&amp;v6=true&amp;grid=true&amp;coords=0,0,12&amp;paused=true" rel="nofollow">https:&#x2F;&#x2F;memalign.github.io&#x2F;m&#x2F;formulagraph&#x2F;index.html?f1(x,t)...</a></div><br/><div id="40797478" class="c"><input type="checkbox" id="c-40797478" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40795964">parent</a><span>|</span><a href="#40797861">next</a><span>|</span><label class="collapse" for="c-40797478">[-]</label><label class="expand" for="c-40797478">[2 more]</label></div><br/><div class="children"><div class="content">when i did this i got better efficiency from ternary search<p><a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;aspmisc&#x2F;intervalgraph.html" rel="nofollow">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;aspmisc&#x2F;intervalgraph.html</a></div><br/><div id="40797512" class="c"><input type="checkbox" id="c-40797512" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#40795964">root</a><span>|</span><a href="#40797478">parent</a><span>|</span><a href="#40797861">next</a><span>|</span><label class="collapse" for="c-40797512">[-]</label><label class="expand" for="c-40797512">[1 more]</label></div><br/><div class="children"><div class="content">you may find this interesting if you haven&#x27;t seen it already: <a href="https:&#x2F;&#x2F;fredrikj.net&#x2F;blog&#x2F;2017&#x2F;11&#x2F;new-rigorous-numerical-integration-in-arb&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fredrikj.net&#x2F;blog&#x2F;2017&#x2F;11&#x2F;new-rigorous-numerical-int...</a></div><br/></div></div></div></div></div></div><div id="40797861" class="c"><input type="checkbox" id="c-40797861" checked=""/><div class="controls bullet"><span class="by">usgroup</span><span>|</span><a href="#40795964">prev</a><span>|</span><a href="#40797865">next</a><span>|</span><label class="collapse" for="c-40797861">[-]</label><label class="expand" for="c-40797861">[1 more]</label></div><br/><div class="children"><div class="content">See clpBNR with SWI Prolog for a way to use interval arithmetic in the broader scope of logic programming.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ridgeworks&#x2F;clpBNR">https:&#x2F;&#x2F;github.com&#x2F;ridgeworks&#x2F;clpBNR</a></div><br/></div></div><div id="40797865" class="c"><input type="checkbox" id="c-40797865" checked=""/><div class="controls bullet"><span class="by">AstroJetson</span><span>|</span><a href="#40797861">prev</a><span>|</span><a href="#40797331">next</a><span>|</span><label class="collapse" for="c-40797865">[-]</label><label class="expand" for="c-40797865">[1 more]</label></div><br/><div class="children"><div class="content">The real takeaway was the Frink language. <a href="https:&#x2F;&#x2F;frinklang.org" rel="nofollow">https:&#x2F;&#x2F;frinklang.org</a>.<p>The manual was a great read and the examples he uses are very entertaining.</div><br/></div></div><div id="40797331" class="c"><input type="checkbox" id="c-40797331" checked=""/><div class="controls bullet"><span class="by">Harmohit</span><span>|</span><a href="#40797865">prev</a><span>|</span><a href="#40797094">next</a><span>|</span><label class="collapse" for="c-40797331">[-]</label><label class="expand" for="c-40797331">[1 more]</label></div><br/><div class="children"><div class="content">This article does a great job at explaining interval arithmetic. However, the introduction says<p>&gt;Instead of treating each as exactly 7 feet, we can instead say that each is somewhere between a minimum of 6.9 feet and a maximum of 7.1. We can write this as an interval (6.9, 7.1).<p>Yes we can use an interval to express an uncertainty. However, uncertainties in physical measurements are a little bit more complicated.<p>When I measure something to be 7 plus minus 0.1 feet, what I am saying is that the value of the measured variable is not known for sure. It can be represented by a bell curve centred on 7 and 95% of the area under the curve (95% probability) that the true value lies between 6.9 and 7.1. The value of the measured variable is much more likely to be 7 than 6.9. There is also a small chance that the value lies outside of the 6.9 to 7.1 range.<p>In an interval, there is no probability distribution. It is more like an infinite list of numbers.<p>In practice, interval arithmetic is seldom used for uncertainty analysis for scientific experiments.</div><br/></div></div><div id="40797094" class="c"><input type="checkbox" id="c-40797094" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40797331">prev</a><span>|</span><a href="#40797422">next</a><span>|</span><label class="collapse" for="c-40797094">[-]</label><label class="expand" for="c-40797094">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You measure the wall with a ruler and get 7 feet, then you measure the couch and get 7 feet. Can you fit the couch against that wall?<p>Normally, yes: the couches generally have somewhat squishy... stuffing? filling?.. which hang off the wooden frame, so you generally can squeeze a couch from the sides a bit to fit it into slightly narrower space.<p>&gt; say 1&#x2F;10th of a foot.<p>This is unholy. Either say &quot;an inch&quot; for this hypothetical scenario, or use some decimal-based measurement system.</div><br/><div id="40797248" class="c"><input type="checkbox" id="c-40797248" checked=""/><div class="controls bullet"><span class="by">wegfawefgawefg</span><span>|</span><a href="#40797094">parent</a><span>|</span><a href="#40797422">next</a><span>|</span><label class="collapse" for="c-40797248">[-]</label><label class="expand" for="c-40797248">[1 more]</label></div><br/><div class="children"><div class="content">a foot divides well into 1&#x2F;2,1&#x2F;3,1&#x2F;4,1&#x2F;6, 1&#x2F;12 too. and he picked 1&#x2F;10.</div><br/></div></div></div></div><div id="40797422" class="c"><input type="checkbox" id="c-40797422" checked=""/><div class="controls bullet"><span class="by">drsopp</span><span>|</span><a href="#40797094">prev</a><span>|</span><a href="#40795723">next</a><span>|</span><label class="collapse" for="c-40797422">[-]</label><label class="expand" for="c-40797422">[2 more]</label></div><br/><div class="children"><div class="content">There are several ways to handle uncertainties and propagation of error. Interval arithmetic is one of the simpler methods. Some Python packages that focus on this problem:<p><a href="https:&#x2F;&#x2F;pythonhosted.org&#x2F;uncertainties&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pythonhosted.org&#x2F;uncertainties&#x2F;</a><p><a href="https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;soerp" rel="nofollow">https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;soerp</a><p><a href="https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;mcerp" rel="nofollow">https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;mcerp</a><p>This last one is one of my favorite Python libraries. My hunch is that it is highly underrated.<p>I am still looking for&#x2F;consider implementing error propagation as probability distributions where these are symbolic.</div><br/><div id="40797764" class="c"><input type="checkbox" id="c-40797764" checked=""/><div class="controls bullet"><span class="by">geokon</span><span>|</span><a href="#40797422">parent</a><span>|</span><a href="#40795723">next</a><span>|</span><label class="collapse" for="c-40797764">[-]</label><label class="expand" for="c-40797764">[1 more]</label></div><br/><div class="children"><div class="content">You seem knowledgeable so maybe you could give me some advice.<p>I developed a new method using SVD&#x2F;PCA with some basis rotation method. I can potentially characterize or estimate errors on my input data, but I have no idea how to propagate these errors to my basis vectors. I&#x27;m at a bit of a loss as to where to look from here. My only idea is to bootstrap... But that&#x27;s a bit lame :) and not very rigorous</div><br/></div></div></div></div><div id="40795723" class="c"><input type="checkbox" id="c-40795723" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#40797422">prev</a><span>|</span><a href="#40795598">next</a><span>|</span><label class="collapse" for="c-40795723">[-]</label><label class="expand" for="c-40795723">[2 more]</label></div><br/><div class="children"><div class="content">This is a good article!<p>In ClickHouse, interval arithmetic is applied to index analysis. A sparse index consists of granules, and each granule is an interval of tuples in lexicographic order. This interval is decomposed into a union of hyperrectangles. Conditions such as comparisons, logic operators, and many other functions are evaluated on these hyperrectangles, yielding boolean intervals. Boolean intervals represent ternary logic (always true, always false, can be true or false). Interesting tricks include: applying functions that are monotonic on ranges (for example, the function &quot;day of month&quot; is monotonic as long as the month does not change), calculating function preimages on intervals, and even calculating preimages of n-ary functions, which is useful for space-filling curves, such as Morton or Hilbert curves.<p>Check for more details: <a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;blob&#x2F;master&#x2F;src&#x2F;Storages&#x2F;MergeTree&#x2F;KeyCondition.h">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;blob&#x2F;master&#x2F;src&#x2F;Sto...</a><p>Or see examples, such as <a href="https:&#x2F;&#x2F;adsb.exposed&#x2F;" rel="nofollow">https:&#x2F;&#x2F;adsb.exposed&#x2F;</a></div><br/><div id="40797129" class="c"><input type="checkbox" id="c-40797129" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#40795723">parent</a><span>|</span><a href="#40795598">next</a><span>|</span><label class="collapse" for="c-40797129">[-]</label><label class="expand" for="c-40797129">[1 more]</label></div><br/><div class="children"><div class="content">Clockhouse is real smart, I wish it spoke real SQL, and not some parody of SQL like it currently does.</div><br/></div></div></div></div><div id="40795598" class="c"><input type="checkbox" id="c-40795598" checked=""/><div class="controls bullet"><span class="by">thomassmith65</span><span>|</span><a href="#40795723">prev</a><span>|</span><a href="#40795195">next</a><span>|</span><label class="collapse" for="c-40795598">[-]</label><label class="expand" for="c-40795598">[1 more]</label></div><br/><div class="children"><div class="content">The article links to a &quot;Gustafson vs Kahan&quot; debate transcript. The video is more entertaining: <a href="https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=KEAKYDyUua4" rel="nofollow">https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=KEAKYDyUua4</a></div><br/></div></div><div id="40795195" class="c"><input type="checkbox" id="c-40795195" checked=""/><div class="controls bullet"><span class="by">civilized</span><span>|</span><a href="#40795598">prev</a><span>|</span><a href="#40797214">next</a><span>|</span><label class="collapse" for="c-40795195">[-]</label><label class="expand" for="c-40795195">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Why x^2 isn&#x27;t always x * x<p>It turns out he&#x27;s claiming they&#x27;re different if x^2 is interpreted as squaring each element in the interval x, while x * x is interpreted as a cross product: the interval obtained by multiplying all pairs of elements in the interval. But I haven&#x27;t ever seen anyone use x^2 to mean pointwise squaring on an interval x. Is that some kind of standard notation?</div><br/><div id="40796238" class="c"><input type="checkbox" id="c-40796238" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40795195">parent</a><span>|</span><a href="#40795476">next</a><span>|</span><label class="collapse" for="c-40796238">[-]</label><label class="expand" for="c-40796238">[1 more]</label></div><br/><div class="children"><div class="content">It makes sense if instead of thinking about intervals, you think about the supports of random variables[1]. Given two independent random variables, X is not indepent of itself, so supp(X) = supp(Y) does not imply supp(X * X) = supp(X * Y).<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Support_(mathematics)#In_probability_and_measure_theory" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Support_(mathematics)#In_proba...</a></div><br/></div></div><div id="40795476" class="c"><input type="checkbox" id="c-40795476" checked=""/><div class="controls bullet"><span class="by">Twisol</span><span>|</span><a href="#40795195">parent</a><span>|</span><a href="#40796238">prev</a><span>|</span><a href="#40797110">next</a><span>|</span><label class="collapse" for="c-40795476">[-]</label><label class="expand" for="c-40795476">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Pointwise squaring on an interval x&quot; is just a weird way of describing the usual function f(x) = x^2 with domain restricted to an interval. It&#x27;s pointwise because that&#x27;s how functions f : R -&gt; R are defined: given a point, or value, of the domain, give me a new point in the codomain.<p>If you think of `x` as a whole interval unto itself, and not just a single point, then I think the options become more interesting. The most natural product on two sets is indeed the cross product; but for intervals, I can imagine defining a common parameterization over both intervals and then multiplying pointwise up to that parameterization.</div><br/></div></div><div id="40797110" class="c"><input type="checkbox" id="c-40797110" checked=""/><div class="controls bullet"><span class="by">ylk</span><span>|</span><a href="#40795195">parent</a><span>|</span><a href="#40795476">prev</a><span>|</span><a href="#40795477">next</a><span>|</span><label class="collapse" for="c-40797110">[-]</label><label class="expand" for="c-40797110">[1 more]</label></div><br/><div class="children"><div class="content">Yes it’s standard for interval arithmetic. 
Have a look at the interval operations section: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Interval_arithmetic" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Interval_arithmetic</a></div><br/></div></div><div id="40795477" class="c"><input type="checkbox" id="c-40795477" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40795195">parent</a><span>|</span><a href="#40797110">prev</a><span>|</span><a href="#40796754">next</a><span>|</span><label class="collapse" for="c-40795477">[-]</label><label class="expand" for="c-40795477">[1 more]</label></div><br/><div class="children"><div class="content">no, it&#x27;s just a common limitation of implementations of interval arithmetic.  things like affine arithmetic solve it</div><br/></div></div><div id="40796754" class="c"><input type="checkbox" id="c-40796754" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#40795195">parent</a><span>|</span><a href="#40795477">prev</a><span>|</span><a href="#40796955">next</a><span>|</span><label class="collapse" for="c-40796754">[-]</label><label class="expand" for="c-40796754">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is that some kind of standard notation?<p>Yes, it&#x27;s just algebra.</div><br/></div></div><div id="40796955" class="c"><input type="checkbox" id="c-40796955" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40795195">parent</a><span>|</span><a href="#40796754">prev</a><span>|</span><a href="#40797214">next</a><span>|</span><label class="collapse" for="c-40796955">[-]</label><label class="expand" for="c-40796955">[1 more]</label></div><br/><div class="children"><div class="content">Yeah it sounds like something he&#x27;s made up. For matrices x^2 is just x*x, not element-wise power (which if you want to be deliberately confusing is also known as Hadamard power). The latter is apparently written like this: <a href="https:&#x2F;&#x2F;math.stackexchange.com&#x2F;a&#x2F;2749724&#x2F;60289" rel="nofollow">https:&#x2F;&#x2F;math.stackexchange.com&#x2F;a&#x2F;2749724&#x2F;60289</a></div><br/></div></div></div></div><div id="40797214" class="c"><input type="checkbox" id="c-40797214" checked=""/><div class="controls bullet"><span class="by">_Microft</span><span>|</span><a href="#40795195">prev</a><span>|</span><a href="#40796519">next</a><span>|</span><label class="collapse" for="c-40797214">[-]</label><label class="expand" for="c-40797214">[1 more]</label></div><br/><div class="children"><div class="content">If you are curious about this then you might also want to have a look at &quot;propagation of uncertainty&quot;.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Propagation_of_uncertainty" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Propagation_of_uncertainty</a> (warning: contains math symbols)</div><br/></div></div><div id="40796519" class="c"><input type="checkbox" id="c-40796519" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40797214">prev</a><span>|</span><a href="#40795220">next</a><span>|</span><label class="collapse" for="c-40796519">[-]</label><label class="expand" for="c-40796519">[4 more]</label></div><br/><div class="children"><div class="content">One detail of interval arithmetic not mentioned in TFA but of much consequence in the context in which we have to contend with in Ardour is ...<p>When you ask if a single non-interval lies within a given interval, the answer is yes or no (with a given resolution).<p>When you ask what the relationship between 2 intervals is, there are multiple answers (*). In a given problem domain, each one may have different semantic implications.<p>(*)<p><pre><code>  interval 1 is larger than interval 2 and fully includes it
  interval 2 is larger than interval 1 and fully includes it
  interval 1 begins before interval 2
  interval 1 ends after interval 2
  interval 2 begins before interval 1
  interval 2 ends after interval 1
  interval 1 and interval 2 are disjoint
  interval 1 and interval 2 are equivalent at a given resolution</code></pre></div><br/><div id="40796882" class="c"><input type="checkbox" id="c-40796882" checked=""/><div class="controls bullet"><span class="by">mikhailfranco</span><span>|</span><a href="#40796519">parent</a><span>|</span><a href="#40796696">next</a><span>|</span><label class="collapse" for="c-40796882">[-]</label><label class="expand" for="c-40796882">[1 more]</label></div><br/><div class="children"><div class="content">Allen&#x27;s interval algebra describes the 2*6+1 = 13 relations:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Allen&#x27;s_interval_algebra" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Allen&#x27;s_interval_algebra</a><p>It&#x27;s possible to build a graph where the relations are nodes, and the edges are possible smooth operations on the intervals (e.g. translation). Then you have a state machine for smooth system evolution.</div><br/></div></div><div id="40796696" class="c"><input type="checkbox" id="c-40796696" checked=""/><div class="controls bullet"><span class="by">simpaticoder</span><span>|</span><a href="#40796519">parent</a><span>|</span><a href="#40796882">prev</a><span>|</span><a href="#40795220">next</a><span>|</span><label class="collapse" for="c-40796696">[-]</label><label class="expand" for="c-40796696">[2 more]</label></div><br/><div class="children"><div class="content">This problem came up for me when writing a tool to help an author index his work. He wanted to be able to enter reference ranges for a term and then combine, including disjoint ones, into a single entry. (There was also a roman numeral problem irrelevant here).<p>This has also come up for me in two dimensions when dealing with overlapping rectangles. For some reason the complexity of it surprised me both times. Sadly computing these cases is a straight-forward slog in 1-D; you can however reuse the solution for higher dimensions in a nice way.</div><br/><div id="40796930" class="c"><input type="checkbox" id="c-40796930" checked=""/><div class="controls bullet"><span class="by">mikhailfranco</span><span>|</span><a href="#40796519">root</a><span>|</span><a href="#40796696">parent</a><span>|</span><a href="#40795220">next</a><span>|</span><label class="collapse" for="c-40796930">[-]</label><label class="expand" for="c-40796930">[1 more]</label></div><br/><div class="children"><div class="content">Most spatial databases use the R-Tree or one of its variants:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;R-tree" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;R-tree</a><p>e.g. PostGIS has GiST-RTree:<p><a href="https:&#x2F;&#x2F;postgis.net&#x2F;docs&#x2F;manual-3.2&#x2F;using_postgis_dbmanagement.html#build-indexes" rel="nofollow">https:&#x2F;&#x2F;postgis.net&#x2F;docs&#x2F;manual-3.2&#x2F;using_postgis_dbmanageme...</a></div><br/></div></div></div></div></div></div><div id="40795220" class="c"><input type="checkbox" id="c-40795220" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#40796519">prev</a><span>|</span><a href="#40796557">next</a><span>|</span><label class="collapse" for="c-40795220">[-]</label><label class="expand" for="c-40795220">[7 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t the overdetermination problem be solved by tagging intervals with their ids? E.g., &quot;x*x&quot; should be resolved as &quot;(x, i[-3, 3])*(x, i[-3, 3])&quot; and &quot;i[-3, 3]*i[-3, 3]&quot; as &quot;(nil, i[-3, 3])*(nil, i[-3, 3])&quot;. Since the tag matches in the first expression and not in the second (nil != nil) different rules could be used.<p>Btw this comes up <i>a lot</i> in compiler design for dynamic languages since constraining the value ranges of variables means that you can implement them more efficiently. In static languages it is not as important since the domains of most variables are either given to you or inferred by the type system.<p>Also an interesting head scratcher is how to implement interval arithmetic for modulus: i[3,6] % i[3, 6] = ???*</div><br/><div id="40797479" class="c"><input type="checkbox" id="c-40797479" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#40795220">parent</a><span>|</span><a href="#40795478">next</a><span>|</span><label class="collapse" for="c-40797479">[-]</label><label class="expand" for="c-40797479">[3 more]</label></div><br/><div class="children"><div class="content">this requires all terms to be represented symbolically, which &#x27;works&#x27;, but now you need a full-blown symbolic rewrite engine to try to simplify things.  very reasonable for an optimiser but not so much for numerics.  for numerics a more common approach is interval mincing.  we have a function f(x) = x*x, and try to apply f([-3 3]).  we can &#x27;mince&#x27; the inner interval and say that (e.g.) [-3 3] = [-3 -1] U [-1 1] U [1 3].  so we have f([-3 -1] U [-1 1] U [1 3]); distribute function application over U (which is sound) to get f([-3 -1]) U f([-1 1]) U f([1 3]), which is obviously tighter than f([-3 3]).  we picked a subinterval size of 2, but can shrink it arbitrarily until we&#x27;re satisfied with the result.  this technique is essentially a form of case analysis, and can also be applied to optimisers&#x2F;static analysers (complementarily to simplifying rewrites)</div><br/><div id="40797520" class="c"><input type="checkbox" id="c-40797520" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40795220">root</a><span>|</span><a href="#40797479">parent</a><span>|</span><a href="#40795478">next</a><span>|</span><label class="collapse" for="c-40797520">[-]</label><label class="expand" for="c-40797520">[2 more]</label></div><br/><div class="children"><div class="content">affine arithmetic does not need a full-blown symbolic rewrite engine, though it too sometimes produces overbroad intervals</div><br/><div id="40797620" class="c"><input type="checkbox" id="c-40797620" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#40795220">root</a><span>|</span><a href="#40797520">parent</a><span>|</span><a href="#40795478">next</a><span>|</span><label class="collapse" for="c-40797620">[-]</label><label class="expand" for="c-40797620">[1 more]</label></div><br/><div class="children"><div class="content">so a middle ground (as many pseudo-symbolic approaches).  glanced at wikipedia—this seems not dissimilar conceptually to the abstract domain of polyhedra, in that it&#x27;s symbolic but has a flat structure and expresses only linear relationships.  of course, polyhedra are exponential where affine arithmetic is quadratic (overall space in number of terms), and polyhedra are global where affine is local (therefore easier to implement as a library, but no sharing).  more missed connections between numerical analysis and program analysis?  (meh but no sharing probably means affine generally loses for a given resource budget.  would still be interesting to try though)</div><br/></div></div></div></div></div></div><div id="40795478" class="c"><input type="checkbox" id="c-40795478" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40795220">parent</a><span>|</span><a href="#40797479">prev</a><span>|</span><a href="#40796557">next</a><span>|</span><label class="collapse" for="c-40795478">[-]</label><label class="expand" for="c-40795478">[3 more]</label></div><br/><div class="children"><div class="content">this is basically how affine arithmetic works.  but in interval arithmetic or modal interval arithmetic the representation of a float is two floats, and in affine arithmetic the representation of a float is a potentially unboundedly large set of float coefficients, none of which can be safely ignored, so there are some drawbacks to this approach<p>i&#x27;m not sure why wayne doesn&#x27;t mention affine arithmetic and modal interval arithmetic in this post; i&#x27;d think they were relevant</div><br/><div id="40796391" class="c"><input type="checkbox" id="c-40796391" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40795220">root</a><span>|</span><a href="#40795478">parent</a><span>|</span><a href="#40796557">next</a><span>|</span><label class="collapse" for="c-40796391">[-]</label><label class="expand" for="c-40796391">[2 more]</label></div><br/><div class="children"><div class="content">&gt; none of which can be safely ignored<p>Or more accurately speaking, they can be ignored but at some expense of accuracy. (You can always approximate every variable with a (-inf, +inf) interval!) There are several working ways to &quot;compress&quot; affine variables when they get too many.<p>Probably a worse problem with AA is that every multiplication introduces a new variable, so it can be very frequent to head into the maximum number of variables set for the reasonable performance...</div><br/><div id="40797528" class="c"><input type="checkbox" id="c-40797528" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40795220">root</a><span>|</span><a href="#40796391">parent</a><span>|</span><a href="#40796557">next</a><span>|</span><label class="collapse" for="c-40797528">[-]</label><label class="expand" for="c-40797528">[1 more]</label></div><br/><div class="children"><div class="content">agreed. i find reduced affine arithmetic the most appealing, but haven&#x27;t tried it</div><br/></div></div></div></div></div></div></div></div><div id="40796557" class="c"><input type="checkbox" id="c-40796557" checked=""/><div class="controls bullet"><span class="by">tristramb</span><span>|</span><a href="#40795220">prev</a><span>|</span><a href="#40795337">next</a><span>|</span><label class="collapse" for="c-40796557">[-]</label><label class="expand" for="c-40796557">[2 more]</label></div><br/><div class="children"><div class="content">The 68040 CPU had two rounding modes to support interval arithmetic.<p>From the M68040 User’s Manual (<a href="https:&#x2F;&#x2F;www.nxp.com&#x2F;docs&#x2F;en&#x2F;reference-manual&#x2F;MC68040UM.pdf" rel="nofollow">https:&#x2F;&#x2F;www.nxp.com&#x2F;docs&#x2F;en&#x2F;reference-manual&#x2F;MC68040UM.pdf</a>):<p>&quot;The processor supports four rounding modes specified by the IEEE 754 standard. These modes  are: round to nearest (RN), round toward zero (RZ), round  toward  plus  infinity (RP), and round toward minus infinity (RM). The RP and RM modes are directed rounding modes that are useful in interval arithmetic.&quot;</div><br/><div id="40797506" class="c"><input type="checkbox" id="c-40797506" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40796557">parent</a><span>|</span><a href="#40795337">next</a><span>|</span><label class="collapse" for="c-40797506">[-]</label><label class="expand" for="c-40797506">[1 more]</label></div><br/><div class="children"><div class="content">these originated i think on the 8087 and are widely supported today, including all amd64 and arm designs</div><br/></div></div></div></div><div id="40796887" class="c"><input type="checkbox" id="c-40796887" checked=""/><div class="controls bullet"><span class="by">zeehio</span><span>|</span><a href="#40795337">prev</a><span>|</span><a href="#40796497">next</a><span>|</span><label class="collapse" for="c-40796887">[-]</label><label class="expand" for="c-40796887">[1 more]</label></div><br/><div class="children"><div class="content">Using intervals for measurements has some limitations. But for many use cases we do not need more than intervals, so it&#x27;s nice to have convenient tools for them. Intervals are a convenient model.<p>That&#x27;s because measurements are complicated.<p>You use a ruler (or some other instrument) to measure something and get a value x.<p>You are happy.<p>Then for some reason you decide to repeat the measurement and you get a slightly different value. And problems start.<p>You decide to write down all the values you get. You are happy again.<p>Shortly after, you realise you have to use those values in calculations and you just want &quot;one representative value&quot;, so you take the average or &quot;the most common value&quot; or some other aggregation, use your intuition!<p>Things start to go wrong when you have to take a decision by setting some threshold like &quot;I do this if my value is above a threshold&quot;. Because the actual value may be different from your averaged number.<p>So you take the standard deviation and call it the uncertainty x±s.<p>But one day you realise that your measurements are not symmetric. You start by saying &quot;instead of x±s, I will use different upper and lower bounds to define an interval&quot;.<p>For instance some things are measured on a log scale and you have a measure like 100±&quot;one order of magnitude&quot; which is &quot;100, but may be between 10 and 1000&quot;.<p>Then you add a confidence, because you are not 100% certain you actually are in that range. Your measurement becomes &quot;with 95% confidence I can say the measure is in [10,1000], with an expected value of 100&quot;.<p>Then you want to combine and aggregate those intervals and you realise they within the intervals their regions are not uniform, you actually have a probability distribution.<p>In the simple case is a Gaussian distribution, described with mean and variance. It can also be a binomial (a &quot;p out of n cases&quot; scenario). Or a lognormal like un our 10-1000 example.<p>And now for each measure you take you need to understand what probability distribution it follows and estimate its parameters.<p>And that parameter estimation is a measure, so it has confidence intervals as well.<p>At this point adding two measurements becomes not so easy anymore... But don&#x27;t panic!<p>The nice part about all of this is that usually you don&#x27;t care about precise error estimates, because you can live with bounding errors covering a worst case scenario.<p>And you can use the Central Limit Theorem (sometimes it is abused rather than used) to simplify calculations.<p>It is a rabbit hole and you need to know how deep you want to dig. Intervals are usually convenient enough.</div><br/></div></div><div id="40796497" class="c"><input type="checkbox" id="c-40796497" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#40796887">prev</a><span>|</span><a href="#40796269">next</a><span>|</span><label class="collapse" for="c-40796497">[-]</label><label class="expand" for="c-40796497">[1 more]</label></div><br/><div class="children"><div class="content">The x*x vs. x^2 issue that the author presents seems contrived. Interval arithmetic is just a specialized case of arithmetic on random variables. If two values are uncorrelated, why would you use the same variable for them? The ambiguity could be trivially resolved by representing the problem as x*x vs. x*y, where x = (3, 3) and y = (3, 3).</div><br/></div></div><div id="40796269" class="c"><input type="checkbox" id="c-40796269" checked=""/><div class="controls bullet"><span class="by">kerkeslager</span><span>|</span><a href="#40796497">prev</a><span>|</span><a href="#40795111">next</a><span>|</span><label class="collapse" for="c-40796269">[-]</label><label class="expand" for="c-40796269">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve experimented on a few systems to apply interval arithmetic to type inference, i.e.<p><pre><code>   &#x2F;&#x2F; starRating is an int&lt;0,5&gt;, meaning
   &#x2F;&#x2F; integer between 0 and 5 inclusive.
   let starRating = console.readInt&lt;0,5&gt;(&quot;How many stars do you rate this movie?&quot;);
   db.addStarRating(starRating);

   &#x2F;&#x2F; starRatingList is a list&lt;int&lt;0,5&gt;&gt;
   let starRatingList = db.readStarRatings(movie);

   &#x2F;&#x2F; totalStarRatings is an int&lt;0,5*starRatingList.length&gt;
   &#x2F;&#x2F; this type can&#x27;t be sized at compile time, but we can still check it!
   let totalStarRatings = sum(starRatings);

   &#x2F;&#x2F; avgStarRating is a very difficult type, because we need to either have
   &#x2F;&#x2F; a fraction type that&#x27;s slow, or some handling of rounding&#x2F;truncating
   &#x2F;&#x2F; when we do division. So now we&#x27;re dealing with 3 intervals: min&#x2F;max,
   &#x2F;&#x2F; min&#x2F;max precision, and min&#x2F;max error.
   let avgStarRating = totalStarRatings &#x2F; starRatingList.length;</code></pre></div><br/></div></div><div id="40795111" class="c"><input type="checkbox" id="c-40795111" checked=""/><div class="controls bullet"><span class="by">grahar64</span><span>|</span><a href="#40796269">prev</a><span>|</span><a href="#40797513">next</a><span>|</span><label class="collapse" for="c-40795111">[-]</label><label class="expand" for="c-40795111">[1 more]</label></div><br/><div class="children"><div class="content">Great job at explaining the complexities in this topic.</div><br/></div></div><div id="40797513" class="c"><input type="checkbox" id="c-40797513" checked=""/><div class="controls bullet"><span class="by">jenniferjames</span><span>|</span><a href="#40795111">prev</a><span>|</span><a href="#40796994">next</a><span>|</span><label class="collapse" for="c-40797513">[-]</label><label class="expand" for="c-40797513">[1 more]</label></div><br/><div class="children"><div class="content">Really informative content it is.
<a href="https:&#x2F;&#x2F;likelyabusiness.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;likelyabusiness.com&#x2F;</a></div><br/></div></div><div id="40796994" class="c"><input type="checkbox" id="c-40796994" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#40797513">prev</a><span>|</span><label class="collapse" for="c-40796994">[-]</label><label class="expand" for="c-40796994">[1 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t intervals a rather limited substitute for distributions (of error)? Using the intervals as if they <i>and</i> their joint distributions are uniform doesn’t make much sense to me. Perhaps if you really need to know the limits, but then as was mentioned elsewhere, the interval widths grow very quickly.</div><br/></div></div></div></div></div></div></div></body></html>