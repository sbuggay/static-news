<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701421258731" as="style"/><link rel="stylesheet" href="styles.css?v=1701421258731"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.logikalsolutions.com/wordpress/information-technology/smart-pointers/">The Myth of Smart Pointers</a> <span class="domain">(<a href="https://www.logikalsolutions.com">www.logikalsolutions.com</a>)</span></div><div class="subtext"><span>jandeboevrie</span> | <span>20 comments</span></div><br/><div><div id="38480508" class="c"><input type="checkbox" id="c-38480508" checked=""/><div class="controls bullet"><span class="by">sgift</span><span>|</span><a href="#38480344">next</a><span>|</span><label class="collapse" for="c-38480508">[-]</label><label class="expand" for="c-38480508">[2 more]</label></div><br/><div class="children"><div class="content">Gee, another rant which can be summed up by &quot;all abstractions are leaky&quot;. Congratulations for the insight, unfortunately it&#x27;s not new, so not too interesting, but let&#x27;s still dive into it.<p>So, smart pointers are leaky, so use normal pointers instead. If we ignored all the problems that normal pointers have this may even look reasonable. After all, if we have a leaky abstraction, maybe we could just use the non-leaky foundation? But pointers have problems. Use-after-free, double-free, memory leaks. All of this happen with pointers <i>far more often</i>. Which is a bit of a problem if you want to write reliable software.<p>Are smart pointers a perfect solution? No. Are they better than &quot;use raw pointers everywhere, cause in some cases the abstraction provided by smart pointers will fail?&quot;. Well .. yeah.</div><br/></div></div><div id="38480344" class="c"><input type="checkbox" id="c-38480344" checked=""/><div class="controls bullet"><span class="by">greiskul</span><span>|</span><a href="#38480508">prev</a><span>|</span><a href="#38480558">next</a><span>|</span><label class="collapse" for="c-38480344">[-]</label><label class="expand" for="c-38480344">[1 more]</label></div><br/><div class="children"><div class="content">Well, yeah, a language feature to improve program correctness won&#x27;t work if you use it wrong. But in both examples, just from the interfaces, this should be caught in code review without even having to read the libraries being called. Anytime you take a raw pointer to a smart pointer owned object, you should question yourself, what happens to the lifetime of my object. Because you just took the safety off C++s classic footgun of memory management, and if you are not extremely careful, you are going to lose a foot.</div><br/></div></div><div id="38480558" class="c"><input type="checkbox" id="c-38480558" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38480344">prev</a><span>|</span><a href="#38480562">next</a><span>|</span><label class="collapse" for="c-38480558">[-]</label><label class="expand" for="c-38480558">[5 more]</label></div><br/><div class="children"><div class="content">I get the idea the author has never worked with a c++ codebase of anywhere close to 1000 lines. I can manage raw new and delete on that scale. As a senor developer with a couple decades of experience I can probably pull it off for 10000 lines of code. But I work with 20 million lines of c++ and there is no way for a human to get manual memory management right at that scale without help from smart pointers. Sometimes I need an intrusive smart pointer which I write manually, but I still confine it to a few thousand lines at most that I need to audit to ensure it is right.</div><br/><div id="38481291" class="c"><input type="checkbox" id="c-38481291" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#38480558">parent</a><span>|</span><a href="#38480562">next</a><span>|</span><label class="collapse" for="c-38481291">[-]</label><label class="expand" for="c-38481291">[4 more]</label></div><br/><div class="children"><div class="content">My first advisor would write code like this:<p><pre><code>    std::vector&lt;float*&gt; myVec;
    myVec.resize(1024);
    for (int i = 0; i &lt; 1024; ++i) myVec[i] = new float(0);
</code></pre>
There were no `delete`s or `free`s <i>anywhere</i> in the codebase. I asked him what he was thinking and his response was: (1) it&#x27;s not a server, and I know there&#x27;s enough room on the computer; and, (2) the OS will free all of the memory for me, anyways.</div><br/><div id="38484483" class="c"><input type="checkbox" id="c-38484483" checked=""/><div class="controls bullet"><span class="by">arghnoname</span><span>|</span><a href="#38480558">root</a><span>|</span><a href="#38481291">parent</a><span>|</span><a href="#38481600">next</a><span>|</span><label class="collapse" for="c-38484483">[-]</label><label class="expand" for="c-38484483">[1 more]</label></div><br/><div class="children"><div class="content">He was probably right. When I write small, short-lived programs I mind my memory because it&#x27;s a muscle I need to retain and I don&#x27;t want to pick up bad habits.<p>For an academic writing a one-off program just to get something done, all manner of bad practice is if not desirable, at least acceptable.</div><br/></div></div><div id="38481600" class="c"><input type="checkbox" id="c-38481600" checked=""/><div class="controls bullet"><span class="by">Tommstein</span><span>|</span><a href="#38480558">root</a><span>|</span><a href="#38481291">parent</a><span>|</span><a href="#38484483">prev</a><span>|</span><a href="#38480562">next</a><span>|</span><label class="collapse" for="c-38481600">[-]</label><label class="expand" for="c-38481600">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the old story about how memory leaks on missiles don&#x27;t matter as long as you&#x27;re leaking slow enough to not run out of memory before they explode.</div><br/><div id="38482120" class="c"><input type="checkbox" id="c-38482120" checked=""/><div class="controls bullet"><span class="by">thechao</span><span>|</span><a href="#38480558">root</a><span>|</span><a href="#38481600">parent</a><span>|</span><a href="#38480562">next</a><span>|</span><label class="collapse" for="c-38482120">[-]</label><label class="expand" for="c-38482120">[1 more]</label></div><br/><div class="children"><div class="content">I worked with a guy — he&#x27;s long deceased — whose doctoral dissertation was for missile guidance systems back in the 60s. The title was something like &quot;supersonic ballistic landing trajectories for light civilian aircraft&quot;; since, obviously, he couldn&#x27;t publish it as &quot;... for ICBMs&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="38480562" class="c"><input type="checkbox" id="c-38480562" checked=""/><div class="controls bullet"><span class="by">calamari4065</span><span>|</span><a href="#38480558">prev</a><span>|</span><a href="#38484296">next</a><span>|</span><label class="collapse" for="c-38480562">[-]</label><label class="expand" for="c-38480562">[2 more]</label></div><br/><div class="children"><div class="content">So his argument is smart pointers are useless bullshit because external libraries that don&#x27;t support smart pointers don&#x27;t support smart pointers.<p>Yeah okay, sure.</div><br/><div id="38484575" class="c"><input type="checkbox" id="c-38484575" checked=""/><div class="controls bullet"><span class="by">afc</span><span>|</span><a href="#38480562">parent</a><span>|</span><a href="#38484296">next</a><span>|</span><label class="collapse" for="c-38484575">[-]</label><label class="expand" for="c-38484575">[1 more]</label></div><br/><div class="children"><div class="content">And when he manages to show that smart pointers can be misused and lead to obscure crashes, what&#x27;s his solution? Just use raw pointers.<p>Those can&#x27;t be misused ... right?</div><br/></div></div></div></div><div id="38484296" class="c"><input type="checkbox" id="c-38484296" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#38480562">prev</a><span>|</span><a href="#38480083">next</a><span>|</span><label class="collapse" for="c-38484296">[-]</label><label class="expand" for="c-38484296">[1 more]</label></div><br/><div class="children"><div class="content">Am I misunderstanding something or does the author seem to be conflating garbage collection with the automatic memory management C++ enables via smart pointers? Those are two entirely different things.</div><br/></div></div><div id="38480083" class="c"><input type="checkbox" id="c-38480083" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38484296">prev</a><span>|</span><a href="#38484562">next</a><span>|</span><label class="collapse" for="c-38480083">[-]</label><label class="expand" for="c-38480083">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Someone thinks it is a good idea to use Smart Pointers then passes the value to library functions written in C and other languages</i><p>If you got a low-level pointer out of the smart pointer container in order to pass to a foreign library, then you&#x27;re not strictly using smart pointers. You violated the encapsulation in order to get a &quot;dumb&quot; pointer out, and the issue is related to that.<p>This is a complete strawman.<p>&quot;Don&#x27;t use a garbage collected, managed languages, they are a myth. Why? Because a pointer to some garbage-collected object ends up in foreign libraries written in C, which can hang on to it past reclamation ...&quot;<p>Well, gee whiz, you will just have to learn about the exact sharing situation with the foreign code (how long does it retain the object) and do what is necessary.<p>&gt; <i>Make them raw pointers and delete them when you know it is safe.</i><p>That&#x27;s completely stupid. If you know when it&#x27;s safe, it means you must know when the third party library is no longer using them. If you know that, you work that knowledge into the smart pointer solution.<p>Smart pointers, by themselves, have their own idea of when it is safe to delete something. That idea is very clear and obvious. If it doesn&#x27;t match the reality of what is safe when, then you have to augment the logic. That&#x27;s it.<p>If a foreign library directly accesses an object that you track with a smart pointer, you can create a proxy object representing that library, and that proxy object can hold on to a smart pointer on behalf of the foreign library.<p>The complexity of dealing with the foreign library could be entirely minor (and self-contained) compared to the overall resource management problem of that smart pointer class; you could be making a lot of unnecessary work for yourself (and future bugs) by uprooting the smart pointers in favor of dumb pointers.<p>What are you going to do if part of the reason the smart pointers are there is that they are providing needed exception safety?</div><br/><div id="38480563" class="c"><input type="checkbox" id="c-38480563" checked=""/><div class="controls bullet"><span class="by">projektfu</span><span>|</span><a href="#38480083">parent</a><span>|</span><a href="#38484304">next</a><span>|</span><label class="collapse" for="c-38480563">[-]</label><label class="expand" for="c-38480563">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.  In the QML example, it sounds like some function is creating a QML form and passing in pointers to objects which are not copied but stored by QML (or Javascript).  The form template is persistent and is reused when new windows are created, perhaps.<p>Another article on the author&#x27;s site references a different complaint about QML, that it sometimes does assume ownership of objects, if they are normal QObjects without parents.  This led to them getting reclaimed by the window being closed.  There is, of course, documentation for when this might happen.<p>One thing that&#x27;s generally true in C++ is that the user of a library has to play along.  If the library wants to allocate your objects, let it.  If it wants to take ownership of your objects, expect it.  If it doesn&#x27;t take ownership, you need to understand their lifetimes.  It&#x27;s definitely one of the frustrating things about C++, but I wouldn&#x27;t expect a lot of complaints about one library or another unless they were being surprisingly capricious, taking ownership on Wednesday, not using your allocated objects on Friday, copying on Monday.</div><br/></div></div><div id="38484304" class="c"><input type="checkbox" id="c-38484304" checked=""/><div class="controls bullet"><span class="by">Remnant44</span><span>|</span><a href="#38480083">parent</a><span>|</span><a href="#38480563">prev</a><span>|</span><a href="#38484562">next</a><span>|</span><label class="collapse" for="c-38484304">[-]</label><label class="expand" for="c-38484304">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. This is a very odd rant against smart pointers that is essentially a rant against the strawman.<p>The most relevant line is this: &quot;to most other languages you are simply passing the address of a buffer&quot;. That&#x27;s true! And so for the love of all that&#x27;s holy, don&#x27;t transfer ownership. Simply pass a (non-owning, defined-lifetime) pointer to your data to the relevant dependency.<p>Have asynchronous issues? Need to extend lifetime sometimes? Well, yeah, unique_ptr is not going to help you there. It&#x27;s not magic.</div><br/></div></div></div></div><div id="38484562" class="c"><input type="checkbox" id="c-38484562" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38480083">prev</a><span>|</span><a href="#38471808">next</a><span>|</span><label class="collapse" for="c-38484562">[-]</label><label class="expand" for="c-38484562">[1 more]</label></div><br/><div class="children"><div class="content">I usually phrase this, when hearing people talk about safety in C++, as the mold coming through the wallpaper. The need to take raw pointers from &quot;smart pointers&quot; keeps coming up, because there are too many C APIs.</div><br/></div></div><div id="38471808" class="c"><input type="checkbox" id="c-38471808" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#38484562">prev</a><span>|</span><label class="collapse" for="c-38471808">[-]</label><label class="expand" for="c-38471808">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The standard states you cannot make [two] unique_ptr&lt;&gt; with the same pointer value within the same compilation unit.<p>&gt; We got this error because the “compiler will only allow one unique_ptr per address” mantra is mostly kaka.<p>I&#x27;m curious where the &quot;enforced one unique_ptr per address&quot; idea comes from. I don&#x27;t think I&#x27;ve ever heard of it before, and I don&#x27;t see any language implying that in the current (?) draft standard [0]. If anything, I think I&#x27;d be a bit surprised if such language existed - after all, creating multiple unique_ptrs to the same place is technically harmless as long as you call release() on enough of them so you don&#x27;t end up multi-deleting the common object.<p>This also seems like one of those things where &quot;cannot&quot; is more &quot;doing this is a bad idea and you may run into UB&quot; than &quot;the program will not compile if you do this&quot; due to guaranteed enforcement being statically infeasible.<p>The other issues including the QML stuff sounds more like unclear ownership semantics across libraries. I feel the advice here is slightly off-target; if you don&#x27;t know the ownership semantics of the libraries you&#x27;re using neither using smart pointers nor avoiding smart pointers are going to be a magic bullet to solve your issues maybe unless you take things to the extreme and allocate everything on startup.<p>&gt; Someone thinks it is a good idea to use Smart Pointers then passes the value to library functions written in C and other languages. Usually these things are in their own threads.<p>Like this. The issue isn&#x27;t the smart pointers, it&#x27;s that the ownership semantics of the library function(s) weren&#x27;t properly accounted for. unique_ptr::release() exists for a reason, after all!<p>&gt; When trying to track down a ghost like crash, <i>nuke all of the Smart Pointers in the code.</i> Make them raw pointers and delete them when you know it is safe.<p>I&#x27;m somewhat surprised this is the advice given rather than something like sanitizers and&#x2F;or valgrind, since those could be <i>significantly</i> less invasive than ripping every smart pointer in a program. Then again, the author states they work on medical devices, and I&#x27;m not sure whether sanitizers or valgrind are available for those.<p>In addition, the second sentence is pretty much &quot;don&#x27;t write bugs&quot;, which is technically correct but not exactly helpful; why not &quot;look at your smart pointers again and ensure they aren&#x27;t violating their ownership guarantees&quot;? You would basically be doing the same thing - lifetime analysis - either way. Heck, you can even re-scope your smart pointers so they&#x27;ll only go out of scope &quot;when you know it is safe&quot;.<p>I don&#x27;t think I&#x27;ve heard &quot;near heap&quot; and &quot;far heap&quot; used in such a way before, either. Not that it&#x27;s bad; just different.<p>[0]: <a href="https:&#x2F;&#x2F;eel.is&#x2F;c++draft&#x2F;unique.ptr" rel="nofollow noreferrer">https:&#x2F;&#x2F;eel.is&#x2F;c++draft&#x2F;unique.ptr</a></div><br/><div id="38480115" class="c"><input type="checkbox" id="c-38480115" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#38471808">parent</a><span>|</span><a href="#38480255">next</a><span>|</span><label class="collapse" for="c-38480115">[-]</label><label class="expand" for="c-38480115">[1 more]</label></div><br/><div class="children"><div class="content">Yeah this just comes across as not understanding pointer ownership, or memory allocation in general. It&#x27;s not a trivial issue, especially if you&#x27;re dealing with weird C libraries. Sometimes you don&#x27;t own a pointer you allocated. Sometimes you need a custom deleter.<p>Within your own code you can just use std::make_unique and rely on the compiler to catch errors, but when passing raw pointers to libraries you really gotta read the docs and work carefully.</div><br/></div></div><div id="38480255" class="c"><input type="checkbox" id="c-38480255" checked=""/><div class="controls bullet"><span class="by">greiskul</span><span>|</span><a href="#38471808">parent</a><span>|</span><a href="#38480115">prev</a><span>|</span><a href="#38484372">next</a><span>|</span><label class="collapse" for="c-38480255">[-]</label><label class="expand" for="c-38480255">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, with the QML example, if the programmer instead had used a raw pointer, he would still have a problem. Since if he chose to call free, he would have the same crash that the example had. And if he chose to just never call free, he would have a memory leak.</div><br/></div></div><div id="38484372" class="c"><input type="checkbox" id="c-38484372" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38471808">parent</a><span>|</span><a href="#38480255">prev</a><span>|</span><label class="collapse" for="c-38484372">[-]</label><label class="expand" for="c-38484372">[1 more]</label></div><br/><div class="children"><div class="content">Multiple unique pointers pointing to NULL happens all of the time.</div><br/></div></div></div></div></div></div></div></div></div></body></html>