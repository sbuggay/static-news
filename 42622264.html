<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736586060714" as="style"/><link rel="stylesheet" href="styles.css?v=1736586060714"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bytes.vadelabs.com/doing-hard-things-while-living-life-why-we-built-vade-studio-in-clojure/">Why we built Vade Studio in Clojure</a> <span class="domain">(<a href="https://bytes.vadelabs.com">bytes.vadelabs.com</a>)</span></div><div class="subtext"><span>puredanger</span> | <span>72 comments</span></div><br/><div><div id="42662721" class="c"><input type="checkbox" id="c-42662721" checked=""/><div class="controls bullet"><span class="by">christophilus</span><span>|</span><a href="#42660644">next</a><span>|</span><label class="collapse" for="c-42662721">[-]</label><label class="expand" for="c-42662721">[13 more]</label></div><br/><div class="children"><div class="content">Clojure is a lot of fun to tinker with, but man… I love my static types. I think I’d hate to work on a large codebase in Clojure and constantly be wondering what exactly “m” is.</div><br/><div id="42662967" class="c"><input type="checkbox" id="c-42662967" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#42662721">parent</a><span>|</span><a href="#42662868">next</a><span>|</span><label class="collapse" for="c-42662967">[-]</label><label class="expand" for="c-42662967">[5 more]</label></div><br/><div class="children"><div class="content">One of the myriad reasons why Common Lisp is far superior to Clojure is the ability to<p><pre><code>  (declare (type Integer m))</code></pre></div><br/><div id="42663101" class="c"><input type="checkbox" id="c-42663101" checked=""/><div class="controls bullet"><span class="by">Zak</span><span>|</span><a href="#42662721">root</a><span>|</span><a href="#42662967">parent</a><span>|</span><a href="#42662868">next</a><span>|</span><label class="collapse" for="c-42663101">[-]</label><label class="expand" for="c-42663101">[4 more]</label></div><br/><div class="children"><div class="content">Typed Clojure is available as a library.</div><br/><div id="42664008" class="c"><input type="checkbox" id="c-42664008" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#42662721">root</a><span>|</span><a href="#42663101">parent</a><span>|</span><a href="#42662868">next</a><span>|</span><label class="collapse" for="c-42664008">[-]</label><label class="expand" for="c-42664008">[3 more]</label></div><br/><div class="children"><div class="content">But just about nobody uses it right? Probably a reason for that.</div><br/><div id="42664153" class="c"><input type="checkbox" id="c-42664153" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#42662721">root</a><span>|</span><a href="#42664008">parent</a><span>|</span><a href="#42664145">next</a><span>|</span><label class="collapse" for="c-42664153">[-]</label><label class="expand" for="c-42664153">[1 more]</label></div><br/><div class="children"><div class="content">Until recently (2023), the type inference was very weak and did not work with higher-order functions (map, filter, reduce, etc.).<p>As a result, Typed Clojure was practically unusable for most applications. That has changed as of last year. For instance, the type checker can now handle the following kinds of expressions.<p><pre><code>  (let [f (comp (fn [y] y)
                (fn [x] x))]
    (f 1))
</code></pre>
This expression was a type error before early 2023, but now it is inferred as a value of type (Val 1).<p>Unfortunately, many Clojure users think types are somehow a bad thing and will usually repeat something from Rich Hickey&#x27;s &quot;Maybe Not&quot; talk.<p>I&#x27;ve worked with Clojure professionally. The codebases I&#x27;ve seen work around dynamic types by aggressively spec&#x27;ing functions and enabling spec instrumentation in development builds. Of course, this instrumentation had to be disabled in production because spec validation has measurable overhead.<p>Although Typed Clojure has made remarkable progress, the most editor tooling I recall for Typed Clojure is an extension to CIDER that hasn&#x27;t been maintained for several years. (The common excuse given in the Clojure community is that some software is &quot;complete&quot; thus doesn&#x27;t need updates, but I have regularly found bugs in &quot;complete&quot; Clojure libraries, so I don&#x27;t have much confidence here).<p>Overall, if one wants static typing, then Clojure will disappoint. I still use Clojure for small, personal-use tools. Having maintained large Clojure codebases, however, I no longer think the DX (and fearless refactoring) in languages like Rust and TypeScript is worth trading off.</div><br/></div></div><div id="42664145" class="c"><input type="checkbox" id="c-42664145" checked=""/><div class="controls bullet"><span class="by">knubie</span><span>|</span><a href="#42662721">root</a><span>|</span><a href="#42664008">parent</a><span>|</span><a href="#42664153">prev</a><span>|</span><a href="#42662868">next</a><span>|</span><label class="collapse" for="c-42664145">[-]</label><label class="expand" for="c-42664145">[1 more]</label></div><br/><div class="children"><div class="content">I think the consensus is that it is not really mature enough for general adoption. Also, most people prefer to use one of the specification libraries that are available (spec, schema, malli). These allow you to do a sort of design-by-contract style of programming.</div><br/></div></div></div></div></div></div></div></div><div id="42662868" class="c"><input type="checkbox" id="c-42662868" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#42662721">parent</a><span>|</span><a href="#42662967">prev</a><span>|</span><a href="#42664143">next</a><span>|</span><label class="collapse" for="c-42662868">[-]</label><label class="expand" for="c-42662868">[6 more]</label></div><br/><div class="children"><div class="content">You wouldn&#x27;t because of the repl. You would jack in and no exactly what m is.</div><br/><div id="42664442" class="c"><input type="checkbox" id="c-42664442" checked=""/><div class="controls bullet"><span class="by">kamma4434</span><span>|</span><a href="#42662721">root</a><span>|</span><a href="#42662868">parent</a><span>|</span><a href="#42664051">next</a><span>|</span><label class="collapse" for="c-42664442">[-]</label><label class="expand" for="c-42664442">[1 more]</label></div><br/><div class="children"><div class="content">The compiler should know it for you, so you cannot get it wrong no matter what. The REPL here is a band-aid not a solution.<p>I mean, I love Clojure, and used it for personal and work projects for 10+ years, some of which have hundreds of stars on github. But I cannot count the time wasted to spot issues where a map was actually a list of maps. Here Elixir is doing the right thing - adding gradual typing.</div><br/></div></div><div id="42664051" class="c"><input type="checkbox" id="c-42664051" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#42662721">root</a><span>|</span><a href="#42662868">parent</a><span>|</span><a href="#42664442">prev</a><span>|</span><a href="#42662991">next</a><span>|</span><label class="collapse" for="c-42664051">[-]</label><label class="expand" for="c-42664051">[2 more]</label></div><br/><div class="children"><div class="content">As nice as nrepl&#x2F;cider are, doing what amounts to setting a breakpoint in the middle of a function to see what `m` looks like isn&#x27;t a replacement for knowing the type without executing code. It&#x27;s just something we put up with.</div><br/><div id="42664404" class="c"><input type="checkbox" id="c-42664404" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#42662721">root</a><span>|</span><a href="#42664051">parent</a><span>|</span><a href="#42662991">next</a><span>|</span><label class="collapse" for="c-42664404">[-]</label><label class="expand" for="c-42664404">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using Clojure for a while and I rarely ever wonder &quot;what &#x27;m&#x27; is&quot; - that almost never happens, despite the language being dynamically typed.<p>Data shapes in Clojure typically explicit and consistent. The context usually makes things quite obvious. Data is self-describing - you can just look at a map and immediately see its structure and contents - the keywords serve as explicit labels and the data, well... is just fucking data. That kind of &quot;data transparency&quot; makes Clojure code easier to reason about.<p>In contrast, in many other PLs, you often need to know the class definition (or some other obscured shit) to understand what properties exist or are accessible. The object&#x27;s internal state may be encapsulated&#x2F;hidden, and its representation might be spread across a class hierarchy. You often can&#x27;t even just print it to see what&#x27;s inside it in a meaningful way. And of course, it makes nearly impossible to navigate such codebases without static types.<p>And of course the REPL - it simply feels extremely liberating, being able to connect to some remote service, running in a container or k8s pod and directly manipulate it. It feels like walking through walls while building a map in a video game. Almost like some magic that allows you to inspect, debug, and modify production systems in real-time, safely and interactively, without stopping or redeploying them.<p>Not to mention that Clojure does have very powerful type systems, although of course, skeptics would argue that Malli and Spec are not &quot;true&quot; types and they&#x27;d be missing the point - they are intentionally different tools solving real problems pragmatically. They can be used for runtime validation when and where you need it. They can be easily manipulated as data. They have dynamic validation mechanisms that static types just can&#x27;t easily express.<p>One thing I learned after using dozens of different programming languages - you can&#x27;t just simply pick one feature or aspect in any of them and say: &quot;it&#x27;s great or horrible because of one specific thing&quot;, because programming languages are complex ecosystems where features interact and complement each other in subtle ways. A language&#x27;s true value emerges from how all its parts work together, e.g.,<p>- Clojure&#x27;s dynamic nature + REPL + data orientation<p>- Haskell&#x27;s type system + purity + lazy evaluation<p>- Erlang&#x27;s processes + supervision + fault tolerance<p>What might seem like a weakness in isolation often enables strengths in combination with other features. The language&#x27;s philosophy, tooling, and community also play crucial roles in the overall development experience.<p>If one says: &quot;I can&#x27;t use Clojure because it doesn&#x27;t have static types&quot;, they have learned very little about the trade they chose to pursue.</div><br/></div></div></div></div><div id="42662991" class="c"><input type="checkbox" id="c-42662991" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42662721">root</a><span>|</span><a href="#42662868">parent</a><span>|</span><a href="#42664051">prev</a><span>|</span><a href="#42664143">next</a><span>|</span><label class="collapse" for="c-42662991">[-]</label><label class="expand" for="c-42662991">[2 more]</label></div><br/><div class="children"><div class="content">With static types, I don&#x27;t have the use the repl at all, I can simply hover over it in my editor.</div><br/><div id="42663073" class="c"><input type="checkbox" id="c-42663073" checked=""/><div class="controls bullet"><span class="by">Zak</span><span>|</span><a href="#42662721">root</a><span>|</span><a href="#42662991">parent</a><span>|</span><a href="#42664143">next</a><span>|</span><label class="collapse" for="c-42663073">[-]</label><label class="expand" for="c-42663073">[1 more]</label></div><br/><div class="children"><div class="content">With a REPL-connected editor (and most have a way to do this), you can simply hover over it in your editor as well. Even though most languages <i>can</i> have a REPL today, few integrate it in the development experience the way lisps do.</div><br/></div></div></div></div></div></div></div></div><div id="42660644" class="c"><input type="checkbox" id="c-42660644" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#42662721">prev</a><span>|</span><a href="#42660131">next</a><span>|</span><label class="collapse" for="c-42660644">[-]</label><label class="expand" for="c-42660644">[14 more]</label></div><br/><div class="children"><div class="content">Interesting story.  I am not entirely convinced that all credit should go to the programming language here, though.<p>My theory is that communicating abstractions is hard.  If you work on your own, or in a (very) small team, you can come up with powerful abstractions that allow you to build amazing systems, quickly.  However, sharing the underlying ideas and philosophy with new team members can be daunting.  As systems grow, and mistakes are made, it becomes more and more likely that you run into serious problems.<p>This may also be why Java and similar object oriented programming languages are so successful for systems that have to be maintained for ages, by large teams of developers.  There are but few abstractions and patterns, and it does not allow you to shoot yourself in the foot, nor to blow your whole leg off.  Conversely, this may also be why complex frameworks, such as Spring, are not always so nice, because they introduce (too?) powerful abstractions, for example through annotations.  It may also clarify why more powerful languages such as Scala, Common Lisp, Smalltalk, Haskell, etc, consistently fail to pick up steam.<p>Another theory is that not every developer is comfortable with abstract concepts, and that it simply takes a team of smart people to handle those.</div><br/><div id="42660900" class="c"><input type="checkbox" id="c-42660900" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42660644">parent</a><span>|</span><a href="#42661122">next</a><span>|</span><label class="collapse" for="c-42660900">[-]</label><label class="expand" for="c-42660900">[3 more]</label></div><br/><div class="children"><div class="content">Another theory is that C inspired languages are very mechanistic and easier to visualize. Same goes for OOP with the Animal-&gt;{Cat,Dog} explanation. But that&#x27;s just surface level and once you get to the difficult part (memory management in C and software design in Java) where the ability to grasp abstractions is required, we&#x27;re back to square one.<p>I believe once you&#x27;ve got to some point, dealing with abstractions is a way of life. It&#x27;s either in the language, the technical requirements, or the software design.</div><br/><div id="42663722" class="c"><input type="checkbox" id="c-42663722" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#42660644">root</a><span>|</span><a href="#42660900">parent</a><span>|</span><a href="#42661122">next</a><span>|</span><label class="collapse" for="c-42663722">[-]</label><label class="expand" for="c-42663722">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Objects are the way we think&quot; is one of the largest design traps ever laid in software development.  Because if you design your program like it, unless in certain special circumstances, it will be shit.</div><br/><div id="42664105" class="c"><input type="checkbox" id="c-42664105" checked=""/><div class="controls bullet"><span class="by">mstipetic</span><span>|</span><a href="#42660644">root</a><span>|</span><a href="#42663722">parent</a><span>|</span><a href="#42661122">next</a><span>|</span><label class="collapse" for="c-42664105">[-]</label><label class="expand" for="c-42664105">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think I’m terms of objects at all, I think it terms of how the data flows. That’s why I like Elixir so much</div><br/></div></div></div></div></div></div><div id="42661122" class="c"><input type="checkbox" id="c-42661122" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42660644">parent</a><span>|</span><a href="#42660900">prev</a><span>|</span><a href="#42663241">next</a><span>|</span><label class="collapse" for="c-42661122">[-]</label><label class="expand" for="c-42661122">[8 more]</label></div><br/><div class="children"><div class="content">&gt; It may also clarify why more powerful languages such as Scala, Common Lisp, Smalltalk, Haskell, etc, consistently fail to pick up steam.<p>Languages need a window of opportunity, and many of those squandered it.<p>Clojure won over Scala because at the time when people were loooking for an alternative JVM langauge, Clojure was more of a departure from Java and seemed to have better tooling (compile times and syntax support) than Scala.<p>Smalltalk and Common Lisp wasted their moment by not being cheap&#x2F;free to people using micros in the 1980s.<p>Lisp, especially, <i>very much</i> wasted its moment with micros.  The fact that no Lisper had the vision to dump a Lisp onto the bank switched micros (which makes GC really easy and useful) of the mid to late 1980s is a self-inflicted bullet wound.  Lots of us <i>hated</i> doing assembly language programming but had no real alternative.  This was a loss born of pure arrogance of Lispers who looked down on those micros as not being &quot;real machines&quot;.<p>I weep for all the hours I wasted doing assembly language as a teenager that I could have been writing Lisp.  How much software could have been written that would have been &lt;100 lines of Lisp if only someone had written that tool?</div><br/><div id="42662040" class="c"><input type="checkbox" id="c-42662040" checked=""/><div class="controls bullet"><span class="by">baobun</span><span>|</span><a href="#42660644">root</a><span>|</span><a href="#42661122">parent</a><span>|</span><a href="#42663698">next</a><span>|</span><label class="collapse" for="c-42662040">[-]</label><label class="expand" for="c-42662040">[2 more]</label></div><br/><div class="children"><div class="content">...in what sense has Clojure actually won over Scala?<p>I see way more Scala in companies last ~5y and have the impression of its ecosystem being more robust. Not uncommon for greenfields. It&#x27;s longer than that I even encountered an active Clojure codebase. This is from a data-engineer perspective.<p>Clojure may be more popular for some niche of app startups perhaps? We are in different &quot;bubbles&quot; I suppose.<p>EDIT: Data disagrees with you also.<p><a href="https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;</a><p><a href="https:&#x2F;&#x2F;redmonk.com&#x2F;sogrady&#x2F;2024&#x2F;09&#x2F;12&#x2F;language-rankings-6-24&#x2F;" rel="nofollow">https:&#x2F;&#x2F;redmonk.com&#x2F;sogrady&#x2F;2024&#x2F;09&#x2F;12&#x2F;language-rankings-6-2...</a><p><a href="https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2024&#x2F;technology#1-programming-scripting-and-markup-languages" rel="nofollow">https:&#x2F;&#x2F;survey.stackoverflow.co&#x2F;2024&#x2F;technology#1-programmin...</a></div><br/><div id="42662836" class="c"><input type="checkbox" id="c-42662836" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42660644">root</a><span>|</span><a href="#42662040">parent</a><span>|</span><a href="#42663698">next</a><span>|</span><label class="collapse" for="c-42662836">[-]</label><label class="expand" for="c-42662836">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t really speak to modern stuff, and it is certainly possible my memory is faulty.  Scala was a PITA in the early 2000s and you were generally better served with something else if you could move off the JVM.  Clojure came in about mid 2000s and seemed to be what a bunch of people stuck on the JVM but doing data processing were desperate to find.<p>My feeling was that a lot of Clojure folks moved on as the data processing stuff moved on from Java&#x2F;JVM.<p>My impression has been that JVM-based languages have effectively been on a steady general decline for a while now.  Java has fixed a lot of its issues; Kotlin gave the Java expats somewhere to go.  And Javascript&#x2F;Node along with Go drained out the general masses who didn&#x27;t really want to be on the JVM anyhow.<p>However, it is interesting that Clojure has effectively disappeared in those rankings.</div><br/></div></div></div></div><div id="42663698" class="c"><input type="checkbox" id="c-42663698" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#42660644">root</a><span>|</span><a href="#42661122">parent</a><span>|</span><a href="#42662040">prev</a><span>|</span><a href="#42661817">next</a><span>|</span><label class="collapse" for="c-42663698">[-]</label><label class="expand" for="c-42663698">[1 more]</label></div><br/><div class="children"><div class="content">Lisps really only come into their own above a certain size&#x2F;amount of resources. For early Lisp the PDP-11 with 2-4 MB RAM was considered to be nice. There were some Lisp implementations for the PCs but they suffered from the need for compatibility with older hardware.</div><br/></div></div><div id="42661817" class="c"><input type="checkbox" id="c-42661817" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#42660644">root</a><span>|</span><a href="#42661122">parent</a><span>|</span><a href="#42663698">prev</a><span>|</span><a href="#42663241">next</a><span>|</span><label class="collapse" for="c-42661817">[-]</label><label class="expand" for="c-42661817">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Lots of us hated doing assembly language programming but had no real alternative.<p>I kind of fail to see Lisp as an alternative to assembler on mid 80s micros.<p>Though, there were several cheap Lisps for PCs...</div><br/><div id="42662268" class="c"><input type="checkbox" id="c-42662268" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42660644">root</a><span>|</span><a href="#42661817">parent</a><span>|</span><a href="#42663241">next</a><span>|</span><label class="collapse" for="c-42662268">[-]</label><label class="expand" for="c-42662268">[3 more]</label></div><br/><div class="children"><div class="content">The bank switched memory architectures were basically unused in mid 80s micros (C128, CoCo3, etc.).<p>Lots of utility software like spell checkers and the like still existed.  These would be trivial to implement in Lisp but are really annoying in assembler.<p>Lisp would have been <i>really good</i> relative to BASIC interpreters at the time--especially since you could have tokenized the atoms.  It also would have freed people from line numbers.  Linked lists work well on these kinds of machines.  64K is solid for a Lisp if you own the whole machine.  You can run over a bank of 16K of memory for GC in about 50 milliseconds or so on those architectures.<p>Had one of the Lisperati evangelized Lisp on micros, the world would look very different.  Alas, they were off charging a gazillion bucks to government contracts.<p>However, to be fair, only Hejlsberg had the correct insights from putting Pascal on the Nascom.</div><br/><div id="42662445" class="c"><input type="checkbox" id="c-42662445" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#42660644">root</a><span>|</span><a href="#42662268">parent</a><span>|</span><a href="#42663241">next</a><span>|</span><label class="collapse" for="c-42662445">[-]</label><label class="expand" for="c-42662445">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Lisp would have been really good relative to BASIC interpreters at the time<p>I see no evidence for that. Lisp was a pain on tiny machines with bad user interface.<p>&gt; 64K is solid for a Lisp if you own the whole machine.<p>I had a Lisp on an Apple II. It was a useless toy. I was using UCSD Pascal and Modula 2 on it. Much better.<p>I had Cambridge Lisp on an Atari with 68k CPU. It was next to unusable due to frequent crashes on calling FFI functions.<p>The first good Lisp implementation I got was MacScheme on the Mac and then the breakthrough was Macintosh Common Lisp from Coral Software.<p>&gt; Had one of the Lisperati evangelized Lisp on micros<p>There were articles for example in the Byte magazine. Lisp simply was a bad fit to tiny machines. Lisp wasn&#x27;t very efficient for small memory. Maybe with lots of work implementing a tiny Lisp in assembler. But who would have paid for it? People need to eat. The tiny Lisp for the Apple II was not usable, due to the lack of useful programming environment.<p>&gt; Alas, they were off charging a gazillion bucks to government contracts.<p>At least there were people willing to pay for it.</div><br/><div id="42662944" class="c"><input type="checkbox" id="c-42662944" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42660644">root</a><span>|</span><a href="#42662445">parent</a><span>|</span><a href="#42663241">next</a><span>|</span><label class="collapse" for="c-42662944">[-]</label><label class="expand" for="c-42662944">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There were articles for example in the Byte magazine.<p>And they were stupid.  Even &quot;good&quot; Lisp references didn&#x27;t cover the important things like hashes and arrays.  Everybody covered the recursive crap over and over and over ad nauseam while people who actually used Lisp almost always sidestepped those parts of the language.<p>&gt; I had a Lisp on an Apple II. It was a useless toy. I was using UCSD Pascal and Modula 2 on it. Much better.<p>And yet UCSD Pascal was using a P-machine.  So, the problem was the implementation and not the concept.  Which was <i>exactly</i> my point.<p>&gt; At least there were people willing to pay for it.<p>Temporarily.  But then it died when the big money went away and left Lisp all but dead.  All the while all the people using languages on those &quot;toys&quot; kept right on going.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42663241" class="c"><input type="checkbox" id="c-42663241" checked=""/><div class="controls bullet"><span class="by">nradov</span><span>|</span><a href="#42660644">parent</a><span>|</span><a href="#42661122">prev</a><span>|</span><a href="#42660866">next</a><span>|</span><label class="collapse" for="c-42663241">[-]</label><label class="expand" for="c-42663241">[1 more]</label></div><br/><div class="children"><div class="content">Powerful abstractions tend to come back and bite you a few years later when the industry trends shift and everyone else starts using a different set of abstractions. Now that small team is stuck maintaining those custom abstractions forever and is unable to take advantage of new abstractions from vendors or open source projects. So their progress stagnates while competitors race ahead. I&#x27;ve been on the wrong side of that before.</div><br/></div></div><div id="42660866" class="c"><input type="checkbox" id="c-42660866" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#42660644">parent</a><span>|</span><a href="#42663241">prev</a><span>|</span><a href="#42660131">next</a><span>|</span><label class="collapse" for="c-42660866">[-]</label><label class="expand" for="c-42660866">[1 more]</label></div><br/><div class="children"><div class="content">Clojure has some interesting advantages - which doesn&#x27;t mean others might not.<p>Rapid application technologies, methedologies, or frameworks are not unusual.<p>I know some wonderfully productive polyglot developers who by their own choice end up at Clojure.  It doesn&#x27;t have to be for everyone.<p>I wouldn&#x27;t rule out that Clojure doesn&#x27;t deserve credit.  I wouldn&#x27;t think it&#x27;s a good idea to discredit Clojure from not having tried it myself.<p>I do hope someone with extensive Clojure experience can weigh in on the advantages.<p>How easy something is a codebase grows is something to really consider.<p>This product regardless of how it&#x27;s built is pretty impressive. I&#x27;d be open to learning advantages and comparisons without denying it.</div><br/></div></div></div></div><div id="42660131" class="c"><input type="checkbox" id="c-42660131" checked=""/><div class="controls bullet"><span class="by">jimbokun</span><span>|</span><a href="#42660644">prev</a><span>|</span><a href="#42663778">next</a><span>|</span><label class="collapse" for="c-42660131">[-]</label><label class="expand" for="c-42660131">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious if Elixir could provide a similar development environment?<p>Seems like many similar capabilities, like a focus on immutable data structures, pure functions, being able to patch and update running systems without a restart, etc.</div><br/><div id="42662473" class="c"><input type="checkbox" id="c-42662473" checked=""/><div class="controls bullet"><span class="by">kevinmershon</span><span>|</span><a href="#42660131">parent</a><span>|</span><a href="#42663778">next</a><span>|</span><label class="collapse" for="c-42662473">[-]</label><label class="expand" for="c-42662473">[2 more]</label></div><br/><div class="children"><div class="content">For the most part, yes.<p>CIDER and nREPL is better tech than IEX though. I live in both and Clojure is much more enjoyable.</div><br/><div id="42662980" class="c"><input type="checkbox" id="c-42662980" checked=""/><div class="controls bullet"><span class="by">innocentoldguy</span><span>|</span><a href="#42660131">root</a><span>|</span><a href="#42662473">parent</a><span>|</span><a href="#42663778">next</a><span>|</span><label class="collapse" for="c-42662980">[-]</label><label class="expand" for="c-42662980">[1 more]</label></div><br/><div class="children"><div class="content">I came to the opposite conclusion for the following reasons:<p>1. IEx provides a robust and interactive debugging environment that allows me to dig into whatever I want, even when running in production. I&#x27;ve never lost state in IEx, but that happens fairly often in CIDER and nREPL.<p>2. IEx uses Elixir&#x27;s compilation model, which is a lot faster than CIDER and nREPL, leading to faster debugging cycles.<p>3. IEx is tightly integrated with Elixir whereas Clojure&#x27;s tools are more fragmented.<p>4. IEx doesn&#x27;t carry the overhead of additional middleware that CIDER and nREPL do.<p>I&#x27;m also not a fan of JVM deployments, so I&#x27;ve migrated all my code away from Clojure to Elixir during the past 10 years.</div><br/></div></div></div></div></div></div><div id="42663778" class="c"><input type="checkbox" id="c-42663778" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#42660131">prev</a><span>|</span><a href="#42663188">next</a><span>|</span><label class="collapse" for="c-42663778">[-]</label><label class="expand" for="c-42663778">[2 more]</label></div><br/><div class="children"><div class="content">Maybe this architecture approach would be challenging in Java or Go, but the style of immutable data, don’t go crazy wrapping stuff in classes is very doable in most languages. We enforce “no mutation of data you did not just instantiate” at Notion, and use TypeScript’s powerful type system with tagged union types to ensure exhaustive handling of new variants which I really miss in languages that don’t have it (go).<p>I guess the major advantage for Closure with this style is the “persisted” data structures end up sharing some bytes behind the scenes - it’s nice the language is explicitly situated around this style, rather than TypeScript’s chaotic Wild West kitchen sink design. What I don’t understand the advantage for “state management”. Like, you build a new state object, and then mutate some pointer from prevState to nextState… that’s what everyone else is doing too.<p>There are times though when it’s nice to switch gears from function-and-data to an OO approach when you need to maintain a lot of invariants, interior mutability has substantial performance advantages, or you really want to make sure callers are interpreting the data’s semantics correctly. So our style has ended up being “functional&#x2F;immutable business logic and user data” w&#x2F; “zero inheritance OO for data structures”.<p>Whenever I read some open source TypeScript code that’s using the language like it’s Java like `class implements ISomething` ruining cmd-click go to method or an elaborate inheritance hierarchy it makes me sad.</div><br/><div id="42663904" class="c"><input type="checkbox" id="c-42663904" checked=""/><div class="controls bullet"><span class="by">knubie</span><span>|</span><a href="#42663778">parent</a><span>|</span><a href="#42663188">next</a><span>|</span><label class="collapse" for="c-42663904">[-]</label><label class="expand" for="c-42663904">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What I don’t understand the advantage for “state management”. Like, you build a new state object, and then mutate some pointer from prevState to nextState… that’s what everyone else is doing too.<p>Clojure&#x27;s real super power is its reference type(s) (in particular the atom). Rich does an excellent job explaining them in this video: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wASCH_gPnDw&amp;t=2278s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wASCH_gPnDw&amp;t=2278s</a></div><br/></div></div></div></div><div id="42663188" class="c"><input type="checkbox" id="c-42663188" checked=""/><div class="controls bullet"><span class="by">low_tech_punk</span><span>|</span><a href="#42663778">prev</a><span>|</span><a href="#42662924">next</a><span>|</span><label class="collapse" for="c-42663188">[-]</label><label class="expand" for="c-42663188">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  Because Clojure treats data as first-class citizens, we could build our own lightweight conflict resolution system using pure functions that operate on these transactions.
</code></pre>
What does it mean to say Clojure &quot;treat data a first-class citizen&quot;? I understand FP would treat function as first-class citizen, but the statement seems to mean something different.</div><br/><div id="42663525" class="c"><input type="checkbox" id="c-42663525" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#42663188">parent</a><span>|</span><a href="#42663280">next</a><span>|</span><label class="collapse" for="c-42663525">[-]</label><label class="expand" for="c-42663525">[1 more]</label></div><br/><div class="children"><div class="content">OOP generally &quot;hides&quot; data as internal state of class instances. Everything is private unless expressed as a method on an object.<p>The two sentences around the one you quoted should answer the question as well:<p><pre><code>    &gt; With Clojure, we modeled the entire collaboration system as a stream of immutable data transformations. Each user action becomes a transaction in our system.
</code></pre>
And<p><pre><code>   &gt; When conflicts occur, our system can merge changes intelligently because we&#x27;re working with pure data structures rather than complex objects.
</code></pre>
Whereas OOP languages combine behavior and data into a single thing (classes with methods model behavior and hide state i.e. data) functional languages separate them: functions model behavior, and data is treated more like an input and output rather than &quot;state&quot;.<p>In particular with clojure, data structures tend to be immutable and functions tend to not have side effects. This gives rise to the benefits the article talks about, though is not without its own drawbacks.</div><br/></div></div><div id="42663280" class="c"><input type="checkbox" id="c-42663280" checked=""/><div class="controls bullet"><span class="by">SerCe</span><span>|</span><a href="#42663188">parent</a><span>|</span><a href="#42663525">prev</a><span>|</span><a href="#42662924">next</a><span>|</span><label class="collapse" for="c-42663280">[-]</label><label class="expand" for="c-42663280">[1 more]</label></div><br/><div class="children"><div class="content">They most likely refer to homoiconicity [1], as Clojure is a dialect of Lisp. However, it&#x27;s hard to say for sure, and maybe they were simply referring to the built-in syntax for maps, lists, etc.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Homoiconicity" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Homoiconicity</a></div><br/></div></div></div></div><div id="42662924" class="c"><input type="checkbox" id="c-42662924" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#42663188">prev</a><span>|</span><a href="#42660737">next</a><span>|</span><label class="collapse" for="c-42662924">[-]</label><label class="expand" for="c-42662924">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Today, we&#x27;re building Vade Studio with just three developers – myself and two developers who joined as interns when in college. (...) Here&#x27;s what we&#x27;ve accomplished: (...)<p>In how many man-hours&#x2F;days? It&#x27;s hard to know if the list is long or short only knowing that calendar time should be multiplied by three for calculating people time spent...</div><br/></div></div><div id="42660737" class="c"><input type="checkbox" id="c-42660737" checked=""/><div class="controls bullet"><span class="by">joeevans1000</span><span>|</span><a href="#42662924">prev</a><span>|</span><a href="#42660002">next</a><span>|</span><label class="collapse" for="c-42660737">[-]</label><label class="expand" for="c-42660737">[2 more]</label></div><br/><div class="children"><div class="content">Is there a technical reason I can&#x27;t sign into Studio with email? I&#x27;ll really try to avoid signing in with other platforms, but I&#x27;ll consider Github if there&#x27;s some reason it has to be. I&#x27;ll never sign into a service with Google.</div><br/><div id="42660811" class="c"><input type="checkbox" id="c-42660811" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#42660737">parent</a><span>|</span><a href="#42660002">next</a><span>|</span><label class="collapse" for="c-42660811">[-]</label><label class="expand" for="c-42660811">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.  If a google account goes away, so does the access to all your google authenticated stuff.<p>I only use google for email logins for services I don&#x27;t take seriously and am willing to lose.</div><br/></div></div></div></div><div id="42660002" class="c"><input type="checkbox" id="c-42660002" checked=""/><div class="controls bullet"><span class="by">jolt42</span><span>|</span><a href="#42660737">prev</a><span>|</span><a href="#42663258">next</a><span>|</span><label class="collapse" for="c-42660002">[-]</label><label class="expand" for="c-42660002">[2 more]</label></div><br/><div class="children"><div class="content">@OP &quot;Model our domain as a graph of attributes and relationships&quot; and &quot;generate resolvers&quot;. I&#x27;m curious what your model looks like so that you are able to &quot;generate resolvers&quot;? I had looked into using Malli as the model, but curious what route you took.</div><br/><div id="42660612" class="c"><input type="checkbox" id="c-42660612" checked=""/><div class="controls bullet"><span class="by">knubie</span><span>|</span><a href="#42660002">parent</a><span>|</span><a href="#42663258">next</a><span>|</span><label class="collapse" for="c-42660612">[-]</label><label class="expand" for="c-42660612">[1 more]</label></div><br/><div class="children"><div class="content">I think these words will make more sense in the context of Pathom.<p><a href="https:&#x2F;&#x2F;pathom3.wsscode.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pathom3.wsscode.com&#x2F;</a></div><br/></div></div></div></div><div id="42663258" class="c"><input type="checkbox" id="c-42663258" checked=""/><div class="controls bullet"><span class="by">dalton_zk</span><span>|</span><a href="#42660002">prev</a><span>|</span><a href="#42661195">next</a><span>|</span><label class="collapse" for="c-42663258">[-]</label><label class="expand" for="c-42663258">[1 more]</label></div><br/><div class="children"><div class="content">Uncle Bob approved this article!!<p>Incredible history, I feel like Clojure makes magic. What I like about functional programming is that it brings other perspectives of how things CAN work!!<p>Congratulations by the life change</div><br/></div></div><div id="42661195" class="c"><input type="checkbox" id="c-42661195" checked=""/><div class="controls bullet"><span class="by">justinl33</span><span>|</span><a href="#42663258">prev</a><span>|</span><a href="#42662783">next</a><span>|</span><label class="collapse" for="c-42661195">[-]</label><label class="expand" for="c-42661195">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve built similar systems using Apache Airflow and Temporal, but the complexity was overwhelming. Using simple maps with enter&#x2F;leave phases for workflow steps is much cleaner than dealing with DAG frameworks.</div><br/></div></div><div id="42662783" class="c"><input type="checkbox" id="c-42662783" checked=""/><div class="controls bullet"><span class="by">android521</span><span>|</span><a href="#42661195">prev</a><span>|</span><a href="#42658564">next</a><span>|</span><label class="collapse" for="c-42662783">[-]</label><label class="expand" for="c-42662783">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t find pricing on the same. Though it is no code, there must be a way for me to work with code directly if i wish to do so. No mobile apps. It would be great if you can generate both web apps and mobile apps.</div><br/></div></div><div id="42658564" class="c"><input type="checkbox" id="c-42658564" checked=""/><div class="controls bullet"><span class="by">Nijikokun</span><span>|</span><a href="#42662783">prev</a><span>|</span><a href="#42658866">next</a><span>|</span><label class="collapse" for="c-42658564">[-]</label><label class="expand" for="c-42658564">[14 more]</label></div><br/><div class="children"><div class="content">Ultimately, it all comes down to build what you&#x27;re comfortable with. Additionally, when you&#x27;re managing large organizations and teams. Build with what you can hire quickly for and easily scale with.</div><br/><div id="42659323" class="c"><input type="checkbox" id="c-42659323" checked=""/><div class="controls bullet"><span class="by">mkreis</span><span>|</span><a href="#42658564">parent</a><span>|</span><a href="#42659512">next</a><span>|</span><label class="collapse" for="c-42659323">[-]</label><label class="expand" for="c-42659323">[9 more]</label></div><br/><div class="children"><div class="content">Quick (and cheap?) hires are not necessarily good hires.
In my experience (and my theory) developer productivity can range from 0.5x to 5x and more, and those developers in the upper range tend to look for certain programming language which they enjoy, like Rust, Go, Elixir, Scala and Clojure. They are hard to get if you are on a &quot;boring&quot; stack like Java, NodeJS, PHP.
So if you might need to invest some time and money to find the right people, but at the end you make a better deal: Even if the salary is twice as much, the productiviy is even more. Additionally less people means less communication overhead, which is another advante.</div><br/><div id="42659631" class="c"><input type="checkbox" id="c-42659631" checked=""/><div class="controls bullet"><span class="by">Nijikokun</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659323">parent</a><span>|</span><a href="#42659464">next</a><span>|</span><label class="collapse" for="c-42659631">[-]</label><label class="expand" for="c-42659631">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not in the business of cheap. I do care about resource availability though.</div><br/></div></div><div id="42659464" class="c"><input type="checkbox" id="c-42659464" checked=""/><div class="controls bullet"><span class="by">deeviant</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659323">parent</a><span>|</span><a href="#42659631">prev</a><span>|</span><a href="#42662893">next</a><span>|</span><label class="collapse" for="c-42659464">[-]</label><label class="expand" for="c-42659464">[6 more]</label></div><br/><div class="children"><div class="content">I find the opposite to be true, that best and most productive developers tend to be more language agnostic than average, although I&#x27;m not saying they don&#x27;t have their preferences.<p>Specifically, I find language evangelists particularly likely to be closer to .5x than 5x. And that&#x27;s before you even account for their tendency to push for rewriting stuff that already works, because &quot;&lt;insert language du jour here&gt; is the future, it&#x27;s going to be great and bug free,&quot; often instead of solving the highest impact problems.</div><br/><div id="42660672" class="c"><input type="checkbox" id="c-42660672" checked=""/><div class="controls bullet"><span class="by">switchbak</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659464">parent</a><span>|</span><a href="#42659749">next</a><span>|</span><label class="collapse" for="c-42660672">[-]</label><label class="expand" for="c-42660672">[1 more]</label></div><br/><div class="children"><div class="content">Oddly, I think both are true, at the same time.<p>I&#x27;ve worked with language zealots and it&#x27;s awful. Especially the ones with the hardcore purely functional obsession. But that can apply to almost anything: folks that refuse to use anything but $TECH (K8S, FreeBSD, etc). Zealots like this general care less about delivering and more about what they get to play with.<p>Then you have the folks that care about delivering. They&#x27;re not language agnostic, they have strong opinions. But also: they communicate and collaborate, they actually CARE: they have real empathy for their users and their co-workers, they&#x27;re pragmatic. Some of these folks have a lot of experience in pushing hard to make things work, and they&#x27;ve learned some valuable lessons in what (not) to do again. Sometimes that can manifest as preferences for languages &#x2F; frameworks &#x2F; etc.<p>It&#x27;s a messy industry, and it can be extremely hard to separate the wheat from the chaff. But a small team with a few of those can do truly game changing work. And there&#x27;s many local optima to be had. Get a highly motivated and gelled team using any of: Elixr &#x2F; Typescript &#x2F; Zig &#x2F; Rust &#x2F; Ada &#x2F; Ocaml &#x2F; Scala &#x2F; Python &#x2F; etc, and you&#x27;ll see magic. Yes, you don&#x27;t need fancy tech to achieve that. There&#x27;s more than a few of those writing C for example, but you&#x27;re unlikely to see these folks writing COBOL.</div><br/></div></div><div id="42659749" class="c"><input type="checkbox" id="c-42659749" checked=""/><div class="controls bullet"><span class="by">ilkhan4</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659464">parent</a><span>|</span><a href="#42660672">prev</a><span>|</span><a href="#42660570">next</a><span>|</span><label class="collapse" for="c-42659749">[-]</label><label class="expand" for="c-42659749">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, this has been my experience too. The mentality seems similar to &quot;productivity hackers&quot; who spend more time figuring out the quickest, most optimal way to do a thing than people who just do the thing.</div><br/><div id="42663656" class="c"><input type="checkbox" id="c-42663656" checked=""/><div class="controls bullet"><span class="by">HeWhoLurksLate</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659749">parent</a><span>|</span><a href="#42660570">next</a><span>|</span><label class="collapse" for="c-42663656">[-]</label><label class="expand" for="c-42663656">[1 more]</label></div><br/><div class="children"><div class="content">One of the things I&#x27;ve noticed is that people who just do the thing, take note of what&#x27;s annoying, and fix the most annoying things about a process later on tend to make the most impressive dents in a system or process, especially since they spend time mulling over the idea in their head and so by the time they implement, they aren&#x27;t &quot;zero-shotting&quot; a solution to what&#x27;s generally a complex issue.</div><br/></div></div></div></div><div id="42660570" class="c"><input type="checkbox" id="c-42660570" checked=""/><div class="controls bullet"><span class="by">dionian</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659464">parent</a><span>|</span><a href="#42659749">prev</a><span>|</span><a href="#42661982">next</a><span>|</span><label class="collapse" for="c-42660570">[-]</label><label class="expand" for="c-42660570">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you but also agree with the above, if youre stuck permanently in some tangled codebase with a boring language&#x2F;style, the really good programmers  tend to find something more fun to work on - unless they can bring their new skills&#x2F;experience to bear. personally I&#x27;ll only go back to doing boring stuff if i can&#x27;t find a job doing the fun stuff</div><br/></div></div><div id="42661982" class="c"><input type="checkbox" id="c-42661982" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659464">parent</a><span>|</span><a href="#42660570">prev</a><span>|</span><a href="#42662893">next</a><span>|</span><label class="collapse" for="c-42661982">[-]</label><label class="expand" for="c-42661982">[1 more]</label></div><br/><div class="children"><div class="content">hear! hear!</div><br/></div></div></div></div><div id="42662893" class="c"><input type="checkbox" id="c-42662893" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659323">parent</a><span>|</span><a href="#42659464">prev</a><span>|</span><a href="#42659512">next</a><span>|</span><label class="collapse" for="c-42662893">[-]</label><label class="expand" for="c-42662893">[1 more]</label></div><br/><div class="children"><div class="content">100% agree. You have hit the nail on the head. I went from Common Lisp to Go to now Rust and find that Rust devs are the best so far on average.<p>There are fewer of them, they ask for more money, but they really are exceptional. Especially Rust devs right now because there are not a lot of jobs you only find the most passionate and the most brilliant in that space. A short window though which will close as Rust gets more popular to startups, take advantage of it now.</div><br/></div></div></div></div><div id="42659512" class="c"><input type="checkbox" id="c-42659512" checked=""/><div class="controls bullet"><span class="by">joeevans1000</span><span>|</span><a href="#42658564">parent</a><span>|</span><a href="#42659323">prev</a><span>|</span><a href="#42660759">next</a><span>|</span><label class="collapse" for="c-42659512">[-]</label><label class="expand" for="c-42659512">[3 more]</label></div><br/><div class="children"><div class="content">In my case, it was definitely worth becoming uncomfortable for a bit to learn Clojure because I was very uncomfortable with the experience of many of the other languages. It’s also great to have endless backwards compatibility and little reliance on changing external libraries baked in.</div><br/><div id="42659647" class="c"><input type="checkbox" id="c-42659647" checked=""/><div class="controls bullet"><span class="by">Nijikokun</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659512">parent</a><span>|</span><a href="#42660759">next</a><span>|</span><label class="collapse" for="c-42659647">[-]</label><label class="expand" for="c-42659647">[2 more]</label></div><br/><div class="children"><div class="content">Never opposed to sacrificing some comfort for learning.</div><br/><div id="42660744" class="c"><input type="checkbox" id="c-42660744" checked=""/><div class="controls bullet"><span class="by">joeevans1000</span><span>|</span><a href="#42658564">root</a><span>|</span><a href="#42659647">parent</a><span>|</span><a href="#42660759">next</a><span>|</span><label class="collapse" for="c-42660744">[-]</label><label class="expand" for="c-42660744">[1 more]</label></div><br/><div class="children"><div class="content">And for superpowers. :-)</div><br/></div></div></div></div></div></div><div id="42660759" class="c"><input type="checkbox" id="c-42660759" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#42658564">parent</a><span>|</span><a href="#42659512">prev</a><span>|</span><a href="#42658866">next</a><span>|</span><label class="collapse" for="c-42660759">[-]</label><label class="expand" for="c-42660759">[1 more]</label></div><br/><div class="children"><div class="content">This.  And End users rarely care what the solution is coded in if it&#x27;s a tool they use and don&#x27;t modify or script at the code level.</div><br/></div></div></div></div><div id="42658866" class="c"><input type="checkbox" id="c-42658866" checked=""/><div class="controls bullet"><span class="by">smw</span><span>|</span><a href="#42658564">prev</a><span>|</span><a href="#42662972">next</a><span>|</span><label class="collapse" for="c-42658866">[-]</label><label class="expand" for="c-42658866">[4 more]</label></div><br/><div class="children"><div class="content">Anyone else unable to login with github to studio?</div><br/><div id="42659420" class="c"><input type="checkbox" id="c-42659420" checked=""/><div class="controls bullet"><span class="by">noshitsherlock</span><span>|</span><a href="#42658866">parent</a><span>|</span><a href="#42662972">next</a><span>|</span><label class="collapse" for="c-42659420">[-]</label><label class="expand" for="c-42659420">[3 more]</label></div><br/><div class="children"><div class="content">Yes, I was unable; just bumped me back to the login</div><br/><div id="42659542" class="c"><input type="checkbox" id="c-42659542" checked=""/><div class="controls bullet"><span class="by">atarian</span><span>|</span><a href="#42658866">root</a><span>|</span><a href="#42659420">parent</a><span>|</span><a href="#42659576">next</a><span>|</span><label class="collapse" for="c-42659542">[-]</label><label class="expand" for="c-42659542">[1 more]</label></div><br/><div class="children"><div class="content">same just redirects me to login every time</div><br/></div></div><div id="42659576" class="c"><input type="checkbox" id="c-42659576" checked=""/><div class="controls bullet"><span class="by">garyrob</span><span>|</span><a href="#42658866">root</a><span>|</span><a href="#42659420">parent</a><span>|</span><a href="#42659542">prev</a><span>|</span><a href="#42662972">next</a><span>|</span><label class="collapse" for="c-42659576">[-]</label><label class="expand" for="c-42659576">[1 more]</label></div><br/><div class="children"><div class="content">Same here</div><br/></div></div></div></div></div></div><div id="42662972" class="c"><input type="checkbox" id="c-42662972" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#42658866">prev</a><span>|</span><a href="#42661888">next</a><span>|</span><label class="collapse" for="c-42662972">[-]</label><label class="expand" for="c-42662972">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Each new layer of complexity fed my developer ego.<p>I&#x27;m unable to understand this mindset. All the time I read things like &quot;Developers love complexity because it feeds their egos&quot; but I&#x27;ve never encountered a situation in which added complexity made me more proud of the work. Just the opposite: being able to <i>do more</i> made me more proud of the work I put in, and complexity was the <i>price</i> I paid for that ability. The greatest hacks, the ones that etch people&#x27;s names into history, are the ones -- like Unix and the Doom engine -- that achieve phenomenal feats with very little code and&#x2F;or extreme parsimony of design. This is no more true than in that famous ego-stroking&#x2F;dick-measuring contest of programming, the demoscene. My favorite example being the 4k demo Omniscent: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=G1Q9LtnnE4w" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=G1Q9LtnnE4w</a><p>Being able to stand up a 100-node K8s cluster to provide a basic web service, connected to a React SPA front end to provide all the functionality of a Delphi program from the 90s doesn&#x27;t stroke the ego of any programmer I know of; but it might stroke their manager&#x27;s ego because it gives them an opportunity to empire-build and requisition a larger budget next year.</div><br/><div id="42663675" class="c"><input type="checkbox" id="c-42663675" checked=""/><div class="controls bullet"><span class="by">jonathanlydall</span><span>|</span><a href="#42662972">parent</a><span>|</span><a href="#42663135">next</a><span>|</span><label class="collapse" for="c-42663675">[-]</label><label class="expand" for="c-42663675">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, I often tell people that one of the “hardest” things to do in software development is actually managing complexity (on any significant sized code base that is, on smaller ones it’s probably not going to be an issue).<p>Big long lived code bases are all about this battle against complexity and the speed at which you can add new or update features largely comes down to how well you’re doing at management of complexity.</div><br/></div></div><div id="42663135" class="c"><input type="checkbox" id="c-42663135" checked=""/><div class="controls bullet"><span class="by">marsavar</span><span>|</span><a href="#42662972">parent</a><span>|</span><a href="#42663675">prev</a><span>|</span><a href="#42661888">next</a><span>|</span><label class="collapse" for="c-42663135">[-]</label><label class="expand" for="c-42663135">[1 more]</label></div><br/><div class="children"><div class="content">I was extremely puzzled by that statement too. I would hate to work with someone like that.</div><br/></div></div></div></div><div id="42661888" class="c"><input type="checkbox" id="c-42661888" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#42662972">prev</a><span>|</span><a href="#42658172">next</a><span>|</span><label class="collapse" for="c-42661888">[-]</label><label class="expand" for="c-42661888">[5 more]</label></div><br/><div class="children"><div class="content">Look these folks can do whatever the heck they want, use whatever language they want.<p>However my criteria for selecting  a language for use in a <i>professional context</i>:<p>0: fit to task - obviously the language has to be able to do the job - to take this seriously you must define the job and what its requirements are and map those against the candidate languages<p>1: hiring and recruiting - there must be a mainstream sized talent pool - talent shortages are not acceptable - and I don&#x27;t buy the argument that &quot;smart people are attracted to non mainstream languages which is how we find smart people&quot;, it is simply not true that &quot;most smart people program with Scala&#x2F;Haskell&#x2F;Elixir&#x2F;whatever&quot; - there&#x27;s smart and smarter working on the mainstream languages.<p>2: size of programming community, size of knowledge base, size of open source community - don&#x27;t end up with a code base stuck in an obscure corner of the Internet where few people know what is going on<p>3: AI - how well can AI program in this language? The size of the training set counts here - all the mainstream languages have had vast amounts of knowledge ingested and thus Claude can write decent code or at least has a shot at it. And in future this will likely get better again based on volume of training data.  AI counts for a huge amount - if you are using a language that the AI knows little about then there&#x27;s little productivity related benefits coming to your development team.<p>4: tools, IDE support, linters, compilers, build tools etc.  It&#x27;s a real obstacle to fire up your IDE and find that the IDE knows nothing about the language you are using, or that the language plugin was written by some guy who did it for the love and its not complete or professional or updated or something.<p>5: hiring and recruiting - it&#x27;s the top priority and the bottom and every priority in between. If you can&#x27;t find the people then you are in big trouble I have seen this play out over and over where the CTO&#x27;s favorite non-mainstream language is used in a professional context and for years - maybe decades after the company suffers trying to find people. And decades after the CTO moved on to a new company and a new favorite language.<p>So what is a mainstream language? Arguable but personally it looks like Python, Java, JavaScript&#x2F;TypeScript, C#, Golang.  To a lesser extent Ruby only because Ruby developers have always been hard to find even though there is lots of community and knowledge and tools etc. Rust seems to have remained somewhat niche when its peer Golang has grown rapidly. Probably C and C++ depending on context. Maybe Kotlin?  How cares what I think anyway its up to you. My main point is - in a professional context the language should be chosen to service the needs of the business. Be systematic and professional and don&#x27;t bring your hobbies into it because the business needs come first.<p>And for home&#x2F;hobbies&#x2F;fun? Do whatever the heck you like.</div><br/><div id="42662182" class="c"><input type="checkbox" id="c-42662182" checked=""/><div class="controls bullet"><span class="by">danielscrubs</span><span>|</span><a href="#42661888">parent</a><span>|</span><a href="#42662907">next</a><span>|</span><label class="collapse" for="c-42662182">[-]</label><label class="expand" for="c-42662182">[3 more]</label></div><br/><div class="children"><div class="content">The signal to noise ratio is way better if you take some eccentric language.<p>The amount of knuckleheads that Ive had to interview just to get a single coherent developer is mind boggling (remote first).</div><br/><div id="42662911" class="c"><input type="checkbox" id="c-42662911" checked=""/><div class="controls bullet"><span class="by">ilrwbwrkhv</span><span>|</span><a href="#42661888">root</a><span>|</span><a href="#42662182">parent</a><span>|</span><a href="#42662202">next</a><span>|</span><label class="collapse" for="c-42662911">[-]</label><label class="expand" for="c-42662911">[1 more]</label></div><br/><div class="children"><div class="content">I think in order of average dev quality (highest to lowest) I recently found:<p>Rust
Common Lisp
Go
Ruby&#x2F;Elixir
C++
Python
C#
Typescript
Java
Javascript</div><br/></div></div></div></div><div id="42662907" class="c"><input type="checkbox" id="c-42662907" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#42661888">parent</a><span>|</span><a href="#42662182">prev</a><span>|</span><a href="#42658172">next</a><span>|</span><label class="collapse" for="c-42662907">[-]</label><label class="expand" for="c-42662907">[1 more]</label></div><br/><div class="children"><div class="content">&gt; talent shortages are not acceptable - and I don&#x27;t buy the argument that &quot;smart people are attracted to non mainstream languages which is how we find smart people&quot;, it is simply not true that &quot;most smart people program with Scala&#x2F;Haskell&#x2F;Elixir&#x2F;whatever&quot; - there&#x27;s smart and smarter working on the mainstream languages.<p>Smart people can be trained in any language and become effective in a reasonably short period of time. I remember one company I worked at, we hired a couple of fresh grads who&#x27;d only worked with Java at school based on how promising they seemed; they were contributing meaningfully to our C++ code base within months. If you work in Lisp or Haskell or Smalltalk or maybe even Ruby, chances are pretty good you&#x27;ve an interesting enough code base to attract and retain this kind of programmer. Smart people paired with the right language can be effective in far smaller numbers as well.<p>The major drawback, however, is that programmers who are <i>this</i> intelligent and <i>this</i> interested in the work itself (rather than the money or career advancement opportunities) are likely to be prickly individualists who have cultivated within themselves Larry Wall&#x27;s three programmer virtues: Laziness, Impatience, and Hubris. So either you know how to support the needs of such a programmer, or you want to hire from a <i>slightly</i> less intelligent and insightful, though still capable, segment of the talent pool which means no, you&#x27;re not going to be targeting those powerful languages off the beaten track. (But you are going to have to do a bit more chucklehead filtering.)<p>&gt; if you are using a language that the AI knows little about then there&#x27;s little productivity related benefits coming to your development team.<p>This is vacuously true because the consequent is always true. The wheels are kind of falling off &quot;Dissociated Press on steroids&quot; as a massive productivity booster over the long haul. I think that by the time you have an AI capable of making decisions and crystallizing intent the way a human programmer can, then you really have to consider whether to give that AI the kind of rights we currently only afford humans.</div><br/></div></div></div></div></div></div></div></div></div></body></html>