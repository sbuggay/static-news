<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692349258435" as="style"/><link rel="stylesheet" href="styles.css?v=1692349258435"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cs.rpi.edu/academics/courses/spring11/proglang/handouts/lambda-calculus-chapter.pdf">λ Calculus (2013) [pdf]</a> <span class="domain">(<a href="https://www.cs.rpi.edu">www.cs.rpi.edu</a>)</span></div><div class="subtext"><span>behnamoh</span> | <span>49 comments</span></div><br/><div><div id="37170775" class="c"><input type="checkbox" id="c-37170775" checked=""/><div class="controls bullet"><span class="by">carlineng</span><span>|</span><a href="#37170893">next</a><span>|</span><label class="collapse" for="c-37170775">[-]</label><label class="expand" for="c-37170775">[5 more]</label></div><br/><div class="children"><div class="content">My favorite discussion of this topic is from David Beazley: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5C6sv7-eTKg">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5C6sv7-eTKg</a><p>He does a wonderful job of taking very dense mathematical notation and explaining it in ways that anyone can understand. He derives the basic concepts of the lambda calculus from the ground up using Python. Super fun to follow along with.</div><br/><div id="37172331" class="c"><input type="checkbox" id="c-37172331" checked=""/><div class="controls bullet"><span class="by">johnmw</span><span>|</span><a href="#37170775">parent</a><span>|</span><a href="#37171157">next</a><span>|</span><label class="collapse" for="c-37172331">[-]</label><label class="expand" for="c-37172331">[1 more]</label></div><br/><div class="children"><div class="content">This is another excellent video if you are more of a Javascript developer: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=OLH3L285EiY">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=OLH3L285EiY</a></div><br/></div></div><div id="37171157" class="c"><input type="checkbox" id="c-37171157" checked=""/><div class="controls bullet"><span class="by">cloudripper</span><span>|</span><a href="#37170775">parent</a><span>|</span><a href="#37172331">prev</a><span>|</span><a href="#37171185">next</a><span>|</span><label class="collapse" for="c-37171157">[-]</label><label class="expand" for="c-37171157">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for sharing. He makes the material very interesting and very accessible. I&#x27;ve fallen into another HN rabbithole..</div><br/></div></div><div id="37171185" class="c"><input type="checkbox" id="c-37171185" checked=""/><div class="controls bullet"><span class="by">photochemsyn</span><span>|</span><a href="#37170775">parent</a><span>|</span><a href="#37171157">prev</a><span>|</span><a href="#37170893">next</a><span>|</span><label class="collapse" for="c-37171185">[-]</label><label class="expand" for="c-37171185">[2 more]</label></div><br/><div class="children"><div class="content">That looks interesting, although it is 3 hrs. I like this ~45 minute intro to the concept, which seems a little more Turing-accesible:, in that it shows how you can implement addition and multiplication in the system, which is a lot:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;OLH3L285EiY" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;OLH3L285EiY</a><p>successor function: given a number, get the next number<p>try this in Python:<p>zero = lambda f: lambda x: x<p>one = lambda f: lambda x: f(x)<p>two = lambda f: lambda x: f(f(x))<p>to_int = lambda n: n(lambda i: i+1)(0)<p>succ = lambda n: lambda f: lambda x: f(n(f)(x))<p>three = succ(two)<p>four = succ(three)<p>to_int(four)<p>So that&#x27;s just counting, the Church Numerals, where it begins.</div><br/><div id="37171449" class="c"><input type="checkbox" id="c-37171449" checked=""/><div class="controls bullet"><span class="by">throwawaylinux</span><span>|</span><a href="#37170775">root</a><span>|</span><a href="#37171185">parent</a><span>|</span><a href="#37170893">next</a><span>|</span><label class="collapse" for="c-37171449">[-]</label><label class="expand" for="c-37171449">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s Turing-accesible?</div><br/></div></div></div></div></div></div><div id="37170893" class="c"><input type="checkbox" id="c-37170893" checked=""/><div class="controls bullet"><span class="by">irascibeth</span><span>|</span><a href="#37170775">prev</a><span>|</span><a href="#37172389">next</a><span>|</span><label class="collapse" for="c-37170893">[-]</label><label class="expand" for="c-37170893">[2 more]</label></div><br/><div class="children"><div class="content">This PDF is an exerpt from the book Programming Distributed Computing Systems: A Foundational Approach by Professor Carlos Varela. He was my advisor at RPI, and one of the most pleasant professors I had the pleasure of interacting with during my time there. His classes were notoriously hard, but I enjoyed them very much. The full book includes very concise walk thoughs of various other less well known calculi and theoretical distributed programming models (in particular, the AMST lambda calculus actor model). If you like language or concurrency theory I highly recommend picking up a copy.</div><br/><div id="37171683" class="c"><input type="checkbox" id="c-37171683" checked=""/><div class="controls bullet"><span class="by">craftuser</span><span>|</span><a href="#37170893">parent</a><span>|</span><a href="#37172389">next</a><span>|</span><label class="collapse" for="c-37171683">[-]</label><label class="expand" for="c-37171683">[1 more]</label></div><br/><div class="children"><div class="content">+1 from another RPI alum. One of my big regrets from college is missing out on doing undergrad research with him. <a href="https:&#x2F;&#x2F;www.cs.rpi.edu&#x2F;~cvarela&#x2F;research.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.rpi.edu&#x2F;~cvarela&#x2F;research.html</a></div><br/></div></div></div></div><div id="37172389" class="c"><input type="checkbox" id="c-37172389" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#37170893">prev</a><span>|</span><a href="#37171273">next</a><span>|</span><label class="collapse" for="c-37172389">[-]</label><label class="expand" for="c-37172389">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The normal order sequencing combinator is: Seq = λx.λy.(λz.y x) where z is chosen so that it does not appear free in y.<p>&gt; This combinator guarantees that x is evaluated before y, which is important
in programs with side-effects<p>This part didn&#x27;t make sense to me. I can apply Seq to x = Ω = (λx.x x)(λx.x x) and y = (λa.λb.b) and z = λx.x, resulting in Seq x y z = y x = λb.b, which leaves x unevaluated.<p>A sequencing operator cannot be defined <i>within</i> the lambda calculus, which has no notion of side-effect; it must be a function defined in a runtime, i.e. in an implementation of lambda calculus. An example is the function seq in Haskell.</div><br/></div></div><div id="37171273" class="c"><input type="checkbox" id="c-37171273" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#37172389">prev</a><span>|</span><a href="#37171894">next</a><span>|</span><label class="collapse" for="c-37171273">[-]</label><label class="expand" for="c-37171273">[2 more]</label></div><br/><div class="children"><div class="content">In university, I had fun actually applying lambda calculus. Here’s a very silly python script.<p><pre><code>    # a factorial function written entirely with just single-argumented lambdas
    # and calls
    fac = ((lambda p: p(p)(lambda q: lambda n: ((n(lambda e: lambda e:
      lambda a: a)(lambda i: lambda l: i))(lambda d: lambda c: c)
      (lambda m: (lambda m: lambda z: m(n(z)))(q(m)))((lambda c: lambda x:
      n(lambda g: lambda h: h(g(c)))(lambda u: x)(lambda u: u))))))
      (lambda s: lambda q: lambda w: q(s(s)(q))(w)))


    # for converting between church numerals and python numbers (you need
    # a few python functions and operators to manipulate them)
    natural = lambda c: c(lambda x: x+1)(0)
    church = lambda n: reduce(lambda x,y:
  (lambda n: lambda f: lambda x: f(n(f)(x)))(x), range(n), lambda f: lambda x: x)


    # test!
    # fac(10) is about the highest number computing in a few seconds on a core 2 CPU
    print natural(fac(church(10)))</code></pre></div><br/><div id="37171909" class="c"><input type="checkbox" id="c-37171909" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#37171273">parent</a><span>|</span><a href="#37171894">next</a><span>|</span><label class="collapse" for="c-37171909">[-]</label><label class="expand" for="c-37171909">[1 more]</label></div><br/><div class="children"><div class="content">You might enjoy this:<p><a href="https:&#x2F;&#x2F;flownet.com&#x2F;ron&#x2F;lambda-calculus.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;flownet.com&#x2F;ron&#x2F;lambda-calculus.html</a></div><br/></div></div></div></div><div id="37171894" class="c"><input type="checkbox" id="c-37171894" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#37171273">prev</a><span>|</span><a href="#37170982">next</a><span>|</span><label class="collapse" for="c-37171894">[-]</label><label class="expand" for="c-37171894">[2 more]</label></div><br/><div class="children"><div class="content">Anyone knows if lambda calculus can be done with the standard function notation, or with something closer to that? I understand that lambda calculus works with expressions and symbols, while standard function notation works with functions and values, still using the same notation seems natural to me, x -&gt; e for lambda, and e(x) for application. I haven&#x27;t worked it out, but I wonder what will I get if I do it?</div><br/><div id="37172919" class="c"><input type="checkbox" id="c-37172919" checked=""/><div class="controls bullet"><span class="by">consilient</span><span>|</span><a href="#37171894">parent</a><span>|</span><a href="#37170982">next</a><span>|</span><label class="collapse" for="c-37172919">[-]</label><label class="expand" for="c-37172919">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I understand that lambda calculus works with expressions and symbols, while standard function notation works with functions and values<p>There&#x27;s no inherent connection. You&#x27;re perfectly free to interpret lambda terms as functions on a domain, or function definitions as abstract rewrite rules.</div><br/></div></div></div></div><div id="37170982" class="c"><input type="checkbox" id="c-37170982" checked=""/><div class="controls bullet"><span class="by">noman-land</span><span>|</span><a href="#37171894">prev</a><span>|</span><a href="#37171799">next</a><span>|</span><label class="collapse" for="c-37170982">[-]</label><label class="expand" for="c-37170982">[7 more]</label></div><br/><div class="children"><div class="content">Can someone please explain to me why people always say THE lambda calculus?</div><br/><div id="37171036" class="c"><input type="checkbox" id="c-37171036" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#37170982">parent</a><span>|</span><a href="#37171936">prev</a><span>|</span><a href="#37171212">next</a><span>|</span><label class="collapse" for="c-37171036">[-]</label><label class="expand" for="c-37171036">[3 more]</label></div><br/><div class="children"><div class="content">How many do you want? If it&#x27;s eponymous, it has a definite article. The positive integers, are quite distinct from all other sets.</div><br/><div id="37171139" class="c"><input type="checkbox" id="c-37171139" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#37170982">root</a><span>|</span><a href="#37171036">parent</a><span>|</span><a href="#37171212">next</a><span>|</span><label class="collapse" for="c-37171139">[-]</label><label class="expand" for="c-37171139">[2 more]</label></div><br/><div class="children"><div class="content">That reminds me of “THE Ohio State University”, contrasting with other Big Ten schools and their common names (Illinois, Indiana, Iowa, Northwestern, Purdue,…) where the THE is often laughed about as hust funny for the reason you cite.</div><br/><div id="37171279" class="c"><input type="checkbox" id="c-37171279" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#37170982">root</a><span>|</span><a href="#37171139">parent</a><span>|</span><a href="#37171212">next</a><span>|</span><label class="collapse" for="c-37171279">[-]</label><label class="expand" for="c-37171279">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I went to THE university of York. How dare the other one have the temerity to think it was THE university of York. No no, it&#x27;s a jumped up teacher training college of Ripon and York St John, made university, just A university of York, not THE.<p>Also, York University in Canada confused things.</div><br/></div></div></div></div></div></div><div id="37171212" class="c"><input type="checkbox" id="c-37171212" checked=""/><div class="controls bullet"><span class="by">chewxy</span><span>|</span><a href="#37170982">parent</a><span>|</span><a href="#37171036">prev</a><span>|</span><a href="#37171758">next</a><span>|</span><label class="collapse" for="c-37171212">[-]</label><label class="expand" for="c-37171212">[1 more]</label></div><br/><div class="children"><div class="content">There are many lambda calculi. THE lambda calculus refers to the original lambda calculus as defined by Church.</div><br/></div></div><div id="37171758" class="c"><input type="checkbox" id="c-37171758" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#37170982">parent</a><span>|</span><a href="#37171212">prev</a><span>|</span><a href="#37171799">next</a><span>|</span><label class="collapse" for="c-37171758">[-]</label><label class="expand" for="c-37171758">[1 more]</label></div><br/><div class="children"><div class="content">It’s the lambda calculus as opposed to the pi calculus or some other calculus. &lt;article&gt; &lt;adjective&gt; &lt;noun&gt;</div><br/></div></div></div></div><div id="37171799" class="c"><input type="checkbox" id="c-37171799" checked=""/><div class="controls bullet"><span class="by">chs20</span><span>|</span><a href="#37170982">prev</a><span>|</span><a href="#37170648">next</a><span>|</span><label class="collapse" for="c-37171799">[-]</label><label class="expand" for="c-37171799">[3 more]</label></div><br/><div class="children"><div class="content">What is the motivation for lambda calculus?</div><br/><div id="37171934" class="c"><input type="checkbox" id="c-37171934" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#37171799">parent</a><span>|</span><a href="#37171970">next</a><span>|</span><label class="collapse" for="c-37171934">[-]</label><label class="expand" for="c-37171934">[1 more]</label></div><br/><div class="children"><div class="content">It was an attempt to find the simplest possible mathematical system that was universal, i.e. could compute any function.  It turns out that the answer is that function application <i>by itself</i> is universal (if functions are first-class entities).  This was a surprise at the time, and it still generally surprises people today when they first learn of it.<p>You might find this interesting:<p><a href="https:&#x2F;&#x2F;flownet.com&#x2F;ron&#x2F;lambda-calculus.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;flownet.com&#x2F;ron&#x2F;lambda-calculus.html</a></div><br/></div></div><div id="37171970" class="c"><input type="checkbox" id="c-37171970" checked=""/><div class="controls bullet"><span class="by">vishnugupta</span><span>|</span><a href="#37171799">parent</a><span>|</span><a href="#37171934">prev</a><span>|</span><a href="#37170648">next</a><span>|</span><label class="collapse" for="c-37171970">[-]</label><label class="expand" for="c-37171970">[1 more]</label></div><br/><div class="children"><div class="content">A little bit of historical background.<p>There was a concerted effort in the late 19th, early 20th century (perhaps earlier too) to mechanise computation i.e., reducing it to a pure symbolic manipulation. There were obvious benefits, a famous one being Enigma Machine that was used to (successfully I think) break the German code during WW-2.<p>On the philosophical side a parallel and overlapping effort was going on to figure out if mathematics could represent <i>all possible truths</i>, again as symbolic manipulation system. Bertrand Russel&#x27;s magnum opus Principia Mathematica [1] was one such famous work towards it. Kurt Gödel then made a breakthrough when he proved that such a system is impossible; i.e., a system can either capture all the truths or it can be consistent but not both[2]. Put differently, any mathematical system capable of representing all the truths will necessarily contain contradictions within it.<p>Now coming to your question.<p>Lambda calculus emerged in this milieu. Alonzo Church[3] invented one such system to mechanise computation, named ƛ-calculus. Using this system one can <i>mechanically</i> compute any function purely by symbolic manipulation. Later on Turing, Church&#x27;s student I think, invented a totally different system named Turing Machine with the same purpose. Later on it was proved (by Church and Turing I think, but I&#x27;m not 100% sure) that ƛ-Calculus and Turing Machine are equivalent, Church-Turing thesis[4].<p>All these work, and more, laid the theoretical foundation for the modern computers. If we can today safely assume that computers are provably correct it&#x27;s because of them.<p>Phil Wadler has an absolutely delightful talk where he takes us through a whirlwind tour of the history of the mathematical foundation of computers [5], highly recommended.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Principia_Mathematica" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Principia_Mathematica</a><p>[2]<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gödel%27s_incompleteness_theorems" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gödel%27s_incompleteness_theor...</a><p>[3] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Alonzo_Church" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Alonzo_Church</a><p>[4] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Church–Turing_thesis" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Church–Turing_thesis</a><p>[5] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=IOiZatlZtGU">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=IOiZatlZtGU</a></div><br/></div></div></div></div><div id="37170648" class="c"><input type="checkbox" id="c-37170648" checked=""/><div class="controls bullet"><span class="by">Mimmy</span><span>|</span><a href="#37171799">prev</a><span>|</span><a href="#37170559">next</a><span>|</span><label class="collapse" for="c-37170648">[-]</label><label class="expand" for="c-37170648">[4 more]</label></div><br/><div class="children"><div class="content">any idea what book this chapter is from?</div><br/><div id="37170726" class="c"><input type="checkbox" id="c-37170726" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#37170648">parent</a><span>|</span><a href="#37170559">next</a><span>|</span><label class="collapse" for="c-37170726">[-]</label><label class="expand" for="c-37170726">[3 more]</label></div><br/><div class="children"><div class="content">Programming Distributed Computing Systems A Foundational Approach<p>Carlos A. Varela<p>2013<p><a href="https:&#x2F;&#x2F;mitpress.mit.edu&#x2F;9780262018982&#x2F;programming-distributed-computing-systems&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mitpress.mit.edu&#x2F;9780262018982&#x2F;programming-distribut...</a></div><br/><div id="37170936" class="c"><input type="checkbox" id="c-37170936" checked=""/><div class="controls bullet"><span class="by">pingohits</span><span>|</span><a href="#37170648">root</a><span>|</span><a href="#37170726">parent</a><span>|</span><a href="#37170791">next</a><span>|</span><label class="collapse" for="c-37170936">[-]</label><label class="expand" for="c-37170936">[1 more]</label></div><br/><div class="children"><div class="content">I had one of his classes. He really knows his stuff. Spoke fast, no filler, and had an answer prepared for any question related to programming language theory. I felt a little bad though, because a lot of the material went over everyone&#x27;s head (it was a required course for CS majors).<p>He&#x27;s also a certified pilot.</div><br/></div></div><div id="37170791" class="c"><input type="checkbox" id="c-37170791" checked=""/><div class="controls bullet"><span class="by">mangodrunk</span><span>|</span><a href="#37170648">root</a><span>|</span><a href="#37170726">parent</a><span>|</span><a href="#37170936">prev</a><span>|</span><a href="#37170559">next</a><span>|</span><label class="collapse" for="c-37170791">[-]</label><label class="expand" for="c-37170791">[1 more]</label></div><br/><div class="children"><div class="content">You beat me to it, this is the link that I found for the book: <a href="http:&#x2F;&#x2F;wcl.cs.rpi.edu&#x2F;pdcs&#x2F;#chapters" rel="nofollow noreferrer">http:&#x2F;&#x2F;wcl.cs.rpi.edu&#x2F;pdcs&#x2F;#chapters</a></div><br/></div></div></div></div></div></div><div id="37170559" class="c"><input type="checkbox" id="c-37170559" checked=""/><div class="controls bullet"><span class="by">andsoitis</span><span>|</span><a href="#37170648">prev</a><span>|</span><label class="collapse" for="c-37170559">[-]</label><label class="expand" for="c-37170559">[22 more]</label></div><br/><div class="children"><div class="content">created by Church and Kleene in the 1930’s!<p>Even more beautiful than the y combinator</div><br/><div id="37170762" class="c"><input type="checkbox" id="c-37170762" checked=""/><div class="controls bullet"><span class="by">curryhoward</span><span>|</span><a href="#37170559">parent</a><span>|</span><a href="#37170760">next</a><span>|</span><label class="collapse" for="c-37170762">[-]</label><label class="expand" for="c-37170762">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Even more beautiful than the y combinator<p>That&#x27;s a bit of a strange statement. The Y combinator is an expression in λ calculus. It&#x27;s like saying French is even more beautiful than the phrase &quot;nouveau départ&quot;.</div><br/></div></div><div id="37170760" class="c"><input type="checkbox" id="c-37170760" checked=""/><div class="controls bullet"><span class="by">cbarrick</span><span>|</span><a href="#37170559">parent</a><span>|</span><a href="#37170762">prev</a><span>|</span><label class="collapse" for="c-37170760">[-]</label><label class="expand" for="c-37170760">[20 more]</label></div><br/><div class="children"><div class="content">They&#x27;re one and the same.<p><pre><code>    Y = λf.(λx.f (x x)) (λx.f (x x))</code></pre></div><br/><div id="37170778" class="c"><input type="checkbox" id="c-37170778" checked=""/><div class="controls bullet"><span class="by">curryhoward</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37170760">parent</a><span>|</span><label class="collapse" for="c-37170778">[-]</label><label class="expand" for="c-37170778">[19 more]</label></div><br/><div class="children"><div class="content">The Y combinator is not the same as λ calculus. The Y combinator is an expression in λ calculus.</div><br/><div id="37170841" class="c"><input type="checkbox" id="c-37170841" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37170778">parent</a><span>|</span><label class="collapse" for="c-37170841">[-]</label><label class="expand" for="c-37170841">[18 more]</label></div><br/><div class="children"><div class="content">The Y combinator is in a sense the heart of the λ calculus; it&#x27;s a key discovery for understanding that the λ calculus is universal, which is what makes it a useful concept rather than an arbitrary bundle of rules.</div><br/><div id="37170975" class="c"><input type="checkbox" id="c-37170975" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37170841">parent</a><span>|</span><a href="#37170887">next</a><span>|</span><label class="collapse" for="c-37170975">[-]</label><label class="expand" for="c-37170975">[4 more]</label></div><br/><div class="children"><div class="content">The simply typed, and, especialy, the dependently typed lambda calculi are extremely versatile and powerful subsets of untyped lambda calculus which do not admit the Y combinator. Their usefulness does not at all require universality, and are, perhaps, more useful for being typed.</div><br/><div id="37171074" class="c"><input type="checkbox" id="c-37171074" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37170975">parent</a><span>|</span><a href="#37170887">next</a><span>|</span><label class="collapse" for="c-37171074">[-]</label><label class="expand" for="c-37171074">[3 more]</label></div><br/><div class="children"><div class="content">There are many useful things that are not &quot;<i>the</i> lambda calculus&quot;. &quot;The lambda calculus&quot; is more widely known and important, largely because it is universal, hence Church-Turing thesis.</div><br/><div id="37171192" class="c"><input type="checkbox" id="c-37171192" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171074">parent</a><span>|</span><a href="#37170887">next</a><span>|</span><label class="collapse" for="c-37171192">[-]</label><label class="expand" for="c-37171192">[2 more]</label></div><br/><div class="children"><div class="content">Of course there are other useful things. But a comment argued that the presence of Y is what makes untyped lambda calculus useful. My rebuttal is that certain subsets which (intentionally) lack Y are more useful. Applications of typed calculi abound, but one rarely sees applications of the untyped calculus. Universality is not so important, it would seem. For example, infinite computations can still be modeled in typed calculi, but one has more control over them in that setting than running on &quot;bare metal&quot; untyped lambda calculus.</div><br/><div id="37171230" class="c"><input type="checkbox" id="c-37171230" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171192">parent</a><span>|</span><a href="#37170887">next</a><span>|</span><label class="collapse" for="c-37171230">[-]</label><label class="expand" for="c-37171230">[1 more]</label></div><br/><div class="children"><div class="content">Ok, &quot;useless&quot; is a slight exaggeration; non-universal calculi can be useful. But the thing that makes the lambda calculus so important and famous - the thing that makes it &quot;<i>the</i> lambda calculus - is universality, and that&#x27;s the ur-application that makes all of the subsequent application of calculi to mechanical computation possible.</div><br/></div></div></div></div></div></div></div></div><div id="37170887" class="c"><input type="checkbox" id="c-37170887" checked=""/><div class="controls bullet"><span class="by">andsoitis</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37170841">parent</a><span>|</span><a href="#37170975">prev</a><span>|</span><a href="#37170964">next</a><span>|</span><label class="collapse" for="c-37170887">[-]</label><label class="expand" for="c-37170887">[2 more]</label></div><br/><div class="children"><div class="content">&gt; heart of the λ calculus<p>The Y combinator is a specific fixed-point combinator in lambda calculus. It is used to express recursion in lambda calculus where direct recursion is not initially available due to the lack of named functions. The Y combinator  <i>demonstrates the power of lambda calculus</i>.</div><br/></div></div><div id="37170964" class="c"><input type="checkbox" id="c-37170964" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37170841">parent</a><span>|</span><a href="#37170887">prev</a><span>|</span><label class="collapse" for="c-37170964">[-]</label><label class="expand" for="c-37170964">[11 more]</label></div><br/><div class="children"><div class="content">&gt; which is what makes it a useful concept rather than an arbitrary bundle of rules.<p>I cannot recall a single practical FP language based on the Y combinator for recursion. The typical approach is to extend lambda calculus with a separate recursion primitive.</div><br/><div id="37171798" class="c"><input type="checkbox" id="c-37171798" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37170964">parent</a><span>|</span><a href="#37171082">next</a><span>|</span><label class="collapse" for="c-37171798">[-]</label><label class="expand" for="c-37171798">[1 more]</label></div><br/><div class="children"><div class="content">The Miranda programming language was an early lazy functional programming language, an ancestor of Haskell. It compiles down to combinators, and uses combinator reduction as its evaluation strategy. This became obsolete by the end of the 1980s but it’s still neat to learn how it works. One of the primitive combinators is Y. Here is its implementation: <a href="https:&#x2F;&#x2F;github.com&#x2F;pkreyenhop&#x2F;miranda&#x2F;blob&#x2F;master&#x2F;reduce.c#L400">https:&#x2F;&#x2F;github.com&#x2F;pkreyenhop&#x2F;miranda&#x2F;blob&#x2F;master&#x2F;reduce.c#L...</a></div><br/></div></div><div id="37171082" class="c"><input type="checkbox" id="c-37171082" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37170964">parent</a><span>|</span><a href="#37171798">prev</a><span>|</span><label class="collapse" for="c-37171082">[-]</label><label class="expand" for="c-37171082">[9 more]</label></div><br/><div class="children"><div class="content">The lambda calculus was never meant to be a &quot;practical FP language&quot;; it predates programming languages and even mechanical stored-program computers as we understand them.</div><br/><div id="37171138" class="c"><input type="checkbox" id="c-37171138" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171082">parent</a><span>|</span><label class="collapse" for="c-37171138">[-]</label><label class="expand" for="c-37171138">[8 more]</label></div><br/><div class="children"><div class="content">What are the useful cases of the Y combinator then? (I don&#x27;t say that the lambda calculus is useless, I was responding to a comment that claimed the lambda calculus is useless without the Y combinator.)</div><br/><div id="37171410" class="c"><input type="checkbox" id="c-37171410" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171138">parent</a><span>|</span><a href="#37171259">next</a><span>|</span><label class="collapse" for="c-37171410">[-]</label><label class="expand" for="c-37171410">[4 more]</label></div><br/><div class="children"><div class="content">the great benefit of the y-combinator is that it permits indefinite iteration in a system that seems at first glance to not support iteration at all<p>so when you&#x27;re faced with a formal system that doesn&#x27;t seem to support indefinite iteration, perhaps because you are trying to design it to guarantee termination, a useful exercise is to try to construct an analogue of the y-combinator in it<p>if you can&#x27;t, you may have gained enough insight into the problem to show that the system actually does guarantee termination, and maybe even show useful time bounds on it<p>if you can, you have usually shown the system is turing-complete, which means you can appeal to rice&#x27;s theorem whenever you are tempted to analyze the behavior of the system in any way, so you can satisfy yourself with partial decision procedures that work often enough to be useful and are conservative in the appropriate way, rather than wasting time trying to find a complete solution<p>(also if you&#x27;re designing the system you might consider either supporting iteration more directly or removing the back door)<p>every once in a while it&#x27;s also useful in practice to be able to program a weird machine, too</div><br/><div id="37171484" class="c"><input type="checkbox" id="c-37171484" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171410">parent</a><span>|</span><a href="#37171259">next</a><span>|</span><label class="collapse" for="c-37171484">[-]</label><label class="expand" for="c-37171484">[3 more]</label></div><br/><div class="children"><div class="content">&gt; the great benefit of the y-combinator is that it permits indefinite iteration in a system that seems at first glance to not support iteration at all<p>This is only the case for untyped systems. If we try to type the Y combinator, we will eventually need some notion of recursion. For example, in Haskell&#x2F;OCaml we can type it with iso&#x2F;equi-recursive types. How many truly untyped systems we use in practice?<p>The Y combinator as a counterexample of termination is a great insight though!</div><br/><div id="37171847" class="c"><input type="checkbox" id="c-37171847" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171484">parent</a><span>|</span><a href="#37171540">next</a><span>|</span><label class="collapse" for="c-37171847">[-]</label><label class="expand" for="c-37171847">[1 more]</label></div><br/><div class="children"><div class="content">Dynamically typed programming languages are statically untyped.<p>You might argue they are unityped, but that’s really a type theoretician’s job security: if a language has the untyped lambda calculus as a subset (like the python example in this discussion) it’s reasonable to call it untyped.</div><br/></div></div><div id="37171540" class="c"><input type="checkbox" id="c-37171540" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171484">parent</a><span>|</span><a href="#37171847">prev</a><span>|</span><a href="#37171259">next</a><span>|</span><label class="collapse" for="c-37171540">[-]</label><label class="expand" for="c-37171540">[1 more]</label></div><br/><div class="children"><div class="content">typing is often an excellent way to ensure termination</div><br/></div></div></div></div></div></div><div id="37171259" class="c"><input type="checkbox" id="c-37171259" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171138">parent</a><span>|</span><a href="#37171410">prev</a><span>|</span><label class="collapse" for="c-37171259">[-]</label><label class="expand" for="c-37171259">[3 more]</label></div><br/><div class="children"><div class="content">Emulating recursion, and more generally the whole Church-Turing thesis. The fact that you can represent mechanical computation through, well, computation - the fact that equating those concepts makes sense at all, which was such a huge innovation that today it seems too banal to even notice.</div><br/><div id="37171446" class="c"><input type="checkbox" id="c-37171446" checked=""/><div class="controls bullet"><span class="by">Hirrolot</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171259">parent</a><span>|</span><label class="collapse" for="c-37171446">[-]</label><label class="expand" for="c-37171446">[2 more]</label></div><br/><div class="children"><div class="content">You keep answering with the same words though. My question was _where_ the Y combinator is useful, not _what_ it is designed for, which I am of course aware of.</div><br/><div id="37172052" class="c"><input type="checkbox" id="c-37172052" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37170559">root</a><span>|</span><a href="#37171446">parent</a><span>|</span><label class="collapse" for="c-37172052">[-]</label><label class="expand" for="c-37172052">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean &quot;where&quot;? In Princeton? In the Proceedings of the London Mathematical Society? In the head of anyone who presumes to think about computation?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>