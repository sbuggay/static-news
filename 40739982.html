<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1718960454039" as="style"/><link rel="stylesheet" href="styles.css?v=1718960454039"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.octomind.dev/blog/why-we-no-longer-use-langchain-for-building-our-ai-agents">We no longer use LangChain for building our AI agents</a> <span class="domain">(<a href="https://www.octomind.dev">www.octomind.dev</a>)</span></div><div class="subtext"><span>ma_za</span> | <span>117 comments</span></div><br/><div><div id="40746797" class="c"><input type="checkbox" id="c-40746797" checked=""/><div class="controls bullet"><span class="by">geuis</span><span>|</span><a href="#40745934">next</a><span>|</span><label class="collapse" for="c-40746797">[-]</label><label class="expand" for="c-40746797">[4 more]</label></div><br/><div class="children"><div class="content">I built my first commercial LLM agent back in October&#x2F;November last year. As a newcomer to the LLM space, every tutorial and youtube video was about using LangChain. But something about the project had that &quot;bad code&quot; smell about it.<p>I was fortunate in that the person I was building the project for was able to introduce me to a few other people more experienced with the entire nascent LLM agent field and both of them strongly steered me away from LangChain.<p>Avoiding going down that minefield ridden path really helped me out early on, and instead I focused more on learning how to build agents &quot;from scratch&quot; more or less. That gave me a much better handle on how to interact with agents and has led me more into learning how to run the various models independently of the API providers and get more productive results.</div><br/><div id="40746900" class="c"><input type="checkbox" id="c-40746900" checked=""/><div class="controls bullet"><span class="by">SCUSKU</span><span>|</span><a href="#40746797">parent</a><span>|</span><a href="#40747387">next</a><span>|</span><label class="collapse" for="c-40746900">[-]</label><label class="expand" for="c-40746900">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve only ever played around with it and not built out an app like you have, but in my experience the second you want to go off script from what the tutorials suggest, it becomes an impossible nightmare of reading source code trying to get a basic thing to work. LangChain is _the_ definition of death by abstraction.</div><br/><div id="40747512" class="c"><input type="checkbox" id="c-40747512" checked=""/><div class="controls bullet"><span class="by">emporas</span><span>|</span><a href="#40746797">root</a><span>|</span><a href="#40746900">parent</a><span>|</span><a href="#40747387">next</a><span>|</span><label class="collapse" for="c-40747512">[-]</label><label class="expand" for="c-40747512">[1 more]</label></div><br/><div class="children"><div class="content">I have read the whole source of LangChain in Rust (there are no docs anyway), and it definitely seems over-engineering. The central premise of the project, of complicated chains of prompts is not useful to many people, and not to me either.<p>On the other hand it took some years into the web, for some web frameworks to emerge and make sense, like Ruby on Rails. Maybe in 3-4 years time, complicated chains of commands to different A.I. engines will be so difficult to get right that a framework might make sense, and establish a set of conventions.<p>Agents, another central feature of LangChain, are not proved to be very useful as well, for the moment.</div><br/></div></div></div></div><div id="40747387" class="c"><input type="checkbox" id="c-40747387" checked=""/><div class="controls bullet"><span class="by">netdevnet</span><span>|</span><a href="#40746797">parent</a><span>|</span><a href="#40746900">prev</a><span>|</span><a href="#40745934">next</a><span>|</span><label class="collapse" for="c-40747387">[-]</label><label class="expand" for="c-40747387">[1 more]</label></div><br/><div class="children"><div class="content">what does build an llm agent mean? i&#x27;m guessing you used a preexisting foundation model, didn&#x27;t you?</div><br/></div></div></div></div><div id="40745934" class="c"><input type="checkbox" id="c-40745934" checked=""/><div class="controls bullet"><span class="by">muzani</span><span>|</span><a href="#40746797">prev</a><span>|</span><a href="#40742912">next</a><span>|</span><label class="collapse" for="c-40745934">[-]</label><label class="expand" for="c-40745934">[11 more]</label></div><br/><div class="children"><div class="content">Langchain was released in October 2022. ChatGPT was released in November 2022.<p>Langchain was <i>before</i> chat models were invented. It let us turn these one-shot APIs into Markov chains. ChatGPT came in and made us realize we didn&#x27;t want Markov chains; a conversational structure worked just as well.<p>After ChatGPT and GPT 3.5, there were no more non-chat models in the LLM world. Chat models worked great for everything, including what we used instruct &amp; completion models for. Langchain doing chat models is just completely redundant with its original purpose.</div><br/><div id="40745948" class="c"><input type="checkbox" id="c-40745948" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#40745934">parent</a><span>|</span><a href="#40746868">next</a><span>|</span><label class="collapse" for="c-40745948">[-]</label><label class="expand" for="c-40745948">[3 more]</label></div><br/><div class="children"><div class="content">We use instruct models extensively as we find smaller models fine tuned to our prompts perform better when general chat models that are much larger. This lets us run inference that can be 1000x cheaper than 3.5, meaning both money saving and much better latencies.</div><br/><div id="40745980" class="c"><input type="checkbox" id="c-40745980" checked=""/><div class="controls bullet"><span class="by">muzani</span><span>|</span><a href="#40745934">root</a><span>|</span><a href="#40745948">parent</a><span>|</span><a href="#40746328">prev</a><span>|</span><a href="#40746868">next</a><span>|</span><label class="collapse" for="c-40745980">[-]</label><label class="expand" for="c-40745980">[1 more]</label></div><br/><div class="children"><div class="content">This feels like a valid use for langchain then. Thanks for sharing.<p>Which models do you use and for what use cases? 1000x is quite a lot of savings; normally even with fine-tuning it&#x27;s at most 3x cheaper. Any cheaper we&#x27;d need to get like $100k of hardware.</div><br/></div></div></div></div><div id="40746868" class="c"><input type="checkbox" id="c-40746868" checked=""/><div class="controls bullet"><span class="by">pietro72ohboy</span><span>|</span><a href="#40745934">parent</a><span>|</span><a href="#40745948">prev</a><span>|</span><a href="#40747208">next</a><span>|</span><label class="collapse" for="c-40746868">[-]</label><label class="expand" for="c-40746868">[3 more]</label></div><br/><div class="children"><div class="content">Chat models were not invented with ChatGPT. Conversational search and AI was a well-established field of study well before ChatGPT. It is remarkable how many people unfamiliar with the field think ChatGPT was the first chat model. It may be the first widely-popular chat model but it certainly isn’t the first</div><br/><div id="40747129" class="c"><input type="checkbox" id="c-40747129" checked=""/><div class="controls bullet"><span class="by">chewxy</span><span>|</span><a href="#40745934">root</a><span>|</span><a href="#40746868">parent</a><span>|</span><a href="#40747208">next</a><span>|</span><label class="collapse" for="c-40747129">[-]</label><label class="expand" for="c-40747129">[2 more]</label></div><br/><div class="children"><div class="content">Dana Angluin&#x27;s group were studying chat systems way back in 1992. There even was a conference around conversational AI back then.</div><br/><div id="40747305" class="c"><input type="checkbox" id="c-40747305" checked=""/><div class="controls bullet"><span class="by">muzani</span><span>|</span><a href="#40745934">root</a><span>|</span><a href="#40747129">parent</a><span>|</span><a href="#40747208">next</a><span>|</span><label class="collapse" for="c-40747305">[-]</label><label class="expand" for="c-40747305">[1 more]</label></div><br/><div class="children"><div class="content">Thank you folks for the correction!</div><br/></div></div></div></div></div></div><div id="40747208" class="c"><input type="checkbox" id="c-40747208" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#40745934">parent</a><span>|</span><a href="#40746868">prev</a><span>|</span><a href="#40746733">next</a><span>|</span><label class="collapse" for="c-40747208">[-]</label><label class="expand" for="c-40747208">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Chat models worked great for everything, including what we used instruct &amp; completion models for<p>In 2022, I built and used a bot using the older completion model. After GPT3.5&#x2F;the chat completions API came around, I switched to them, and what I found was that the output was actually way worse. It started producing all those robotic &quot;As an AI language model, I cannot...&quot; and &quot;It&#x27;s important to note that...&quot; all the time. The older completion models didn&#x27;t have such.</div><br/></div></div><div id="40746733" class="c"><input type="checkbox" id="c-40746733" checked=""/><div class="controls bullet"><span class="by">isaacfung</span><span>|</span><a href="#40745934">parent</a><span>|</span><a href="#40747208">prev</a><span>|</span><a href="#40742912">next</a><span>|</span><label class="collapse" for="c-40746733">[-]</label><label class="expand" for="c-40746733">[3 more]</label></div><br/><div class="children"><div class="content">I am not sure what you mean by &quot;turn these one-shot APIs into Markov chains.&quot; To me, langchain was mostly marketed as a framework that makes RAG easy by providing integration with all kinds of data sources(vector db, pdf, sql db, web search, etc). Also older models(including initial chatgpt) had limited context lengths. Langchain helped you to manage the conversation memory by splitting it up and storing the pieces in a vector db. Another thing langchain did was implementing the react framework(which you can implement with a few lines of code) to help you answer multi hop problems.</div><br/><div id="40747257" class="c"><input type="checkbox" id="c-40747257" checked=""/><div class="controls bullet"><span class="by">muzani</span><span>|</span><a href="#40745934">root</a><span>|</span><a href="#40746733">parent</a><span>|</span><a href="#40746794">next</a><span>|</span><label class="collapse" for="c-40747257">[-]</label><label class="expand" for="c-40747257">[1 more]</label></div><br/><div class="children"><div class="content">Yup, I meant &quot;Markov chain&quot; as a way to say state. The idea was that it was extremely complex to control state. You&#x27;d talk about a topic and then jump to another topic, but you want to keep context of that previous topic, as you say.<p>Was RAG popular on release? Google Trends indicates it started appearing around April 2023.<p>To be honest, I&#x27;m trying to reverse engineer its popularity, and I think there are better solutions out there for RAG. But I believe people were already using Langchain as GPT 3.5 was taking off, so it&#x27;s likely they changed the marketing to cover RAG.</div><br/></div></div><div id="40746794" class="c"><input type="checkbox" id="c-40746794" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#40745934">root</a><span>|</span><a href="#40746733">parent</a><span>|</span><a href="#40747257">prev</a><span>|</span><a href="#40742912">next</a><span>|</span><label class="collapse" for="c-40746794">[-]</label><label class="expand" for="c-40746794">[1 more]</label></div><br/><div class="children"><div class="content">I too wondered about <i>&quot;by &quot;turn these one-shot APIs into Markov chains.&quot;</i>.</div><br/></div></div></div></div></div></div><div id="40742912" class="c"><input type="checkbox" id="c-40742912" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#40745934">prev</a><span>|</span><a href="#40744895">next</a><span>|</span><label class="collapse" for="c-40742912">[-]</label><label class="expand" for="c-40742912">[9 more]</label></div><br/><div class="children"><div class="content">Bigger problem might be using agents in the first place.<p>We did some testing with agents for content generation (e.g. &quot;authoring&quot; agent, &quot;researcher&quot; agent, &quot;editor&quot; agent) and found that it was easier to just write it as 3 sequential prompts with an explicit control loop.<p>It&#x27;s easier to debug, monitor, and control the output flow this way.<p>But we still use Semantic Kernel[0] because the lowest level abstractions that it provides are still very useful in reducing the code that we have to roll ourselves and also makes some parts of the API very flexible.  These are things we&#x27;d end up writing ourselves anyways so why not just use the framework primitives instead?<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;semantic-kernel">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;semantic-kernel</a></div><br/><div id="40743989" class="c"><input type="checkbox" id="c-40743989" checked=""/><div class="controls bullet"><span class="by">Kiro</span><span>|</span><a href="#40742912">parent</a><span>|</span><a href="#40746986">next</a><span>|</span><label class="collapse" for="c-40743989">[-]</label><label class="expand" for="c-40743989">[7 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the difference? I thought &quot;agents&quot; was just a fancier word for sequential prompts.</div><br/><div id="40744447" class="c"><input type="checkbox" id="c-40744447" checked=""/><div class="controls bullet"><span class="by">CharlieDigital</span><span>|</span><a href="#40742912">root</a><span>|</span><a href="#40743989">parent</a><span>|</span><a href="#40744413">next</a><span>|</span><label class="collapse" for="c-40744447">[-]</label><label class="expand" for="c-40744447">[1 more]</label></div><br/><div class="children"><div class="content">Typically, the term &quot;agents&quot; implies some autonomous collaboration.  In an agent workflow, the flow itself is non-deterministic. One agent can work with another agent and keep cycling between themselves until an output is resolved that meets some criteria. An agent itself is also typically evaluating the terminal condition for the workflow.</div><br/></div></div><div id="40744413" class="c"><input type="checkbox" id="c-40744413" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#40742912">root</a><span>|</span><a href="#40743989">parent</a><span>|</span><a href="#40744447">prev</a><span>|</span><a href="#40746818">next</a><span>|</span><label class="collapse" for="c-40744413">[-]</label><label class="expand" for="c-40744413">[1 more]</label></div><br/><div class="children"><div class="content">Some folks try to orchestrate the whole operation by a higher level prompt that essentially uses function calls to more specific prompts.<p>Versus just using the LLM’s for specific tasks and heuristics &#x2F; own code for the orchestration.<p>But I agree there is a lot of anthropomorphizing that over states current model capabilities and just confuses things in general.</div><br/></div></div><div id="40746818" class="c"><input type="checkbox" id="c-40746818" checked=""/><div class="controls bullet"><span class="by">isaacfung</span><span>|</span><a href="#40742912">root</a><span>|</span><a href="#40743989">parent</a><span>|</span><a href="#40744413">prev</a><span>|</span><a href="#40746735">next</a><span>|</span><label class="collapse" for="c-40746818">[-]</label><label class="expand" for="c-40746818">[1 more]</label></div><br/><div class="children"><div class="content">Some &quot;agents&quot; like the minecraft bot Voyager(<a href="https:&#x2F;&#x2F;github.com&#x2F;MineDojo&#x2F;Voyager">https:&#x2F;&#x2F;github.com&#x2F;MineDojo&#x2F;Voyager</a>) have a control loop, they are given a high level task and then they use LLM to decide what actions to take, then evaluate the result and iterate. In some LLM frameworks, a chain&#x2F;pipeline just uses LLM to process input data(classification, named entitiy extraction, summary, etc).</div><br/></div></div><div id="40746735" class="c"><input type="checkbox" id="c-40746735" checked=""/><div class="controls bullet"><span class="by">mstipetic</span><span>|</span><a href="#40742912">root</a><span>|</span><a href="#40743989">parent</a><span>|</span><a href="#40746818">prev</a><span>|</span><a href="#40744887">next</a><span>|</span><label class="collapse" for="c-40746735">[-]</label><label class="expand" for="c-40746735">[1 more]</label></div><br/><div class="children"><div class="content">Sequential prompts with an occasional cron job</div><br/></div></div><div id="40744887" class="c"><input type="checkbox" id="c-40744887" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#40742912">root</a><span>|</span><a href="#40743989">parent</a><span>|</span><a href="#40746735">prev</a><span>|</span><a href="#40744731">next</a><span>|</span><label class="collapse" for="c-40744887">[-]</label><label class="expand" for="c-40744887">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also used to mean &quot;characters interacting with each other&quot; and sort of message passing between them. Not sure but I get the sense thats what the author is using it as</div><br/></div></div><div id="40744731" class="c"><input type="checkbox" id="c-40744731" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#40742912">root</a><span>|</span><a href="#40743989">parent</a><span>|</span><a href="#40744887">prev</a><span>|</span><a href="#40746986">next</a><span>|</span><label class="collapse" for="c-40744731">[-]</label><label class="expand" for="c-40744731">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Agent&quot; means that it outputs JSON with a function call name and parameters which you execute and usually then feed the results back to the LLM.</div><br/></div></div></div></div><div id="40746986" class="c"><input type="checkbox" id="c-40746986" checked=""/><div class="controls bullet"><span class="by">huevosabio</span><span>|</span><a href="#40742912">parent</a><span>|</span><a href="#40743989">prev</a><span>|</span><a href="#40744895">next</a><span>|</span><label class="collapse" for="c-40746986">[-]</label><label class="expand" for="c-40746986">[1 more]</label></div><br/><div class="children"><div class="content">What does semantic kernel do for you? It isn&#x27;t immediately obvious from the Readme.</div><br/></div></div></div></div><div id="40744895" class="c"><input type="checkbox" id="c-40744895" checked=""/><div class="controls bullet"><span class="by">elijahbenizzy</span><span>|</span><a href="#40742912">prev</a><span>|</span><a href="#40747376">next</a><span>|</span><label class="collapse" for="c-40744895">[-]</label><label class="expand" for="c-40744895">[3 more]</label></div><br/><div class="children"><div class="content">I really like the idea of &quot;good&quot; and &quot;bad&quot; abstractions. I have absolutely built both.<p>This sentiment is echoed in this comment in reddit comment as well: <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;LocalLLaMA&#x2F;comments&#x2F;1d4p1t6&#x2F;comment&#x2F;l6g1b3t&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;LocalLLaMA&#x2F;comments&#x2F;1d4p1t6&#x2F;comment...</a>.<p>Similarly to this post, I think that the &quot;good&quot; abstractions handle application logic (telemetry, state management, common complexity), and the &quot;bad&quot; abstractions make things abstract away tasks that you really need insight into.<p>This has been a big part of our philosophy on Burr (<a href="https:&#x2F;&#x2F;github.com&#x2F;dagworks-inc&#x2F;burr">https:&#x2F;&#x2F;github.com&#x2F;dagworks-inc&#x2F;burr</a>), and basically everything we build -- we never want to tell how people should interact with LLMs, rather solve the common problems. Still learning about what makes a good&#x2F;bad abstraction in this space -- people really quickly reach for something like langchain then get sick of abstractions right after that and build their own stuff.</div><br/><div id="40745201" class="c"><input type="checkbox" id="c-40745201" checked=""/><div class="controls bullet"><span class="by">laborcontract</span><span>|</span><a href="#40744895">parent</a><span>|</span><a href="#40747376">next</a><span>|</span><label class="collapse" for="c-40745201">[-]</label><label class="expand" for="c-40745201">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; the &quot;bad&quot; abstractions make things abstract away tasks that you really need insight into.
</code></pre>
Yup. People say to use langchain to prototype stuff before it goes into production but I find it falls flat there. The documentation is horrible and they explain absolutely zero about the methods they use, so the only way to “learn” is by reading their spaghetti code.</div><br/><div id="40745634" class="c"><input type="checkbox" id="c-40745634" checked=""/><div class="controls bullet"><span class="by">elijahbenizzy</span><span>|</span><a href="#40744895">root</a><span>|</span><a href="#40745201">parent</a><span>|</span><a href="#40747376">next</a><span>|</span><label class="collapse" for="c-40745634">[-]</label><label class="expand" for="c-40745634">[1 more]</label></div><br/><div class="children"><div class="content">Agreed — also I’m generally against prototyping stuff and then entirely rewriting it for production as the default approach. It’s a nice idea but nobody ever actually rewrites it (or they do and it’s exceedingly painful). In true research it makes sense, but very little of what engineers do falls under that category.<p>Instead, it’s either “welp, pushed this to prod and got promoted and it’s someone else’s problem” or “sorry, this valuable thing is too complex to do right but this cool demo got me promoted...”</div><br/></div></div></div></div></div></div><div id="40747376" class="c"><input type="checkbox" id="c-40747376" checked=""/><div class="controls bullet"><span class="by">fragebogen</span><span>|</span><a href="#40744895">prev</a><span>|</span><a href="#40746708">next</a><span>|</span><label class="collapse" for="c-40747376">[-]</label><label class="expand" for="c-40747376">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d challenge some of these criticisms and give my 2c on this.
I&#x27;ve spent the last 6 months working on a rather complex chat with routes, agents, bells and whistles sort of system. Initially, time to POC was short, so I picked it to get quick at my feet. Eventually, I thought. The code base isn&#x27;t enormous, I can easily rewrite it, but I&#x27;d like to see what people mean with &quot;abstraction limiting progress&quot; kind of statements. I&#x27;ve now kept building this project for another 6 months and I must say the more I work with it and understand its philosophy.<p>It&#x27;s not that complicated. The philosophy is just different from many other python projects. The LCEL pipes for example is a really nice way to think of modularity. Want to switch out one model for another? Well just import another model and replace the old. Want to parse it more strictly, exchange the parser. The fact that everything is an instance of `RunnableSerializable` is a really convenient way of making things truly modular. Want to test your pipe syncronously? Easy just use `.stream()` instead of `.astream()` and get on with it.<p>I think my biggest hurdle was understanding how to debug and pipe components, but once I got familiarized with it, I must say it made me grow as a python dev and appreciate the structure and thought behind it.
Where complexity arise is when you have a multi-step setup, some sync and some async. I&#x27;ve had to break some of these steps up in code, but otherwise it gives me tons of flexibility to pick and chose components.<p>My only real complaint would be lack of documentation and outdated documentation, I&#x27;m hardly the only one, but it really is frustrating sometimes to understand what some niche module can and cannot do.</div><br/></div></div><div id="40746708" class="c"><input type="checkbox" id="c-40746708" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#40747376">prev</a><span>|</span><a href="#40747430">next</a><span>|</span><label class="collapse" for="c-40746708">[-]</label><label class="expand" for="c-40746708">[7 more]</label></div><br/><div class="children"><div class="content">Sorry noob question - where can I read more about this &quot;agents&quot; paradigm? Is one agent&#x27;s output directly calling&#x2F;invoking another agent? Or there&#x27;s already fixed graph of information flow with each agent (I presume some prompt presets&#x2F;templates like &quot;you are an expert this only respond in that&quot;) sorts of?<p>Also, how much success people have or had with automating the E2E tests for their various apps by stringing such agents together themselves<p>EDIT: Typos</div><br/><div id="40746736" class="c"><input type="checkbox" id="c-40746736" checked=""/><div class="controls bullet"><span class="by">zEddSH</span><span>|</span><a href="#40746708">parent</a><span>|</span><a href="#40746771">next</a><span>|</span><label class="collapse" for="c-40746736">[-]</label><label class="expand" for="c-40746736">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Also, how much success people have or had with automating the E2E tests for their various apps by stringing such agents themselves together?<p>There’s a few startups in the space doing this like QA Tech in Stockholm, and others even in YC (but I forgot the name). I’m skeptical of how successful they’ll be, not just from complex test cases but things like data management and mistakingly affecting other tests. Interesting to follow just in case though, E2E is a pain!</div><br/></div></div><div id="40746771" class="c"><input type="checkbox" id="c-40746771" checked=""/><div class="controls bullet"><span class="by">zby</span><span>|</span><a href="#40746708">parent</a><span>|</span><a href="#40746736">prev</a><span>|</span><a href="#40746732">next</a><span>|</span><label class="collapse" for="c-40746771">[-]</label><label class="expand" for="c-40746771">[1 more]</label></div><br/><div class="children"><div class="content">In practice this means function calling - the LLM chooses the function to call (and its parameters). Usually in a loop with a &#x27;finish&#x27; function that returns the control to the outside code.<p>You can do that without function calling - as did the original ReAct paper - but then you have to write your own grammar for the communication with the LLM, a parser for it, and also you need to teach the LLM to use that grammar. This is very time consuming.</div><br/></div></div><div id="40746732" class="c"><input type="checkbox" id="c-40746732" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#40746708">parent</a><span>|</span><a href="#40746771">prev</a><span>|</span><a href="#40746745">next</a><span>|</span><label class="collapse" for="c-40746732">[-]</label><label class="expand" for="c-40746732">[1 more]</label></div><br/><div class="children"><div class="content">Fundamentally, &quot;Agent&quot; refers to anything that operates in an &quot;observe-act&quot; loop. So in the context of LLMs, an agent sees an observation (like the code base and test output) and produces an action (like a patch), and repeats.</div><br/></div></div><div id="40746745" class="c"><input type="checkbox" id="c-40746745" checked=""/><div class="controls bullet"><span class="by">pavi2410</span><span>|</span><a href="#40746708">parent</a><span>|</span><a href="#40746732">prev</a><span>|</span><a href="#40746750">next</a><span>|</span><label class="collapse" for="c-40746745">[-]</label><label class="expand" for="c-40746745">[1 more]</label></div><br/><div class="children"><div class="content">I want to learn about agents too!</div><br/></div></div><div id="40746750" class="c"><input type="checkbox" id="c-40746750" checked=""/><div class="controls bullet"><span class="by">hcks</span><span>|</span><a href="#40746708">parent</a><span>|</span><a href="#40746745">prev</a><span>|</span><a href="#40747430">next</a><span>|</span><label class="collapse" for="c-40746750">[-]</label><label class="expand" for="c-40746750">[2 more]</label></div><br/><div class="children"><div class="content">Don’t waste your time, it’s been around since GPT3, and had no results so far. Also notice how no frontier lab is working on it.</div><br/><div id="40746791" class="c"><input type="checkbox" id="c-40746791" checked=""/><div class="controls bullet"><span class="by">zby</span><span>|</span><a href="#40746708">root</a><span>|</span><a href="#40746750">parent</a><span>|</span><a href="#40747430">next</a><span>|</span><label class="collapse" for="c-40746791">[-]</label><label class="expand" for="c-40746791">[1 more]</label></div><br/><div class="children"><div class="content">Letting the LLM to decide what to do is a powerful technique. For example one pass RAG is very limited: <a href="https:&#x2F;&#x2F;zzbbyy.substack.com&#x2F;p&#x2F;why-iterative-thinking-is-crucial" rel="nofollow">https:&#x2F;&#x2F;zzbbyy.substack.com&#x2F;p&#x2F;why-iterative-thinking-is-cruc...</a> To make it iterative you need the cede the control to the LLM.</div><br/></div></div></div></div></div></div><div id="40747430" class="c"><input type="checkbox" id="c-40747430" checked=""/><div class="controls bullet"><span class="by">Oras</span><span>|</span><a href="#40746708">prev</a><span>|</span><a href="#40746412">next</a><span>|</span><label class="collapse" for="c-40747430">[-]</label><label class="expand" for="c-40747430">[1 more]</label></div><br/><div class="children"><div class="content">The comments are good example that hype &gt; quality.<p>99% of docs mentioning LangChain or showing a code example with LangChain. Wherever you look at tutorials or YouTube videos, you will see LangChain.<p>They take the credit of being the first framework to abstract LLM calls and other features such as reading data from multiple sources (before function calling was a thing).<p>Langchain was first, got popular, and hence for new comers they think it’s the way, until they use it.</div><br/></div></div><div id="40746412" class="c"><input type="checkbox" id="c-40746412" checked=""/><div class="controls bullet"><span class="by">empiko</span><span>|</span><a href="#40747430">prev</a><span>|</span><a href="#40747091">next</a><span>|</span><label class="collapse" for="c-40746412">[-]</label><label class="expand" for="c-40746412">[1 more]</label></div><br/><div class="children"><div class="content">This echoes our experience with LangChain, although we have abandoned it before putting it into production. We found out that for simple use cases it&#x27;s too complex (as mentioned in the blog), and for complex use cases it&#x27;s too difficult to adapt. We were not able to identify what is the sweet spot when it is worth it to use it. We felt like we can easily code ourselves most of its functionality very quickly and in a way that fits our requirements.</div><br/></div></div><div id="40747091" class="c"><input type="checkbox" id="c-40747091" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#40746412">prev</a><span>|</span><a href="#40744572">next</a><span>|</span><label class="collapse" for="c-40747091">[-]</label><label class="expand" for="c-40747091">[1 more]</label></div><br/><div class="children"><div class="content">This is so common I think it could just about be a lemma:<p>Any tool that that helps you to get up and running quicker by abstracting away boilerplate will eventually get in the way as your projects complexity increases.</div><br/></div></div><div id="40744572" class="c"><input type="checkbox" id="c-40744572" checked=""/><div class="controls bullet"><span class="by">altdataseller</span><span>|</span><a href="#40747091">prev</a><span>|</span><a href="#40746695">next</a><span>|</span><label class="collapse" for="c-40744572">[-]</label><label class="expand" for="c-40744572">[10 more]</label></div><br/><div class="children"><div class="content">Langchain reminds me of GraphQL. A technology that a lot of ppl seem to hype about, sounds like something you should use because all the cool kids use it, but at the end of the day just makes things unncessarily complicated.</div><br/><div id="40744631" class="c"><input type="checkbox" id="c-40744631" checked=""/><div class="controls bullet"><span class="by">OutOfHere</span><span>|</span><a href="#40744572">parent</a><span>|</span><a href="#40745039">next</a><span>|</span><label class="collapse" for="c-40744631">[-]</label><label class="expand" for="c-40744631">[7 more]</label></div><br/><div class="children"><div class="content">GraphQL actually holds value in my view as it gives custom SQL-like functionality instead of basic JSON APIs. With it, you can do fewer calls and retrieve only the attributes you need. Granted, if SQL were directly an API, then GraphQL wouldn&#x27;t hold too much value.<p>Langchain has no such benefit.</div><br/><div id="40744784" class="c"><input type="checkbox" id="c-40744784" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#40744572">root</a><span>|</span><a href="#40744631">parent</a><span>|</span><a href="#40744694">next</a><span>|</span><label class="collapse" for="c-40744784">[-]</label><label class="expand" for="c-40744784">[1 more]</label></div><br/><div class="children"><div class="content">SQL has sophisticated WHERE clause support, GraphQL doesn&#x27;t. It should be called GraphPickL.</div><br/></div></div><div id="40744694" class="c"><input type="checkbox" id="c-40744694" checked=""/><div class="controls bullet"><span class="by">andybak</span><span>|</span><a href="#40744572">root</a><span>|</span><a href="#40744631">parent</a><span>|</span><a href="#40744784">prev</a><span>|</span><a href="#40744886">next</a><span>|</span><label class="collapse" for="c-40744694">[-]</label><label class="expand" for="c-40744694">[4 more]</label></div><br/><div class="children"><div class="content">Surely SQL <i>is</i> an API? The line between language and API is fairly blurry.</div><br/><div id="40744726" class="c"><input type="checkbox" id="c-40744726" checked=""/><div class="controls bullet"><span class="by">newzisforsukas</span><span>|</span><a href="#40744572">root</a><span>|</span><a href="#40744694">parent</a><span>|</span><a href="#40744886">next</a><span>|</span><label class="collapse" for="c-40744726">[-]</label><label class="expand" for="c-40744726">[3 more]</label></div><br/><div class="children"><div class="content">Can you elaborate?</div><br/><div id="40745243" class="c"><input type="checkbox" id="c-40745243" checked=""/><div class="controls bullet"><span class="by">manquer</span><span>|</span><a href="#40744572">root</a><span>|</span><a href="#40744726">parent</a><span>|</span><a href="#40744886">next</a><span>|</span><label class="collapse" for="c-40745243">[-]</label><label class="expand" for="c-40745243">[2 more]</label></div><br/><div class="children"><div class="content">What GP means is it is a Programmable Interface, any interface you can interact against is an API. That means any programing complete language is an API, so are sign languages or human languages.<p>While nobody does it , SQL implementations have network API,  authentication, authorization, ACL&#x2F;RBAC, serialization, Business logic all the things you use in RESTful apis can all be done with just db servers.<p>You can expose in theory a direct SQL API to clients to consume without any other language or other components to the stack .<p>Most SQL servers use some layer on top of TCP&#x2F;IP to connect their backends to frontend .libpq is the client which does this in postgreSQL for example .<p>You could either wrap that in Backend SQL server with an extension and talk to browser and other clients in HTTP[1], or you can write a wasm client in browsers to directly talk to TCP&#x2F;IP port on the SQL server<p>Perhaps if you are oracle , that makes sense, but for no one else, they do build and push products that basically do parts of this .<p>[1] projects like postgREST basically do this .</div><br/><div id="40746197" class="c"><input type="checkbox" id="c-40746197" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40744572">root</a><span>|</span><a href="#40745243">parent</a><span>|</span><a href="#40744886">next</a><span>|</span><label class="collapse" for="c-40746197">[-]</label><label class="expand" for="c-40746197">[1 more]</label></div><br/><div class="children"><div class="content">SQL (as an API) and databases are orthogonal, though. In fact, I work on an application that uses SQL for its API even though it doesn&#x27;t even have a database directly attached. All of its data comes from third-parties that only make the data available using REST services.<p>In theory, the app servers that sit in front of those databases could just as easily use SQL instead of GraphQL. Even practically:  The libraries around working with SQL in this way have become quite good. <i>But</i> they solve different problems. If you have a problem GraphQL is well suited to solve, SQL will not be a suitable replacement – and vice versa.</div><br/></div></div></div></div></div></div></div></div><div id="40744886" class="c"><input type="checkbox" id="c-40744886" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#40744572">root</a><span>|</span><a href="#40744631">parent</a><span>|</span><a href="#40744694">prev</a><span>|</span><a href="#40745039">next</a><span>|</span><label class="collapse" for="c-40744886">[-]</label><label class="expand" for="c-40744886">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>if SQL were directly an API</i><p>Isn&#x27;t that what SQL&#x2F;CLI is for? <a href="https:&#x2F;&#x2F;publications.opengroup.org&#x2F;c451" rel="nofollow">https:&#x2F;&#x2F;publications.opengroup.org&#x2F;c451</a></div><br/></div></div></div></div><div id="40745039" class="c"><input type="checkbox" id="c-40745039" checked=""/><div class="controls bullet"><span class="by">ahzhou</span><span>|</span><a href="#40744572">parent</a><span>|</span><a href="#40744631">prev</a><span>|</span><a href="#40745078">next</a><span>|</span><label class="collapse" for="c-40745039">[-]</label><label class="expand" for="c-40745039">[1 more]</label></div><br/><div class="children"><div class="content">GraphQL is very powerful when combined with Relay. It’s useless extra bloat if you just use it like REST.<p>The difference between the two technologies is that LangChain was developed and funded before anyone know what to do with LLMs and GraphQL was internal tooling using to solve a real problem at Meta.<p>In a lot of ways, LangChain is a poor abstraction because the layer it’s abstracting was (and still is) in it’s infancy.</div><br/></div></div><div id="40745078" class="c"><input type="checkbox" id="c-40745078" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#40744572">parent</a><span>|</span><a href="#40745039">prev</a><span>|</span><a href="#40746695">next</a><span>|</span><label class="collapse" for="c-40745078">[-]</label><label class="expand" for="c-40745078">[1 more]</label></div><br/><div class="children"><div class="content">Evaluating technology based on its &quot;cool kid usage&quot; and a vague sense of complexity is likely not the best strategy. Perhaps instead you could ask &quot;what problems does this solve&#x2F;create?&quot;</div><br/></div></div></div></div><div id="40746695" class="c"><input type="checkbox" id="c-40746695" checked=""/><div class="controls bullet"><span class="by">zby</span><span>|</span><a href="#40744572">prev</a><span>|</span><a href="#40746441">next</a><span>|</span><label class="collapse" for="c-40746695">[-]</label><label class="expand" for="c-40746695">[1 more]</label></div><br/><div class="children"><div class="content">I am always suspicious with frameworks. There are two reasons of that. First is that because of the inversion of control they are more rigid than libraries. This is quite fundamental - but there are cases where the trade off is totally worth it. The second one is because of how they are created - it often starts with an application which is then gradually made generic. This is good for advertising - you can always show how useful the framework with an application that uses it. But this &quot;making it generic&quot; is a very tricky process that often fails. It is a top down, the authors need to imagine possible uses and then enable them in the framework - while with libraries the users have much more freedom to discover them in a bottom up process. Users always have surprising ideas.<p>There are now libraries that cover some of the features of Langchain. There is Instructor and mine LLMEasyTools for function calling, there is LiteLLM for API unification.</div><br/></div></div><div id="40746441" class="c"><input type="checkbox" id="c-40746441" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#40746695">prev</a><span>|</span><a href="#40744391">next</a><span>|</span><label class="collapse" for="c-40746441">[-]</label><label class="expand" for="c-40746441">[1 more]</label></div><br/><div class="children"><div class="content">It would have been great if the article provided a more realistic example.<p>The example they use is indeed more complex than the openai equivalent, but LangChain allows you to use several models from several providers.<p>Also, it&#x27;s true that the override of the pipe character is unexpected. But it should make sense, if you&#x27;re familiar with Linux&#x2F;Unix. And I find it shows more clearly that you are constructing a pipeline:<p><pre><code>    prompt | model | parser</code></pre></div><br/></div></div><div id="40744391" class="c"><input type="checkbox" id="c-40744391" checked=""/><div class="controls bullet"><span class="by">etse</span><span>|</span><a href="#40746441">prev</a><span>|</span><a href="#40743176">next</a><span>|</span><label class="collapse" for="c-40744391">[-]</label><label class="expand" for="c-40744391">[6 more]</label></div><br/><div class="children"><div class="content">My reading of the article is that because LangChain is abstracted poorly, frameworks should not be used, but that seems a bit far.<p>my experience is that Python has a frustrating developer experience for production services. So I would prefer a framework with better abstractions and a solid production language (performance and safety), over no framework and Python (if those were options)</div><br/><div id="40744474" class="c"><input type="checkbox" id="c-40744474" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40744391">parent</a><span>|</span><a href="#40747012">next</a><span>|</span><label class="collapse" for="c-40744474">[-]</label><label class="expand" for="c-40744474">[3 more]</label></div><br/><div class="children"><div class="content">For most of what people are doing with AI you don&#x27;t need Python because you don&#x27;t need the ML ecosystem. You&#x27;re either going to be talking to some provider&#x27;s API (in which case there are wrappers aplenty and even if there weren&#x27;t their APIs are simple and trivial to wrap yourself) or you&#x27;re going to self-host a model somewhere, in which case you can use something like ollama to give yourself an easy API to code against.<p>All of the logic of stringing prompts and outputs together can easily happen in basically any programming language with <i>maybe</i> a tiny bespoke framework customized to your needs.<p>Calling these things &quot;AI agents&quot; makes them sound both cooler and more complicated than they actually are or need to be. It&#x27;s all just taking the output from one black box and sticking it into the input of another, the same kind of work frontline programmers have been doing for decades.</div><br/><div id="40744715" class="c"><input type="checkbox" id="c-40744715" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#40744391">root</a><span>|</span><a href="#40744474">parent</a><span>|</span><a href="#40747012">next</a><span>|</span><label class="collapse" for="c-40744715">[-]</label><label class="expand" for="c-40744715">[2 more]</label></div><br/><div class="children"><div class="content">They become agents when the LLM output is function calls.</div><br/><div id="40745064" class="c"><input type="checkbox" id="c-40745064" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#40744391">root</a><span>|</span><a href="#40744715">parent</a><span>|</span><a href="#40747012">next</a><span>|</span><label class="collapse" for="c-40745064">[-]</label><label class="expand" for="c-40745064">[1 more]</label></div><br/><div class="children"><div class="content">So the output of Black Box A is an instruction to give Black Box B a piece of data X and then give the resulting output back to BBA. We&#x27;re still just wiring up black boxes to each other the same as we&#x27;ve always done, and we still don&#x27;t need an abstraction for that.</div><br/></div></div></div></div></div></div><div id="40747012" class="c"><input type="checkbox" id="c-40747012" checked=""/><div class="controls bullet"><span class="by">Kostarrr</span><span>|</span><a href="#40744391">parent</a><span>|</span><a href="#40744474">prev</a><span>|</span><a href="#40744700">next</a><span>|</span><label class="collapse" for="c-40747012">[-]</label><label class="expand" for="c-40747012">[1 more]</label></div><br/><div class="children"><div class="content">Disclamer: I work for Octomind.<p>I think the reading is more &quot;It&#x27;s hard to find a good abstraction in a field that has not settled yet on what a good abstraction is. In that case, you might want to avoid frameworks as things shift around too much.&quot;</div><br/></div></div><div id="40744700" class="c"><input type="checkbox" id="c-40744700" checked=""/><div class="controls bullet"><span class="by">autokad</span><span>|</span><a href="#40744391">parent</a><span>|</span><a href="#40747012">prev</a><span>|</span><a href="#40743176">next</a><span>|</span><label class="collapse" for="c-40744700">[-]</label><label class="expand" for="c-40744700">[1 more]</label></div><br/><div class="children"><div class="content">prompt engineering requires the ability to see what is happening at various steps and langchain makes that harder if not impossible.<p>honestly I don&#x27;t need that much abstraction.</div><br/></div></div></div></div><div id="40743176" class="c"><input type="checkbox" id="c-40743176" checked=""/><div class="controls bullet"><span class="by">deckar01</span><span>|</span><a href="#40744391">prev</a><span>|</span><a href="#40743910">next</a><span>|</span><label class="collapse" for="c-40743176">[-]</label><label class="expand" for="c-40743176">[2 more]</label></div><br/><div class="children"><div class="content">I recently unwrapped linktransformer to get access to some intermediate calculations and realized it was a pretty thin wrapper around SentenceTransformer and DBScan. It would have taken me so much longer to get similar results without copying their defaults and IO flow. It’s easy to take for granted code you didn’t have to develop from scratch. It would be interesting if there was a tool that inlined dependency calls and shook out unvisited branches automatically.</div><br/><div id="40743856" class="c"><input type="checkbox" id="c-40743856" checked=""/><div class="controls bullet"><span class="by">luke-stanley</span><span>|</span><a href="#40743176">parent</a><span>|</span><a href="#40743910">next</a><span>|</span><label class="collapse" for="c-40743856">[-]</label><label class="expand" for="c-40743856">[1 more]</label></div><br/><div class="children"><div class="content">From memory, I recall Vulture might do something like that!</div><br/></div></div></div></div><div id="40743910" class="c"><input type="checkbox" id="c-40743910" checked=""/><div class="controls bullet"><span class="by">Kydlaw</span><span>|</span><a href="#40743176">prev</a><span>|</span><a href="#40744681">next</a><span>|</span><label class="collapse" for="c-40743910">[-]</label><label class="expand" for="c-40743910">[1 more]</label></div><br/><div class="children"><div class="content">IMO LangChain provides very high level abstractions that are very useful for prototyping. It allows you to abstract away components while you dig deeper on some parts that will deliver actual value.<p>But aside from that, I don&#x27;t think I would run it in production. If something breaks, I feel like we would be in a world of pain to get things back up and running. I am glad they shared their experience on that, this is an interesting data point.</div><br/></div></div><div id="40744681" class="c"><input type="checkbox" id="c-40744681" checked=""/><div class="controls bullet"><span class="by">nosefrog</span><span>|</span><a href="#40743910">prev</a><span>|</span><a href="#40744532">next</a><span>|</span><label class="collapse" for="c-40744681">[-]</label><label class="expand" for="c-40744681">[2 more]</label></div><br/><div class="children"><div class="content">Anyone who has read LangChain&#x27;s code would know better than to depend on it.</div><br/><div id="40745653" class="c"><input type="checkbox" id="c-40745653" checked=""/><div class="controls bullet"><span class="by">whydid</span><span>|</span><a href="#40744681">parent</a><span>|</span><a href="#40744532">next</a><span>|</span><label class="collapse" for="c-40745653">[-]</label><label class="expand" for="c-40745653">[1 more]</label></div><br/><div class="children"><div class="content">A heuristic that I use when judging code quality is a search for &quot;datas&quot; or &quot;metadatas&quot;.</div><br/></div></div></div></div><div id="40744532" class="c"><input type="checkbox" id="c-40744532" checked=""/><div class="controls bullet"><span class="by">andrewfromx</span><span>|</span><a href="#40744681">prev</a><span>|</span><a href="#40746952">next</a><span>|</span><label class="collapse" for="c-40744532">[-]</label><label class="expand" for="c-40744532">[1 more]</label></div><br/><div class="children"><div class="content">&quot;When abstractions do more harm than good&quot; I&#x27;ll take this for $2000 please and if i get the daily double, bet it all.</div><br/></div></div><div id="40746952" class="c"><input type="checkbox" id="c-40746952" checked=""/><div class="controls bullet"><span class="by">sandGorgon</span><span>|</span><a href="#40744532">prev</a><span>|</span><a href="#40743346">next</a><span>|</span><label class="collapse" for="c-40746952">[-]</label><label class="expand" for="c-40746952">[1 more]</label></div><br/><div class="children"><div class="content">shameless plug - i build a JS&#x2F;TS framework which tries to solve the abstraction problem. we use a json variant called jsonnet (created at google. expressive enough for kubernetes).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;arakoodev&#x2F;EdgeChains&#x2F;tree&#x2F;ts&#x2F;JS&#x2F;edgechains&#x2F;examples">https:&#x2F;&#x2F;github.com&#x2F;arakoodev&#x2F;EdgeChains&#x2F;tree&#x2F;ts&#x2F;JS&#x2F;edgechain...</a><p>examples of these jsonnet for react COT chains - <a href="https:&#x2F;&#x2F;github.com&#x2F;arakoodev&#x2F;EdgeChains&#x2F;blob&#x2F;ts&#x2F;JS&#x2F;edgechains&#x2F;examples&#x2F;react-chain&#x2F;jsonnet&#x2F;main.jsonnet">https:&#x2F;&#x2F;github.com&#x2F;arakoodev&#x2F;EdgeChains&#x2F;blob&#x2F;ts&#x2F;JS&#x2F;edgechain...</a><p>P.S. we also build a webassembly compiler that compiles this down to wasm and deploy on hardware.</div><br/></div></div><div id="40743346" class="c"><input type="checkbox" id="c-40743346" checked=""/><div class="controls bullet"><span class="by">danielmarkbruce</span><span>|</span><a href="#40746952">prev</a><span>|</span><a href="#40744829">next</a><span>|</span><label class="collapse" for="c-40743346">[-]</label><label class="expand" for="c-40743346">[4 more]</label></div><br/><div class="children"><div class="content">Yup. The problem with frameworks is they assume (historically mostly but not always correctly) that layers of abstraction mean one can forget about the layers below. This just doesn&#x27;t work with LLMs. The systems are closer to biology or something.</div><br/><div id="40745165" class="c"><input type="checkbox" id="c-40745165" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#40743346">parent</a><span>|</span><a href="#40744829">next</a><span>|</span><label class="collapse" for="c-40745165">[-]</label><label class="expand" for="c-40745165">[3 more]</label></div><br/><div class="children"><div class="content">Very much depends on the framework. I&#x27;m currently building a GitHub App with the Probot framework, which mostly just handles authentication boilerplate and some testing niceties, then just gives you an authenticated GitHub API client (no facade&#x2F;abstraction).<p>Then of course there&#x27;s the many web application frameworks, because nobody in their right mind would want to implement http request parsing themselves (outside of academic exercises).<p>In fact, I would argue that most popular frameworks exist precisely because it&#x27;s often more time efficient to forget about underlying details. All computer software is built on abstraction. The key is picking the right level of abstraction for your use case.</div><br/><div id="40746022" class="c"><input type="checkbox" id="c-40746022" checked=""/><div class="controls bullet"><span class="by">danielmarkbruce</span><span>|</span><a href="#40743346">root</a><span>|</span><a href="#40745165">parent</a><span>|</span><a href="#40744829">next</a><span>|</span><label class="collapse" for="c-40746022">[-]</label><label class="expand" for="c-40746022">[2 more]</label></div><br/><div class="children"><div class="content">Reread the thread and the comment. It&#x27;s about the LLM frameworks and acknowledges that most non LLM frameworks historically are helpful and correct in abstracting away details.</div><br/><div id="40746822" class="c"><input type="checkbox" id="c-40746822" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#40743346">root</a><span>|</span><a href="#40746022">parent</a><span>|</span><a href="#40744829">next</a><span>|</span><label class="collapse" for="c-40746822">[-]</label><label class="expand" for="c-40746822">[1 more]</label></div><br/><div class="children"><div class="content">Ah the bit in parentheses was worded such that I misunderstood your point.</div><br/></div></div></div></div></div></div></div></div><div id="40744829" class="c"><input type="checkbox" id="c-40744829" checked=""/><div class="controls bullet"><span class="by">infecto</span><span>|</span><a href="#40743346">prev</a><span>|</span><a href="#40744638">next</a><span>|</span><label class="collapse" for="c-40744829">[-]</label><label class="expand" for="c-40744829">[20 more]</label></div><br/><div class="children"><div class="content">LangChain itself blows my mind as one of the most useless libraries to exist. I hope this does not come off the wrong way but so many people told me they were using it so it was easy to move been models. I just did not understand it, these are simple API calls that felt like Web Dev 101 when starting a new product. Maybe its that so many new people were coming into the field using LLM but it surprised me as even what I thought were experienced people were struggling. Its like LLMs brought out the confusion in people.<p>It was interesting as a library at the very beginning to see how people were thinking about patterns but pretty useless in production.</div><br/><div id="40745080" class="c"><input type="checkbox" id="c-40745080" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#40744829">parent</a><span>|</span><a href="#40744894">next</a><span>|</span><label class="collapse" for="c-40745080">[-]</label><label class="expand" for="c-40745080">[6 more]</label></div><br/><div class="children"><div class="content">It was the first pass at solving the common problems when building with LLMs. People jumped on it because it was trendy and popular.<p>But it quickly became obvious that LangChain would be better named LangSpaghetti.<p>That’s nothing against the authors. What are the chances the first attempt at solving a problem is successful? They should be commended for shipping quickly and raising money on top of it to keep iterating.<p>The mistake of LangChain is that they doubled down on the bad abstraction. They should have been iterating by exploring different approaches to solving the problem, not by adding even more complexity to their first attempt.</div><br/><div id="40745397" class="c"><input type="checkbox" id="c-40745397" checked=""/><div class="controls bullet"><span class="by">dongobread</span><span>|</span><a href="#40744829">root</a><span>|</span><a href="#40745080">parent</a><span>|</span><a href="#40745989">next</a><span>|</span><label class="collapse" for="c-40745397">[-]</label><label class="expand" for="c-40745397">[2 more]</label></div><br/><div class="children"><div class="content">Langchain feels very much like shovelware that was created for the sole purpose of parting VCs of their money. At one point the codebase had a &quot;prompt template&quot; class that literally just called Python&#x27;s f-string.</div><br/></div></div><div id="40745989" class="c"><input type="checkbox" id="c-40745989" checked=""/><div class="controls bullet"><span class="by">jhoechtl</span><span>|</span><a href="#40744829">root</a><span>|</span><a href="#40745080">parent</a><span>|</span><a href="#40745397">prev</a><span>|</span><a href="#40746031">next</a><span>|</span><label class="collapse" for="c-40745989">[-]</label><label class="expand" for="c-40745989">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t langchain provide useful functionality when it comes to RAG? Here it seems it does considerably more but being a mere shim abstraction?</div><br/><div id="40746258" class="c"><input type="checkbox" id="c-40746258" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40744829">root</a><span>|</span><a href="#40745989">parent</a><span>|</span><a href="#40746031">next</a><span>|</span><label class="collapse" for="c-40746258">[-]</label><label class="expand" for="c-40746258">[1 more]</label></div><br/><div class="children"><div class="content">Not really. It&#x27;s pretty much the same for RAG as it is for everything else - just a thin additional abstraction on top of apis that are easy to call on their own.</div><br/></div></div></div></div><div id="40746031" class="c"><input type="checkbox" id="c-40746031" checked=""/><div class="controls bullet"><span class="by">__loam</span><span>|</span><a href="#40744829">root</a><span>|</span><a href="#40745080">parent</a><span>|</span><a href="#40745989">prev</a><span>|</span><a href="#40744894">next</a><span>|</span><label class="collapse" for="c-40746031">[-]</label><label class="expand" for="c-40746031">[1 more]</label></div><br/><div class="children"><div class="content">Good thing they didn&#x27;t raise money to develop this piece of crap.<p><a href="https:&#x2F;&#x2F;blog.langchain.dev&#x2F;announcing-our-10m-seed-round-led-by-benchmark&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.langchain.dev&#x2F;announcing-our-10m-seed-round-led...</a></div><br/></div></div></div></div><div id="40744894" class="c"><input type="checkbox" id="c-40744894" checked=""/><div class="controls bullet"><span class="by">ravenstine</span><span>|</span><a href="#40744829">parent</a><span>|</span><a href="#40745080">prev</a><span>|</span><a href="#40745641">next</a><span>|</span><label class="collapse" for="c-40744894">[-]</label><label class="expand" for="c-40744894">[4 more]</label></div><br/><div class="children"><div class="content">Every time I approached LangChain, contrary to the attitude of my colleagues, I could never figure out what the point of it was other than to fetishize certain design patterns.  Interacting with an LLM in a useful way requires literally none of what LangChain has to offer, yet for a time it was on its way to being the de facto way to do anything with LLMs.  It reminds me a lot of the false promise of ORMs, which is that if you trust the patterns then you can swap out the underlying engine and everything will still just work, and is more or less a fantasy.</div><br/><div id="40745071" class="c"><input type="checkbox" id="c-40745071" checked=""/><div class="controls bullet"><span class="by">langcss</span><span>|</span><a href="#40744829">root</a><span>|</span><a href="#40744894">parent</a><span>|</span><a href="#40746026">next</a><span>|</span><label class="collapse" for="c-40745071">[-]</label><label class="expand" for="c-40745071">[2 more]</label></div><br/><div class="children"><div class="content">ORMs are useful though for a different reason. They let you creat typed objects then generate the schema from them and automatically create a lot of boilerplate SQL for you.<p>Admittedly for anything more than 1-2 joins you are better off hand crafting the SQL. But that is the exception not the rule.<p>Refactoring DB changes becomes easier, you have a history of migrations for free, DDL generation for free.<p>In the early 2000 I worked where people handcrafted SQL for every little query for 100 tables and yeah you end up with inconsistent APIs and bugs that are eliminated by code generation &#x2F; meta programming done by ORMs.</div><br/></div></div><div id="40746026" class="c"><input type="checkbox" id="c-40746026" checked=""/><div class="controls bullet"><span class="by">gavmor</span><span>|</span><a href="#40744829">root</a><span>|</span><a href="#40744894">parent</a><span>|</span><a href="#40745071">prev</a><span>|</span><a href="#40745641">next</a><span>|</span><label class="collapse" for="c-40746026">[-]</label><label class="expand" for="c-40746026">[1 more]</label></div><br/><div class="children"><div class="content">&gt; to fetishize certain design patterns<p>Yes; exactly. There&#x27;s value in a Schelling Point[0], and in a pattern language[1].<p>&gt; requires literally none<p>True, yes. There isn&#x27;t <i>infinite</i> value in these things, and &quot;duplication is far cheaper than the wrong abstraction&quot;[2], but they can&#x27;t be avoided; they occupy local maxima.<p>0. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Focal_point_(game_theory)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Focal_point_(game_theory)</a><p>1. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pattern_language" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pattern_language</a><p>2. <a href="https:&#x2F;&#x2F;sandimetz.com&#x2F;blog&#x2F;2016&#x2F;1&#x2F;20&#x2F;the-wrong-abstraction" rel="nofollow">https:&#x2F;&#x2F;sandimetz.com&#x2F;blog&#x2F;2016&#x2F;1&#x2F;20&#x2F;the-wrong-abstraction</a></div><br/></div></div></div></div><div id="40745641" class="c"><input type="checkbox" id="c-40745641" checked=""/><div class="controls bullet"><span class="by">choilive</span><span>|</span><a href="#40744829">parent</a><span>|</span><a href="#40744894">prev</a><span>|</span><a href="#40746042">next</a><span>|</span><label class="collapse" for="c-40745641">[-]</label><label class="expand" for="c-40745641">[1 more]</label></div><br/><div class="children"><div class="content">This seems to be a universal sentiment.. we took a short look at langchain and determined it was doing really trivial string manipulation&#x2F;string templating stuff but inside really rigid and unnecessary abstractions. It was all stuff that could be implemented by any competent programmer in hours in any language without all the crap, so that&#x27;s what we did. <i>shrug</i></div><br/></div></div><div id="40746042" class="c"><input type="checkbox" id="c-40746042" checked=""/><div class="controls bullet"><span class="by">cyberdrunk2</span><span>|</span><a href="#40744829">parent</a><span>|</span><a href="#40745641">prev</a><span>|</span><a href="#40744939">next</a><span>|</span><label class="collapse" for="c-40746042">[-]</label><label class="expand" for="c-40746042">[1 more]</label></div><br/><div class="children"><div class="content">I think it was great at first when llms were new and prompting required more strategy. Now the amount of of abstractions&#x2F; bloat they have for essentially string wrappers makes no sense</div><br/></div></div><div id="40744939" class="c"><input type="checkbox" id="c-40744939" checked=""/><div class="controls bullet"><span class="by">richrichie</span><span>|</span><a href="#40744829">parent</a><span>|</span><a href="#40746042">prev</a><span>|</span><a href="#40745796">next</a><span>|</span><label class="collapse" for="c-40744939">[-]</label><label class="expand" for="c-40744939">[1 more]</label></div><br/><div class="children"><div class="content">Langchain seems to have been made just for the tutorial business on Udemy and Youtube.</div><br/></div></div><div id="40745796" class="c"><input type="checkbox" id="c-40745796" checked=""/><div class="controls bullet"><span class="by">justanotheratom</span><span>|</span><a href="#40744829">parent</a><span>|</span><a href="#40744939">prev</a><span>|</span><a href="#40744881">next</a><span>|</span><label class="collapse" for="c-40745796">[-]</label><label class="expand" for="c-40745796">[1 more]</label></div><br/><div class="children"><div class="content">never understood the &quot;chain&quot; in langchain.</div><br/></div></div><div id="40744881" class="c"><input type="checkbox" id="c-40744881" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#40744829">parent</a><span>|</span><a href="#40745796">prev</a><span>|</span><a href="#40744638">next</a><span>|</span><label class="collapse" for="c-40744881">[-]</label><label class="expand" for="c-40744881">[5 more]</label></div><br/><div class="children"><div class="content">Ah, the halcyon days of March 2023, we were a while loop away from AGI.  I remember there was something that was It for like a month, to the point that whoever built the framework was treating a cocktail napkin on which they scribbled, whatever, &quot;act, evaluate, decide next action, repeat&quot;, as if it was a historical talisman. And I wasn&#x27;t sure! Maybe it was!</div><br/><div id="40744906" class="c"><input type="checkbox" id="c-40744906" checked=""/><div class="controls bullet"><span class="by">causal</span><span>|</span><a href="#40744829">root</a><span>|</span><a href="#40744881">parent</a><span>|</span><a href="#40744638">next</a><span>|</span><label class="collapse" for="c-40744906">[-]</label><label class="expand" for="c-40744906">[4 more]</label></div><br/><div class="children"><div class="content">Yeah I thought the consensus against LangChain was formed a year ago, surprised to still be seeing these articles.</div><br/><div id="40744951" class="c"><input type="checkbox" id="c-40744951" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#40744829">root</a><span>|</span><a href="#40744906">parent</a><span>|</span><a href="#40744638">next</a><span>|</span><label class="collapse" for="c-40744951">[-]</label><label class="expand" for="c-40744951">[3 more]</label></div><br/><div class="children"><div class="content">Just chit chatting, not a strong claim, more a hot take I turn over in my mind:<p>my guess is 40% of software engineers did a AI pivot the last 18 months, so there&#x27;s a massive market for frameworks, and there&#x27;s an inclination to go beyond REST requests, find something that just does it for you &#x2F; can do all the cool patterns you&#x27;ll find in research papers.<p>Incredible amount of bad info out there, whether its the 10th prompting framework that boils down to a while loop and just drives up  token costs, the 400 LLM tokenizer library that can only do GPT-3.5&#x2F;4.0, the Nth app that took XX ex-FAANG and $XX mil and a year to get another web app, or another iOS-only OpenAI client with background blur,m  memory thats an array of strings injected into every call<p>It&#x27;s at the point where I&#x27;m hoping for a cooling down even though I&#x27;m launching something*, and think it&#x27;s hilarious people rant about it all just being hype and think people agree.<p>* TL;Dr consumer app with &#x27;chain gui&#x27;, just hand people an easy to use GUI like playground.openai.com &#x2F; console.anthropic.com, instead of getting cute and being the Nth team to try to launch a full grade assistant on a monthly plan matching openai pricing, shoving 6000K+ prompts with each request and not showing them</div><br/><div id="40745788" class="c"><input type="checkbox" id="c-40745788" checked=""/><div class="controls bullet"><span class="by">gbickford</span><span>|</span><a href="#40744829">root</a><span>|</span><a href="#40744951">parent</a><span>|</span><a href="#40745792">next</a><span>|</span><label class="collapse" for="c-40745788">[-]</label><label class="expand" for="c-40745788">[1 more]</label></div><br/><div class="children"><div class="content">This is true. Devs are looking for frameworks. See CrewAI who refuses to allow users to disable some pretty aggressive telemetry, yet they have a huge number of GH stars.<p>The abstractions are handy if you have no idea what you are doing but it&#x27;s not groundbreaking tech.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;joaomdmoura&#x2F;crewAI&#x2F;pull&#x2F;402">https:&#x2F;&#x2F;github.com&#x2F;joaomdmoura&#x2F;crewAI&#x2F;pull&#x2F;402</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40744638" class="c"><input type="checkbox" id="c-40744638" checked=""/><div class="controls bullet"><span class="by">Treesrule14</span><span>|</span><a href="#40744829">prev</a><span>|</span><a href="#40746702">next</a><span>|</span><label class="collapse" for="c-40744638">[-]</label><label class="expand" for="c-40744638">[15 more]</label></div><br/><div class="children"><div class="content">Has anyone else found a good way to swap out models between companies, Langchain has made it very easy for us to swap between openai&#x2F;anthropic etc</div><br/><div id="40744713" class="c"><input type="checkbox" id="c-40744713" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#40744638">parent</a><span>|</span><a href="#40745584">next</a><span>|</span><label class="collapse" for="c-40744713">[-]</label><label class="expand" for="c-40744713">[6 more]</label></div><br/><div class="children"><div class="content">The point is that you don’t need a framework for that; the APIs are already similar enough that it should be obvious how to abstract over them using whatever approach is natural in your programming language of choice.</div><br/><div id="40744893" class="c"><input type="checkbox" id="c-40744893" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#40744638">root</a><span>|</span><a href="#40744713">parent</a><span>|</span><a href="#40745584">next</a><span>|</span><label class="collapse" for="c-40744893">[-]</label><label class="expand" for="c-40744893">[5 more]</label></div><br/><div class="children"><div class="content">I have a consumer app that swaps between the 5 bigs and wholeheartedly agree, except, God help you if you&#x27;re doing Gemini. I somewhat regret hacking it into the same concepts as everyone else.<p>I should have built stronger separation boundaries with more general abstractions. It works fine, I haven&#x27;t had any critical bugs &#x2F; mistakes, but it&#x27;s really nasty once you get to the actual JSON you&#x27;ll send.<p>Google&#x27;s was 100% designed by a committee of people who had never seen anyone else&#x27;s API, and if they had, they would have dismissed it via NIH.  (disclaimer: ex-Googler, no direct knowledge)</div><br/><div id="40745901" class="c"><input type="checkbox" id="c-40745901" checked=""/><div class="controls bullet"><span class="by">Jensson</span><span>|</span><a href="#40744638">root</a><span>|</span><a href="#40744893">parent</a><span>|</span><a href="#40745143">next</a><span>|</span><label class="collapse" for="c-40745901">[-]</label><label class="expand" for="c-40745901">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Google&#x27;s was 100% designed by a committee of people who had never seen anyone else&#x27;s API<p>Google made their API before the others had one, since they were the first with making these kind of language models. Its just that it has been an internal API before.</div><br/><div id="40746151" class="c"><input type="checkbox" id="c-40746151" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#40744638">root</a><span>|</span><a href="#40745901">parent</a><span>|</span><a href="#40745143">next</a><span>|</span><label class="collapse" for="c-40746151">[-]</label><label class="expand" for="c-40746151">[2 more]</label></div><br/><div class="children"><div class="content">No.<p>That&#x27;d be a good explanation, but it&#x27;s theoretical.<p>In practice:<p>A) there was no meaningful internal LLM API pre-ChatGPT. All this AI stuff was under lock and key until Nov 2022, then it was an emergency.<p>B) the bits we&#x27;re discussing are OpenAI-specific concepts that could only have occurred after OpenAI&#x27;s.<p>The API includes chat messages organized with roles, an OpenAI concept, and &quot;tools&quot;, an OpenAI concept, both of which came well after the GPT API.<p>Initial API announcement here: <a href="https:&#x2F;&#x2F;developers.googleblog.com&#x2F;en&#x2F;palm-api-makersuite-an-approachable-way-to-start-prototyping-and-building-generative-ai-applications&#x2F;" rel="nofollow">https:&#x2F;&#x2F;developers.googleblog.com&#x2F;en&#x2F;palm-api-makersuite-an-...</a></div><br/><div id="40746959" class="c"><input type="checkbox" id="c-40746959" checked=""/><div class="controls bullet"><span class="by">Jensson</span><span>|</span><a href="#40744638">root</a><span>|</span><a href="#40746151">parent</a><span>|</span><a href="#40745143">next</a><span>|</span><label class="collapse" for="c-40746959">[-]</label><label class="expand" for="c-40746959">[1 more]</label></div><br/><div class="children"><div class="content">Google started including LLM features in internal products 2019 at least, I knew since I worked there then. I can&#x27;t remember exactly when they started having LLM generated snippets and suggestions everywhere but it was there at least since 2019. So they have had internal APIs for this for quite some time.<p>&gt; All this AI stuff was under lock and key until Nov 2022<p>That is all wrong... Did you work there? What do you base this on? Google has been experimenting with LLMs internally ever since the original paper, I worked in search then and I remember my senior manager said this was the biggest revolution in natural language processing since ever.<p>So even if Google added a few concepts from OpenAI, or renamed them, they still have had plenty of experience working with LLM APIs internally and that would make them want different things in their public API as well.</div><br/></div></div></div></div></div></div><div id="40745143" class="c"><input type="checkbox" id="c-40745143" checked=""/><div class="controls bullet"><span class="by">__cayenne__</span><span>|</span><a href="#40744638">root</a><span>|</span><a href="#40744893">parent</a><span>|</span><a href="#40745901">prev</a><span>|</span><a href="#40745584">next</a><span>|</span><label class="collapse" for="c-40745143">[-]</label><label class="expand" for="c-40745143">[1 more]</label></div><br/><div class="children"><div class="content">luckily Google now support&#x27;s using the OpenAI lib <a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;vertex-ai&#x2F;generative-ai&#x2F;docs&#x2F;multimodal&#x2F;call-gemini-using-openai-library" rel="nofollow">https:&#x2F;&#x2F;cloud.google.com&#x2F;vertex-ai&#x2F;generative-ai&#x2F;docs&#x2F;multim...</a></div><br/></div></div></div></div></div></div><div id="40745584" class="c"><input type="checkbox" id="c-40745584" checked=""/><div class="controls bullet"><span class="by">pveierland</span><span>|</span><a href="#40744638">parent</a><span>|</span><a href="#40744713">prev</a><span>|</span><a href="#40744996">next</a><span>|</span><label class="collapse" for="c-40745584">[-]</label><label class="expand" for="c-40745584">[1 more]</label></div><br/><div class="children"><div class="content">Using Llama Index for this via the `llama_index.core.base.llms.base.BaseLLM` interface. Using config files to describe the args to different models makes swapping models literally as easy as:<p><pre><code>  chat_model:
    cls: llama_index.llms.openai.OpenAI
    kwargs:
      model: gpt-4

  chat_model:
    cls: llama_index.llms.gemini.Gemini
    kwargs:
      model_name: models&#x2F;gemini-pro</code></pre></div><br/></div></div><div id="40744996" class="c"><input type="checkbox" id="c-40744996" checked=""/><div class="controls bullet"><span class="by">spdustin</span><span>|</span><a href="#40744638">parent</a><span>|</span><a href="#40745584">prev</a><span>|</span><a href="#40744771">next</a><span>|</span><label class="collapse" for="c-40744996">[-]</label><label class="expand" for="c-40744996">[3 more]</label></div><br/><div class="children"><div class="content">LiteLLM.<p><a href="https:&#x2F;&#x2F;www.litellm.ai&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.litellm.ai&#x2F;</a></div><br/><div id="40747018" class="c"><input type="checkbox" id="c-40747018" checked=""/><div class="controls bullet"><span class="by">ponywombat</span><span>|</span><a href="#40744638">root</a><span>|</span><a href="#40744996">parent</a><span>|</span><a href="#40747101">next</a><span>|</span><label class="collapse" for="c-40747018">[-]</label><label class="expand" for="c-40747018">[1 more]</label></div><br/><div class="children"><div class="content">LiteLLM seemed to be the best approach for what I needed - simple integration with different models (mainly OpenAI and the various Bedrock  models) and the ability to track costs &#x2F; limit spending.  It&#x27;s working really well so far.</div><br/></div></div><div id="40747101" class="c"><input type="checkbox" id="c-40747101" checked=""/><div class="controls bullet"><span class="by">emporas</span><span>|</span><a href="#40744638">root</a><span>|</span><a href="#40744996">parent</a><span>|</span><a href="#40747018">prev</a><span>|</span><a href="#40744771">next</a><span>|</span><label class="collapse" for="c-40747101">[-]</label><label class="expand" for="c-40747101">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t know about LiteLLM. That seems to be the right kind of middleware most people would need, instead of Langchain.</div><br/></div></div></div></div><div id="40744771" class="c"><input type="checkbox" id="c-40744771" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#40744638">parent</a><span>|</span><a href="#40744996">prev</a><span>|</span><a href="#40746656">next</a><span>|</span><label class="collapse" for="c-40744771">[-]</label><label class="expand" for="c-40744771">[1 more]</label></div><br/><div class="children"><div class="content">Use a consistent argument structure and make a simple class or function for each provider that translates that to the specific API calls. They are very similar APIs. Maybe select the function call based on the model name.</div><br/></div></div><div id="40746656" class="c"><input type="checkbox" id="c-40746656" checked=""/><div class="controls bullet"><span class="by">skeledrew</span><span>|</span><a href="#40744638">parent</a><span>|</span><a href="#40744771">prev</a><span>|</span><a href="#40745097">next</a><span>|</span><label class="collapse" for="c-40746656">[-]</label><label class="expand" for="c-40746656">[1 more]</label></div><br/><div class="children"><div class="content">Openrouter maybe?</div><br/></div></div><div id="40745097" class="c"><input type="checkbox" id="c-40745097" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#40744638">parent</a><span>|</span><a href="#40746656">prev</a><span>|</span><a href="#40744712">next</a><span>|</span><label class="collapse" for="c-40745097">[-]</label><label class="expand" for="c-40745097">[1 more]</label></div><br/><div class="children"><div class="content">The strategy design pattern would be suitable for this.</div><br/></div></div></div></div><div id="40746702" class="c"><input type="checkbox" id="c-40746702" checked=""/><div class="controls bullet"><span class="by">czechdeveloper</span><span>|</span><a href="#40744638">prev</a><span>|</span><a href="#40744107">next</a><span>|</span><label class="collapse" for="c-40746702">[-]</label><label class="expand" for="c-40746702">[1 more]</label></div><br/><div class="children"><div class="content">I used langchain in one project and I do regret choosing it over just writing everything over direct API. I feel their pain.<p>It had advantage of having standardized API, so I could switch local LLM to OpenAI and just compare results in a heartbeat, but when I wanted anything out of ordinary (ie. get logprobs), there was just no way.</div><br/></div></div><div id="40744107" class="c"><input type="checkbox" id="c-40744107" checked=""/><div class="controls bullet"><span class="by">maximilianburke</span><span>|</span><a href="#40746702">prev</a><span>|</span><a href="#40746496">next</a><span>|</span><label class="collapse" for="c-40744107">[-]</label><label class="expand" for="c-40744107">[1 more]</label></div><br/><div class="children"><div class="content">I just pulled out LangChain from our AI agents; we now have much smaller docker images and the code is a lot easier to understand.</div><br/></div></div><div id="40746496" class="c"><input type="checkbox" id="c-40746496" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#40744107">prev</a><span>|</span><a href="#40746226">next</a><span>|</span><label class="collapse" for="c-40746496">[-]</label><label class="expand" for="c-40746496">[1 more]</label></div><br/><div class="children"><div class="content">every good developer i know that has started using langchain stopped after realizing that they need more control than it provides. if you actually look at what is going on under the hood by looking at the requests you would probably stop using it as well.</div><br/></div></div><div id="40746226" class="c"><input type="checkbox" id="c-40746226" checked=""/><div class="controls bullet"><span class="by">jsemrau</span><span>|</span><a href="#40746496">prev</a><span>|</span><a href="#40744586">next</a><span>|</span><label class="collapse" for="c-40746226">[-]</label><label class="expand" for="c-40746226">[2 more]</label></div><br/><div class="children"><div class="content">LCEL is such a weird paradigm that I never got the hang of. 
Why | use | pipes?</div><br/><div id="40746406" class="c"><input type="checkbox" id="c-40746406" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#40746226">parent</a><span>|</span><a href="#40744586">next</a><span>|</span><label class="collapse" for="c-40746406">[-]</label><label class="expand" for="c-40746406">[1 more]</label></div><br/><div class="children"><div class="content">I found it weird as well to see that. I didn&#x27;t know LangChain overrode Python syntax.<p>But, if you&#x27;re familiar with Linux&#x2F;Unix, this should be familiar. You are piping the output of one function as the input of another function.</div><br/></div></div></div></div><div id="40744586" class="c"><input type="checkbox" id="c-40744586" checked=""/><div class="controls bullet"><span class="by">wouldbecouldbe</span><span>|</span><a href="#40746226">prev</a><span>|</span><a href="#40746716">next</a><span>|</span><label class="collapse" for="c-40744586">[-]</label><label class="expand" for="c-40744586">[1 more]</label></div><br/><div class="children"><div class="content">Everyone in my office is talking about ai agents as a magic bullet, driving me crazy</div><br/></div></div><div id="40746716" class="c"><input type="checkbox" id="c-40746716" checked=""/><div class="controls bullet"><span class="by">ZiiS</span><span>|</span><a href="#40744586">prev</a><span>|</span><a href="#40745323">next</a><span>|</span><label class="collapse" for="c-40746716">[-]</label><label class="expand" for="c-40746716">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;good abstraction&quot; has a bug; slightly undermines the argument.</div><br/></div></div><div id="40745323" class="c"><input type="checkbox" id="c-40745323" checked=""/><div class="controls bullet"><span class="by">gravenate</span><span>|</span><a href="#40746716">prev</a><span>|</span><a href="#40744415">next</a><span>|</span><label class="collapse" for="c-40745323">[-]</label><label class="expand" for="c-40745323">[1 more]</label></div><br/><div class="children"><div class="content">Hard Agree, Semantic Kernal, On the other hand seems to actually be a value add on top of the simple API calls.  Have you guys tried it  ?</div><br/></div></div><div id="40744415" class="c"><input type="checkbox" id="c-40744415" checked=""/><div class="controls bullet"><span class="by">dcole2929</span><span>|</span><a href="#40745323">prev</a><span>|</span><a href="#40744483">next</a><span>|</span><label class="collapse" for="c-40744415">[-]</label><label class="expand" for="c-40744415">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen a lot of stuff recently about how LangChain and other frameworks for AI&#x2F;LLM are terrible and we shouldn&#x27;t use them and I can&#x27;t help but think that people are missing the point. If you need strong customization or flexibility frameworks of any kind are almost always the wrong choice, whether you&#x27;re building a website or an AI agent. That&#x27;s kind of the whole point of a framework. Opinionated workflows that enable a specific kind of application. Ideally the goal is to cover 80% of the cases and provide escape hatches to handle the other 20% until you can successfully cover those too.<p>As someone new to the space I have zero opinions of whether LangChain is better than writing it all yourself, but I can certainly say that, I at least, appreciate having a proscribed way of doing things, and I&#x27;m okay with the idea that I may get to a place where it no longer serves my needs. It&#x27;s also worth noting that the benefit of LangChain is the ability to &quot;chain&quot; together these various AI links. Is there a better easier way to do that? Probably, but LangChain removes that overhead.</div><br/><div id="40744820" class="c"><input type="checkbox" id="c-40744820" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#40744415">parent</a><span>|</span><a href="#40744772">next</a><span>|</span><label class="collapse" for="c-40744820">[-]</label><label class="expand" for="c-40744820">[1 more]</label></div><br/><div class="children"><div class="content">I think that yes, there is a better way. You have a function that calls the API, then take the output and call another function that calls the API, inserting the first output into the second one&#x27;s prompt using an f-string or whatever. You can have a helper function that has defaults for model params or something.<p>You don&#x27;t need an abstraction at all really. Inserting the previous output into the new prompt is one line of code, and calling the API is another line of code.<p>If you really feel like you need to abstract that then you can make an additional helper function. But often you want to do different things at each stage so that doesn&#x27;t really help.</div><br/></div></div><div id="40744772" class="c"><input type="checkbox" id="c-40744772" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#40744415">parent</a><span>|</span><a href="#40744820">prev</a><span>|</span><a href="#40744483">next</a><span>|</span><label class="collapse" for="c-40744772">[-]</label><label class="expand" for="c-40744772">[1 more]</label></div><br/><div class="children"><div class="content">As the article points out, the difference between frameworks for building a website vs building an LLM agent is that we have decades more industrial experience behind our website-building opinions. I’ve used heavyweight frameworks before, and would understand your defense in the context of eg complaints about Spring Boot—but Langchain isn’t Spring; it really does kinda suck, for reasons that go beyond the inherent trade offs of using any framework.</div><br/></div></div></div></div><div id="40744483" class="c"><input type="checkbox" id="c-40744483" checked=""/><div class="controls bullet"><span class="by">djohnston</span><span>|</span><a href="#40744415">prev</a><span>|</span><label class="collapse" for="c-40744483">[-]</label><label class="expand" for="c-40744483">[3 more]</label></div><br/><div class="children"><div class="content">Idk, dude spends the post whining about writing multi agent architecture and doesn’t mention langgraph once. Reads like a lead who failed to read the docs.</div><br/><div id="40744901" class="c"><input type="checkbox" id="c-40744901" checked=""/><div class="controls bullet"><span class="by">2C64</span><span>|</span><a href="#40744483">parent</a><span>|</span><a href="#40745639">next</a><span>|</span><label class="collapse" for="c-40744901">[-]</label><label class="expand" for="c-40744901">[1 more]</label></div><br/><div class="children"><div class="content">LangGraph is the primary reason I use LangChain - being able to express my flow as a state machine has been a boon to both the design of my platform as well as my own productivity.</div><br/></div></div><div id="40745639" class="c"><input type="checkbox" id="c-40745639" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#40744483">parent</a><span>|</span><a href="#40744901">prev</a><span>|</span><label class="collapse" for="c-40745639">[-]</label><label class="expand" for="c-40745639">[1 more]</label></div><br/><div class="children"><div class="content">How does langgraph stack up against the alternatives?</div><br/></div></div></div></div></div></div></div></div></div></body></html>