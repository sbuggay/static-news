<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728464455038" as="style"/><link rel="stylesheet" href="styles.css?v=1728464455038"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://roman.pt/posts/dont-let-dicts-spoil-your-code/">Don&#x27;t let dicts spoil your code</a> <span class="domain">(<a href="https://roman.pt">roman.pt</a>)</span></div><div class="subtext"><span>juniperplant</span> | <span>86 comments</span></div><br/><div><div id="41783927" class="c"><input type="checkbox" id="c-41783927" checked=""/><div class="controls bullet"><span class="by">cardanome</span><span>|</span><a href="#41785009">next</a><span>|</span><label class="collapse" for="c-41783927">[-]</label><label class="expand" for="c-41783927">[3 more]</label></div><br/><div class="children"><div class="content">This is absolute key advice.<p>Another way to look at it is the functional core, imperative shell pattern.<p>Wrapping up your dict in a value object (dataclass or whatever that is in you language) early on means you handle the ugly stuff first. Parse don&#x27;t validate. Resist the temptation of optional fields. Is there really anything you can do if the field is null? No, then don&#x27;t make it optional. Let it crash early on. Clearly define you data.<p>If you have put your data in a neat value objects you know what is in it. You know the types. You know all required fields are there. You will be so much happier. No checking for null throughout the code, no checking for empty strings. You can just focus on the business logic.<p>Seriously so much suffering can be avoided by just following this pattern.</div><br/><div id="41785823" class="c"><input type="checkbox" id="c-41785823" checked=""/><div class="controls bullet"><span class="by">mcdeltat</span><span>|</span><a href="#41783927">parent</a><span>|</span><a href="#41785702">next</a><span>|</span><label class="collapse" for="c-41785823">[-]</label><label class="expand" for="c-41785823">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;loosey-goosey&quot; approach to data in coding is one of my biggest pet peeves. Some people absolutely <i>insist</i> on making everything as dynamic as possible, and then wonder why we end up with a buggy mess. I always found it very natural to move as much as possible into the type system, because why wouldn&#x27;t I want the machine to find all my inevitable mistakes for me?</div><br/></div></div><div id="41785702" class="c"><input type="checkbox" id="c-41785702" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#41783927">parent</a><span>|</span><a href="#41785823">prev</a><span>|</span><a href="#41785009">next</a><span>|</span><label class="collapse" for="c-41785702">[-]</label><label class="expand" for="c-41785702">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s little to disagree with here, and yet this comment reads like a slogan soup.</div><br/></div></div></div></div><div id="41785009" class="c"><input type="checkbox" id="c-41785009" checked=""/><div class="controls bullet"><span class="by">Jean-Papoulos</span><span>|</span><a href="#41783927">prev</a><span>|</span><a href="#41783740">next</a><span>|</span><label class="collapse" for="c-41785009">[-]</label><label class="expand" for="c-41785009">[7 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;unstructured data is problematic&quot;<p>&gt;&quot;solution : use dataclasses&quot;<p>Damn, it&#x27;s almost like using an untyped language for large projects is not a great idea.</div><br/><div id="41785503" class="c"><input type="checkbox" id="c-41785503" checked=""/><div class="controls bullet"><span class="by">ktosobcy</span><span>|</span><a href="#41785009">parent</a><span>|</span><a href="#41785119">next</a><span>|</span><label class="collapse" for="c-41785503">[-]</label><label class="expand" for="c-41785503">[1 more]</label></div><br/><div class="children"><div class="content">And yet we are overwhelmed by javascript nonsense... I get it - it&#x27;s so easy to get up to speed with tiny snippets but it quickly becomes hot mess.<p>Yes, decades ago I was also fascinated by python and it&#x27;s ease of doing stuff (compiler doesn&#x27;t complain that I missed something) but with time I grew fond of statically typed languages... they simply catch swaths of errors earlier...</div><br/></div></div></div></div><div id="41783740" class="c"><input type="checkbox" id="c-41783740" checked=""/><div class="controls bullet"><span class="by">jimmytucson</span><span>|</span><a href="#41785009">prev</a><span>|</span><a href="#41784912">next</a><span>|</span><label class="collapse" for="c-41783740">[-]</label><label class="expand" for="c-41783740">[7 more]</label></div><br/><div class="children"><div class="content">Here’s an out-there take, but one I’ve held loosely for a long time and haven’t shed yet: dicts are not appropriate for what people mostly use them for, which is named access to member attributes.<p>dict is an implementation of a hash table. Hash table are designed for o(1) lookup of items. As such, they are arrays which are much bigger than the number of items they store, to allow hashing items into integers and sidestep collisions. They’re meant to act like an index that contains many records, not a single record.<p>A single record is more
like a tuple, except you want named access instead of, title = movie[0], release_year = movie[1], etc. And Python had that, in NamedTuple, but it was kinda magical and no one used it (shoutout Raymond Hettinger).<p>Granted, this rant is pretty much the meme with the guy explaining something to a brick wall, in that dicts are so firmly entrenched as the &quot;record&quot; type of choice in Python (but not so in other languages: struct, case class, etc. and JSON doesn’t just deserialize to a weak type but I digress).</div><br/><div id="41784097" class="c"><input type="checkbox" id="c-41784097" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#41783740">parent</a><span>|</span><a href="#41783753">next</a><span>|</span><label class="collapse" for="c-41784097">[-]</label><label class="expand" for="c-41784097">[1 more]</label></div><br/><div class="children"><div class="content">NamedTuples are great, but they let you do too much with the objects. You probably don&#x27;t want users of your GitHubRepo class to be able to do things like `repo[1]` or `for foo in repo`. Dataclasses have more constrained semantics, so I reach for them by default. In my ideal world they would default to frozen=True, kw_only=True, slots=True, but even without those they&#x27;re a big improvement.</div><br/></div></div><div id="41783753" class="c"><input type="checkbox" id="c-41783753" checked=""/><div class="controls bullet"><span class="by">jsyang00</span><span>|</span><a href="#41783740">parent</a><span>|</span><a href="#41784097">prev</a><span>|</span><a href="#41784367">next</a><span>|</span><label class="collapse" for="c-41783753">[-]</label><label class="expand" for="c-41783753">[1 more]</label></div><br/><div class="children"><div class="content">I think most modern Python codebases are using dataclasses&#x2F; something like Pydantic. I think dicts are mostly seen, like the author suggests, because something which you hacked up to work quickly ends up turning into actual software and it&#x27;s too much work refactor the types</div><br/></div></div><div id="41784367" class="c"><input type="checkbox" id="c-41784367" checked=""/><div class="controls bullet"><span class="by">aatarax</span><span>|</span><a href="#41783740">parent</a><span>|</span><a href="#41783753">prev</a><span>|</span><a href="#41784797">next</a><span>|</span><label class="collapse" for="c-41784367">[-]</label><label class="expand" for="c-41784367">[1 more]</label></div><br/><div class="children"><div class="content">Dicts in python are for when you have a thing and you aren&#x27;t sure what the keys are. Dataclasses are for when you have a thing and you&#x27;re sure what the keys (attributes are). The trouble is when you have a thing and you&#x27;re sort of sure, but not entirely sure, and some things are definitely there but not everything you might be thinking of.</div><br/></div></div><div id="41784797" class="c"><input type="checkbox" id="c-41784797" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#41783740">parent</a><span>|</span><a href="#41784367">prev</a><span>|</span><a href="#41784628">next</a><span>|</span><label class="collapse" for="c-41784797">[-]</label><label class="expand" for="c-41784797">[1 more]</label></div><br/><div class="children"><div class="content">I think I once heard a Clojure talk where they were referred to as big and small maps. Small ones are what you’re comparing to arrays.<p>A place where dicts for hard coded keys makes sense is notebooks. The convenience is worth it and it’s unlikely to get out of hand.</div><br/></div></div><div id="41784628" class="c"><input type="checkbox" id="c-41784628" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#41783740">parent</a><span>|</span><a href="#41784797">prev</a><span>|</span><a href="#41785296">next</a><span>|</span><label class="collapse" for="c-41784628">[-]</label><label class="expand" for="c-41784628">[1 more]</label></div><br/><div class="children"><div class="content">Subclassing NamedTuple is very ergonomic, and given they&#x27;re immutable unlike data classes I often reach for them by default. I still use Pydantic when I want  custom validation or when it ties into another lib like FastAPI.</div><br/></div></div><div id="41785296" class="c"><input type="checkbox" id="c-41785296" checked=""/><div class="controls bullet"><span class="by">jonathrg</span><span>|</span><a href="#41783740">parent</a><span>|</span><a href="#41784628">prev</a><span>|</span><a href="#41784912">next</a><span>|</span><label class="collapse" for="c-41785296">[-]</label><label class="expand" for="c-41785296">[1 more]</label></div><br/><div class="children"><div class="content">dicts are used internally in the language to look up class and module attributes. They are optimized for this use case. How can it be wrong to use them that way when the very fabric of the language depends on it?<p>namedtuple is widely used in Python code, especially before the introduction of dataclasses.</div><br/></div></div></div></div><div id="41784912" class="c"><input type="checkbox" id="c-41784912" checked=""/><div class="controls bullet"><span class="by">ungamedplayer</span><span>|</span><a href="#41783740">prev</a><span>|</span><a href="#41785259">next</a><span>|</span><label class="collapse" for="c-41784912">[-]</label><label class="expand" for="c-41784912">[8 more]</label></div><br/><div class="children"><div class="content">Can someone educate me in why dicts are uncool for explained reasons, but clojure (which seems to be highly recommended on hn) seems to suffer the same issues when dealing with a map as a parameter (ring request etc).<p>I know how to deal with missing values or variability in maps, and so do a lot of people.. what am I missing here?</div><br/><div id="41785070" class="c"><input type="checkbox" id="c-41785070" checked=""/><div class="controls bullet"><span class="by">bloppe</span><span>|</span><a href="#41784912">parent</a><span>|</span><a href="#41785060">next</a><span>|</span><label class="collapse" for="c-41785070">[-]</label><label class="expand" for="c-41785070">[3 more]</label></div><br/><div class="children"><div class="content">Dicts are great when the data is uniform and dynamic, like an address book mapping names to contact info. You never assume that a key must be in there. Lookups can always fail. That&#x27;s normal for this kind of use-case.<p>When the data is not uniform (different keys point to differently-typed values), and not as dynamic (maybe your data model evolves over time, but certain functions always expect certain keys to be present), a dict is like a cancer. Sure, it&#x27;s simple at first, but wait until the same dict gets passed around to a hundred different functions instead of properly-typed parameters. I just quit my job tech at a company that shall remain nameless, partially because the gigantic Ruby codebase I was working on had a highly advanced form of this cancer, and at that point it was impossible to remove. You were never sure if the dict you&#x27;re supplying to some function had all the necessary keys for the function it would eventually invoke 50 layers down the call stack. But, changing every single call-site would involve such a major refactor that everybody just kept defining their functions to accept these opaque mega-dicts. So many bugs resulted because of this. That was far from the only problem with that codebase, but it was a major recurring theme.<p>I learned this lesson the hard way.</div><br/><div id="41785376" class="c"><input type="checkbox" id="c-41785376" checked=""/><div class="controls bullet"><span class="by">cornholio</span><span>|</span><a href="#41784912">root</a><span>|</span><a href="#41785070">parent</a><span>|</span><a href="#41785824">next</a><span>|</span><label class="collapse" for="c-41785376">[-]</label><label class="expand" for="c-41785376">[1 more]</label></div><br/><div class="children"><div class="content">This should be the top answer. It&#x27;s not about using dicts in their primary use case, it&#x27;s about abusing them as a catch all variadic parameter for quick prototyping and &quot;future expansion&quot;</div><br/></div></div><div id="41785824" class="c"><input type="checkbox" id="c-41785824" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41784912">root</a><span>|</span><a href="#41785070">parent</a><span>|</span><a href="#41785376">prev</a><span>|</span><a href="#41785060">next</a><span>|</span><label class="collapse" for="c-41785824">[-]</label><label class="expand" for="c-41785824">[1 more]</label></div><br/><div class="children"><div class="content">I think the problem is that different data containers have completely different interfaces.<p>If getting a filed of your object had the same syntax as getting a value from a dict you could easily replace dicts with smarter, more rigid types at any point.<p>My dream is a language that has the containers share as much interface as possible so you can easily swap them out according to your needs without changing most of the code that refers to them. Like easily swap dict for BTreeMap or Redis.<p>I think the closest is Scala but it fallen out of favor before I had a chance to know it.</div><br/></div></div></div></div><div id="41785060" class="c"><input type="checkbox" id="c-41785060" checked=""/><div class="controls bullet"><span class="by">lispisok</span><span>|</span><a href="#41784912">parent</a><span>|</span><a href="#41785070">prev</a><span>|</span><a href="#41785063">next</a><span>|</span><label class="collapse" for="c-41785060">[-]</label><label class="expand" for="c-41785060">[1 more]</label></div><br/><div class="children"><div class="content">Maps arent nearly as problematic in clojure because data is immutable by default on top of the functional paradigm where your program is basically a big composition of functions and the language is built around using maps. In Python I largely agree with the author. In clojure I love my maps.<p>Here is Rich Hickey with an extreme counter example although I would argue he&#x27;s really demonstrating against getters and setters.
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aSEQfqNYNAc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aSEQfqNYNAc</a></div><br/></div></div><div id="41785439" class="c"><input type="checkbox" id="c-41785439" checked=""/><div class="controls bullet"><span class="by">nlitened</span><span>|</span><a href="#41784912">parent</a><span>|</span><a href="#41785063">prev</a><span>|</span><a href="#41785289">next</a><span>|</span><label class="collapse" for="c-41785439">[-]</label><label class="expand" for="c-41785439">[1 more]</label></div><br/><div class="children"><div class="content">In Clojure, maps don’t have either of the flaws highlighted in the article. They are neither opaque (they are self-describing with namespaces keys) nor mutable.<p>As a result, they are very powerful and simple to use.</div><br/></div></div><div id="41785289" class="c"><input type="checkbox" id="c-41785289" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#41784912">parent</a><span>|</span><a href="#41785439">prev</a><span>|</span><a href="#41785259">next</a><span>|</span><label class="collapse" for="c-41785289">[-]</label><label class="expand" for="c-41785289">[1 more]</label></div><br/><div class="children"><div class="content">They also work fine with JavaScript.<p>The issue is that the concrete types are implicit. Depending on the language, runtime or type system expressing the type in a “better” way might be very hard or un-ergonomic.</div><br/></div></div></div></div><div id="41785259" class="c"><input type="checkbox" id="c-41785259" checked=""/><div class="controls bullet"><span class="by">Garlef</span><span>|</span><a href="#41784912">prev</a><span>|</span><a href="#41783625">next</a><span>|</span><label class="collapse" for="c-41785259">[-]</label><label class="expand" for="c-41785259">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think dicts themselves are the problem.<p>In typescript using plain JS objects is very straightforward.
Of course you have to validate the schema at your system boundaries.
But you&#x27;ll have to do this either way.<p>So: If this works very well in TS it can&#x27;t be dicts themselves but must be the way they integrate into- and are handled in python.<p>This leads me to the conclusion that arguments presented in the article might be the wrong ones.<p>(But I still think, the conclusion the article arrives at is okay. But I don&#x27;t think there&#x27;s a strong case being made in the article about wether to prefer data classes or typed dicts.)</div><br/><div id="41785519" class="c"><input type="checkbox" id="c-41785519" checked=""/><div class="controls bullet"><span class="by">soulchild77</span><span>|</span><a href="#41785259">parent</a><span>|</span><a href="#41783625">next</a><span>|</span><label class="collapse" for="c-41785519">[-]</label><label class="expand" for="c-41785519">[1 more]</label></div><br/><div class="children"><div class="content">This. I think types really make the difference here. You can get very far with just plain old JS objects as long as you&#x27;ve got strong types in place.</div><br/></div></div></div></div><div id="41783625" class="c"><input type="checkbox" id="c-41783625" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#41785259">prev</a><span>|</span><a href="#41785283">next</a><span>|</span><label class="collapse" for="c-41783625">[-]</label><label class="expand" for="c-41783625">[11 more]</label></div><br/><div class="children"><div class="content">For better or for worse, Python doesn&#x27;t do typing well. I don&#x27;t disagree that I prefer well defined types, but if that is your desire then I think Python is perhaps not the correct choice of language.</div><br/><div id="41784178" class="c"><input type="checkbox" id="c-41784178" checked=""/><div class="controls bullet"><span class="by">Ey7NFZ3P0nzAe</span><span>|</span><a href="#41783625">parent</a><span>|</span><a href="#41783747">next</a><span>|</span><label class="collapse" for="c-41784178">[-]</label><label class="expand" for="c-41784178">[2 more]</label></div><br/><div class="children"><div class="content">Personnaly I became a huge fan of beartype : <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;beartype&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;beartype&#x2F;</a><p>Leyec, the magic dev behind it managed to make a full python type checker with super advanced features and about 0 overhead. It&#x27;s crazy</div><br/><div id="41784634" class="c"><input type="checkbox" id="c-41784634" checked=""/><div class="controls bullet"><span class="by">skeledrew</span><span>|</span><a href="#41783625">root</a><span>|</span><a href="#41784178">parent</a><span>|</span><a href="#41783747">next</a><span>|</span><label class="collapse" for="c-41784634">[-]</label><label class="expand" for="c-41784634">[1 more]</label></div><br/><div class="children"><div class="content">I tried using it, but beartype quickly became a pain with having to decorate things manually. Then I found typeguard which goes even further and never looked back. Instead of manually decorating each individual function, an import hook can be activated that automatically decorates any function with type annotation. Massive QoL improvement. I have it set to only activate during testing though as I&#x27;m unsure of the overhead.</div><br/></div></div></div></div><div id="41783747" class="c"><input type="checkbox" id="c-41783747" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#41783625">parent</a><span>|</span><a href="#41784178">prev</a><span>|</span><a href="#41784082">next</a><span>|</span><label class="collapse" for="c-41783747">[-]</label><label class="expand" for="c-41783747">[1 more]</label></div><br/><div class="children"><div class="content">Python does typing pretty darn well now for data like API requests and responses.<p>&quot;Typed Python&quot; does poorly (compared to e.g. Typescript) on things like overloading functions, generics, structural subtyping, et al.</div><br/></div></div><div id="41784082" class="c"><input type="checkbox" id="c-41784082" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#41783625">parent</a><span>|</span><a href="#41783747">prev</a><span>|</span><a href="#41785283">next</a><span>|</span><label class="collapse" for="c-41784082">[-]</label><label class="expand" for="c-41784082">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Python doesn&#x27;t do typing well<p>Golang does typing, but JSONs are PITA to handle.<p>Try parsing something like `[{&quot;a&#x27;: 1, &quot;b&quot;: &quot;c&quot;, &quot;d&quot;: [], &quot;e&quot;: {}}, null, 1, &quot;2&quot;]` in go.<p>Types are a bless as well as a curse.</div><br/><div id="41784139" class="c"><input type="checkbox" id="c-41784139" checked=""/><div class="controls bullet"><span class="by">Aditya_Garg</span><span>|</span><a href="#41783625">root</a><span>|</span><a href="#41784082">parent</a><span>|</span><a href="#41784969">next</a><span>|</span><label class="collapse" for="c-41784139">[-]</label><label class="expand" for="c-41784139">[5 more]</label></div><br/><div class="children"><div class="content">Thats only because your list has different types. Its a badly formed API and if you really need to support that use case then you can use maps and reflection to handle it.</div><br/><div id="41784252" class="c"><input type="checkbox" id="c-41784252" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#41783625">root</a><span>|</span><a href="#41784139">parent</a><span>|</span><a href="#41784969">next</a><span>|</span><label class="collapse" for="c-41784252">[-]</label><label class="expand" for="c-41784252">[4 more]</label></div><br/><div class="children"><div class="content">The problem is, programmers can&#x27;t dictate what JSON should look like in the wild.<p>We used to have strict typed XML. Nobody even bothered.</div><br/><div id="41784686" class="c"><input type="checkbox" id="c-41784686" checked=""/><div class="controls bullet"><span class="by">a57721</span><span>|</span><a href="#41783625">root</a><span>|</span><a href="#41784252">parent</a><span>|</span><a href="#41784698">next</a><span>|</span><label class="collapse" for="c-41784686">[-]</label><label class="expand" for="c-41784686">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The problem is, programmers can&#x27;t dictate what JSON should look like in the wild.<p>Not JSONs in general, but a sane API would never return something like that.<p>&gt; We used to have strict typed XML. Nobody even bothered.<p>Nowadays there is OpenAPI, GraphQL, protobuf, etc. and people do bother about such things.</div><br/><div id="41784749" class="c"><input type="checkbox" id="c-41784749" checked=""/><div class="controls bullet"><span class="by">mook</span><span>|</span><a href="#41783625">root</a><span>|</span><a href="#41784686">parent</a><span>|</span><a href="#41784698">next</a><span>|</span><label class="collapse" for="c-41784749">[-]</label><label class="expand" for="c-41784749">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, a lot of the time you need to deal with other people&#x27;s APIs.</div><br/></div></div></div></div><div id="41784698" class="c"><input type="checkbox" id="c-41784698" checked=""/><div class="controls bullet"><span class="by">shiroiushi</span><span>|</span><a href="#41783625">root</a><span>|</span><a href="#41784252">parent</a><span>|</span><a href="#41784686">prev</a><span>|</span><a href="#41784969">next</a><span>|</span><label class="collapse" for="c-41784698">[-]</label><label class="expand" for="c-41784698">[1 more]</label></div><br/><div class="children"><div class="content">&gt;We used to have strict typed XML. Nobody even bothered.<p>Yeah, because it was ugly as hell and not human-readable.</div><br/></div></div></div></div></div></div><div id="41784969" class="c"><input type="checkbox" id="c-41784969" checked=""/><div class="controls bullet"><span class="by">Turskarama</span><span>|</span><a href="#41783625">root</a><span>|</span><a href="#41784082">parent</a><span>|</span><a href="#41784139">prev</a><span>|</span><a href="#41785283">next</a><span>|</span><label class="collapse" for="c-41784969">[-]</label><label class="expand" for="c-41784969">[1 more]</label></div><br/><div class="children"><div class="content">And if you got that JSON back in Python, how would you do anything with it?  This API is essentially useless.  You can deserisalise it, sure, but then what?</div><br/></div></div></div></div></div></div><div id="41785283" class="c"><input type="checkbox" id="c-41785283" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#41783625">prev</a><span>|</span><a href="#41784453">next</a><span>|</span><label class="collapse" for="c-41785283">[-]</label><label class="expand" for="c-41785283">[2 more]</label></div><br/><div class="children"><div class="content">This has merit in some cases but let me try to make a counterpoint.<p>You lose the algebra of dict’s - and it’s a rich algebra to lose since in python it’s not just all the basic obvious stuff but it’s also powerful things like dict comprehensions and ordering guarantees (3.7+ only).<p>You tightly couple to a definition - in the simple GitHubRepository example this is unlikely to be problematic. In the real world, coupling like this[1] to objects trying to capture domain data with dynamic structures is regularly the stuff of nightmares.<p>The over-arching problem with the approach given is that it puts code above data. You take what could be a schema, inert data about inert data, and instead use code. But it might also be an interesting case to consider as a slippery slope - if you can put code concerns above data concerns then maybe soon you will see cases where code concerns rank higher than the users of your software?<p>[1] - by coupling like this I mean the “parse don’t validate” school of thought which says as soon as you get a blob of data from an external source, be it a file, a database or in this case a remote service, you immediately tie yourself to a rocket ship whose journey can see you explosively grow the number of types to accurately capture the information needed for every use case of the data. You could move this parsing operation to be local to the use case of the data (much better) rather than have it here at the entry point of the data to the system but often times (although not always) we can arrive at a simpler solution if we are clever enough to express it in a style that can easily be understood by a newbie to programming. That often means relying on the common algebra of core types rather than introducing your own types.</div><br/><div id="41785315" class="c"><input type="checkbox" id="c-41785315" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#41785283">parent</a><span>|</span><a href="#41784453">next</a><span>|</span><label class="collapse" for="c-41785315">[-]</label><label class="expand" for="c-41785315">[1 more]</label></div><br/><div class="children"><div class="content">You also make a nightmare of dynamically adding middleware — which can piggyback on a generic dict and have no meaningful way to insert themselves into your type maze.</div><br/></div></div></div></div><div id="41784453" class="c"><input type="checkbox" id="c-41784453" checked=""/><div class="controls bullet"><span class="by">cle</span><span>|</span><a href="#41785283">prev</a><span>|</span><a href="#41783595">next</a><span>|</span><label class="collapse" for="c-41784453">[-]</label><label class="expand" for="c-41784453">[5 more]</label></div><br/><div class="children"><div class="content">Dicts can be a problem, but this particular example isn&#x27;t that great, like in this diagram from the article:<p><pre><code>  External API &lt;--dict--&gt; Ser&#x2F;De &lt;--model--&gt; Business Logic
</code></pre>
Life&#x27;s all great until &quot;External API&quot; adds a field that your model doesn&#x27;t know about, it gets dropped when you deserialize it, and then when you send it back (or around somewhere else) it&#x27;s missing a field.<p>There&#x27;s config for this in Pydantic, but it&#x27;s not the default, and isn&#x27;t for most ser&#x2F;de frameworks (TypeScript is a notable exception here).<p>Closed enums have a similar tradeoff.</div><br/><div id="41784645" class="c"><input type="checkbox" id="c-41784645" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#41784453">parent</a><span>|</span><a href="#41783595">next</a><span>|</span><label class="collapse" for="c-41784645">[-]</label><label class="expand" for="c-41784645">[4 more]</label></div><br/><div class="children"><div class="content">If external API adds a new field but your software already worked, you didn&#x27;t need it in the first place, so why should it matter?<p>Dropping unknown&#x2F;unused fields makes sense in 99% of cases.</div><br/><div id="41784792" class="c"><input type="checkbox" id="c-41784792" checked=""/><div class="controls bullet"><span class="by">buzer</span><span>|</span><a href="#41784453">root</a><span>|</span><a href="#41784645">parent</a><span>|</span><a href="#41783595">next</a><span>|</span><label class="collapse" for="c-41784792">[-]</label><label class="expand" for="c-41784792">[3 more]</label></div><br/><div class="children"><div class="content">Unfortunately some APIs assume that they will get all the fields as part of the update. If field doesn&#x27;t exist in the input it gets it will drop the original value during the update.</div><br/><div id="41784967" class="c"><input type="checkbox" id="c-41784967" checked=""/><div class="controls bullet"><span class="by">_ZeD_</span><span>|</span><a href="#41784453">root</a><span>|</span><a href="#41784792">parent</a><span>|</span><a href="#41783595">next</a><span>|</span><label class="collapse" for="c-41784967">[-]</label><label class="expand" for="c-41784967">[2 more]</label></div><br/><div class="children"><div class="content">yet, again, most of the libraries already deal with extra fields... i.e. for pydantic <a href="https:&#x2F;&#x2F;docs.pydantic.dev&#x2F;latest&#x2F;concepts&#x2F;models&#x2F;#extra-fields" rel="nofollow">https:&#x2F;&#x2F;docs.pydantic.dev&#x2F;latest&#x2F;concepts&#x2F;models&#x2F;#extra-fiel...</a></div><br/><div id="41785408" class="c"><input type="checkbox" id="c-41785408" checked=""/><div class="controls bullet"><span class="by">vouwfietsman</span><span>|</span><a href="#41784453">root</a><span>|</span><a href="#41784967">parent</a><span>|</span><a href="#41783595">next</a><span>|</span><label class="collapse" for="c-41785408">[-]</label><label class="expand" for="c-41785408">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t deal with external APIs often, but this is a development nightmare. You can&#x27;t just magically let data flow through your system without knowing about it, because this is not how programming works. Your API has a contract and your code is written to support that contract, if the contract changes it should either be a very consciously decided breaking change that is versioned somehow, or it should be an unversioned non breaking change. Apparently whatever data is added like this is completely meaningless to your program so why do you need to be in charge of passing it back to the API.<p>Changing your API and assuming everything just keeps working is a nonsense cowboy attitude to software compatibility, even if some frameworks bend over backwards to support it through magic that&#x27;s hidden from the developer. Furthermore, many programming languages are simply incapable of doing this, and this approach to APIs is immediately restricting those languages from use.<p>Finally, transforming objects to an internal domain model is really the cornerstone of a lot of recent well-thought-out programming discipline, and this API design is throwing that in the garbage. It&#x27;s explicitly asking you to mess up your service architecture, spreading bad architecture like a virus to all systems that interact with the API.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41783595" class="c"><input type="checkbox" id="c-41783595" checked=""/><div class="controls bullet"><span class="by">fhdsgbbcaA</span><span>|</span><a href="#41784453">prev</a><span>|</span><a href="#41784820">next</a><span>|</span><label class="collapse" for="c-41783595">[-]</label><label class="expand" for="c-41783595">[8 more]</label></div><br/><div class="children"><div class="content">Seems like the issue is less using dicts than not treating external APIs as input that needs to be sanitized.</div><br/><div id="41783603" class="c"><input type="checkbox" id="c-41783603" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#41783595">parent</a><span>|</span><a href="#41784820">next</a><span>|</span><label class="collapse" for="c-41783603">[-]</label><label class="expand" for="c-41783603">[7 more]</label></div><br/><div class="children"><div class="content">Agreed. If you sanitize&#x2F;allowlist API data you should not have issues with dicts.</div><br/><div id="41783654" class="c"><input type="checkbox" id="c-41783654" checked=""/><div class="controls bullet"><span class="by">imron</span><span>|</span><a href="#41783595">root</a><span>|</span><a href="#41783603">parent</a><span>|</span><a href="#41784820">next</a><span>|</span><label class="collapse" for="c-41783654">[-]</label><label class="expand" for="c-41783654">[6 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll have issues if you ever rename things in the dict.<p>Linting tools will pick up on every instance where you forgot to rename the fields of a class, but won&#x27;t do the same for dicts.</div><br/><div id="41783739" class="c"><input type="checkbox" id="c-41783739" checked=""/><div class="controls bullet"><span class="by">FreakLegion</span><span>|</span><a href="#41783595">root</a><span>|</span><a href="#41783654">parent</a><span>|</span><a href="#41784820">next</a><span>|</span><label class="collapse" for="c-41783739">[-]</label><label class="expand" for="c-41783739">[5 more]</label></div><br/><div class="children"><div class="content">TypedDicts solve the linting problem, but refactoring tools haven&#x27;t caught up (unlike e.g. ForwardRef type annotations, which are strings but can be transformed alongside type literals).</div><br/><div id="41783992" class="c"><input type="checkbox" id="c-41783992" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#41783595">root</a><span>|</span><a href="#41783739">parent</a><span>|</span><a href="#41784820">next</a><span>|</span><label class="collapse" for="c-41783992">[-]</label><label class="expand" for="c-41783992">[4 more]</label></div><br/><div class="children"><div class="content">Is there any advantage to using a TypedDict for a record over a dataclass?</div><br/><div id="41784481" class="c"><input type="checkbox" id="c-41784481" checked=""/><div class="controls bullet"><span class="by">FreakLegion</span><span>|</span><a href="#41783595">root</a><span>|</span><a href="#41783992">parent</a><span>|</span><a href="#41784820">next</a><span>|</span><label class="collapse" for="c-41784481">[-]</label><label class="expand" for="c-41784481">[3 more]</label></div><br/><div class="children"><div class="content">TypedDicts &quot;aren&#x27;t real&quot; in the sense that they&#x27;re a compile-time feature, so you&#x27;re getting typing without any deserialization cost beyond the original JSON. Dataclasses and Pydantic models are slow to construct, so that&#x27;s not nothing.<p>This of course means TypeDicts don&#x27;t give you run-time validation. For that, and for full-blown custom types in general, I tend to favor msgspec Structs: <a href="https:&#x2F;&#x2F;jcristharif.com&#x2F;msgspec&#x2F;benchmarks.html#json-serialization-validation" rel="nofollow">https:&#x2F;&#x2F;jcristharif.com&#x2F;msgspec&#x2F;benchmarks.html#json-seriali...</a>.</div><br/><div id="41784979" class="c"><input type="checkbox" id="c-41784979" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#41783595">root</a><span>|</span><a href="#41784481">parent</a><span>|</span><a href="#41784820">next</a><span>|</span><label class="collapse" for="c-41784979">[-]</label><label class="expand" for="c-41784979">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Dataclasses and Pydantic models are slow to construct<p>Citation needed? Pydantic is really quite fast, and you can pass raw JSON responses into it.<p>It may be <i>slower</i> (depending on the validators or structure), but I’d expect it to be comparably fast to the stdlib JSON module.</div><br/><div id="41785416" class="c"><input type="checkbox" id="c-41785416" checked=""/><div class="controls bullet"><span class="by">FreakLegion</span><span>|</span><a href="#41783595">root</a><span>|</span><a href="#41784979">parent</a><span>|</span><a href="#41784820">next</a><span>|</span><label class="collapse" for="c-41785416">[-]</label><label class="expand" for="c-41785416">[1 more]</label></div><br/><div class="children"><div class="content">Pydantic&#x27;s JSON parsing is faster than the built-in module, on par with orjson, but creating model instances and run-time type checking net out to be much slower. I linked msgspec&#x27;s benchmarks in the previous post.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41784820" class="c"><input type="checkbox" id="c-41784820" checked=""/><div class="controls bullet"><span class="by">cranium</span><span>|</span><a href="#41783595">prev</a><span>|</span><a href="#41783523">next</a><span>|</span><label class="collapse" for="c-41784820">[-]</label><label class="expand" for="c-41784820">[1 more]</label></div><br/><div class="children"><div class="content">Python dataclasses are a good start for internal use. They are just a bit of a pain to serialize&#x2F;deserialize natively. When it comes to that, I prefer to use Pydantic objects and have all the goodies, at the cost of some complexity.</div><br/></div></div><div id="41783523" class="c"><input type="checkbox" id="c-41783523" checked=""/><div class="controls bullet"><span class="by">hcarvalhoalves</span><span>|</span><a href="#41784820">prev</a><span>|</span><a href="#41783471">next</a><span>|</span><label class="collapse" for="c-41783523">[-]</label><label class="expand" for="c-41783523">[1 more]</label></div><br/><div class="children"><div class="content">Debatable. Here&#x27;s a counter-point:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aSEQfqNYNAc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aSEQfqNYNAc</a><p>But ok, it&#x27;s less bad in Python since objects are dicts anyway and you don&#x27;t need getters.</div><br/></div></div><div id="41783471" class="c"><input type="checkbox" id="c-41783471" checked=""/><div class="controls bullet"><span class="by">cschneid</span><span>|</span><a href="#41783523">prev</a><span>|</span><a href="#41784657">next</a><span>|</span><label class="collapse" for="c-41783471">[-]</label><label class="expand" for="c-41783471">[1 more]</label></div><br/><div class="children"><div class="content">I generally support this. When dealing with API endpoints especially I like to wrap them in a class that ends up being. I also like having nested data structures as their own class sometimes too. Depends on complexity &amp; need of course.<p><pre><code>    class GetThingResult
      def initialize(json)
        @json = json
      end
    
      # single thing
      def thing_id
        @json.dig(&#x27;wrapper&#x27;, &#x27;metadata&#x27;, &#x27;id&#x27;)
      end
    
      # multiple things
      def history
        @json[&#x27;history&#x27;].map { |h| ThingHistory.new(h) }
      end
      ... two dozen more things
    end</code></pre></div><br/></div></div><div id="41784657" class="c"><input type="checkbox" id="c-41784657" checked=""/><div class="controls bullet"><span class="by">xenoxcs</span><span>|</span><a href="#41783471">prev</a><span>|</span><a href="#41785064">next</a><span>|</span><label class="collapse" for="c-41784657">[-]</label><label class="expand" for="c-41784657">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a big fan of using Protobuf for the third-party API validation task. After some slightly finniky initial schema definition (helped by things like json-to-proto.github.io), I can be sure the data I&#x27;m consuming from an external API is strongly typed, and the functions included in Protobuf which convert JSON to a Proto message instance blows up by default if there&#x27;s an unexpected field in the API data it&#x27;s consuming.<p>I use it to parse and validate incoming webhook data in my Python AWS Lambda functions, then re-use the protobuf types when I later ship the webhook data to our Flutter-based frontend. Adding extensions to the protobuf fields gives me a nice, structured way to add flags and metadata to different fields in the webhook message. For example, I can add table &amp; column names to the protobuf message fields, and have them automatically be populated from the DB with some simple helper functions. Avoids me needing to write many lines of code that look like:<p>MyProtoClass.field1 = DB.table.column1.val<p>MyProtoClass.field2 = DB.table.column2.val</div><br/></div></div><div id="41785064" class="c"><input type="checkbox" id="c-41785064" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41784657">prev</a><span>|</span><a href="#41785805">next</a><span>|</span><label class="collapse" for="c-41785064">[-]</label><label class="expand" for="c-41785064">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>convert [dicts] immediately to data structures providing semantics [...] You can simplify your work by employing a library that makes “better classes” for you</i><p>Python seems to have many different kinds of &quot;better classes&quot; - the article mentions `dataclass` and `TypedDict`, and AFAIK there are also two different kinds of named tuple (`collections.namedtuple` and `Typing.NamedTuple`).<p>What are the advantages of these &quot;better classes&quot; over traditional classes? How would you choose which of the four (or more?) kinds to use?</div><br/><div id="41785148" class="c"><input type="checkbox" id="c-41785148" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#41785064">parent</a><span>|</span><a href="#41785805">next</a><span>|</span><label class="collapse" for="c-41785148">[-]</label><label class="expand" for="c-41785148">[2 more]</label></div><br/><div class="children"><div class="content">To me, the proliferation of &quot;better classes&quot; implies there&#x27;s a problem with Python&#x27;s built-in classes - but what&#x27;s wrong? Are they just too flexible and&#x2F;or too verbose? Or actually deficient in some way?</div><br/><div id="41785305" class="c"><input type="checkbox" id="c-41785305" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#41785064">root</a><span>|</span><a href="#41785148">parent</a><span>|</span><a href="#41785805">next</a><span>|</span><label class="collapse" for="c-41785305">[-]</label><label class="expand" for="c-41785305">[1 more]</label></div><br/><div class="children"><div class="content">People enjoy the flexibility and many Python systems rely on duck-typing via dicts, etc.<p>So people are trying to force Python to be something it isn’t in adherence to their ideology — but it fails to gain consensus because there’s a sizable cohort that use Python because it <i>isnt</i> those things.<p>So we get repeated implementations, from each ideologically motivated group.</div><br/></div></div></div></div></div></div><div id="41785805" class="c"><input type="checkbox" id="c-41785805" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41785064">prev</a><span>|</span><a href="#41784320">next</a><span>|</span><label class="collapse" for="c-41785805">[-]</label><label class="expand" for="c-41785805">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ignore fields coming from the API if you don’t need them. Keep only those that you use.<p>This is great if you know what you need from the start. If you only find out what you need after passing your data through multiple layers and modules of your system then you need to backtrack through all your code to the place of creation.<p>If you have immutable data structures then you have to backtrack through multiple places where your data is used from previous structures to create new ones to pass your additional data through all that.<p>So if your data travels through let&#x27;s say 3 immutable types to reach the place you are working on then even if you know exactly where the new field that you need originates, you need to alter 3 types and 3 places where data is read from one type and crammed into another.<p>If you have a dict that you fill with all you got from the api there&#x27;s zero work involved with getting the new piece of information that you thought you didn&#x27;t need but you actually do. It&#x27;s just there.</div><br/></div></div><div id="41784320" class="c"><input type="checkbox" id="c-41784320" checked=""/><div class="controls bullet"><span class="by">karmakurtisaani</span><span>|</span><a href="#41785805">prev</a><span>|</span><a href="#41784096">next</a><span>|</span><label class="collapse" for="c-41784320">[-]</label><label class="expand" for="c-41784320">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve cleaned up code where input parameters came in a dict form. Absolute shit show.<p>- The only way to figure out which parameters are even possible was to search through the code for the uses of the dict.<p>- Default values were decided on the spot all over the place (input.getOrDefault(..)).<p>- Parameter names had to be typed out each time, so better be careful with correct spelling.<p>- Having a concise overview how the input is handled (sanitized) was practically impossible.<p>0&#x2F;10 design decision, would not recommend.</div><br/></div></div><div id="41784096" class="c"><input type="checkbox" id="c-41784096" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#41784320">prev</a><span>|</span><a href="#41783519">next</a><span>|</span><label class="collapse" for="c-41784096">[-]</label><label class="expand" for="c-41784096">[6 more]</label></div><br/><div class="children"><div class="content">dicts are OK, because at least they do have a `key` and it does mean something.<p>un-annotated tuples and too many func params are cancer.</div><br/><div id="41784149" class="c"><input type="checkbox" id="c-41784149" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#41784096">parent</a><span>|</span><a href="#41784122">next</a><span>|</span><label class="collapse" for="c-41784149">[-]</label><label class="expand" for="c-41784149">[2 more]</label></div><br/><div class="children"><div class="content">Who does this still??</div><br/><div id="41785258" class="c"><input type="checkbox" id="c-41785258" checked=""/><div class="controls bullet"><span class="by">directevolve</span><span>|</span><a href="#41784096">root</a><span>|</span><a href="#41784149">parent</a><span>|</span><a href="#41784122">next</a><span>|</span><label class="collapse" for="c-41785258">[-]</label><label class="expand" for="c-41785258">[1 more]</label></div><br/><div class="children"><div class="content">In bioinformatics, one of our main dataflow platforms, Nextflow, is built with unnamed tuples in mind. Implementing the ability to conveniently pass data with HashMaps instead of unnamed tuples was a huge boost to usability for me.</div><br/></div></div></div></div><div id="41784122" class="c"><input type="checkbox" id="c-41784122" checked=""/><div class="controls bullet"><span class="by">stonethrowaway</span><span>|</span><a href="#41784096">parent</a><span>|</span><a href="#41784149">prev</a><span>|</span><a href="#41783519">next</a><span>|</span><label class="collapse" for="c-41784122">[-]</label><label class="expand" for="c-41784122">[3 more]</label></div><br/><div class="children"><div class="content">No no,<p>Un-annotated tuples and too many func params are OK, because at least they are pushed and popped from the stack.<p>Calls and rets without a prologue and epilogue on the other hand…</div><br/><div id="41784176" class="c"><input type="checkbox" id="c-41784176" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#41784096">root</a><span>|</span><a href="#41784122">parent</a><span>|</span><a href="#41784426">next</a><span>|</span><label class="collapse" for="c-41784176">[-]</label><label class="expand" for="c-41784176">[1 more]</label></div><br/><div class="children"><div class="content">&gt; from the stack<p>Or many, many stacks you can&#x27;t comprehend nor amend.<p>I dare to add a new `key` to a dict, can you modify a func call or a tuple with confidence?</div><br/></div></div></div></div></div></div><div id="41783519" class="c"><input type="checkbox" id="c-41783519" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#41784096">prev</a><span>|</span><a href="#41783597">next</a><span>|</span><label class="collapse" for="c-41783519">[-]</label><label class="expand" for="c-41783519">[6 more]</label></div><br/><div class="children"><div class="content">I think one really nice thing about Python is duck typing.  Your interfaces are rarely asking for a dict as much as they’re asking for a dict-like. It’s pretty great how often you can worry about this kind of problem at the appropriate time (now, later, never) without much pain.<p>There’s useful ideas in this post but I’d be careful not to throw the baby out with the bath water. Dicts are right there. There’s dict literals and dict comprehensions. Reach for more specific dict-likes when it really matters.</div><br/><div id="41783951" class="c"><input type="checkbox" id="c-41783951" checked=""/><div class="controls bullet"><span class="by">turnsout</span><span>|</span><a href="#41783519">parent</a><span>|</span><a href="#41783597">next</a><span>|</span><label class="collapse" for="c-41783951">[-]</label><label class="expand" for="c-41783951">[5 more]</label></div><br/><div class="children"><div class="content">Duck typing is so fragile… Once you have implementations that are depending on your naming or property structure, you can’t update the model without breaking them all.<p>If you use a real type, you never have to worry about this.</div><br/><div id="41784670" class="c"><input type="checkbox" id="c-41784670" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41783519">root</a><span>|</span><a href="#41783951">parent</a><span>|</span><a href="#41785329">next</a><span>|</span><label class="collapse" for="c-41784670">[-]</label><label class="expand" for="c-41784670">[3 more]</label></div><br/><div class="children"><div class="content">You would still have to update everything if you rename a field in a struct, what do you mean you never have to worry?</div><br/><div id="41784965" class="c"><input type="checkbox" id="c-41784965" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41783519">root</a><span>|</span><a href="#41784670">parent</a><span>|</span><a href="#41785329">next</a><span>|</span><label class="collapse" for="c-41784965">[-]</label><label class="expand" for="c-41784965">[2 more]</label></div><br/><div class="children"><div class="content">If you use type checking, the breakage occurs when you introduce the change: the author of the change is the one who can figure out what it means if &#x27;foo&#x27; is no longer being passed into this function.<p>If you&#x27;re duck typing, you find this out in the best case when your unit tests exercise it, and in the worst case by a support call when that 1&#x2F;1000 error handling path finally gets exercised in production.</div><br/><div id="41785538" class="c"><input type="checkbox" id="c-41785538" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41783519">root</a><span>|</span><a href="#41784965">parent</a><span>|</span><a href="#41785329">next</a><span>|</span><label class="collapse" for="c-41785538">[-]</label><label class="expand" for="c-41785538">[1 more]</label></div><br/><div class="children"><div class="content">I agree with that, in the context of dynamically typed languages.<p>Slowly but surely, new languages are starting to develop with static duck typing. Implicit interfaces if you will.</div><br/></div></div></div></div></div></div><div id="41785329" class="c"><input type="checkbox" id="c-41785329" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#41783519">root</a><span>|</span><a href="#41783951">parent</a><span>|</span><a href="#41784670">prev</a><span>|</span><a href="#41783597">next</a><span>|</span><label class="collapse" for="c-41785329">[-]</label><label class="expand" for="c-41785329">[1 more]</label></div><br/><div class="children"><div class="content">And now inserting every middleware is an exercise in retyping the system, rather than piggybacking on the parameter dict.</div><br/></div></div></div></div></div></div><div id="41783597" class="c"><input type="checkbox" id="c-41783597" checked=""/><div class="controls bullet"><span class="by">pmarreck</span><span>|</span><a href="#41783519">prev</a><span>|</span><a href="#41783629">next</a><span>|</span><label class="collapse" for="c-41783597">[-]</label><label class="expand" for="c-41783597">[3 more]</label></div><br/><div class="children"><div class="content">Less important in Elixir (where they are &quot;maps&quot;) due to the immutable nature of them as well as the Struct type which is a structured map.</div><br/><div id="41784662" class="c"><input type="checkbox" id="c-41784662" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#41783597">parent</a><span>|</span><a href="#41784116">next</a><span>|</span><label class="collapse" for="c-41784662">[-]</label><label class="expand" for="c-41784662">[1 more]</label></div><br/><div class="children"><div class="content">Yes, usually my APIs in Elixir receive their arguments as a well-typed map, not stringly keyed, and transform them to structs which the core business logic expects.</div><br/></div></div><div id="41784116" class="c"><input type="checkbox" id="c-41784116" checked=""/><div class="controls bullet"><span class="by">mikhmha</span><span>|</span><a href="#41783597">parent</a><span>|</span><a href="#41784662">prev</a><span>|</span><a href="#41783629">next</a><span>|</span><label class="collapse" for="c-41784116">[-]</label><label class="expand" for="c-41784116">[1 more]</label></div><br/><div class="children"><div class="content">Yup! I find Elixir makes it really intuitive to know when to represent a collection as a map and when to use a list of tuples. And its easy to transform between the two when needed.</div><br/></div></div></div></div><div id="41783629" class="c"><input type="checkbox" id="c-41783629" checked=""/><div class="controls bullet"><span class="by">thebeardisred</span><span>|</span><a href="#41783597">prev</a><span>|</span><a href="#41784221">next</a><span>|</span><label class="collapse" for="c-41783629">[-]</label><label class="expand" for="c-41783629">[1 more]</label></div><br/><div class="children"><div class="content">FYI, posted in 2020, updated in 2021.</div><br/></div></div><div id="41784221" class="c"><input type="checkbox" id="c-41784221" checked=""/><div class="controls bullet"><span class="by">leoh</span><span>|</span><a href="#41783629">prev</a><span>|</span><a href="#41783604">next</a><span>|</span><label class="collapse" for="c-41784221">[-]</label><label class="expand" for="c-41784221">[2 more]</label></div><br/><div class="children"><div class="content">Big structs as params in rust have similar issues</div><br/><div id="41784361" class="c"><input type="checkbox" id="c-41784361" checked=""/><div class="controls bullet"><span class="by">saintfire</span><span>|</span><a href="#41784221">parent</a><span>|</span><a href="#41783604">next</a><span>|</span><label class="collapse" for="c-41784361">[-]</label><label class="expand" for="c-41784361">[1 more]</label></div><br/><div class="children"><div class="content">In what way? 
They&#x27;re not opaque or mutable (by default).<p>They can be unwieldy but they do define a pretty strongly typed API.</div><br/></div></div></div></div><div id="41783604" class="c"><input type="checkbox" id="c-41783604" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#41784221">prev</a><span>|</span><a href="#41784505">next</a><span>|</span><label class="collapse" for="c-41783604">[-]</label><label class="expand" for="c-41783604">[2 more]</label></div><br/><div class="children"><div class="content">Lists and sets suffer the same drawbacks.  If the advice is to not use any of the batteries included if the language, why are we using Python?<p>If you want an immutable mapping, why not use an enum?</div><br/><div id="41783690" class="c"><input type="checkbox" id="c-41783690" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41783604">parent</a><span>|</span><a href="#41784505">next</a><span>|</span><label class="collapse" for="c-41783690">[-]</label><label class="expand" for="c-41783690">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t arguing against them in general, but against the unfortunate Javascript-esque abandonment of specified semantics.<p>In particular, whenever anyone thinks that &quot;deep clone vs shallow clone&quot; is a meaningful distinction, that means their types are utterly void of meaning.</div><br/></div></div></div></div><div id="41784505" class="c"><input type="checkbox" id="c-41784505" checked=""/><div class="controls bullet"><span class="by">gotoeleven</span><span>|</span><a href="#41783604">prev</a><span>|</span><a href="#41784023">next</a><span>|</span><label class="collapse" for="c-41784505">[-]</label><label class="expand" for="c-41784505">[1 more]</label></div><br/><div class="children"><div class="content">Personally I find it is often helpful to keep Dicts in a BigBag ie:<p>BigBag&lt;Dict&gt;</div><br/></div></div><div id="41784023" class="c"><input type="checkbox" id="c-41784023" checked=""/><div class="controls bullet"><span class="by">Barrin92</span><span>|</span><a href="#41784505">prev</a><span>|</span><label class="collapse" for="c-41784023">[-]</label><label class="expand" for="c-41784023">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bit of an odd article because the second part kind of shows why dicts aren&#x27;t a problem. You basically just need to apply the most old school of OO doctrines: &quot;recipients of messages are responsible for how they interpret them&quot;, and that&#x27;s exactly what the author advocates when he talks about treating dict data akin to data over the wire, which is correct.<p>If you&#x27;re programming correctly and take encapsulation seriously, then whatever shape incoming data in a dict has isn&#x27;t something you should take an issue with, you just need to make sure if what you care about is in it (or not) and handle that within your own context appropriately.<p>Rich Hickey once gave a talk about something like this talking about maps in Clojure and I think he made the analogy of the DHL truck stopping at your door. You don&#x27;t care what every package in the truck is, you just care if your package is in there. If some other data changes, which data always does, that&#x27;s not your concern, you should be decoupled from it. It&#x27;s just equivalent to how we program networked applications. There are no global semantics or guarantees on the state of data, there can&#x27;t be because the world isn&#x27;t in sync or static, there is no global state. There&#x27;s actually another Hickey-ism along the lines of &quot;program on the inside the same way you program on the outside&quot;. Dicts are cool, just make sure that you&#x27;re always responsible for what you do with one.</div><br/><div id="41785059" class="c"><input type="checkbox" id="c-41785059" checked=""/><div class="controls bullet"><span class="by">alfons_foobar</span><span>|</span><a href="#41784023">parent</a><span>|</span><label class="collapse" for="c-41785059">[-]</label><label class="expand" for="c-41785059">[1 more]</label></div><br/><div class="children"><div class="content">I assume you&#x27;re basically referring to this quote from the article?<p>&quot;Ignore fields coming from the API if you don’t need them. Keep only those that you use.&quot;<p>IMO this addresses only one part of the problem, namely &quot;sanitize your inputs&quot;.
But if you follow this, and therefore end up with a dict whose keys are known and always the same, using something &quot;struct-like&quot; (dataclasses, attrs, pydantic, ...) is just SO much more ergonomic :)</div><br/></div></div></div></div></div></div></div></div></div></body></html>