<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726563668770" as="style"/><link rel="stylesheet" href="styles.css?v=1726563668770"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/nyxpsi/nyxpsi">Nyxpsi – A Next-Gen Network Protocol for Extreme Packet Loss</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>nyxpsi</span> | <span>57 comments</span></div><br/><div><div id="41563816" class="c"><input type="checkbox" id="c-41563816" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41563251">next</a><span>|</span><label class="collapse" for="c-41563816">[-]</label><label class="expand" for="c-41563816">[2 more]</label></div><br/><div class="children"><div class="content">Just reading the description, I guessed it would be a fountain code. And, indeed, it’s a very very thin wrapper around RaptorQ.  So it gets data through a link that drops each packet, independently, with moderate probability, at approximately the maximum rate in the sense of number of packets transmitted divided by total message size.<p>What it does _not_ do is anything resembling intelligent determination of appropriate bandwidth, let alone real congestion control.  And it does not obviously handle the part that fountain codes don’t give for free: a way to stream out data that the sender wasn’t aware of from the very beginning.</div><br/><div id="41563971" class="c"><input type="checkbox" id="c-41563971" checked=""/><div class="controls bullet"><span class="by">commandersaki</span><span>|</span><a href="#41563816">parent</a><span>|</span><a href="#41563251">next</a><span>|</span><label class="collapse" for="c-41563971">[-]</label><label class="expand" for="c-41563971">[1 more]</label></div><br/><div class="children"><div class="content">Would a protocol like this be useful for a data diode?</div><br/></div></div></div></div><div id="41563251" class="c"><input type="checkbox" id="c-41563251" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#41563816">prev</a><span>|</span><a href="#41563054">next</a><span>|</span><label class="collapse" for="c-41563251">[-]</label><label class="expand" for="c-41563251">[8 more]</label></div><br/><div class="children"><div class="content">This is neat, but I&#x27;m a little confused on those benchmark numbers and what they mean exactly. For example, with 10% or 50% packet loss you aren&#x27;t going to get a TCP stream to do anything reasonable. They will seem to just &quot;pause&quot; and make very, very slow progress. When we talk about loss scenarios, we are typically talking about single digit loss and more often well under 1%. Scenarios of 10 to 50% loss are catastrophic where TCPs effectively cease to function, so if this protocol works well in that that environment, it is an impressive feat.<p>EDIT: It probably also needs to be clarified which TCP algorithm they are using. TCP standards just dictate framing&#x2F;windowing, etc. but algorithms are free to use their own strategies for retransmissions and bursting, and the algorithm used makes a big difference in differing loss scenarios.<p>EDIT 2: I just noticed the number in parens is transfer success rate. Seeing 0% for 10 and 50% loss for TCP sounds about right. I&#x27;m not sure I still understand their UDP #&#x27;s as UDP isn&#x27;t a stream protocol, so raw transferred data would be 100% minus loss %, unless they are using some protocol on top of it.</div><br/><div id="41563451" class="c"><input type="checkbox" id="c-41563451" checked=""/><div class="controls bullet"><span class="by">AdamJacobMuller</span><span>|</span><a href="#41563251">parent</a><span>|</span><a href="#41563522">next</a><span>|</span><label class="collapse" for="c-41563451">[-]</label><label class="expand" for="c-41563451">[4 more]</label></div><br/><div class="children"><div class="content">With the # in parens being success rate, the timing makes little sense to me.<p>A TCP connection with 10% loss will work and transfer (it&#x27;s gonna suck) and be very very very slow but their TCP 10% loss example is faster somehow?<p>TCP being reliable will just get slower with loss until it eventually can&#x27;t transmit any successful packets within some TCP timeout (or some application-level timeout).<p>Even a 50% packet loss connection will work, within some definitions of the word &quot;work&quot; and also this brings up the biggest missing point in that chart: this all depends heavily on latency.<p>50% loss on a connection with 1ms latency is much more tolerable than 1% loss on a connection with 1000ms latency and will transfer faster (caveats around algorithms and other things apply, but this is directionally correct).<p>A real chart for this would be a graph where X is the % of packet loss and Y is the latency amount with distinct lines per protocol (really one line per defined protocol configuration, eg tcp cubic w&#x2F;nagle vs without and with&#x2F;without some device doing RED in the middle or different RED configurations, etc, many parameters to test here).<p>If this sounds negative, it&#x27;s not, I think the research around effective high-latency protocols is very interesting and important. I was thinking recently (probably due to all the SpaceX news) about what the internet will look like for people on the moon or on mars. The current internet will just not work for them at all. We will require very creative solutions to make a useful open internet connections which isn&#x27;t locked down to Apple&#x2F;Facebook&#x2F;Google&#x2F;X&#x2F;Netflix&#x2F;etc.</div><br/><div id="41563501" class="c"><input type="checkbox" id="c-41563501" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#41563251">root</a><span>|</span><a href="#41563451">parent</a><span>|</span><a href="#41563522">next</a><span>|</span><label class="collapse" for="c-41563501">[-]</label><label class="expand" for="c-41563501">[3 more]</label></div><br/><div class="children"><div class="content">A big problem with TCP&#x27;s loss avoidance is that it assumes the cause of loss is congestion, so if you use it on a network with random packet loss it can just get slower and slower and slower until it effectively stops working entirely.</div><br/><div id="41563603" class="c"><input type="checkbox" id="c-41563603" checked=""/><div class="controls bullet"><span class="by">AdamJacobMuller</span><span>|</span><a href="#41563251">root</a><span>|</span><a href="#41563501">parent</a><span>|</span><a href="#41563616">next</a><span>|</span><label class="collapse" for="c-41563603">[-]</label><label class="expand" for="c-41563603">[1 more]</label></div><br/><div class="children"><div class="content">Agreed that it&#x27;s a problem but probably not a huge one today on the internet since most loss is actually a result of congestion.<p>It has led to some weird things whereby the L2 protocols (thinking wifi and LTE&#x2F;cellular) have their own reliability layer to combat the problem you&#x27;re describing. I&#x27;m not sure if things would be better or worse if they didn&#x27;t do this and TCP was responsible, the iteration of solutions for it would be much slower and probably could never be as good as the current situation where the network presents a less-lossy layer to TCP.<p>We have to completely rethink things for interplanetary networking.<p>I thought I recognized your username, I remember jailbreaking the original iPhone on IRC with you helping :)</div><br/></div></div><div id="41563616" class="c"><input type="checkbox" id="c-41563616" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#41563251">root</a><span>|</span><a href="#41563501">parent</a><span>|</span><a href="#41563603">prev</a><span>|</span><a href="#41563522">next</a><span>|</span><label class="collapse" for="c-41563616">[-]</label><label class="expand" for="c-41563616">[1 more]</label></div><br/><div class="children"><div class="content">Similarly, I wonder if nyxpsi has congestion control? It&#x27;s probably tricky to implement if you are trying work with a crap network. I guess you could see how packet loss or latency responds to throughput, but then you need to change the throughput periodically while transmitting, which slows down the transfer.</div><br/></div></div></div></div></div></div><div id="41563522" class="c"><input type="checkbox" id="c-41563522" checked=""/><div class="controls bullet"><span class="by">daxdev</span><span>|</span><a href="#41563251">parent</a><span>|</span><a href="#41563451">prev</a><span>|</span><a href="#41563606">next</a><span>|</span><label class="collapse" for="c-41563522">[-]</label><label class="expand" for="c-41563522">[1 more]</label></div><br/><div class="children"><div class="content">not sure what ur asking then, it uses the standard UDP implementation and the benchmarks have to do with transferring the entirety of the sample data not by individual packet loss but rather receiving the whole context of the message. There is no retransmission. Its all or nothing...</div><br/></div></div><div id="41563606" class="c"><input type="checkbox" id="c-41563606" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#41563251">parent</a><span>|</span><a href="#41563522">prev</a><span>|</span><a href="#41563054">next</a><span>|</span><label class="collapse" for="c-41563606">[-]</label><label class="expand" for="c-41563606">[2 more]</label></div><br/><div class="children"><div class="content">Yes, esp comparing against &quot;UDP&quot; this way doesn&#x27;t make sense.</div><br/><div id="41563748" class="c"><input type="checkbox" id="c-41563748" checked=""/><div class="controls bullet"><span class="by">klempner</span><span>|</span><a href="#41563251">root</a><span>|</span><a href="#41563606">parent</a><span>|</span><a href="#41563054">next</a><span>|</span><label class="collapse" for="c-41563748">[-]</label><label class="expand" for="c-41563748">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s particularly confusing is that this appears to be coming from the dev team themselves -- this isn&#x27;t some rando pointing at an interesting unprepared github they found.<p>Like, if they&#x27;re looking for publicity by sharing their github page, I&#x27;d expect the readme to have a basic elevator pitch, but their benchmarking section is a giant category error and it&#x27;s missing even the most high level of summary as to what it is doing to achieve good throughput at high packet loss rates.</div><br/></div></div></div></div></div></div><div id="41563054" class="c"><input type="checkbox" id="c-41563054" checked=""/><div class="controls bullet"><span class="by">HippoBaro</span><span>|</span><a href="#41563251">prev</a><span>|</span><a href="#41563875">next</a><span>|</span><label class="collapse" for="c-41563054">[-]</label><label class="expand" for="c-41563054">[1 more]</label></div><br/><div class="children"><div class="content">It would be great to know a bit more about the protocol itself in the readme. I’m left wondering if it’s reliable connection-oriented, stream or message based, etc.</div><br/></div></div><div id="41563875" class="c"><input type="checkbox" id="c-41563875" checked=""/><div class="controls bullet"><span class="by">iczero</span><span>|</span><a href="#41563054">prev</a><span>|</span><a href="#41562964">next</a><span>|</span><label class="collapse" for="c-41563875">[-]</label><label class="expand" for="c-41563875">[5 more]</label></div><br/><div class="children"><div class="content">Hi, respectfully, you do not appear to understand how networking works.<p>&gt; <a href="https:&#x2F;&#x2F;github.com&#x2F;nyxpsi&#x2F;nyxpsi&#x2F;blob&#x2F;bbe84472aa2f92e1e821039f518a528ce9585937&#x2F;benches&#x2F;network_benchmark.rs#L110">https:&#x2F;&#x2F;github.com&#x2F;nyxpsi&#x2F;nyxpsi&#x2F;blob&#x2F;bbe84472aa2f92e1e82103...</a><p>This is not how you &quot;simulate packet loss&quot;. You are not &quot;dropping TCP packets&quot;. You are never giving your data to the TCP stack in the first place.<p>UDP is incomparable to TCP. Your protocol is incomparable to TCP. Your entire benchmark is misguided and quite frankly irrelevant.<p>As far as I can tell, absolutely no attempt is made whatsoever to retransmit lost packets. Any sporadic failure (for example, wifi dropout for 5 seconds) will result in catastrophic data loss. I do not see any connection logic, so your protocol cannot distinguish between connections other than hoping that ports are never reused.<p>Have you considered spending less time on branding and more time on technical matters? Or was this supposed to be a troll?<p>edit: There&#x27;s no congestion control nor pacing. Every packet is sent as fast as possible. The &quot;protocol&quot; is entirely incapable of streaming operation, and hence message order is not even considered. The entire project is just a thin wrapper over the raptorq crate. Why even bother comparing this to TCP?</div><br/><div id="41564112" class="c"><input type="checkbox" id="c-41564112" checked=""/><div class="controls bullet"><span class="by">acheong08</span><span>|</span><a href="#41563875">parent</a><span>|</span><a href="#41563985">next</a><span>|</span><label class="collapse" for="c-41564112">[-]</label><label class="expand" for="c-41564112">[2 more]</label></div><br/><div class="children"><div class="content">The project seems to have been made for their portfolio rather than any practical purpose (nothing wrong with that). Just a few hundred lines of hard coded server&#x2F;client wrapping around raptorQ</div><br/><div id="41564253" class="c"><input type="checkbox" id="c-41564253" checked=""/><div class="controls bullet"><span class="by">iczero</span><span>|</span><a href="#41563875">root</a><span>|</span><a href="#41564112">parent</a><span>|</span><a href="#41563985">next</a><span>|</span><label class="collapse" for="c-41564253">[-]</label><label class="expand" for="c-41564253">[1 more]</label></div><br/><div class="children"><div class="content">They list their email as:<p>&gt; For more information or to contact us open a PR or email us at nyxpsi@skill-issue.dev<p>This sounds to me like a troll. In any case, I don&#x27;t think blatantly advertising your lack of expertise in networking is a good way of improving one&#x27;s portfolio.</div><br/></div></div></div></div><div id="41563899" class="c"><input type="checkbox" id="c-41563899" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#41563875">parent</a><span>|</span><a href="#41563985">prev</a><span>|</span><a href="#41562964">next</a><span>|</span><label class="collapse" for="c-41563899">[-]</label><label class="expand" for="c-41563899">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m assuming you&#x27;re getting downvoted for your tone, but your technical points are spot on.</div><br/></div></div></div></div><div id="41562964" class="c"><input type="checkbox" id="c-41562964" checked=""/><div class="controls bullet"><span class="by">dools</span><span>|</span><a href="#41563875">prev</a><span>|</span><a href="#41563655">next</a><span>|</span><label class="collapse" for="c-41562964">[-]</label><label class="expand" for="c-41562964">[2 more]</label></div><br/><div class="children"><div class="content">Since it is so stable under lossy conditions it might be a good candidate for VoIP applications. The protocol du jour for VoIP is UDP because you really want to just drop your packets and move on rather than try to retransmit most of the time, but since the transfer speed in this case seems to be immune to the effects of packet loss and it performs just as well as UDP in a 0% packet loss environment it seems like it would produce superior call quality more consistently than either TCP or UDP.</div><br/><div id="41562982" class="c"><input type="checkbox" id="c-41562982" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41562964">parent</a><span>|</span><a href="#41563655">next</a><span>|</span><label class="collapse" for="c-41562982">[-]</label><label class="expand" for="c-41562982">[1 more]</label></div><br/><div class="children"><div class="content">Most VoIP runs on RTP and RTP FEC has existed for a while. <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc5109" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc5109</a> <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8627" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc8627</a></div><br/></div></div></div></div><div id="41563655" class="c"><input type="checkbox" id="c-41563655" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#41562964">prev</a><span>|</span><a href="#41563143">next</a><span>|</span><label class="collapse" for="c-41563655">[-]</label><label class="expand" for="c-41563655">[1 more]</label></div><br/><div class="children"><div class="content">Are we assuming that ~all packet loss is due to the physical medium, and almost none due to congestion?<p>The reason why TCP will usually fall over at high loss rates is because many commonly-used congestion controllers assume that loss is likely due to congestion. If you were to replace the congestion control algorithm with a fixed send window, it&#x27;d do just fine under these conditions, with the caveat that you&#x27;d either end up underutilizing your links, or you&#x27;d run into congestive collapse.<p>I&#x27;m also not at all sure that the benchmark is even measuring what you&#x27;d want to. I cannot see any indications of attempting to retransmit any packets under TCP -- we&#x27;re just sometimes writing the bytes to a socket (and simulating the delay), and declaring that the transfer is incomplete when not all the bytes showed up at the other side? You can see that there&#x27;s something especially fishy in the benchmark results -- the TCP benchmark at 50% loss finishes running in 50% of the time... because you&#x27;re skipping all the logic in those cases.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nyxpsi&#x2F;nyxpsi&#x2F;blob&#x2F;main&#x2F;benches&#x2F;network_benchmark.rs#L110-L112">https:&#x2F;&#x2F;github.com&#x2F;nyxpsi&#x2F;nyxpsi&#x2F;blob&#x2F;main&#x2F;benches&#x2F;network_b...</a><p>Mathis equation suggests that even with 50% packet loss at 1ms RTT, the max achievable TCP [edit: Reno, IIRC] throughput is about 16.5 Mbps.</div><br/></div></div><div id="41563143" class="c"><input type="checkbox" id="c-41563143" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#41563655">prev</a><span>|</span><a href="#41562477">next</a><span>|</span><label class="collapse" for="c-41563143">[-]</label><label class="expand" for="c-41563143">[5 more]</label></div><br/><div class="children"><div class="content">What are the conditions leading to extreme packet loss in layers 2&amp;3 in the first place?<p>I can imagine noisy RF, industrial, congested links, new queueing at the extremes in densely loaded switches, but the thing is: usually out there are strategies to reduce the congestion. External noise, factory&#x2F;industrial&#x2F;adversarial, sure. This is going to exist.</div><br/><div id="41563498" class="c"><input type="checkbox" id="c-41563498" checked=""/><div class="controls bullet"><span class="by">AdamJacobMuller</span><span>|</span><a href="#41563143">parent</a><span>|</span><a href="#41564878">next</a><span>|</span><label class="collapse" for="c-41563498">[-]</label><label class="expand" for="c-41563498">[3 more]</label></div><br/><div class="children"><div class="content">At 0-1%, basically anything.<p>Your wifi and home network probably are closer to 1% than 0%.<p>at 1-10%, you&#x27;re probably on some kind of shared connection (CMTS or GPON with TDMA) and your provider has an overloaded network design (and you&#x27;re at the end of the upgrade&#x2F;split queue).<p>at anything above 10% you&#x27;re in the realm of weird broken stuff. Congestion on the internet between major providers is a thing but is far less common than it was a decade ago, it does still happen though. Major providers who have N<i>ECMP or N</i>LAG links inside their backbones or between providers where one of the links breaks in a way which doesn&#x27;t remove it from the ECMP&#x2F;LAG and suddenly you drop 1&#x2F;N of the traffic (where N might be 2 == 50% loss). More common was finding LAG&#x2F;ECMP where 1&#x2F;N of the links was oversubscribed but the others were fine due to unequal traffic distribution.<p>&gt; noisy RF, industrial<p>Pretty uncommon in my experience as most of these environments are not as cost optimized and know already that they will be in weird RF&#x2F;electrical environments so they just use wired ethernet (and even shielded cable for really janky situations).<p>While there are strategies to reduce congestion on backbone links, they are not commonly implemented and even less commonly implemented well and sometimes implemented intentionally poorly.</div><br/><div id="41563585" class="c"><input type="checkbox" id="c-41563585" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#41563143">root</a><span>|</span><a href="#41563498">parent</a><span>|</span><a href="#41564878">next</a><span>|</span><label class="collapse" for="c-41563585">[-]</label><label class="expand" for="c-41563585">[2 more]</label></div><br/><div class="children"><div class="content">There isn&#x27;t much point in wierd algo solutions to 1% packetloss, and most people are living under 5% most of the time. I would say on an 80&#x2F;20 class decision most of us either have layer2 loss in the link to the provider, and then not much loss, or have some corner case of congestion like zoom inter-continentally.<p>Remember, 75% of content now comes from a DC within 1 AS hop of your ISP.<p>For non-western economies reliant on mobile IP, there is a level of loss and congestion being seen in the radio packet layer but that layer is usually dealing with it.<p>Starlink has worked out how to manage it&#x27;s TCP loss issues despite steering dishy between sats in orbit in a 15 second timeslot model.<p>I&#x27;m not trying to dismiss this work: I don&#x27;t understand the use-case because from my perspective (admittedly in the western economy, but in asia and exposed to the other kind of internet for less developed places) this level of sustained packetloss isn&#x27;t usual, And when it is, the link layer is usually doing something like FEC to take care of it.</div><br/><div id="41563617" class="c"><input type="checkbox" id="c-41563617" checked=""/><div class="controls bullet"><span class="by">AdamJacobMuller</span><span>|</span><a href="#41563143">root</a><span>|</span><a href="#41563585">parent</a><span>|</span><a href="#41564878">next</a><span>|</span><label class="collapse" for="c-41563617">[-]</label><label class="expand" for="c-41563617">[1 more]</label></div><br/><div class="children"><div class="content">I think the use-case for the author is &quot;this is cool&quot; which is the best reason for anything to exist.</div><br/></div></div></div></div></div></div><div id="41564878" class="c"><input type="checkbox" id="c-41564878" checked=""/><div class="controls bullet"><span class="by">vasilvv</span><span>|</span><a href="#41563143">parent</a><span>|</span><a href="#41563498">prev</a><span>|</span><a href="#41562477">next</a><span>|</span><label class="collapse" for="c-41564878">[-]</label><label class="expand" for="c-41564878">[1 more]</label></div><br/><div class="children"><div class="content">Generally, L2 networks are engineered with the assumption that they will carry TCP, and TCP performs really poorly with high loss rates (depends on the specific congestion control used, but the boundary can be anywhere between 1% and 25%), so they try to make sure on L2 level that losses are minimal.  There are some scenarios in which a network can be engineered around high loss rates (e.g. some data center networks), but those don&#x27;t use TCP, at least with traditional loss recovery.<p>Error correction codes on L4 level are generally only useful for very low latency situations, since if you can wait for one RTT, you can just have the original sender retransmit the exact packets that got lost, which is inherently more efficient than any ECC.</div><br/></div></div></div></div><div id="41562477" class="c"><input type="checkbox" id="c-41562477" checked=""/><div class="controls bullet"><span class="by">mmastrac</span><span>|</span><a href="#41563143">prev</a><span>|</span><a href="#41563477">next</a><span>|</span><label class="collapse" for="c-41562477">[-]</label><label class="expand" for="c-41562477">[13 more]</label></div><br/><div class="children"><div class="content">Went looking for fountain codes, was not disappointed [1]. It&#x27;s a shame these have been locked up for so long -- there&#x27;s a lot of network infrastructure that could be improved by them.<p>The patents are hopefully expiring soon.<p>Generic tornado codes are likely patent free, having been expired for a few years now: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tornado_code" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tornado_code</a><p>EDIT: looking a bit deeper into this repo, it&#x27;s really just a wrapper over the raptorq crate with a basic UDP layer on top. Nothing really novel here that I can see over `raptorq` itself.<p>[1] <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;raptorq" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;raptorq</a></div><br/><div id="41562583" class="c"><input type="checkbox" id="c-41562583" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#41562477">parent</a><span>|</span><a href="#41563134">next</a><span>|</span><label class="collapse" for="c-41562583">[-]</label><label class="expand" for="c-41562583">[8 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a lot of network infrastructure that could be improved by them.<p>One killer feature was multicast streaming of data.  The streaming could do an extra 5% of broadcasting packets instead of several round trips and retransmissions.<p>Now that I think about it, I wish we actually used multicast.</div><br/><div id="41562973" class="c"><input type="checkbox" id="c-41562973" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41562477">root</a><span>|</span><a href="#41562583">parent</a><span>|</span><a href="#41562697">next</a><span>|</span><label class="collapse" for="c-41562973">[-]</label><label class="expand" for="c-41562973">[5 more]</label></div><br/><div class="children"><div class="content">The hard part about multicast is the scaling overhead of coordinating which streams should go where when it&#x27;s more than &quot;these couple things on these couple networks&quot;. Even then, the way it&#x27;s a dedicated range of IPs instead of parts of public assignments pretty much shut down the idea it could ever be coordinated at scale outside of a few private networks doing it together.<p>It has found good success in IPTV delivery inside provider&#x27;s own networks though. Cameras at casinos&#x2F;hotels&#x2F;Transit systems and the like too.</div><br/><div id="41563123" class="c"><input type="checkbox" id="c-41563123" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#41562477">root</a><span>|</span><a href="#41562973">parent</a><span>|</span><a href="#41563031">next</a><span>|</span><label class="collapse" for="c-41563123">[-]</label><label class="expand" for="c-41563123">[2 more]</label></div><br/><div class="children"><div class="content">Ipv6 works much better with multicast. I learned about it a few years back and it&#x27;s actually core to the ipv6 protocol. That means all ipv6 routers must support multicast.<p>There&#x27;s 2^112 possible global multicast addresses with ipv6 as well (1). Though yeah, you&#x27;ll still have queuing overloads as well and other issues.<p>1. <a href="https:&#x2F;&#x2F;learningnetwork.cisco.com&#x2F;s&#x2F;question&#x2F;0D53i00000Kt0EKCAZ&#x2F;ipv6-multicast-address-ccna" rel="nofollow">https:&#x2F;&#x2F;learningnetwork.cisco.com&#x2F;s&#x2F;question&#x2F;0D53i00000Kt0EK...</a></div><br/><div id="41563170" class="c"><input type="checkbox" id="c-41563170" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41562477">root</a><span>|</span><a href="#41563123">parent</a><span>|</span><a href="#41563031">next</a><span>|</span><label class="collapse" for="c-41563170">[-]</label><label class="expand" for="c-41563170">[1 more]</label></div><br/><div class="children"><div class="content"><i>all ipv6 routers must support multicast</i><p>That doesn&#x27;t help if all routers have it turned off.</div><br/></div></div></div></div><div id="41563031" class="c"><input type="checkbox" id="c-41563031" checked=""/><div class="controls bullet"><span class="by">xxpor</span><span>|</span><a href="#41562477">root</a><span>|</span><a href="#41562973">parent</a><span>|</span><a href="#41563123">prev</a><span>|</span><a href="#41562697">next</a><span>|</span><label class="collapse" for="c-41563031">[-]</label><label class="expand" for="c-41563031">[2 more]</label></div><br/><div class="children"><div class="content">Copying packets is brutal in software as well.</div><br/><div id="41563053" class="c"><input type="checkbox" id="c-41563053" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41562477">root</a><span>|</span><a href="#41563031">parent</a><span>|</span><a href="#41562697">next</a><span>|</span><label class="collapse" for="c-41563053">[-]</label><label class="expand" for="c-41563053">[1 more]</label></div><br/><div class="children"><div class="content">Pushing packets in software is generally brutal but multicast&#x2F;broadcast should be inherently easier. It&#x27;s less &quot;copy this packet 27 times&quot; and more &quot;instead of receiving 27 packets and sending 27 packets you receive 1 packet and send it 27 times before you remove it from memory&quot;. The &quot;hard&quot; part becomes dealing with the queues filling up because you&#x27;re inherently able to churn out so much more data than you&#x27;re able to receive vs unicast.</div><br/></div></div></div></div></div></div><div id="41562697" class="c"><input type="checkbox" id="c-41562697" checked=""/><div class="controls bullet"><span class="by">ddingus</span><span>|</span><a href="#41562477">root</a><span>|</span><a href="#41562583">parent</a><span>|</span><a href="#41562973">prev</a><span>|</span><a href="#41563134">next</a><span>|</span><label class="collapse" for="c-41562697">[-]</label><label class="expand" for="c-41562697">[2 more]</label></div><br/><div class="children"><div class="content">Me too.<p>SGI had good support for it in IRIX and I am pretty sure I saw one video streaming solution using it on a LAN to maximize the throughput possible.<p>Seems like a good tech that fell into disuse.</div><br/><div id="41562806" class="c"><input type="checkbox" id="c-41562806" checked=""/><div class="controls bullet"><span class="by">vermilingua</span><span>|</span><a href="#41562477">root</a><span>|</span><a href="#41562697">parent</a><span>|</span><a href="#41563134">next</a><span>|</span><label class="collapse" for="c-41562806">[-]</label><label class="expand" for="c-41562806">[1 more]</label></div><br/><div class="children"><div class="content">IP CCTV and IP TV (think hotels) make extensive use of multicast, it&#x27;s not completely disused; but only practical on LAN.</div><br/></div></div></div></div></div></div><div id="41563134" class="c"><input type="checkbox" id="c-41563134" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#41562477">parent</a><span>|</span><a href="#41562583">prev</a><span>|</span><a href="#41563209">next</a><span>|</span><label class="collapse" for="c-41563134">[-]</label><label class="expand" for="c-41563134">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re curious about the RFC IPR: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;ipr&#x2F;2554&#x2F;" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;ipr&#x2F;2554&#x2F;</a></div><br/></div></div><div id="41563209" class="c"><input type="checkbox" id="c-41563209" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#41562477">parent</a><span>|</span><a href="#41563134">prev</a><span>|</span><a href="#41563477">next</a><span>|</span><label class="collapse" for="c-41563209">[-]</label><label class="expand" for="c-41563209">[3 more]</label></div><br/><div class="children"><div class="content">TIL about fountain codes and raptor.  Thanks!<p>I wonder if it opens up new opportunities erasure coding replacements, e.g. RAID for disks, PARQ2 for data recovery, or as Reed-Solomon replacements for comms?</div><br/><div id="41563732" class="c"><input type="checkbox" id="c-41563732" checked=""/><div class="controls bullet"><span class="by">bb88</span><span>|</span><a href="#41562477">root</a><span>|</span><a href="#41563209">parent</a><span>|</span><a href="#41563456">next</a><span>|</span><label class="collapse" for="c-41563732">[-]</label><label class="expand" for="c-41563732">[1 more]</label></div><br/><div class="children"><div class="content">For comms it&#x27;s better since raptorq can generate a large number of symbols.  One use would be a TCP replacement.  If a file can be transmitted in 100 TCP packets, and there&#x27;s 10% loss on the link, then the client needs to retry the lost packets in order.<p>With raptorq, the client needs to receive 102 packets (I believe).  And this can be any combination of original 100 packets and the large number of potential recovery packets.</div><br/></div></div><div id="41563456" class="c"><input type="checkbox" id="c-41563456" checked=""/><div class="controls bullet"><span class="by">nullc</span><span>|</span><a href="#41562477">root</a><span>|</span><a href="#41563209">parent</a><span>|</span><a href="#41563732">prev</a><span>|</span><a href="#41563477">next</a><span>|</span><label class="collapse" for="c-41563456">[-]</label><label class="expand" for="c-41563456">[1 more]</label></div><br/><div class="children"><div class="content">These sorts of codes are not really the thing you want for RAID-N.  They work best with coding groups of thousands of packets or more.<p>For adding redundant blocks to a read-mostly&#x2F;only file (e.g. to correct for sector errors) they could be useful indeed. as that&#x27;s a case where you might have a few dozen correction packets protecting millions.  I&#x27;d really like to see some FS develop support for file protection because on SSDs I&#x27;m seeing a LOT more random sector failures that disk failures.<p>RS codes are optimal for erasures so you really only want to use something else where there are so many packets in the group that RS code performance would be poor... or where a rateless code would be useful.</div><br/></div></div></div></div></div></div><div id="41563477" class="c"><input type="checkbox" id="c-41563477" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#41562477">prev</a><span>|</span><a href="#41563602">next</a><span>|</span><label class="collapse" for="c-41563477">[-]</label><label class="expand" for="c-41563477">[2 more]</label></div><br/><div class="children"><div class="content">What’s the protocol actually?<p>All I can see are hardcoded ping&#x2F;pong “meow” messages going over a hardcoded client and server.<p>But maybe the ping&#x2F;pong is part of the protocol?<p>It’s not clear.<p>Anyway, this redundancy-based protocol doesn’t seem to take into account that too many packets over the network can be a cause of bad, “overloaded” network conditions.<p>Raptorq is a nice addition, though.</div><br/><div id="41563532" class="c"><input type="checkbox" id="c-41563532" checked=""/><div class="controls bullet"><span class="by">daxdev</span><span>|</span><a href="#41563477">parent</a><span>|</span><a href="#41563602">next</a><span>|</span><label class="collapse" for="c-41563532">[-]</label><label class="expand" for="c-41563532">[1 more]</label></div><br/><div class="children"><div class="content">We are getting there, this was hacked together over the weekend. So for now enjoy ur cat sounds. MEOW</div><br/></div></div></div></div><div id="41563602" class="c"><input type="checkbox" id="c-41563602" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41563477">prev</a><span>|</span><a href="#41564334">next</a><span>|</span><label class="collapse" for="c-41563602">[-]</label><label class="expand" for="c-41563602">[3 more]</label></div><br/><div class="children"><div class="content">IIUC this would work well to tunnel the TCP&#x2F;UDP WiFi traffic and cellular traffic over so that you get the advantages without needing to migrate software. But then again FEC is already employed by these (maybe not raptor codes but that’s a relatively simple update). Or does tunneling not work?<p>Is 10% loss common for backbone networks? Maybe if you’re dealing with horribly underprovisioned routers that don’t have enough RAM for how much traffic they’re processing? Not sure otherwise the use case…</div><br/><div id="41563620" class="c"><input type="checkbox" id="c-41563620" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41563602">parent</a><span>|</span><a href="#41564334">next</a><span>|</span><label class="collapse" for="c-41563620">[-]</label><label class="expand" for="c-41563620">[2 more]</label></div><br/><div class="children"><div class="content">I wish many of these protocols would expose non-FEC versions so that the FEC and retry logic could happen at a higher layer.  In particular G.hn powerline is <i>terrible</i> in the implementations I&#x27;ve seen, since it will retransmit infinitely, a sudden loss of bandwidth during a large bulk transfer can increase ping times to over a minute.</div><br/><div id="41565369" class="c"><input type="checkbox" id="c-41565369" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41563602">root</a><span>|</span><a href="#41563620">parent</a><span>|</span><a href="#41564334">next</a><span>|</span><label class="collapse" for="c-41565369">[-]</label><label class="expand" for="c-41565369">[1 more]</label></div><br/><div class="children"><div class="content">I’ve thought about this before since there’s lossy data you can just discard instead of delivering (ie use FEC to recover video and otherwise throw away bad frames).<p>The challenge of course is that this doesn’t work so well:<p>1. Packets come in discrete chunks but FEC works best on a stream of data at the bit level (at least in a transmission context)<p>2. Lossy links will have their own understanding of the PHY that can’t be explained to applications &#x2F; needs to happen much more quickly.<p>3. There’s information that can’t be corrupted in the packet full stop (ie the IP and maybe TCP framing).<p>2 is really the killer - applications can’t respond to noise issues like the MAC can to issues with the WiFi link for example. And higher layers can’t know about all the intermediary hops that might exist and how to characterize that to tune the FEC parameters.<p>3 is also a killer because it means you still need to apply FEC to the PHY to guarantee the framing packet and TCP requires checksums to pass on the packet. It’s really really difficult to use FEC at the application layer in an end to end way. It’s really something that works best at the PHY level for transmissions, at least from the brief time I’ve spent thinking on it. Possible I messed something up in my analysis of course.</div><br/></div></div></div></div></div></div><div id="41564334" class="c"><input type="checkbox" id="c-41564334" checked=""/><div class="controls bullet"><span class="by">nodeshiftcloud</span><span>|</span><a href="#41563602">prev</a><span>|</span><a href="#41562886">next</a><span>|</span><label class="collapse" for="c-41564334">[-]</label><label class="expand" for="c-41564334">[2 more]</label></div><br/><div class="children"><div class="content">Interesting project! It&#x27;s great to see efforts to tackle high packet loss scenarios using fountain codes like RaptorQ. However, the benchmarks could use more clarity. Comparing Nyxpsi to TCP and UDP without considering factors like congestion control, latency, and retransmission strategies might not give a complete picture. It would be helpful to see how Nyxpsi performs under different network conditions, especially with varying latencies and in real-world environments. Also, providing more detailed documentation about the protocol&#x27;s operation and its handling of issues like streaming and congestion control would be beneficial. Looking forward to seeing how this evolves!</div><br/><div id="41564420" class="c"><input type="checkbox" id="c-41564420" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41564334">parent</a><span>|</span><a href="#41562886">next</a><span>|</span><label class="collapse" for="c-41564420">[-]</label><label class="expand" for="c-41564420">[1 more]</label></div><br/><div class="children"><div class="content">AI bros will talk about AI content being indistinguishable from real humans and then post things like this...</div><br/></div></div></div></div><div id="41562886" class="c"><input type="checkbox" id="c-41562886" checked=""/><div class="controls bullet"><span class="by">adamch</span><span>|</span><a href="#41564334">prev</a><span>|</span><a href="#41563749">next</a><span>|</span><label class="collapse" for="c-41562886">[-]</label><label class="expand" for="c-41562886">[6 more]</label></div><br/><div class="children"><div class="content">This is interesting. But how would you use it? You&#x27;d need to open up a new type of socket (neither TCP nor UDP but nyxpsi) and everything along your network route would need to support it. So it wouldn&#x27;t be useful with existing mobile networks (middle boxes won&#x27;t speak the protocol) nor within the data center (because it&#x27;s used for high packet loss situations). So what&#x27;s the use case? Custom wireless networks with embedded devices?</div><br/><div id="41562937" class="c"><input type="checkbox" id="c-41562937" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41562886">parent</a><span>|</span><a href="#41562902">next</a><span>|</span><label class="collapse" for="c-41562937">[-]</label><label class="expand" for="c-41562937">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s using UDP.</div><br/></div></div><div id="41562902" class="c"><input type="checkbox" id="c-41562902" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41562886">parent</a><span>|</span><a href="#41562937">prev</a><span>|</span><a href="#41563749">next</a><span>|</span><label class="collapse" for="c-41562902">[-]</label><label class="expand" for="c-41562902">[3 more]</label></div><br/><div class="children"><div class="content">&gt; middle boxes won&#x27;t speak the protocol<p>Middle boxes only need to speak IP, which they do already, and not block nyxpsi packets (which they probably do).</div><br/><div id="41562939" class="c"><input type="checkbox" id="c-41562939" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41562886">root</a><span>|</span><a href="#41562902">parent</a><span>|</span><a href="#41563749">next</a><span>|</span><label class="collapse" for="c-41562939">[-]</label><label class="expand" for="c-41562939">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll still run into trouble with anything wanting to allow everything but trying to do NAT. I&#x27;d hazard to guess this actually still uses UDP under the covers for that reason (but haven&#x27;t bothered to verify). QUIC and HTTP&#x2F;3 went that route for the same reason.<p>Edit: It does.</div><br/><div id="41563148" class="c"><input type="checkbox" id="c-41563148" checked=""/><div class="controls bullet"><span class="by">wyager</span><span>|</span><a href="#41562886">root</a><span>|</span><a href="#41562939">parent</a><span>|</span><a href="#41563749">next</a><span>|</span><label class="collapse" for="c-41563148">[-]</label><label class="expand" for="c-41563148">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s not really a sufficiently compelling reason to use anything except UDP for future protocols aiming to replace TCP</div><br/></div></div></div></div></div></div></div></div><div id="41562736" class="c"><input type="checkbox" id="c-41562736" checked=""/><div class="controls bullet"><span class="by">rasengan</span><span>|</span><a href="#41563749">prev</a><span>|</span><a href="#41562894">next</a><span>|</span><label class="collapse" for="c-41562736">[-]</label><label class="expand" for="c-41562736">[1 more]</label></div><br/><div class="children"><div class="content">First time I&#x27;m hearing of raptor codes which seems a lot more efficient for this use case which I had until now been using KCP for.</div><br/></div></div><div id="41562894" class="c"><input type="checkbox" id="c-41562894" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41562736">prev</a><span>|</span><a href="#41563595">next</a><span>|</span><label class="collapse" for="c-41562894">[-]</label><label class="expand" for="c-41562894">[1 more]</label></div><br/><div class="children"><div class="content">Re: information sharing by entanglement, CHSH, and the Bell test: 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41480957#41515663">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41480957#41515663</a> :<p>&gt; <i>And all it takes to win the game is to transmit classical bits with digital error correction using hidden variables?</i></div><br/></div></div><div id="41563595" class="c"><input type="checkbox" id="c-41563595" checked=""/><div class="controls bullet"><span class="by">notpushkin</span><span>|</span><a href="#41562894">prev</a><span>|</span><a href="#41562920">next</a><span>|</span><label class="collapse" for="c-41563595">[-]</label><label class="expand" for="c-41563595">[1 more]</label></div><br/><div class="children"><div class="content">Show HN?</div><br/></div></div></div></div></div></div></div></body></html>