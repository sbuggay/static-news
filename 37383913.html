<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693904466104" as="style"/><link rel="stylesheet" href="styles.css?v=1693904466104"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://vgel.me/posts/c500/">Writing a C compiler in 500 lines of Python</a> <span class="domain">(<a href="https://vgel.me">vgel.me</a>)</span></div><div class="subtext"><span>vgel</span> | <span>128 comments</span></div><br/><div><div id="37389310" class="c"><input type="checkbox" id="c-37389310" checked=""/><div class="controls bullet"><span class="by">ak_111</span><span>|</span><a href="#37384209">next</a><span>|</span><label class="collapse" for="c-37389310">[-]</label><label class="expand" for="c-37389310">[4 more]</label></div><br/><div class="children"><div class="content">Somewhat unrelated question, but I think one of the second most difficult things of learning C for coders who are used to scripting languages is to get your head around how the various scaler data types like short, int, long,... (and the unsigned&#x2F;hex version of each) are represented and how they relate to each other and how they relate to the platform.<p>I am wondering if this complexity exists due to historical reasons, in other words if you were to invent C today you would just define int as always being 32, long as 64 and provide much more sane and well-defined rules on how the various datatypes relate to each other, without losing anything of what makes C a popular low-level language?</div><br/><div id="37389359" class="c"><input type="checkbox" id="c-37389359" checked=""/><div class="controls bullet"><span class="by">ricardo81</span><span>|</span><a href="#37389310">parent</a><span>|</span><a href="#37389409">next</a><span>|</span><label class="collapse" for="c-37389359">[-]</label><label class="expand" for="c-37389359">[1 more]</label></div><br/><div class="children"><div class="content">I learnt C about a decade ago (after using scriping languages 10 years prior) and just stuck with using the uint values, no second thoughts about how big a uint32_t is.</div><br/></div></div><div id="37389409" class="c"><input type="checkbox" id="c-37389409" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#37389310">parent</a><span>|</span><a href="#37389359">prev</a><span>|</span><a href="#37389323">next</a><span>|</span><label class="collapse" for="c-37389409">[-]</label><label class="expand" for="c-37389409">[1 more]</label></div><br/><div class="children"><div class="content">&gt;if you were to invent C today you would just define int as always being 32, long as 64 and provide much more sane and well-defined rules on how the various datatypes relate to each other, without losing anything of what makes C a popular low-level language?<p>You&#x27;d lose something because those decisions would be impractical for 8-bit and 16-bit targets (which still exist in the world of embedded programming).</div><br/></div></div><div id="37389323" class="c"><input type="checkbox" id="c-37389323" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#37389310">parent</a><span>|</span><a href="#37389409">prev</a><span>|</span><a href="#37384209">next</a><span>|</span><label class="collapse" for="c-37389323">[-]</label><label class="expand" for="c-37389323">[1 more]</label></div><br/><div class="children"><div class="content">If we were to write C today, we would never have such cases.</div><br/></div></div></div></div><div id="37384209" class="c"><input type="checkbox" id="c-37384209" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#37389310">prev</a><span>|</span><a href="#37384279">next</a><span>|</span><label class="collapse" for="c-37384209">[-]</label><label class="expand" for="c-37384209">[19 more]</label></div><br/><div class="children"><div class="content">&gt; Instead, we&#x27;ll be single-pass: code generation happens during parsing<p>IIRC, C was specifically designed to allow single-pass compilation, right? I.e. in many languages you don&#x27;t know what needs to be output without parsing the full AST, but in C, syntax directly implies semantics. I think I remember hearing this was because early computers couldn&#x27;t necessarily fit the AST for an entire code file in memory at once</div><br/><div id="37384340" class="c"><input type="checkbox" id="c-37384340" checked=""/><div class="controls bullet"><span class="by">speps</span><span>|</span><a href="#37384209">parent</a><span>|</span><a href="#37385238">next</a><span>|</span><label class="collapse" for="c-37384340">[-]</label><label class="expand" for="c-37384340">[9 more]</label></div><br/><div class="children"><div class="content">Linked from another thread: <a href="http:&#x2F;&#x2F;cm.bell-labs.co&#x2F;who&#x2F;dmr&#x2F;chist.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;cm.bell-labs.co&#x2F;who&#x2F;dmr&#x2F;chist.html</a><p>It explains the memory limits and what happened :)<p>&gt; After the TMG version of B was working, Thompson rewrote B in itself (a bootstrapping step). During development, he continually struggled against memory limitations: each language addition inflated the compiler so it could barely fit, but each rewrite taking advantage of the feature reduced its size. For example, B introduced generalized assignment operators, using x=+y to add y to x. The notation came from Algol 68 [Wijngaarden 75] via McIlroy, who had incorporated it into his version of TMG. (In B and early C, the operator was spelled =+ instead of += ; this mistake, repaired in 1976, was induced by a seductively easy way of handling the first form in B&#x27;s lexical analyzer.)</div><br/><div id="37385404" class="c"><input type="checkbox" id="c-37385404" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37384340">parent</a><span>|</span><a href="#37387611">next</a><span>|</span><label class="collapse" for="c-37385404">[-]</label><label class="expand" for="c-37385404">[7 more]</label></div><br/><div class="children"><div class="content">I wonder why =+ is so obviously a mistake. It does look vaguely wrong for some reason, but I’m prejudiced by current languages.</div><br/><div id="37389182" class="c"><input type="checkbox" id="c-37389182" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37385404">parent</a><span>|</span><a href="#37385430">next</a><span>|</span><label class="collapse" for="c-37389182">[-]</label><label class="expand" for="c-37389182">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>I wonder why =+ is so obviously a mistake</i><p>Consider<p><pre><code>  x = -5
</code></pre>
now how about:<p><pre><code>  x =- 5
</code></pre>
One makes x negative 5, the other subtracts 5 from it. And under this design of the operator the only difference is a space.<p>It&#x27;s the same with +, just that we&#x27;re not used to seeing unary plus in the wild.</div><br/></div></div><div id="37385430" class="c"><input type="checkbox" id="c-37385430" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37385404">parent</a><span>|</span><a href="#37389182">prev</a><span>|</span><a href="#37387611">next</a><span>|</span><label class="collapse" for="c-37385430">[-]</label><label class="expand" for="c-37385430">[5 more]</label></div><br/><div class="children"><div class="content">I think because it&#x27;s ambiguous with unary plus (a = +b), since C isn&#x27;t supposed to have significant whitespace in most circumstances.</div><br/><div id="37385601" class="c"><input type="checkbox" id="c-37385601" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37385430">parent</a><span>|</span><a href="#37387611">next</a><span>|</span><label class="collapse" for="c-37385601">[-]</label><label class="expand" for="c-37385601">[4 more]</label></div><br/><div class="children"><div class="content">You also run into problems with a=*p and a=-b, which are perhaps more likely.</div><br/><div id="37385806" class="c"><input type="checkbox" id="c-37385806" checked=""/><div class="controls bullet"><span class="by">zeusk</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37385601">parent</a><span>|</span><a href="#37387611">next</a><span>|</span><label class="collapse" for="c-37385806">[-]</label><label class="expand" for="c-37385806">[3 more]</label></div><br/><div class="children"><div class="content">But they could&#x27;ve fixed that by going a=(*p) and a=(-b);<p>Kind of how we use (*p)-&gt;next instead of *p-&gt;next where p is node_t**</div><br/><div id="37386905" class="c"><input type="checkbox" id="c-37386905" checked=""/><div class="controls bullet"><span class="by">kdmccormick</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37385806">parent</a><span>|</span><a href="#37387611">next</a><span>|</span><label class="collapse" for="c-37386905">[-]</label><label class="expand" for="c-37386905">[2 more]</label></div><br/><div class="children"><div class="content">That seems a little backwards and barbaric, though right?<p>Imagine if we had to watch out for this as a common pitfall:<p><pre><code>    &#x2F;&#x2F; BUG! Actually subtracts x from current val of neg_x.
    neg_x = -x;
</code></pre>
Even moreso, how would these two lines behave? Would they differ in semantics?<p><pre><code>    n = -5
    n =- 5
</code></pre>
Overall, -= is just so much less ambiguous.<p>EDIT: To your point about -&gt;, I personally think C would be better if:<p><pre><code>    *p-&gt;next
</code></pre>
parsed as:<p><pre><code>    (*p)-&gt;next
</code></pre>
instead of:<p><pre><code>    *(p-&gt;next)
</code></pre>
but maybe now <i>I&#x27;m</i> not thinking through all the parsing impliciations :)</div><br/><div id="37387130" class="c"><input type="checkbox" id="c-37387130" checked=""/><div class="controls bullet"><span class="by">zeusk</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37386905">parent</a><span>|</span><a href="#37387611">next</a><span>|</span><label class="collapse" for="c-37387130">[-]</label><label class="expand" for="c-37387130">[1 more]</label></div><br/><div class="children"><div class="content">As you note in your edit; we already have to watch for that pitfall :)<p>so really the best way out is to be as verbose as possible imo; a = a + c or auto nodep = *nodepp; nodep-&gt;next;<p>Compilers and compute performance have grown to make the difference negligible for code output and compilation times but they definitely take a lot of mental complexity out of such scenarios (anything helps when grokking 10k+ lines of code).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37387611" class="c"><input type="checkbox" id="c-37387611" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37384340">parent</a><span>|</span><a href="#37385404">prev</a><span>|</span><a href="#37385238">next</a><span>|</span><label class="collapse" for="c-37387611">[-]</label><label class="expand" for="c-37387611">[1 more]</label></div><br/><div class="children"><div class="content">Infix parsing chews up a remarkable amount code and memory.<p>It&#x27;s scary just how much easier it is to parse languages without infix parsing.</div><br/></div></div></div></div><div id="37385238" class="c"><input type="checkbox" id="c-37385238" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#37384209">parent</a><span>|</span><a href="#37384340">prev</a><span>|</span><a href="#37385150">next</a><span>|</span><label class="collapse" for="c-37385238">[-]</label><label class="expand" for="c-37385238">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re exactly right. This makes for a small, memory-efficient compiler. But this entails a lot of compromises that we&#x27;re not willing to put up with anymore, because there&#x27;s no longer a reason to.</div><br/></div></div><div id="37385150" class="c"><input type="checkbox" id="c-37385150" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37384209">parent</a><span>|</span><a href="#37385238">prev</a><span>|</span><a href="#37384561">next</a><span>|</span><label class="collapse" for="c-37385150">[-]</label><label class="expand" for="c-37385150">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure, haven&#x27;t looked at the codebases of old compilers in a long time. Definitely a lot of the language is pretty amenable to it, especially if you have unstructured jumps for e.g. the for advancement statement. I had a distinct feeling while writing the compiler every time I added a new feature that &quot;wow, the semantics work exactly how I&#x27;d like them to for ease of implementation.&quot;<p>Compare that to, say, Rust, which would be pretty painful to single-pass compile with all the non-local behavior around traits.</div><br/><div id="37387352" class="c"><input type="checkbox" id="c-37387352" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37385150">parent</a><span>|</span><a href="#37385222">next</a><span>|</span><label class="collapse" for="c-37387352">[-]</label><label class="expand" for="c-37387352">[1 more]</label></div><br/><div class="children"><div class="content">What you are saying is true for a naive C compiler.<p>Once you want to optimize or analyse, things become more complicated.<p>&gt; Compare that to, say, Rust, which would be pretty painful to single-pass compile with all the non-local behavior around traits.<p>Type inference also spans a whole function, so you can&#x27;t do it in a single pass through the code.  (But it&#x27;s still tamer than in eg Haskell, where type inference considers your whole program.)</div><br/></div></div></div></div><div id="37384561" class="c"><input type="checkbox" id="c-37384561" checked=""/><div class="controls bullet"><span class="by">frutiger</span><span>|</span><a href="#37384209">parent</a><span>|</span><a href="#37385150">prev</a><span>|</span><a href="#37384445">next</a><span>|</span><label class="collapse" for="c-37384561">[-]</label><label class="expand" for="c-37384561">[1 more]</label></div><br/><div class="children"><div class="content">I once read that this is why the MSVC compiler didn&#x27;t support two-pass template instantiation until very recently: the original compiler implemented templates almost like a macro that re-emitted a stream of tokens with the template parameters replaced.</div><br/></div></div><div id="37384445" class="c"><input type="checkbox" id="c-37384445" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#37384209">parent</a><span>|</span><a href="#37384561">prev</a><span>|</span><a href="#37384279">next</a><span>|</span><label class="collapse" for="c-37384445">[-]</label><label class="expand" for="c-37384445">[4 more]</label></div><br/><div class="children"><div class="content">using recursive descent, you don&#x27;t need to build an ast</div><br/><div id="37384640" class="c"><input type="checkbox" id="c-37384640" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37384445">parent</a><span>|</span><a href="#37388461">next</a><span>|</span><label class="collapse" for="c-37384640">[-]</label><label class="expand" for="c-37384640">[2 more]</label></div><br/><div class="children"><div class="content">the call stack during recursive descent is an ephemeral ast, for the recursive descent parsers I&#x27;ve written.</div><br/><div id="37386061" class="c"><input type="checkbox" id="c-37386061" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37384640">parent</a><span>|</span><a href="#37388461">next</a><span>|</span><label class="collapse" for="c-37386061">[-]</label><label class="expand" for="c-37386061">[1 more]</label></div><br/><div class="children"><div class="content">That implies the memory usage is proportional to the depth of the AST, not the total size (which is the point, I think).</div><br/></div></div></div></div><div id="37388461" class="c"><input type="checkbox" id="c-37388461" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37384209">root</a><span>|</span><a href="#37384445">parent</a><span>|</span><a href="#37384640">prev</a><span>|</span><a href="#37384279">next</a><span>|</span><label class="collapse" for="c-37388461">[-]</label><label class="expand" for="c-37388461">[1 more]</label></div><br/><div class="children"><div class="content">Only if the compiler doesn&#x27;t do anything beyond basic peephole optimizations.</div><br/></div></div></div></div></div></div><div id="37384279" class="c"><input type="checkbox" id="c-37384279" checked=""/><div class="controls bullet"><span class="by">mati365</span><span>|</span><a href="#37384209">prev</a><span>|</span><a href="#37384140">next</a><span>|</span><label class="collapse" for="c-37384279">[-]</label><label class="expand" for="c-37384279">[3 more]</label></div><br/><div class="children"><div class="content">I made similar project in TypeScript[1]. Basically multipass compiler that generates x86 assembly, compiles it to binary and runs it. The worst thing were register allocator, designing IR code and assembler.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;Mati365&#x2F;ts-c-compiler">https:&#x2F;&#x2F;github.com&#x2F;Mati365&#x2F;ts-c-compiler</a></div><br/><div id="37385157" class="c"><input type="checkbox" id="c-37385157" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37384279">parent</a><span>|</span><a href="#37385501">next</a><span>|</span><label class="collapse" for="c-37385157">[-]</label><label class="expand" for="c-37385157">[1 more]</label></div><br/><div class="children"><div class="content">Ooh, this is cool! Using WASM let me avoid writing a register allocator (though I probably would have just used the stack if I had targeted x86&#x2F;ARM since I wasn&#x27;t going for speed).</div><br/></div></div><div id="37385501" class="c"><input type="checkbox" id="c-37385501" checked=""/><div class="controls bullet"><span class="by">amedvednikov</span><span>|</span><a href="#37384279">parent</a><span>|</span><a href="#37385157">prev</a><span>|</span><a href="#37384140">next</a><span>|</span><label class="collapse" for="c-37385501">[-]</label><label class="expand" for="c-37385501">[1 more]</label></div><br/><div class="children"><div class="content">Nice project!</div><br/></div></div></div></div><div id="37384140" class="c"><input type="checkbox" id="c-37384140" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#37384279">prev</a><span>|</span><a href="#37384283">next</a><span>|</span><label class="collapse" for="c-37384140">[-]</label><label class="expand" for="c-37384140">[1 more]</label></div><br/><div class="children"><div class="content">A time-honored approach!<p><a href="https:&#x2F;&#x2F;www.blackhat.com&#x2F;presentations&#x2F;win-usa-04&#x2F;bh-win-04-aitel.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.blackhat.com&#x2F;presentations&#x2F;win-usa-04&#x2F;bh-win-04-...</a><p>(minus directly emitting opcodes, and fitting into 500 lines, of course.)</div><br/></div></div><div id="37384283" class="c"><input type="checkbox" id="c-37384283" checked=""/><div class="controls bullet"><span class="by">kaycebasques</span><span>|</span><a href="#37384140">prev</a><span>|</span><a href="#37385280">next</a><span>|</span><label class="collapse" for="c-37384283">[-]</label><label class="expand" for="c-37384283">[3 more]</label></div><br/><div class="children"><div class="content">Is there a C compiler written in Python that aims for maximum readability rather than trying to get as much done under X lines of code?</div><br/><div id="37385202" class="c"><input type="checkbox" id="c-37385202" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37384283">parent</a><span>|</span><a href="#37385093">next</a><span>|</span><label class="collapse" for="c-37385202">[-]</label><label class="expand" for="c-37385202">[1 more]</label></div><br/><div class="children"><div class="content">I think the code is fairly readable! It&#x27;s formatted with Black (and therefore limited to reasonable line lengths) and well-commented.<p>IMO, being under X lines of code is <i>part of</i> the readability—10,000 lines of code is hard to approach no matter how readable it otherwise is.</div><br/></div></div><div id="37385093" class="c"><input type="checkbox" id="c-37385093" checked=""/><div class="controls bullet"><span class="by">muth02446</span><span>|</span><a href="#37384283">parent</a><span>|</span><a href="#37385202">prev</a><span>|</span><a href="#37385280">next</a><span>|</span><label class="collapse" for="c-37385093">[-]</label><label class="expand" for="c-37385093">[1 more]</label></div><br/><div class="children"><div class="content">Not quite a C compiler but arguably better:<p><a href="http:&#x2F;&#x2F;cwerg.org" rel="nofollow noreferrer">http:&#x2F;&#x2F;cwerg.org</a></div><br/></div></div></div></div><div id="37385280" class="c"><input type="checkbox" id="c-37385280" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#37384283">prev</a><span>|</span><a href="#37386268">next</a><span>|</span><label class="collapse" for="c-37385280">[-]</label><label class="expand" for="c-37385280">[13 more]</label></div><br/><div class="children"><div class="content">This looks a lot like the Tiny Pascal compiler that BYTE published a listing of back in 1978.<p><a href="http:&#x2F;&#x2F;www.trs-80.org&#x2F;tiny-pascal&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.trs-80.org&#x2F;tiny-pascal&#x2F;</a><p>I figured out the basics of how a compiler works by going through it line by line.</div><br/><div id="37385328" class="c"><input type="checkbox" id="c-37385328" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37385280">parent</a><span>|</span><a href="#37385334">next</a><span>|</span><label class="collapse" for="c-37385328">[-]</label><label class="expand" for="c-37385328">[1 more]</label></div><br/><div class="children"><div class="content">Oh, that&#x27;s neat (funny that they skipped out on similar things to me, like GOTO and structs :-)<p>I didn&#x27;t see a link to the source in the article, but this seems to be it: <a href="https:&#x2F;&#x2F;sourceforge.net&#x2F;p&#x2F;tiny-pascal&#x2F;code&#x2F;HEAD&#x2F;tree&#x2F;NorthStar%20Horizon&#x2F;pascomp.bas" rel="nofollow noreferrer">https:&#x2F;&#x2F;sourceforge.net&#x2F;p&#x2F;tiny-pascal&#x2F;code&#x2F;HEAD&#x2F;tree&#x2F;NorthSt...</a></div><br/></div></div><div id="37385334" class="c"><input type="checkbox" id="c-37385334" checked=""/><div class="controls bullet"><span class="by">dugmartin</span><span>|</span><a href="#37385280">parent</a><span>|</span><a href="#37385328">prev</a><span>|</span><a href="#37389190">next</a><span>|</span><label class="collapse" for="c-37385334">[-]</label><label class="expand" for="c-37385334">[10 more]</label></div><br/><div class="children"><div class="content">I think Borland’s Turbo Pascal was also a single pass compiler that emitted machine code as COM files.</div><br/><div id="37388581" class="c"><input type="checkbox" id="c-37388581" checked=""/><div class="controls bullet"><span class="by">bemmu</span><span>|</span><a href="#37385280">root</a><span>|</span><a href="#37385334">parent</a><span>|</span><a href="#37385459">next</a><span>|</span><label class="collapse" for="c-37388581">[-]</label><label class="expand" for="c-37388581">[3 more]</label></div><br/><div class="children"><div class="content">It makes development so much more fun when you see the results right away.<p>Pressing &quot;build&quot; in Turbo Pascal on my 386sx it was already done before you could even perceive any delay. Instant.</div><br/><div id="37388985" class="c"><input type="checkbox" id="c-37388985" checked=""/><div class="controls bullet"><span class="by">pantulis</span><span>|</span><a href="#37385280">root</a><span>|</span><a href="#37388581">parent</a><span>|</span><a href="#37385459">next</a><span>|</span><label class="collapse" for="c-37388985">[-]</label><label class="expand" for="c-37388985">[2 more]</label></div><br/><div class="children"><div class="content">I think Turbo Pascal had the capability of generating code directly to memory without generating disk files.</div><br/><div id="37389148" class="c"><input type="checkbox" id="c-37389148" checked=""/><div class="controls bullet"><span class="by">ForOldHack</span><span>|</span><a href="#37385280">root</a><span>|</span><a href="#37388985">parent</a><span>|</span><a href="#37385459">next</a><span>|</span><label class="collapse" for="c-37389148">[-]</label><label class="expand" for="c-37389148">[1 more]</label></div><br/><div class="children"><div class="content">It did that on floppy based systems too. The &#x27;87 equipped pcs in the physics building were much faster at  4500 line project, which I worked on for a year. So... First thing to test on a new 33Mhz 386 w&#x2F; wolf3d (install only, no source) my project loaded and 33mhz itt 387. Less than 2 seconds. If you brought everything into the ide,and hit run... It screamed.</div><br/></div></div></div></div></div></div><div id="37385459" class="c"><input type="checkbox" id="c-37385459" checked=""/><div class="controls bullet"><span class="by">kwhitefoot</span><span>|</span><a href="#37385280">root</a><span>|</span><a href="#37385334">parent</a><span>|</span><a href="#37388581">prev</a><span>|</span><a href="#37389190">next</a><span>|</span><label class="collapse" for="c-37385459">[-]</label><label class="expand" for="c-37385459">[6 more]</label></div><br/><div class="children"><div class="content">Surely it is a feature of all Pascal compilers that they are single pass.  I thought that it was part of the specification of the language that it be possible to compile in a single pass.</div><br/><div id="37387799" class="c"><input type="checkbox" id="c-37387799" checked=""/><div class="controls bullet"><span class="by">drewolbrich</span><span>|</span><a href="#37385280">root</a><span>|</span><a href="#37385459">parent</a><span>|</span><a href="#37388425">next</a><span>|</span><label class="collapse" for="c-37387799">[-]</label><label class="expand" for="c-37387799">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s disturbing to me that I remembered this, but the IBM Pascal Compiler for DOS (1981) had two passes. 
<a href="https:&#x2F;&#x2F;winworldpc.com&#x2F;product&#x2F;ibm-pascal-compiler&#x2F;100" rel="nofollow noreferrer">https:&#x2F;&#x2F;winworldpc.com&#x2F;product&#x2F;ibm-pascal-compiler&#x2F;100</a></div><br/></div></div><div id="37388425" class="c"><input type="checkbox" id="c-37388425" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37385280">root</a><span>|</span><a href="#37385459">parent</a><span>|</span><a href="#37387799">prev</a><span>|</span><a href="#37387331">next</a><span>|</span><label class="collapse" for="c-37388425">[-]</label><label class="expand" for="c-37388425">[1 more]</label></div><br/><div class="children"><div class="content">Not all, although the language was designed that way.<p>Some dialects and optimising compilers, had multiple passes.</div><br/></div></div><div id="37387331" class="c"><input type="checkbox" id="c-37387331" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37385280">root</a><span>|</span><a href="#37385459">parent</a><span>|</span><a href="#37388425">prev</a><span>|</span><a href="#37385465">next</a><span>|</span><label class="collapse" for="c-37387331">[-]</label><label class="expand" for="c-37387331">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a bunch of LLVM-based Pascal compilers these days.  I doubt they are single pass, given how LLVM works.  (And in general, any optimizing compiler is most likely doing multiple passes.)<p>You are right about Pascal&#x27;s original design.  Though I&#x27;m not sure if that&#x27;s still true about modern versions of the language?</div><br/><div id="37388443" class="c"><input type="checkbox" id="c-37388443" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37385280">root</a><span>|</span><a href="#37387331">parent</a><span>|</span><a href="#37385465">next</a><span>|</span><label class="collapse" for="c-37388443">[-]</label><label class="expand" for="c-37388443">[1 more]</label></div><br/><div class="children"><div class="content">Not even old ones, if we taken optimising compilers like VMS Pascal into account.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37386268" class="c"><input type="checkbox" id="c-37386268" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#37385280">prev</a><span>|</span><a href="#37384275">next</a><span>|</span><label class="collapse" for="c-37386268">[-]</label><label class="expand" for="c-37386268">[20 more]</label></div><br/><div class="children"><div class="content">Writing your own compiler<p>- demystifies compilers, interpreters, linkers&#x2F;loaders and related systems software, which you now understand. This understanding will no doubt one day help in your debugging efforts;<p>- elevates you to become a higher level developer: you are now a tool smith who can make their own language if needed (e.g. to create domain specific languages embedded in larger systems you architect).<p>So congratulations, on top of other forms of abstraction, you have mastered meta-linguistic abstraction (see the latter part of Structure and Interpretation of Computer Programs, preferably the 1st or 2nd ed.).</div><br/><div id="37386984" class="c"><input type="checkbox" id="c-37386984" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#37386268">parent</a><span>|</span><a href="#37386641">next</a><span>|</span><label class="collapse" for="c-37386984">[-]</label><label class="expand" for="c-37386984">[14 more]</label></div><br/><div class="children"><div class="content">I dunno. I did a compiler writing course once, writing a compiler for a subset of Pascal in Ada, generating a kind of quasi assembly. It was a team project. I did most of the codegen and static optimisation.<p>It was super fun and interesting. But I wouldn&#x27;t say it was a terribly useful exercise that has greatly enriched me as a programmer.<p>And somehow I have ended up with a very strong bias against DSLs.</div><br/><div id="37389012" class="c"><input type="checkbox" id="c-37389012" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37386984">parent</a><span>|</span><a href="#37388183">next</a><span>|</span><label class="collapse" for="c-37389012">[-]</label><label class="expand" for="c-37389012">[1 more]</label></div><br/><div class="children"><div class="content">I wrote so many compilers and interpreters in my life, simply because I cannot stand the long compile times and waiting while developing. Only single pass to make it as fast as possible, foregoing many optimisations (I don’t need them during dev); I wrote them for parts (so basically dsls which are compatible with the original compiler of the respective language) of c++, Java, c#, typescript etc. It gave us a competitive advantage as others were waiting for builds. Then I went back to Lisp (sbcl) and found it to be perfect; instant feedback, high performance, trivial to make dsls.</div><br/></div></div><div id="37388183" class="c"><input type="checkbox" id="c-37388183" checked=""/><div class="controls bullet"><span class="by">dragonelite</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37386984">parent</a><span>|</span><a href="#37389012">prev</a><span>|</span><a href="#37387368">next</a><span>|</span><label class="collapse" for="c-37388183">[-]</label><label class="expand" for="c-37388183">[2 more]</label></div><br/><div class="children"><div class="content">I thought the same when i did compiler course, but 8 years after that course i wrote tooling to mass refactor a java codebase by creating AST manipulate AST and convert the AST to code again.</div><br/><div id="37388409" class="c"><input type="checkbox" id="c-37388409" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37388183">parent</a><span>|</span><a href="#37387368">next</a><span>|</span><label class="collapse" for="c-37388409">[-]</label><label class="expand" for="c-37388409">[1 more]</label></div><br/><div class="children"><div class="content">Oh, yeah, true. I have done a couple of pretty complex things that involved parsing code or manipulating ASTs and it was probably useful for that.<p>I attempted to write a parser for Wikitext once in ANTLR which was an interesting nightmare.</div><br/></div></div></div></div><div id="37387368" class="c"><input type="checkbox" id="c-37387368" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37386984">parent</a><span>|</span><a href="#37388183">prev</a><span>|</span><a href="#37387714">next</a><span>|</span><label class="collapse" for="c-37387368">[-]</label><label class="expand" for="c-37387368">[6 more]</label></div><br/><div class="children"><div class="content">&gt; And somehow I have ended up with a very strong bias against DSLs.<p>Most DSLs are bad, partially because most people are bad at designing languages.<p>Embedded DSLs can be quite neat.  Eg Haskell makes it easy to embed something like DSLs inside your Haskell code.<p>(If you squint a bit, the ability to define your own functions in any language goes in that direction of allowing you to define your own mini-sub-language that handles your problem better.  Haskell (and the Lisps) just dial that kind of approach up to 11.)</div><br/><div id="37387411" class="c"><input type="checkbox" id="c-37387411" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37387368">parent</a><span>|</span><a href="#37388170">next</a><span>|</span><label class="collapse" for="c-37387411">[-]</label><label class="expand" for="c-37387411">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t necessarily think the DSLs are badly designed. But personally I find the overhead in learning and remembering a new language to be enormous. I instantly drop from extremely high productivity in my language of choice to fumbling around like a newbie. And often DSLs are used for smallish tasks that you work on, write the code, then leave for a long time. Then you come back to it and have no idea how that language worked, its pecularities, etc.<p>It had better have an extremely high payoff to justify that cost.</div><br/><div id="37388359" class="c"><input type="checkbox" id="c-37388359" checked=""/><div class="controls bullet"><span class="by">extr</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37387411">parent</a><span>|</span><a href="#37387500">next</a><span>|</span><label class="collapse" for="c-37388359">[-]</label><label class="expand" for="c-37388359">[1 more]</label></div><br/><div class="children"><div class="content">The issue is that a good DSL shouldn&#x27;t be a &quot;language&quot;, it should be a tool, a textual UI that is designed by and for power users for a particular task. When you are doing something 500 times a day you want a hyper efficient tool to accomplish that. Learning curve is irrelevant, only efficiency and expressibility. A DSL is a great fit. If you are doing some task once a month you just want something simple you can wrap your head around quickly. The problem is that the former often forget that the latter exists and so recommend their workflow to everyone, forgetting they have different needs. But both sets of needs are valid.</div><br/></div></div><div id="37387500" class="c"><input type="checkbox" id="c-37387500" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37387411">parent</a><span>|</span><a href="#37388359">prev</a><span>|</span><a href="#37388170">next</a><span>|</span><label class="collapse" for="c-37387500">[-]</label><label class="expand" for="c-37387500">[2 more]</label></div><br/><div class="children"><div class="content">Embedded DSLs have much lower learning overhead, since they are just embedded in the language you are already using.  Eg in Haskell, they are still valid Haskell programs.  So they eg inherit the control structures from the host language, and most of the tooling in your editor, like &#x27;jump to definition&#x27; also still works.<p>See <a href="http:&#x2F;&#x2F;wiki.haskell.org&#x2F;Embedded_domain_specific_language" rel="nofollow noreferrer">http:&#x2F;&#x2F;wiki.haskell.org&#x2F;Embedded_domain_specific_language</a><p>Because the overheads are lower, the payoff doesn&#x27;t have to be as high to make it worthwhile.<p>(However, there&#x27;s still some overhead, otherwise you wouldn&#x27;t really label them as embedded-DSLs.)</div><br/><div id="37387656" class="c"><input type="checkbox" id="c-37387656" checked=""/><div class="controls bullet"><span class="by">stevage</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37387500">parent</a><span>|</span><a href="#37388170">next</a><span>|</span><label class="collapse" for="c-37387656">[-]</label><label class="expand" for="c-37387656">[1 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t really aware of the embedded DSL distinction.<p>But even then. I was never really able to get into Observable because although it looks like JavaScript, there are kind of hidden objects and methods available to you that I found weirdly hard to discover.</div><br/></div></div></div></div></div></div><div id="37388170" class="c"><input type="checkbox" id="c-37388170" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37387368">parent</a><span>|</span><a href="#37387411">prev</a><span>|</span><a href="#37387714">next</a><span>|</span><label class="collapse" for="c-37388170">[-]</label><label class="expand" for="c-37388170">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Most DSLs are bad, partially because most people are bad at designing languages.<p>A perfectly-designed DSL is still bad just because it&#x27;s a whole &#x27;nother language for you to build, and for others to learn, that probably isn&#x27;t needed for whatever project.</div><br/></div></div></div></div><div id="37387714" class="c"><input type="checkbox" id="c-37387714" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37386984">parent</a><span>|</span><a href="#37387368">prev</a><span>|</span><a href="#37386641">next</a><span>|</span><label class="collapse" for="c-37387714">[-]</label><label class="expand" for="c-37387714">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, nowadays a DSL is almost never a good idea. A library for some pre-existing flexible language can do the job without reinventing a whole lot of wheels. The most specific languages I can think of that make sense are SQL and Solidity.<p>But DSLs are tempting, especially among the more passionate programmers, so at work we&#x27;ve ended up with a lot of them. All of them are tripping hazards.</div><br/><div id="37389291" class="c"><input type="checkbox" id="c-37389291" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37387714">parent</a><span>|</span><a href="#37388873">next</a><span>|</span><label class="collapse" for="c-37389291">[-]</label><label class="expand" for="c-37389291">[1 more]</label></div><br/><div class="children"><div class="content">DSLs are awesome for what they are. DSLs let you ingest&#x2F;load untrusted user code directly <i>and</i> have strong isolation barrier, allowing for very powerful user customizations with &quot;native&quot; implementations of certain features &#x2F;functions.<p>Anything from programmable authorization to custom views becomes safely and relatively easily available. Say what you want about ESB pattern, but you can implement ESB transformers in a custom DSL.<p>Obviously not every piece of software needs these features, but when it does DSLs are very handy.</div><br/></div></div><div id="37388873" class="c"><input type="checkbox" id="c-37388873" checked=""/><div class="controls bullet"><span class="by">wolletd</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37387714">parent</a><span>|</span><a href="#37389291">prev</a><span>|</span><a href="#37386641">next</a><span>|</span><label class="collapse" for="c-37388873">[-]</label><label class="expand" for="c-37388873">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m wondering, is Bash&#x2F;Shell a DSL?<p>You can do anything with it because it allows launching other programs, but I&#x27;d say it was designed specifically for the domain of launching other programs and building data pipelines with their in- and outputs.</div><br/><div id="37389349" class="c"><input type="checkbox" id="c-37389349" checked=""/><div class="controls bullet"><span class="by">friendzis</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37388873">parent</a><span>|</span><a href="#37386641">next</a><span>|</span><label class="collapse" for="c-37389349">[-]</label><label class="expand" for="c-37389349">[1 more]</label></div><br/><div class="children"><div class="content">While DSLs are primarily designed to easily express certain idioms (e.g. Logo-family primarily describes pencil movement), generally (!), DSL is embeddable, isolated, Turing incomplete language. Although some DSLs are Turing complete, they are first and foremost designed to express domain specific idioms.<p>IMO Bash and friends are too powerful and generic to be considered DSLs.</div><br/></div></div></div></div></div></div></div></div><div id="37386641" class="c"><input type="checkbox" id="c-37386641" checked=""/><div class="controls bullet"><span class="by">glouwbug</span><span>|</span><a href="#37386268">parent</a><span>|</span><a href="#37386984">prev</a><span>|</span><a href="#37386841">next</a><span>|</span><label class="collapse" for="c-37386641">[-]</label><label class="expand" for="c-37386641">[3 more]</label></div><br/><div class="children"><div class="content">Took me seven years to do my own dynamic one that ended up being very similar to python2 with curly braces. Every programmer should try it</div><br/><div id="37386756" class="c"><input type="checkbox" id="c-37386756" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37386641">parent</a><span>|</span><a href="#37387373">next</a><span>|</span><label class="collapse" for="c-37386756">[-]</label><label class="expand" for="c-37386756">[1 more]</label></div><br/><div class="children"><div class="content">“Crafting Interpreters” is a phenomenal place to start. It’s very accessible. If you think you’re “not good enough” to write a programming language, it will show you just how wrong you are. Really boosted my confidence. (Hi Bob!)</div><br/></div></div><div id="37387373" class="c"><input type="checkbox" id="c-37387373" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#37386268">root</a><span>|</span><a href="#37386641">parent</a><span>|</span><a href="#37386756">prev</a><span>|</span><a href="#37386841">next</a><span>|</span><label class="collapse" for="c-37387373">[-]</label><label class="expand" for="c-37387373">[1 more]</label></div><br/><div class="children"><div class="content">Writing your own interpreter can be a lot of fun.<p>Not sure if most people will get much extra out of writing their own compiler, too?</div><br/></div></div></div></div><div id="37386841" class="c"><input type="checkbox" id="c-37386841" checked=""/><div class="controls bullet"><span class="by">mighmi</span><span>|</span><a href="#37386268">parent</a><span>|</span><a href="#37386641">prev</a><span>|</span><a href="#37389187">next</a><span>|</span><label class="collapse" for="c-37386841">[-]</label><label class="expand" for="c-37386841">[1 more]</label></div><br/><div class="children"><div class="content">How do later editions of SICP differ? I have no idea which I used.</div><br/></div></div></div></div><div id="37384275" class="c"><input type="checkbox" id="c-37384275" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#37386268">prev</a><span>|</span><a href="#37386983">next</a><span>|</span><label class="collapse" for="c-37384275">[-]</label><label class="expand" for="c-37384275">[29 more]</label></div><br/><div class="children"><div class="content">It is interesting to think that 500 lines of code is something one can write in one or two days. But, writing a C compiler in 500 of comprehensible code (even in python) is challenge in itself that may take months after a few years of solid learning.<p>I wonder if is this a good path to becoming an extremely productive developer. If some one spends time developing projects like this, but for different areas... A kernel, a compressor, renderer, multimedia&#x2F;network stack, IA&#x2F;ML... Will that turn a good dev into a 0.1 Bellard?</div><br/><div id="37384885" class="c"><input type="checkbox" id="c-37384885" checked=""/><div class="controls bullet"><span class="by">sciolist</span><span>|</span><a href="#37384275">parent</a><span>|</span><a href="#37384515">next</a><span>|</span><label class="collapse" for="c-37384885">[-]</label><label class="expand" for="c-37384885">[3 more]</label></div><br/><div class="children"><div class="content">It does remind me of a project [1] Andrej Karpathy did, writing a neural network and training code in ~600 lines (although networks have easier logic to code than a compiler).<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;karpathy&#x2F;nanoGPT">https:&#x2F;&#x2F;github.com&#x2F;karpathy&#x2F;nanoGPT</a></div><br/><div id="37385236" class="c"><input type="checkbox" id="c-37385236" checked=""/><div class="controls bullet"><span class="by">pama</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37384885">parent</a><span>|</span><a href="#37384515">next</a><span>|</span><label class="collapse" for="c-37385236">[-]</label><label class="expand" for="c-37385236">[2 more]</label></div><br/><div class="children"><div class="content">This is an implementation of GPT using the pytorch library. It is not meant to be the shortest implementation of a trainable GPT, however it is very clean code. Pytorch does a lot of the heavy lifting, especially when it comes to training on multiple GPU.  This implementation only works with data distributed parallel training, so one could not train models of the size of GPT-4 with it out of the box.</div><br/><div id="37385692" class="c"><input type="checkbox" id="c-37385692" checked=""/><div class="controls bullet"><span class="by">tavianator</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385236">parent</a><span>|</span><a href="#37384515">next</a><span>|</span><label class="collapse" for="c-37385692">[-]</label><label class="expand" for="c-37385692">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps they were thinking of <a href="https:&#x2F;&#x2F;github.com&#x2F;karpathy&#x2F;micrograd">https:&#x2F;&#x2F;github.com&#x2F;karpathy&#x2F;micrograd</a></div><br/></div></div></div></div></div></div><div id="37384515" class="c"><input type="checkbox" id="c-37384515" checked=""/><div class="controls bullet"><span class="by">pitherpather</span><span>|</span><a href="#37384275">parent</a><span>|</span><a href="#37384885">prev</a><span>|</span><a href="#37386160">next</a><span>|</span><label class="collapse" for="c-37384515">[-]</label><label class="expand" for="c-37384515">[5 more]</label></div><br/><div class="children"><div class="content">&gt; 0.1 Bellard<p>Off topic, but a log scale might be useful: 0.1 Bellard --&gt; -10 deciBellards. That allows for: 0.001 Bellard --&gt; -30 deciBellards.<p>Problem: Programmers with negative productivity cannot be represented on the same log scale.</div><br/><div id="37385028" class="c"><input type="checkbox" id="c-37385028" checked=""/><div class="controls bullet"><span class="by">araes</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37384515">parent</a><span>|</span><a href="#37385218">next</a><span>|</span><label class="collapse" for="c-37385028">[-]</label><label class="expand" for="c-37385028">[2 more]</label></div><br/><div class="children"><div class="content">Sure they can.  Abs().  Or if you prefer to not have quite so much micro-nano, you could also use Cumulative Distribution Functions [1] which are basically just sums of Probability Density [2].<p>Are they a 4σ programmer, 1σ programmer, -0.5σ programmer, -2σ programmer?<p>Plus, most people are &quot;average&quot; not negative productivity, and CDFs let you use really fun stuff like Beta Distributions (variable, shapable distributions) and Gamma Distributions (exponential distributions).  They&#x27;re super sweet as far as probability statistics.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cumulative_distribution_function" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cumulative_distribution_functi...</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Probability_density_function" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Probability_density_function</a><p>[3] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Beta_distribution" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Beta_distribution</a><p>[4] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gamma_distribution" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gamma_distribution</a></div><br/><div id="37385919" class="c"><input type="checkbox" id="c-37385919" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385028">parent</a><span>|</span><a href="#37385218">next</a><span>|</span><label class="collapse" for="c-37385919">[-]</label><label class="expand" for="c-37385919">[1 more]</label></div><br/><div class="children"><div class="content">The number of people that are average is infinitesimal, even if you define average as “mode” instead of median or mean.<p>About half are better than median though.</div><br/></div></div></div></div><div id="37385218" class="c"><input type="checkbox" id="c-37385218" checked=""/><div class="controls bullet"><span class="by">analog31</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37384515">parent</a><span>|</span><a href="#37385028">prev</a><span>|</span><a href="#37386160">next</a><span>|</span><label class="collapse" for="c-37385218">[-]</label><label class="expand" for="c-37385218">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;&gt; Problem: Programmers with negative productivity cannot be represented on the same log scale.<p>This is similar to the problem of price-to-earnings ratio. The ratio goes asymptotic as earnings goes through zero. It would be better to quote earnings-to-price ratio. Another screwy reciprocal unit is miles per gallon for cars.</div><br/><div id="37385931" class="c"><input type="checkbox" id="c-37385931" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385218">parent</a><span>|</span><a href="#37386160">next</a><span>|</span><label class="collapse" for="c-37385931">[-]</label><label class="expand" for="c-37385931">[1 more]</label></div><br/><div class="children"><div class="content">Now that I have an EV with 130 miles of range, I’m finding miles per kwh to be much more useful than efficiency.<p>I’d bet range anxiety was also a thing for early gasoline powered cars, so the early adopters of those probably preferred mpg over gpm.</div><br/></div></div></div></div></div></div><div id="37386160" class="c"><input type="checkbox" id="c-37386160" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#37384275">parent</a><span>|</span><a href="#37384515">prev</a><span>|</span><a href="#37388093">next</a><span>|</span><label class="collapse" for="c-37386160">[-]</label><label class="expand" for="c-37386160">[2 more]</label></div><br/><div class="children"><div class="content">As an experienced developer who did not do a compilers course at university I was able to write a SQL&#x2F;JSONPath evaluator in TypeScript in a week or so. I don’t expect a minimal C compiler would be that much more complex.<p>Essentially all you need is a grammar, parser library and a couple of tree walkers to convert the AST first to expand macros and then convert to assembly.<p>A production compiler with all its optimisation steps is of course far more complex and more modern languages have many more features, but C is really pretty simple (the K&amp;R book is concise and good!) as it was built to work on the computers of half a century ago.</div><br/><div id="37386803" class="c"><input type="checkbox" id="c-37386803" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37386160">parent</a><span>|</span><a href="#37388093">next</a><span>|</span><label class="collapse" for="c-37386803">[-]</label><label class="expand" for="c-37386803">[1 more]</label></div><br/><div class="children"><div class="content">Using a library is cheating. Any one with enough knowledge can create their own programming language in two weekends using parser combinators.</div><br/></div></div></div></div><div id="37388093" class="c"><input type="checkbox" id="c-37388093" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#37384275">parent</a><span>|</span><a href="#37386160">prev</a><span>|</span><a href="#37384428">next</a><span>|</span><label class="collapse" for="c-37388093">[-]</label><label class="expand" for="c-37388093">[1 more]</label></div><br/><div class="children"><div class="content">You might like the book 500 Lines or Less, Experienced Programmers solve interesting problems<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;500-Lines-Less-Amy-Brown&#x2F;dp&#x2F;1329871278" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.amazon.com&#x2F;500-Lines-Less-Amy-Brown&#x2F;dp&#x2F;132987127...</a></div><br/></div></div><div id="37384428" class="c"><input type="checkbox" id="c-37384428" checked=""/><div class="controls bullet"><span class="by">Barrin92</span><span>|</span><a href="#37384275">parent</a><span>|</span><a href="#37388093">prev</a><span>|</span><a href="#37384838">next</a><span>|</span><label class="collapse" for="c-37384428">[-]</label><label class="expand" for="c-37384428">[13 more]</label></div><br/><div class="children"><div class="content">at the very least it&#x27;ll remove a lot of &#x27;magic&#x27; from programming. Today a lot of people seem to be not so fond of university education but I&#x27;m personally very glad it made me go through implementing a shell, a compiler, a little toy kernel and so on.<p>The feeling that you write code somewhere in the skies and have no idea how something works underneath has always really bugged me when I&#x27;ve used something.</div><br/><div id="37385172" class="c"><input type="checkbox" id="c-37385172" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37384428">parent</a><span>|</span><a href="#37384838">next</a><span>|</span><label class="collapse" for="c-37385172">[-]</label><label class="expand" for="c-37385172">[12 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need a university education to do those things, just some curiosity.<p>The function of the university in the near future will probably just be to have like-minded curious people to discuss ideas with, and to get a better grasp of what problems need to be solved (specifically scientific ideas, rather than just applying engineering).<p>The prestige element (specifically of certain universities over others, perhaps not university over high school) is dwindling, and hopefully will be abolished with this new generation.</div><br/><div id="37386233" class="c"><input type="checkbox" id="c-37386233" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385172">parent</a><span>|</span><a href="#37388817">next</a><span>|</span><label class="collapse" for="c-37386233">[-]</label><label class="expand" for="c-37386233">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;uni degree value&quot; discussion on here is very biased towards the US, where expensive courses exist, some excellent but others perhaps not providing sufficient value for money.<p>Note that in several countries in Europe, studying is free of charge or only costs a symbolic fee (scholarships aside).<p>The university system is thousands of years old, and it would be disastrous if it were abolished. I&#x27;m a self-taught developer, who also obtained two Masters and a Ph.D. later, and I can attest to it that the speed of learning at uni cannot be compared with the speed of learning via self study, especially self-study in isolation.<p>Having said this, learning only in groups&#x2F;herds is also not the best approach IMHO, there is something to sitting alone and figuring something out without external help, at least occasionally, as it trains your analytical skills, your ability to concentrate and it gives you grit&#x2F;perseverance.</div><br/><div id="37386647" class="c"><input type="checkbox" id="c-37386647" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37386233">parent</a><span>|</span><a href="#37388817">next</a><span>|</span><label class="collapse" for="c-37386647">[-]</label><label class="expand" for="c-37386647">[1 more]</label></div><br/><div class="children"><div class="content">Lectures were made obsolete by Gutenberg. There is little of value (but not none, ok) in wasting time of reputable professors on repeating the same stuff each semester to a hall of 200 students.<p>Seminars&#x2F;labs and office hours is where the biggest value of university can come from, but that’s the part that is often left to TA…</div><br/></div></div></div></div><div id="37388817" class="c"><input type="checkbox" id="c-37388817" checked=""/><div class="controls bullet"><span class="by">Ultimatt</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385172">parent</a><span>|</span><a href="#37386233">prev</a><span>|</span><a href="#37386015">next</a><span>|</span><label class="collapse" for="c-37388817">[-]</label><label class="expand" for="c-37388817">[1 more]</label></div><br/><div class="children"><div class="content">That was already and always the function and value of a university... Notice the academics aren&#x27;t sitting in lectures 6 hours a day or trying to pass exams to obtain degrees. They&#x27;re the longterm users of universities and educating themselves their entire lives.</div><br/></div></div><div id="37386015" class="c"><input type="checkbox" id="c-37386015" checked=""/><div class="controls bullet"><span class="by">nativeit</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385172">parent</a><span>|</span><a href="#37388817">prev</a><span>|</span><a href="#37385481">next</a><span>|</span><label class="collapse" for="c-37386015">[-]</label><label class="expand" for="c-37386015">[1 more]</label></div><br/><div class="children"><div class="content">I found that attending my home state university afforded me access to facilities and resources I would never have had on my own, and to not just a wealth of knowledge but also mentors and incredibly capable guides for how to navigate that knowledge while putting into productive practice.<p>Motivation and internet access can get some of those things, but even among those things one would struggle to find them in one place and so readily available to them.</div><br/></div></div><div id="37385481" class="c"><input type="checkbox" id="c-37385481" checked=""/><div class="controls bullet"><span class="by">jabits</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385172">parent</a><span>|</span><a href="#37386015">prev</a><span>|</span><a href="#37385251">next</a><span>|</span><label class="collapse" for="c-37385481">[-]</label><label class="expand" for="c-37385481">[6 more]</label></div><br/><div class="children"><div class="content">A university degree is much more than this, and I think most people who view its value as “dwindling” have not had the experience…</div><br/><div id="37386604" class="c"><input type="checkbox" id="c-37386604" checked=""/><div class="controls bullet"><span class="by">chaxor</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385481">parent</a><span>|</span><a href="#37386670">next</a><span>|</span><label class="collapse" for="c-37386604">[-]</label><label class="expand" for="c-37386604">[1 more]</label></div><br/><div class="children"><div class="content">It would be great if there were more emphasis on some of the aspects that made academia so great many years ago, but unfortunately the scene has changed dramatically.<p>My perspective on the value dwindling comes from several graduate degrees and teaching at some of these &#x27;prestigious&#x27; universities in the northeast.<p>It is of course just my singular experience, but the handful of research institutions I have worked at actually provided more of a typical &#x27;academic&#x27; atmosphere than the universities, unfortunately.  I still really <i>want</i> to believe that universities provide the most innovative research environment, but the incentive and operational structures don&#x27;t really make it as optimal.<p>The reason I mention the new generation viewing its value as dwindling is that the cost isn&#x27;t really &#x27;worth it&#x27; and  many of the best educational resources are actually free online now.<p>I&#x27;m an academic, so the fact that the investment doesn&#x27;t pay off doesn&#x27;t really bother me (academics typically don&#x27;t care about money), but many people do want some financial advantage from education, and that isn&#x27;t as present anymore.</div><br/></div></div><div id="37386670" class="c"><input type="checkbox" id="c-37386670" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385481">parent</a><span>|</span><a href="#37386604">prev</a><span>|</span><a href="#37385581">next</a><span>|</span><label class="collapse" for="c-37386670">[-]</label><label class="expand" for="c-37386670">[1 more]</label></div><br/><div class="children"><div class="content">What is implied by “much more than this” and why shouldn’t those things be available to people not enrolled into a university?</div><br/></div></div><div id="37385581" class="c"><input type="checkbox" id="c-37385581" checked=""/><div class="controls bullet"><span class="by">solumunus</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385481">parent</a><span>|</span><a href="#37386670">prev</a><span>|</span><a href="#37385251">next</a><span>|</span><label class="collapse" for="c-37385581">[-]</label><label class="expand" for="c-37385581">[3 more]</label></div><br/><div class="children"><div class="content">It massively depends on what degree and where I suppose. Most people I know with degrees view it as a complete waste of money.</div><br/><div id="37386017" class="c"><input type="checkbox" id="c-37386017" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385581">parent</a><span>|</span><a href="#37386058">next</a><span>|</span><label class="collapse" for="c-37386017">[-]</label><label class="expand" for="c-37386017">[1 more]</label></div><br/><div class="children"><div class="content">Most people with a university degree don’t have a traditional university education.<p>I’m very much pro-education, and think that US high school should include the first two years of a current university education (grades should be roughly split between D, C, B and  A, where D means “meets curriculum requirements”).<p>After that, I don’t think many people should go to a university.  Instead, the state should provide up to 10 years of vocational education (splittable and redeemable at any point in life) or 8 years of university education (subject to a B or better average in high school).<p>Most vocational programs would be under 3 years, so you’d get three-four cracks at finding the right profession for you.<p>University track would be targeted at educators, researchers and entrepreneurs.<p>I think this would be better for every socioeconomic demographic in the US, and also help alleviate the housing shortage, enable modern manufacturing, fix many current issues with healthcare, and so on.)</div><br/></div></div></div></div></div></div><div id="37385251" class="c"><input type="checkbox" id="c-37385251" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37385172">parent</a><span>|</span><a href="#37385481">prev</a><span>|</span><a href="#37384838">next</a><span>|</span><label class="collapse" for="c-37385251">[-]</label><label class="expand" for="c-37385251">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m largely taught outside the academic world. so I sympathize with your position.<p>however, the engineering culture which took the time to tell me about all these cool things and let me grow into being an expert in them seems to be largely gone.</div><br/></div></div></div></div></div></div><div id="37384503" class="c"><input type="checkbox" id="c-37384503" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37384275">parent</a><span>|</span><a href="#37384838">prev</a><span>|</span><a href="#37386036">next</a><span>|</span><label class="collapse" for="c-37384503">[-]</label><label class="expand" for="c-37384503">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But, writing a C compiler in 500 of comprehensible code (even in python) is challenge in itself that may take months after a few years of solid learning.<p>The people behind this project avoided that caveat by simply not implementing C. Apparently they kept a bit of the syntax but then proceeded to cherry-pick features that suited them and not make.an effort to even try to comply with any version of the standard.</div><br/><div id="37384881" class="c"><input type="checkbox" id="c-37384881" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#37384275">root</a><span>|</span><a href="#37384503">parent</a><span>|</span><a href="#37386036">next</a><span>|</span><label class="collapse" for="c-37384881">[-]</label><label class="expand" for="c-37384881">[1 more]</label></div><br/><div class="children"><div class="content">It’s a little bit bigger than Small C <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Small-C" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Small-C</a></div><br/></div></div></div></div></div></div><div id="37386983" class="c"><input type="checkbox" id="c-37386983" checked=""/><div class="controls bullet"><span class="by">aldousd666</span><span>|</span><a href="#37384275">prev</a><span>|</span><a href="#37385442">next</a><span>|</span><label class="collapse" for="c-37386983">[-]</label><label class="expand" for="c-37386983">[1 more]</label></div><br/><div class="children"><div class="content">This is crazy cool! Esolangs have been a hobby of mine, (more just an interest lately, since I haven&#x27;t built any in a while,) so this is like a fun code golf game for compilation. Nice work, and even better, nice explanation article!</div><br/></div></div><div id="37385442" class="c"><input type="checkbox" id="c-37385442" checked=""/><div class="controls bullet"><span class="by">rcarmo</span><span>|</span><a href="#37386983">prev</a><span>|</span><a href="#37385085">next</a><span>|</span><label class="collapse" for="c-37385442">[-]</label><label class="expand" for="c-37385442">[2 more]</label></div><br/><div class="children"><div class="content">I have to wonder if there&#x27;s a Scheme to WASM compiler out there someplace right now I haven&#x27;t found yet.</div><br/><div id="37385543" class="c"><input type="checkbox" id="c-37385543" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37385442">parent</a><span>|</span><a href="#37385085">next</a><span>|</span><label class="collapse" for="c-37385543">[-]</label><label class="expand" for="c-37385543">[1 more]</label></div><br/><div class="children"><div class="content">Looks like Schism (<a href="https:&#x2F;&#x2F;github.com&#x2F;schism-lang&#x2F;schism">https:&#x2F;&#x2F;github.com&#x2F;schism-lang&#x2F;schism</a>) got part of the way there, but it unfortunately seems to be dead.</div><br/></div></div></div></div><div id="37385085" class="c"><input type="checkbox" id="c-37385085" checked=""/><div class="controls bullet"><span class="by">nn3</span><span>|</span><a href="#37385442">prev</a><span>|</span><a href="#37387255">next</a><span>|</span><label class="collapse" for="c-37385085">[-]</label><label class="expand" for="c-37385085">[4 more]</label></div><br/><div class="children"><div class="content">Just for comparison the LOCs for some other small C or C like compilers.
It&#x27;s not that far away from Ritchie&#x27;s<p>C4x86                              |   0.6K  (very close)<p>small C (x86)                      |   3.1K<p>Ritchie&#x27;s earliest struct compiler |   2.3K<p>v7 Unix C compiler                 |  10.2K<p>chibicc                            |   8.4K<p>Biederman&#x27;s romcc                  |  25.0K</div><br/><div id="37385475" class="c"><input type="checkbox" id="c-37385475" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#37385085">parent</a><span>|</span><a href="#37385127">next</a><span>|</span><label class="collapse" for="c-37385475">[-]</label><label class="expand" for="c-37385475">[1 more]</label></div><br/><div class="children"><div class="content">This one is certainly stretching the definition of &quot;C like&quot;, but it&#x27;s just under 512 <i>bytes</i> : <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36064971">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36064971</a></div><br/></div></div><div id="37385127" class="c"><input type="checkbox" id="c-37385127" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37385085">parent</a><span>|</span><a href="#37385475">prev</a><span>|</span><a href="#37385154">next</a><span>|</span><label class="collapse" for="c-37385127">[-]</label><label class="expand" for="c-37385127">[1 more]</label></div><br/><div class="children"><div class="content">Oh, C4 is neat—technically it has me beat since it also implements the VM to <i>run</i> the code—though their formatting definitely takes advantage of long lines :-)</div><br/></div></div></div></div><div id="37387255" class="c"><input type="checkbox" id="c-37387255" checked=""/><div class="controls bullet"><span class="by">golemarms</span><span>|</span><a href="#37385085">prev</a><span>|</span><a href="#37384439">next</a><span>|</span><label class="collapse" for="c-37387255">[-]</label><label class="expand" for="c-37387255">[1 more]</label></div><br/><div class="children"><div class="content">Cool. Now try writing a Python compiler in 500 lines of C.</div><br/></div></div><div id="37384439" class="c"><input type="checkbox" id="c-37384439" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#37387255">prev</a><span>|</span><a href="#37389132">next</a><span>|</span><label class="collapse" for="c-37384439">[-]</label><label class="expand" for="c-37384439">[6 more]</label></div><br/><div class="children"><div class="content">For some value of “C”:<p>&gt; <i>Notably, it doesn&#x27;t support:</i><p>&gt; <i>structs :-( would be possible with more code, the fundamentals were there, I just couldn&#x27;t squeeze it in</i><p>&gt; <i>enums &#x2F; unions</i><p>&gt; <i>preprocessor directives (this would probably be 500 lines by itself...)</i><p>&gt; <i>floating point. would also be possible, the wasm_type stuff is in, again just couldn&#x27;t squeeze it in</i><p>&gt; <i>8 byte types (long&#x2F;long long or double)</i><p>&gt; <i>some other small things like pre&#x2F;post cremements, in-place initialization, etc., which just didn&#x27;t quite fit any sort of standard library or i&#x2F;o that isn&#x27;t returning an integer from main()</i><p>&gt; <i>casting expressions</i></div><br/><div id="37385246" class="c"><input type="checkbox" id="c-37385246" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37384439">parent</a><span>|</span><a href="#37388479">next</a><span>|</span><label class="collapse" for="c-37385246">[-]</label><label class="expand" for="c-37385246">[1 more]</label></div><br/><div class="children"><div class="content">Well, I set the 500 line budget up front, and that was really as much as I could fit with reasonable formatting. I&#x27;ll be excited to see your 500 line C compiler supporting all those features once it&#x27;s done ;-)</div><br/></div></div><div id="37388479" class="c"><input type="checkbox" id="c-37388479" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37384439">parent</a><span>|</span><a href="#37385246">prev</a><span>|</span><a href="#37385126">next</a><span>|</span><label class="collapse" for="c-37388479">[-]</label><label class="expand" for="c-37388479">[1 more]</label></div><br/><div class="children"><div class="content">Basically like many C compilers outside UNIX during the 1980&#x27;s.<p>RatC did not need 500 lines for its preprocessor support, by the way.</div><br/></div></div><div id="37385126" class="c"><input type="checkbox" id="c-37385126" checked=""/><div class="controls bullet"><span class="by">spease</span><span>|</span><a href="#37384439">parent</a><span>|</span><a href="#37388479">prev</a><span>|</span><a href="#37384461">next</a><span>|</span><label class="collapse" for="c-37385126">[-]</label><label class="expand" for="c-37385126">[2 more]</label></div><br/><div class="children"><div class="content">C--23<p>(Respect to the author for doing this, I just couldn’t resist the obvious joke)</div><br/><div id="37385223" class="c"><input type="checkbox" id="c-37385223" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37384439">root</a><span>|</span><a href="#37385126">parent</a><span>|</span><a href="#37384461">next</a><span>|</span><label class="collapse" for="c-37385223">[-]</label><label class="expand" for="c-37385223">[1 more]</label></div><br/><div class="children"><div class="content">I actually almost made it a C-- (<a href="https:&#x2F;&#x2F;www.cs.tufts.edu&#x2F;~nr&#x2F;c--&#x2F;download&#x2F;ppdp.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.tufts.edu&#x2F;~nr&#x2F;c--&#x2F;download&#x2F;ppdp.pdf</a>) compiler, but IIRC the `goto`s made me go with the regular C subset instead.</div><br/></div></div></div></div></div></div><div id="37389132" class="c"><input type="checkbox" id="c-37389132" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#37384439">prev</a><span>|</span><a href="#37388609">next</a><span>|</span><label class="collapse" for="c-37389132">[-]</label><label class="expand" for="c-37389132">[2 more]</label></div><br/><div class="children"><div class="content">Inevitably we have to ask: and how many lines of C in library functions?</div><br/></div></div><div id="37388609" class="c"><input type="checkbox" id="c-37388609" checked=""/><div class="controls bullet"><span class="by">hamilyon2</span><span>|</span><a href="#37389132">prev</a><span>|</span><a href="#37389168">next</a><span>|</span><label class="collapse" for="c-37388609">[-]</label><label class="expand" for="c-37388609">[3 more]</label></div><br/><div class="children"><div class="content">So, given the python is an interpreter and very well understood, can we say that we are sure this compiler does not include Thompson virus?</div><br/><div id="37388638" class="c"><input type="checkbox" id="c-37388638" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#37388609">parent</a><span>|</span><a href="#37389197">next</a><span>|</span><label class="collapse" for="c-37388638">[-]</label><label class="expand" for="c-37388638">[1 more]</label></div><br/><div class="children"><div class="content">No</div><br/></div></div></div></div><div id="37389168" class="c"><input type="checkbox" id="c-37389168" checked=""/><div class="controls bullet"><span class="by">ForOldHack</span><span>|</span><a href="#37388609">prev</a><span>|</span><a href="#37384146">next</a><span>|</span><label class="collapse" for="c-37389168">[-]</label><label class="expand" for="c-37389168">[2 more]</label></div><br/><div class="children"><div class="content">The *point* of a compiler is to compile itself.</div><br/></div></div><div id="37384146" class="c"><input type="checkbox" id="c-37384146" checked=""/><div class="controls bullet"><span class="by">fan_of_yoinked</span><span>|</span><a href="#37389168">prev</a><span>|</span><a href="#37384049">next</a><span>|</span><label class="collapse" for="c-37384146">[-]</label><label class="expand" for="c-37384146">[2 more]</label></div><br/><div class="children"><div class="content">I love the graphic - would go see the worlds largest chomsky</div><br/></div></div><div id="37384049" class="c"><input type="checkbox" id="c-37384049" checked=""/><div class="controls bullet"><span class="by">rhabarba</span><span>|</span><a href="#37384146">prev</a><span>|</span><a href="#37387452">next</a><span>|</span><label class="collapse" for="c-37384049">[-]</label><label class="expand" for="c-37384049">[9 more]</label></div><br/><div class="children"><div class="content">Finally, one can have inefficient C.</div><br/><div id="37384190" class="c"><input type="checkbox" id="c-37384190" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#37384049">parent</a><span>|</span><a href="#37384528">next</a><span>|</span><label class="collapse" for="c-37384190">[-]</label><label class="expand" for="c-37384190">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s always the <i>CINT</i> interpreter for C and C++.<p><a href="https:&#x2F;&#x2F;root.cern.ch&#x2F;root&#x2F;html534&#x2F;guides&#x2F;users-guide&#x2F;CINT.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;root.cern.ch&#x2F;root&#x2F;html534&#x2F;guides&#x2F;users-guide&#x2F;CINT.ht...</a></div><br/><div id="37385288" class="c"><input type="checkbox" id="c-37385288" checked=""/><div class="controls bullet"><span class="by">brnt</span><span>|</span><a href="#37384049">root</a><span>|</span><a href="#37384190">parent</a><span>|</span><a href="#37384528">next</a><span>|</span><label class="collapse" for="c-37385288">[-]</label><label class="expand" for="c-37385288">[1 more]</label></div><br/><div class="children"><div class="content">A PTSD trigger for me. Only half joking. Funny thing is, I never checked out Cling to see if it was at long last the real deal.</div><br/></div></div></div></div><div id="37384528" class="c"><input type="checkbox" id="c-37384528" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#37384049">parent</a><span>|</span><a href="#37384190">prev</a><span>|</span><a href="#37385385">next</a><span>|</span><label class="collapse" for="c-37384528">[-]</label><label class="expand" for="c-37384528">[4 more]</label></div><br/><div class="children"><div class="content">Why would language choice of compiler make any difference for efficiency of final output?</div><br/><div id="37385190" class="c"><input type="checkbox" id="c-37385190" checked=""/><div class="controls bullet"><span class="by">NeuroCoder</span><span>|</span><a href="#37384049">root</a><span>|</span><a href="#37384528">parent</a><span>|</span><a href="#37385262">next</a><span>|</span><label class="collapse" for="c-37385190">[-]</label><label class="expand" for="c-37385190">[1 more]</label></div><br/><div class="children"><div class="content">They didn&#x27;t say the language was the issue. It doesn&#x27;t support the full C spec. But if you want a reason why language might be an issue for a compiler, it could make compilation time slower. But I think the point of this project is not real world use but fun demonstration of skill</div><br/></div></div><div id="37385262" class="c"><input type="checkbox" id="c-37385262" checked=""/><div class="controls bullet"><span class="by">vgel</span><span>|</span><a href="#37384049">root</a><span>|</span><a href="#37384528">parent</a><span>|</span><a href="#37385190">prev</a><span>|</span><a href="#37385821">next</a><span>|</span><label class="collapse" for="c-37385262">[-]</label><label class="expand" for="c-37385262">[1 more]</label></div><br/><div class="children"><div class="content">Maybe not the language choice, but the codegen of this compiler is <i>terrible</i> because of the single-pass shortcuts (for example, it unconditionally loads the result of all assignment operations back to the stack <i>just in case</i> you want to write `a = b = 1`, even though 99% of the time that load is immediately thrown away.)</div><br/></div></div></div></div><div id="37385385" class="c"><input type="checkbox" id="c-37385385" checked=""/><div class="controls bullet"><span class="by">folmar</span><span>|</span><a href="#37384049">parent</a><span>|</span><a href="#37384528">prev</a><span>|</span><a href="#37385159">next</a><span>|</span><label class="collapse" for="c-37385385">[-]</label><label class="expand" for="c-37385385">[1 more]</label></div><br/><div class="children"><div class="content">Always remember _bashcc_.</div><br/></div></div></div></div></div></div></div></div></div></body></html>