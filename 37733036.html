<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696237265978" as="style"/><link rel="stylesheet" href="styles.css?v=1696237265978"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://buildkite.com/blog/goodbye-integers-hello-uuids">Goodbye integers, hello UUIDv7</a> <span class="domain">(<a href="https://buildkite.com">buildkite.com</a>)</span></div><div class="subtext"><span>juanfatas</span> | <span>168 comments</span></div><br/><div><div id="37733717" class="c"><input type="checkbox" id="c-37733717" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#37733334">next</a><span>|</span><label class="collapse" for="c-37733717">[-]</label><label class="expand" for="c-37733717">[46 more]</label></div><br/><div class="children"><div class="content">This is great for internal distributed systems where having ordered keys is useful, however, it should probably be noted that these probably shouldn&#x27;t be used as public identifiers (even though this will probably be the defacto standard and used publicly without thought).<p>Having any information, specifically time information, leaking from your systems may or may not have unanticipated security or business implications. (e.g. knowing when session tokens or accounts are created).</div><br/><div id="37734024" class="c"><input type="checkbox" id="c-37734024" checked=""/><div class="controls bullet"><span class="by">oconnore</span><span>|</span><a href="#37733717">parent</a><span>|</span><a href="#37734500">next</a><span>|</span><label class="collapse" for="c-37734024">[-]</label><label class="expand" for="c-37734024">[24 more]</label></div><br/><div class="children"><div class="content">Given that a UUID identifier fits in a single cipher block, and the whole point is that these are unique by construction (no IV needed so long as that holds true), it seems like a single round of ECB-mode AES-128 would enable quickly converting between internal&#x2F;external identifiers.<p>128 bits -&gt; 128 bits</div><br/><div id="37734980" class="c"><input type="checkbox" id="c-37734980" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734024">parent</a><span>|</span><a href="#37734960">next</a><span>|</span><label class="collapse" for="c-37734980">[-]</label><label class="expand" for="c-37734980">[3 more]</label></div><br/><div class="children"><div class="content">Why not just use the AES-128 result as the UUID then? What&#x27;s the benefit of the internal structure at all?<p>If AES-128 is an acceptable external UUID (and likely an acceptable internal one), then you might as well just stick with a faster RNG.</div><br/><div id="37735034" class="c"><input type="checkbox" id="c-37735034" checked=""/><div class="controls bullet"><span class="by">oconnore</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734980">parent</a><span>|</span><a href="#37734960">next</a><span>|</span><label class="collapse" for="c-37735034">[-]</label><label class="expand" for="c-37735034">[2 more]</label></div><br/><div class="children"><div class="content">That would be the same as using a random identifier (UUIDv4, for example) with the associated indexing issues when stored in a database.<p>The whole point here would be that you can expose something opaque externally but benefit from well behaved index keys internally.</div><br/><div id="37735597" class="c"><input type="checkbox" id="c-37735597" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37735034">parent</a><span>|</span><a href="#37734960">next</a><span>|</span><label class="collapse" for="c-37735597">[-]</label><label class="expand" for="c-37735597">[1 more]</label></div><br/><div class="children"><div class="content">Storage is cheap, you might as well store the extra integer.</div><br/></div></div></div></div></div></div><div id="37734960" class="c"><input type="checkbox" id="c-37734960" checked=""/><div class="controls bullet"><span class="by">MattPalmer1086</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734024">parent</a><span>|</span><a href="#37734980">prev</a><span>|</span><a href="#37735350">next</a><span>|</span><label class="collapse" for="c-37734960">[-]</label><label class="expand" for="c-37734960">[3 more]</label></div><br/><div class="children"><div class="content">This seems overly complex, and you need some kind of key too.<p>Why not just hash it with pretty much any hash function?</div><br/><div id="37735061" class="c"><input type="checkbox" id="c-37735061" checked=""/><div class="controls bullet"><span class="by">oconnore</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734960">parent</a><span>|</span><a href="#37734989">next</a><span>|</span><label class="collapse" for="c-37735061">[-]</label><label class="expand" for="c-37735061">[1 more]</label></div><br/><div class="children"><div class="content">A hash is not reversible, so you’d need a database index to recover the original efficient-to-index identifier, which misses the whole point ;)<p>If you didn’t care about index  clustering then just use UUIDv4</div><br/></div></div><div id="37734989" class="c"><input type="checkbox" id="c-37734989" checked=""/><div class="controls bullet"><span class="by">bajsejohannes</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734960">parent</a><span>|</span><a href="#37735061">prev</a><span>|</span><a href="#37735350">next</a><span>|</span><label class="collapse" for="c-37734989">[-]</label><label class="expand" for="c-37734989">[1 more]</label></div><br/><div class="children"><div class="content">Because a hash is (by definition) a one-way function. You need to be able to go the other way for incoming ids.</div><br/></div></div></div></div><div id="37735350" class="c"><input type="checkbox" id="c-37735350" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734024">parent</a><span>|</span><a href="#37734960">prev</a><span>|</span><a href="#37734672">next</a><span>|</span><label class="collapse" for="c-37735350">[-]</label><label class="expand" for="c-37735350">[2 more]</label></div><br/><div class="children"><div class="content">One key for all tokens or one key per token? If it’s the latter a simple XOR would do because it would be the equivalent of a one time pad.</div><br/><div id="37735581" class="c"><input type="checkbox" id="c-37735581" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37735350">parent</a><span>|</span><a href="#37734672">next</a><span>|</span><label class="collapse" for="c-37735581">[-]</label><label class="expand" for="c-37735581">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it can be a key per token, or it will scale appallingly.</div><br/></div></div></div></div><div id="37734672" class="c"><input type="checkbox" id="c-37734672" checked=""/><div class="controls bullet"><span class="by">fodkodrasz</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734024">parent</a><span>|</span><a href="#37735350">prev</a><span>|</span><a href="#37734367">next</a><span>|</span><label class="collapse" for="c-37734672">[-]</label><label class="expand" for="c-37734672">[4 more]</label></div><br/><div class="children"><div class="content">No IV, ECB mode... why bother with encryption at all? Just expose the internal id.</div><br/><div id="37734816" class="c"><input type="checkbox" id="c-37734816" checked=""/><div class="controls bullet"><span class="by">computerfriend</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734672">parent</a><span>|</span><a href="#37734791">next</a><span>|</span><label class="collapse" for="c-37734816">[-]</label><label class="expand" for="c-37734816">[1 more]</label></div><br/><div class="children"><div class="content">ECB is perfectly secure when you use it on a single block.</div><br/></div></div><div id="37734791" class="c"><input type="checkbox" id="c-37734791" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734672">parent</a><span>|</span><a href="#37734816">prev</a><span>|</span><a href="#37734717">next</a><span>|</span><label class="collapse" for="c-37734791">[-]</label><label class="expand" for="c-37734791">[1 more]</label></div><br/><div class="children"><div class="content">Encrypting an internal id with ECB into an external id continues to allow the comparison for equality of 2 ids, to determine whether they are the same or not, but except for this it removes all the information contained in the structure of an UUID.</div><br/></div></div><div id="37734717" class="c"><input type="checkbox" id="c-37734717" checked=""/><div class="controls bullet"><span class="by">bajsejohannes</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734672">parent</a><span>|</span><a href="#37734791">prev</a><span>|</span><a href="#37734367">next</a><span>|</span><label class="collapse" for="c-37734717">[-]</label><label class="expand" for="c-37734717">[1 more]</label></div><br/><div class="children"><div class="content">You would still use a secret key, so it&#x27;s impossible for the end user to decrypt it.</div><br/></div></div></div></div><div id="37734367" class="c"><input type="checkbox" id="c-37734367" checked=""/><div class="controls bullet"><span class="by">dajonker</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734024">parent</a><span>|</span><a href="#37734672">prev</a><span>|</span><a href="#37734410">next</a><span>|</span><label class="collapse" for="c-37734367">[-]</label><label class="expand" for="c-37734367">[7 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an interesting idea, how would you deal with the bits in the UUID that are used for the version? Setting them to random bits may cause issues for clients that try to use the identifier in their own database or application, as mentioned in the article.</div><br/><div id="37734485" class="c"><input type="checkbox" id="c-37734485" checked=""/><div class="controls bullet"><span class="by">notpushkin</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734367">parent</a><span>|</span><a href="#37734410">next</a><span>|</span><label class="collapse" for="c-37734485">[-]</label><label class="expand" for="c-37734485">[6 more]</label></div><br/><div class="children"><div class="content">Is there a way to encrypt 122 bits -&gt; 122 bits? If so – do that and set version to 4.<p>Alternatively, just say it&#x27;s a random string ID and not an UUID.</div><br/><div id="37735422" class="c"><input type="checkbox" id="c-37735422" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734485">parent</a><span>|</span><a href="#37734775">next</a><span>|</span><label class="collapse" for="c-37735422">[-]</label><label class="expand" for="c-37735422">[1 more]</label></div><br/><div class="children"><div class="content">For your information, yes, you can [1]. For example if you have a good enough 128-bit block cipher (e.g. AES-128-ECB), start with a block of 128 bits where specific 6 bits are filled out and others are filled with the plain text. Repeatedly encrypt the block until those specific 6 bits are reached again (and do the same thing in reverse for decryption). This is possible because a good block cipher is also a good pseudorandom permutation, so it should have a small number of extremely long cycles (ideally just one) with a 2^-6 probability of allowed values in average.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Format-preserving_encryption" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Format-preserving_encryption</a></div><br/></div></div><div id="37734775" class="c"><input type="checkbox" id="c-37734775" checked=""/><div class="controls bullet"><span class="by">bajsejohannes</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734485">parent</a><span>|</span><a href="#37735422">prev</a><span>|</span><a href="#37735552">next</a><span>|</span><label class="collapse" for="c-37734775">[-]</label><label class="expand" for="c-37734775">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually working on encrypting database keys like this, and I opted for a string ID with &quot;url safe&quot; base64. It avoids the ambiguity of looking like a UUID when it&#x27;s not, and I prefer &quot;o3Ru98R3Qw-_x2MdiEEdSQ&quot; in a URL over &quot;a3746ef7-c477-430f-bfc7-631d88411d49&quot;. (Not that either one is very beautiful)</div><br/><div id="37735036" class="c"><input type="checkbox" id="c-37735036" checked=""/><div class="controls bullet"><span class="by">matja</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734775">parent</a><span>|</span><a href="#37735552">next</a><span>|</span><label class="collapse" for="c-37735036">[-]</label><label class="expand" for="c-37735036">[2 more]</label></div><br/><div class="children"><div class="content">Curious on the preference there, especially when characters in base64url encoding can look similar&#x2F;ambiguous in some fonts.</div><br/><div id="37735151" class="c"><input type="checkbox" id="c-37735151" checked=""/><div class="controls bullet"><span class="by">bajsejohannes</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37735036">parent</a><span>|</span><a href="#37735552">next</a><span>|</span><label class="collapse" for="c-37735151">[-]</label><label class="expand" for="c-37735151">[1 more]</label></div><br/><div class="children"><div class="content">The preference is purely about the amount of characters. I hope no one will ever actually read or write these URLs, but you never know...</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37734410" class="c"><input type="checkbox" id="c-37734410" checked=""/><div class="controls bullet"><span class="by">lysium</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734024">parent</a><span>|</span><a href="#37734367">prev</a><span>|</span><a href="#37734500">next</a><span>|</span><label class="collapse" for="c-37734410">[-]</label><label class="expand" for="c-37734410">[4 more]</label></div><br/><div class="children"><div class="content">Neat idea.<p>I’m afraid you won’t be able to ever rotate that key, would you? Since it’s result is externally used as an identifier, you would have to rotate the external identifiers, too.</div><br/><div id="37735184" class="c"><input type="checkbox" id="c-37735184" checked=""/><div class="controls bullet"><span class="by">oconnore</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734410">parent</a><span>|</span><a href="#37734478">next</a><span>|</span><label class="collapse" for="c-37735184">[-]</label><label class="expand" for="c-37735184">[1 more]</label></div><br/><div class="children"><div class="content">I think you could but it would further complicate the id scheme (would need some sort of a version mask to facilitate a rotation window).</div><br/></div></div><div id="37734478" class="c"><input type="checkbox" id="c-37734478" checked=""/><div class="controls bullet"><span class="by">the_arun</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734410">parent</a><span>|</span><a href="#37735184">prev</a><span>|</span><a href="#37734500">next</a><span>|</span><label class="collapse" for="c-37734478">[-]</label><label class="expand" for="c-37734478">[2 more]</label></div><br/><div class="children"><div class="content">What is the use case for rotating uuids? Aren’t they immutable?</div><br/><div id="37734489" class="c"><input type="checkbox" id="c-37734489" checked=""/><div class="controls bullet"><span class="by">Raed667</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734478">parent</a><span>|</span><a href="#37734500">next</a><span>|</span><label class="collapse" for="c-37734489">[-]</label><label class="expand" for="c-37734489">[1 more]</label></div><br/><div class="children"><div class="content">i think they meant rotating the encryption key not the internal uuids</div><br/></div></div></div></div></div></div></div></div><div id="37734500" class="c"><input type="checkbox" id="c-37734500" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37733717">parent</a><span>|</span><a href="#37734024">prev</a><span>|</span><a href="#37734487">next</a><span>|</span><label class="collapse" for="c-37734500">[-]</label><label class="expand" for="c-37734500">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a fan of Cuid2[1] for this reason.<p>They are compact, don&#x27;t leak information, and make a good case why k-sortable IDs are unnecessary, or even harmful for performance.<p>I&#x27;m using sequential integers and created_at&#x2F;updated_at timestamps for internal use, and Cuid2 IDs externally.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;paralleldrive&#x2F;cuid2">https:&#x2F;&#x2F;github.com&#x2F;paralleldrive&#x2F;cuid2</a></div><br/><div id="37734555" class="c"><input type="checkbox" id="c-37734555" checked=""/><div class="controls bullet"><span class="by">BiteCode_dev</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734500">parent</a><span>|</span><a href="#37734487">next</a><span>|</span><label class="collapse" for="c-37734555">[-]</label><label class="expand" for="c-37734555">[4 more]</label></div><br/><div class="children"><div class="content">What benefice over uuid4 ?</div><br/><div id="37735247" class="c"><input type="checkbox" id="c-37735247" checked=""/><div class="controls bullet"><span class="by">matharmin</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734555">parent</a><span>|</span><a href="#37734771">next</a><span>|</span><label class="collapse" for="c-37735247">[-]</label><label class="expand" for="c-37735247">[1 more]</label></div><br/><div class="children"><div class="content">Reading their docs: No real benefits, just misconceptions.<p>1. Collision resistance &#x2F; &quot;weak&quot; PRGNs used to generate UUIDv4. Firstly, these are properties of the <i>implementation</i>, not the spec. Secondly, the source for calling the browser `Crypto.getRandomValues()` insecure is an issue that has been fixed back in 2016. I would not trust the developers of this implementation to do a better job than current browsers.<p>2. &quot;Not URL or name friendly&quot;: Fair, but not very strong argument.<p>3. &quot;Horizontally scalable&quot; and &quot;offline-capable&quot;: No argument given for why UUIDv4 does not meet these requirements, apart from point 1 above.<p>4. &quot;Too fast&quot;: No argument given for why having a slower algorithm to generate random ids is more secure. Both UUIDv4 and Cuid2 use a similar number of random bits (122-124). When using a secure PRNG, both are equally difficult to guess, the SHA3 hashing doesn&#x27;t add anything. You don&#x27;t have to try and guess the &quot;input&quot; of the Cuid2 - you can just try to guess the &quot;output&quot; and skip the SHA3 hashing. It would be impossible to actually guess a generated ID, but UUIDv4 is just as impossible. Also no argument given for why UUIDv7 is fine but UUIDv4 is not.<p>I&#x27;ve used UUIDv4 for genering unique IDs for over 10 years now. I <i>have</i> run into collisions, when I hand-rolled my own implementation for J2ME with major bugs many years ago - ended up with around 20 bits of entropy instead of 122. That&#x27;s not a reason to not use UUIDv4, just a reason to not implement it yourself unless you really know what you&#x27;re doing.</div><br/></div></div><div id="37734771" class="c"><input type="checkbox" id="c-37734771" checked=""/><div class="controls bullet"><span class="by">pfix</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734555">parent</a><span>|</span><a href="#37735247">prev</a><span>|</span><a href="#37734487">next</a><span>|</span><label class="collapse" for="c-37734771">[-]</label><label class="expand" for="c-37734771">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a comparison in the README of the project:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;paralleldrive&#x2F;cuid2#the-contenders">https:&#x2F;&#x2F;github.com&#x2F;paralleldrive&#x2F;cuid2#the-contenders</a><p>Some of the arguments mentioned are explained elsewhere in the README, others are assumed.<p>One argument standing out for me is the lack of collision-resistance for UUIDv4 which is surprising for me and I didn&#x27;t spot any sources for that argument.<p>Another argument is the entropy source where they go about that Math.random is not reliable as a single entropy source but glimpsing at the source code, they sprinkle the CUID with Math.random data.<p>I am no expert in ID security, so I am not qualified to speak about the validity of their arguments, only that there&#x27;s insufficient information to validate without prior knowledge about the problem domain.</div><br/><div id="37734964" class="c"><input type="checkbox" id="c-37734964" checked=""/><div class="controls bullet"><span class="by">forty</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734771">parent</a><span>|</span><a href="#37734487">next</a><span>|</span><label class="collapse" for="c-37734964">[-]</label><label class="expand" for="c-37734964">[1 more]</label></div><br/><div class="children"><div class="content">crypto.randomUUID should generate UUIDv4 with a cryptographically secure RNG (ie not math.random)<p>Collision of UUIDV4 (which are 122 bits of entropy) are unlikely enough that it should fit most definitions of the word &quot;impossible&quot;.<p>The argument listed in this library README feels like total bullshit to me, I&#x27;d avoid using it for this reason alone.</div><br/></div></div></div></div></div></div></div></div><div id="37734487" class="c"><input type="checkbox" id="c-37734487" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#37733717">parent</a><span>|</span><a href="#37734500">prev</a><span>|</span><a href="#37734563">next</a><span>|</span><label class="collapse" for="c-37734487">[-]</label><label class="expand" for="c-37734487">[6 more]</label></div><br/><div class="children"><div class="content">Thinking that harder-to-guess IDs will mitigate attacks is an example of security by obscurity. It&#x27;s better to think of any IDs in your database as being public knowledge, because they will leak anyway. Assuming that no one can guess another ID leads to shoddy practices. I generally keep IDs sequential and build security around the basic assumption that IDs are not keys, passwords, sessions, or secrets - they&#x27;re just the public matching identifier for those things.<p>To that end, I think it&#x27;s neat to be able to improve indexing on UUIDs, but it&#x27;s not a security solution.</div><br/><div id="37735536" class="c"><input type="checkbox" id="c-37735536" checked=""/><div class="controls bullet"><span class="by">ivan_gammel</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734487">parent</a><span>|</span><a href="#37734559">next</a><span>|</span><label class="collapse" for="c-37735536">[-]</label><label class="expand" for="c-37735536">[1 more]</label></div><br/><div class="children"><div class="content">Security by obscurity is a working solution if implemented with other measures. It increases the cost of attack, which in the presence of unknown vulnerabilities gives you precious time to respond.</div><br/></div></div><div id="37734559" class="c"><input type="checkbox" id="c-37734559" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734487">parent</a><span>|</span><a href="#37735536">prev</a><span>|</span><a href="#37734563">next</a><span>|</span><label class="collapse" for="c-37734559">[-]</label><label class="expand" for="c-37734559">[4 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t that still leak (statistical) information?<p>It may not be technically security, but e.g. knowing your competitor just added N products to their shop, might be a security issue for the business.</div><br/><div id="37734935" class="c"><input type="checkbox" id="c-37734935" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734559">parent</a><span>|</span><a href="#37734580">next</a><span>|</span><label class="collapse" for="c-37734935">[-]</label><label class="expand" for="c-37734935">[2 more]</label></div><br/><div class="children"><div class="content">It may. Certainly, for instance, sequential invoice numbers do. If a business decides to take measures to obscure that, no problem. All I&#x27;m saying is that obscuring a numbering system for data artifacts shouldn&#x27;t be considered any sort of security as far as keeping your endpoints from being hacked.</div><br/><div id="37735428" class="c"><input type="checkbox" id="c-37735428" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734935">parent</a><span>|</span><a href="#37734580">next</a><span>|</span><label class="collapse" for="c-37735428">[-]</label><label class="expand" for="c-37735428">[1 more]</label></div><br/><div class="children"><div class="content">The point on invoice-numbers brings another issue to mind.<p>We model our domain(s) using DDD, and often &quot;The ID&quot; really is best left a thing with meaning. Customer-id, Bank-account-number, invoice-number, email, etc. At least within the domain, it is. The business (and laws etc) already ensure there can only ever be one invoice with this number. 
Its terribly counterproductive to have two ID&#x27;s for something. &quot;Hey, can you have a look at invoice 20230233, because it seems the VAT was applied wrong. Hmm, do you have the UUID for that invoice and DM me that? You know, the long one with the hyphens&quot;.<p>I guess there isn&#x27;t a one-size-fits all solution and that &quot;it depends&quot; very much on what e.g. &quot;public&quot; means.</div><br/></div></div></div></div><div id="37734580" class="c"><input type="checkbox" id="c-37734580" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734559">parent</a><span>|</span><a href="#37734935">prev</a><span>|</span><a href="#37734563">next</a><span>|</span><label class="collapse" for="c-37734580">[-]</label><label class="expand" for="c-37734580">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re absolutely right, this is also why you generally encrypt sessionized or &quot;consistent view&quot; pagination tokens for public apis (save for primitives like ddb or Kafka)<p>The end user should know no details about your internal key space.</div><br/></div></div></div></div></div></div><div id="37734563" class="c"><input type="checkbox" id="c-37734563" checked=""/><div class="controls bullet"><span class="by">woile</span><span>|</span><a href="#37733717">parent</a><span>|</span><a href="#37734487">prev</a><span>|</span><a href="#37734011">next</a><span>|</span><label class="collapse" for="c-37734563">[-]</label><label class="expand" for="c-37734563">[1 more]</label></div><br/><div class="children"><div class="content">Could you explain a bit more how it would be a risk? Maybe for session tokens is understandable. But why leaking account created info is a problem?</div><br/></div></div><div id="37734011" class="c"><input type="checkbox" id="c-37734011" checked=""/><div class="controls bullet"><span class="by">andrewmatte</span><span>|</span><a href="#37733717">parent</a><span>|</span><a href="#37734563">prev</a><span>|</span><a href="#37733334">next</a><span>|</span><label class="collapse" for="c-37734011">[-]</label><label class="expand" for="c-37734011">[9 more]</label></div><br/><div class="children"><div class="content">jonhohle, thanks. Do you know of examples of when milliseconds are part of the session tokens or accounts being created has been exploited?</div><br/><div id="37734260" class="c"><input type="checkbox" id="c-37734260" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734011">parent</a><span>|</span><a href="#37734327">next</a><span>|</span><label class="collapse" for="c-37734260">[-]</label><label class="expand" for="c-37734260">[3 more]</label></div><br/><div class="children"><div class="content">The German tank production capacity was estimated by serial numbers of captured tanks. There are ways to read all kinds of information by observing energy usage. High resolution time and sequence data undoubtedly reveal more than you’d like.</div><br/><div id="37734577" class="c"><input type="checkbox" id="c-37734577" checked=""/><div class="controls bullet"><span class="by">CSDude</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734260">parent</a><span>|</span><a href="#37734327">next</a><span>|</span><label class="collapse" for="c-37734577">[-]</label><label class="expand" for="c-37734577">[2 more]</label></div><br/><div class="children"><div class="content">Most of our lives as boring SaaS etc. software developer will not be near as exciting as this, but of course you may never know.<p>I parsed the EV chargers APIs  where I live (using Frida in Android) and one of the fields returned the daily revenue and profit.</div><br/><div id="37735163" class="c"><input type="checkbox" id="c-37735163" checked=""/><div class="controls bullet"><span class="by">t0mas88</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734577">parent</a><span>|</span><a href="#37734327">next</a><span>|</span><label class="collapse" for="c-37735163">[-]</label><label class="expand" for="c-37735163">[1 more]</label></div><br/><div class="children"><div class="content">Could be quite useful information to competing charger networks or in future M&amp;A discussions.<p>I&#x27;ve seen a project for a trading firm that inferred all kinds of traffic and revenue numbers for companies before their quarterly earnings were made public. It wasn&#x27;t perfect, but knowing with a certain confidence level whether the numbers were going to be better or worse than estimate was profitable for them.</div><br/></div></div></div></div></div></div><div id="37734327" class="c"><input type="checkbox" id="c-37734327" checked=""/><div class="controls bullet"><span class="by">BWStearns</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734011">parent</a><span>|</span><a href="#37734260">prev</a><span>|</span><a href="#37733334">next</a><span>|</span><label class="collapse" for="c-37734327">[-]</label><label class="expand" for="c-37734327">[5 more]</label></div><br/><div class="children"><div class="content">I could imagine using the timestamp segment of publicly observable ids to estimate activity patterns in an organization. Probably not super crucial and there are probably easier ways in most cases but it could be a big deal at the right moment and for the right target. This could be like a more refined version of PIZZAINT (where you can detect impending policy&#x2F;operational movements by the quantity of food deliveries to a government organization).</div><br/><div id="37734336" class="c"><input type="checkbox" id="c-37734336" checked=""/><div class="controls bullet"><span class="by">rhaps0dy</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734327">parent</a><span>|</span><a href="#37733334">next</a><span>|</span><label class="collapse" for="c-37734336">[-]</label><label class="expand" for="c-37734336">[4 more]</label></div><br/><div class="children"><div class="content">Is PIZZAINT real? I thought it was a joke. How do you even find out how much pizza is being delivered?</div><br/><div id="37734383" class="c"><input type="checkbox" id="c-37734383" checked=""/><div class="controls bullet"><span class="by">BWStearns</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734336">parent</a><span>|</span><a href="#37733334">next</a><span>|</span><label class="collapse" for="c-37734383">[-]</label><label class="expand" for="c-37734383">[3 more]</label></div><br/><div class="children"><div class="content">In ye olden days you had a minion sitting in a car watching the front gate with a notepad and enough cigarettes to last the night.<p>Pizza itself might be a bit of a joke but looking for non-operational behavioral changes is absolutely real. The Cuban missile crisis was started in part because soviets played soccer and Cubans played baseball and the presence of soccer fields helped confirm soviet presence (in enough numbers to bother making rec centers). A more advanced version might be the public Strava data leaking US base layouts and locations or Strava helping the Ukrainians kill a Russian submarine commander.<p>Edit to add: you could also just figure out where your target orders pizza from and pay one of the dudes working there to tell you when there’s a spike in deliveries to your target.</div><br/><div id="37734551" class="c"><input type="checkbox" id="c-37734551" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734383">parent</a><span>|</span><a href="#37733334">next</a><span>|</span><label class="collapse" for="c-37734551">[-]</label><label class="expand" for="c-37734551">[2 more]</label></div><br/><div class="children"><div class="content">&gt; soviets played soccer and Cubans played baseball<p>It&#x27;s a Henri Kissinger&#x27;s quote, but it&#x27;s not accurate: Cubans do in fact play football. Also this quote wasn&#x27;t from the 1962 Cuban missile crisis, but to another event in 1970. That being said, it is true that the US intelligence got warned by the construction of football fields (or maybe even more so by the lack of baseball grounds).<p><a href="https:&#x2F;&#x2F;www.cracked.com&#x2F;article_31335_that-time-soccer-fields-nearly-caused-another-cuban-missile-crisis.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cracked.com&#x2F;article_31335_that-time-soccer-field...</a></div><br/><div id="37735092" class="c"><input type="checkbox" id="c-37735092" checked=""/><div class="controls bullet"><span class="by">yard2010</span><span>|</span><a href="#37733717">root</a><span>|</span><a href="#37734551">parent</a><span>|</span><a href="#37733334">next</a><span>|</span><label class="collapse" for="c-37735092">[-]</label><label class="expand" for="c-37735092">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s Goodhart&#x27;s law, if you want to know something instead of asking just say something which is wrong and someone will correct you</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37733334" class="c"><input type="checkbox" id="c-37733334" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#37733717">prev</a><span>|</span><a href="#37735280">next</a><span>|</span><label class="collapse" for="c-37733334">[-]</label><label class="expand" for="c-37733334">[22 more]</label></div><br/><div class="children"><div class="content">I find it interesting that it’s quoted random IDs are bad for performance, because it’s actually better for distributed storage systems because you don’t hotspot on a single node. For example see: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;53901549" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;53901549</a> and <a href="https:&#x2F;&#x2F;medium.com&#x2F;google-cloud&#x2F;cloud-spanner-choosing-the-right-primary-keys-cd2a47c7b52d" rel="nofollow noreferrer">https:&#x2F;&#x2F;medium.com&#x2F;google-cloud&#x2F;cloud-spanner-choosing-the-r...</a></div><br/><div id="37733384" class="c"><input type="checkbox" id="c-37733384" checked=""/><div class="controls bullet"><span class="by">chacham15</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37733376">next</a><span>|</span><label class="collapse" for="c-37733384">[-]</label><label class="expand" for="c-37733384">[6 more]</label></div><br/><div class="children"><div class="content">They can be bad for performance. It all depends on your access patterns. A common caching pattern is called &quot;temporal locality&quot; which means that theres a high likelihood that data created at the same time will be accessed at the same time. Therefore, if these pieces of information are on the same machine, they can be queried &#x2F; returned much faster than if they were both on separate machines. This is doubly true if theres a data dependency between them. E.g. SELECT x + y or SELECT x WHERE y = &#x27;foo&#x27;.</div><br/><div id="37734608" class="c"><input type="checkbox" id="c-37734608" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37733384">parent</a><span>|</span><a href="#37733565">next</a><span>|</span><label class="collapse" for="c-37734608">[-]</label><label class="expand" for="c-37734608">[1 more]</label></div><br/><div class="children"><div class="content">We solved that with UUIDS and updated_at and created_at columns. The latter the default sort in all views and queries. So the btree&#x2F;indexing issues were hardly an issue. Whenever you fetch a set of rows, they will be bounded by these timestamps.<p>We even sharded on these columns, because of this (our business case made it so that hardly ever did people need data over multiple months)<p>But we never encountered distribution issues. I don&#x27;t think the locality issue will be solved, as postgres doesn&#x27;t consider other columns when distributing data, only the primary key IIRC. I don&#x27;t know why we never saw this, though.</div><br/></div></div><div id="37733565" class="c"><input type="checkbox" id="c-37733565" checked=""/><div class="controls bullet"><span class="by">stepanhruda</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37733384">parent</a><span>|</span><a href="#37734608">prev</a><span>|</span><a href="#37734587">next</a><span>|</span><label class="collapse" for="c-37733565">[-]</label><label class="expand" for="c-37733565">[3 more]</label></div><br/><div class="children"><div class="content">Yes but if that machine with sequential data receives 100x the traffic of other machines, it can be worse than splitting this traffic evenly across all available machines.</div><br/><div id="37734332" class="c"><input type="checkbox" id="c-37734332" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37733565">parent</a><span>|</span><a href="#37734012">next</a><span>|</span><label class="collapse" for="c-37734332">[-]</label><label class="expand" for="c-37734332">[1 more]</label></div><br/><div class="children"><div class="content">It depends if you have a request covers a lot of sequential data, or if you have a lot of requests of sequential data.</div><br/></div></div><div id="37734012" class="c"><input type="checkbox" id="c-37734012" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37733565">parent</a><span>|</span><a href="#37734332">prev</a><span>|</span><a href="#37734587">next</a><span>|</span><label class="collapse" for="c-37734012">[-]</label><label class="expand" for="c-37734012">[1 more]</label></div><br/><div class="children"><div class="content">If your database simply shards keys sequentially, it&#x27;s going to get hotspots in a lot of use cases, like plain old integer keys and timestamps, not just UUIDv7. In that case it would be fair to say that your database is doing it wrong.<p>Fortunately, there&#x27;s no rule that says you should shard your keys using the sequential part up front.<p>One of the rules for generating randomness from environmental sources is to throw away the high bits and only use the low bits. Distributed databases should do the same if they want a good distribution.</div><br/></div></div></div></div><div id="37734587" class="c"><input type="checkbox" id="c-37734587" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37733384">parent</a><span>|</span><a href="#37733565">prev</a><span>|</span><a href="#37733376">next</a><span>|</span><label class="collapse" for="c-37734587">[-]</label><label class="expand" for="c-37734587">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re working on a multi-user system, particularly one with hundreds of requests per second, there is no locality of ids. Two of my actions are separated by a sea of actions by other users.</div><br/></div></div></div></div><div id="37733376" class="c"><input type="checkbox" id="c-37733376" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37733384">prev</a><span>|</span><a href="#37733375">next</a><span>|</span><label class="collapse" for="c-37733376">[-]</label><label class="expand" for="c-37733376">[3 more]</label></div><br/><div class="children"><div class="content">UUIDv7:  Timestamp up front,  random in the back.</div><br/><div id="37733646" class="c"><input type="checkbox" id="c-37733646" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37733376">parent</a><span>|</span><a href="#37733425">next</a><span>|</span><label class="collapse" for="c-37733646">[-]</label><label class="expand" for="c-37733646">[1 more]</label></div><br/><div class="children"><div class="content">I know HN doesn&#x27;t like jokes, but this is really funny. And the subcomment about mullets too.<p>(for folks who don&#x27;t get it, mullets are a 1980s haircut (think MacGyver) with a short front but a long tail in the back. A funny description of them is &quot;business in the front, party in the back&quot;)</div><br/></div></div><div id="37733425" class="c"><input type="checkbox" id="c-37733425" checked=""/><div class="controls bullet"><span class="by">labster</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37733376">parent</a><span>|</span><a href="#37733646">prev</a><span>|</span><a href="#37733375">next</a><span>|</span><label class="collapse" for="c-37733425">[-]</label><label class="expand" for="c-37733425">[1 more]</label></div><br/><div class="children"><div class="content">Truly, the mullet of unique identifiers.</div><br/></div></div></div></div><div id="37733375" class="c"><input type="checkbox" id="c-37733375" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37733376">prev</a><span>|</span><a href="#37734277">next</a><span>|</span><label class="collapse" for="c-37733375">[-]</label><label class="expand" for="c-37733375">[1 more]</label></div><br/><div class="children"><div class="content">In all the distributed systems I’ve built I hashed the keys to ensure good distribution.  A nice thing of ordered keys is you can use part of the ordering to distribute keys with a tunable amount of key locality in each node for efficiency.</div><br/></div></div><div id="37734277" class="c"><input type="checkbox" id="c-37734277" checked=""/><div class="controls bullet"><span class="by">sj26</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37733375">prev</a><span>|</span><a href="#37734584">next</a><span>|</span><label class="collapse" for="c-37734277">[-]</label><label class="expand" for="c-37734277">[1 more]</label></div><br/><div class="children"><div class="content">It Depends(tm).<p>If you&#x27;re using a system which is built for distribution, random is great.<p>When you&#x27;re leaning on a Postgres database which has powered your startup through scaling but expects right-leaning btree indexes, it&#x27;s a bad time.<p>Rearchitecting to use a new data store is ideal, but often impractical as an immediate step. UUIDv7 is a great increment walking that road via sharding etc.</div><br/></div></div><div id="37734584" class="c"><input type="checkbox" id="c-37734584" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37734277">prev</a><span>|</span><a href="#37734108">next</a><span>|</span><label class="collapse" for="c-37734584">[-]</label><label class="expand" for="c-37734584">[2 more]</label></div><br/><div class="children"><div class="content">Depends how you query it. In a lot of systems, recently added data is also the most queried data or data typically gets pulled out sorted by time. Having that data on disk in more or less the order it is going to be queried makes sorting it a bit easier. Even in a sharded system, each of the shards would have less work to do for sorting. Of course a lot of these systems would have an append only write model which would effectively sort things by time anyway, even with completely random ids.<p>Somebody posted an interesting article for the instagram ids, which do something similar. They use 41 bits for a time from a custom epoch followed two more groups of bits for a shard id and a sequential number. Each shard has an incrementing sequence for the sequential bit, which guarantees that things on a shard are sorted by time.<p>This UUIDv7 is slightly weaker than that but sorting things published in the same millisecond is mostly going to be very light work. The lack of a dedicated sharding group of bits is not that important as you could just take the n least significant bits at the end for that without too much effort. Those are random so you end up with nice consistent hashing. Having 48 instead of 41 bits  for the time means we won&#x27;t run out of time any time soon (nearly 9K years vs. 70 years).</div><br/><div id="37735565" class="c"><input type="checkbox" id="c-37735565" checked=""/><div class="controls bullet"><span class="by">gregw2</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37734584">parent</a><span>|</span><a href="#37734108">next</a><span>|</span><label class="collapse" for="c-37735565">[-]</label><label class="expand" for="c-37735565">[1 more]</label></div><br/><div class="children"><div class="content">An explicit shard id can ensure all related data across all tables can be on the same shard. Helpful for SQL JOIN operations.<p>Picking the N least significant bits only a single table has good distribution and sort qualities, no cross-table properties.</div><br/></div></div></div></div><div id="37734108" class="c"><input type="checkbox" id="c-37734108" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37734584">prev</a><span>|</span><a href="#37734792">next</a><span>|</span><label class="collapse" for="c-37734108">[-]</label><label class="expand" for="c-37734108">[1 more]</label></div><br/><div class="children"><div class="content">It can be bad for performance due to how b-trees work in databases, and more pronounced when you have a clustered index.</div><br/></div></div><div id="37734792" class="c"><input type="checkbox" id="c-37734792" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37734108">prev</a><span>|</span><a href="#37733567">next</a><span>|</span><label class="collapse" for="c-37734792">[-]</label><label class="expand" for="c-37734792">[1 more]</label></div><br/><div class="children"><div class="content">As far as I understand, you want to have a random shard position, but once you have found a shard you want that index operation to be cache friendly. When choosing a shard, you can always use the last N bits or use some consistent hashing strategy[1]<p>[1]: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Consistent_hashing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Consistent_hashing</a></div><br/></div></div><div id="37733567" class="c"><input type="checkbox" id="c-37733567" checked=""/><div class="controls bullet"><span class="by">stingraycharles</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37734792">prev</a><span>|</span><a href="#37733465">next</a><span>|</span><label class="collapse" for="c-37733567">[-]</label><label class="expand" for="c-37733567">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the use case. If, for example, you store things on disk ordered by these IDs, and access patterns to your dataset are related to time (e.g. more recently created data is accessed more frequently), it will help a lot to have this data ordered by time.<p>This is especially useful when your underlying database stores data in large &quot;chunks&quot;, such as LSM-trees you find with e.g. rocksdb.</div><br/></div></div><div id="37733465" class="c"><input type="checkbox" id="c-37733465" checked=""/><div class="controls bullet"><span class="by">moralestapia</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37733567">prev</a><span>|</span><a href="#37733480">next</a><span>|</span><label class="collapse" for="c-37733465">[-]</label><label class="expand" for="c-37733465">[1 more]</label></div><br/><div class="children"><div class="content">Agree, but the solution is easy peasy with a simple hash function.<p>(Or just reverse the bits, take the last n, etc)</div><br/></div></div><div id="37733480" class="c"><input type="checkbox" id="c-37733480" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37733465">prev</a><span>|</span><a href="#37733350">next</a><span>|</span><label class="collapse" for="c-37733480">[-]</label><label class="expand" for="c-37733480">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s bad for performance if you frequently access large consecutive sets of records.</div><br/><div id="37734614" class="c"><input type="checkbox" id="c-37734614" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37733480">parent</a><span>|</span><a href="#37733350">next</a><span>|</span><label class="collapse" for="c-37734614">[-]</label><label class="expand" for="c-37734614">[1 more]</label></div><br/><div class="children"><div class="content">UUIDs are good for data where I want either lots of different users being able to insert without collision, or lots of users who I want to keep their peepers off of other user&#x27;s metadata (eg, how many X they add to the system per day).<p>In both cases I&#x27;m melding highly disjointed data into a single schema. There are no large consecutive sets of records.<p>If you&#x27;re using UUIDs, there&#x27;s probably a reason. And that reason invalidates the justifications for not using them.</div><br/></div></div></div></div><div id="37733350" class="c"><input type="checkbox" id="c-37733350" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#37733334">parent</a><span>|</span><a href="#37733480">prev</a><span>|</span><a href="#37735280">next</a><span>|</span><label class="collapse" for="c-37733350">[-]</label><label class="expand" for="c-37733350">[2 more]</label></div><br/><div class="children"><div class="content">They likely mean it’s good for latency and not necessarily for throughput.<p>I still think that graph databases are way better for this sort of thing.</div><br/><div id="37733390" class="c"><input type="checkbox" id="c-37733390" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#37733334">root</a><span>|</span><a href="#37733350">parent</a><span>|</span><a href="#37735280">next</a><span>|</span><label class="collapse" for="c-37733390">[-]</label><label class="expand" for="c-37733390">[1 more]</label></div><br/><div class="children"><div class="content">They later note most of this traffic is going to a single postgres instance. Having all the keys go to the same range probably helps throughput because they can do a better job of grouping fsync. But that probably depends on the type of drives they are using (even fast NVMe benefit from locality).</div><br/></div></div></div></div></div></div><div id="37735280" class="c"><input type="checkbox" id="c-37735280" checked=""/><div class="controls bullet"><span class="by">wvh</span><span>|</span><a href="#37733334">prev</a><span>|</span><a href="#37734682">next</a><span>|</span><label class="collapse" for="c-37735280">[-]</label><label class="expand" for="c-37735280">[1 more]</label></div><br/><div class="children"><div class="content">A few years back, I wrote some code that generates a sortable 128-bit UUID-like identifier starting with a milliseconds-since-epoch timestamp, a node number and a random byte tail. It has been working fine in Postgresql, using its builtin UUID type. I suppose downstream system have been using the string representation though. The main reason for going such an identifier was being able to generate them from different, non-centralised places. A nice side effect is that you can&#x27;t accidentally get an erroneous ID that happens to work the way you can with a sequential integer primary key.<p>For another project, I&#x27;ve also used sortable 64-bit snowflake-like identifiers; they have the added benefit of being able to use 64-bit integer representation in code and database identifiers, even if you might want to externally represent them in base58 or similar encoding.<p>The original UUID types aren&#x27;t as useful as they once were, so it&#x27;d be worth writing a new RFC and extending those original types.</div><br/></div></div><div id="37734682" class="c"><input type="checkbox" id="c-37734682" checked=""/><div class="controls bullet"><span class="by">dajonker</span><span>|</span><a href="#37735280">prev</a><span>|</span><a href="#37735553">next</a><span>|</span><label class="collapse" for="c-37734682">[-]</label><label class="expand" for="c-37734682">[1 more]</label></div><br/><div class="children"><div class="content">Similar to the old situation in the article, we are using sequential 64 bit primary keys, but we use an additional random 64 bit key for external usage (instead of 128 bit).<p>The external key is base64 encoded for use in URLs which results in an 11 byte string.<p>This hides any information about the size of the data, the creation date of customer accounts (which would be sort of visible with UUIDv7) and prevents anyone from attempting to enumerate data by changing the integer in URLs.<p>I thought about using UUIDs as external keys but the only compelling use case seems to be the ability to generate keys from many decoupled sources that have to be merged later.<p>64 bit should be enough for most things <a href="https:&#x2F;&#x2F;youtu.be&#x2F;gocwRvLhDf8?si=QBheJCG21bAAV0Z7" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;gocwRvLhDf8?si=QBheJCG21bAAV0Z7</a></div><br/></div></div><div id="37735553" class="c"><input type="checkbox" id="c-37735553" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#37734682">prev</a><span>|</span><a href="#37735433">next</a><span>|</span><label class="collapse" for="c-37735553">[-]</label><label class="expand" for="c-37735553">[1 more]</label></div><br/><div class="children"><div class="content">Always wondered what the point of dash-separating uuid if the separated parts are unreadable anyway just like in this version, just makes it harder to select as a single blob of text</div><br/></div></div><div id="37735433" class="c"><input type="checkbox" id="c-37735433" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37735553">prev</a><span>|</span><a href="#37733526">next</a><span>|</span><label class="collapse" for="c-37735433">[-]</label><label class="expand" for="c-37735433">[2 more]</label></div><br/><div class="children"><div class="content">As a beginner I treated and understood (SQL) databases as something I have to use in order to store stuff.<p>Later I was excited about the power and expressiveness of SQL and its extensions. There is a ton of leverage and you can make it so that interfacing with it directly becomes much more useful.<p>However now I’m in a different phase. I see it as a durable data structure. I think in terms of “what does it provide to make the overall system better?”<p>The issues around indexing and uuids that is discussed in the article fits nicely into this line of thinking.<p>In web development, database access and performance often dominates and infects the whole system.</div><br/><div id="37735546" class="c"><input type="checkbox" id="c-37735546" checked=""/><div class="controls bullet"><span class="by">foreigner</span><span>|</span><a href="#37735433">parent</a><span>|</span><a href="#37733526">next</a><span>|</span><label class="collapse" for="c-37735546">[-]</label><label class="expand" for="c-37735546">[1 more]</label></div><br/><div class="children"><div class="content">As a beginner I thought of the database as a backend for the app. Now I think of the app as a frontend for the database. :-D</div><br/></div></div></div></div><div id="37733526" class="c"><input type="checkbox" id="c-37733526" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#37735433">prev</a><span>|</span><a href="#37733316">next</a><span>|</span><label class="collapse" for="c-37733526">[-]</label><label class="expand" for="c-37733526">[6 more]</label></div><br/><div class="children"><div class="content">&gt; We use sequential primary keys for efficient indexing, and UUID secondary keys for external use. The upcoming UUIDv7 standard offers the best of both worlds<p>Unless you consider users being able to extract the generation time from the id to be an issue, of course.</div><br/><div id="37733551" class="c"><input type="checkbox" id="c-37733551" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#37733526">parent</a><span>|</span><a href="#37733316">next</a><span>|</span><label class="collapse" for="c-37733551">[-]</label><label class="expand" for="c-37733551">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been seeing a few different vendors do this already. MongoDB&#x27;s ObjectIds are inherently timestamps (so you can actually generate generic MongoDB IDs to query based on time). There&#x27;s also Discord&#x27;s Snowflakes as well. I&#x27;m sure there&#x27;s loads of others. All it tells you is when something was generated, not much else. I do love how MongoDB has it stored in such a way that it is easy to query against. I wonder if any RDBMS&#x27; will allow you to query these timestamps as well.</div><br/><div id="37733611" class="c"><input type="checkbox" id="c-37733611" checked=""/><div class="controls bullet"><span class="by">andersa</span><span>|</span><a href="#37733526">root</a><span>|</span><a href="#37733551">parent</a><span>|</span><a href="#37733316">next</a><span>|</span><label class="collapse" for="c-37733611">[-]</label><label class="expand" for="c-37733611">[4 more]</label></div><br/><div class="children"><div class="content">There are definitely many cases where it isn&#x27;t an issue since you were going to tell the user the time anyway (like sent time on a message)</div><br/><div id="37733887" class="c"><input type="checkbox" id="c-37733887" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#37733526">root</a><span>|</span><a href="#37733611">parent</a><span>|</span><a href="#37733718">next</a><span>|</span><label class="collapse" for="c-37733887">[-]</label><label class="expand" for="c-37733887">[2 more]</label></div><br/><div class="children"><div class="content">Can’t agree with that logic. Unless it’s specifically documented leaking timestamp data is going to get totally forgotten. So when you add (e.g.) the ability to change the sent timestamp on a message you’re going to inadvertently leak when a timestamp has been changed. Could cause embarrassment in a lot of scenarios.</div><br/><div id="37735106" class="c"><input type="checkbox" id="c-37735106" checked=""/><div class="controls bullet"><span class="by">zo1</span><span>|</span><a href="#37733526">root</a><span>|</span><a href="#37733887">parent</a><span>|</span><a href="#37733718">next</a><span>|</span><label class="collapse" for="c-37735106">[-]</label><label class="expand" for="c-37735106">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of that recent investigation regarding fudged data in those Harvard studies. The fields stored the &quot;original&quot; ID, solidifying their creation sequence, which differed to the displayed sequence - Implying that the fields were updated out-of-sequence, thereby they were tampered with.</div><br/></div></div></div></div><div id="37733718" class="c"><input type="checkbox" id="c-37733718" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#37733526">root</a><span>|</span><a href="#37733611">parent</a><span>|</span><a href="#37733887">prev</a><span>|</span><a href="#37733316">next</a><span>|</span><label class="collapse" for="c-37733718">[-]</label><label class="expand" for="c-37733718">[1 more]</label></div><br/><div class="children"><div class="content">I think Twitter also does it as well. I think its really nice honestly.</div><br/></div></div></div></div></div></div></div></div><div id="37733316" class="c"><input type="checkbox" id="c-37733316" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#37733526">prev</a><span>|</span><a href="#37735024">next</a><span>|</span><label class="collapse" for="c-37733316">[-]</label><label class="expand" for="c-37733316">[9 more]</label></div><br/><div class="children"><div class="content">And you can use it today with Postgres uuid type. Postgres doesn’t care what you store in it as long as it has the correct length. So you can generate a uuidv7 and store it natively</div><br/><div id="37733563" class="c"><input type="checkbox" id="c-37733563" checked=""/><div class="controls bullet"><span class="by">hardwaresofton</span><span>|</span><a href="#37733316">parent</a><span>|</span><a href="#37733558">next</a><span>|</span><label class="collapse" for="c-37733563">[-]</label><label class="expand" for="c-37733563">[1 more]</label></div><br/><div class="children"><div class="content">Yup this is one of the reasons I put together a light extension for this:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;VADOSWARE&#x2F;pg_idkit">https:&#x2F;&#x2F;github.com&#x2F;VADOSWARE&#x2F;pg_idkit</a><p>There are a lot of options for UUID extensions (lots of great pure SQL ones!), but I wanted to get as many ID generation strategies in one place<p>Also note that native UUID v7 is slated to land in pg17:<p><a href="https:&#x2F;&#x2F;commitfest.postgresql.org&#x2F;44&#x2F;4388&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;commitfest.postgresql.org&#x2F;44&#x2F;4388&#x2F;</a></div><br/></div></div><div id="37733558" class="c"><input type="checkbox" id="c-37733558" checked=""/><div class="controls bullet"><span class="by">perfmode</span><span>|</span><a href="#37733316">parent</a><span>|</span><a href="#37733563">prev</a><span>|</span><a href="#37733362">next</a><span>|</span><label class="collapse" for="c-37733558">[-]</label><label class="expand" for="c-37733558">[4 more]</label></div><br/><div class="children"><div class="content">What are the benefits of using the Postgres uuid type (versus using TEXT or VARCHAR)?</div><br/><div id="37733581" class="c"><input type="checkbox" id="c-37733581" checked=""/><div class="controls bullet"><span class="by">jvolkman</span><span>|</span><a href="#37733316">root</a><span>|</span><a href="#37733558">parent</a><span>|</span><a href="#37734019">next</a><span>|</span><label class="collapse" for="c-37733581">[-]</label><label class="expand" for="c-37733581">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s 16 bytes versus 36 bytes.</div><br/></div></div><div id="37734019" class="c"><input type="checkbox" id="c-37734019" checked=""/><div class="controls bullet"><span class="by">gabereiser</span><span>|</span><a href="#37733316">root</a><span>|</span><a href="#37733558">parent</a><span>|</span><a href="#37733581">prev</a><span>|</span><a href="#37733986">next</a><span>|</span><label class="collapse" for="c-37734019">[-]</label><label class="expand" for="c-37734019">[1 more]</label></div><br/><div class="children"><div class="content">Stored in binary format, validation, more efficient due to non-cast, faster access due to non char*, being able to split the high-low, indexing and uniqueness at the byte level.</div><br/></div></div><div id="37733986" class="c"><input type="checkbox" id="c-37733986" checked=""/><div class="controls bullet"><span class="by">thangngoc89</span><span>|</span><a href="#37733316">root</a><span>|</span><a href="#37733558">parent</a><span>|</span><a href="#37734019">prev</a><span>|</span><a href="#37733362">next</a><span>|</span><label class="collapse" for="c-37733986">[-]</label><label class="expand" for="c-37733986">[1 more]</label></div><br/><div class="children"><div class="content">It’s stored in binary format (16 bytes) instead of text (36 bytes)</div><br/></div></div></div></div><div id="37733362" class="c"><input type="checkbox" id="c-37733362" checked=""/><div class="controls bullet"><span class="by">jolux</span><span>|</span><a href="#37733316">parent</a><span>|</span><a href="#37733558">prev</a><span>|</span><a href="#37735024">next</a><span>|</span><label class="collapse" for="c-37733362">[-]</label><label class="expand" for="c-37733362">[3 more]</label></div><br/><div class="children"><div class="content">Wouldn’t the index types need to be updated to support ordering on UUIDs?</div><br/><div id="37733402" class="c"><input type="checkbox" id="c-37733402" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#37733316">root</a><span>|</span><a href="#37733362">parent</a><span>|</span><a href="#37735024">next</a><span>|</span><label class="collapse" for="c-37733402">[-]</label><label class="expand" for="c-37733402">[2 more]</label></div><br/><div class="children"><div class="content">No, because the ordering is purely byte level which will work perfectly fine here.</div><br/><div id="37733410" class="c"><input type="checkbox" id="c-37733410" checked=""/><div class="controls bullet"><span class="by">jolux</span><span>|</span><a href="#37733316">root</a><span>|</span><a href="#37733402">parent</a><span>|</span><a href="#37735024">next</a><span>|</span><label class="collapse" for="c-37733410">[-]</label><label class="expand" for="c-37733410">[1 more]</label></div><br/><div class="children"><div class="content">Neat</div><br/></div></div></div></div></div></div></div></div><div id="37735024" class="c"><input type="checkbox" id="c-37735024" checked=""/><div class="controls bullet"><span class="by">jimmySixDOF</span><span>|</span><a href="#37733316">prev</a><span>|</span><a href="#37733802">next</a><span>|</span><label class="collapse" for="c-37735024">[-]</label><label class="expand" for="c-37735024">[1 more]</label></div><br/><div class="children"><div class="content">Discussion here a couple months ago :<p>Analyzing New Unique Identifier Formats (UUIDv6, UUIDv7, and UUIDv8) (2022)
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36438367">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36438367</a></div><br/></div></div><div id="37733802" class="c"><input type="checkbox" id="c-37733802" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#37735024">prev</a><span>|</span><a href="#37733931">next</a><span>|</span><label class="collapse" for="c-37733802">[-]</label><label class="expand" for="c-37733802">[10 more]</label></div><br/><div class="children"><div class="content">It seems insane to me to “validate” GUIDs&#x2F;UUIDs.<p>Half the point of these things is that they’re treated as opaque identifiers.</div><br/><div id="37734275" class="c"><input type="checkbox" id="c-37734275" checked=""/><div class="controls bullet"><span class="by">threeseed</span><span>|</span><a href="#37733802">parent</a><span>|</span><a href="#37734075">next</a><span>|</span><label class="collapse" for="c-37734275">[-]</label><label class="expand" for="c-37734275">[3 more]</label></div><br/><div class="children"><div class="content">Because in SPAs if a user creates new entities it can be easier to generate the UUIDs client side.<p>So then just a simple validation server side to ensure the data isn&#x27;t malicious.</div><br/><div id="37734502" class="c"><input type="checkbox" id="c-37734502" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#37733802">root</a><span>|</span><a href="#37734275">parent</a><span>|</span><a href="#37734075">next</a><span>|</span><label class="collapse" for="c-37734502">[-]</label><label class="expand" for="c-37734502">[2 more]</label></div><br/><div class="children"><div class="content">Never trust the client.</div><br/><div id="37734863" class="c"><input type="checkbox" id="c-37734863" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#37733802">root</a><span>|</span><a href="#37734502">parent</a><span>|</span><a href="#37734075">next</a><span>|</span><label class="collapse" for="c-37734863">[-]</label><label class="expand" for="c-37734863">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, you can require them to generate a UUID if it helps for your app (e.g. bulk create objects with relationships between them) but then on the server you can generate new UUIDs and return a mapping from old-&gt;new to the client.</div><br/></div></div></div></div></div></div><div id="37734075" class="c"><input type="checkbox" id="c-37734075" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#37733802">parent</a><span>|</span><a href="#37734275">prev</a><span>|</span><a href="#37734093">next</a><span>|</span><label class="collapse" for="c-37734075">[-]</label><label class="expand" for="c-37734075">[3 more]</label></div><br/><div class="children"><div class="content">I’d assume the validation is parsing the uuid with a uuid library (to decode it), and the library eagerly validates the version field, either to check for garbage or because it wants to yield a different subtype for each version.</div><br/><div id="37734132" class="c"><input type="checkbox" id="c-37734132" checked=""/><div class="controls bullet"><span class="by">philsnow</span><span>|</span><a href="#37733802">root</a><span>|</span><a href="#37734075">parent</a><span>|</span><a href="#37734093">next</a><span>|</span><label class="collapse" for="c-37734132">[-]</label><label class="expand" for="c-37734132">[2 more]</label></div><br/><div class="children"><div class="content">but why decode it at all, if it&#x27;s meant to be opaque?</div><br/><div id="37734297" class="c"><input type="checkbox" id="c-37734297" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#37733802">root</a><span>|</span><a href="#37734132">parent</a><span>|</span><a href="#37734093">next</a><span>|</span><label class="collapse" for="c-37734297">[-]</label><label class="expand" for="c-37734297">[1 more]</label></div><br/><div class="children"><div class="content">I think there are a couple minor problems:<p>- if the ID is intended to be opaque then the vendor shouldn&#x27;t document it as a UUID, as this changing to a different format would be a breaking change<p>- if the customer isn&#x27;t going to process the subcomponents of the UUID then they should process it as an opaque string<p>- if the UUID library encounters a version number in a UUID it doesn&#x27;t understand, it shouldn&#x27;t reject the UUID but present it as an unstructured string.<p>After this blog post it seems likely that even Kite more customer will parse the IDs to extract time, since this has been documented.</div><br/></div></div></div></div></div></div><div id="37734093" class="c"><input type="checkbox" id="c-37734093" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#37733802">parent</a><span>|</span><a href="#37734075">prev</a><span>|</span><a href="#37733931">next</a><span>|</span><label class="collapse" for="c-37734093">[-]</label><label class="expand" for="c-37734093">[3 more]</label></div><br/><div class="children"><div class="content">If UUIDv4 was all that ever existed, there would be no need to validate anything apart of the fact that it&#x27;s supposed to contain 32 hexadecimal characters.<p>All other versions, including the new v7, attach meaning to certain bits of the identifier. That cat has been out of the bag for a long time, so now everyone needs to maintain code to ensure that some rogue node doesn&#x27;t spew back-dated identifiers belonging to the wrong department.</div><br/><div id="37735185" class="c"><input type="checkbox" id="c-37735185" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#37733802">root</a><span>|</span><a href="#37734093">parent</a><span>|</span><a href="#37734348">next</a><span>|</span><label class="collapse" for="c-37735185">[-]</label><label class="expand" for="c-37735185">[1 more]</label></div><br/><div class="children"><div class="content">UUIDv4 also contains some bits with meaning. But joke&#x27;s on them, I tend to even randomize the version bits and call it UUIDv0.</div><br/></div></div><div id="37734348" class="c"><input type="checkbox" id="c-37734348" checked=""/><div class="controls bullet"><span class="by">hawski</span><span>|</span><a href="#37733802">root</a><span>|</span><a href="#37734093">parent</a><span>|</span><a href="#37735185">prev</a><span>|</span><a href="#37733931">next</a><span>|</span><label class="collapse" for="c-37734348">[-]</label><label class="expand" for="c-37734348">[1 more]</label></div><br/><div class="children"><div class="content">UUIDv4 attaches meaning to certain 6 or 7 bits (depending on a variant) of the identifier. UUIDv4 is a UUID after all.</div><br/></div></div></div></div></div></div><div id="37733931" class="c"><input type="checkbox" id="c-37733931" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37733802">prev</a><span>|</span><a href="#37733890">next</a><span>|</span><label class="collapse" for="c-37733931">[-]</label><label class="expand" for="c-37733931">[2 more]</label></div><br/><div class="children"><div class="content">Why use UUIDv7 over ULIDs?<p>As Lazare points out in this thread they&#x27;re basically the same thing, except with ULIDs you get those 6 extra bits of randomness back that UUIDs have to use for metadata.</div><br/><div id="37734762" class="c"><input type="checkbox" id="c-37734762" checked=""/><div class="controls bullet"><span class="by">oittaa</span><span>|</span><a href="#37733931">parent</a><span>|</span><a href="#37733890">next</a><span>|</span><label class="collapse" for="c-37734762">[-]</label><label class="expand" for="c-37734762">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-ietf-uuidrev-rfc4122bis-11#name-motivation" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-ietf-uuidrev-rfc...</a><p>ULID isn&#x27;t an &quot;official&quot; standard like UUID. Having a real standard usually promotes interoperability and makes it easier to use. Additionally as others have pointed out you can already use UUIDv7 with some databases since it&#x27;s just 16 opaque bytes and the database doesn&#x27;t care what&#x27;s actually in the UUID field.</div><br/></div></div></div></div><div id="37733890" class="c"><input type="checkbox" id="c-37733890" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37733931">prev</a><span>|</span><a href="#37735337">next</a><span>|</span><label class="collapse" for="c-37733890">[-]</label><label class="expand" for="c-37733890">[14 more]</label></div><br/><div class="children"><div class="content">&gt; first component (prefix) of the identifier is a sortable timestamp<p>&gt; values generated are practically sequential<p>These statements aren’t strict enough to be relied on. Maybe you have engineered the hell out of your distributed clock scheme, and your IDs actually are completely monotonic, which is great. But you probably haven’t done that, which means conflicts will <i>surely happen</i> and you must handle them gracefully.</div><br/><div id="37734070" class="c"><input type="checkbox" id="c-37734070" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#37733890">parent</a><span>|</span><a href="#37733929">next</a><span>|</span><label class="collapse" for="c-37734070">[-]</label><label class="expand" for="c-37734070">[1 more]</label></div><br/><div class="children"><div class="content">Well yes, but were they even implying that?  Even if it was infinitely strict, clocks being perfect, two server processes can touch the same data at the same time.<p>In other words: Sorting by millisecond-or-so is just as good as sorting by picosecond in most situations.  The reason you have to deal with conflicts gracefully isn&#x27;t particularly because timestamps can be imperfect.</div><br/></div></div><div id="37733929" class="c"><input type="checkbox" id="c-37733929" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#37733890">parent</a><span>|</span><a href="#37734070">prev</a><span>|</span><a href="#37734045">next</a><span>|</span><label class="collapse" for="c-37733929">[-]</label><label class="expand" for="c-37733929">[4 more]</label></div><br/><div class="children"><div class="content">When I&#x27;m using integer surrogate keys to manipulate subsets of a table, they usually correspond to some kind of out-of-band predicate.  Like this is the data that appeared <i>today</i>, or this is everything <i>after the bug happened</i>, etc.<p>Maybe there are applications where the monotonicity matters, but in my experience reasoning by surrogate key is rather coarse grained and you manually scrutinize the boundaries, so unless your clocks are quite wrong, your worries are probably better placed elsewhere.</div><br/><div id="37734043" class="c"><input type="checkbox" id="c-37734043" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37733890">root</a><span>|</span><a href="#37733929">parent</a><span>|</span><a href="#37734045">next</a><span>|</span><label class="collapse" for="c-37734043">[-]</label><label class="expand" for="c-37734043">[3 more]</label></div><br/><div class="children"><div class="content">I’ve seen too many people write a query like<p><pre><code>  where ts between txn_start and txn_end
  order by ts
</code></pre>
and not even realize that what they’re seeing is incomplete and misleading. Clock skew is very common, and we shouldn’t sweep that under the rug to promote time ordering, because people <i>want</i> to believe this works the way they think.</div><br/><div id="37734497" class="c"><input type="checkbox" id="c-37734497" checked=""/><div class="controls bullet"><span class="by">Foobar8568</span><span>|</span><a href="#37733890">root</a><span>|</span><a href="#37734043">parent</a><span>|</span><a href="#37734045">next</a><span>|</span><label class="collapse" for="c-37734497">[-]</label><label class="expand" for="c-37734497">[2 more]</label></div><br/><div class="children"><div class="content">Clock skews in a single node database? Actual question.</div><br/><div id="37734676" class="c"><input type="checkbox" id="c-37734676" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37733890">root</a><span>|</span><a href="#37734497">parent</a><span>|</span><a href="#37734045">next</a><span>|</span><label class="collapse" for="c-37734676">[-]</label><label class="expand" for="c-37734676">[1 more]</label></div><br/><div class="children"><div class="content">Usually Hive or Dremel, with rows ingested from frontend instance logs. I get that it would actually work on a smaller system with a single server assigning times (or a quorum, if leader election ensures a monotonic clock).</div><br/></div></div></div></div></div></div></div></div><div id="37734045" class="c"><input type="checkbox" id="c-37734045" checked=""/><div class="controls bullet"><span class="by">ianbutler</span><span>|</span><a href="#37733890">parent</a><span>|</span><a href="#37733929">prev</a><span>|</span><a href="#37734041">next</a><span>|</span><label class="collapse" for="c-37734045">[-]</label><label class="expand" for="c-37734045">[1 more]</label></div><br/><div class="children"><div class="content">This was my first reaction as well. The keys use a unix timestamp, which are clearly not going to be synchronized by default so for event ordering purposes across a distributed system this is dodgy.<p>For providing better query locality it probably doesn&#x27;t matter significantly though which seems to be the main benefit here while preserving the other benefits UUIDs provide.</div><br/></div></div><div id="37734041" class="c"><input type="checkbox" id="c-37734041" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37733890">parent</a><span>|</span><a href="#37734045">prev</a><span>|</span><a href="#37733901">next</a><span>|</span><label class="collapse" for="c-37734041">[-]</label><label class="expand" for="c-37734041">[3 more]</label></div><br/><div class="children"><div class="content">I feel like it&#x27;s well beyond the scope of UUIDs to get into &quot;are your clocks really monotonic?&quot;. They give you 48 bits for a timestamp, what that timestamp signifies (transactional time, valid time...) and how that&#x27;s generated is up to you.<p>Out of curiosity, are you into hybrid logical clocks?</div><br/><div id="37734328" class="c"><input type="checkbox" id="c-37734328" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37733890">root</a><span>|</span><a href="#37734041">parent</a><span>|</span><a href="#37733901">next</a><span>|</span><label class="collapse" for="c-37734328">[-]</label><label class="expand" for="c-37734328">[2 more]</label></div><br/><div class="children"><div class="content">I only raise this when I see promises that IDs are ordered and can be <i>sorted</i>, not merely grouped by approximate time for storage locality.<p>Yeah, though I’m more likely to go with a region ID and monotonic version number to compare-and-set and verify gapless data, where versions from different regions aren’t comparable. Actually I think earlier UUID RFCs talk about a “clock sequence” to distinguish timestamps from separate monotonic sources, but this paper doesn’t bring that up (or mention multiple clocks at all).</div><br/><div id="37734864" class="c"><input type="checkbox" id="c-37734864" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37733890">root</a><span>|</span><a href="#37734328">parent</a><span>|</span><a href="#37733901">next</a><span>|</span><label class="collapse" for="c-37734864">[-]</label><label class="expand" for="c-37734864">[1 more]</label></div><br/><div class="children"><div class="content">The reason I ask is because I&#x27;m always looking for material around this kind of thing. I read the Hybrid Logical Clocks paper from the university of Buffalo, but then found it if one of your clocks is inaccurate all your timestamps get dragged forward forever.<p>So any thing you can link, let me know.</div><br/></div></div></div></div></div></div><div id="37733901" class="c"><input type="checkbox" id="c-37733901" checked=""/><div class="controls bullet"><span class="by">QuadrupleA</span><span>|</span><a href="#37733890">parent</a><span>|</span><a href="#37734041">prev</a><span>|</span><a href="#37734782">next</a><span>|</span><label class="collapse" for="c-37733901">[-]</label><label class="expand" for="c-37733901">[3 more]</label></div><br/><div class="children"><div class="content">But the timestamp is less than half the bits. The rest are random. So timestamp conflicts don&#x27;t matter.</div><br/><div id="37733953" class="c"><input type="checkbox" id="c-37733953" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#37733890">root</a><span>|</span><a href="#37733901">parent</a><span>|</span><a href="#37734782">next</a><span>|</span><label class="collapse" for="c-37733953">[-]</label><label class="expand" for="c-37733953">[2 more]</label></div><br/><div class="children"><div class="content">By “conflict” I don’t mean a UUID collision, I agree with the logic that 2^128 is so much entropy that memory corruption is the more likely culprit.<p>I mean that you can’t rely for correctness on time(X) &lt; time(Y) when X happened before Y. It’s damn hard to keep two commodity server clocks within ±1 ms of each other even within a single LAN, and across production you’re more likely to see ±10 ms, or worse if your sysadmins don’t realize you intend to bet the farm on no clock skew.</div><br/><div id="37734295" class="c"><input type="checkbox" id="c-37734295" checked=""/><div class="controls bullet"><span class="by">jpgvm</span><span>|</span><a href="#37733890">root</a><span>|</span><a href="#37733953">parent</a><span>|</span><a href="#37734782">next</a><span>|</span><label class="collapse" for="c-37734295">[-]</label><label class="expand" for="c-37734295">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not designed for this use case. It&#x27;s for cases where events in the same epoch may as well of happened concurrently.<p>ULID on the other hand does address this case by providing monotonicity within an epoch for a given producer. So would still need to treat each producer as a separate partition of the key space but you could order X &gt; Y as long as both were produced by same producer (which effectively acts like a sequencer in this case).<p>EDIT: nvm, the UUIDv7 spec -allows- for arbitrary allocation of the remaining 62 bits which can be used as a counter: <a href="https:&#x2F;&#x2F;www.ietf.org&#x2F;archive&#x2F;id&#x2F;draft-peabody-dispatch-new-uuid-format-01.html#name-uuidv7-layout-and-bit-order" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ietf.org&#x2F;archive&#x2F;id&#x2F;draft-peabody-dispatch-new-u...</a>
All points for ULID can also apply to UUIDv7 depending on generation algorithm.</div><br/></div></div></div></div></div></div><div id="37734782" class="c"><input type="checkbox" id="c-37734782" checked=""/><div class="controls bullet"><span class="by">oittaa</span><span>|</span><a href="#37733890">parent</a><span>|</span><a href="#37733901">prev</a><span>|</span><a href="#37735337">next</a><span>|</span><label class="collapse" for="c-37734782">[-]</label><label class="expand" for="c-37734782">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-ietf-uuidrev-rfc4122bis-11#name-distributed-uuid-generation" rel="nofollow noreferrer">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-ietf-uuidrev-rfc...</a></div><br/></div></div></div></div><div id="37735337" class="c"><input type="checkbox" id="c-37735337" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#37733890">prev</a><span>|</span><a href="#37735170">next</a><span>|</span><label class="collapse" for="c-37735337">[-]</label><label class="expand" for="c-37735337">[1 more]</label></div><br/><div class="children"><div class="content">I am just about to wrap up some prototyping comparing snowflake, typeids, uuidv4 and ulid.  Why did I not bump into uuidv7 earlier?!?</div><br/></div></div><div id="37735170" class="c"><input type="checkbox" id="c-37735170" checked=""/><div class="controls bullet"><span class="by">danwee</span><span>|</span><a href="#37735337">prev</a><span>|</span><a href="#37733851">next</a><span>|</span><label class="collapse" for="c-37735170">[-]</label><label class="expand" for="c-37735170">[4 more]</label></div><br/><div class="children"><div class="content">So, how do you guys use UUIDs for real? I worked in a company in which they were using UUIDs in Mongo, and of the most painful things were implementing API endpoints that filter resources. Imagine you have an endpoint in which you are filtering by resources A, B, C and D. Ideally you would end up with something like this:<p><pre><code>    GET &#x2F;filter?a_id=X&amp;b_id=Y&amp;c_id=Z&amp;d_id=w
</code></pre>
But in practice we were using POST and passing the ids in the body payload. Why Because my old team said &quot;the UUIDs are long, so we may reach the maximum URL length if we pass them as parameters&quot;. I didn&#x27;t like it, and I still don&#x27;t like it at all.</div><br/><div id="37735288" class="c"><input type="checkbox" id="c-37735288" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#37735170">parent</a><span>|</span><a href="#37735221">next</a><span>|</span><label class="collapse" for="c-37735288">[-]</label><label class="expand" for="c-37735288">[1 more]</label></div><br/><div class="children"><div class="content">Do you dislike the use of POST because of its effect on caching, or because it doesn’t feel semantically correct? If you don’t need the caching I wouldn’t mind using a POST to filter.<p>Note that you can also use GET with a body, it’s not spec compliant (a body is allowed but not supposed to have any meaning) but is used by products such as Elasticsearch. If you control both clients and servers that’s something you can safely do (and use an etag header for idempotency).</div><br/></div></div><div id="37735221" class="c"><input type="checkbox" id="c-37735221" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37735170">parent</a><span>|</span><a href="#37735288">prev</a><span>|</span><a href="#37733851">next</a><span>|</span><label class="collapse" for="c-37735221">[-]</label><label class="expand" for="c-37735221">[2 more]</label></div><br/><div class="children"><div class="content">The maximum url length is typically quite long.<p>Another thing is that you don’t necessarily need to encode uuids canonically. They are just u128’s. It’s relatively straightforward to find a url friendly string representation that is shorter.</div><br/><div id="37735260" class="c"><input type="checkbox" id="c-37735260" checked=""/><div class="controls bullet"><span class="by">danwee</span><span>|</span><a href="#37735170">root</a><span>|</span><a href="#37735221">parent</a><span>|</span><a href="#37733851">next</a><span>|</span><label class="collapse" for="c-37735260">[-]</label><label class="expand" for="c-37735260">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s relatively straightforward to find a url friendly string representation that is shorter.<p>Are we talking about shortening the whole URL or shortening specific UUIDs? If the latter then I imagine one would still need to keep track of the mapping UUID &lt;-&gt; shorten version, somewhere, right? If so, why not just add yet another field&#x2F;column for an old good numeric integer that can be used for filtering? Would that work?</div><br/></div></div></div></div></div></div><div id="37733851" class="c"><input type="checkbox" id="c-37733851" checked=""/><div class="controls bullet"><span class="by">Lazare</span><span>|</span><a href="#37735170">prev</a><span>|</span><a href="#37735090">next</a><span>|</span><label class="collapse" for="c-37733851">[-]</label><label class="expand" for="c-37733851">[6 more]</label></div><br/><div class="children"><div class="content">UUIDv7 is a nice idea, and should <i>probably</i> be what people use by default instead of UUIDv4 for internal facing uses.<p>For the curious:<p>* UUIDv4 are 128 bits long, 122 bits of which are random, with 6 bits used for the version. Traditionally displayed as 32 hex characters with 4 dashes, so 36 alphanumeric characters, and compatible with anything that expects a UUID.<p>* UUIDv7 are 128 bits long, 48 bits encode a unix timestamp with millisecond precision, 6 bits are for the version, and 74 bits are random. You&#x27;re expected to display them the same as other UUIDs, and should be compatible with <i>basically</i> anything that expects a UUID. (Would be a very odd system that parses a UUID and throws an error because it doesn&#x27;t recognise v7, but I guess it could happen, in theory?)<p>* ULIDs (<a href="https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec">https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec</a>) are 128 bits long, 48 bits encode a unix timestamp with millisecond precision, 80 bits are random. You&#x27;re expected to display them in Crockford&#x27;s base32, so 26 alphanumeric characters. Compatible with almost everything that expects a UUID (since they&#x27;re the right length). Spec has some <i>dumb</i> quirks if followed literally but thankfully they mostly don&#x27;t hurt things.<p>* KSUIDs (<a href="https:&#x2F;&#x2F;github.com&#x2F;segmentio&#x2F;ksuid">https:&#x2F;&#x2F;github.com&#x2F;segmentio&#x2F;ksuid</a>) are 160 bits long, 32 bits encode a timestamp with second precision and a custom epoch of May 13th, 2014, and 128 bits are random. You&#x27;re expected to display them in base62, so 27 alphanumeric characters. Since they&#x27;re a different length, they&#x27;re <i>not</i> compatible with UUIDs.<p>I quite like KSUIDs; I think base62 is a smart choice. And while the timestamp portion is a trickier question, KSUIDs use 32 bits which, with second precision (more than good enough), means they won&#x27;t overflow for well over a century. Whereas UUIDv7s use 48 bits, so even with millisecond precision (not needed) they won&#x27;t overflow for something like 8000 years. We can argue whether 100 years is future proof enough (I&#x27;d argue it is), but 8000 years is just silly. Nobody will ever generate a compliant UUIDv7 with any of the first <i>several</i> bits aren&#x27;t 0. The only downside to KSUIDs is the length isn&#x27;t UUID compatible (and arguably, that they don&#x27;t devote 6 bits to a compliant UUID version).<p>Still feels like there&#x27;s room for improvement, but for now I think I&#x27;d always pick UUIDv7 over UUIDv4 unless there&#x27;s an very specific reason not to. Which would be, mostly, if there&#x27;s a concern over potentially leaking the time the UUID was generated. Although if you weren&#x27;t worrying about leaking an integer sequence ID, you likely won&#x27;t care here either.</div><br/><div id="37734115" class="c"><input type="checkbox" id="c-37734115" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37733851">parent</a><span>|</span><a href="#37734125">next</a><span>|</span><label class="collapse" for="c-37734115">[-]</label><label class="expand" for="c-37734115">[2 more]</label></div><br/><div class="children"><div class="content">Second precision is too coarse for many (most?) use cases.</div><br/><div id="37734499" class="c"><input type="checkbox" id="c-37734499" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#37733851">root</a><span>|</span><a href="#37734115">parent</a><span>|</span><a href="#37734125">next</a><span>|</span><label class="collapse" for="c-37734499">[-]</label><label class="expand" for="c-37734499">[1 more]</label></div><br/><div class="children"><div class="content">How so? It seems like the only real use case for these timestamps is to get data from around the same time together. A second is fine for that. It&#x27;s not about concurrency or avoiding collisions. A second can&#x27;t handle that, but neither can a millisecond.</div><br/></div></div></div></div><div id="37734125" class="c"><input type="checkbox" id="c-37734125" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#37733851">parent</a><span>|</span><a href="#37734115">prev</a><span>|</span><a href="#37735090">next</a><span>|</span><label class="collapse" for="c-37734125">[-]</label><label class="expand" for="c-37734125">[3 more]</label></div><br/><div class="children"><div class="content">100 years sounds short-sighted for something that&#x27;s supposed to be &quot;universally&quot; unique. We&#x27;re already having problems with the 32-bit Unix timestamp not being large enough. If you&#x27;re willing to use 160-bit (or longer) identifiers, you might as well give a few more bits to the timestamp. Round it up to an even number of base-62 characters, too. That part of KSUID has always struck me as a weird decision.<p>I wish UUIDv7 pulled the version&#x2F;variant bits up front, though, just to make sure that the identifiers don&#x27;t all start with null bytes.</div><br/><div id="37735067" class="c"><input type="checkbox" id="c-37735067" checked=""/><div class="controls bullet"><span class="by">jsf01</span><span>|</span><a href="#37733851">root</a><span>|</span><a href="#37734125">parent</a><span>|</span><a href="#37734330">next</a><span>|</span><label class="collapse" for="c-37735067">[-]</label><label class="expand" for="c-37735067">[1 more]</label></div><br/><div class="children"><div class="content">If the version bits were up front, then switching to a hypothetical UUIDv8 in several years would be guaranteed to break the sortability. So I see that decision as a bit of future proofing.</div><br/></div></div><div id="37734330" class="c"><input type="checkbox" id="c-37734330" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#37733851">root</a><span>|</span><a href="#37734125">parent</a><span>|</span><a href="#37735067">prev</a><span>|</span><a href="#37735090">next</a><span>|</span><label class="collapse" for="c-37734330">[-]</label><label class="expand" for="c-37734330">[1 more]</label></div><br/><div class="children"><div class="content">The timestamp is first.<p><a href="https:&#x2F;&#x2F;www.ietf.org&#x2F;archive&#x2F;id&#x2F;draft-peabody-dispatch-new-uuid-format-04.html#name-uuid-version-7" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.ietf.org&#x2F;archive&#x2F;id&#x2F;draft-peabody-dispatch-new-u...</a></div><br/></div></div></div></div></div></div><div id="37735090" class="c"><input type="checkbox" id="c-37735090" checked=""/><div class="controls bullet"><span class="by">zooFox</span><span>|</span><a href="#37733851">prev</a><span>|</span><a href="#37734932">next</a><span>|</span><label class="collapse" for="c-37735090">[-]</label><label class="expand" for="c-37735090">[1 more]</label></div><br/><div class="children"><div class="content">One benefit of an epoch is that it&#x27;s easily readable (or comparable, at the very least). I am not sure I can read epoch in hexadecimal format though.</div><br/></div></div><div id="37734932" class="c"><input type="checkbox" id="c-37734932" checked=""/><div class="controls bullet"><span class="by">jug</span><span>|</span><a href="#37735090">prev</a><span>|</span><a href="#37735006">next</a><span>|</span><label class="collapse" for="c-37734932">[-]</label><label class="expand" for="c-37734932">[1 more]</label></div><br/><div class="children"><div class="content">Haha this is what we came up with for our home brewn unique ID&#x27;s in a GIS application since decades ago. For the same reasons.</div><br/></div></div><div id="37735006" class="c"><input type="checkbox" id="c-37735006" checked=""/><div class="controls bullet"><span class="by">jsf01</span><span>|</span><a href="#37734932">prev</a><span>|</span><a href="#37734570">next</a><span>|</span><label class="collapse" for="c-37735006">[-]</label><label class="expand" for="c-37735006">[3 more]</label></div><br/><div class="children"><div class="content">How long will it be before the “milliseconds since epoch” part of the uuid overflows or repeats?</div><br/><div id="37735060" class="c"><input type="checkbox" id="c-37735060" checked=""/><div class="controls bullet"><span class="by">jolmg</span><span>|</span><a href="#37735006">parent</a><span>|</span><a href="#37734570">next</a><span>|</span><label class="collapse" for="c-37735060">[-]</label><label class="expand" for="c-37735060">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  $ date -ud @$(( 256 ** 6 &#x2F; 1000 ))
  Tue Aug  2 05:31:50 AM UTC 10889</code></pre></div><br/><div id="37735082" class="c"><input type="checkbox" id="c-37735082" checked=""/><div class="controls bullet"><span class="by">birracerveza</span><span>|</span><a href="#37735006">root</a><span>|</span><a href="#37735060">parent</a><span>|</span><a href="#37734570">next</a><span>|</span><label class="collapse" for="c-37735082">[-]</label><label class="expand" for="c-37735082">[1 more]</label></div><br/><div class="children"><div class="content">Well, at least it&#x27;s not a Friday.</div><br/></div></div></div></div></div></div><div id="37734570" class="c"><input type="checkbox" id="c-37734570" checked=""/><div class="controls bullet"><span class="by">miiiiiike</span><span>|</span><a href="#37735006">prev</a><span>|</span><a href="#37733557">next</a><span>|</span><label class="collapse" for="c-37734570">[-]</label><label class="expand" for="c-37734570">[1 more]</label></div><br/><div class="children"><div class="content">This is neat. I&#x27;ve been using a custom snowflake cluster for years. Having this in the language&#x2F;DB would be great for smaller projects.<p>For bigger&#x2F;public projects I&#x27;d like to be able to add a sequence, node, and data center id to the UUID too.</div><br/></div></div><div id="37733557" class="c"><input type="checkbox" id="c-37733557" checked=""/><div class="controls bullet"><span class="by">amanzi</span><span>|</span><a href="#37734570">prev</a><span>|</span><a href="#37733437">next</a><span>|</span><label class="collapse" for="c-37733557">[-]</label><label class="expand" for="c-37733557">[4 more]</label></div><br/><div class="children"><div class="content">Can you take the first portion of the UUIDv7 string, and decode it to figure out the exact date and time that record was created? I&#x27;m wondering if there might be security&#x2F;privacy concerns in some situations if the UUID codes are visible in your app?</div><br/><div id="37733919" class="c"><input type="checkbox" id="c-37733919" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#37733557">parent</a><span>|</span><a href="#37733733">next</a><span>|</span><label class="collapse" for="c-37733919">[-]</label><label class="expand" for="c-37733919">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, years from now we’re going to see some story about how a company fudged their timestamps in order to get away with X, only to be given away by the timestamp hidden in public UUIDs.</div><br/></div></div><div id="37733733" class="c"><input type="checkbox" id="c-37733733" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#37733557">parent</a><span>|</span><a href="#37733919">prev</a><span>|</span><a href="#37733437">next</a><span>|</span><label class="collapse" for="c-37733733">[-]</label><label class="expand" for="c-37733733">[2 more]</label></div><br/><div class="children"><div class="content">I just commented the same thing. I can&#x27;t imagine most applications would want to leak time information in their identifiers but these undoubtedly will be used most placed out of convenience. In a year or so we&#x27;ll read about an attack and everyone will migrate back to v4 or have to maintain a cryptographic identifier in addition to their temporal identifier.</div><br/><div id="37734118" class="c"><input type="checkbox" id="c-37734118" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#37733557">root</a><span>|</span><a href="#37733733">parent</a><span>|</span><a href="#37733437">next</a><span>|</span><label class="collapse" for="c-37734118">[-]</label><label class="expand" for="c-37734118">[1 more]</label></div><br/><div class="children"><div class="content">Most application may not want it, but will it hurt them?<p>I mean this is a similar concern to sequential IDs: many apps do not want to leak them, and in some cases it might cause issues, but in general it doesn&#x27;t matter.</div><br/></div></div></div></div></div></div><div id="37733437" class="c"><input type="checkbox" id="c-37733437" checked=""/><div class="controls bullet"><span class="by">user3939382</span><span>|</span><a href="#37733557">prev</a><span>|</span><a href="#37734492">next</a><span>|</span><label class="collapse" for="c-37733437">[-]</label><label class="expand" for="c-37733437">[1 more]</label></div><br/><div class="children"><div class="content">It’s nice for front end state. You post the new entity, the front provides the ID, and as long as you get a 200 you can update your state, or update optimistically and roll it back. You don’t need to wait for the API to figure out what your ID is.</div><br/></div></div><div id="37734492" class="c"><input type="checkbox" id="c-37734492" checked=""/><div class="controls bullet"><span class="by">tzahifadida</span><span>|</span><a href="#37733437">prev</a><span>|</span><a href="#37733365">next</a><span>|</span><label class="collapse" for="c-37734492">[-]</label><label class="expand" for="c-37734492">[3 more]</label></div><br/><div class="children"><div class="content">To me it sounds like a corner case. Example:<p>a) UUID4, CreatedTime&#x2F;UpdatedTime.<p>b) Bigint, CreatedTime&#x2F;UpdatedTime.<p>c) UUID7 internal (which also includes time badly), UUID4 external&#x2F;whatever short ID.<p>How exactly this helps if you need external ids (which you usually do today)? It doesn&#x27;t even make it a short ID.<p>Even if there is a corner case, are we just saving a few bytes while adding more complication?<p>Clustered Index is a myth in PostgreSQL, not practical since you have to run a special program to reorder. So, a regular index might suffer but not really. Why? Because I am not ordering by the ID most of the time, I am ordering by &quot;Created Date&#x2F;Updated Date&quot; or Name or whatever. Who cares about ordering IDs?<p>WAIT!!! But what about Next Tokens? ok, these are painful, but easily solved: Next can be (&gt;=Created Date,&gt;ID). Same result. Pagination, stays the same since it is sorted by Created Date.</div><br/><div id="37734650" class="c"><input type="checkbox" id="c-37734650" checked=""/><div class="controls bullet"><span class="by">otherme123</span><span>|</span><a href="#37734492">parent</a><span>|</span><a href="#37734578">next</a><span>|</span><label class="collapse" for="c-37734650">[-]</label><label class="expand" for="c-37734650">[1 more]</label></div><br/><div class="children"><div class="content">I understood it as c) only UUID7, no secondary external UUID.<p>The external Id is used instead of Bigint because you don&#x27;t want your external users to query 1, then 2, then 3 (IDOR)... But the random part of the Uuid7 makes this impossible.<p>Uuid7 isn&#x27;t a substitute for Created&#x2F;Updated, but a substitute for the dual field Uuid4&#x2F;Bigint.</div><br/></div></div></div></div><div id="37733365" class="c"><input type="checkbox" id="c-37733365" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#37734492">prev</a><span>|</span><a href="#37734761">next</a><span>|</span><label class="collapse" for="c-37733365">[-]</label><label class="expand" for="c-37733365">[1 more]</label></div><br/><div class="children"><div class="content">The first time I heard about ordered string IDs was Firebase’s push IDs. They had an interesting solution to also address time skew to get better ordering for drivers: <a href="https:&#x2F;&#x2F;firebase.blog&#x2F;posts&#x2F;2015&#x2F;02&#x2F;the-2120-ways-to-ensure-unique_68&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;firebase.blog&#x2F;posts&#x2F;2015&#x2F;02&#x2F;the-2120-ways-to-ensure-...</a></div><br/></div></div><div id="37734761" class="c"><input type="checkbox" id="c-37734761" checked=""/><div class="controls bullet"><span class="by">markcollin</span><span>|</span><a href="#37733365">prev</a><span>|</span><a href="#37733610">next</a><span>|</span><label class="collapse" for="c-37734761">[-]</label><label class="expand" for="c-37734761">[1 more]</label></div><br/><div class="children"><div class="content">Interesting - have beem using uuidv4 for a long time. Will explore further on uuidv7</div><br/></div></div><div id="37733610" class="c"><input type="checkbox" id="c-37733610" checked=""/><div class="controls bullet"><span class="by">declan_roberts</span><span>|</span><a href="#37734761">prev</a><span>|</span><a href="#37734292">next</a><span>|</span><label class="collapse" for="c-37733610">[-]</label><label class="expand" for="c-37733610">[15 more]</label></div><br/><div class="children"><div class="content">It’s 2023. Why aren’t we using more characters from the utf-8 keyspace to make things like UUIDs use less characters?</div><br/><div id="37733657" class="c"><input type="checkbox" id="c-37733657" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#37733610">parent</a><span>|</span><a href="#37734729">next</a><span>|</span><label class="collapse" for="c-37733657">[-]</label><label class="expand" for="c-37733657">[1 more]</label></div><br/><div class="children"><div class="content">You could, if you are only optimizing for display size. UUIDs are very infrequently presented as user-facing data, and pretty much every sensible system will be storing them as a 128-bit value, not the ASCII representation you see.<p>So really, what are you trying to optimize?</div><br/></div></div><div id="37734729" class="c"><input type="checkbox" id="c-37734729" checked=""/><div class="controls bullet"><span class="by">sapling-ginger</span><span>|</span><a href="#37733610">parent</a><span>|</span><a href="#37733657">prev</a><span>|</span><a href="#37733648">next</a><span>|</span><label class="collapse" for="c-37734729">[-]</label><label class="expand" for="c-37734729">[3 more]</label></div><br/><div class="children"><div class="content">Base8192: <a href="https:&#x2F;&#x2F;alicecengal.github.io&#x2F;uuid-hangul&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;alicecengal.github.io&#x2F;uuid-hangul&#x2F;</a></div><br/><div id="37734840" class="c"><input type="checkbox" id="c-37734840" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37733610">root</a><span>|</span><a href="#37734729">parent</a><span>|</span><a href="#37734886">next</a><span>|</span><label class="collapse" for="c-37734840">[-]</label><label class="expand" for="c-37734840">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s awesome. &quot;Aesthetic, Cosmopolitan&quot; LOL</div><br/></div></div><div id="37734886" class="c"><input type="checkbox" id="c-37734886" checked=""/><div class="controls bullet"><span class="by">larschdk</span><span>|</span><a href="#37733610">root</a><span>|</span><a href="#37734729">parent</a><span>|</span><a href="#37734840">prev</a><span>|</span><a href="#37733648">next</a><span>|</span><label class="collapse" for="c-37734886">[-]</label><label class="expand" for="c-37734886">[1 more]</label></div><br/><div class="children"><div class="content">Not very useful. Always decodes to 00NaN-0NaN-0NaN-0NaN-000000NaN.</div><br/></div></div></div></div><div id="37733648" class="c"><input type="checkbox" id="c-37733648" checked=""/><div class="controls bullet"><span class="by">chewbacha</span><span>|</span><a href="#37733610">parent</a><span>|</span><a href="#37734729">prev</a><span>|</span><a href="#37733980">next</a><span>|</span><label class="collapse" for="c-37733648">[-]</label><label class="expand" for="c-37733648">[6 more]</label></div><br/><div class="children"><div class="content">UUIDs are 128-bits, not characters. The string representation is just for humans.</div><br/><div id="37733706" class="c"><input type="checkbox" id="c-37733706" checked=""/><div class="controls bullet"><span class="by">treve</span><span>|</span><a href="#37733610">root</a><span>|</span><a href="#37733648">parent</a><span>|</span><a href="#37734030">next</a><span>|</span><label class="collapse" for="c-37733706">[-]</label><label class="expand" for="c-37733706">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a fair question, because yes you should store them as numbers, but they are still often sent in text formats and urls. Wanting a shorter representation is reasonable.<p>The easiest is probably to just base64 the binary representation of the 128 bit number, which results in a 128&#x2F;6=22 character string, which is a bit smaller.<p>If glyph-length and not byte-length is more important you could go even smaller but I&#x27;m less sure if that&#x27;s a good idea.</div><br/></div></div><div id="37734030" class="c"><input type="checkbox" id="c-37734030" checked=""/><div class="controls bullet"><span class="by">gabereiser</span><span>|</span><a href="#37733610">root</a><span>|</span><a href="#37733648">parent</a><span>|</span><a href="#37733706">prev</a><span>|</span><a href="#37733663">next</a><span>|</span><label class="collapse" for="c-37734030">[-]</label><label class="expand" for="c-37734030">[1 more]</label></div><br/><div class="children"><div class="content">This is the way. Look not at the characters but at the hex.</div><br/></div></div><div id="37733663" class="c"><input type="checkbox" id="c-37733663" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#37733610">root</a><span>|</span><a href="#37733648">parent</a><span>|</span><a href="#37734030">prev</a><span>|</span><a href="#37733980">next</a><span>|</span><label class="collapse" for="c-37733663">[-]</label><label class="expand" for="c-37733663">[3 more]</label></div><br/><div class="children"><div class="content">I think the parent is saying that we can make UUIDs more human-readable by displaying the underlying 128 bits with a larger set of characters.</div><br/><div id="37733675" class="c"><input type="checkbox" id="c-37733675" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#37733610">root</a><span>|</span><a href="#37733663">parent</a><span>|</span><a href="#37733697">next</a><span>|</span><label class="collapse" for="c-37733675">[-]</label><label class="expand" for="c-37733675">[1 more]</label></div><br/><div class="children"><div class="content">Base58 and Base64 exist in pure-ASCII space. Expanding into non-ASCII characters would probably just be confusing.</div><br/></div></div><div id="37733697" class="c"><input type="checkbox" id="c-37733697" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#37733610">root</a><span>|</span><a href="#37733663">parent</a><span>|</span><a href="#37733675">prev</a><span>|</span><a href="#37733980">next</a><span>|</span><label class="collapse" for="c-37733697">[-]</label><label class="expand" for="c-37733697">[1 more]</label></div><br/><div class="children"><div class="content">We could make the string representation more compact with more characters, but I’m not sure compactness and readability are the same, especially any compactness that takes more than the ASCII character set (sure, just the hexadecimal digits may be fewer than ideal.)</div><br/></div></div></div></div></div></div><div id="37733980" class="c"><input type="checkbox" id="c-37733980" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#37733610">parent</a><span>|</span><a href="#37733648">prev</a><span>|</span><a href="#37734097">next</a><span>|</span><label class="collapse" for="c-37733980">[-]</label><label class="expand" for="c-37733980">[1 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s 2023.  You&#x27;re looking at the UUID through a giant pile of interpreters and renderers and buffers... plenty of opportunity to give each one a tartan without changing it in the data.<p>Or better yet, only decorate one after it has been clicked by the user, that way when it appears again elsewhere, it stands out.  If you make each one pretty you&#x27;ll have made all of them ugly when viewed together.</div><br/></div></div><div id="37734097" class="c"><input type="checkbox" id="c-37734097" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#37733610">parent</a><span>|</span><a href="#37733980">prev</a><span>|</span><a href="#37734025">next</a><span>|</span><label class="collapse" for="c-37734097">[-]</label><label class="expand" for="c-37734097">[1 more]</label></div><br/><div class="children"><div class="content">UUIDs are 128 bits, or 16 bytes. They have infinitely many possible string representations. Those strings are not the value, they&#x27;re a transformation of the value.</div><br/></div></div><div id="37734025" class="c"><input type="checkbox" id="c-37734025" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#37733610">parent</a><span>|</span><a href="#37734097">prev</a><span>|</span><a href="#37733829">next</a><span>|</span><label class="collapse" for="c-37734025">[-]</label><label class="expand" for="c-37734025">[1 more]</label></div><br/><div class="children"><div class="content">we should display them as a monochrome block of 8*16 pixels.</div><br/></div></div><div id="37733829" class="c"><input type="checkbox" id="c-37733829" checked=""/><div class="controls bullet"><span class="by">xdennis</span><span>|</span><a href="#37733610">parent</a><span>|</span><a href="#37734025">prev</a><span>|</span><a href="#37734292">next</a><span>|</span><label class="collapse" for="c-37733829">[-]</label><label class="expand" for="c-37733829">[1 more]</label></div><br/><div class="children"><div class="content">Firstly, &quot;it&#x27;s current year&quot; is never a good argument, but you seem to be confusing things (UTF-8 vs Unicode). UTF-8 can take as much as 6 bytes to encode a Unicode codepoint.<p>If you want to store UUIDs as compactly as possible you&#x27;d use 16 bytes.<p>If you want to store them as text, mapping them to Unicode would be a terrible idea because: many characters are from scripts you&#x27;ve never heard of, many characters look identical (Α vs A), many characters are decomposed and it can change the encoding if they&#x27;re decomposed[1], &amp;c.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Precomposed_character" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Precomposed_character</a></div><br/></div></div></div></div><div id="37734292" class="c"><input type="checkbox" id="c-37734292" checked=""/><div class="controls bullet"><span class="by">coolgoose</span><span>|</span><a href="#37733610">prev</a><span>|</span><a href="#37733524">next</a><span>|</span><label class="collapse" for="c-37734292">[-]</label><label class="expand" for="c-37734292">[4 more]</label></div><br/><div class="children"><div class="content">I am confused how this is new.
UUIDv1 is time based, you just need to be careful about entropy, and in MySQL 8 you can for a longish time use it as an ordered field.</div><br/><div id="37734307" class="c"><input type="checkbox" id="c-37734307" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#37734292">parent</a><span>|</span><a href="#37733524">next</a><span>|</span><label class="collapse" for="c-37734307">[-]</label><label class="expand" for="c-37734307">[3 more]</label></div><br/><div class="children"><div class="content">The use of a MAC address and fine grained timestamp are challenges of UUIDv1.<p><a href="https:&#x2F;&#x2F;blog.devgenius.io&#x2F;analyzing-new-unique-identifier-formats-uuidv6-uuidv7-and-uuidv8-d6cc5cd7391a?gi=e90b435d8f84" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.devgenius.io&#x2F;analyzing-new-unique-identifier-fo...</a></div><br/><div id="37734883" class="c"><input type="checkbox" id="c-37734883" checked=""/><div class="controls bullet"><span class="by">coolgoose</span><span>|</span><a href="#37734292">root</a><span>|</span><a href="#37734307">parent</a><span>|</span><a href="#37734811">next</a><span>|</span><label class="collapse" for="c-37734883">[-]</label><label class="expand" for="c-37734883">[1 more]</label></div><br/><div class="children"><div class="content">Sure, hence why I said entropy, but it&#x27;s not like you can&#x27;t use it :)</div><br/></div></div><div id="37734811" class="c"><input type="checkbox" id="c-37734811" checked=""/><div class="controls bullet"><span class="by">oittaa</span><span>|</span><a href="#37734292">root</a><span>|</span><a href="#37734307">parent</a><span>|</span><a href="#37734883">prev</a><span>|</span><a href="#37733524">next</a><span>|</span><label class="collapse" for="c-37734811">[-]</label><label class="expand" for="c-37734811">[1 more]</label></div><br/><div class="children"><div class="content">And the crazy epoch instead the more known Unix epoch. Why would anyone want to create UUIDs around year 1500?</div><br/></div></div></div></div></div></div><div id="37733524" class="c"><input type="checkbox" id="c-37733524" checked=""/><div class="controls bullet"><span class="by">mooreed</span><span>|</span><a href="#37734292">prev</a><span>|</span><a href="#37734359">next</a><span>|</span><label class="collapse" for="c-37733524">[-]</label><label class="expand" for="c-37733524">[1 more]</label></div><br/><div class="children"><div class="content">Feels like a spiritual successor to the ksuid [1] lib which I first heard of used in conjunction with DynamoDB<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;segmentio&#x2F;ksuid">https:&#x2F;&#x2F;github.com&#x2F;segmentio&#x2F;ksuid</a> which has very similar use cases.</div><br/></div></div><div id="37734359" class="c"><input type="checkbox" id="c-37734359" checked=""/><div class="controls bullet"><span class="by">hknmtt</span><span>|</span><a href="#37733524">prev</a><span>|</span><a href="#37733810">next</a><span>|</span><label class="collapse" for="c-37734359">[-]</label><label class="expand" for="c-37734359">[1 more]</label></div><br/><div class="children"><div class="content">I have been using ULID for years. Using digits now would feel very strange.</div><br/></div></div><div id="37734013" class="c"><input type="checkbox" id="c-37734013" checked=""/><div class="controls bullet"><span class="by">dataangel</span><span>|</span><a href="#37733810">prev</a><span>|</span><label class="collapse" for="c-37734013">[-]</label><label class="expand" for="c-37734013">[3 more]</label></div><br/><div class="children"><div class="content">why bother with any version of the uuid standard? just generate a random 128-bit number and use it. that&#x27;s all the newer ones are anyway</div><br/><div id="37734449" class="c"><input type="checkbox" id="c-37734449" checked=""/><div class="controls bullet"><span class="by">mholt</span><span>|</span><a href="#37734013">parent</a><span>|</span><a href="#37734438">next</a><span>|</span><label class="collapse" for="c-37734449">[-]</label><label class="expand" for="c-37734449">[1 more]</label></div><br/><div class="children"><div class="content">Sorry to be this guy, but did you read the article? Only UUIDv4 is &quot;just generating a random 128-bit number&quot; (almost) -- and there are valid reasons that&#x27;s not a good choice. Which the article explains. :) Like database insertion performance. Sequential IDs have benefits.</div><br/></div></div><div id="37734438" class="c"><input type="checkbox" id="c-37734438" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37734013">parent</a><span>|</span><a href="#37734449">prev</a><span>|</span><label class="collapse" for="c-37734438">[-]</label><label class="expand" for="c-37734438">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why bother with any version of the uuid standard? just generate a random 128-bit number and use it. that&#x27;s all the newer ones are anyway<p>Good question.<p>Won&#x27;t random 128-bit numbers actually be <i>superior</i> to UUIDs in every way except predictability?</div><br/></div></div></div></div></div></div></div></div></div></body></html>