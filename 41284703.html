<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724058071688" as="style"/><link rel="stylesheet" href="styles.css?v=1724058071688"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/janbjorge/PgQueuer">Show HN: PgQueuer – Transform PostgreSQL into a Job Queue</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>jeeybee</span> | <span>82 comments</span></div><br/><div><div id="41288493" class="c"><input type="checkbox" id="c-41288493" checked=""/><div class="controls bullet"><span class="by">kdunglas</span><span>|</span><a href="#41285205">next</a><span>|</span><label class="collapse" for="c-41288493">[-]</label><label class="expand" for="c-41288493">[1 more]</label></div><br/><div class="children"><div class="content">The Symfony framework (PHP) provides a similar feature, which  also relies on LISTEN&#x2F;NOTIFY and FOR UPDATE SKIP LOCKED: <a href="https:&#x2F;&#x2F;symfony.com&#x2F;doc&#x2F;current&#x2F;messenger.html#doctrine-transport" rel="nofollow">https:&#x2F;&#x2F;symfony.com&#x2F;doc&#x2F;current&#x2F;messenger.html#doctrine-tran...</a><p>It also supports many other backends including AMQP, Beanstalkd, Redis and various cloud services.<p>This component, called Messenger, can be installed as a standalone library in any PHP project.<p>(Disclaimer: I’m the author of the PostgreSQL transport for Symfony Messenger).</div><br/></div></div><div id="41285205" class="c"><input type="checkbox" id="c-41285205" checked=""/><div class="controls bullet"><span class="by">cklee</span><span>|</span><a href="#41288493">prev</a><span>|</span><a href="#41285037">next</a><span>|</span><label class="collapse" for="c-41285205">[-]</label><label class="expand" for="c-41285205">[16 more]</label></div><br/><div class="children"><div class="content">I’ve been thinking about the potential for PostgreSQL-backed job queue libraries to share a common schema. For instance, I’m a big fan of Oban in Elixir: <a href="https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban">https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban</a><p>Given that there are many Sidekiq-compatible libraries across various languages, it might be beneficial to have a similar approach for PostgreSQL-based job queues. This could allow for job processing in different languages while maintaining compatibility.<p>Alternatively, we could consider developing a core job queue library in Rust, with language-specific bindings. This would provide a robust, cross-language solution while leveraging the performance and safety benefits of Rust.</div><br/><div id="41285821" class="c"><input type="checkbox" id="c-41285821" checked=""/><div class="controls bullet"><span class="by">rileymichael</span><span>|</span><a href="#41285205">parent</a><span>|</span><a href="#41287831">next</a><span>|</span><label class="collapse" for="c-41285821">[-]</label><label class="expand" for="c-41285821">[1 more]</label></div><br/><div class="children"><div class="content">If you want a generic queue that can be consumed in any runtime, you can just build it directly into postgres via extensions like <a href="https:&#x2F;&#x2F;github.com&#x2F;tembo-io&#x2F;pgmq">https:&#x2F;&#x2F;github.com&#x2F;tembo-io&#x2F;pgmq</a>.</div><br/></div></div><div id="41287831" class="c"><input type="checkbox" id="c-41287831" checked=""/><div class="controls bullet"><span class="by">AlphaSite</span><span>|</span><a href="#41285205">parent</a><span>|</span><a href="#41285821">prev</a><span>|</span><a href="#41285276">next</a><span>|</span><label class="collapse" for="c-41287831">[-]</label><label class="expand" for="c-41287831">[1 more]</label></div><br/><div class="children"><div class="content">River is my go to in Golang, it’s really handy to have transactional queuing with a nice little ui.</div><br/></div></div><div id="41285276" class="c"><input type="checkbox" id="c-41285276" checked=""/><div class="controls bullet"><span class="by">memset</span><span>|</span><a href="#41285205">parent</a><span>|</span><a href="#41287831">prev</a><span>|</span><a href="#41285671">next</a><span>|</span><label class="collapse" for="c-41285276">[-]</label><label class="expand" for="c-41285276">[7 more]</label></div><br/><div class="children"><div class="content">I am building an SQS compatible queue for exactly that reason. Use with any language or framework. <a href="https:&#x2F;&#x2F;github.com&#x2F;poundifdef&#x2F;smoothmq">https:&#x2F;&#x2F;github.com&#x2F;poundifdef&#x2F;smoothmq</a><p>It is based on SQLite, but it’s written in a modular way. It would be easy to add Postgres as a backend (in fact, it might “just work” if I switch the ORM connection string.)</div><br/><div id="41285552" class="c"><input type="checkbox" id="c-41285552" checked=""/><div class="controls bullet"><span class="by">GordonS</span><span>|</span><a href="#41285205">root</a><span>|</span><a href="#41285276">parent</a><span>|</span><a href="#41286936">next</a><span>|</span><label class="collapse" for="c-41285552">[-]</label><label class="expand" for="c-41285552">[2 more]</label></div><br/><div class="children"><div class="content">Does SmoothMQ support running multiple nodes for high availability? (I didn&#x27;t see anything in the docs, but they seem unfinished)</div><br/><div id="41287030" class="c"><input type="checkbox" id="c-41287030" checked=""/><div class="controls bullet"><span class="by">memset</span><span>|</span><a href="#41285205">root</a><span>|</span><a href="#41285552">parent</a><span>|</span><a href="#41286936">next</a><span>|</span><label class="collapse" for="c-41287030">[-]</label><label class="expand" for="c-41287030">[1 more]</label></div><br/><div class="children"><div class="content">Not today. It&#x27;s a work in progress! There are several iterations that I&#x27;m working on:<p>1. Primary with secondaries as replicas (replication for availability)
2. Sharding across multiple nodes (sharding for horizontal scaling)
3. Sharding with replication<p>However, those aren&#x27;t ready yet. The easiest way to implement this would probably be to use Postgres as the backing storage for the queue, which means relying on Postgres&#x27; multiple node support. Then the queue server itself could also scale up and down independently.<p>Working on the docs! I&#x27;d love your feedback - what makes them seem unfinished? (What would you want to see that would make them feel more complete?)</div><br/></div></div></div></div><div id="41286936" class="c"><input type="checkbox" id="c-41286936" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#41285205">root</a><span>|</span><a href="#41285276">parent</a><span>|</span><a href="#41285552">prev</a><span>|</span><a href="#41285671">next</a><span>|</span><label class="collapse" for="c-41286936">[-]</label><label class="expand" for="c-41286936">[4 more]</label></div><br/><div class="children"><div class="content">Sounds like it wouldn&#x27;t have immediate notification of new submissions due to no listen&#x2F;notify support in SQLite?</div><br/><div id="41287015" class="c"><input type="checkbox" id="c-41287015" checked=""/><div class="controls bullet"><span class="by">memset</span><span>|</span><a href="#41285205">root</a><span>|</span><a href="#41286936">parent</a><span>|</span><a href="#41285671">next</a><span>|</span><label class="collapse" for="c-41287015">[-]</label><label class="expand" for="c-41287015">[3 more]</label></div><br/><div class="children"><div class="content">It does not implement immediate notification of new submissions because the SQS protocol doesn&#x27;t have a &quot;push&quot; mechanism, only pull.<p>The software, however, could support this for a different queue protocol. This is because SQLite is just used as a disk store for queue items. The golang code itself still processes each message before writing to disk. Since that code is &quot;aware&quot; of incoming messages, it could implement an immediate notification mechanism if there was a protocol that supported it.</div><br/><div id="41287325" class="c"><input type="checkbox" id="c-41287325" checked=""/><div class="controls bullet"><span class="by">agrothberg</span><span>|</span><a href="#41285205">root</a><span>|</span><a href="#41287015">parent</a><span>|</span><a href="#41285671">next</a><span>|</span><label class="collapse" for="c-41287325">[-]</label><label class="expand" for="c-41287325">[2 more]</label></div><br/><div class="children"><div class="content">SQS does offer long polling, which looks closer to &quot;push&quot; semantics.</div><br/><div id="41287503" class="c"><input type="checkbox" id="c-41287503" checked=""/><div class="controls bullet"><span class="by">memset</span><span>|</span><a href="#41285205">root</a><span>|</span><a href="#41287325">parent</a><span>|</span><a href="#41285671">next</a><span>|</span><label class="collapse" for="c-41287503">[-]</label><label class="expand" for="c-41287503">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough. I do implement long polling!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41285671" class="c"><input type="checkbox" id="c-41285671" checked=""/><div class="controls bullet"><span class="by">earthnail</span><span>|</span><a href="#41285205">parent</a><span>|</span><a href="#41285276">prev</a><span>|</span><a href="#41285238">next</a><span>|</span><label class="collapse" for="c-41285671">[-]</label><label class="expand" for="c-41285671">[4 more]</label></div><br/><div class="children"><div class="content">This would be so immensely useful. I’d estimate that there are so many cases where the producer is Node or Rails and the consumer is Python.</div><br/><div id="41288140" class="c"><input type="checkbox" id="c-41288140" checked=""/><div class="controls bullet"><span class="by">bgentry</span><span>|</span><a href="#41285205">root</a><span>|</span><a href="#41285671">parent</a><span>|</span><a href="#41286715">next</a><span>|</span><label class="collapse" for="c-41288140">[-]</label><label class="expand" for="c-41288140">[1 more]</label></div><br/><div class="children"><div class="content">River ( <a href="https:&#x2F;&#x2F;riverqueue.com" rel="nofollow">https:&#x2F;&#x2F;riverqueue.com</a> ) is a Postgres background job engine written in Go, which also has insert only clients in other languages. Currently we have these for Ruby and Python:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;riverqueue-ruby">https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;riverqueue-ruby</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;riverqueue-python">https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;riverqueue-python</a></div><br/></div></div><div id="41286715" class="c"><input type="checkbox" id="c-41286715" checked=""/><div class="controls bullet"><span class="by">mind-blight</span><span>|</span><a href="#41285205">root</a><span>|</span><a href="#41285671">parent</a><span>|</span><a href="#41288140">prev</a><span>|</span><a href="#41285238">next</a><span>|</span><label class="collapse" for="c-41286715">[-]</label><label class="expand" for="c-41286715">[2 more]</label></div><br/><div class="children"><div class="content">This is the exact use case I&#x27;m running into right now. I&#x27;ve been looking at BullMQ some it has good typescript support, and is working towards a 1.0 for python. But, I have tried it out in a production stack yet</div><br/><div id="41287067" class="c"><input type="checkbox" id="c-41287067" checked=""/><div class="controls bullet"><span class="by">jmvoodoo</span><span>|</span><a href="#41285205">root</a><span>|</span><a href="#41286715">parent</a><span>|</span><a href="#41285238">next</a><span>|</span><label class="collapse" for="c-41287067">[-]</label><label class="expand" for="c-41287067">[1 more]</label></div><br/><div class="children"><div class="content">We have been using bullmq in production for just over a year. It is a piece of technology that our team doesn&#x27;t have to think about, which is pretty much all I could ask for.<p>We did end up adding some additional generics which allows us to get strong typing between producers and consumers. That I think has been a key piece of making it easy to use and avoiding dumb mistakes.</div><br/></div></div></div></div></div></div><div id="41285727" class="c"><input type="checkbox" id="c-41285727" checked=""/><div class="controls bullet"><span class="by">stephenr</span><span>|</span><a href="#41285205">parent</a><span>|</span><a href="#41285238">prev</a><span>|</span><a href="#41285037">next</a><span>|</span><label class="collapse" for="c-41285727">[-]</label><label class="expand" for="c-41285727">[1 more]</label></div><br/><div class="children"><div class="content">Qless &quot;solves&quot; this problem (in redis) by having all core logic written as lua and executed in redis.<p>You could take a similar approach for pg: define a series of procedures that provide all the required functionality, and then language bindings are all just thin wrappers (to handle language native stuff) around calls to execute a given procedure with the correct arguments.</div><br/></div></div></div></div><div id="41285037" class="c"><input type="checkbox" id="c-41285037" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#41285205">prev</a><span>|</span><a href="#41285713">next</a><span>|</span><label class="collapse" for="c-41285037">[-]</label><label class="expand" for="c-41285037">[8 more]</label></div><br/><div class="children"><div class="content">This looks like a great task queue, I&#x27;m a massive proponent of &quot;Postgres is all you need&quot; [0] and doubling down on it with my project that takes it to the extreme.<p>What I would love is a Postgres task queue that does multi-step pipelines, with fan out and accumulation. In my view a structured relational database is a particularly good backend for that as it inherently can model the structure. Is that something you have considered exploring?<p>The one thing with listen&#x2F;notify that I find lacking is the max payload size of 8k, it somewhat limits its capability without having to start saving stuff to tables. What I would really like is a streaming table, with a schema and all the rich type support... maybe one day.<p>0: <a href="https:&#x2F;&#x2F;www.amazingcto.com&#x2F;postgres-for-everything&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.amazingcto.com&#x2F;postgres-for-everything&#x2F;</a></div><br/><div id="41287838" class="c"><input type="checkbox" id="c-41287838" checked=""/><div class="controls bullet"><span class="by">jashmatthews</span><span>|</span><a href="#41285037">parent</a><span>|</span><a href="#41287262">next</a><span>|</span><label class="collapse" for="c-41287838">[-]</label><label class="expand" for="c-41287838">[2 more]</label></div><br/><div class="children"><div class="content">Putting low throughput queues in the same DB is great both for simplicity and for getting exactly-once-processing.<p>Putting high throughput queues in Postgres sucks because...<p>No O(1) guarantee to get latest job. Query planner can go haywire.<p>High update tables bloat like crazy. Needs a whole new storage engine aka ZHEAP<p>Write amplification as every update has to update every index<p>LISTEN&#x2F;NOTIFY doesn&#x27;t work through connection pooling</div><br/><div id="41288079" class="c"><input type="checkbox" id="c-41288079" checked=""/><div class="controls bullet"><span class="by">mickeyp</span><span>|</span><a href="#41285037">root</a><span>|</span><a href="#41287838">parent</a><span>|</span><a href="#41287262">next</a><span>|</span><label class="collapse" for="c-41288079">[-]</label><label class="expand" for="c-41288079">[1 more]</label></div><br/><div class="children"><div class="content">Update-related throughput and index problems are only a problem if you update tables. You can use an append-only structure to mitigate some of that: insert new entries with the updated statuses instead. You gain the benefit of history also. You can even coax the index into holding non-key values for speed with INCLUDE to CREATE INDEX.<p>You can then delete the older rows when needed or as required.<p>Query planner issues are a general problem in postgres and is not unique to this problem. Not sure what O(1) means in this context. I am not sure pg has ever been able to promise constant-time access to anything; indeed, with an index, it&#x27;d never be asymptotically upper bounded as constant time at all?</div><br/></div></div></div></div><div id="41287262" class="c"><input type="checkbox" id="c-41287262" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#41285037">parent</a><span>|</span><a href="#41287838">prev</a><span>|</span><a href="#41285246">next</a><span>|</span><label class="collapse" for="c-41287262">[-]</label><label class="expand" for="c-41287262">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve come to hate &quot;Postgres is all you need.&quot; Or at least, &quot;a single Postgres database is all you need.&quot;</div><br/><div id="41288168" class="c"><input type="checkbox" id="c-41288168" checked=""/><div class="controls bullet"><span class="by">philippta</span><span>|</span><a href="#41285037">root</a><span>|</span><a href="#41287262">parent</a><span>|</span><a href="#41285246">next</a><span>|</span><label class="collapse" for="c-41288168">[-]</label><label class="expand" for="c-41288168">[2 more]</label></div><br/><div class="children"><div class="content">Why?</div><br/></div></div></div></div><div id="41285246" class="c"><input type="checkbox" id="c-41285246" checked=""/><div class="controls bullet"><span class="by">jeeybee</span><span>|</span><a href="#41285037">parent</a><span>|</span><a href="#41287262">prev</a><span>|</span><a href="#41286133">next</a><span>|</span><label class="collapse" for="c-41285246">[-]</label><label class="expand" for="c-41285246">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for your insights!<p>Regarding multi-step pipelines and fan-out capabilities: It&#x27;s a great suggestion, and while PgQueuer doesn&#x27;t currently support this, it&#x27;s something I&#x27;m considering for future updates.<p>As for the LISTEN&#x2F;NOTIFY payload limit, PgQueuer uses these signals just to indicate changes in the queue table, avoiding the size constraint by not transmitting substantial data through this channel.</div><br/></div></div><div id="41286133" class="c"><input type="checkbox" id="c-41286133" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#41285037">parent</a><span>|</span><a href="#41285246">prev</a><span>|</span><a href="#41285713">next</a><span>|</span><label class="collapse" for="c-41286133">[-]</label><label class="expand" for="c-41286133">[1 more]</label></div><br/><div class="children"><div class="content">Is multi-step (fan out, etc) typically something a queue or message bus would handle?<p>I’ve always handled this with an orchestrator solution like (think Airflow and similar).<p>Or is this a matter of use case? Like for a real-time scenario where you need a series of things to happen (user registration, etc) maybe a queue handling this makes sense? Whereas with longer running tasks (ETL pipelines, etc) the orchestrator is beneficial?</div><br/></div></div></div></div><div id="41285713" class="c"><input type="checkbox" id="c-41285713" checked=""/><div class="controls bullet"><span class="by">aflukasz</span><span>|</span><a href="#41285037">prev</a><span>|</span><a href="#41288868">next</a><span>|</span><label class="collapse" for="c-41285713">[-]</label><label class="expand" for="c-41285713">[2 more]</label></div><br/><div class="children"><div class="content">BTW: Good PostgresFM episode on implementing queues in Postgres, various caveats etc: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mW5z5NYpGeA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mW5z5NYpGeA</a> .</div><br/><div id="41285942" class="c"><input type="checkbox" id="c-41285942" checked=""/><div class="controls bullet"><span class="by">jeeybee</span><span>|</span><a href="#41285713">parent</a><span>|</span><a href="#41288868">next</a><span>|</span><label class="collapse" for="c-41285942">[-]</label><label class="expand" for="c-41285942">[1 more]</label></div><br/><div class="children"><div class="content">thanks for sharing, added to my to watch list.</div><br/></div></div></div></div><div id="41288868" class="c"><input type="checkbox" id="c-41288868" checked=""/><div class="controls bullet"><span class="by">piyushtechsavy</span><span>|</span><a href="#41285713">prev</a><span>|</span><a href="#41288126">next</a><span>|</span><label class="collapse" for="c-41288868">[-]</label><label class="expand" for="c-41288868">[1 more]</label></div><br/><div class="children"><div class="content">Although I am more of a MySQL guy, I have been exploring PostgreSQL from sometime. Seems it has lot of features out of box.<p>This is very interesting tool.</div><br/></div></div><div id="41288126" class="c"><input type="checkbox" id="c-41288126" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#41288868">prev</a><span>|</span><a href="#41286456">next</a><span>|</span><label class="collapse" for="c-41288126">[-]</label><label class="expand" for="c-41288126">[7 more]</label></div><br/><div class="children"><div class="content">The most simple job queue in MySQL:<p><pre><code>    update job_table set key=value where ... limit 1
</code></pre>
It&#x27;s simple and atomic. Unfortunately PG doesn&#x27;t allow `update ... limit` syntax</div><br/><div id="41288225" class="c"><input type="checkbox" id="c-41288225" checked=""/><div class="controls bullet"><span class="by">DemocracyFTW2</span><span>|</span><a href="#41288126">parent</a><span>|</span><a href="#41286456">next</a><span>|</span><label class="collapse" for="c-41288225">[-]</label><label class="expand" for="c-41288225">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s simple and atomic<p>and almost certainly incorrect, gotta read at least <a href="https:&#x2F;&#x2F;www.pgcon.org&#x2F;2016&#x2F;schedule&#x2F;attachments&#x2F;414_queues-pgcon-2016.pdf" rel="nofollow">https:&#x2F;&#x2F;www.pgcon.org&#x2F;2016&#x2F;schedule&#x2F;attachments&#x2F;414_queues-p...</a> which discusses FOR UPDATE SKIP LOCKED</div><br/><div id="41288264" class="c"><input type="checkbox" id="c-41288264" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#41288126">root</a><span>|</span><a href="#41288225">parent</a><span>|</span><a href="#41286456">next</a><span>|</span><label class="collapse" for="c-41288264">[-]</label><label class="expand" for="c-41288264">[5 more]</label></div><br/><div class="children"><div class="content">that&#x27;s a nice read, but does it also apply to MySQL (InnoDB)?</div><br/><div id="41288413" class="c"><input type="checkbox" id="c-41288413" checked=""/><div class="controls bullet"><span class="by">hparadiz</span><span>|</span><a href="#41288126">root</a><span>|</span><a href="#41288264">parent</a><span>|</span><a href="#41286456">next</a><span>|</span><label class="collapse" for="c-41288413">[-]</label><label class="expand" for="c-41288413">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done this with mysql. Never do one at a time if you have jobs per minute over 30. It won&#x27;t scale. Instead have the job dispatcher reserve 100 at a time and then fire that off to a subprocess which will subsequently fire off a process for each job. A three layer approach makes it much easier to build out multiserver. Or if you don&#x27;t want the headache just use SQS which is pretty much free under 1 million jobs.</div><br/><div id="41288436" class="c"><input type="checkbox" id="c-41288436" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#41288126">root</a><span>|</span><a href="#41288413">parent</a><span>|</span><a href="#41286456">next</a><span>|</span><label class="collapse" for="c-41288436">[-]</label><label class="expand" for="c-41288436">[3 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s very basic and limited.<p>However if I am about to use DB as a job queue for budget reasons, I&#x27;d make sure the job doesn&#x27;t get too complicated.</div><br/><div id="41288482" class="c"><input type="checkbox" id="c-41288482" checked=""/><div class="controls bullet"><span class="by">hparadiz</span><span>|</span><a href="#41288126">root</a><span>|</span><a href="#41288436">parent</a><span>|</span><a href="#41286456">next</a><span>|</span><label class="collapse" for="c-41288482">[-]</label><label class="expand" for="c-41288482">[2 more]</label></div><br/><div class="children"><div class="content">For me it was a lot of small jobs.<p>I was able to get it up to 3500 jobs an hour and likely could have gone far past that but the load on the MySQL server was not reasonable</div><br/><div id="41289134" class="c"><input type="checkbox" id="c-41289134" checked=""/><div class="controls bullet"><span class="by">jeeybee</span><span>|</span><a href="#41288126">root</a><span>|</span><a href="#41288482">parent</a><span>|</span><a href="#41286456">next</a><span>|</span><label class="collapse" for="c-41289134">[-]</label><label class="expand" for="c-41289134">[1 more]</label></div><br/><div class="children"><div class="content">I was able to push PqQueuer to 25k jobs a second in my benchmarking script.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41286456" class="c"><input type="checkbox" id="c-41286456" checked=""/><div class="controls bullet"><span class="by">gmag</span><span>|</span><a href="#41288126">prev</a><span>|</span><a href="#41288745">next</a><span>|</span><label class="collapse" for="c-41286456">[-]</label><label class="expand" for="c-41286456">[4 more]</label></div><br/><div class="children"><div class="content">You might also want to look at River (<a href="https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;river">https:&#x2F;&#x2F;github.com&#x2F;riverqueue&#x2F;river</a>) for inspiration as they support scheduled jobs, etc.<p>From an end-user perspective, they also have a UI which is nice to have for debugging.</div><br/><div id="41288889" class="c"><input type="checkbox" id="c-41288889" checked=""/><div class="controls bullet"><span class="by">rubenvanwyk</span><span>|</span><a href="#41286456">parent</a><span>|</span><a href="#41286682">next</a><span>|</span><label class="collapse" for="c-41288889">[-]</label><label class="expand" for="c-41288889">[1 more]</label></div><br/><div class="children"><div class="content">Also wanted to say I thought this problem has already been solved by River.<p>Although seems like OP references a Python library rather than standalone server, so would probably be useful to Python devs.</div><br/></div></div><div id="41286682" class="c"><input type="checkbox" id="c-41286682" checked=""/><div class="controls bullet"><span class="by">bdcravens</span><span>|</span><a href="#41286456">parent</a><span>|</span><a href="#41288889">prev</a><span>|</span><a href="#41286598">next</a><span>|</span><label class="collapse" for="c-41286682">[-]</label><label class="expand" for="c-41286682">[1 more]</label></div><br/><div class="children"><div class="content">Glancing at it briefly, I like the Workflows feature. I&#x27;m a long time Sidekiq user (Ruby), and while you can construct workflows pretty easily (especially using nested batches and callbacks in the Pro version), there really isn&#x27;t a dedicated UI for visualizing them.</div><br/></div></div><div id="41286598" class="c"><input type="checkbox" id="c-41286598" checked=""/><div class="controls bullet"><span class="by">onionisafruit</span><span>|</span><a href="#41286456">parent</a><span>|</span><a href="#41286682">prev</a><span>|</span><a href="#41288745">next</a><span>|</span><label class="collapse" for="c-41286598">[-]</label><label class="expand" for="c-41286598">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been using river for some low volume stuff. I love that I can add a job to the queue in the same db transaction that handle the synchronous changes.</div><br/></div></div></div></div><div id="41288745" class="c"><input type="checkbox" id="c-41288745" checked=""/><div class="controls bullet"><span class="by">odie5533</span><span>|</span><a href="#41286456">prev</a><span>|</span><a href="#41286659">next</a><span>|</span><label class="collapse" for="c-41288745">[-]</label><label class="expand" for="c-41288745">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been referring to this post about issues with Celery: <a href="https:&#x2F;&#x2F;docs.hatchet.run&#x2F;blog&#x2F;problems-with-celery">https:&#x2F;&#x2F;docs.hatchet.run&#x2F;blog&#x2F;problems-with-celery</a><p>Does PgQueuer address any of them?</div><br/></div></div><div id="41286659" class="c"><input type="checkbox" id="c-41286659" checked=""/><div class="controls bullet"><span class="by">bdcravens</span><span>|</span><a href="#41288745">prev</a><span>|</span><a href="#41285787">next</a><span>|</span><label class="collapse" for="c-41286659">[-]</label><label class="expand" for="c-41286659">[4 more]</label></div><br/><div class="children"><div class="content">Good Job does the same for Rails<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bensheldon&#x2F;good_job">https:&#x2F;&#x2F;github.com&#x2F;bensheldon&#x2F;good_job</a></div><br/><div id="41288234" class="c"><input type="checkbox" id="c-41288234" checked=""/><div class="controls bullet"><span class="by">Lio</span><span>|</span><a href="#41286659">parent</a><span>|</span><a href="#41287634">next</a><span>|</span><label class="collapse" for="c-41288234">[-]</label><label class="expand" for="c-41288234">[2 more]</label></div><br/><div class="children"><div class="content">There’s also the new built in SolidQueue.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rails&#x2F;solid_queue&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;rails&#x2F;solid_queue&#x2F;</a></div><br/><div id="41288379" class="c"><input type="checkbox" id="c-41288379" checked=""/><div class="controls bullet"><span class="by">sandGorgon</span><span>|</span><a href="#41286659">root</a><span>|</span><a href="#41288234">parent</a><span>|</span><a href="#41287634">next</a><span>|</span><label class="collapse" for="c-41288379">[-]</label><label class="expand" for="c-41288379">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;dev.37signals.com&#x2F;introducing-solid-queue&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dev.37signals.com&#x2F;introducing-solid-queue&#x2F;</a></div><br/></div></div></div></div><div id="41287634" class="c"><input type="checkbox" id="c-41287634" checked=""/><div class="controls bullet"><span class="by">strzibny</span><span>|</span><a href="#41286659">parent</a><span>|</span><a href="#41288234">prev</a><span>|</span><a href="#41285787">next</a><span>|</span><label class="collapse" for="c-41287634">[-]</label><label class="expand" for="c-41287634">[1 more]</label></div><br/><div class="children"><div class="content">Wanted to post this, glad it&#x27;s already here. This is PgQueuer for Rails but also with some history under its belt.</div><br/></div></div></div></div><div id="41285787" class="c"><input type="checkbox" id="c-41285787" checked=""/><div class="controls bullet"><span class="by">_medihack_</span><span>|</span><a href="#41286659">prev</a><span>|</span><a href="#41286459">next</a><span>|</span><label class="collapse" for="c-41285787">[-]</label><label class="expand" for="c-41285787">[3 more]</label></div><br/><div class="children"><div class="content">There is also Procrastinate: <a href="https:&#x2F;&#x2F;procrastinate.readthedocs.io&#x2F;en&#x2F;stable&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;procrastinate.readthedocs.io&#x2F;en&#x2F;stable&#x2F;index.html</a><p>Procrastinate also uses PostgreSQL&#x27;s LISTEN&#x2F;NOTIFY (but can optionally be turned off and use polling). It also supports many features (and more are planned), like sync and async jobs (it uses asyncio under the hood), periodic tasks, retries, task locks, priorities, job cancellation&#x2F;aborting, Django integration (optional).<p>DISCLAIMER: I am a co-maintainer of Procrastinate.</div><br/><div id="41289034" class="c"><input type="checkbox" id="c-41289034" checked=""/><div class="controls bullet"><span class="by">joking</span><span>|</span><a href="#41285787">parent</a><span>|</span><a href="#41286795">next</a><span>|</span><label class="collapse" for="c-41289034">[-]</label><label class="expand" for="c-41289034">[1 more]</label></div><br/><div class="children"><div class="content">it should be the opposite of procastination, but good naming anyway.</div><br/></div></div></div></div><div id="41286459" class="c"><input type="checkbox" id="c-41286459" checked=""/><div class="controls bullet"><span class="by">airocker</span><span>|</span><a href="#41285787">prev</a><span>|</span><a href="#41286669">next</a><span>|</span><label class="collapse" for="c-41286459">[-]</label><label class="expand" for="c-41286459">[1 more]</label></div><br/><div class="children"><div class="content">We use listen notify extensively and it is great. The things it lacks most for us is guaranteed single recipient. All subscribers get all notifications which leads to problems in determining who should act on the message n our case.</div><br/></div></div><div id="41286669" class="c"><input type="checkbox" id="c-41286669" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41286459">prev</a><span>|</span><a href="#41286219">next</a><span>|</span><label class="collapse" for="c-41286669">[-]</label><label class="expand" for="c-41286669">[4 more]</label></div><br/><div class="children"><div class="content">I am going to go the other direction on this... to anyone reading this, please consider using a backend-generic queueing system for your Python project.<p>Why? Mainly because those systems offer good affordances for testing and running locally in an operationally simple way. They also tend to have decent default answers for various futzy questions around disconnects at various parts of the workflow.<p>We all know Celery is a buggy pain in the butt, but rolling your own job queue likely ends up with you just writing a similary-buggy pain in the butt. We&#x27;ve already done &quot;Celery but simpler&quot;, it&#x27;s stuff like Dramatiq!<p>If you have backend-specific needs, you won&#x27;t listen to this advice. But think deeply how important your needs are. Computers are fast, and you can deal with a lot of events with most systems.<p>Meanwhile if you use a backend-generic system... well you could write a backend using PgQueuer!</div><br/><div id="41286758" class="c"><input type="checkbox" id="c-41286758" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41286669">parent</a><span>|</span><a href="#41286219">next</a><span>|</span><label class="collapse" for="c-41286758">[-]</label><label class="expand" for="c-41286758">[3 more]</label></div><br/><div class="children"><div class="content">&gt; those systems offer good affordances for testing and running locally in an operationally simple way<p>Define &quot;operationally simple&quot;, most if not all of them need persistent anyway, on top of the queue itself. This eliminates the queue and uses a persistent you likely already have.</div><br/><div id="41286805" class="c"><input type="checkbox" id="c-41286805" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41286669">root</a><span>|</span><a href="#41286758">parent</a><span>|</span><a href="#41287510">next</a><span>|</span><label class="collapse" for="c-41286805">[-]</label><label class="expand" for="c-41286805">[1 more]</label></div><br/><div class="children"><div class="content">Well for example, lots of queueing libraries have an &quot;eager task&quot; runtime option. What does that do? Instead of putting work into a backend queue, it just immediately runs the task in-process. You don&#x27;t need any processing queue!<p>How many times have you shipped some background task change, only to realize half your test suite doesn&#x27;t do anything with background tasks, and you&#x27;re not testing your business logic to the logical conclusion? Eager task execution catches bugs earlier on, and is close enough to the reality for things that matter, while removing the need for, say, multi-process cordination in most tests.<p>And you can still test things the &quot;real way&quot; if you need to!<p>And to your other point: you can use Dramatiq with Postgres, for example[0]. I&#x27;ve written custom backends that just use pg for these libs, it&#x27;s usually straightforward because the broker classes tend to abstract the gnarly things.<p>[0]: <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;dramatiq-pg&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;dramatiq-pg&#x2F;</a></div><br/></div></div><div id="41287510" class="c"><input type="checkbox" id="c-41287510" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#41286669">root</a><span>|</span><a href="#41286758">parent</a><span>|</span><a href="#41286805">prev</a><span>|</span><a href="#41286219">next</a><span>|</span><label class="collapse" for="c-41287510">[-]</label><label class="expand" for="c-41287510">[1 more]</label></div><br/><div class="children"><div class="content">Some message queue brokers that traditionally implement their own backends can also use Postgresql (and other RDBMSs) for persistence.  This is a reasonable option if you a.) want to consolidate persistence backends b.) want a mature, battle proven broker and client stack.</div><br/></div></div></div></div></div></div><div id="41286219" class="c"><input type="checkbox" id="c-41286219" checked=""/><div class="controls bullet"><span class="by">ijustlovemath</span><span>|</span><a href="#41286669">prev</a><span>|</span><a href="#41285186">next</a><span>|</span><label class="collapse" for="c-41286219">[-]</label><label class="expand" for="c-41286219">[1 more]</label></div><br/><div class="children"><div class="content">You could even layer in PostgREST for a nice HTTP API that is available from any language!</div><br/></div></div><div id="41285186" class="c"><input type="checkbox" id="c-41285186" checked=""/><div class="controls bullet"><span class="by">CowOfKrakatoa</span><span>|</span><a href="#41286219">prev</a><span>|</span><a href="#41285896">next</a><span>|</span><label class="collapse" for="c-41285186">[-]</label><label class="expand" for="c-41285186">[4 more]</label></div><br/><div class="children"><div class="content">How does LISTEN&#x2F;NOTIFY compare to using select for update skip locked? I thought listen&#x2F;notify can lose queue items when the process crashes? Is that true? Do you need to code for those cases in some manner?</div><br/><div id="41285278" class="c"><input type="checkbox" id="c-41285278" checked=""/><div class="controls bullet"><span class="by">jeeybee</span><span>|</span><a href="#41285186">parent</a><span>|</span><a href="#41285951">next</a><span>|</span><label class="collapse" for="c-41285278">[-]</label><label class="expand" for="c-41285278">[1 more]</label></div><br/><div class="children"><div class="content">LISTEN&#x2F;NOTIFY and SELECT FOR UPDATE SKIP LOCKED serve different purposes in PgQueuer. LISTEN&#x2F;NOTIFY notifies consumers about changes in the queue table, prompting them to check for new jobs. This method doesn’t inherently lose messages if a process crashes, because it simply triggers a check rather than transmitting data. The actual job handling and locking are managed by SELECT FOR UPDATE SKIP LOCKED, which safely processes each job even when multiple workers are involved.</div><br/></div></div><div id="41285951" class="c"><input type="checkbox" id="c-41285951" checked=""/><div class="controls bullet"><span class="by">severino</span><span>|</span><a href="#41285186">parent</a><span>|</span><a href="#41285278">prev</a><span>|</span><a href="#41286474">next</a><span>|</span><label class="collapse" for="c-41285951">[-]</label><label class="expand" for="c-41285951">[1 more]</label></div><br/><div class="children"><div class="content">I think the usage of listen&#x2F;notify is just a mechanism to save you from querying the database every X seconds looking for new tasks (polling). That has some drawbacks, because if the timeout is too small, you are making too much queries that usually may not return any new tasks, and if it&#x27;s too big, then you may start processing the task long after it was submitted.
This way, it just notifies you that new tasks are ready so you can query the database.</div><br/></div></div><div id="41286474" class="c"><input type="checkbox" id="c-41286474" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#41285186">parent</a><span>|</span><a href="#41285951">prev</a><span>|</span><a href="#41285896">next</a><span>|</span><label class="collapse" for="c-41286474">[-]</label><label class="expand" for="c-41286474">[1 more]</label></div><br/><div class="children"><div class="content">There are two things:<p>1. Signaling<p>2. Messaging<p>In some systems, those are, effectively, the same. A consumer listens, and the signal is the message. If the consumer process crashes, the message returns to the queue and gets processed when the consumer comes back online.<p>If the signal and messaging are separated, as in Postgres, where LISTEN&#x2F;NOTIFY is the signal, and the skip locked query is the message pull, the consumer process would need to do some combination of polling and listening.<p>In the consumer, that could essentially be a loop that’s just doing the skip locked query on startup, then dropping into a LISTEN query only once there are no messages present in the queue. Then the LISTEN&#x2F;NOTIFY is just signaling to tell the consumer to check for new messages.</div><br/></div></div></div></div><div id="41285896" class="c"><input type="checkbox" id="c-41285896" checked=""/><div class="controls bullet"><span class="by">martinald</span><span>|</span><a href="#41285186">prev</a><span>|</span><a href="#41285422">next</a><span>|</span><label class="collapse" for="c-41285896">[-]</label><label class="expand" for="c-41285896">[4 more]</label></div><br/><div class="children"><div class="content">Any suggestions for something like this for dotnet?</div><br/><div id="41286757" class="c"><input type="checkbox" id="c-41286757" checked=""/><div class="controls bullet"><span class="by">wordofx</span><span>|</span><a href="#41285896">parent</a><span>|</span><a href="#41285931">next</a><span>|</span><label class="collapse" for="c-41286757">[-]</label><label class="expand" for="c-41286757">[1 more]</label></div><br/><div class="children"><div class="content">It’s a simple query to write. You don’t need a library or framework.</div><br/></div></div><div id="41285931" class="c"><input type="checkbox" id="c-41285931" checked=""/><div class="controls bullet"><span class="by">eknkc</span><span>|</span><a href="#41285896">parent</a><span>|</span><a href="#41286757">prev</a><span>|</span><a href="#41286448">next</a><span>|</span><label class="collapse" for="c-41285931">[-]</label><label class="expand" for="c-41285931">[1 more]</label></div><br/><div class="children"><div class="content">Hangfire with PostgreSQL driver.</div><br/></div></div><div id="41286448" class="c"><input type="checkbox" id="c-41286448" checked=""/><div class="controls bullet"><span class="by">hkon</span><span>|</span><a href="#41285896">parent</a><span>|</span><a href="#41285931">prev</a><span>|</span><a href="#41285422">next</a><span>|</span><label class="collapse" for="c-41286448">[-]</label><label class="expand" for="c-41286448">[1 more]</label></div><br/><div class="children"><div class="content">Updlock rowlock readpast should do the trick</div><br/></div></div></div></div><div id="41285422" class="c"><input type="checkbox" id="c-41285422" checked=""/><div class="controls bullet"><span class="by">redskyluan</span><span>|</span><a href="#41285896">prev</a><span>|</span><a href="#41286200">next</a><span>|</span><label class="collapse" for="c-41285422">[-]</label><label class="expand" for="c-41285422">[12 more]</label></div><br/><div class="children"><div class="content">there seems to be a big hype to adapt pg into any infra.
I love PG but this seems not be right thing.</div><br/><div id="41286596" class="c"><input type="checkbox" id="c-41286596" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#41285422">parent</a><span>|</span><a href="#41285805">next</a><span>|</span><label class="collapse" for="c-41286596">[-]</label><label class="expand" for="c-41286596">[1 more]</label></div><br/><div class="children"><div class="content">I think for me the problem with every single new PG queue is that it seems like everyone and their mother thinks they need to reinvent this specific wheel for some reason and the flavor of the day doesn’t often bring much new to the space. Probably because it&#x27;s<p>1. Pretty easy to understand and grok the problem space<p>2. Scratching the programmer itch of wanting something super generic that you can reuse all over the place<p>3. Doable with a modest effort over a reasonable scope of time<p>4. Built on rock solid internals (Postgres) with specific guarantees that you can lean on<p>Here&#x27;s 7 of them just right quick:<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;timgit&#x2F;pg-boss">https:&#x2F;&#x2F;github.com&#x2F;timgit&#x2F;pg-boss</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;queueclassic&#x2F;queue_classic">https:&#x2F;&#x2F;github.com&#x2F;queueclassic&#x2F;queue_classic</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;florentx&#x2F;pgqueue">https:&#x2F;&#x2F;github.com&#x2F;florentx&#x2F;pgqueue</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;mbreit&#x2F;pg_jobs">https:&#x2F;&#x2F;github.com&#x2F;mbreit&#x2F;pg_jobs</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;graphile&#x2F;worker">https:&#x2F;&#x2F;github.com&#x2F;graphile&#x2F;worker</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;pgq&#x2F;pgq">https:&#x2F;&#x2F;github.com&#x2F;pgq&#x2F;pgq</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;que-rb&#x2F;que">https:&#x2F;&#x2F;github.com&#x2F;que-rb&#x2F;que</a><p>Probably could easily find more by searching, I only spent about 5 minutes looking and grabbing the first ones I found.<p>I&#x27;m all for doing this kind of thing as an academic exercise, because it&#x27;s a great way to learn about this problem space. But at this point if you&#x27;re reinventing the Postgres job queue wheel and sharing it to this technical audience you need to probably also include why your wheel is particularly interesting if you want to grab my attention.</div><br/></div></div><div id="41285805" class="c"><input type="checkbox" id="c-41285805" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#41285422">parent</a><span>|</span><a href="#41286596">prev</a><span>|</span><a href="#41285980">next</a><span>|</span><label class="collapse" for="c-41285805">[-]</label><label class="expand" for="c-41285805">[6 more]</label></div><br/><div class="children"><div class="content">At low-medium scale, this will be fine. Even at higher scale, so long as you monitor autovacuum performance on the queue table.<p>At some point it may become practical to bring a dedicated queue system into the stack, sure, but this can massively simplify things when you don’t need or want the additional complexity.</div><br/><div id="41286428" class="c"><input type="checkbox" id="c-41286428" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#41285422">root</a><span>|</span><a href="#41285805">parent</a><span>|</span><a href="#41285901">next</a><span>|</span><label class="collapse" for="c-41286428">[-]</label><label class="expand" for="c-41286428">[4 more]</label></div><br/><div class="children"><div class="content">Aside from that, the main advantage of this is transactions. I can do:<p><pre><code>  begin;
    insert_row();
    schedule_job_for_elasticsearch();
  commit;
</code></pre>
And it&#x27;s guaranteed that both the row and job for Elasticsearch update are inserted.<p>If you use a dedicated queue system them this becomes a lot more tricky:<p><pre><code>  begin;
    insert_row();
    schedule_job_for_elasticsearch();
  commit; &#x2F;&#x2F; Can fail, and then we have a ES job but no SQL row.

  begin;
    insert_row();
  commit;
  schedule_job_for_elasticsearch(); &#x2F;&#x2F; Can fail, and then we have a SQL row and no job.
</code></pre>
There are of course also situations where this doesn&#x27;t apply, but this &quot;insert row(s) in SQL and then queue job to do more with that&quot; is a fairly common use case for queues, and in those cases this is a great choice.</div><br/><div id="41287879" class="c"><input type="checkbox" id="c-41287879" checked=""/><div class="controls bullet"><span class="by">jashmatthews</span><span>|</span><a href="#41285422">root</a><span>|</span><a href="#41286428">parent</a><span>|</span><a href="#41287010">next</a><span>|</span><label class="collapse" for="c-41287879">[-]</label><label class="expand" for="c-41287879">[1 more]</label></div><br/><div class="children"><div class="content">Transactional Outbox solves this. You use a table like in the first example but instead of actually doing the ElasticSearch update the Outbox table is piped into the dedicated queue.</div><br/></div></div><div id="41287010" class="c"><input type="checkbox" id="c-41287010" checked=""/><div class="controls bullet"><span class="by">nostrebored</span><span>|</span><a href="#41285422">root</a><span>|</span><a href="#41286428">parent</a><span>|</span><a href="#41287879">prev</a><span>|</span><a href="#41285901">next</a><span>|</span><label class="collapse" for="c-41287010">[-]</label><label class="expand" for="c-41287010">[2 more]</label></div><br/><div class="children"><div class="content">Most of these two phase problems can be solved by having separate queue consumers.<p>And as far as I can tell, this is only a perk when your two actions are mutate the collocated database and do X. For all other situations this seems like a downgrade.</div><br/><div id="41287902" class="c"><input type="checkbox" id="c-41287902" checked=""/><div class="controls bullet"><span class="by">jashmatthews</span><span>|</span><a href="#41285422">root</a><span>|</span><a href="#41287010">parent</a><span>|</span><a href="#41285901">next</a><span>|</span><label class="collapse" for="c-41287902">[-]</label><label class="expand" for="c-41287902">[1 more]</label></div><br/><div class="children"><div class="content">Do you mean like the consumer for the first phase enqueues a job for the second phase?</div><br/></div></div></div></div></div></div><div id="41285901" class="c"><input type="checkbox" id="c-41285901" checked=""/><div class="controls bullet"><span class="by">jeeybee</span><span>|</span><a href="#41285422">root</a><span>|</span><a href="#41285805">parent</a><span>|</span><a href="#41286428">prev</a><span>|</span><a href="#41285980">next</a><span>|</span><label class="collapse" for="c-41285901">[-]</label><label class="expand" for="c-41285901">[1 more]</label></div><br/><div class="children"><div class="content">I agree, there is no need for FANG level infrastructure. Imo. in most cases, the simplicity &#x2F; performance tradeoff for small&#x2F;medium is worth it. There is also a statistics tooling that helps you monitor throughput and failure rats (aggregated on a per second basis)</div><br/></div></div></div></div><div id="41285980" class="c"><input type="checkbox" id="c-41285980" checked=""/><div class="controls bullet"><span class="by">eknkc</span><span>|</span><a href="#41285422">parent</a><span>|</span><a href="#41285805">prev</a><span>|</span><a href="#41285572">next</a><span>|</span><label class="collapse" for="c-41285980">[-]</label><label class="expand" for="c-41285980">[1 more]</label></div><br/><div class="children"><div class="content">Instead of SQS, I recently created a basic abstraction on PG that mimics the SQS apis. The intention was to use it during development and we would simply switch to SQS later.<p>Never did. The production code still uses PG based queue (which has been improved since) and pg just works perfectly fine. Might still need to go with a dedicated queue service at some point but it has been perfectly fine so far.</div><br/></div></div><div id="41285572" class="c"><input type="checkbox" id="c-41285572" checked=""/><div class="controls bullet"><span class="by">mlnj</span><span>|</span><a href="#41285422">parent</a><span>|</span><a href="#41285980">prev</a><span>|</span><a href="#41286581">next</a><span>|</span><label class="collapse" for="c-41285572">[-]</label><label class="expand" for="c-41285572">[1 more]</label></div><br/><div class="children"><div class="content">I use it as a job queue. Yes, it has it&#x27;s cons, but not dealing with another moving piece in the big picture is totally worth it.</div><br/></div></div><div id="41286581" class="c"><input type="checkbox" id="c-41286581" checked=""/><div class="controls bullet"><span class="by">jascha_eng</span><span>|</span><a href="#41285422">parent</a><span>|</span><a href="#41285572">prev</a><span>|</span><a href="#41286200">next</a><span>|</span><label class="collapse" for="c-41286581">[-]</label><label class="expand" for="c-41286581">[2 more]</label></div><br/><div class="children"><div class="content">I mean I love postgres like the next guy. And I like simple solutions as long as they work.
I just wonder if this is truly simpler than using a redis or rabbitmq queue if you need Queues. If you&#x27;re already using a cloud provider sqs is quite trivial as well.<p>I guess if you already have postgres and don&#x27;t want to use the cloud provider&#x27;s solution. You can use this to avoid hosting another piece of infra.</div><br/><div id="41286634" class="c"><input type="checkbox" id="c-41286634" checked=""/><div class="controls bullet"><span class="by">bdcravens</span><span>|</span><a href="#41285422">root</a><span>|</span><a href="#41286581">parent</a><span>|</span><a href="#41286200">next</a><span>|</span><label class="collapse" for="c-41286634">[-]</label><label class="expand" for="c-41286634">[1 more]</label></div><br/><div class="children"><div class="content">db-based gives you the ability to query against your queues, if you use case needs it. Other options tend to dispose the state once the job is finished.</div><br/></div></div></div></div></div></div><div id="41286200" class="c"><input type="checkbox" id="c-41286200" checked=""/><div class="controls bullet"><span class="by">rgbrgb</span><span>|</span><a href="#41285422">prev</a><span>|</span><a href="#41285614">next</a><span>|</span><label class="collapse" for="c-41286200">[-]</label><label class="expand" for="c-41286200">[3 more]</label></div><br/><div class="children"><div class="content">Cool, congrats on releasing. Have you seen graphile worker? Wondering how this compares or if you&#x27;re building for different use-cases.</div><br/><div id="41288327" class="c"><input type="checkbox" id="c-41288327" checked=""/><div class="controls bullet"><span class="by">jeeybee</span><span>|</span><a href="#41286200">parent</a><span>|</span><a href="#41286735">next</a><span>|</span><label class="collapse" for="c-41288327">[-]</label><label class="expand" for="c-41288327">[1 more]</label></div><br/><div class="children"><div class="content">I haven’t used Graphile Worker since I’m not familiar with JavaScript. PgQueuer is tailored for Python with PostgreSQL environments. I’d be interested to hear about Graphile Worker’s features and how they might inspire improvements to PgQueuer.</div><br/></div></div><div id="41286735" class="c"><input type="checkbox" id="c-41286735" checked=""/><div class="controls bullet"><span class="by">mind-blight</span><span>|</span><a href="#41286200">parent</a><span>|</span><a href="#41288327">prev</a><span>|</span><a href="#41285614">next</a><span>|</span><label class="collapse" for="c-41286735">[-]</label><label class="expand" for="c-41286735">[1 more]</label></div><br/><div class="children"><div class="content">I think graphile worker is Node only. This project is for Python.</div><br/></div></div></div></div><div id="41285614" class="c"><input type="checkbox" id="c-41285614" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41286200">prev</a><span>|</span><a href="#41287979">next</a><span>|</span><label class="collapse" for="c-41285614">[-]</label><label class="expand" for="c-41285614">[1 more]</label></div><br/><div class="children"><div class="content">Does the celery SQLAlchemy broker support PostgreSQL&#x27;s LISTEN&#x2F;NOTIFY features?<p>Similar support in SQLite would simplify testing applications built with celery.<p>How to add table event messages to SQLite so that the SQLite broker has the same features as AMQP? Could a vtable facade send messages on tablet events?<p>Are there sqlite Triggers?<p>Celery &gt; Backends and Brokers: 
<a href="https:&#x2F;&#x2F;docs.celeryq.dev&#x2F;en&#x2F;stable&#x2F;getting-started&#x2F;backends-and-brokers&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.celeryq.dev&#x2F;en&#x2F;stable&#x2F;getting-started&#x2F;backends-...</a><p>&#x2F;? sqlalchemy listen notify: 
<a href="https:&#x2F;&#x2F;www.google.com&#x2F;search?q=sqlalchemy+listen+notify" rel="nofollow">https:&#x2F;&#x2F;www.google.com&#x2F;search?q=sqlalchemy+listen+notify</a> :<p>asyncpg.Connection.add_listener<p>sqlalchemy.event.listen, @listen_for<p>psychopg2 conn.poll(), while connection.notifies<p>psychopg2 &gt; docs &gt; advanced &gt; Advanced notifications: 
<a href="https:&#x2F;&#x2F;www.psycopg.org&#x2F;docs&#x2F;advanced.html#asynchronous-notifications" rel="nofollow">https:&#x2F;&#x2F;www.psycopg.org&#x2F;docs&#x2F;advanced.html#asynchronous-noti...</a><p>PgQueuer.db, PgQueuer.listeners.add_listener;  asyncpg add_listener: <a href="https:&#x2F;&#x2F;github.com&#x2F;janbjorge&#x2F;PgQueuer&#x2F;blob&#x2F;main&#x2F;src&#x2F;PgQueuer&#x2F;db.py">https:&#x2F;&#x2F;github.com&#x2F;janbjorge&#x2F;PgQueuer&#x2F;blob&#x2F;main&#x2F;src&#x2F;PgQueuer...</a><p>asyncpg&#x2F;tests&#x2F;test_listeners.py: 
<a href="https:&#x2F;&#x2F;github.com&#x2F;MagicStack&#x2F;asyncpg&#x2F;blob&#x2F;master&#x2F;tests&#x2F;test_listeners.py">https:&#x2F;&#x2F;github.com&#x2F;MagicStack&#x2F;asyncpg&#x2F;blob&#x2F;master&#x2F;tests&#x2F;test...</a><p>&#x2F;? sqlite LISTEN NOTIFY: <a href="https:&#x2F;&#x2F;www.google.com&#x2F;search?q=sqlite+listen+notify" rel="nofollow">https:&#x2F;&#x2F;www.google.com&#x2F;search?q=sqlite+listen+notify</a><p>sqlite3 update_hook: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;c3ref&#x2F;update_hook.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;c3ref&#x2F;update_hook.html</a></div><br/></div></div><div id="41287979" class="c"><input type="checkbox" id="c-41287979" checked=""/><div class="controls bullet"><span class="by">joseferben</span><span>|</span><a href="#41285614">prev</a><span>|</span><a href="#41287419">next</a><span>|</span><label class="collapse" for="c-41287979">[-]</label><label class="expand" for="c-41287979">[1 more]</label></div><br/><div class="children"><div class="content">for typescript there is pg-boss, works great for us</div><br/></div></div><div id="41287419" class="c"><input type="checkbox" id="c-41287419" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#41287979">prev</a><span>|</span><a href="#41285740">next</a><span>|</span><label class="collapse" for="c-41287419">[-]</label><label class="expand" for="c-41287419">[1 more]</label></div><br/><div class="children"><div class="content">Why so much code for Avery simple concept<p>One table.<p>Producer writes Co sumer reads<p>A very good idea</div><br/></div></div><div id="41285740" class="c"><input type="checkbox" id="c-41285740" checked=""/><div class="controls bullet"><span class="by">fijiaarone</span><span>|</span><a href="#41287419">prev</a><span>|</span><label class="collapse" for="c-41285740">[-]</label><label class="expand" for="c-41285740">[2 more]</label></div><br/><div class="children"><div class="content">You can make anything that stores data into a job queue.</div><br/><div id="41286099" class="c"><input type="checkbox" id="c-41286099" checked=""/><div class="controls bullet"><span class="by">kaoD</span><span>|</span><a href="#41285740">parent</a><span>|</span><label class="collapse" for="c-41286099">[-]</label><label class="expand" for="c-41286099">[1 more]</label></div><br/><div class="children"><div class="content">But can you make a <i>decent</i> job queue with anything that stores data? Not easily. E.g. you need atomicity if multiple consumers can take jobs, and I think you need CAS for that, not just any storage will do, right?<p>You probably need ACI and also D if you want your jobs to persist.</div><br/></div></div></div></div></div></div></div></div></div></body></html>