<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720256449524" as="style"/><link rel="stylesheet" href="styles.css?v=1720256449524"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://maciejwalkowiak.com/blog/postgres-uuid-primary-key/">PostgreSQL and UUID as Primary Key</a> <span class="domain">(<a href="https://maciejwalkowiak.com">maciejwalkowiak.com</a>)</span></div><div class="subtext"><span>taubek</span> | <span>208 comments</span></div><br/><div><div id="40885948" class="c"><input type="checkbox" id="c-40885948" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40885700">next</a><span>|</span><label class="collapse" for="c-40885948">[-]</label><label class="expand" for="c-40885948">[103 more]</label></div><br/><div class="children"><div class="content">The best advice I can give you is to use bigserial for B-tree friendly primary keys and consider a string-encoded UUID as one of your external record locator options. Consider other simple options like PNR-style (airline booking) locators first, especially if nontechnical users will quote them. It may even be OK if they’re reused every few years. Do not mix PK types within the schema for a service or application, especially a line-of-business application. Use UUIDv7 only as an identifier for data that is inherently timecoded, otherwise it leaks information (even if timeshifted). Do not use hashids - they have no cryptographic qualities and are less friendly to everyday humans than the integers they represent; you may as well just use the sequence ID.  As for the encoding, do not use base64 or other hyphenated alphabets, nor any identifier scheme that can produce a leading ‘0’ (zero) or ‘+’ (plus) when encoded (for the day your stuff is pasted via Excel).<p>Generally, the principles of separation of concerns and mechanical sympathy should be top of mind when designing a lasting and purposeful database schema.<p>Finally, since folks often say “I like stripe’s typed random IDs” in these kind of threads: Stripe are lying when they say their IDs are random. They have some random parts but when analyzed in sets, a large chunk of the binary layout is clearly metadata, including embedded timestamps, shard and reference keys, and versioning, in varying combinations depending on the service.  I estimate they typically have 48-64 bits of randomness. That’s still plenty for most systems; you can do the same. Personally I am very fond of base58-encoded AES-encrypted bigserial+HMAC locators with a leading type prefix and a trailing metadata digit, and you can in a pinch even do this inside the database with plv8.</div><br/><div id="40886496" class="c"><input type="checkbox" id="c-40886496" checked=""/><div class="controls bullet"><span class="by">GGO</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40886226">next</a><span>|</span><label class="collapse" for="c-40886496">[-]</label><label class="expand" for="c-40886496">[22 more]</label></div><br/><div class="children"><div class="content">I dont understand the recommendation of using bigserial with uuid column when you can use UUIDv7. I get that it made sense years ago when there was no UUIDv7, but why do people keep recommending it over UUIDv7 now beats me.</div><br/><div id="40887113" class="c"><input type="checkbox" id="c-40887113" checked=""/><div class="controls bullet"><span class="by">whynotmaybe</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886496">parent</a><span>|</span><a href="#40886884">next</a><span>|</span><label class="collapse" for="c-40887113">[-]</label><label class="expand" for="c-40887113">[17 more]</label></div><br/><div class="children"><div class="content">As uuid v7 hold time information, they can help bad actors for timing attacks or pattern recognition because they contain a time information linked to the record.<p>You can guess the time the system took between 2 uuid v7 id&#x27;s.<p>They can only be used if they&#x27;re not shown to the user.
 (so not in the form mysite.com&#x2F;mypage? id=0190854d-7f9f-78fc-b9bc-598867ebf39a)<p>A big serial starting at a high number can&#x27;t provide the time information.</div><br/><div id="40887971" class="c"><input type="checkbox" id="c-40887971" checked=""/><div class="controls bullet"><span class="by">TeeWEE</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887113">parent</a><span>|</span><a href="#40888623">next</a><span>|</span><label class="collapse" for="c-40887971">[-]</label><label class="expand" for="c-40887971">[2 more]</label></div><br/><div class="children"><div class="content">Big serial is sequential and it’s very easy to guess the next number. So you got the problem of sequential key attack…<p>If you use only uuid in your outwards facing api then you still have the problem of slow queries. Since you need them to find the object (as mentioned below)<p>UUIDv7 has a random part, can be created distributedly, and indexes well.<p>It’s the best choice for modern application that support distributed data creation.</div><br/><div id="40888678" class="c"><input type="checkbox" id="c-40888678" checked=""/><div class="controls bullet"><span class="by">badestrand</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887971">parent</a><span>|</span><a href="#40888623">next</a><span>|</span><label class="collapse" for="c-40888678">[-]</label><label class="expand" for="c-40888678">[1 more]</label></div><br/><div class="children"><div class="content">You never expose the bigserial, you generate a ID (like UUID) for external use&#x2F;identification and simply have an index over that column for fast selects.</div><br/></div></div></div></div><div id="40888623" class="c"><input type="checkbox" id="c-40888623" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887113">parent</a><span>|</span><a href="#40887971">prev</a><span>|</span><a href="#40888872">next</a><span>|</span><label class="collapse" for="c-40888623">[-]</label><label class="expand" for="c-40888623">[5 more]</label></div><br/><div class="children"><div class="content">Can I ask (as a humble application developer, not a backend&#x2F;database person), if the two requirements are:<p>1. The UUIDs should be ordered internally, for B-tree performance<p>2. The UUIDs should not be ordered externally, for security reasons<p>Why not use encryption? The unencrypted ID is a sequential id, but as soon as it leaves the database, it&#x27;s always encrypted. Like, when getting it out:<p><pre><code>    SELECT encrypt(id) FROM table WHERE something = whatever;
</code></pre>
and when putting stuff in:<p><pre><code>    UPDATE table SET something = whatever WHERE id = decrypt(&lt;encrypted-key&gt;)
</code></pre>
Seems like the best of both worlds, and you don&#x27;t need to store separate things.</div><br/><div id="40888795" class="c"><input type="checkbox" id="c-40888795" checked=""/><div class="controls bullet"><span class="by">spencerap</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888623">parent</a><span>|</span><a href="#40888836">next</a><span>|</span><label class="collapse" for="c-40888795">[-]</label><label class="expand" for="c-40888795">[3 more]</label></div><br/><div class="children"><div class="content">If the key and encryption mechanism are ever leaked, those opaque external IDs can be converted easily back to sequence numbers, and vice versa, which might pose a risk for you or your users. You won&#x27;t be able to rotate the encryption key without breaking anything external that tracks those encrypted IDs... third party services, SEO, user bookmarks, etc.</div><br/><div id="40888834" class="c"><input type="checkbox" id="c-40888834" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888795">parent</a><span>|</span><a href="#40888836">next</a><span>|</span><label class="collapse" for="c-40888834">[-]</label><label class="expand" for="c-40888834">[2 more]</label></div><br/><div class="children"><div class="content">You store the key in the database, right? Like, if the database leaks, it doesn’t matter if your ids are sequeneced or unsequenced, because <i>all data</i> has leaked anyway. The key leaking doesn’t seem like a realistic security issue.</div><br/><div id="40889034" class="c"><input type="checkbox" id="c-40889034" checked=""/><div class="controls bullet"><span class="by">zxexz</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888834">parent</a><span>|</span><a href="#40888836">next</a><span>|</span><label class="collapse" for="c-40889034">[-]</label><label class="expand" for="c-40889034">[1 more]</label></div><br/><div class="children"><div class="content">Ideally <i>if</i> you do this, you store the key in a separate schema with proper roles so that you can call encrypt() with the database role, which can&#x27;t select the key. Even then, the decrypted metadata should not be particularly sensitive -   and should immutably reference a point in time so you can validate against some known key revocation retroactively.<p>My take is it&#x27;s rarely necessary to have a token, that you give to an external entity, that has any embedded metadata all - 99.9% of apps aren&#x27;t operating at a scale where even a million-key hashmap sitting in ram and syncing changes to disk on update would cause any performance difference.</div><br/></div></div></div></div></div></div><div id="40888836" class="c"><input type="checkbox" id="c-40888836" checked=""/><div class="controls bullet"><span class="by">fauigerzigerk</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888623">parent</a><span>|</span><a href="#40888795">prev</a><span>|</span><a href="#40888872">next</a><span>|</span><label class="collapse" for="c-40888836">[-]</label><label class="expand" for="c-40888836">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt;Why not use encryption?</i><p>Because then you have a key management problem, which adds complexity.</div><br/></div></div></div></div><div id="40888872" class="c"><input type="checkbox" id="c-40888872" checked=""/><div class="controls bullet"><span class="by">thiht</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887113">parent</a><span>|</span><a href="#40888623">prev</a><span>|</span><a href="#40888011">next</a><span>|</span><label class="collapse" for="c-40888872">[-]</label><label class="expand" for="c-40888872">[1 more]</label></div><br/><div class="children"><div class="content">I don’t understand how that’s an issue. Do you have an example of a possible attack using UUIDv7 timestamp? Is there evidence of this being a real security flaw?</div><br/></div></div><div id="40888011" class="c"><input type="checkbox" id="c-40888011" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887113">parent</a><span>|</span><a href="#40888872">prev</a><span>|</span><a href="#40888560">next</a><span>|</span><label class="collapse" for="c-40888011">[-]</label><label class="expand" for="c-40888011">[7 more]</label></div><br/><div class="children"><div class="content">For almost all use cases just showing a UUIDv7 or sequential ID is fine. There are a few exceptions, but it&#x27;s not the common case.</div><br/><div id="40888083" class="c"><input type="checkbox" id="c-40888083" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888011">parent</a><span>|</span><a href="#40888560">next</a><span>|</span><label class="collapse" for="c-40888083">[-]</label><label class="expand" for="c-40888083">[6 more]</label></div><br/><div class="children"><div class="content">How would it be fine, e.g. for e commerce which is arguably very large portion of the use cases?<p>You would be immediately leaking how many orders a day your business is getting with sequential id.</div><br/><div id="40888243" class="c"><input type="checkbox" id="c-40888243" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888083">parent</a><span>|</span><a href="#40888274">next</a><span>|</span><label class="collapse" for="c-40888243">[-]</label><label class="expand" for="c-40888243">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You would be immediately leaking how many orders a day your business is getting with sequential id.<p>Which is fine for almost all of them. All brick and mortar stores &quot;leak&quot; this too; it&#x27;s really not that hard to guess number of orders for most businesses, and it&#x27;s not really a problem for the overwhelming majority.<p>And &quot;Hi, this is Martin, I&#x27;d like to ask a question about order 2bf8aa01-6f4e-42ae-8635-9648f70a9a05&quot; doesn&#x27;t really work. Neither does &quot;John, did you already pay order 2bf8aa01-6f4e-42ae-8635-9648f70a9a05&quot; or &quot;Alice, isn&#x27;t 2bf8aa01-6f4e-42ae-8635-9648f70a9a05 the same as what we ordered with 7bb027c3-83ea-481a-bb1e-861be18d21ea?&quot;<p><i>Especially</i> for order IDs UUIDs are huge PITA because unlike user IDs and other more &quot;internal&quot; IDs, people can and do want to talk about them. You will need some secondary human-friendly unique ID regardless (possibly obfuscated, if you really want to), and if you have that, then why bother giving UUIDs to people?</div><br/><div id="40888689" class="c"><input type="checkbox" id="c-40888689" checked=""/><div class="controls bullet"><span class="by">badestrand</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888243">parent</a><span>|</span><a href="#40888274">next</a><span>|</span><label class="collapse" for="c-40888689">[-]</label><label class="expand" for="c-40888689">[1 more]</label></div><br/><div class="children"><div class="content">Best solution is to have a serial identifier internally and a generated ID for external. And yes it shouldn&#x27;t be a UUID as they are user-hostile, it should be something like 6-10 letters+digits.</div><br/></div></div></div></div><div id="40888274" class="c"><input type="checkbox" id="c-40888274" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888083">parent</a><span>|</span><a href="#40888243">prev</a><span>|</span><a href="#40888560">next</a><span>|</span><label class="collapse" for="c-40888274">[-]</label><label class="expand" for="c-40888274">[3 more]</label></div><br/><div class="children"><div class="content">There are jurisdictions e.g. Germany in which a consecutive sequence for invoice numbers is a mandatory, legislated requirement (mercifully, gaps are generally permitted, with caveats)<p>For extra spice, in some places this is legislated as a per-seller sequence, and in others as a per-customer sequence, so there’s no policy you can apply globally, and this once again highlights the separation of concerns between a primary key and a record locator&#x2F;identifier.</div><br/><div id="40888397" class="c"><input type="checkbox" id="c-40888397" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888274">parent</a><span>|</span><a href="#40888390">next</a><span>|</span><label class="collapse" for="c-40888397">[-]</label><label class="expand" for="c-40888397">[1 more]</label></div><br/><div class="children"><div class="content">&gt; consecutive sequence for invoice numbers is a mandatory, legislated requirement (mercifully, gaps are generally permitted, with caveats)<p>That’s surprising. In Denmark gaps are not allowed. You have to account for all invoices and if you have an invoice numbered 50, then you have at least 50 invoices to account for.</div><br/></div></div><div id="40888390" class="c"><input type="checkbox" id="c-40888390" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888274">parent</a><span>|</span><a href="#40888397">prev</a><span>|</span><a href="#40888560">next</a><span>|</span><label class="collapse" for="c-40888390">[-]</label><label class="expand" for="c-40888390">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There are jurisdictions e.g. Germany in which a consecutive sequence for invoice numbers is a mandatory<p>Same in France. I thought it was a pretty common requirement.</div><br/></div></div></div></div></div></div></div></div><div id="40888560" class="c"><input type="checkbox" id="c-40888560" checked=""/><div class="controls bullet"><span class="by">sebazzz</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887113">parent</a><span>|</span><a href="#40888011">prev</a><span>|</span><a href="#40886884">next</a><span>|</span><label class="collapse" for="c-40888560">[-]</label><label class="expand" for="c-40888560">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As uuid v7 hold time information, they can help bad actors for timing attacks or pattern recognition because they contain a time information linked to the record.<p>Are you then not doing security by randomness if that is the thing that worries you?</div><br/></div></div></div></div><div id="40886884" class="c"><input type="checkbox" id="c-40886884" checked=""/><div class="controls bullet"><span class="by">dajtxx</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886496">parent</a><span>|</span><a href="#40887113">prev</a><span>|</span><a href="#40888154">next</a><span>|</span><label class="collapse" for="c-40886884">[-]</label><label class="expand" for="c-40886884">[2 more]</label></div><br/><div class="children"><div class="content">The comment above warns against it due to the embedded timestamp info as a info leak risk. Perhaps that was a problem for them in some circumstance.</div><br/><div id="40888252" class="c"><input type="checkbox" id="c-40888252" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886884">parent</a><span>|</span><a href="#40888154">next</a><span>|</span><label class="collapse" for="c-40888252">[-]</label><label class="expand" for="c-40888252">[1 more]</label></div><br/><div class="children"><div class="content">It wasn’t a problem for me directly but was observed and related by a colleague:  an identifier for an acquired entity embedded the record’s creation timestamp and effectively leaked the date of  acquisition despite it being commercial-in-confidence information. Cue post-M&amp;A ruckus at board level.<p>Just goes to show you can’t inadvertently disclose anything these days.</div><br/></div></div></div></div><div id="40888154" class="c"><input type="checkbox" id="c-40888154" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886496">parent</a><span>|</span><a href="#40886884">prev</a><span>|</span><a href="#40886226">next</a><span>|</span><label class="collapse" for="c-40888154">[-]</label><label class="expand" for="c-40888154">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re saving storage space but potentially leaking details.  Is that ok for your application?  No one can answer but your org.</div><br/><div id="40888847" class="c"><input type="checkbox" id="c-40888847" checked=""/><div class="controls bullet"><span class="by">hoffs</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888154">parent</a><span>|</span><a href="#40886226">next</a><span>|</span><label class="collapse" for="c-40888847">[-]</label><label class="expand" for="c-40888847">[1 more]</label></div><br/><div class="children"><div class="content">The details part is so miniscule that I doubt it even matters. You&#x27;d have difficult time trying to enumerate uuidv7s anyways.</div><br/></div></div></div></div></div></div><div id="40886226" class="c"><input type="checkbox" id="c-40886226" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40886496">prev</a><span>|</span><a href="#40887642">next</a><span>|</span><label class="collapse" for="c-40886226">[-]</label><label class="expand" for="c-40886226">[47 more]</label></div><br/><div class="children"><div class="content">IMO using bigserial by default is wrong. Use whatever data type is appropriate. Not every table will grow to 4 billion rows and not every table will grow to even 60k rows. ID data type leaks to every foreign key referencing given table. Many foreign key usually will be indexed, so this further degrades performance. There are multiple data types for a reason.</div><br/><div id="40886571" class="c"><input type="checkbox" id="c-40886571" checked=""/><div class="controls bullet"><span class="by">njtransit</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886226">parent</a><span>|</span><a href="#40886372">next</a><span>|</span><label class="collapse" for="c-40886571">[-]</label><label class="expand" for="c-40886571">[19 more]</label></div><br/><div class="children"><div class="content">Using 32 bit ints for IDs is insane in today’s world. If an attacker can control record generation, e.g. creating a record via API, then they can easily exhaust your ID space. A lot of kernel vulnerabilities stem from using incrementing 32 bit integers as an identifier. If you’re considering using 32 bits for an ID, don’t do it!</div><br/><div id="40886784" class="c"><input type="checkbox" id="c-40886784" checked=""/><div class="controls bullet"><span class="by">incrudible</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886571">parent</a><span>|</span><a href="#40886820">next</a><span>|</span><label class="collapse" for="c-40886784">[-]</label><label class="expand" for="c-40886784">[17 more]</label></div><br/><div class="children"><div class="content">If an attacker can create billions of records through your API, maybe that is a problem you need to address either way.</div><br/><div id="40887927" class="c"><input type="checkbox" id="c-40887927" checked=""/><div class="controls bullet"><span class="by">njtransit</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886784">parent</a><span>|</span><a href="#40886986">next</a><span>|</span><label class="collapse" for="c-40887927">[-]</label><label class="expand" for="c-40887927">[4 more]</label></div><br/><div class="children"><div class="content">It’s about 100 records per second for a year and a half, or 10,000 records per second for 5 days. Both are easily achievable. As an engineer, why would you ever knowingly design such a system when it’s trivial to not have this vulnerability in the first place.<p>It’s like hosting an internal app at a company that contains a SQL injection. “Well, if a hacker can access this app, then that’s a problem that needs addressing either way.” Sure, that may be true, but it’s also true that you’re not a good software engineer.</div><br/><div id="40888032" class="c"><input type="checkbox" id="c-40888032" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887927">parent</a><span>|</span><a href="#40889063">next</a><span>|</span><label class="collapse" for="c-40888032">[-]</label><label class="expand" for="c-40888032">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It’s like hosting an internal app at a company that contains a SQL injection<p>It&#x27;s nothing like that at all because the wrong SQL injection can completely ruin people&#x27;s lives due to leaking stuff it shouldn&#x27;t whereas the worst an int exhaustion can do is bring some app offline. Whoopdie-doo. Okay, that&#x27;s not brilliant, but it&#x27;s not comparable at all.<p>And there&#x27;s a reason there aren&#x27;t tons of &quot;int exhaustion attacks&quot;: because there&#x27;s little point in doing so.</div><br/><div id="40888066" class="c"><input type="checkbox" id="c-40888066" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888032">parent</a><span>|</span><a href="#40889063">next</a><span>|</span><label class="collapse" for="c-40888066">[-]</label><label class="expand" for="c-40888066">[1 more]</label></div><br/><div class="children"><div class="content">So taking down the apps ability to insert any rows into the table (and hence breaking the app) isn’t going to impact anyone? Including the apps ability to make money?<p>This does happen and break people. You usually don’t hear about it (except on the SRE side) because it is so obvious when it happens to someone they <i>really</i> don’t like talking about it.</div><br/></div></div></div></div><div id="40889063" class="c"><input type="checkbox" id="c-40889063" checked=""/><div class="controls bullet"><span class="by">fauigerzigerk</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887927">parent</a><span>|</span><a href="#40888032">prev</a><span>|</span><a href="#40886986">next</a><span>|</span><label class="collapse" for="c-40889063">[-]</label><label class="expand" for="c-40889063">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not a great analogy. SQL injection is a completely binary issue. A single malicious statement that gets through can do all the damage.<p>Defending against denial of service attacks is a gradual, multifaceted problem that is pretty unlikely to hinge on the size of database keys.<p>If your system is dimensioned to serve a few hundered users then it&#x27;s not going to be a whole lot more robust if it can theoretically create thousands of trillions of user records rather than just hundereds of millions.<p>In fact, infinite scalability is a risk in its own right because it can bankrupt you, which is arguably worse than a temporary outage.<p>That said, I tend to use 64 bit IDs by default as well unless there is a good reason not to (because, you know, what if I&#x27;m the next Google?!?!?).</div><br/></div></div></div></div><div id="40886986" class="c"><input type="checkbox" id="c-40886986" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886784">parent</a><span>|</span><a href="#40887927">prev</a><span>|</span><a href="#40888223">next</a><span>|</span><label class="collapse" for="c-40886986">[-]</label><label class="expand" for="c-40886986">[10 more]</label></div><br/><div class="children"><div class="content">Conversely: if using bigserial for a primary key introduces crippling performance problems to your system, maybe that is a problem you need to address either way.</div><br/><div id="40887100" class="c"><input type="checkbox" id="c-40887100" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886986">parent</a><span>|</span><a href="#40888223">next</a><span>|</span><label class="collapse" for="c-40887100">[-]</label><label class="expand" for="c-40887100">[9 more]</label></div><br/><div class="children"><div class="content">Conversely? Who mentioned there being a performance impact?</div><br/><div id="40887245" class="c"><input type="checkbox" id="c-40887245" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887100">parent</a><span>|</span><a href="#40888178">next</a><span>|</span><label class="collapse" for="c-40887245">[-]</label><label class="expand" for="c-40887245">[7 more]</label></div><br/><div class="children"><div class="content">It’s the only reason I could think of for why you wouldn’t use a bigserial column. Maybe there is another?</div><br/><div id="40887352" class="c"><input type="checkbox" id="c-40887352" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887245">parent</a><span>|</span><a href="#40888178">next</a><span>|</span><label class="collapse" for="c-40887352">[-]</label><label class="expand" for="c-40887352">[6 more]</label></div><br/><div class="children"><div class="content">Information leakage - it leaks how many records have been created [<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;German_tank_problem" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;German_tank_problem</a>]</div><br/><div id="40887486" class="c"><input type="checkbox" id="c-40887486" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887352">parent</a><span>|</span><a href="#40888178">next</a><span>|</span><label class="collapse" for="c-40887486">[-]</label><label class="expand" for="c-40887486">[5 more]</label></div><br/><div class="children"><div class="content">That’s why the original comment suggested both bigserial and a separate UUID for public exposure. More to the point the person I was replying to said:<p>&gt; IMO using bigserial by default is wrong. Use whatever data type is appropriate. Not every table will grow to 4 billion rows and not every table will grow to even 60k rows<p>The implication I took from that was that they were suggesting using serial over bigserial. My comment was pushing back on that.</div><br/><div id="40887602" class="c"><input type="checkbox" id="c-40887602" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887486">parent</a><span>|</span><a href="#40888178">next</a><span>|</span><label class="collapse" for="c-40887602">[-]</label><label class="expand" for="c-40887602">[4 more]</label></div><br/><div class="children"><div class="content">My Dream Web Framework, which for a variety of reasons was never and never will be built, has built-in functionality for obscuring IDs in some session-level map, so you can indicate through some sort of type that something is an ID and it automatically allocates some sort of randomized identifier on the way out and converts it back transparently on the way back in.<p>Thus, not only would DB ids in principle never show in the UI, they wouldn&#x27;t even be stable between sessions.<p>This would protect against a number of security attacks. (I don&#x27;t know what I&#x27;d do about bookmarking, though I suspect most apps have a 80&#x2F;20 solution they could deploy.) DB ids going out to a user really ought to be considered at least a smell, but it&#x27;s pretty ingrained into our culture.</div><br/><div id="40888785" class="c"><input type="checkbox" id="c-40888785" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887602">parent</a><span>|</span><a href="#40887724">next</a><span>|</span><label class="collapse" for="c-40888785">[-]</label><label class="expand" for="c-40888785">[1 more]</label></div><br/><div class="children"><div class="content">That wouldn&#x27;t work for integration scenarios where the other system need to store the ID so it can refer to it later. How would you provide IDs for integration purposes?</div><br/></div></div><div id="40887724" class="c"><input type="checkbox" id="c-40887724" checked=""/><div class="controls bullet"><span class="by">gregoryl</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887602">parent</a><span>|</span><a href="#40888785">prev</a><span>|</span><a href="#40888178">next</a><span>|</span><label class="collapse" for="c-40887724">[-]</label><label class="expand" for="c-40887724">[2 more]</label></div><br/><div class="children"><div class="content">I wrote that style of session mapping for a project long ago. It was fairly easy, but a massive pain in the ass to debug. Ended up needing to record the mappings in the backend for a period of time.</div><br/><div id="40888120" class="c"><input type="checkbox" id="c-40888120" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887724">parent</a><span>|</span><a href="#40888178">next</a><span>|</span><label class="collapse" for="c-40888120">[-]</label><label class="expand" for="c-40888120">[1 more]</label></div><br/><div class="children"><div class="content">I too coded that in my server. It&#x27;s not hard to do, and debugging can be harder at times (but not excessively so.) As you say it&#x27;s just a case of logging when debugging.<p>When anchors are needed I use a different column for that- not the primary index. (Usually some other unique, already-present, value like the sku or whatever.<p>The security implications though are substantial. I don&#x27;t leak primary key info even if the PK is serialized. (These days I&#x27;m all-in on UIDS but I have older legacy systems to deal with too.)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40888223" class="c"><input type="checkbox" id="c-40888223" checked=""/><div class="controls bullet"><span class="by">klooney</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886784">parent</a><span>|</span><a href="#40886986">prev</a><span>|</span><a href="#40888062">next</a><span>|</span><label class="collapse" for="c-40888223">[-]</label><label class="expand" for="c-40888223">[1 more]</label></div><br/><div class="children"><div class="content">If you expose an API, your customer&#x27;s CI systems will probably get there eventually.</div><br/></div></div><div id="40888062" class="c"><input type="checkbox" id="c-40888062" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886784">parent</a><span>|</span><a href="#40888223">prev</a><span>|</span><a href="#40886820">next</a><span>|</span><label class="collapse" for="c-40888062">[-]</label><label class="expand" for="c-40888062">[1 more]</label></div><br/><div class="children"><div class="content">It doesn’t require an attacker to create billions of rows.<p>All it requires is for there to be billions of rows. 32 bits is nutty small considering how little overhead there is in storing 64 bits instead.</div><br/></div></div></div></div></div></div><div id="40886372" class="c"><input type="checkbox" id="c-40886372" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886226">parent</a><span>|</span><a href="#40886571">prev</a><span>|</span><a href="#40886645">next</a><span>|</span><label class="collapse" for="c-40886372">[-]</label><label class="expand" for="c-40886372">[6 more]</label></div><br/><div class="children"><div class="content">Defaulting to 64-bit integers internally is to me a matter of mechanical sympathy, it has little to do with row capacity. It’s just a word size that current CPUs and memory architectures like working with.</div><br/><div id="40886725" class="c"><input type="checkbox" id="c-40886725" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886372">parent</a><span>|</span><a href="#40886645">next</a><span>|</span><label class="collapse" for="c-40886725">[-]</label><label class="expand" for="c-40886725">[5 more]</label></div><br/><div class="children"><div class="content">What architecture? Both amd64 and ARM64 can work with 32-bit integers just fine.</div><br/><div id="40887107" class="c"><input type="checkbox" id="c-40887107" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886725">parent</a><span>|</span><a href="#40886645">next</a><span>|</span><label class="collapse" for="c-40887107">[-]</label><label class="expand" for="c-40887107">[4 more]</label></div><br/><div class="children"><div class="content">Not optimally.</div><br/><div id="40887258" class="c"><input type="checkbox" id="c-40887258" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887107">parent</a><span>|</span><a href="#40886645">next</a><span>|</span><label class="collapse" for="c-40887258">[-]</label><label class="expand" for="c-40887258">[3 more]</label></div><br/><div class="children"><div class="content">It is not optimal to use 8-byte integers instead of 4-bytes.<p>CPU works just as fast with both, however your CPU cache is limited and you&#x27;ll put more 4-byte integers into your L1.<p>I don&#x27;t really understand what you want to convey. CPU is very fast with any kind of integer size. There&#x27;s no performance penalty to use 1-byte integer compared to 8-byte integer. And there&#x27;s performance penalty when your L1 or L2 or L3 cache is busted and you need to go to the next memory layer.</div><br/><div id="40888637" class="c"><input type="checkbox" id="c-40888637" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887258">parent</a><span>|</span><a href="#40887354">next</a><span>|</span><label class="collapse" for="c-40888637">[-]</label><label class="expand" for="c-40888637">[1 more]</label></div><br/><div class="children"><div class="content">1-byte integers or any other integers smaller than 8 bytes (64 bits) save space only when they are parts of arrays or structures.<p>As individual variables, they take exactly the same space as 64-bit integers, both in registers and in memory (i.e. in the stack used for automatic variables or in the heap used for dynamically-allocated variables), because of the alignment requirements.<p>Therefore it never makes sense to use other integers than 64-bit, except as members of aggregate data types.<p>A database table is an aggregate data type, so the use of small integers in some columns may be justified, but such types shall not be used for variables in the programs that process data from the tables, where misuse of the small integers may cause overflows and there is no advantage from using smaller integer sizes.</div><br/></div></div><div id="40887354" class="c"><input type="checkbox" id="c-40887354" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887258">parent</a><span>|</span><a href="#40888637">prev</a><span>|</span><a href="#40886645">next</a><span>|</span><label class="collapse" for="c-40887354">[-]</label><label class="expand" for="c-40887354">[1 more]</label></div><br/><div class="children"><div class="content">&gt; CPU works just as fast with both<p>They don&#x27;t. CPUs have as many issues with data alignment as with cache sizes.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40886645" class="c"><input type="checkbox" id="c-40886645" checked=""/><div class="controls bullet"><span class="by">rangerelf</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886226">parent</a><span>|</span><a href="#40886372">prev</a><span>|</span><a href="#40887638">next</a><span>|</span><label class="collapse" for="c-40886645">[-]</label><label class="expand" for="c-40886645">[3 more]</label></div><br/><div class="children"><div class="content">I read your post and hear echoes of &quot;Who would ever need more than 2 digits for the year in this timestamp column?&quot;<p>Never again.</div><br/><div id="40886718" class="c"><input type="checkbox" id="c-40886718" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886645">parent</a><span>|</span><a href="#40887638">next</a><span>|</span><label class="collapse" for="c-40886718">[-]</label><label class="expand" for="c-40886718">[2 more]</label></div><br/><div class="children"><div class="content">Using 2 digits for year is as wrong as using 8 bytes for year.</div><br/><div id="40888405" class="c"><input type="checkbox" id="c-40888405" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886718">parent</a><span>|</span><a href="#40887638">next</a><span>|</span><label class="collapse" for="c-40888405">[-]</label><label class="expand" for="c-40888405">[1 more]</label></div><br/><div class="children"><div class="content">scale of damage is very different, so &quot;as&quot; is up to discussion.</div><br/></div></div></div></div></div></div><div id="40888812" class="c"><input type="checkbox" id="c-40888812" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886226">parent</a><span>|</span><a href="#40887638">prev</a><span>|</span><a href="#40888701">next</a><span>|</span><label class="collapse" for="c-40888812">[-]</label><label class="expand" for="c-40888812">[1 more]</label></div><br/><div class="children"><div class="content">Postgres doesn&#x27;t support unsigned ints last I looked, so it&#x27;s actually a ~2 billion limit.<p>Secondly, it&#x27;s not XXXk rows currently-you have to consider the complete lifetime of the table.  When rows are deleted&#x2F;created and how often.<p>So what you&#x27;ve said is true, but the set of appropriateness for smallint is a much smaller than expected.</div><br/></div></div><div id="40888701" class="c"><input type="checkbox" id="c-40888701" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886226">parent</a><span>|</span><a href="#40888812">prev</a><span>|</span><a href="#40886380">next</a><span>|</span><label class="collapse" for="c-40888701">[-]</label><label class="expand" for="c-40888701">[1 more]</label></div><br/><div class="children"><div class="content">The problems from unnecessary bigserial is nothing compared to the pain of insufficient serial.<p>This is especially true for PostgreSQL which increments sequences for upserts (even if no records are inserted).<p>That&#x27;s how I&#x27;ve hit 32-bit limits on tables that had only a couple million rows.<p>---<p>I would only use 32-bit for very selective items that is used in a lot of FKs, like a tenant ID.</div><br/></div></div><div id="40886380" class="c"><input type="checkbox" id="c-40886380" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886226">parent</a><span>|</span><a href="#40888701">prev</a><span>|</span><a href="#40887642">next</a><span>|</span><label class="collapse" for="c-40886380">[-]</label><label class="expand" for="c-40886380">[15 more]</label></div><br/><div class="children"><div class="content">there is unlikely significant performance degradation for int vs big int, but it will be huge PITA, if 10 years later and tons of legacy code written that table will grow over 4B rows..</div><br/><div id="40887171" class="c"><input type="checkbox" id="c-40887171" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886380">parent</a><span>|</span><a href="#40887642">next</a><span>|</span><label class="collapse" for="c-40887171">[-]</label><label class="expand" for="c-40887171">[14 more]</label></div><br/><div class="children"><div class="content">It’s double the size. 4 bytes * 2^31 (because Postgres doesn’t allow have unsigned ints, unlike MySQL) is 8.6 GB. That is quite a difference for an index, not to mention the table overhead.<p>You’re going to know well in advance before hitting this limit becomes an issue, and you’ll have plenty of time to either take a bit of downtime and do a column conversion, or do an online migration.</div><br/><div id="40887211" class="c"><input type="checkbox" id="c-40887211" checked=""/><div class="controls bullet"><span class="by">big_whack</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887171">parent</a><span>|</span><a href="#40887207">next</a><span>|</span><label class="collapse" for="c-40887211">[-]</label><label class="expand" for="c-40887211">[3 more]</label></div><br/><div class="children"><div class="content">Postgres pads tuples to 8 bytes alignment so an indexed single-column int takes the same space as an indexed bigint. That&#x27;s the usual case for indexed foreign keys.<p>Differences can appear in multicolumn indexes because two ints takes 8 bytes while two bigints takes 16, however the right layout of columns for an index is not always the layout that minimizes padding.</div><br/><div id="40887878" class="c"><input type="checkbox" id="c-40887878" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887211">parent</a><span>|</span><a href="#40887207">next</a><span>|</span><label class="collapse" for="c-40887878">[-]</label><label class="expand" for="c-40887878">[2 more]</label></div><br/><div class="children"><div class="content">Postgres doesn&#x27;t necessarily pad to 8 bytes; it depends on the next column&#x27;s type. EDB has a good writeup on this (<a href="https:&#x2F;&#x2F;www.2ndquadrant.com&#x2F;en&#x2F;blog&#x2F;on-rocks-and-sand&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.2ndquadrant.com&#x2F;en&#x2F;blog&#x2F;on-rocks-and-sand&#x2F;</a>), but also here&#x27;s a small example:<p><pre><code>  CREATE TABLE foo
    (id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY, iid INT NOT NULL);

  CREATE TABLE bar
    (id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY, iid BIGINT NOT NULL);

  CREATE TABLE baz
    (id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY, iid BIGINT NOT NULL);

  -- fill each with 1,000,000 rows, then index

  CREATE INDEX {foo,bar,baz}_iid_idx ON {foo,bar,baz}(iid);

  SELECT table_name,
         pg_size_pretty(pg_table_size(quote_ident(table_name))) &quot;table_size&quot;,
         pg_size_pretty(pg_indexes_size(quote_ident(table_name))) &quot;index_size&quot;
  FROM information_schema.tables
  WHERE table_schema = &#x27;public&#x27;;

   table_name | table_size | index_size
  ------------+------------+------------
   foo        | 35 MB      | 43 MB
   bar        | 42 MB      | 43 MB
   baz        | 42 MB      | 43 MB
</code></pre>
`foo` has an INT followed by an INT, and its table size is 35 MB. `bar` has an INT followed by a BIGINT, and its table size is 43 MB; this is the same size for `baz`, despite `baz` being a BIGINT followed by a BIGINT.</div><br/><div id="40888039" class="c"><input type="checkbox" id="c-40888039" checked=""/><div class="controls bullet"><span class="by">big_whack</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887878">parent</a><span>|</span><a href="#40887207">next</a><span>|</span><label class="collapse" for="c-40888039">[-]</label><label class="expand" for="c-40888039">[1 more]</label></div><br/><div class="children"><div class="content">You seem to think you&#x27;re disagreeing with me but afaict you&#x27;re just demonstrating my point, unless your point is just about how (int, int) will get packed. That&#x27;s what I meant about the column order of indexes. If you have two ints and a bigint, but you need to index it like (int, bigint, int), then you aren&#x27;t gaining anything there either.<p>As your example shows, there is no benefit in index size (e.g for supporting FKs) in going from int to bigint for a single key. You end up with the same index size no matter what, not twice the size which was what I took your original post to mean.</div><br/></div></div></div></div></div></div><div id="40887207" class="c"><input type="checkbox" id="c-40887207" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887171">parent</a><span>|</span><a href="#40887211">prev</a><span>|</span><a href="#40887642">next</a><span>|</span><label class="collapse" for="c-40887207">[-]</label><label class="expand" for="c-40887207">[10 more]</label></div><br/><div class="children"><div class="content">&gt; 4 bytes * 2^31 (because Postgres doesn’t allow have unsigned ints, unlike MySQL) is 8.6 GB<p>I didn&#x27;t get your point. When it is 2^31, you definitely need bigint already. When it is much smaller, it will be much smaller overhead.<p>Also, per docs (<a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;storage-page-layout.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;storage-page-layout....</a>), each postgres row has 23 bytes overhead, so your transition from 8-&gt;4 bytes will bring marginal improvement.</div><br/><div id="40888116" class="c"><input type="checkbox" id="c-40888116" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887207">parent</a><span>|</span><a href="#40887893">next</a><span>|</span><label class="collapse" for="c-40888116">[-]</label><label class="expand" for="c-40888116">[5 more]</label></div><br/><div class="children"><div class="content">With multiple tables and the same IDs being references more than once, this kind of stuff can really add up.<p>For example I have a table that has about a billion rows and uses bigserial, but that table references about 6 other much smaller tables that use serial. I&#x27;m saving 48 bytes per row, or 90GB in total. It&#x27;s a fairly significant save, and that&#x27;s just on this one table: I have a bunch of tables like this. If I had bigint&#x27;d everything my disk space would be roughly double. And all of that is not even considering the extra index size and memory requirements.<p>Using bigint here would add absolutely nothing. I&#x27;m never going to have billions of users. I&#x27;m never going to have billions of different operating systems. There will never be billions of countries. I can probably get away with smallint for some of those, but I felt the extra headroom for that was worth the extra bytes.<p>This is why &quot;bigint by default&quot; is just bad advice IMHO. You will always need to think about it. <i>Of course</i> you shouldn&#x27;t prematurely optimize integer sizes, but it&#x27;s also not true that it doesn&#x27;t matter, because it does. &quot;Better safe than sorry&quot; also applies in the other direction: &quot;zomg we&#x27;re wasting tons of disk space and spend much more money on servers than we need to&quot; just because someone unthinkingly applied some stupid dogma they read on HN and didn&#x27;t spend 4 seconds thinking about it.</div><br/><div id="40888247" class="c"><input type="checkbox" id="c-40888247" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888116">parent</a><span>|</span><a href="#40887893">next</a><span>|</span><label class="collapse" for="c-40888247">[-]</label><label class="expand" for="c-40888247">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m saving 48 bytes per row<p>you saving 24 bytes per row: downsizing 6 columns from 8 bytes to 4, which is fraction of your table size. If your system is sensitive to such change, you likely should optimize something else.<p>&gt; Using bigint here would add absolutely nothing. I&#x27;m never going to have billions of users. I&#x27;m never going to have billions of different operating systems.<p>I think you cherry picked some fictional examples which you won&#x27;t combine in one table, and your real entities are different. It adds process safety: you don&#x27;t need to play mind quizzes to estimate how system can grow&#x2F;change in a N years.</div><br/><div id="40888298" class="c"><input type="checkbox" id="c-40888298" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888247">parent</a><span>|</span><a href="#40887893">next</a><span>|</span><label class="collapse" for="c-40888298">[-]</label><label class="expand" for="c-40888298">[3 more]</label></div><br/><div class="children"><div class="content">&gt; cherry picked some fictional example<p>What an incredibly rude and dismissive accusation. Here&#x27;s my table: <a href="https:&#x2F;&#x2F;github.com&#x2F;arp242&#x2F;goatcounter&#x2F;blob&#x2F;master&#x2F;db&#x2F;schema.gotxt#L70">https:&#x2F;&#x2F;github.com&#x2F;arp242&#x2F;goatcounter&#x2F;blob&#x2F;master&#x2F;db&#x2F;schema....</a> – number of IDs is actually 7, not 6.<p>I can give a lot more details and context on all of that and why it works the way it works and the savings are certainly not insignificant and theoretical, but save me real money in server costs every month. But I have little interest in talking to you further since you&#x27;re just going to insult everyone who tries to inject the slightest nuance into &quot;always use bigserial&quot;-extremism. So good day to you.</div><br/><div id="40888318" class="c"><input type="checkbox" id="c-40888318" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888298">parent</a><span>|</span><a href="#40887893">next</a><span>|</span><label class="collapse" for="c-40888318">[-]</label><label class="expand" for="c-40888318">[2 more]</label></div><br/><div class="children"><div class="content">&gt;   <a href="https:&#x2F;&#x2F;github.com&#x2F;arp242&#x2F;goatcounter&#x2F;blob&#x2F;master&#x2F;db&#x2F;schema">https:&#x2F;&#x2F;github.com&#x2F;arp242&#x2F;goatcounter&#x2F;blob&#x2F;master&#x2F;db&#x2F;schema</a>.... - number of IDs is actually 7, not 6.<p>the point is that some&#x2F;many of those ids are not timezone and country, and potentially can grow high in cardinality.</div><br/><div id="40889021" class="c"><input type="checkbox" id="c-40889021" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888318">parent</a><span>|</span><a href="#40887893">next</a><span>|</span><label class="collapse" for="c-40889021">[-]</label><label class="expand" for="c-40889021">[1 more]</label></div><br/><div class="children"><div class="content">No, my point is you accused me of lying at the drop of a hat for no good reason, and that this is demonstrably not true. Don&#x27;t try and spinelessly slime your way out of that. And no, they I won&#x27;t run out of IDs for them. &quot;Potentially&quot; anything can happen, but it won&#x27;t happen here. After five year the furthest sequence is 0.86% on its way of being full.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40887893" class="c"><input type="checkbox" id="c-40887893" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887207">parent</a><span>|</span><a href="#40888116">prev</a><span>|</span><a href="#40887642">next</a><span>|</span><label class="collapse" for="c-40887893">[-]</label><label class="expand" for="c-40887893">[4 more]</label></div><br/><div class="children"><div class="content">Not all tables need even the capacity for 2^30 rows, much less 2^31, or 2^63. If you have a reference table with things like timezone information, color schemes, etc. and are using anything other than a SMALLINT (2^15), you&#x27;re probably wasting space.<p>As to the maximal 8.6 GB mentioned, that&#x27;s not nothing, _especially_ for RAM. Disk is cheap, but RAM isn&#x27;t. If you have a smaller instance – say, an r6i.xlarge on AWS (4 vCPU, 32 GB RAM), that&#x27;s 1&#x2F;4 of the entire DB&#x27;s memory.</div><br/><div id="40887924" class="c"><input type="checkbox" id="c-40887924" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887893">parent</a><span>|</span><a href="#40887642">next</a><span>|</span><label class="collapse" for="c-40887924">[-]</label><label class="expand" for="c-40887924">[3 more]</label></div><br/><div class="children"><div class="content">so, what about my argument that PG has 23 bytes overhead per row and your space win is very small compared to that overhead?</div><br/><div id="40888458" class="c"><input type="checkbox" id="c-40888458" checked=""/><div class="controls bullet"><span class="by">nirvdrum</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887924">parent</a><span>|</span><a href="#40887642">next</a><span>|</span><label class="collapse" for="c-40888458">[-]</label><label class="expand" for="c-40888458">[2 more]</label></div><br/><div class="children"><div class="content">Is that an innate property or a current implementation detail?</div><br/><div id="40888472" class="c"><input type="checkbox" id="c-40888472" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888458">parent</a><span>|</span><a href="#40887642">next</a><span>|</span><label class="collapse" for="c-40888472">[-]</label><label class="expand" for="c-40888472">[1 more]</label></div><br/><div class="children"><div class="content">price for various features, like ACID.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40887642" class="c"><input type="checkbox" id="c-40887642" checked=""/><div class="controls bullet"><span class="by">saaspirant</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40886226">prev</a><span>|</span><a href="#40886904">next</a><span>|</span><label class="collapse" for="c-40887642">[-]</label><label class="expand" for="c-40887642">[7 more]</label></div><br/><div class="children"><div class="content">Naive question. Above comment suggests using bigserial as internal identifier and uuid as public facing ID.
Now let&#x27;s say there&#x27;s a user table and post table. Both will have only uuid available in the APIs. So every time API requests a post of the user or user of the post, we will find the the relevant row using uuid right? Since uuid will be sent by the public facing APIs?
How would bigserial be used here?<p>I don&#x27;t know much databases in general BTW..<p>Edit: Can I use uuidv4 as PK since it doesn&#x27;t leak timestamp data? Why bigserial + uuid7 is better?</div><br/><div id="40887702" class="c"><input type="checkbox" id="c-40887702" checked=""/><div class="controls bullet"><span class="by">jpollock</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887642">parent</a><span>|</span><a href="#40886904">next</a><span>|</span><label class="collapse" for="c-40887702">[-]</label><label class="expand" for="c-40887702">[6 more]</label></div><br/><div class="children"><div class="content">Each object has an external key and an internal key. This separation allows you to migrate to other layouts, technologies, etc. without breaking your customer&#x27;s links or records.<p>Internally, your database looks like:<p><pre><code>  User
    ID - uint128
    external_id - UUID (of some sort)
    name - string

  Post
    ID - uint128
    UserId - uint128 (User.ID)
    external_id - UUID
    ...
</code></pre>
Then you have secondary indices on the external_id columns in both tables, and the UserId column on Post. You can then join from one to the other using the ID column.<p>e.g.<p><pre><code>  SELECT count(*) FROM
   Post JOIN User 
   ON User.ID = Post.UserID
  WHERE 
   User.external_id = &lt;%USERID_FROM_REQUEST%&gt;;

  &#x2F;&#x2F; Don&#x27;t forget to bind USER_ID_FROM_REQUEST instead of 
  &#x2F;&#x2F; concating the string, no Johny-Tables here!
</code></pre>
There should be significant performance benefits from using int&#x27;s for the joining keys (at least compared to strings), but my experience might be old.</div><br/><div id="40888381" class="c"><input type="checkbox" id="c-40888381" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887702">parent</a><span>|</span><a href="#40887976">next</a><span>|</span><label class="collapse" for="c-40888381">[-]</label><label class="expand" for="c-40888381">[1 more]</label></div><br/><div class="children"><div class="content">A uuid is just an uint128, or a byte array of the same size. A DB can use them as fixed size keys just fine, and they convert quickly from&#x2F;into their string representaion.<p>The problem is indexing and generation.<p>For example sqlite already generates sequential ids whether you use them or not.<p>Non sequential uuids suck for indexing as the table grows. There are some benchmarks and explanations to look up.<p>The benefit is you can merge aggregates from different DB instances without a fuss. And you can generate uuids without asking your DB.</div><br/></div></div><div id="40887976" class="c"><input type="checkbox" id="c-40887976" checked=""/><div class="controls bullet"><span class="by">TeeWEE</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887702">parent</a><span>|</span><a href="#40888381">prev</a><span>|</span><a href="#40888139">next</a><span>|</span><label class="collapse" for="c-40887976">[-]</label><label class="expand" for="c-40887976">[3 more]</label></div><br/><div class="children"><div class="content">So it can’t use the internal id index, result: slow lookups for external ids.</div><br/><div id="40888049" class="c"><input type="checkbox" id="c-40888049" checked=""/><div class="controls bullet"><span class="by">bfung</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887976">parent</a><span>|</span><a href="#40888139">next</a><span>|</span><label class="collapse" for="c-40888049">[-]</label><label class="expand" for="c-40888049">[2 more]</label></div><br/><div class="children"><div class="content">&gt; secondary indices on the external_id columns in both tables<p>pick your poison, slower lookup or more disk usage</div><br/><div id="40888626" class="c"><input type="checkbox" id="c-40888626" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888049">parent</a><span>|</span><a href="#40888139">next</a><span>|</span><label class="collapse" for="c-40888626">[-]</label><label class="expand" for="c-40888626">[1 more]</label></div><br/><div class="children"><div class="content">There are other fun ideas to explore e.g. if your external id is a hash you can rebuild, it might be an option to scavenge the full hash but keep the first few bytes of it, indexed. That increases lookup costs if the hash does not exist or has been scavenged but lowers storage.<p>In fact if your external ids are evenly distributed you can do that anyway, only index the few leading &#x2F; trailing bytes of the id. That will increase lookup costs a bit but significantly decrease storage.</div><br/></div></div></div></div></div></div><div id="40888139" class="c"><input type="checkbox" id="c-40888139" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887702">parent</a><span>|</span><a href="#40887976">prev</a><span>|</span><a href="#40886904">next</a><span>|</span><label class="collapse" for="c-40888139">[-]</label><label class="expand" for="c-40888139">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>no Johny-Tables here!</i><p>It’s “Bobby tables”: &lt;<a href="https:&#x2F;&#x2F;xkcd.com&#x2F;327&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;327&#x2F;</a>&gt;</div><br/></div></div></div></div></div></div><div id="40886904" class="c"><input type="checkbox" id="c-40886904" checked=""/><div class="controls bullet"><span class="by">brycelarkin</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40887642">prev</a><span>|</span><a href="#40888034">next</a><span>|</span><label class="collapse" for="c-40886904">[-]</label><label class="expand" for="c-40886904">[6 more]</label></div><br/><div class="children"><div class="content">For postgres, you want to use “bigint generated always as identity” instead of bigserial.</div><br/><div id="40888157" class="c"><input type="checkbox" id="c-40888157" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886904">parent</a><span>|</span><a href="#40888885">next</a><span>|</span><label class="collapse" for="c-40888157">[-]</label><label class="expand" for="c-40888157">[1 more]</label></div><br/><div class="children"><div class="content">I agree and apologise for writing bigserial out of ossified habit. Identity columns hew to the SQL standard, bigserial is a pg-ism. I actually do still use it when the ORM’s DDL generator prefers as much (looking at you Rails), there’s no gain from fighting the middleware.<p>For other readers: the two are almost the same in behaviour, they differ primarily in that identity columns don’t need a USAGE grant on their associated sequence, and the ALWAYS makes it harder (but despite the term not actually impossible) to override the default value on row insert.</div><br/></div></div><div id="40888885" class="c"><input type="checkbox" id="c-40888885" checked=""/><div class="controls bullet"><span class="by">thiht</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886904">parent</a><span>|</span><a href="#40888157">prev</a><span>|</span><a href="#40887572">next</a><span>|</span><label class="collapse" for="c-40888885">[-]</label><label class="expand" for="c-40888885">[1 more]</label></div><br/><div class="children"><div class="content">Why?</div><br/></div></div><div id="40887572" class="c"><input type="checkbox" id="c-40887572" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886904">parent</a><span>|</span><a href="#40888885">prev</a><span>|</span><a href="#40888034">next</a><span>|</span><label class="collapse" for="c-40887572">[-]</label><label class="expand" for="c-40887572">[3 more]</label></div><br/><div class="children"><div class="content">Why  “bigint generated always as identity” instead of bigserial, instead of Postgres&#x27; uuid data type?<p>Postgres&#x27; UUID datatype: 
<a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-uuid.html#DATATYPE-UUID" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-uuid.html#D...</a><p>django.db.models.fields.UUIDField: <a href="https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.0&#x2F;ref&#x2F;models&#x2F;fields&#x2F;#uuidfield" rel="nofollow">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.0&#x2F;ref&#x2F;models&#x2F;fields&#x2F;#uui...</a> :<p>&gt; class UUIDField: <i>A field for storing universally unique identifiers. Uses Python’s UUID class. When used on PostgreSQL and MariaDB 10.7+, this stores in a uuid datatype, otherwise in a char(32)</i><p>&gt; [...] <i>Lookups on PostgreSQL and MariaDB 10.7+</i>: <i>Using iexact, contains, icontains, startswith, istartswith, endswith, or iendswith lookups on PostgreSQL don’t work for values without hyphens, because PostgreSQL and MariaDB 10.7+ store them in a hyphenated uuid datatype type.</i><p>From the sqlalachemy.types.Uuid docs: <a href="https:&#x2F;&#x2F;docs.sqlalchemy.org&#x2F;en&#x2F;20&#x2F;core&#x2F;type_basics.html#sqlalchemy.types.Uuid" rel="nofollow">https:&#x2F;&#x2F;docs.sqlalchemy.org&#x2F;en&#x2F;20&#x2F;core&#x2F;type_basics.html#sqla...</a> :<p>&gt; <i>Represent a database agnostic UUID datatype.</i><p>&gt; <i>For backends that have no “native” UUID datatype, the value will make use of CHAR(32) and store the UUID as a 32-character alphanumeric hex string.</i><p>&gt; <i>For backends which are known to support UUID directly or a similar uuid-storing datatype such as SQL Server’s UNIQUEIDENTIFIER, a “native” mode enabled by default allows these types will be used on those backends.</i><p>&gt; <i>In its default mode of use, the Uuid datatype expects Python uuid objects, from the Python uuid module</i><p>From the docs for the uuid Python module: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;uuid.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;uuid.html</a> :<p>&gt; class uuid.SafeUUID: <i>Added in version 3.7.</i><p>&gt; <i>safe: The UUID was generated by the platform in a multiprocessing-safe way</i><p>And there&#x27;s not yet a uuid.uuid7() in the uuid Python module.<p>UUIDv7 leaks timing information ( <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40886496">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40886496</a> ); which is ironic because uuids are usually used to avoid the &quot;guess an autoincrement integer key&quot; issue</div><br/><div id="40887725" class="c"><input type="checkbox" id="c-40887725" checked=""/><div class="controls bullet"><span class="by">avg_dev</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887572">parent</a><span>|</span><a href="#40887850">prev</a><span>|</span><a href="#40888034">next</a><span>|</span><label class="collapse" for="c-40887725">[-]</label><label class="expand" for="c-40887725">[1 more]</label></div><br/><div class="children"><div class="content">Just noting, the commenter you replied to said:<p>&gt;  use “bigint generated always as identity” instead of bigserial.<p>The commenter you are replying to was not saying anything about whether to use UUIDs or not; they just said &quot;if you are going to use bigserial, you should use bigint generated always as identity instead&quot;.</div><br/></div></div></div></div></div></div><div id="40888034" class="c"><input type="checkbox" id="c-40888034" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40886904">prev</a><span>|</span><a href="#40888153">next</a><span>|</span><label class="collapse" for="c-40888034">[-]</label><label class="expand" for="c-40888034">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never played enough with UUIDs in Postgres, but I wonder if you could publicly expose only the random bits (i.e. the second half if an UUIDv7) and have another non-b-tree index on SUBSTR(id, 16) for quick lookups based on that value. Similar is done for &quot;short commit hashes&quot; too.<p>Though I would wonder why go with UUIDs in that case at all?</div><br/><div id="40888086" class="c"><input type="checkbox" id="c-40888086" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888034">parent</a><span>|</span><a href="#40888153">next</a><span>|</span><label class="collapse" for="c-40888086">[-]</label><label class="expand" for="c-40888086">[1 more]</label></div><br/><div class="children"><div class="content">Offhand, I remember _reading_ about that but haven&#x27;t ever used it in practice so please test and confirm...<p># Postgres can Index Function Results (including what you described)<p># Postgres does not magically know to USE those results.  To use them you must E.G. JOIN (probably works for WHERE?) or ORDER or LIMIT by the same parameter that went into the Index (which is how it&#x27;s matched up).<p>Generally, the Primary Key should either be &#x27;small&#x27; (BigInt can count as such) and only used internally or be something strongly relevant to how the records in that table can be limited for most (or the most) queries.</div><br/></div></div></div></div><div id="40888153" class="c"><input type="checkbox" id="c-40888153" checked=""/><div class="controls bullet"><span class="by">olalonde</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40888034">prev</a><span>|</span><a href="#40886876">next</a><span>|</span><label class="collapse" for="c-40888153">[-]</label><label class="expand" for="c-40888153">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They have some random parts but when analyzed in sets, a large chunk of the binary layout is clearly metadata, including embedded timestamps, shard and reference keys, and versioning, in varying combinations depending on the service.<p>Could you share this analysis? Seems interesting.</div><br/></div></div><div id="40886876" class="c"><input type="checkbox" id="c-40886876" checked=""/><div class="controls bullet"><span class="by">solidsnack9000</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40888153">prev</a><span>|</span><a href="#40887943">next</a><span>|</span><label class="collapse" for="c-40886876">[-]</label><label class="expand" for="c-40886876">[10 more]</label></div><br/><div class="children"><div class="content">One challenge with PNR is actually restricting the alphabet appropriately. They sure are easy to say aloud -- just five or six letters in many cases -- but how do you ensure you have (a) enough letters to get a reasonable bitwidth and (b) not form ridiculous words?</div><br/><div id="40887287" class="c"><input type="checkbox" id="c-40887287" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886876">parent</a><span>|</span><a href="#40886945">next</a><span>|</span><label class="collapse" for="c-40887287">[-]</label><label class="expand" for="c-40887287">[3 more]</label></div><br/><div class="children"><div class="content">Do you ensure that your software does not form ridiculous numbers? Imagine that some christian person gets &quot;666&quot; number. What a scandal.<p>Do you ensure that your software does not form ridiculous words in every language? Or just another US-centric thing?<p>The idea of avoiding identifiers to be ridiculous is ridiculous to me, honestly...</div><br/><div id="40887670" class="c"><input type="checkbox" id="c-40887670" checked=""/><div class="controls bullet"><span class="by">solidsnack9000</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887287">parent</a><span>|</span><a href="#40888687">next</a><span>|</span><label class="collapse" for="c-40887670">[-]</label><label class="expand" for="c-40887670">[1 more]</label></div><br/><div class="children"><div class="content">This is just not going work in a customer centric organization. If SABRE gave out PNRs like, I don&#x27;t know, SEXGOD, it would make customers angry, and that is not even with any curse words. They are heavily filtered.<p><a href="https:&#x2F;&#x2F;onemileatatime.com&#x2F;insights&#x2F;funny-airline-pnr&#x2F;" rel="nofollow">https:&#x2F;&#x2F;onemileatatime.com&#x2F;insights&#x2F;funny-airline-pnr&#x2F;</a></div><br/></div></div><div id="40888687" class="c"><input type="checkbox" id="c-40888687" checked=""/><div class="controls bullet"><span class="by">alex_duf</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887287">parent</a><span>|</span><a href="#40887670">prev</a><span>|</span><a href="#40886945">next</a><span>|</span><label class="collapse" for="c-40888687">[-]</label><label class="expand" for="c-40888687">[1 more]</label></div><br/><div class="children"><div class="content">You can also get 666 in a quid for what it&#x27;s worth</div><br/></div></div></div></div><div id="40886945" class="c"><input type="checkbox" id="c-40886945" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886876">parent</a><span>|</span><a href="#40887287">prev</a><span>|</span><a href="#40886962">next</a><span>|</span><label class="collapse" for="c-40886945">[-]</label><label class="expand" for="c-40886945">[2 more]</label></div><br/><div class="children"><div class="content">&gt; not form ridiculous words<p>Depends on what you mean by ridiculous.<p>For example <a href="https:&#x2F;&#x2F;sqids.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sqids.org&#x2F;</a> ensures that there are no profanities in the generated ids. And it allows you to add additional words that you want to avoid.</div><br/><div id="40887676" class="c"><input type="checkbox" id="c-40887676" checked=""/><div class="controls bullet"><span class="by">solidsnack9000</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886945">parent</a><span>|</span><a href="#40886962">next</a><span>|</span><label class="collapse" for="c-40887676">[-]</label><label class="expand" for="c-40887676">[1 more]</label></div><br/><div class="children"><div class="content">It does but it allows common names, the name of the deity, common words, &amp;c. I suspect you have to do something like an earlier poster suggested -- strip out all the vowels to start with...</div><br/></div></div></div></div><div id="40886962" class="c"><input type="checkbox" id="c-40886962" checked=""/><div class="controls bullet"><span class="by">dmurray</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886876">parent</a><span>|</span><a href="#40886945">prev</a><span>|</span><a href="#40887943">next</a><span>|</span><label class="collapse" for="c-40886962">[-]</label><label class="expand" for="c-40886962">[4 more]</label></div><br/><div class="children"><div class="content">Take all the Roman alphabet apart from the vowels - 21 characters and length 6 gives you 100 million possibilities which is plenty for most applications.<p>You can still get vaguely offensive sequences like FKNNGR or BLKCNT, but at some point you have to put this down not to your software being offensive or hateful but to humans finding patterns in randomness.</div><br/><div id="40887120" class="c"><input type="checkbox" id="c-40887120" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886962">parent</a><span>|</span><a href="#40887674">next</a><span>|</span><label class="collapse" for="c-40887120">[-]</label><label class="expand" for="c-40887120">[1 more]</label></div><br/><div class="children"><div class="content">Use Crockford encoding to reduce this. It has readability and dictation considerations too which makes it ideal for things humans will interface with.</div><br/></div></div><div id="40887674" class="c"><input type="checkbox" id="c-40887674" checked=""/><div class="controls bullet"><span class="by">solidsnack9000</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40886962">parent</a><span>|</span><a href="#40887120">prev</a><span>|</span><a href="#40887943">next</a><span>|</span><label class="collapse" for="c-40887674">[-]</label><label class="expand" for="c-40887674">[2 more]</label></div><br/><div class="children"><div class="content">Removing Y turns out to be important, as well...</div><br/><div id="40888686" class="c"><input type="checkbox" id="c-40888686" checked=""/><div class="controls bullet"><span class="by">alex_duf</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887674">parent</a><span>|</span><a href="#40887943">next</a><span>|</span><label class="collapse" for="c-40888686">[-]</label><label class="expand" for="c-40888686">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still bothering me that Y is a vowel in french but not in English. Can we all agree on something for once?</div><br/></div></div></div></div></div></div></div></div><div id="40887943" class="c"><input type="checkbox" id="c-40887943" checked=""/><div class="controls bullet"><span class="by">TeeWEE</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40886876">prev</a><span>|</span><a href="#40887990">next</a><span>|</span><label class="collapse" for="c-40887943">[-]</label><label class="expand" for="c-40887943">[4 more]</label></div><br/><div class="children"><div class="content">If you have distributed data creation. (Creating data on the client). And a CRDT style mechanism for syncing, then you can’t use bigserial because of the simple fact that it is sequential. The best solution here is uuidv7. Since you can generate these at the client even when offline.</div><br/><div id="40888003" class="c"><input type="checkbox" id="c-40888003" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887943">parent</a><span>|</span><a href="#40887990">next</a><span>|</span><label class="collapse" for="c-40888003">[-]</label><label class="expand" for="c-40888003">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not true, you can increment by 2, 10, 100, or any number. I&#x27;m not saying that&#x27;s necessarily the best solution, but it&#x27;s not true that you can&#x27;t use it.</div><br/><div id="40888057" class="c"><input type="checkbox" id="c-40888057" checked=""/><div class="controls bullet"><span class="by">azinman2</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888003">parent</a><span>|</span><a href="#40887990">next</a><span>|</span><label class="collapse" for="c-40888057">[-]</label><label class="expand" for="c-40888057">[2 more]</label></div><br/><div class="children"><div class="content">But if you’re distributed or offline incrementing by an arbitrary amount can still create collisions unless you’re willing to increment by very very large amounts at random, in which case you’ve effectively reinvented uuid</div><br/><div id="40888151" class="c"><input type="checkbox" id="c-40888151" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40888057">parent</a><span>|</span><a href="#40887990">next</a><span>|</span><label class="collapse" for="c-40888151">[-]</label><label class="expand" for="c-40888151">[1 more]</label></div><br/><div class="children"><div class="content">No, every server will have its own series:<p><pre><code>  Server 1: [1 4 7]
  Server 2: [2 5 8]
  Server 3: [3 6 9]
</code></pre>
Or whatever is appropriate. You can even add&#x2F;change this later on.<p>Again, I&#x27;m not saying it&#x27;s necessarily the best solution, I&#x27;m just saying it&#x27;s possible. I&#x27;m not really interested in a long discussion about uuid vs. serial because it&#x27;s been done to death a million times. Previous poster said it&#x27;s impossible and that&#x27;s just flat-out wrong.</div><br/></div></div></div></div></div></div></div></div><div id="40887990" class="c"><input type="checkbox" id="c-40887990" checked=""/><div class="controls bullet"><span class="by">darby_nine</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40887943">prev</a><span>|</span><a href="#40886702">next</a><span>|</span><label class="collapse" for="c-40887990">[-]</label><label class="expand" for="c-40887990">[2 more]</label></div><br/><div class="children"><div class="content">You really have to understand the usage patterns of a program to give a recommendation. Anyone who doesn&#x27;t is just a grifter.<p>I don&#x27;t trust anyone who gives recommendations sight unseen.</div><br/><div id="40888172" class="c"><input type="checkbox" id="c-40888172" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40885948">root</a><span>|</span><a href="#40887990">parent</a><span>|</span><a href="#40886702">next</a><span>|</span><label class="collapse" for="c-40888172">[-]</label><label class="expand" for="c-40888172">[1 more]</label></div><br/><div class="children"><div class="content">100% this. Context is everything, and advice without understanding context should be suspect at best.<p>That said, I&#x27;ve found that contexts can change. Personally I started with the database being local (send single). It the migrated to remote (web), after that to distributed and from there to mobile.<p>As contexts gave changed I&#x27;ve found we needed to switch to UUID (and the switch was a pain.) A lot of our problems would simply not exist if we&#x27;d used uuid from the start.<p>So now my &quot;default advice&quot; is uuid, unless there&#x27;s a -specific- reason not to. For me, performance is not that reason (your database outlives multiple generations of hardware, and faster hardware will dwarf optimisation-via-data-type.)<p>And don&#x27;t get me started on natural versus surrogate identifiers- that ship sailed decades ago.)</div><br/></div></div></div></div><div id="40886702" class="c"><input type="checkbox" id="c-40886702" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40885948">parent</a><span>|</span><a href="#40887990">prev</a><span>|</span><a href="#40885700">next</a><span>|</span><label class="collapse" for="c-40886702">[-]</label><label class="expand" for="c-40886702">[1 more]</label></div><br/><div class="children"><div class="content">Why string encoded column? Is it just to make the table bigger?<p>Why not just use the UUID type??</div><br/></div></div></div></div><div id="40885700" class="c"><input type="checkbox" id="c-40885700" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#40885948">prev</a><span>|</span><a href="#40888922">next</a><span>|</span><label class="collapse" for="c-40885700">[-]</label><label class="expand" for="c-40885700">[13 more]</label></div><br/><div class="children"><div class="content">My somewhat naive understanding was that random UUIDs were not that big of a deal in Postgres because it does not cluster by primary key. And of course a UUID (16 bytes) is larger than a serial (4 bytes) or bigserial (8 bytes) by a factor of 2-4 . This certainly might matter for an index, but on a whole table level where you have 20+ bytes overhead per row this doesn&#x27;t seem that big of a deal for anything except very narrow tables with large row counts.<p>So far my impression is that there are a whole lot of other things I need to worry about in Postgres before I spend time considering serial vs. random UUID vs. ordered UUID. Am I wrong here and this is something that really matters and you should invest more time in?</div><br/><div id="40885808" class="c"><input type="checkbox" id="c-40885808" checked=""/><div class="controls bullet"><span class="by">oppositelock</span><span>|</span><a href="#40885700">parent</a><span>|</span><a href="#40885976">next</a><span>|</span><label class="collapse" for="c-40885808">[-]</label><label class="expand" for="c-40885808">[5 more]</label></div><br/><div class="children"><div class="content">Random UUID&#x27;s are super useful when you have distributed creation of UUID&#x27;s, because you avoid conflicts with very high probability and don&#x27;t rely on your DB to generate them for you, and they also leak no information about when or where the UUID was created.<p>Postgres is happier with sequence ID&#x27;s, but keeping Postgres happy isn&#x27;t the only design goal. It does well enough for all practical purposes if you need randomness.</div><br/><div id="40887645" class="c"><input type="checkbox" id="c-40887645" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40885700">root</a><span>|</span><a href="#40885808">parent</a><span>|</span><a href="#40887181">next</a><span>|</span><label class="collapse" for="c-40887645">[-]</label><label class="expand" for="c-40887645">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Postgres is happier with sequence ID&#x27;s, but keeping Postgres happy isn&#x27;t the only design goal.<p>It literally is the one thing in the entire stack that must always be happy. Every stateful service likely depends on it. Sad DBs means higher latency for everyone, and grumpy DBREs getting paged.</div><br/><div id="40887854" class="c"><input type="checkbox" id="c-40887854" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#40885700">root</a><span>|</span><a href="#40887645">parent</a><span>|</span><a href="#40887181">next</a><span>|</span><label class="collapse" for="c-40887854">[-]</label><label class="expand" for="c-40887854">[2 more]</label></div><br/><div class="children"><div class="content">DBRE? I guess DBA is too old fashioned for the cool kids?</div><br/><div id="40887899" class="c"><input type="checkbox" id="c-40887899" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40885700">root</a><span>|</span><a href="#40887854">parent</a><span>|</span><a href="#40887181">next</a><span>|</span><label class="collapse" for="c-40887899">[-]</label><label class="expand" for="c-40887899">[1 more]</label></div><br/><div class="children"><div class="content">Listen, I didn&#x27;t make the title up, I just grabbed onto it from the SRE world because I love databases.<p>There are some pragmatic differences I&#x27;ve found, though - generally, DBAs are less focused on things like IaC (though I know at least one who does), SLIs&#x2F;SLOs, CI&#x2F;CD, and the other things often associated with SRE. So DBRE is SRE + DBA, or a DB-focused SRE, if you&#x27;d rather.</div><br/></div></div></div></div></div></div><div id="40887181" class="c"><input type="checkbox" id="c-40887181" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40885700">root</a><span>|</span><a href="#40885808">parent</a><span>|</span><a href="#40887645">prev</a><span>|</span><a href="#40885976">next</a><span>|</span><label class="collapse" for="c-40887181">[-]</label><label class="expand" for="c-40887181">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Random UUID&#x27;s are super useful when you have distributed creation of UUID&#x27;s, because you avoid conflicts with very high probability and don&#x27;t rely on your DB to generate them for you<p>See Snowflake IDs for a scheme that gives you the benefit of random UUIDs but are strictly increasing. Which is really UUIDv7 but fits in your bigint column. No entropy required.</div><br/></div></div></div></div><div id="40885976" class="c"><input type="checkbox" id="c-40885976" checked=""/><div class="controls bullet"><span class="by">kevin_nisbet</span><span>|</span><a href="#40885700">parent</a><span>|</span><a href="#40885808">prev</a><span>|</span><a href="#40886113">next</a><span>|</span><label class="collapse" for="c-40885976">[-]</label><label class="expand" for="c-40885976">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So far my impression is that there are a whole lot of other things I need to worry about in Postgres before I spend time considering serial vs. random UUID vs. ordered UUID. Am I wrong here and this is something that really matters and you should invest more time in?<p>Like any sort of optimization I believe this will depend on your workload and what&#x27;s important.<p>For me when I switched to UUIDv7 a few months ago, it was basically no effort to switch v4 to v7 on a relatively new system. I was observing much higher batch insertion latencies than I expected, and producing inserts that touch less of the btree on an index created a very noticeable reduction in insertion latencies. But my workloads and latencies may look nothing like yours. On amazon RDS instances with EBS volumes and relatively low memory, insertion latency stood out, so using strategies that reduce the number of disk blocks that are needed has an outsized performance impact.<p>This of course would produce different results on different hardware &#x2F; system sizing.</div><br/></div></div><div id="40886113" class="c"><input type="checkbox" id="c-40886113" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#40885700">parent</a><span>|</span><a href="#40885976">prev</a><span>|</span><a href="#40885761">next</a><span>|</span><label class="collapse" for="c-40886113">[-]</label><label class="expand" for="c-40886113">[3 more]</label></div><br/><div class="children"><div class="content">To:<p>&gt; Am I wrong here and this is something that really matters and you should invest more time in?<p>Specifically, no - you don&#x27;t need to worry about it.  Reconfiguring your tables to use a different style of unique identifier if your tables have a unique identifier is a bit of a pain but no more so than any other instance of renaming a column - if you want to minimize downtime you add the new column, migrate data to the column, deploy code that utilizes the new column and then finally retire the old column.  Even if the previous version of the table lacked any sort of unique key it is still possible to add one after the fact (it&#x27;s a bit technically harder to properly keep them in sync but it is possible to do safely).<p>It&#x27;s just a question of the cost of doing so and the benefits of it - I work in a system that exclusively uses integral keys and our data is such that we don&#x27;t really suffer any downsides from that choice - if you&#x27;re working in a larger system with less confidence in the security practices of other teams then avoiding sequential keys so that you have obscurity to fall back on if someone really drops the ball on real security isn&#x27;t the worst idea... but I think the really compelling reason to prefer UUIDs is for the power of distributed generation... that really only applies to inherently decentralized or astoundingly large products though - and if your product eventually grows to astoundingly large you&#x27;ll have plenty of time to switch first (probably the wake-up call will be closing in on running out of 4 bit serial unique keys).</div><br/><div id="40886366" class="c"><input type="checkbox" id="c-40886366" checked=""/><div class="controls bullet"><span class="by">big_whack</span><span>|</span><a href="#40885700">root</a><span>|</span><a href="#40886113">parent</a><span>|</span><a href="#40885761">next</a><span>|</span><label class="collapse" for="c-40886366">[-]</label><label class="expand" for="c-40886366">[2 more]</label></div><br/><div class="children"><div class="content">Reconfiguring tables to use a different kind of unique ID (primary key in this context) can be a much bigger pain than an ordinary column rename if it is in use by foreign key constraints.</div><br/><div id="40887826" class="c"><input type="checkbox" id="c-40887826" checked=""/><div class="controls bullet"><span class="by">snicker7</span><span>|</span><a href="#40885700">root</a><span>|</span><a href="#40886366">parent</a><span>|</span><a href="#40885761">next</a><span>|</span><label class="collapse" for="c-40887826">[-]</label><label class="expand" for="c-40887826">[1 more]</label></div><br/><div class="children"><div class="content">OR if the primary key is exported out of the DB, i.e. for constructing URLs.</div><br/></div></div></div></div></div></div><div id="40885761" class="c"><input type="checkbox" id="c-40885761" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40885700">parent</a><span>|</span><a href="#40886113">prev</a><span>|</span><a href="#40887504">next</a><span>|</span><label class="collapse" for="c-40885761">[-]</label><label class="expand" for="c-40885761">[1 more]</label></div><br/><div class="children"><div class="content">While Postgres does not cluster table, uuids do affect indexes significantly, random insertion causes increased index slack which translates to cache bloat and thus longer traversal and lower cache residency.</div><br/></div></div><div id="40887504" class="c"><input type="checkbox" id="c-40887504" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40885700">parent</a><span>|</span><a href="#40885761">prev</a><span>|</span><a href="#40887276">next</a><span>|</span><label class="collapse" for="c-40887504">[-]</label><label class="expand" for="c-40887504">[1 more]</label></div><br/><div class="children"><div class="content">UUIDv7 are good enough that you can just avoid thinking and use it as a “default”. The worst consequences of doing so are some slightly impacted performance and leak of some timing information but these are extremely minor drawbacks.<p>Using completely random UUIDs is IMO the worst choice. It’s fine right up until it isn’t, and then you are stuck in hell with no good way out.</div><br/></div></div><div id="40887276" class="c"><input type="checkbox" id="c-40887276" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40885700">parent</a><span>|</span><a href="#40887504">prev</a><span>|</span><a href="#40888922">next</a><span>|</span><label class="collapse" for="c-40887276">[-]</label><label class="expand" for="c-40887276">[1 more]</label></div><br/><div class="children"><div class="content">You still get performance hits from Visibility Map lookups, and WAL bloat.<p>As a DBRE, I believe it always matters, and you should invest time in it. Pragmatically, it is unlikely to have noticeable effects until your tables are at least in the 1E5 rows range, if not higher. Unfortunately, by that point, it’s likely that you’ll find other things of higher importance to deal with, so the problem will only grow.</div><br/></div></div></div></div><div id="40888922" class="c"><input type="checkbox" id="c-40888922" checked=""/><div class="controls bullet"><span class="by">Pinus</span><span>|</span><a href="#40885700">prev</a><span>|</span><a href="#40886471">next</a><span>|</span><label class="collapse" for="c-40888922">[-]</label><label class="expand" for="c-40888922">[2 more]</label></div><br/><div class="children"><div class="content">I’m not sure I understand the bit about time-ordered values being a better fit for B-trees. Actually, I’m sure that I <i>don’t</i> understand it... If anything, I’d naively assume that inserting already-sorted values would be a worst case, always going down the same branch of the tree and triggering re-balancing operations left and right (figuratively — literally mostly left!). The Wikipedia article on B-trees notices that there are some shortcuts that can be taken if one knows one is going to do a batch insert of sorted values. Is that what happens? But then how does Postgres know this?</div><br/><div id="40889005" class="c"><input type="checkbox" id="c-40889005" checked=""/><div class="controls bullet"><span class="by">conradludgate</span><span>|</span><a href="#40888922">parent</a><span>|</span><a href="#40886471">next</a><span>|</span><label class="collapse" for="c-40889005">[-]</label><label class="expand" for="c-40889005">[1 more]</label></div><br/><div class="children"><div class="content">Btrees don&#x27;t need to be rebalanced. They only split. The cost of splitting to the root is counteracted by the cache locality of always accessing the same set of pages. Inserting into the last page only needs O(logn) page accesses and O(logn) page writes worst case.</div><br/></div></div></div></div><div id="40886471" class="c"><input type="checkbox" id="c-40886471" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#40888922">prev</a><span>|</span><a href="#40887920">next</a><span>|</span><label class="collapse" for="c-40886471">[-]</label><label class="expand" for="c-40886471">[5 more]</label></div><br/><div class="children"><div class="content">It would be nice for these comparisons to also include &#x27;int64&#x27; so people can see how much of an overhead UUID&#x27;s are compared to the traditional approach.</div><br/><div id="40887114" class="c"><input type="checkbox" id="c-40887114" checked=""/><div class="controls bullet"><span class="by">tills13</span><span>|</span><a href="#40886471">parent</a><span>|</span><a href="#40887920">next</a><span>|</span><label class="collapse" for="c-40887114">[-]</label><label class="expand" for="c-40887114">[4 more]</label></div><br/><div class="children"><div class="content">The problem here is that auto increment ints are guessable.<p>The size of that problem depends on your situation</div><br/><div id="40887650" class="c"><input type="checkbox" id="c-40887650" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40886471">root</a><span>|</span><a href="#40887114">parent</a><span>|</span><a href="#40887371">next</a><span>|</span><label class="collapse" for="c-40887650">[-]</label><label class="expand" for="c-40887650">[2 more]</label></div><br/><div class="children"><div class="content">If your API is relying purely on the user ID for AuthZ, you have much bigger problems.</div><br/><div id="40888377" class="c"><input type="checkbox" id="c-40888377" checked=""/><div class="controls bullet"><span class="by">t-writescode</span><span>|</span><a href="#40886471">root</a><span>|</span><a href="#40887650">parent</a><span>|</span><a href="#40887371">next</a><span>|</span><label class="collapse" for="c-40888377">[-]</label><label class="expand" for="c-40888377">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just authz, it can also be a reflection of how many customers you have, and that can also be its own problem.<p>Or, let&#x27;s say you are a middleware company and you&#x27;re trying to contract your services to two other companies. These companies are competitors of each other, but they&#x27;re also the biggest in their space.<p>If you have use, let&#x27;s say, autoincrementing ints for orders or operations, then the companies could use the distance between order numbers as a way of calculating how much business the other business is doing.<p>If that functionality is possible &#x2F; easy, that may be a reason for those customers to stop using you, and you&#x27;ve now lost one or two of your major contracts.<p>Apparently this has been brought up by others and is called the German Tank Problem.</div><br/></div></div></div></div><div id="40887371" class="c"><input type="checkbox" id="c-40887371" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40886471">root</a><span>|</span><a href="#40887114">parent</a><span>|</span><a href="#40887650">prev</a><span>|</span><a href="#40887920">next</a><span>|</span><label class="collapse" for="c-40887371">[-]</label><label class="expand" for="c-40887371">[1 more]</label></div><br/><div class="children"><div class="content">Also auto increment IDs that are exposed publicly cause [<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;German_tank_problem" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;German_tank_problem</a>].</div><br/></div></div></div></div></div></div><div id="40887920" class="c"><input type="checkbox" id="c-40887920" checked=""/><div class="controls bullet"><span class="by">sarreph</span><span>|</span><a href="#40886471">prev</a><span>|</span><a href="#40886939">next</a><span>|</span><label class="collapse" for="c-40887920">[-]</label><label class="expand" for="c-40887920">[2 more]</label></div><br/><div class="children"><div class="content">We chose ULID for our Postgres PK recently, and this article helped a lot in making that decision: <a href="https:&#x2F;&#x2F;brandur.org&#x2F;nanoglyphs&#x2F;026-ids" rel="nofollow">https:&#x2F;&#x2F;brandur.org&#x2F;nanoglyphs&#x2F;026-ids</a><p>I personally prefer ULID since it is compat with a UUID type and you also get a timestamp lexicographically built into the ID so that sorting by ID also means sorting by timestamp. There are multiple PG extensions to make it easy to drop in and use.</div><br/><div id="40887946" class="c"><input type="checkbox" id="c-40887946" checked=""/><div class="controls bullet"><span class="by">saaspirant</span><span>|</span><a href="#40887920">parent</a><span>|</span><a href="#40886939">next</a><span>|</span><label class="collapse" for="c-40887946">[-]</label><label class="expand" for="c-40887946">[1 more]</label></div><br/><div class="children"><div class="content">How do you deal with ulid exposing the timestamp (since is lexicographically sortable) ?
Maybe your ULID is not public facing? Or this is not an issue for your application?<p>I want to use something url friendly too since uuid sucks..</div><br/></div></div></div></div><div id="40886939" class="c"><input type="checkbox" id="c-40886939" checked=""/><div class="controls bullet"><span class="by">declan_roberts</span><span>|</span><a href="#40887920">prev</a><span>|</span><a href="#40885889">next</a><span>|</span><label class="collapse" for="c-40886939">[-]</label><label class="expand" for="c-40886939">[8 more]</label></div><br/><div class="children"><div class="content">Call me old fashion but I really like integer autoincrement primary keys. It&#x27;s easy to understand and obviously simple to sort. Furthermore when working on large batch projects you can just store the last primary key as your high water mark and get everything greater than that.<p>I suppose TSID works to this end, but certainly more complicated.</div><br/><div id="40888932" class="c"><input type="checkbox" id="c-40888932" checked=""/><div class="controls bullet"><span class="by">foreigner</span><span>|</span><a href="#40886939">parent</a><span>|</span><a href="#40887311">next</a><span>|</span><label class="collapse" for="c-40888932">[-]</label><label class="expand" for="c-40888932">[1 more]</label></div><br/><div class="children"><div class="content">Be advised using the last auto-incremented value as a &quot;high water mark&quot; and getting everything greater than that is not 100% reliable, because in some scenarios auto-incrementing values can be written out of order.</div><br/></div></div><div id="40887311" class="c"><input type="checkbox" id="c-40887311" checked=""/><div class="controls bullet"><span class="by">tommy_axle</span><span>|</span><a href="#40886939">parent</a><span>|</span><a href="#40888932">prev</a><span>|</span><a href="#40885889">next</a><span>|</span><label class="collapse" for="c-40887311">[-]</label><label class="expand" for="c-40887311">[6 more]</label></div><br/><div class="children"><div class="content">It is simpler but like everything else it depends on the application. For a private app you can generally get away with it. Something that&#x27;s more public facing? The ID will most likely leak information. As systems mature and you introduce things like replication, having IDs that are more universal starts looking good. In general, starting off with a uuid like uuid v4 or nanoid is a good bet.</div><br/><div id="40887376" class="c"><input type="checkbox" id="c-40887376" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40886939">root</a><span>|</span><a href="#40887311">parent</a><span>|</span><a href="#40885889">next</a><span>|</span><label class="collapse" for="c-40887376">[-]</label><label class="expand" for="c-40887376">[5 more]</label></div><br/><div class="children"><div class="content">The info leak, specifically, is [<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;German_tank_problem" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;German_tank_problem</a>].</div><br/><div id="40887671" class="c"><input type="checkbox" id="c-40887671" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40886939">root</a><span>|</span><a href="#40887376">parent</a><span>|</span><a href="#40885889">next</a><span>|</span><label class="collapse" for="c-40887671">[-]</label><label class="expand" for="c-40887671">[4 more]</label></div><br/><div class="children"><div class="content">Oh no, someone might know the number of customers, or the rate of signups.<p>Traditional businesses can figure this out by sitting in the parking lot. Why SaaS has decided it’s a huge problem is beyond me.</div><br/><div id="40888227" class="c"><input type="checkbox" id="c-40888227" checked=""/><div class="controls bullet"><span class="by">bruce511</span><span>|</span><a href="#40886939">root</a><span>|</span><a href="#40887671">parent</a><span>|</span><a href="#40888351">next</a><span>|</span><label class="collapse" for="c-40888227">[-]</label><label class="expand" for="c-40888227">[1 more]</label></div><br/><div class="children"><div class="content">Yes, sure, it leaks some information - but to be fair printing an invoice also leaks information.<p>For me the priority is security. If I get a link (visible or invisible) that contains a numeric ID, there&#x27;s the possibility to tweak that link with another number.<p>Ideally, the server treats that number as suspect. Every. Single . Time. In practice I only need one developer to miss the check in one place and I have a serious security issue. Like leaking my entire customer list serious. This has happened multiple times -that we know of-.<p>Yes obscurity is not security. But sequential numbers are insecure by design, and it takes a lot of well-maintained walls to protect them. One crack leaves them very vulnerable.</div><br/></div></div><div id="40888351" class="c"><input type="checkbox" id="c-40888351" checked=""/><div class="controls bullet"><span class="by">karmajunkie</span><span>|</span><a href="#40886939">root</a><span>|</span><a href="#40887671">parent</a><span>|</span><a href="#40888227">prev</a><span>|</span><a href="#40888061">next</a><span>|</span><label class="collapse" for="c-40888351">[-]</label><label class="expand" for="c-40888351">[1 more]</label></div><br/><div class="children"><div class="content">i mean, you might care if the investors you’re trying to woo for that bridge round figure out your churn is a lot higher than you’re willing to admit… or worse, your traction is terrible.</div><br/></div></div><div id="40888061" class="c"><input type="checkbox" id="c-40888061" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40886939">root</a><span>|</span><a href="#40887671">parent</a><span>|</span><a href="#40888351">prev</a><span>|</span><a href="#40885889">next</a><span>|</span><label class="collapse" for="c-40888061">[-]</label><label class="expand" for="c-40888061">[1 more]</label></div><br/><div class="children"><div class="content">By sitting in every parking lot, yes.  Which requires physical presence. And hedge funds do indeed do it against some targets specifically as a leg up, and pay quite a bit of money to do so, presumably because it is worth it to them.<p>It certainly helped the Allies in the war, as previous intelligence had the rate of tank production much higher, and they were expending a lot of effort trying to exceed that previous false number.<p>Information is power, etc. etc.<p>As to if it&#x27;s worth it for <i>your</i> SaaS to mitigate is up to you of course. I know <i>I</i> notice when things like Invoice #&#x27;s, my userID, customerID, etc. get shown, and it&#x27;s a small number, or small delta. And that impacts my behavior. Does it also impact someone like a VC’s behavior? Or a competitor? Unknown.<p>But Hell, a bunch of people right now are probably launching SaaS&#x27;s with NO-OP auth flows for documents or images, or with trivial external SQL injection flaws, which is a way bigger problem.<p>But it doesn&#x27;t make the vulnerability&#x2F;problem non-existent.  Also feel free to use 16 bit auto incrementing primary keys for all your core tables if you want.<p>But if we&#x27;re in an engineering discussion on the topic, knowledgeable folks will bring up the issues with it, because that is what they do. Most would feel it is their duty to do it, even.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40885889" class="c"><input type="checkbox" id="c-40885889" checked=""/><div class="controls bullet"><span class="by">aabhay</span><span>|</span><a href="#40886939">prev</a><span>|</span><a href="#40886801">next</a><span>|</span><label class="collapse" for="c-40885889">[-]</label><label class="expand" for="c-40885889">[2 more]</label></div><br/><div class="children"><div class="content">I think insert performance is a bad way to evaluate performance here, no? While B-Tree performance for time sorted keys is better on insert, what about during large transactions?<p>In SQLite, my assumption was that the consensus was towards UUID4 rather than 7 because it meant less likelihood for page cache contention during transaction locks? Would that not also roughly map onto a Postgres-flavored system? Or dues Postgres only have row-level locking?</div><br/><div id="40885979" class="c"><input type="checkbox" id="c-40885979" checked=""/><div class="controls bullet"><span class="by">samokhvalov</span><span>|</span><a href="#40885889">parent</a><span>|</span><a href="#40886801">next</a><span>|</span><label class="collapse" for="c-40885979">[-]</label><label class="expand" for="c-40885979">[1 more]</label></div><br/><div class="children"><div class="content">there is also a problem of data locality and blocks present in caches (page cache, buffer pool) at any given time, in general -- UUIDv4 is losing to bigint and UUIDv7 in this area</div><br/></div></div></div></div><div id="40886801" class="c"><input type="checkbox" id="c-40886801" checked=""/><div class="controls bullet"><span class="by">sbuttgereit</span><span>|</span><a href="#40885889">prev</a><span>|</span><a href="#40888749">next</a><span>|</span><label class="collapse" for="c-40886801">[-]</label><label class="expand" for="c-40886801">[9 more]</label></div><br/><div class="children"><div class="content">The article had a link to the PostgreSQL commitfest for UUIDv7 support, but as far as I can&#x27;t tell it looks unlikely that it will actually be in PostgreSQL 17.  The most recent action was the committer being removed from the task and I believe version 17 is already well past feature freeze.... Is my understanding correct? This is what I think is going on, but I can&#x27;t find any substantiated facts too point me to a definite conclusion.<p>I was hoping to see it in version 17, but can&#x27;t get a really good read on what&#x27;s going on with this feature.</div><br/><div id="40887532" class="c"><input type="checkbox" id="c-40887532" checked=""/><div class="controls bullet"><span class="by">jrochkind1</span><span>|</span><a href="#40886801">parent</a><span>|</span><a href="#40886857">next</a><span>|</span><label class="collapse" for="c-40887532">[-]</label><label class="expand" for="c-40887532">[2 more]</label></div><br/><div class="children"><div class="content">That is too bad, I too would be very eager to see natively supported in Postgres. It doesn&#x27;t seem like it should be so complex to implement on top of pg&#x27;s existing uuid support, but famous last words?</div><br/><div id="40888059" class="c"><input type="checkbox" id="c-40888059" checked=""/><div class="controls bullet"><span class="by">sbuttgereit</span><span>|</span><a href="#40886801">root</a><span>|</span><a href="#40887532">parent</a><span>|</span><a href="#40886857">next</a><span>|</span><label class="collapse" for="c-40888059">[-]</label><label class="expand" for="c-40888059">[1 more]</label></div><br/><div class="children"><div class="content">It looks like the feature had made good progress with the contention really being around the fact that the standard hadn&#x27;t yet become an RFC.  However, the new UUID standard did reach that milestone back in early May, but the feature kinda went radio silent... at least insofar as any public record... up to a couple days ago when the assigned reviewer&#x2F;committer was removed.<p>But no word on if it&#x27;s delayed, or there&#x27;s some problem, etc. It&#x27;s still tagged as 17... and some of the related work has been committed, but not the UUIDv7 itself so it seems.</div><br/></div></div></div></div><div id="40886857" class="c"><input type="checkbox" id="c-40886857" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#40886801">parent</a><span>|</span><a href="#40887532">prev</a><span>|</span><a href="#40888749">next</a><span>|</span><label class="collapse" for="c-40886857">[-]</label><label class="expand" for="c-40886857">[6 more]</label></div><br/><div class="children"><div class="content">What database support is needed? Assuming Postgres already has the uuid type and that you can (and often should) do the actual generation of them in application code?</div><br/><div id="40887548" class="c"><input type="checkbox" id="c-40887548" checked=""/><div class="controls bullet"><span class="by">sbuttgereit</span><span>|</span><a href="#40886801">root</a><span>|</span><a href="#40886857">parent</a><span>|</span><a href="#40886909">next</a><span>|</span><label class="collapse" for="c-40887548">[-]</label><label class="expand" for="c-40887548">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you can (and often should) do the actual generation of them in application code<p>I can absolutely see scenarios where it would be desirable or convenient to create the these IDs in the application code.  However, I can equally assert that you can, and often should, let the database be the source of truth for record identity when using database surrogate keys for that purpose... but I won&#x27;t.<p>The truth is there are many kinds of architectures and many kinds of applications the details of which have a direct bearing on where or where not certain operations should be conducted.  In many environments in which I work, the idea of &quot;the application&quot; can be murky.  In many enterprise environments databases can be driven by and integrated into many applications, possibly from different software developers and vendors with varying degrees of influence in how they internally operate.  In such environments the database can be the great unifier and placing substantial control of data in the database itself can make sense in these heterogenous application environments: but it&#x27;s very much a circumstantial call.<p>I would expect if there really were one true way to develop application or how to use databases to achieve goals, we could well be asking why they built these functions in the first place... I suspect it&#x27;s because there are a reasonable number of valid use cases to justify the lift.  I&#x27;d like to think my use cases fit the envisioned valid use cases thus my interest and question.</div><br/></div></div><div id="40886909" class="c"><input type="checkbox" id="c-40886909" checked=""/><div class="controls bullet"><span class="by">tyre</span><span>|</span><a href="#40886801">root</a><span>|</span><a href="#40886857">parent</a><span>|</span><a href="#40887548">prev</a><span>|</span><a href="#40888749">next</a><span>|</span><label class="collapse" for="c-40886909">[-]</label><label class="expand" for="c-40886909">[4 more]</label></div><br/><div class="children"><div class="content">Why should they be done in application code?</div><br/><div id="40887035" class="c"><input type="checkbox" id="c-40887035" checked=""/><div class="controls bullet"><span class="by">eproxus</span><span>|</span><a href="#40886801">root</a><span>|</span><a href="#40886909">parent</a><span>|</span><a href="#40888749">next</a><span>|</span><label class="collapse" for="c-40887035">[-]</label><label class="expand" for="c-40887035">[3 more]</label></div><br/><div class="children"><div class="content">There’s no need since they are random, so you might as well generate them on your application servers which are easier to scale, to offload the write database.</div><br/><div id="40887162" class="c"><input type="checkbox" id="c-40887162" checked=""/><div class="controls bullet"><span class="by">bozey07</span><span>|</span><a href="#40886801">root</a><span>|</span><a href="#40887035">parent</a><span>|</span><a href="#40888749">next</a><span>|</span><label class="collapse" for="c-40887162">[-]</label><label class="expand" for="c-40887162">[2 more]</label></div><br/><div class="children"><div class="content">IMO marking the row as generated makes its intent clearer. It also means less code - no generating UUIDs, shorter queries = more robust.<p>For my workloads at least, I think it&#x27;s worth the tradeoff of forcing Postgres to muster 15 random bytes.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40888749" class="c"><input type="checkbox" id="c-40888749" checked=""/><div class="controls bullet"><span class="by">hakanderyal</span><span>|</span><a href="#40886801">prev</a><span>|</span><a href="#40886450">next</a><span>|</span><label class="collapse" for="c-40888749">[-]</label><label class="expand" for="c-40888749">[1 more]</label></div><br/><div class="children"><div class="content">Using ULID has probably the best ROI among all the architectural decisions I&#x27;ve made. Generating IDs on the server before insert is helpful, and not just for distributed system issues.<p>If I don&#x27;t want to leak the timestamp, I just use an auto generated integer along with it.</div><br/></div></div><div id="40886450" class="c"><input type="checkbox" id="c-40886450" checked=""/><div class="controls bullet"><span class="by">vog</span><span>|</span><a href="#40888749">prev</a><span>|</span><a href="#40886287">next</a><span>|</span><label class="collapse" for="c-40886450">[-]</label><label class="expand" for="c-40886450">[1 more]</label></div><br/><div class="children"><div class="content">Note that the article&#x27;s link to the UUID v7 standard is meanwhile outdated. You should instead head directly to RFC 9562:<p><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562</a><p>(which wasn&#x27;t yet finished at the time of the article)</div><br/></div></div><div id="40886287" class="c"><input type="checkbox" id="c-40886287" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#40886450">prev</a><span>|</span><a href="#40886045">next</a><span>|</span><label class="collapse" for="c-40886287">[-]</label><label class="expand" for="c-40886287">[7 more]</label></div><br/><div class="children"><div class="content">My strategy is to use v4 Uuids for anything that is not inserted frequently and don&#x27;t need to be ordered (think user ids) and v7 ids for things that are.<p>If your dataset is small the overhead from Uuids wont matter, if your dataset is large the randomness of Uuids will save your ass when you migrate to a distributed solution.</div><br/><div id="40886833" class="c"><input type="checkbox" id="c-40886833" checked=""/><div class="controls bullet"><span class="by">rareitem</span><span>|</span><a href="#40886287">parent</a><span>|</span><a href="#40886045">next</a><span>|</span><label class="collapse" for="c-40886833">[-]</label><label class="expand" for="c-40886833">[6 more]</label></div><br/><div class="children"><div class="content">Is there a reason to not always use v7 by default?</div><br/><div id="40886894" class="c"><input type="checkbox" id="c-40886894" checked=""/><div class="controls bullet"><span class="by">davisp</span><span>|</span><a href="#40886287">root</a><span>|</span><a href="#40886833">parent</a><span>|</span><a href="#40887009">next</a><span>|</span><label class="collapse" for="c-40886894">[-]</label><label class="expand" for="c-40886894">[4 more]</label></div><br/><div class="children"><div class="content">Information leakage since they have a timestamp component. Some people may not care, but plenty of folks do. As others have said, anything security related likely should UUIDv4. UUIDv7 is basically an engineering compromise on security (they leak a timestamp) vs performance (random reads and writes to an index aren’t as performant as localized reads and writes).</div><br/><div id="40886921" class="c"><input type="checkbox" id="c-40886921" checked=""/><div class="controls bullet"><span class="by">rareitem</span><span>|</span><a href="#40886287">root</a><span>|</span><a href="#40886894">parent</a><span>|</span><a href="#40887009">next</a><span>|</span><label class="collapse" for="c-40886921">[-]</label><label class="expand" for="c-40886921">[3 more]</label></div><br/><div class="children"><div class="content">Thanks, I get it. Do you have any example where leaking a timestamp could pose a security risk? I can&#x27;t think of any.</div><br/><div id="40888141" class="c"><input type="checkbox" id="c-40888141" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#40886287">root</a><span>|</span><a href="#40886921">parent</a><span>|</span><a href="#40887381">next</a><span>|</span><label class="collapse" for="c-40888141">[-]</label><label class="expand" for="c-40888141">[1 more]</label></div><br/><div class="children"><div class="content">If it is public, any cases where for an entity, when it was created could be potentially sensitive information. E.g. some sort of legal documents, product, ecommerce data that could potentially reveal data to your competitors, etc.</div><br/></div></div><div id="40887381" class="c"><input type="checkbox" id="c-40887381" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40886287">root</a><span>|</span><a href="#40886921">parent</a><span>|</span><a href="#40888141">prev</a><span>|</span><a href="#40887009">next</a><span>|</span><label class="collapse" for="c-40887381">[-]</label><label class="expand" for="c-40887381">[1 more]</label></div><br/><div class="children"><div class="content">Timing attacks?</div><br/></div></div></div></div></div></div><div id="40887009" class="c"><input type="checkbox" id="c-40887009" checked=""/><div class="controls bullet"><span class="by">brigadier132</span><span>|</span><a href="#40886287">root</a><span>|</span><a href="#40886833">parent</a><span>|</span><a href="#40886894">prev</a><span>|</span><a href="#40886045">next</a><span>|</span><label class="collapse" for="c-40887009">[-]</label><label class="expand" for="c-40887009">[1 more]</label></div><br/><div class="children"><div class="content">Information leakage like the other person said but also if you ever move to a distributed db v7 uuids can lead to hotspots.</div><br/></div></div></div></div></div></div><div id="40886045" class="c"><input type="checkbox" id="c-40886045" checked=""/><div class="controls bullet"><span class="by">netcraft</span><span>|</span><a href="#40886287">prev</a><span>|</span><a href="#40886447">next</a><span>|</span><label class="collapse" for="c-40886045">[-]</label><label class="expand" for="c-40886045">[11 more]</label></div><br/><div class="children"><div class="content">Another day, another article saying not to use UUIDs as PKs. I&#x27;ve maintained systems using UUIDs stored as char(36) with million record tables without issue - This is not an endorsement, just explaining that this is bikeshedding. Should you use v7 when you can? Sure. Would int&#x2F;bigint be faster in your benchmarks? Sure. But the benefits totally outweigh the speed differences until you get to a very large system. But instead of worrying about this, spend your energy on a million other things first and then celebrate when UUIDs become your bottleneck.</div><br/><div id="40886097" class="c"><input type="checkbox" id="c-40886097" checked=""/><div class="controls bullet"><span class="by">eerikkivistik</span><span>|</span><a href="#40886045">parent</a><span>|</span><a href="#40888143">next</a><span>|</span><label class="collapse" for="c-40886097">[-]</label><label class="expand" for="c-40886097">[1 more]</label></div><br/><div class="children"><div class="content">I was gonna say... When your system is large enough to run into this specific performance bottleneck, pop a bottle and celebrate, you are making enough money to solve that problem.<p>While knowing this information is useful, most services fail in different domains and problems way before you reach that point. I&#x27;m not sure people really comprehend how hard you can hit a single machine before you need to distribute a workload.</div><br/></div></div><div id="40888143" class="c"><input type="checkbox" id="c-40888143" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40886045">parent</a><span>|</span><a href="#40886097">prev</a><span>|</span><a href="#40887545">next</a><span>|</span><label class="collapse" for="c-40888143">[-]</label><label class="expand" for="c-40888143">[1 more]</label></div><br/><div class="children"><div class="content">A million rows is quite small.<p>A string will use 36 bytes per row. bigserial will use 8 bytes per row. At 4 billion rows that&#x27;s about 100G. Now imagine a row with 3 foreign keys to other tables with string UUIDs and you&#x27;re wasting 300G (vs UUID type) or 400G (vs. bigserial), for no good reason. And doing things like &quot;where id = ?&quot; will be slower. You will be able to keep fewer rows cached in memory. Etc.<p>It&#x27;s absolutely not a bikeshed. And migrating all of this later on can be a right pain so it&#x27;s worth getting it right up-frong.<p>It&#x27;s also not more effort to do things right: usually it&#x27;s exactly the same effort as doing it wrong.</div><br/></div></div><div id="40887545" class="c"><input type="checkbox" id="c-40887545" checked=""/><div class="controls bullet"><span class="by">jrochkind1</span><span>|</span><a href="#40886045">parent</a><span>|</span><a href="#40888143">prev</a><span>|</span><a href="#40887894">next</a><span>|</span><label class="collapse" for="c-40887545">[-]</label><label class="expand" for="c-40887545">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, good to hear.<p>If you are using PG, simply using it&#x27;s native UUID type instead of char(36) seems like a no-opportunity-cost obvious optimization choice at least though, if you have a choice?</div><br/></div></div><div id="40887894" class="c"><input type="checkbox" id="c-40887894" checked=""/><div class="controls bullet"><span class="by">therealdrag0</span><span>|</span><a href="#40886045">parent</a><span>|</span><a href="#40887545">prev</a><span>|</span><a href="#40887703">next</a><span>|</span><label class="collapse" for="c-40887894">[-]</label><label class="expand" for="c-40887894">[1 more]</label></div><br/><div class="children"><div class="content">Million records isn’t very many. But ya we have tables with billions of records and v4 UUIDs hasn’t been a blocker.</div><br/></div></div><div id="40887703" class="c"><input type="checkbox" id="c-40887703" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40886045">parent</a><span>|</span><a href="#40887894">prev</a><span>|</span><a href="#40886296">next</a><span>|</span><label class="collapse" for="c-40887703">[-]</label><label class="expand" for="c-40887703">[2 more]</label></div><br/><div class="children"><div class="content">Milliseconds matter, especially when they compound. If your DB can return a SELECT in sub-msec time (to its network boundary, obviously) instead of 10 msec, that adds up when a given page might require a dozen or more trips.<p>Also, I have never seen devs (PMs, really – devs are the unfortunate souls slogging through tickets) suddenly care about performance-related tech debt. Why would they, when you can just click a button and double your DB’s hardware? Boom, problem solved… until it isn’t. Eventually, you run out of scaling, and since you probably don’t have a DBA&#x2F;DBRE (else they’d have been screaming at you for months), it’s going to be extremely painful to solve now.<p>The bare minimum I’m asking – as a DBRE – is to use UUIDv7 and store them in Postgres’ native UUID type. That’s all. That’s an incredibly small amount of effort to put forth.</div><br/><div id="40888171" class="c"><input type="checkbox" id="c-40888171" checked=""/><div class="controls bullet"><span class="by">mewpmewp2</span><span>|</span><a href="#40886045">root</a><span>|</span><a href="#40887703">parent</a><span>|</span><a href="#40886296">next</a><span>|</span><label class="collapse" for="c-40888171">[-]</label><label class="expand" for="c-40888171">[1 more]</label></div><br/><div class="children"><div class="content">But then by default you are leaking potentially business sensitive data with your id if you are using it as public facing, which is unsecure design by default.<p>I would rather have secure data by default and opt in to optimise when it is clear this info is fine to leak.</div><br/></div></div></div></div><div id="40886296" class="c"><input type="checkbox" id="c-40886296" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40886045">parent</a><span>|</span><a href="#40887703">prev</a><span>|</span><a href="#40886447">next</a><span>|</span><label class="collapse" for="c-40886296">[-]</label><label class="expand" for="c-40886296">[4 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t maintained any sizable database system without any issues, least of all performance ones.<p>I call BS.</div><br/><div id="40886937" class="c"><input type="checkbox" id="c-40886937" checked=""/><div class="controls bullet"><span class="by">netcraft</span><span>|</span><a href="#40886045">root</a><span>|</span><a href="#40886296">parent</a><span>|</span><a href="#40886595">next</a><span>|</span><label class="collapse" for="c-40886937">[-]</label><label class="expand" for="c-40886937">[2 more]</label></div><br/><div class="children"><div class="content">lol, I of course don&#x27;t mean that I have no issues, performance or otherwise. Only that I have never had an issue with UUIDs in postgres</div><br/><div id="40887456" class="c"><input type="checkbox" id="c-40887456" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40886045">root</a><span>|</span><a href="#40886937">parent</a><span>|</span><a href="#40886595">next</a><span>|</span><label class="collapse" for="c-40887456">[-]</label><label class="expand" for="c-40887456">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;issue&quot; is that you&#x27;re doubling the size of your identifiers, and increasing memory usage of indexes.<p>And memory is the key factor of any sizable database.</div><br/></div></div></div></div><div id="40886595" class="c"><input type="checkbox" id="c-40886595" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#40886045">root</a><span>|</span><a href="#40886296">parent</a><span>|</span><a href="#40886937">prev</a><span>|</span><a href="#40886447">next</a><span>|</span><label class="collapse" for="c-40886595">[-]</label><label class="expand" for="c-40886595">[1 more]</label></div><br/><div class="children"><div class="content">This gave me a good chuckle, and has generally been my experience. Systems grow often in unpredictable or unintuitive ways.<p>You can pay the cost for something upfront, and the cost of maintaining it, and in the long term paid too much for something you didn&#x27;t actually need.<p>Alternatively you can wait to pay it until you&#x27;re certain you need it but the work involved has become much more significant, in which it can cost more than it would have to have built and maintained it from the beginning.<p>Compounding the issue is the build-up-front scenario costs fade with time and you don&#x27;t really think about them, but build-when-you-need-it always creates a stir even if the costs are less overall than build-up-front.<p>Either way something will go wrong no matter how many times you predict where the cards will fall.</div><br/></div></div></div></div></div></div><div id="40886447" class="c"><input type="checkbox" id="c-40886447" checked=""/><div class="controls bullet"><span class="by">rootedbox</span><span>|</span><a href="#40886045">prev</a><span>|</span><a href="#40885631">next</a><span>|</span><label class="collapse" for="c-40886447">[-]</label><label class="expand" for="c-40886447">[7 more]</label></div><br/><div class="children"><div class="content">Just a heads up about UUID 7.. be careful when using.<p>par the RFC<p>If UUIDs are required for use with any security operation within an application context in any shape or form then [RFC4122] UUIDv4 SHOULD be utilized.</div><br/><div id="40886556" class="c"><input type="checkbox" id="c-40886556" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#40886447">parent</a><span>|</span><a href="#40886992">next</a><span>|</span><label class="collapse" for="c-40886556">[-]</label><label class="expand" for="c-40886556">[4 more]</label></div><br/><div class="children"><div class="content">I was thinking of adopting UUIDv7 for some of my stuff. So, I&#x27;m curious: why is this the case? Is it because of the time component?</div><br/><div id="40886703" class="c"><input type="checkbox" id="c-40886703" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40886447">root</a><span>|</span><a href="#40886556">parent</a><span>|</span><a href="#40886766">next</a><span>|</span><label class="collapse" for="c-40886703">[-]</label><label class="expand" for="c-40886703">[1 more]</label></div><br/><div class="children"><div class="content">1. UUIDv7 allows to extract timestamp<p>2. UUIDv7 allows to predict first half, if you know the timestamp.<p>3. UUIDv7 provides 62 bits of randomness compared to 122 bits for UUIDv4.<p>Whether that&#x27;s a problem for your particular use-case or not, it&#x27;s up for you to decide. I don&#x27;t think that UUIDv7 is &quot;insecure&quot;, it just provides different trade-offs and in some situations it might be less secure compared to UUIDv4, but I hardly see any attack vector where you could issue 2^62 requests to brute-force the ID.</div><br/></div></div><div id="40886766" class="c"><input type="checkbox" id="c-40886766" checked=""/><div class="controls bullet"><span class="by">lulzury</span><span>|</span><a href="#40886447">root</a><span>|</span><a href="#40886556">parent</a><span>|</span><a href="#40886703">prev</a><span>|</span><a href="#40886769">next</a><span>|</span><label class="collapse" for="c-40886766">[-]</label><label class="expand" for="c-40886766">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what the RFC states:<p>&gt; Timestamps embedded in the UUID do pose a very small attack surface. The timestamp in conjunction with an embedded counter does signal the order of creation for a given UUID and its corresponding data but does not define anything about the data itself or the application as a whole. If UUIDs are required for use with any security operation within an application context in any shape or form, then UUIDv4 (Section 5.4) SHOULD be utilized.<p><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562#name-security-considerations" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562#name-security-...</a></div><br/></div></div></div></div><div id="40886992" class="c"><input type="checkbox" id="c-40886992" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40886447">parent</a><span>|</span><a href="#40886556">prev</a><span>|</span><a href="#40885631">next</a><span>|</span><label class="collapse" for="c-40886992">[-]</label><label class="expand" for="c-40886992">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately, UUIDv4 is often specifically prohibited for some sensitive applications due to many cases of broken RNGs  undermining the security guarantees of UUIDv4. Deterministic generation plus encryption is a common choice in these cases.</div><br/><div id="40887537" class="c"><input type="checkbox" id="c-40887537" checked=""/><div class="controls bullet"><span class="by">jrochkind1</span><span>|</span><a href="#40886447">root</a><span>|</span><a href="#40886992">parent</a><span>|</span><a href="#40885631">next</a><span>|</span><label class="collapse" for="c-40887537">[-]</label><label class="expand" for="c-40887537">[1 more]</label></div><br/><div class="children"><div class="content">The important point is that UUIDv7 is even worse (and unsuitable) for that application so anything prohibited UUIDv4 for those reasons would not be okay with v7 either!</div><br/></div></div></div></div></div></div><div id="40885631" class="c"><input type="checkbox" id="c-40885631" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#40886447">prev</a><span>|</span><a href="#40888019">next</a><span>|</span><label class="collapse" for="c-40885631">[-]</label><label class="expand" for="c-40885631">[2 more]</label></div><br/><div class="children"><div class="content">Would have been nice to also include bigserial&#x2F;bigint in the INSERT performance comparison to understand the impact of migrating those to UUIDv4 and UUIDv7.</div><br/><div id="40885702" class="c"><input type="checkbox" id="c-40885702" checked=""/><div class="controls bullet"><span class="by">AdamJacobMuller</span><span>|</span><a href="#40885631">parent</a><span>|</span><a href="#40888019">next</a><span>|</span><label class="collapse" for="c-40885702">[-]</label><label class="expand" for="c-40885702">[1 more]</label></div><br/><div class="children"><div class="content">Also testing using postgres-native uuid generation</div><br/></div></div></div></div><div id="40888019" class="c"><input type="checkbox" id="c-40888019" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#40885631">prev</a><span>|</span><a href="#40885934">next</a><span>|</span><label class="collapse" for="c-40888019">[-]</label><label class="expand" for="c-40888019">[1 more]</label></div><br/><div class="children"><div class="content">The benchmark for UUIDv7 insertion time includes UUID generation: when looking at simply index update cost, I&#x27;d like to see those decoupled.<p>FWIW, I do expect UUIDv7 to take roughly half the time to generate if it has roughly half the random bits of UUIDv4 and an unprotected source of entropy is used.</div><br/></div></div><div id="40885934" class="c"><input type="checkbox" id="c-40885934" checked=""/><div class="controls bullet"><span class="by">samokhvalov</span><span>|</span><a href="#40888019">prev</a><span>|</span><a href="#40886800">next</a><span>|</span><label class="collapse" for="c-40885934">[-]</label><label class="expand" for="c-40885934">[1 more]</label></div><br/><div class="children"><div class="content">some related stuff:<p>- <a href="https:&#x2F;&#x2F;commitfest.postgresql.org&#x2F;48&#x2F;4388&#x2F;" rel="nofollow">https:&#x2F;&#x2F;commitfest.postgresql.org&#x2F;48&#x2F;4388&#x2F;</a> (original patch created live <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=YPq_hiOE-N8" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=YPq_hiOE-N8</a>)<p>- <a href="https:&#x2F;&#x2F;postgres.fm&#x2F;episodes&#x2F;uuid" rel="nofollow">https:&#x2F;&#x2F;postgres.fm&#x2F;episodes&#x2F;uuid</a><p>- <a href="https:&#x2F;&#x2F;postgres.fm&#x2F;episodes&#x2F;partitioning-by-ulid" rel="nofollow">https:&#x2F;&#x2F;postgres.fm&#x2F;episodes&#x2F;partitioning-by-ulid</a><p>- <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;postgres-ai&#x2F;postgresql-consulting&#x2F;postgres-howtos&#x2F;-&#x2F;blob&#x2F;main&#x2F;0065_uuid_v7_and_partitioning_timescaledb.md" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;postgres-ai&#x2F;postgresql-consulting&#x2F;postgre...</a></div><br/></div></div><div id="40886800" class="c"><input type="checkbox" id="c-40886800" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40885934">prev</a><span>|</span><a href="#40888012">next</a><span>|</span><label class="collapse" for="c-40886800">[-]</label><label class="expand" for="c-40886800">[8 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re generating random UUIDs as the primary key, how do you not run into key collisions?  Having to search the entire table before inserting is slow, and catching the error and trying again is also annoying.</div><br/><div id="40886858" class="c"><input type="checkbox" id="c-40886858" checked=""/><div class="controls bullet"><span class="by">davisp</span><span>|</span><a href="#40886800">parent</a><span>|</span><a href="#40886928">next</a><span>|</span><label class="collapse" for="c-40886858">[-]</label><label class="expand" for="c-40886858">[2 more]</label></div><br/><div class="children"><div class="content">Worrying about UUID collisions is like worrying about being hit in the head by a meteor. Sure, its technically possible, but it happens so rarely that worrying about a collision as a performance concern is just a misunderstanding on how UUIDs work.<p>And, it’s so random that if you ever do see a collision you should immediately start looking for a compromised system or bug. This is basically how GitHub discovered the OpenSSL bug that had removed too much entropy from the RNG setup.</div><br/><div id="40887614" class="c"><input type="checkbox" id="c-40887614" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#40886800">root</a><span>|</span><a href="#40886858">parent</a><span>|</span><a href="#40886928">next</a><span>|</span><label class="collapse" for="c-40887614">[-]</label><label class="expand" for="c-40887614">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to worry about a collision in a UUIDv4 that you created on your server. But I have seen a surprising number of applications that took a UUID generated client side and basically upserted it. Allowing taking over resources who&#x27;s ID was known via the insert API (even if the update API has proper access control).</div><br/></div></div></div></div><div id="40886928" class="c"><input type="checkbox" id="c-40886928" checked=""/><div class="controls bullet"><span class="by">netcraft</span><span>|</span><a href="#40886800">parent</a><span>|</span><a href="#40886858">prev</a><span>|</span><a href="#40886860">next</a><span>|</span><label class="collapse" for="c-40886928">[-]</label><label class="expand" for="c-40886928">[1 more]</label></div><br/><div class="children"><div class="content">The point of UUIDs is that they&#x27;re inherently unique. You can generate them in the database or in your application, or anywhere. You can move records between databases without worrying about a collision. Its this reason that theyre so useful and so many people use them that others like to write articles like this.<p>You do not need to search. I have generated hundreds of millions and have never hit a duplicate. Its technically possible, but its so vanishingly rare it will be something to brag about, not worry about. If you&#x27;re really worried about it, and building something that cannot tolerate an error, put a try&#x2F;catch around it and detect a PK failure and try again. But it will be a waste of time.</div><br/></div></div><div id="40886860" class="c"><input type="checkbox" id="c-40886860" checked=""/><div class="controls bullet"><span class="by">joshuamcginnis</span><span>|</span><a href="#40886800">parent</a><span>|</span><a href="#40886928">prev</a><span>|</span><a href="#40887560">next</a><span>|</span><label class="collapse" for="c-40886860">[-]</label><label class="expand" for="c-40886860">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  This identifier is a 128-bit quantity that is generated by an algorithm chosen to make it very unlikely that the same identifier will be generated by anyone else in the known universe using the same algorithm. Therefore, for distributed systems, these identifiers provide a better uniqueness guarantee than sequence generators, which are only unique within a single database.<p><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-uuid.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;datatype-uuid.html</a></div><br/></div></div><div id="40887560" class="c"><input type="checkbox" id="c-40887560" checked=""/><div class="controls bullet"><span class="by">jrochkind1</span><span>|</span><a href="#40886800">parent</a><span>|</span><a href="#40886860">prev</a><span>|</span><a href="#40887395">next</a><span>|</span><label class="collapse" for="c-40887560">[-]</label><label class="expand" for="c-40887560">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s indexed in a unique index, as a primary key certainly would be, the DB is of course already checking for collision on insert, so there&#x27;s no reason for application code to do it. (If it did, it would be an indexed lookup rather than a table scan).<p>So if there&#x27;s a collision you&#x27;ll get an error. You can write application code to handle the error (by re-generating a new ID and re-trying).  Or you can figure it&#x27;s so unlikely (googling for uuidv4 says &quot;1 in 2.71 x 1018&quot;, which is pretty huge; not sure for uuidv7 which will be somewhat more likely) that you aren&#x27;t going to worry about it, and if an error happens, oh well, errors happen sometimes, depending on the domain you are in, which is probably what many apps do and do fine with it.<p>I would guess that pg&#x27;s built in uuidv4-generating implementation might re-try on colision under-the-hood, but i haven&#x27;t checked to see, and it may also just count on the improbability and raise an error if it happens!</div><br/></div></div><div id="40887395" class="c"><input type="checkbox" id="c-40887395" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40886800">parent</a><span>|</span><a href="#40887560">prev</a><span>|</span><a href="#40887165">next</a><span>|</span><label class="collapse" for="c-40887395">[-]</label><label class="expand" for="c-40887395">[1 more]</label></div><br/><div class="children"><div class="content">It should be so rare that if it did happen, you likely have a serious bug somewhere. Crash dumping and investigating is the right course of action, not building in retry logic.<p>So if you are using it as a PK
value, only ever insert and if there is a duplicate, blow up
loudly.<p>Performance wise, that isn’t particularly impactful IMO.</div><br/></div></div></div></div><div id="40888012" class="c"><input type="checkbox" id="c-40888012" checked=""/><div class="controls bullet"><span class="by">rjurney</span><span>|</span><a href="#40886800">prev</a><span>|</span><a href="#40887356">next</a><span>|</span><label class="collapse" for="c-40888012">[-]</label><label class="expand" for="c-40888012">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve started using python-ulid as ULIDs seem superior to UUIDs. <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;python-ulid&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;python-ulid&#x2F;</a></div><br/><div id="40888037" class="c"><input type="checkbox" id="c-40888037" checked=""/><div class="controls bullet"><span class="by">openthc</span><span>|</span><a href="#40888012">parent</a><span>|</span><a href="#40887356">next</a><span>|</span><label class="collapse" for="c-40888037">[-]</label><label class="expand" for="c-40888037">[1 more]</label></div><br/><div class="children"><div class="content">I love ULID too; but it&#x27;s really just UUIDv7 (or v8) with a mustache (it&#x27;s all just 128bit IDs).  And in the PG world, where there isn&#x27;t native support for ULID one can use UUIDv7&#x2F;8 and bridge that gap.  We use ULID extensively in exposed IDs, it&#x27;s very URL friendly, copy&#x2F;paste friendly, etc -- but it&#x27;s a UUID datatype in the DB.  (ie: ULID =&gt; UUID =&gt; DB)</div><br/></div></div></div></div><div id="40887356" class="c"><input type="checkbox" id="c-40887356" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#40888012">prev</a><span>|</span><a href="#40888695">next</a><span>|</span><label class="collapse" for="c-40887356">[-]</label><label class="expand" for="c-40887356">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m surprised there is no mention of hash based indexes (i.e. CREATE INDEX ... USING hash...) since lookups would conceivably always use equality.</div><br/><div id="40888067" class="c"><input type="checkbox" id="c-40888067" checked=""/><div class="controls bullet"><span class="by">openthc</span><span>|</span><a href="#40887356">parent</a><span>|</span><a href="#40888695">next</a><span>|</span><label class="collapse" for="c-40888067">[-]</label><label class="expand" for="c-40888067">[1 more]</label></div><br/><div class="children"><div class="content">With UUIDv7&#x2F;v8 (and ULID) there are some timestamps in the front half.  I&#x27;ve seen spots where the query was in the style of  `uuid_col &gt;= &#x27;SOME_UUID_0000&#x27; AND ulid_col &lt;= &#x27;SOME_UUID_FFFF&#x27;`  When one is using them ast the timing for record create&#x2F;insert these things happen.</div><br/></div></div></div></div><div id="40888695" class="c"><input type="checkbox" id="c-40888695" checked=""/><div class="controls bullet"><span class="by">avkrpatel</span><span>|</span><a href="#40887356">prev</a><span>|</span><a href="#40887173">next</a><span>|</span><label class="collapse" for="c-40888695">[-]</label><label class="expand" for="c-40888695">[1 more]</label></div><br/><div class="children"><div class="content">Instead of uuid7 why cant they use ulid?</div><br/></div></div><div id="40887173" class="c"><input type="checkbox" id="c-40887173" checked=""/><div class="controls bullet"><span class="by">tantalor</span><span>|</span><a href="#40888695">prev</a><span>|</span><a href="#40885911">next</a><span>|</span><label class="collapse" for="c-40887173">[-]</label><label class="expand" for="c-40887173">[3 more]</label></div><br/><div class="children"><div class="content">&gt; inserting UUID v7 is ~2x faster and inserting regular UUID v4<p>Okay but why</div><br/><div id="40887196" class="c"><input type="checkbox" id="c-40887196" checked=""/><div class="controls bullet"><span class="by">mythrwy</span><span>|</span><a href="#40887173">parent</a><span>|</span><a href="#40885911">next</a><span>|</span><label class="collapse" for="c-40887196">[-]</label><label class="expand" for="c-40887196">[2 more]</label></div><br/><div class="children"><div class="content">It tells you in the previous section:<p>&quot;UUID - even though always looks similar - comes in multiple variants. Java&#x27;s UUID.randomUUID() - returns UUID v4 - which is a pseudo-random value. For us the more interesting one is UUID v7 - which produces time-sorted values. It means that each time new UUID v7 is generated, a greater value it has. And that makes it a good fit for B-Tree index.&quot;</div><br/><div id="40887979" class="c"><input type="checkbox" id="c-40887979" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#40887173">root</a><span>|</span><a href="#40887196">parent</a><span>|</span><a href="#40885911">next</a><span>|</span><label class="collapse" for="c-40887979">[-]</label><label class="expand" for="c-40887979">[1 more]</label></div><br/><div class="children"><div class="content">The benchmark seems to include generation in the total time. Not sure that&#x27;s a useful comparison of how b-tree index behaves in each case (as UUIDv7 has fewer bits of randomness, it&#x27;s also cheaper to generate).</div><br/></div></div></div></div></div></div><div id="40885911" class="c"><input type="checkbox" id="c-40885911" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#40887173">prev</a><span>|</span><a href="#40885890">next</a><span>|</span><label class="collapse" for="c-40885911">[-]</label><label class="expand" for="c-40885911">[10 more]</label></div><br/><div class="children"><div class="content">UUIDs are guaranteed to be unique?<p>They often use tricks like including the MAC address of the generator machine and other ways to increase uniqueness assurances.<p>It was my understanding that uuids are simply very very unlikely to duplicate in situations with random generation.</div><br/><div id="40886013" class="c"><input type="checkbox" id="c-40886013" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#40885911">parent</a><span>|</span><a href="#40886293">next</a><span>|</span><label class="collapse" for="c-40886013">[-]</label><label class="expand" for="c-40886013">[1 more]</label></div><br/><div class="children"><div class="content">UUIDv2 uses Mac addresses, but those turned out to be mostly a bad idea. Today when people say UUID they mean UUIDv4, which is just 124 random bits (and 4 version bits). Assuming a good random number generator it&#x27;s basically impossible to generate the same UUIDv4 twice by pure chance. Even if you make billions of them per second it&#x27;s vanishingly unlikely to happen.</div><br/></div></div><div id="40886293" class="c"><input type="checkbox" id="c-40886293" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#40885911">parent</a><span>|</span><a href="#40886013">prev</a><span>|</span><a href="#40886221">next</a><span>|</span><label class="collapse" for="c-40886293">[-]</label><label class="expand" for="c-40886293">[6 more]</label></div><br/><div class="children"><div class="content">Your understanding is correct but you&#x27;re underselling very very in this context.  It is astronomically unlikely to hit a collision with the advised generation methods.  If you want a possibly easier to grasp parallel git relies on SHA hashes never colliding and will break in a really awful way if you can produce two commits in a tree with the same hash - it&#x27;s so astoundingly unlikely that people are okay summarizing it as &quot;Never gonna happen&quot; - it certainly will eventually, but it might not happen until the earth is swallowed by the sun.</div><br/><div id="40886933" class="c"><input type="checkbox" id="c-40886933" checked=""/><div class="controls bullet"><span class="by">aero_code</span><span>|</span><a href="#40885911">root</a><span>|</span><a href="#40886293">parent</a><span>|</span><a href="#40886786">next</a><span>|</span><label class="collapse" for="c-40886933">[-]</label><label class="expand" for="c-40886933">[2 more]</label></div><br/><div class="children"><div class="content">&quot;it certainly will eventually&quot; - I think even that is underselling how unlikely it is for Git 256-bit hashes to collide. I calculated (taking into account the birthday paradox), that even if 8 billion people on Earth each created a Git commit every second, that they would have to do that non-stop for 1,588,059,911 trillion years before there&#x27;s a 50% chance that any of the two commits have the same hash. Our sun is predicted to only last 0.005 trillion years more.<p>√(2^256)×1.1774÷8000000000÷3600÷24÷365 = 1,588,059,910,945,875,138,261<p>UUIDs are more likely to collide but still basically impossible. You&#x27;d have to generate √(2^122)×1.1774 = 2714899559048203259 to have 50% chance of a collision. Just to store the UUIDs for that database would take 39,506,988 TB of space. If you aren&#x27;t thinking about your database not fitting on millions of drives, don&#x27;t think about UUID collisions.</div><br/><div id="40888079" class="c"><input type="checkbox" id="c-40888079" checked=""/><div class="controls bullet"><span class="by">openthc</span><span>|</span><a href="#40885911">root</a><span>|</span><a href="#40886933">parent</a><span>|</span><a href="#40886786">next</a><span>|</span><label class="collapse" for="c-40888079">[-]</label><label class="expand" for="c-40888079">[1 more]</label></div><br/><div class="children"><div class="content">Collision Calculators:<p>- <a href="https:&#x2F;&#x2F;alex7kom.github.io&#x2F;nano-nanoid-cc&#x2F;" rel="nofollow">https:&#x2F;&#x2F;alex7kom.github.io&#x2F;nano-nanoid-cc&#x2F;</a>
- <a href="https:&#x2F;&#x2F;devina.io&#x2F;collision-calculator" rel="nofollow">https:&#x2F;&#x2F;devina.io&#x2F;collision-calculator</a></div><br/></div></div></div></div><div id="40886786" class="c"><input type="checkbox" id="c-40886786" checked=""/><div class="controls bullet"><span class="by">lulzury</span><span>|</span><a href="#40885911">root</a><span>|</span><a href="#40886293">parent</a><span>|</span><a href="#40886933">prev</a><span>|</span><a href="#40886221">next</a><span>|</span><label class="collapse" for="c-40886786">[-]</label><label class="expand" for="c-40886786">[3 more]</label></div><br/><div class="children"><div class="content">What you stated makes intuitive sense, but it does make me wonder why the RFC states the following in the security considerations:<p>&gt; Implementations SHOULD NOT assume that UUIDs are hard to guess. For example, they MUST NOT be used as security capabilities (identifiers whose mere possession grants access). Discovery of predictability in a random number source will result in a vulnerability.<p><a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562#name-security-considerations" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;rfc9562#name-security-...</a></div><br/><div id="40887998" class="c"><input type="checkbox" id="c-40887998" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#40885911">root</a><span>|</span><a href="#40886786">parent</a><span>|</span><a href="#40887583">next</a><span>|</span><label class="collapse" for="c-40887998">[-]</label><label class="expand" for="c-40887998">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s mostly focusing on broken RNG properties (i.e. static seed for a pseudo random generator, an outright bad algorithm, or bad entropy source for non-pseudo RNG). They make random numbers predictable, thus your UUIDs become predictable.<p>Cryptographic hashes are usually also dependent on RNGs having good properties (encryption has been broken due to bad RNGs too), but they are a bit more involved to figure out even if you know the input randomness, and are easier to invalidate (change the secret).</div><br/></div></div><div id="40887583" class="c"><input type="checkbox" id="c-40887583" checked=""/><div class="controls bullet"><span class="by">jrochkind1</span><span>|</span><a href="#40885911">root</a><span>|</span><a href="#40886786">parent</a><span>|</span><a href="#40887998">prev</a><span>|</span><a href="#40886221">next</a><span>|</span><label class="collapse" for="c-40887583">[-]</label><label class="expand" for="c-40887583">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know the math here specifically, but being <i>hard to guess</i> is a different quantity than <i>chance of collision when following the algorithm</i>.<p>That is, if you aren&#x27;t <i>trying</i> to have a collision and following the algorithm that has that aim, a collision can be exceedingly unlikely; but they can still be easy to guess if you are trying to predict someone else&#x27;s assignment.</div><br/></div></div></div></div></div></div><div id="40886221" class="c"><input type="checkbox" id="c-40886221" checked=""/><div class="controls bullet"><span class="by">throwawayffffas</span><span>|</span><a href="#40885911">parent</a><span>|</span><a href="#40886293">prev</a><span>|</span><a href="#40885890">next</a><span>|</span><label class="collapse" for="c-40886221">[-]</label><label class="expand" for="c-40886221">[2 more]</label></div><br/><div class="children"><div class="content">They are not theoretically guaranteed they are in practice though. 2^128 and 122 are big numbers. Even if you are producing a billion per second you have a 50% chance of not getting a collision for 100 years.</div><br/><div id="40886306" class="c"><input type="checkbox" id="c-40886306" checked=""/><div class="controls bullet"><span class="by">jacobgorm</span><span>|</span><a href="#40885911">root</a><span>|</span><a href="#40886221">parent</a><span>|</span><a href="#40885890">next</a><span>|</span><label class="collapse" for="c-40886306">[-]</label><label class="expand" for="c-40886306">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used 128 secure-random bits for ages, not caring for any of the UUID version nonsense. Per the birthday paradox, I need to have 2*64 entries in my tables to reach 50% collision probability, and it will be a while before I can afford that much storage anyhow.</div><br/></div></div></div></div></div></div><div id="40885890" class="c"><input type="checkbox" id="c-40885890" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#40885911">prev</a><span>|</span><a href="#40885861">next</a><span>|</span><label class="collapse" for="c-40885890">[-]</label><label class="expand" for="c-40885890">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t B-Tree with UUIDv4 keys getting more balanced than with UUIDv7? Doesn&#x27;t longer insert time result in faster searches later?</div><br/></div></div><div id="40885861" class="c"><input type="checkbox" id="c-40885861" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#40885890">prev</a><span>|</span><a href="#40889085">next</a><span>|</span><label class="collapse" for="c-40885861">[-]</label><label class="expand" for="c-40885861">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  If you have an option to choose, take a look at TSID maintained by Vlad Mihalcea.<p>TSID:
&gt; A Java library for generating Time-Sorted Unique Identifiers (TSID).<p>Wouldn&#x27;t this TSID thing be more useful if it were implemented as a set of PostgreSQL stored procedures or something than a Java library? Not everyone uses Java.</div><br/><div id="40885973" class="c"><input type="checkbox" id="c-40885973" checked=""/><div class="controls bullet"><span class="by">busterarm</span><span>|</span><a href="#40885861">parent</a><span>|</span><a href="#40888697">next</a><span>|</span><label class="collapse" for="c-40885973">[-]</label><label class="expand" for="c-40885973">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s forked from <a href="https:&#x2F;&#x2F;github.com&#x2F;f4b6a3&#x2F;tsid-creator">https:&#x2F;&#x2F;github.com&#x2F;f4b6a3&#x2F;tsid-creator</a>.  While this is also in Java, it has many reimplementations in other languages.</div><br/></div></div><div id="40888697" class="c"><input type="checkbox" id="c-40888697" checked=""/><div class="controls bullet"><span class="by">avkrpatel</span><span>|</span><a href="#40885861">parent</a><span>|</span><a href="#40885973">prev</a><span>|</span><a href="#40889085">next</a><span>|</span><label class="collapse" for="c-40888697">[-]</label><label class="expand" for="c-40888697">[1 more]</label></div><br/><div class="children"><div class="content">Ulid is also similar to it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>