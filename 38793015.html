<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1703840466035" as="style"/><link rel="stylesheet" href="styles.css?v=1703840466035"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fernandovillalba.substack.com/p/its-not-microservice-or-monolith">It&#x27;s not microservice or monolith; it&#x27;s cognitive load</a> <span class="domain">(<a href="https://fernandovillalba.substack.com">fernandovillalba.substack.com</a>)</span></div><div class="subtext"><span>DevOpsy</span> | <span>107 comments</span></div><br/><div><div id="38802353" class="c"><input type="checkbox" id="c-38802353" checked=""/><div class="controls bullet"><span class="by">hooby</span><span>|</span><a href="#38801286">next</a><span>|</span><label class="collapse" for="c-38802353">[-]</label><label class="expand" for="c-38802353">[7 more]</label></div><br/><div class="children"><div class="content">Reading the responses&#x2F;comments in here, a question arises...<p>Are things really that black and white as people here paint them - with monoliths unavoidably and necessarily becoming a tangled mess of spaghetti, and micro-services being the singular, only way to achieve clean separation, autonomy and partition?
With microservices inevitably being an organizational nightmare that leads to problems in inter-team coordination, while monoliths automatically ensure that everyone always is perfectly the same page?<p>Because by my personal experience, you totally can code a monolith in a strictly modular fashion, with clean interface-based API boundaries between the separate parts. And if you put those &quot;modules&quot; into separate packages, the dependencies between them end up being managed and documented as well. Just like you totally can setup microservices and surrounding procedures in a way that actually increases the feeling of product ownership in the teams, and reduces the hassle of inter-team coordination - especially in larger companies.<p>Obviously there are ways to do monoliths right, and spectacularly wrong. And there are ways to do microservices right and wrong...<p>I see so many arguments here, that do compare one method done wrong with the other method done right - and then imply that this is a strong reason for choosing that second method.<p>I don&#x27;t get it?</div><br/><div id="38802948" class="c"><input type="checkbox" id="c-38802948" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#38802353">parent</a><span>|</span><a href="#38802897">next</a><span>|</span><label class="collapse" for="c-38802948">[-]</label><label class="expand" for="c-38802948">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps it is easier to understand when you remember that service is not a technical term? <i>People</i> provide service.<p>In the macro economy, service comes from other companies. If you integrate an LLM into your application, you may use the services of OpenAI. If you integrate payment processing into your application, you may use the services of Stripe. Microservices are just like services, except offered within a micro economy (think a single business).<p>In other words, it&#x27;s a team separation technique. You let teams within a business organize as if they were separate businesses and let them offer services to each other as if they were operating different businesses.<p>How those teams design their software is ultimately irrelevant. The key aspect is keeping active communication between teams to a minimum, using published documentation and API contracts as the mode of communication between teams. Getting another team on the phone should be as hard as getting Google on the phone to help you with a problem – i.e. basically impossible, but also basically unnecessary.<p>This is done in large organizations to ensure that developers aren&#x27;t forever bogged down in meetings. If you have 10,000 developers all trying to work on the same project the communication overhead will kill you. Microservices is a way to try to overcome that. Of course, they serve no purpose in a small company where an economy can&#x27;t reasonably grow anyway.</div><br/></div></div><div id="38802897" class="c"><input type="checkbox" id="c-38802897" checked=""/><div class="controls bullet"><span class="by">dzikimarian</span><span>|</span><a href="#38802353">parent</a><span>|</span><a href="#38802948">prev</a><span>|</span><a href="#38802704">next</a><span>|</span><label class="collapse" for="c-38802897">[-]</label><label class="expand" for="c-38802897">[1 more]</label></div><br/><div class="children"><div class="content">In my opinion it&#x27;s people problem. Lots of developers are focused on pure technicalities. They will focus on writing code and ignore why it&#x27;s written.<p>As result of that their choice of architecture will be detached from business function. Also, as thinking about architecture isn&#x27;t writing code it will be often afterthought based on shallow knowledge and superstitions.<p>Keeping that in mind - when you are talking to bigger team containing people with various seniority, it&#x27;s often best to give them rigid set of rules, because they&#x27;ll misinterpret or ignore something more complex.<p>And that&#x27;s why black and white approach often works - it&#x27;s far from ideal, but at least possible to actually execute in many of the teams.</div><br/></div></div><div id="38802704" class="c"><input type="checkbox" id="c-38802704" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#38802353">parent</a><span>|</span><a href="#38802897">prev</a><span>|</span><a href="#38802485">next</a><span>|</span><label class="collapse" for="c-38802704">[-]</label><label class="expand" for="c-38802704">[1 more]</label></div><br/><div class="children"><div class="content">A lot of factors come together whenever the term Microservie or Monolith arises:<p>- Monolith has implicitly replaced the word &quot;Legacy&quot; system<p>- Microservices were (&#x2F;are still) the cool thing to do in a conference driven industry. They were championed by big tech because they desire granular and flexible deployment systems (whereas in smaller products your code just needs to run and everything else is just overhead). Having multiple instances of a MS can fix some performance issues as well.<p>- People rarely talk about failing with their new (microservice) projects.<p>- Microservices can be a technical solutions for human problems. Large teams benefit from distributed deployments due to organizational reasons. They also force you to think more about modelling your responsibilities, which might be add odds with your company culture.<p>To me, Microservices are not an architecture pattern but a deployment strategy. Obviously, you want high cohesion and modules, which you might or might not get with Microservices. It comes down to understanding your problem domain.<p>If you have a modular monolith, you can still deploy it separately at a later point if the need arises. Even having a shared database is not a problem if your modules are only using the respective tables they own (this can be enforced with permissions).</div><br/></div></div><div id="38802485" class="c"><input type="checkbox" id="c-38802485" checked=""/><div class="controls bullet"><span class="by">chronid</span><span>|</span><a href="#38802353">parent</a><span>|</span><a href="#38802704">prev</a><span>|</span><a href="#38802397">next</a><span>|</span><label class="collapse" for="c-38802485">[-]</label><label class="expand" for="c-38802485">[2 more]</label></div><br/><div class="children"><div class="content">My 2c: you can get things right, but most of the time you won&#x27;t, for many reasons - technical, logistical, cultural or merely political. Sometimes you don&#x27;t control these reasons.<p>So you are now left with managing risk. It&#x27;s trade-offs all the way down.</div><br/><div id="38802658" class="c"><input type="checkbox" id="c-38802658" checked=""/><div class="controls bullet"><span class="by">braza</span><span>|</span><a href="#38802353">root</a><span>|</span><a href="#38802485">parent</a><span>|</span><a href="#38802397">next</a><span>|</span><label class="collapse" for="c-38802658">[-]</label><label class="expand" for="c-38802658">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but most of the time you won&#x27;t, for many reasons<p>This.<p>One thing that I noticed working in 3 different continents is that the learning&#x2F;teaching on technology (CS?) is highly fragmented and it&#x27;s quite hard to find some &quot;common ground&quot; in practices and methods and mesh all of that in a socio-technological place makes everything harder.<p>A weak generalization to illustrate the point: A [Continent A] developer will be more resource aware due to their natural lack of, an [Continent B] developer since it has more human capital available (better mentors, big ecosystem, huge amount of finance capital) will have more room for scaling ideas, a [Continent C] developer will have a better understanding of the intricacies due to their formal education and cultural aspects.<p>Placing all those people underneath a tech project and not having a program to terraform biases and level them to a shared and understandable set of expectations is the root cause of all this debacle.</div><br/></div></div></div></div><div id="38802397" class="c"><input type="checkbox" id="c-38802397" checked=""/><div class="controls bullet"><span class="by">nullandvoid</span><span>|</span><a href="#38802353">parent</a><span>|</span><a href="#38802485">prev</a><span>|</span><a href="#38801286">next</a><span>|</span><label class="collapse" for="c-38802397">[-]</label><label class="expand" for="c-38802397">[1 more]</label></div><br/><div class="children"><div class="content">To borrow some monolith examples from Monolith to Microservices (<a href="https:&#x2F;&#x2F;www.goodreads.com&#x2F;en&#x2F;book&#x2F;show&#x2F;44144499" rel="nofollow">https:&#x2F;&#x2F;www.goodreads.com&#x2F;en&#x2F;book&#x2F;show&#x2F;44144499</a> - fantastic read)<p>&quot;Single Process&quot; -  Can be module based (Shopify), where multiple module&#x27;s interact, but must be combined for deployment still, these module&#x27;s can even extend to the DB&#x27;s. Can still have multiple instances for performance<p>&quot;Distributed Monolith&quot; - This is one to fear the most, we have multiple services, yet there is still shared DB&#x27;s meaning we have to deploy things together.<p>Both are monoliths but one is less susceptible to ball of mud. It&#x27;s a sliding scale, with trade offs for each (and many variations still in between those listed).<p>I think it&#x27;s a lack of common terminology surrounding monolith &#x2F; micro-service that creates this binary illusion.</div><br/></div></div></div></div><div id="38801286" class="c"><input type="checkbox" id="c-38801286" checked=""/><div class="controls bullet"><span class="by">nateburke</span><span>|</span><a href="#38802353">prev</a><span>|</span><a href="#38802682">next</a><span>|</span><label class="collapse" for="c-38801286">[-]</label><label class="expand" for="c-38801286">[33 more]</label></div><br/><div class="children"><div class="content">The moment you adopt service based teams with service based managers, say goodbye to engineers caring about working product. Say hello to cross team meetings and project management every time you want to ship a feature.<p>It&#x27;s pure vanity for a startup to think they will become the next AWS by adopting hard service-based contracts between teams.</div><br/><div id="38801878" class="c"><input type="checkbox" id="c-38801878" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#38801286">parent</a><span>|</span><a href="#38802724">next</a><span>|</span><label class="collapse" for="c-38801878">[-]</label><label class="expand" for="c-38801878">[7 more]</label></div><br/><div class="children"><div class="content">This viewpoint doesn&#x27;t translate to reality in my experience. Monolith or not, engineers care about working product if they are incentivized to care about working product (and if they aren&#x27;t, they don&#x27;t).<p>Code is code. Cognitive load is cognitive load. Doesn&#x27;t matter how you organize it. Unless your company is still very small and simple, there&#x27;s no single team that is going to be able to understand how the entire system works (and take ownership of every part of it working properly). I&#x27;ve worked in many monoliths where you still had to have &quot;cross team meetings and project management every time you want to ship a feature&quot;.</div><br/><div id="38802338" class="c"><input type="checkbox" id="c-38802338" checked=""/><div class="controls bullet"><span class="by">cncivubyv</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801878">parent</a><span>|</span><a href="#38802258">next</a><span>|</span><label class="collapse" for="c-38802338">[-]</label><label class="expand" for="c-38802338">[5 more]</label></div><br/><div class="children"><div class="content">Microservices tends to result in developers thinking their service is the product they&#x27;re shipping to other developers.</div><br/><div id="38802463" class="c"><input type="checkbox" id="c-38802463" checked=""/><div class="controls bullet"><span class="by">aniforprez</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38802338">parent</a><span>|</span><a href="#38802258">next</a><span>|</span><label class="collapse" for="c-38802463">[-]</label><label class="expand" for="c-38802463">[4 more]</label></div><br/><div class="children"><div class="content">Honestly, in my experience there&#x27;s nothing wrong with this line of thinking as long as you also consider that the product you&#x27;re shipping to other devs is in service of a much more important and larger product&#x2F;service in itself. Thinking of your service as a product keeps you thinking of the use cases, the potential errors and the DX of what you&#x27;re shipping which is a good thing I say as long as you&#x27;re not building pies in the sky. As with most things, it comes down to good planning</div><br/><div id="38802811" class="c"><input type="checkbox" id="c-38802811" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38802463">parent</a><span>|</span><a href="#38802666">next</a><span>|</span><label class="collapse" for="c-38802811">[-]</label><label class="expand" for="c-38802811">[1 more]</label></div><br/><div class="children"><div class="content">The key word here is DX. If a team is exposed to how the DX of their owned service or library enables others in the company to build things that bring smiles to customers&#x27; faces, they&#x27;ll be able to better design for their downstream teams&#x27; experiences, finding the right balance of keeping API churn low while building for future flexibility. This is true whether the API boundary is over a network or over a function call.<p>That said, microservices have the added problem that if you don&#x27;t get the culture and boundaries set just right from the beginning, it&#x27;s harder to change. They&#x27;re good for small domains where boundaries are defined, and many even-early-stage startups have some of those, but it&#x27;s unlikely that the primary interface for customers is included in that.</div><br/></div></div><div id="38802666" class="c"><input type="checkbox" id="c-38802666" checked=""/><div class="controls bullet"><span class="by">cncivubyv</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38802463">parent</a><span>|</span><a href="#38802811">prev</a><span>|</span><a href="#38802258">next</a><span>|</span><label class="collapse" for="c-38802666">[-]</label><label class="expand" for="c-38802666">[2 more]</label></div><br/><div class="children"><div class="content">This results in people optimizing local maximums, ultimately the real product suffers.<p>The developers also assume their product is relevant when perhaps it no longer is in the wider context of the business.</div><br/><div id="38802684" class="c"><input type="checkbox" id="c-38802684" checked=""/><div class="controls bullet"><span class="by">aniforprez</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38802666">parent</a><span>|</span><a href="#38802258">next</a><span>|</span><label class="collapse" for="c-38802684">[-]</label><label class="expand" for="c-38802684">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s why I added my conditionals. Obviously the goal is the broader product&#x2F;service at large</div><br/></div></div></div></div></div></div></div></div><div id="38802258" class="c"><input type="checkbox" id="c-38802258" checked=""/><div class="controls bullet"><span class="by">Nextgrid</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801878">parent</a><span>|</span><a href="#38802338">prev</a><span>|</span><a href="#38802724">next</a><span>|</span><label class="collapse" for="c-38802258">[-]</label><label class="expand" for="c-38802258">[1 more]</label></div><br/><div class="children"><div class="content">&gt; engineers care about working product if they are incentivized to care about working product<p>Places that set up the correct incentives are usually very rare. Maybe hedge funds or some finance places which give you a decent chunk of the profits your code makes but that&#x27;s about it.<p>Every other place pays you the same &quot;meh&quot; salary and the quickest way up is to job-hop frequently, in which case resume-driven-development takes priority over &quot;working product&quot;. That&#x27;s how you get cargo-cult over-engineering, everything else be damned since you will be gone by the time the consequences emerge anyway.<p>(also you have &quot;startups&quot; where over-engineering is usually a desired feature as it gives them a justification to grift more VC money to keep their unsustainable business afloat further).</div><br/></div></div></div></div><div id="38802724" class="c"><input type="checkbox" id="c-38802724" checked=""/><div class="controls bullet"><span class="by">dzikimarian</span><span>|</span><a href="#38801286">parent</a><span>|</span><a href="#38801878">prev</a><span>|</span><a href="#38801326">next</a><span>|</span><label class="collapse" for="c-38802724">[-]</label><label class="expand" for="c-38802724">[2 more]</label></div><br/><div class="children"><div class="content">Correct question is: why does it take a few teams to deliver feature? This defeats point of entire exercise.<p>Usually answer is, that division was done by technical role and not business function of the subsystem.</div><br/><div id="38802846" class="c"><input type="checkbox" id="c-38802846" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38802724">parent</a><span>|</span><a href="#38801326">next</a><span>|</span><label class="collapse" for="c-38802846">[-]</label><label class="expand" for="c-38802846">[1 more]</label></div><br/><div class="children"><div class="content">In most cases there&#x27;s going to be substantial overlap between the functionality required for various business functions, and even in differentiated systems the ideal technical domains may not map cleanly to business domains. It&#x27;s very easy for this to result in multiple teams having half-assed, semi-compatible implementations of the same functionality.<p>Some places try to address this by creating dedicated &quot;core&quot; or &quot;platform&quot; teams, but there&#x27;s numerous pitfalls this way as well. Platform teams and product teams necessarily have to justify their budgets in different ways. They have different stakeholders and internal sponsors. This can result in political struggles over headcount. &quot;Brain drain&quot; scenarios where product teams are perennially starved as their strongest ICs are moved to platform. &quot;Slush fund&quot; scenarios where platform teams are regularly &quot;temporarily&quot; reassigned to support feature development. I&#x27;ve seen them both.<p>The longer you can have your entire engineering team share responsibility for the entire product the better. I am convinced of this. Unless you can truly, completely decouple systems -- making them separate products with dedicated teams -- you run a high risk of having a codebase that is more complex that people still need to understand in its entirety to work effectively. The worst of both worlds.</div><br/></div></div></div></div><div id="38801326" class="c"><input type="checkbox" id="c-38801326" checked=""/><div class="controls bullet"><span class="by">ddejohn</span><span>|</span><a href="#38801286">parent</a><span>|</span><a href="#38802724">prev</a><span>|</span><a href="#38801568">next</a><span>|</span><label class="collapse" for="c-38801326">[-]</label><label class="expand" for="c-38801326">[21 more]</label></div><br/><div class="children"><div class="content">This strikes me as overly cynical.<p>My current job is working with around 20 other engineers on an extremely bloated and coupled monolith. I&#x27;d love to be able to separate myself and my team from others by an agreed-upon interface.<p>Yes, &quot;agreed-upon&quot; is certainly doing some heavy lifting there, but I don&#x27;t think it&#x27;s realistic to expect that<p>&gt; cross team meetings and project management every time you want to ship a feature<p>is somehow avoidable in tech?</div><br/><div id="38801380" class="c"><input type="checkbox" id="c-38801380" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801326">parent</a><span>|</span><a href="#38801485">next</a><span>|</span><label class="collapse" for="c-38801380">[-]</label><label class="expand" for="c-38801380">[15 more]</label></div><br/><div class="children"><div class="content">&gt; This strikes me as overly cynical.<p>&gt; My current job is working with around 20 other engineers on an extremely bloated and coupled monolith. I&#x27;d love to be able to separate myself and my team from others by an agreed-upon interface.<p>&gt; Yes, &quot;agreed-upon&quot; is certainly doing some heavy lifting there, but I don&#x27;t think it&#x27;s realistic to expect that<p>This is overly cynical to you likely because you haven&#x27;t experienced maintaining micro-services in the long term. Being able to &quot;break away&quot; with a common interface is literally the microservice tag line. It&#x27;s completely true too. Standing up a service w&#x2F; an interface is incredibly fast, rewarding and watching it hum is beautiful.<p>The problem starts when there&#x27;s a bug that&#x27;s upstream of your service. It&#x27;s not too hard to get all 15+ services running on your laptop, but the problem is the other teams no longer let external members directly deploy the services they maintain (that one time someone from another team deployed a big bug). So now you&#x27;ve got to get PR approval and seemingly no one wants to review your bug. So you ask for time from the Product Owner and it gets forgotten because they&#x27;re really busy too. So you go to an eng manager, etc etc...<p>The above scenario plays out SO many times. I&#x27;ve been there in all various forms. As a blunt statement - any team under 30 members, monolith.</div><br/><div id="38801971" class="c"><input type="checkbox" id="c-38801971" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801380">parent</a><span>|</span><a href="#38801774">next</a><span>|</span><label class="collapse" for="c-38801971">[-]</label><label class="expand" for="c-38801971">[1 more]</label></div><br/><div class="children"><div class="content">Standing up a service across the globe is non-trivial even with world class tools. You still run into issues like services not being properly co located with other services they need to call so you end up paying for inter continental hops. And cold connections because the new service doesn&#x27;t have much traffic yet. And maybe DB leaders are only in North America so Asia has terrible perf.</div><br/></div></div><div id="38801774" class="c"><input type="checkbox" id="c-38801774" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801380">parent</a><span>|</span><a href="#38801971">prev</a><span>|</span><a href="#38801485">next</a><span>|</span><label class="collapse" for="c-38801774">[-]</label><label class="expand" for="c-38801774">[13 more]</label></div><br/><div class="children"><div class="content">If you have to &quot;get all 15+ services running on your laptop&quot;, you&#x27;ve already lost. Every one of our 100+ components maintained by our dozen person team can be run and tested on its own. The <i>only</i> reason we have Docker on our machine is to test the images we deploy (just to make sure they build and run).<p>You have experienced what happens when web developers cosplay as software architects. That&#x27;s when you get &quot;microservices&quot;. It&#x27;s a travesty, and it has ruined an entire generation of software developers who now believe that partitioning and autonomy are just myths.<p>So, as a blunt statement - your experience is typical. That is, it&#x27;s average. That is, you experienced an average team doing average work misguided by average bad advice. It says absolutely nothing about software design. It only speaks to the fat part of the bell curve doing what it always does.</div><br/><div id="38801858" class="c"><input type="checkbox" id="c-38801858" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801774">parent</a><span>|</span><a href="#38801821">next</a><span>|</span><label class="collapse" for="c-38801858">[-]</label><label class="expand" for="c-38801858">[10 more]</label></div><br/><div class="children"><div class="content">&gt; So, as a blunt statement - your experience is typical. That is, it&#x27;s average.<p>Definitely a fair judgement and would agree that this constitutes poor architecting on many many companies&#x27; parts including ones that I&#x27;ve been a part of.<p>&gt; Every one of our 100+ components maintained by our dozen person team can be run and tested on its own.<p>Can you elaborate on this? What is the primary benefit of running 100-300 components vs a monolith specifically with a 12 person team?<p>More directly, what&#x27;s wrong with a monolith at the dozen person team size?</div><br/><div id="38801914" class="c"><input type="checkbox" id="c-38801914" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801858">parent</a><span>|</span><a href="#38801821">next</a><span>|</span><label class="collapse" for="c-38801914">[-]</label><label class="expand" for="c-38801914">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Can you elaborate on this? What is the primary benefit of running 100-300 components vs a monolith specifically with a 12 person team?<p>&gt; More directly, what&#x27;s wrong with a monolith at the dozen person team size?<p>Great question. It&#x27;s honestly a hard question to answer because the real answer requires tacit knowledge, but I&#x27;ll try anyway because you asked. I&#x27;ll link a couple articles of longer form writing that may help to answer as well.<p>The benefit ultimately is productivity. That productivity comes from autonomy, which comes from partitioning.<p>Each component can be worked, tested, and deployed on its own. We never need to spin up more than one at a time, which means any time we are working on our code, we are typically working on 1&#x2F;400th of it, and we know we are because we have 400 separate GitHub repositories. We can&#x27;t accidentally get peanut butter in our mayonaise. Each part is independently built and tested.<p>When it&#x27;s time to upgrade Rails, we can upgrade one application. This is 1&#x2F;20th of our Rails code. That&#x27;s a smaller batch. We know from basic flow principles that (see: Principles of Product Development Flow, Lean, etc.) that small batches are  better for productivity.<p>We rarely have merge conflicts. We don&#x27;t do pull requests. We branch when we need to. We are often working on a brand new, never been deployed project. We don&#x27;t have our tests running in CI. Our tests run in less than a second in most projects on our laptops. With those that have UI, our tests typically run in less than 30 seconds which include thorough Capybara (UI Interaction) testing.<p>When we are working in any application, we only need to consider its direct efferents when making a change to any interfaces it exposes. We can trace those changes through easily when we need to make them. Because we practice software design, we don&#x27;t often need to make large sweeping changes, but when we do, we can do them methodically without disruption.<p>The &quot;worst&quot; part is that some things are tedious. But we can automate tedious things. We can invent around tedious things. We used to have to deploy 15 web applications any time we had a style change. Now we deploy one application that supplies the CSS for all our applications via SSI (server-side-include). If we need to deploy 70 back end components, we can script that (with manual verification at each step). We can even spread that out across a couple team members and do it as an ensemble. It takes about an hour to deploy everything. We maybe do this once a month or so (when something highly afferent changes -- and guess what, we structure our design so that afferent things change as infrequently as possible).<p>Most things we work on we work until they are &quot;complete&quot;. That is, they rarely change after that. We have components that have been in production for 3 years and haven&#x27;t been substantially touched aside from Ruby upgrades and the like. They are still perfectly in control.<p>The list goes on and on.<p>Here are a few articles, feel free to poke around the others and ask any follow up questions.<p>Partitions and Compositions: <a href="https:&#x2F;&#x2F;github.com&#x2F;aaronjensen&#x2F;software-development&#x2F;blob&#x2F;master&#x2F;partitions-and-compositions.md">https:&#x2F;&#x2F;github.com&#x2F;aaronjensen&#x2F;software-development&#x2F;blob&#x2F;mas...</a><p>The Mythical Monolith: <a href="https:&#x2F;&#x2F;github.com&#x2F;aaronjensen&#x2F;software-development&#x2F;blob&#x2F;master&#x2F;monoliths.md">https:&#x2F;&#x2F;github.com&#x2F;aaronjensen&#x2F;software-development&#x2F;blob&#x2F;mas...</a></div><br/><div id="38802762" class="c"><input type="checkbox" id="c-38802762" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801914">parent</a><span>|</span><a href="#38802120">next</a><span>|</span><label class="collapse" for="c-38802762">[-]</label><label class="expand" for="c-38802762">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Each part is independently built and tested.<p>&gt; We don&#x27;t have our tests running in CI.<p>&gt; It takes about an hour to deploy everything.<p>Eh? 400 components without any integration testing?? Who glues the sum of the parts together into a whole? This can’t be a single application. Sounds more like many completely independent applications to me.</div><br/></div></div><div id="38802120" class="c"><input type="checkbox" id="c-38802120" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801914">parent</a><span>|</span><a href="#38802762">prev</a><span>|</span><a href="#38802728">next</a><span>|</span><label class="collapse" for="c-38802120">[-]</label><label class="expand" for="c-38802120">[3 more]</label></div><br/><div class="children"><div class="content">&gt; we have 400 separate GitHub repositories<p>Do you think this sounds good?<p>&gt; We can&#x27;t accidentally get peanut butter in our mayonaise<p>Hint: you have 400 different jars of peanut butter with mayonnaise.</div><br/><div id="38802173" class="c"><input type="checkbox" id="c-38802173" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38802120">parent</a><span>|</span><a href="#38802728">next</a><span>|</span><label class="collapse" for="c-38802173">[-]</label><label class="expand" for="c-38802173">[2 more]</label></div><br/><div class="children"><div class="content">How do you know that? Hint: you don’t. You’re not the first to tell us what we do is impossible, and you won’t be the last.<p>By the way, I know how it sounds. And I know why a person would fear it. And, I know why they’d be incorrect in their assessment, because, unlike them, I have significant material experience in both camps.</div><br/><div id="38802348" class="c"><input type="checkbox" id="c-38802348" checked=""/><div class="controls bullet"><span class="by">outsomnia</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38802173">parent</a><span>|</span><a href="#38802728">next</a><span>|</span><label class="collapse" for="c-38802348">[-]</label><label class="expand" for="c-38802348">[1 more]</label></div><br/><div class="children"><div class="content">This whole business has had few conceptual ideas that stand apart from fashion and stood the tests of time.  A lot of people look down on C now for various reasons, but it&#x27;s still extremely useful and going strong 50+ years later.  Even though I&#x27;m older than C itself in the last year or two using it intensively, I found new insights in how to arrange things and what to avoid to make things more robust and maintainable.<p>It&#x27;s not likely that hundreds of &quot;microrepos&quot; on github and even rails are The Last Word that people will eventually converge on and be using into the 2100s.  It sounds like each repo is its own standalone thing with its own deps.  There are advantages and disadvantages to maintaining this kind of thing, some of the disadvantages will only become clear as the deps evolve and mutate.  Although you may feel you are in a local optimum with this architecture in 2023, ahead of the game, energized by your belief in it, you probably are not finished evolving your understanding even on the scale of one or five years.<p>One way or another almost everything in this business is ephemeral, disposable and will be disposed of in favour of something else.</div><br/></div></div></div></div></div></div><div id="38802728" class="c"><input type="checkbox" id="c-38802728" checked=""/><div class="controls bullet"><span class="by">hw</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801914">parent</a><span>|</span><a href="#38802120">prev</a><span>|</span><a href="#38802498">next</a><span>|</span><label class="collapse" for="c-38802728">[-]</label><label class="expand" for="c-38802728">[1 more]</label></div><br/><div class="children"><div class="content">Great that it works for you and your particular project.<p>Without knowing the details if your project and team, I’d take a monolith any day over 400 microrepos and the 70+ backend microservices. Our customers don’t care if it’s microservices or monoliths as long as it works and meets SLAs, so the question really is do I want to upgrade ruby or rails 400 times and deploy 100 services or just do it once in my monolith and deploy once?<p>Need to upgrade a gem that’s used in 100 of those repos to address a CVE - no thanks. Worse, 10 of those repos were owned by someone who left the company a year ago and since there were no PRs, no one knows how to work in the repo or understand what it does.</div><br/></div></div><div id="38802498" class="c"><input type="checkbox" id="c-38802498" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801914">parent</a><span>|</span><a href="#38802728">prev</a><span>|</span><a href="#38802129">next</a><span>|</span><label class="collapse" for="c-38802498">[-]</label><label class="expand" for="c-38802498">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t intend this to be mean, but in some parts this reads as satire.</div><br/></div></div><div id="38802129" class="c"><input type="checkbox" id="c-38802129" checked=""/><div class="controls bullet"><span class="by">irjustin</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801914">parent</a><span>|</span><a href="#38802498">prev</a><span>|</span><a href="#38801821">next</a><span>|</span><label class="collapse" for="c-38802129">[-]</label><label class="expand" for="c-38802129">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the longer writeup, I appreciate it. It&#x27;ll take me some time to digest the concepts.</div><br/><div id="38802180" class="c"><input type="checkbox" id="c-38802180" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38802129">parent</a><span>|</span><a href="#38801821">next</a><span>|</span><label class="collapse" for="c-38802180">[-]</label><label class="expand" for="c-38802180">[1 more]</label></div><br/><div class="children"><div class="content">You are welcome. Feel free to reach out at any time with follow up questions. GitHub discussions are probably easiest, but I’ll try to check here too.</div><br/></div></div></div></div></div></div></div></div><div id="38801821" class="c"><input type="checkbox" id="c-38801821" checked=""/><div class="controls bullet"><span class="by">kamikaz1k</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801774">parent</a><span>|</span><a href="#38801858">prev</a><span>|</span><a href="#38801485">next</a><span>|</span><label class="collapse" for="c-38801821">[-]</label><label class="expand" for="c-38801821">[2 more]</label></div><br/><div class="children"><div class="content">Just to clarify, what are components referring to? Are they independent web services?<p>And what is the total size of the developers you worked with? Are the 12 just your team or the entire engineering org?<p>Edit: found from another comment<p>&gt; We don’t call them microservices, because we aren’t web developers pretending to do architecture and recreating the mistakes of DCOM, CORBA, and Web Services. Most of them are autonomous event sourced components. The others are stand alone web applications that are stitched together with Nginx routing and SSI.</div><br/><div id="38801836" class="c"><input type="checkbox" id="c-38801836" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801821">parent</a><span>|</span><a href="#38801485">next</a><span>|</span><label class="collapse" for="c-38801836">[-]</label><label class="expand" for="c-38801836">[1 more]</label></div><br/><div class="children"><div class="content">Components are either autonomous event sourced back end components (using Eventide) or independent web applications that are combined with Nginx routes and SSI. The UI is (mostly) server-rendered Rails. The users have no idea they are hitting 20 or so different web applications, but the developers sure feel the productivity boost of every application being a small application that is (relatively) independent from one another.<p>A dozen or so is the entire software development organization.<p>Edit: Indeed! If you have any other questions, ask away. Most people think what we do isn&#x27;t actually possible, but it is.</div><br/></div></div></div></div></div></div></div></div><div id="38801485" class="c"><input type="checkbox" id="c-38801485" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801326">parent</a><span>|</span><a href="#38801380">prev</a><span>|</span><a href="#38802270">next</a><span>|</span><label class="collapse" for="c-38801485">[-]</label><label class="expand" for="c-38801485">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d love to be able to separate myself and my team from others by an agreed-upon interface.<p>Don&#x27;t doubt it, but that is what the grandparent was going to - you don&#x27;t want to be held accountable for the success of the overall product, you want a defined contract that you maintain and the value-add of that is someone else&#x27;s problem.<p>The dysfunction of a business is made up of individuals doing what makes the most sense for them locally. It isn&#x27;t unreasonable to want microservices, it just happens that the incentives that make  developers like microservices also tend towards systems that lack accountability for achieving system-level outcomes.</div><br/><div id="38801727" class="c"><input type="checkbox" id="c-38801727" checked=""/><div class="controls bullet"><span class="by">jpk</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801485">parent</a><span>|</span><a href="#38802270">next</a><span>|</span><label class="collapse" for="c-38801727">[-]</label><label class="expand" for="c-38801727">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this precisely what leadership is for?  If you&#x27;ve implemented an architecture that mirrors your org chart, then the interfaces aren&#x27;t just in software, they exist between managers as well.  System-level success depends on the managers and the directors above them to steer the boat in a way that places accountability on the teams and components of the architecture necessary to ship a feature, or whatever.</div><br/><div id="38802714" class="c"><input type="checkbox" id="c-38802714" checked=""/><div class="controls bullet"><span class="by">onion2k</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801727">parent</a><span>|</span><a href="#38802360">next</a><span>|</span><label class="collapse" for="c-38802714">[-]</label><label class="expand" for="c-38802714">[1 more]</label></div><br/><div class="children"><div class="content"><i>Isn&#x27;t this precisely what leadership is for?</i><p>If your devs are just implementing whatever system design is coming from your tech leads, and having no opportunity to have an input or their own, you&#x27;ll find you have very unhappy devs who don&#x27;t hang around very long. That churn will make it impossible to build a decent system.</div><br/></div></div><div id="38802360" class="c"><input type="checkbox" id="c-38802360" checked=""/><div class="controls bullet"><span class="by">kaashif</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801727">parent</a><span>|</span><a href="#38802714">prev</a><span>|</span><a href="#38802270">next</a><span>|</span><label class="collapse" for="c-38802360">[-]</label><label class="expand" for="c-38802360">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you&#x27;ve implemented an architecture that mirrors your org chart<p>In my experience this is almost invariably what happens. I would replace the if with a when.<p>Wow, you&#x27;re telling me our three teams want to write three separate services? No way.<p>And the teams in New York want to use one technology while the teams in San Francisco want to use something else? Say it ain&#x27;t so!</div><br/></div></div></div></div></div></div><div id="38802270" class="c"><input type="checkbox" id="c-38802270" checked=""/><div class="controls bullet"><span class="by">Nextgrid</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801326">parent</a><span>|</span><a href="#38801485">prev</a><span>|</span><a href="#38801568">next</a><span>|</span><label class="collapse" for="c-38802270">[-]</label><label class="expand" for="c-38802270">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d love to be able to separate myself and my team from others by an agreed-upon interface.<p>My experience suggests that speccing out such an interface <i>well</i> is a tremendous amount of work, and if you get it wrong (you most likely will) or if it needs to evolve it will generate lots of work since now it&#x27;s set in stone and very hard to change so you&#x27;re likely going to pay &quot;interest&quot; by working around its shortcomings for the foreseeable future.</div><br/></div></div></div></div><div id="38801568" class="c"><input type="checkbox" id="c-38801568" checked=""/><div class="controls bullet"><span class="by">gedy</span><span>|</span><a href="#38801286">parent</a><span>|</span><a href="#38801326">prev</a><span>|</span><a href="#38802682">next</a><span>|</span><label class="collapse" for="c-38801568">[-]</label><label class="expand" for="c-38801568">[2 more]</label></div><br/><div class="children"><div class="content">The moment you adopt feature teams with feature managers, say goodbye to engineers caring about working infrastructure. Say hello to cross team meetings and project management every time you want to deal with anything platform related.<p>I appreciate you qualified as for startups, but worked with plenty of former startups&#x2F;scaleups that were bogging down rapidly due to infra or scaling issues.  Since they were feature factories, no team or PMs were measured or cared about overall system health.  This includes &quot;majestic monolith&quot; <i>cough</i> stacks with Rails.<p>Adding some services were clear wins and needed for things like external APIs, Auth, reporting, etc. - but this is a far cry from AWS microservice hell for simple UI&#x2F;CRUD features.</div><br/><div id="38802065" class="c"><input type="checkbox" id="c-38802065" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#38801286">root</a><span>|</span><a href="#38801568">parent</a><span>|</span><a href="#38802682">next</a><span>|</span><label class="collapse" for="c-38802065">[-]</label><label class="expand" for="c-38802065">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t ring true for me at all and I&#x27;ve dealt with the dreaded omni-rails stack (or worse the dreaded tomcat springboot stack). Monoliths are far far easier to scale because you have one throat to choke and performance patches &#x2F; elimination of n+1&#x27;s spread across the whole app. Also in a monolith unit tests have the power of integration tests in a microservice world. I can actually be sure the boundaries between components behave as I expect and fail loudly if they change in a manner that breaks me. And the last thing in the world I ever want to do for scaling purposes is stick a network call&#x2F;serialization step between two pieces of my own app because that&#x27;s a bottleneck waiting to happen.<p>It feels like a lot of people reach for microservices when they should be reaching for sharding and&#x2F;or moving to reads to replicas (which you can finally do in Rails thank god).</div><br/></div></div></div></div></div></div><div id="38802682" class="c"><input type="checkbox" id="c-38802682" checked=""/><div class="controls bullet"><span class="by">edandersen</span><span>|</span><a href="#38801286">prev</a><span>|</span><a href="#38801833">next</a><span>|</span><label class="collapse" for="c-38802682">[-]</label><label class="expand" for="c-38802682">[2 more]</label></div><br/><div class="children"><div class="content">Lots of architects &#x2F; tech leads read this instead as: &quot;design the software to fit the maximum team cognitive load <i>that you desire</i>”. They actually over-complicate software builds in order to justify headcount later. &quot;Oh whoops yes we now need a whole full time Ops team, don&#x27;t worry I know just the guys&quot;.</div><br/><div id="38802730" class="c"><input type="checkbox" id="c-38802730" checked=""/><div class="controls bullet"><span class="by">pluto_modadic</span><span>|</span><a href="#38802682">parent</a><span>|</span><a href="#38801833">next</a><span>|</span><label class="collapse" for="c-38802730">[-]</label><label class="expand" for="c-38802730">[1 more]</label></div><br/><div class="children"><div class="content">Kubernetes: because we have cloud engineers and they&#x27;re not busy, right?<p>it&#x27;s not like they could be doing more important things if they weren&#x27;t chasing fires....<p>wait why is my head count soaring...</div><br/></div></div></div></div><div id="38801833" class="c"><input type="checkbox" id="c-38801833" checked=""/><div class="controls bullet"><span class="by">LarsDu88</span><span>|</span><a href="#38802682">prev</a><span>|</span><a href="#38801226">next</a><span>|</span><label class="collapse" for="c-38801833">[-]</label><label class="expand" for="c-38801833">[4 more]</label></div><br/><div class="children"><div class="content">Lets step back a second. If the rationale behind adopting microservices for everything is PURE orgitecture rather than software architecture, then that&#x27;s not really a rationale at all.<p>Instead of having one instance, you now have dozens of little service fiefdoms plus all the added network I&#x2F;O overhead associated with that.<p>The principled approach is really to simply not do that, for the basic latency costs. I mean, did World of Warcraft, which is way more impressive than 99% of all the little django apps out there in corpo world run on a gajillion microservices? Fuck no</div><br/><div id="38802904" class="c"><input type="checkbox" id="c-38802904" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#38801833">parent</a><span>|</span><a href="#38802067">next</a><span>|</span><label class="collapse" for="c-38802904">[-]</label><label class="expand" for="c-38802904">[1 more]</label></div><br/><div class="children"><div class="content">If you follow the authors advice you would be tricked into believing monoliths like Photoshop, Excel or any AAA-game could only have been written by a single team only. That couldn’t be further from the truth. There are like 100 other ways to create interface boundaries than carving out microservices.<p>Microservices is a deployment strategy, not a tool you use to reinforce Conway law, a law that you actually want to defuse more often than follow, to not get your product stuck into your old org chart.</div><br/></div></div><div id="38802067" class="c"><input type="checkbox" id="c-38802067" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38801833">parent</a><span>|</span><a href="#38802904">prev</a><span>|</span><a href="#38801857">next</a><span>|</span><label class="collapse" for="c-38802067">[-]</label><label class="expand" for="c-38802067">[1 more]</label></div><br/><div class="children"><div class="content">Maybe WoW didn&#x27;t run on Microservices, but you can bet the project was divided into a bunch of different fiefdoms. Just they were separated at the interface level rather than the network level. Same concept though.<p>Ultimately if you&#x27;ve got different teams working simultaneously, they should be working on non-conflicting features. Microservice is just one architecture that develops within this constraint. You&#x27;ll never get anywhere if everyone is working on the same interfaces with no separation of concerns. So where should the separation emerge, if not along the same lines as the existing IRL separation? Conway&#x27;s law is not a coincidence; it&#x27;s an inevitability...</div><br/></div></div><div id="38801857" class="c"><input type="checkbox" id="c-38801857" checked=""/><div class="controls bullet"><span class="by">c048</span><span>|</span><a href="#38801833">parent</a><span>|</span><a href="#38802067">prev</a><span>|</span><a href="#38801226">next</a><span>|</span><label class="collapse" for="c-38801857">[-]</label><label class="expand" for="c-38801857">[1 more]</label></div><br/><div class="children"><div class="content">This is what you get when all you talk about it the positives, especially to new programmers or students. It&#x27;s not about the why, but only if you do or do not.<p>I&#x27;ll die on this hill, but DDD can be put right up there with microservices as a solution to a certain type of problem being sold as THE solution.</div><br/></div></div></div></div><div id="38801226" class="c"><input type="checkbox" id="c-38801226" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#38801833">prev</a><span>|</span><a href="#38802447">next</a><span>|</span><label class="collapse" for="c-38801226">[-]</label><label class="expand" for="c-38801226">[15 more]</label></div><br/><div class="children"><div class="content">I used to complain about overly complex software, until I realized the problems themselves were very complex. There was&#x2F;is no way around complexity, and pushing for early simplicity causes more problems than it solves. People need to accept that encoding 1,000 if else statements (software engineering) will be complex no matter how you spin it. Just design the software upfront for what you will need, like a professional. Technical debt more commonly comes from under abstraction rather than too much complexity&#x2F;abstraction.</div><br/><div id="38802818" class="c"><input type="checkbox" id="c-38802818" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#38801226">parent</a><span>|</span><a href="#38802723">next</a><span>|</span><label class="collapse" for="c-38802818">[-]</label><label class="expand" for="c-38802818">[1 more]</label></div><br/><div class="children"><div class="content">You have the terms essential vs accidental complexity for that.<p>Accidental complexity is something you should work hard to avoid. Trying to avoid essential complexity however is a fools errand and if you try, it will result in a deck of cards that only work under perfect conditions.</div><br/></div></div><div id="38802723" class="c"><input type="checkbox" id="c-38802723" checked=""/><div class="controls bullet"><span class="by">Zanfa</span><span>|</span><a href="#38801226">parent</a><span>|</span><a href="#38802818">prev</a><span>|</span><a href="#38801376">next</a><span>|</span><label class="collapse" for="c-38802723">[-]</label><label class="expand" for="c-38802723">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Just design the software upfront for what you will need, like a professional.<p>This is impossible for anything more complex than the simplest of toy examples. Never have I seen a production system where all behaviors and use cases are known, well-defined and correctly documented ahead of (or even after the) implementation in enough detail. That’s just not how people operate.<p>It’s the equivalent of saying everybody should just come together and talk it out to achieve world peace.</div><br/></div></div><div id="38801376" class="c"><input type="checkbox" id="c-38801376" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#38801226">parent</a><span>|</span><a href="#38802723">prev</a><span>|</span><a href="#38801252">next</a><span>|</span><label class="collapse" for="c-38801376">[-]</label><label class="expand" for="c-38801376">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Just design the software upfront for what you will need</i><p>That assumes that you know upfront what you will need and what software design will best meet the need. Sometimes that is the case, but many times it isn&#x27;t. Different strategies are needed to deal with the latter case.</div><br/><div id="38801430" class="c"><input type="checkbox" id="c-38801430" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#38801226">root</a><span>|</span><a href="#38801376">parent</a><span>|</span><a href="#38801252">next</a><span>|</span><label class="collapse" for="c-38801430">[-]</label><label class="expand" for="c-38801430">[3 more]</label></div><br/><div class="children"><div class="content">If you need flexibility for unknowns, design for that.  Specialize as the requirements become more clear.</div><br/><div id="38801580" class="c"><input type="checkbox" id="c-38801580" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#38801226">root</a><span>|</span><a href="#38801430">parent</a><span>|</span><a href="#38801252">next</a><span>|</span><label class="collapse" for="c-38801580">[-]</label><label class="expand" for="c-38801580">[2 more]</label></div><br/><div class="children"><div class="content">That assumes that you know the unknowns and how to design for the flexibility you will need. That won&#x27;t always be the case. Sometimes you just have to accept the fact that you don&#x27;t know enough up front to make a good design, so your initial efforts need to be focused at gaining the information you need, for example by prototyping to get user feedback knowing that you will probably throw some prototypes away, not making design decisions up front that you don&#x27;t have the information to make.</div><br/><div id="38802279" class="c"><input type="checkbox" id="c-38802279" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#38801226">root</a><span>|</span><a href="#38801580">parent</a><span>|</span><a href="#38801252">next</a><span>|</span><label class="collapse" for="c-38802279">[-]</label><label class="expand" for="c-38802279">[1 more]</label></div><br/><div class="children"><div class="content">We agree.  I just phrased it as design and plan for project flexibility, not design a bunch of knobs strictly for every case you happen to know about at some snapshot in time.<p>I say design and not just plan because you&#x27;ll want to mock out or prototype something to show and that does take design work to keep your iteration cadence high.<p>In my mind flexible means easy to iterate on but maybe that is not clear.</div><br/></div></div></div></div></div></div></div></div><div id="38801252" class="c"><input type="checkbox" id="c-38801252" checked=""/><div class="controls bullet"><span class="by">imachine1980_</span><span>|</span><a href="#38801226">parent</a><span>|</span><a href="#38801376">prev</a><span>|</span><a href="#38801269">next</a><span>|</span><label class="collapse" for="c-38801252">[-]</label><label class="expand" for="c-38801252">[3 more]</label></div><br/><div class="children"><div class="content">i work in legacy code over abstraction gives more headaches than having to check manually when you need to change the software and the person who write it isn&#x27;t in the company in the last five years, because the software is full of constrains that you don&#x27;t known, and when you need to change something basic the whole software collapse(because of the interdependence of the componentes).</div><br/><div id="38801261" class="c"><input type="checkbox" id="c-38801261" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#38801226">root</a><span>|</span><a href="#38801252">parent</a><span>|</span><a href="#38801269">next</a><span>|</span><label class="collapse" for="c-38801261">[-]</label><label class="expand" for="c-38801261">[2 more]</label></div><br/><div class="children"><div class="content">Right but thats just bad programming. If they had used no abstraction it would also be a nightmare.</div><br/><div id="38801317" class="c"><input type="checkbox" id="c-38801317" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#38801226">root</a><span>|</span><a href="#38801261">parent</a><span>|</span><a href="#38801269">next</a><span>|</span><label class="collapse" for="c-38801317">[-]</label><label class="expand" for="c-38801317">[1 more]</label></div><br/><div class="children"><div class="content">Rememeber: Having no abstraction is better than the wrong abstraction.</div><br/></div></div></div></div></div></div><div id="38801269" class="c"><input type="checkbox" id="c-38801269" checked=""/><div class="controls bullet"><span class="by">jahewson</span><span>|</span><a href="#38801226">parent</a><span>|</span><a href="#38801252">prev</a><span>|</span><a href="#38801285">next</a><span>|</span><label class="collapse" for="c-38801269">[-]</label><label class="expand" for="c-38801269">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Just design the software upfront<p>We call that waterfall :)</div><br/><div id="38801341" class="c"><input type="checkbox" id="c-38801341" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#38801226">root</a><span>|</span><a href="#38801269">parent</a><span>|</span><a href="#38801295">next</a><span>|</span><label class="collapse" for="c-38801341">[-]</label><label class="expand" for="c-38801341">[1 more]</label></div><br/><div class="children"><div class="content">No its called software engineering</div><br/></div></div><div id="38801295" class="c"><input type="checkbox" id="c-38801295" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801226">root</a><span>|</span><a href="#38801269">parent</a><span>|</span><a href="#38801341">prev</a><span>|</span><a href="#38801285">next</a><span>|</span><label class="collapse" for="c-38801295">[-]</label><label class="expand" for="c-38801295">[1 more]</label></div><br/><div class="children"><div class="content">No, we don’t.</div><br/></div></div></div></div><div id="38801285" class="c"><input type="checkbox" id="c-38801285" checked=""/><div class="controls bullet"><span class="by">malfist</span><span>|</span><a href="#38801226">parent</a><span>|</span><a href="#38801269">prev</a><span>|</span><a href="#38802447">next</a><span>|</span><label class="collapse" for="c-38801285">[-]</label><label class="expand" for="c-38801285">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a balance to strike, right? Some complexity is just for complexity&#x27;s sake, or out of inexperience or incompetence. But yeah, a lot of it is that the real world is complicated. That&#x27;s convoluted code is solving for a bug an engineer was woken up at night for.<p>And it can be really hard to tell the difference</div><br/><div id="38801343" class="c"><input type="checkbox" id="c-38801343" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#38801226">root</a><span>|</span><a href="#38801285">parent</a><span>|</span><a href="#38802447">next</a><span>|</span><label class="collapse" for="c-38801343">[-]</label><label class="expand" for="c-38801343">[1 more]</label></div><br/><div class="children"><div class="content">People just get burned by bad programmers. So they make up all these rules to safe guard against them. Its not abstraction thats the problem, its low quality engineers.</div><br/></div></div></div></div></div></div><div id="38802447" class="c"><input type="checkbox" id="c-38802447" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#38801226">prev</a><span>|</span><a href="#38801283">next</a><span>|</span><label class="collapse" for="c-38802447">[-]</label><label class="expand" for="c-38802447">[1 more]</label></div><br/><div class="children"><div class="content">I totally agree... the real question is how to reduce cognitive load. Try to get a system that can fit in your head, although I have totally failed to achieve this myself. But it is a goal!</div><br/></div></div><div id="38801283" class="c"><input type="checkbox" id="c-38801283" checked=""/><div class="controls bullet"><span class="by">mariodiana</span><span>|</span><a href="#38802447">prev</a><span>|</span><a href="#38801151">next</a><span>|</span><label class="collapse" for="c-38801283">[-]</label><label class="expand" for="c-38801283">[3 more]</label></div><br/><div class="children"><div class="content">“[D]esign the software to fit the maximum team cognitive load.”<p>I see. So, RAID drives, failover servers for redundancy, and generators (or at least UPS batteries) for power — but push your team to their maximum load.</div><br/><div id="38801337" class="c"><input type="checkbox" id="c-38801337" checked=""/><div class="controls bullet"><span class="by">guhcampos</span><span>|</span><a href="#38801283">parent</a><span>|</span><a href="#38801151">next</a><span>|</span><label class="collapse" for="c-38801337">[-]</label><label class="expand" for="c-38801337">[2 more]</label></div><br/><div class="children"><div class="content">Might be a bit of a wording thing, because I think I got it very differently than you.<p>To me, that sounds like &quot;you can&#x27;t design for a higher cognitive load than what your team can absorb&quot; - and not &quot;try to optimize the cognitive load dor the maximum your team can absorb&quot;.</div><br/><div id="38801420" class="c"><input type="checkbox" id="c-38801420" checked=""/><div class="controls bullet"><span class="by">slabity</span><span>|</span><a href="#38801283">root</a><span>|</span><a href="#38801337">parent</a><span>|</span><a href="#38801151">next</a><span>|</span><label class="collapse" for="c-38801420">[-]</label><label class="expand" for="c-38801420">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like it should have been worded like, &quot;Minimize cognitive load to maximize team effectiveness&quot;<p>The original wording sounds like could go both ways, so I understand why the person you&#x27;re responding to sees it that way.</div><br/></div></div></div></div></div></div><div id="38801151" class="c"><input type="checkbox" id="c-38801151" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38801283">prev</a><span>|</span><a href="#38801164">next</a><span>|</span><label class="collapse" for="c-38801151">[-]</label><label class="expand" for="c-38801151">[1 more]</label></div><br/><div class="children"><div class="content">Cognitive load is one good dimension to think about here. I like that it is a human concern. There are probably multiple.<p>What I think is challenging is figuring out what the teams should be - this can be more complex than it appears. Do you have an &quot;auth team&quot; for example? How do you ensure the people in that team are happy that their CV is going to be &quot;done auth for 2 years&quot; when they next do their job.<p>For small companies you might have micro teams, where there are 0.1 members on that team - I.e. it is at the point of part of someone&#x27;s role. But treating it like it&#x27;s own team (it get&#x27;s own repo(s)) might make sense.</div><br/></div></div><div id="38801164" class="c"><input type="checkbox" id="c-38801164" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#38801151">prev</a><span>|</span><a href="#38801510">next</a><span>|</span><label class="collapse" for="c-38801164">[-]</label><label class="expand" for="c-38801164">[1 more]</label></div><br/><div class="children"><div class="content">I think a revisit of Conway&#x27;s paper[1] might be appropriate. Between that, and the recent talk by Kevlin Henney about architecture[2], you&#x27;ll be in far better shape to make such decisions.<p>[1] <a href="https:&#x2F;&#x2F;www.melconway.com&#x2F;Home&#x2F;Committees_Paper.html" rel="nofollow">https:&#x2F;&#x2F;www.melconway.com&#x2F;Home&#x2F;Committees_Paper.html</a><p>[2] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aCK-Pu80EEs" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=aCK-Pu80EEs</a></div><br/></div></div><div id="38801510" class="c"><input type="checkbox" id="c-38801510" checked=""/><div class="controls bullet"><span class="by">LASR</span><span>|</span><a href="#38801164">prev</a><span>|</span><a href="#38802588">next</a><span>|</span><label class="collapse" for="c-38801510">[-]</label><label class="expand" for="c-38801510">[2 more]</label></div><br/><div class="children"><div class="content">The single-most important lesson I&#x27;ve learned building products as a founding engineer in a successfully exited startup: weighing tradeoffs and deciding which software architecture to use is the wrong place to dedicate mental energy.<p>It&#x27;s always the product. It comes first. Then the business. If you&#x27;re lucky you may become a pawn in a larger battle among giants and you&#x27;ll get acquired before you attempt to make any profit.<p>If you end up in a place where your chosen architecture is no longer capable of supporting your scale - that&#x27;s a happy place that very few teams get to experience. It means you&#x27;ve survived.<p>Given that, whatever allows you to quickly get things in the hands of real customers (which depends quite heavily on what the actual product is) is the best architecture.<p>We&#x27;ve hired some experienced engineers from giga-corp FAANG etc into tiny startups. The transition is hard, because there the opposite is true. You have a business already, and you have a well-defined goal you need to achieve with multi-year roadmaps etc. There, yeah you should probably decide on architecture first.</div><br/><div id="38802567" class="c"><input type="checkbox" id="c-38802567" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#38801510">parent</a><span>|</span><a href="#38802588">next</a><span>|</span><label class="collapse" for="c-38802567">[-]</label><label class="expand" for="c-38802567">[1 more]</label></div><br/><div class="children"><div class="content">Sad to see this isn&#x27;t the top comment. Unless or until you have a built-in source of guaranteed demand - the only thing that matters is product agility in order to find customer demand. Without demand, you have no revenue, investors lose interest, the money runs out, and people stop paying you to work on that system. Then everything gets thrown out. And &quot;demand&quot; is not &quot;we have paying customers&quot; - it&#x27;s having sufficient revenue, for whatever that means for that particular org.</div><br/></div></div></div></div><div id="38802588" class="c"><input type="checkbox" id="c-38802588" checked=""/><div class="controls bullet"><span class="by">konschubert</span><span>|</span><a href="#38801510">prev</a><span>|</span><a href="#38801211">next</a><span>|</span><label class="collapse" for="c-38802588">[-]</label><label class="expand" for="c-38802588">[3 more]</label></div><br/><div class="children"><div class="content">It’s hard to enforce api contracts between components of a monolith.<p>And when performance tanks, it’s hard to pin the root cause to a component.<p>Both of these could probably be fixed by tooling. Could be z as fun research project or maybe a company.</div><br/><div id="38802636" class="c"><input type="checkbox" id="c-38802636" checked=""/><div class="controls bullet"><span class="by">karlmdavis</span><span>|</span><a href="#38802588">parent</a><span>|</span><a href="#38801211">next</a><span>|</span><label class="collapse" for="c-38802636">[-]</label><label class="expand" for="c-38802636">[2 more]</label></div><br/><div class="children"><div class="content">You and I must work in very different contexts, as these questions are so obvious that they first seemed like satire to me.<p>You enforce API contracts in a monolith (or any codebase, really) via an at-least-modest amount of typing and a compiler. You diagnose performance issues via any number of tools, prominently including metrics and profilers.<p>My context for this is a lot of years working with backend languages like Java, Rust, etc. though the same assurances and tooling are available for most every platform I’m aware of.</div><br/><div id="38802789" class="c"><input type="checkbox" id="c-38802789" checked=""/><div class="controls bullet"><span class="by">konschubert</span><span>|</span><a href="#38802588">root</a><span>|</span><a href="#38802636">parent</a><span>|</span><a href="#38801211">next</a><span>|</span><label class="collapse" for="c-38802789">[-]</label><label class="expand" for="c-38802789">[1 more]</label></div><br/><div class="children"><div class="content">Sure… and then the type of the return object if of API is<p>‘CustomerORMModel’… and now the api consumer can build n+1 query problems across components.<p>You need a few more restrictions than that. But I agree it’s doable.</div><br/></div></div></div></div></div></div><div id="38801211" class="c"><input type="checkbox" id="c-38801211" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38802588">prev</a><span>|</span><a href="#38801581">next</a><span>|</span><label class="collapse" for="c-38801211">[-]</label><label class="expand" for="c-38801211">[7 more]</label></div><br/><div class="children"><div class="content">It’s hard to imagine worse advice. Software design principles lead you to good architecture. Focus on autonomy, proper partitioning, and sound design and you get what you get. If you target monoliths out of some misguided attempt to reduce cognitive load, you will only create unnecessary entanglement. If you try to target “microservices” with N services per team or other arbitrary target, you will end up missing boundaries you should realize or introducing ones you shouldn’t.<p>There is no instant pudding.</div><br/><div id="38801246" class="c"><input type="checkbox" id="c-38801246" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801211">parent</a><span>|</span><a href="#38801581">next</a><span>|</span><label class="collapse" for="c-38801246">[-]</label><label class="expand" for="c-38801246">[6 more]</label></div><br/><div class="children"><div class="content">Just read the author’s bio. This is a person that appears to have zero software design experience writing an article telling you to ignore software design and just respect your team configuration. I call this Conway’s Confusion.</div><br/><div id="38801264" class="c"><input type="checkbox" id="c-38801264" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38801211">root</a><span>|</span><a href="#38801246">parent</a><span>|</span><a href="#38801581">next</a><span>|</span><label class="collapse" for="c-38801264">[-]</label><label class="expand" for="c-38801264">[5 more]</label></div><br/><div class="children"><div class="content">The entire purpose of microservices is to comply with Conway.</div><br/><div id="38801287" class="c"><input type="checkbox" id="c-38801287" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801211">root</a><span>|</span><a href="#38801264">parent</a><span>|</span><a href="#38801268">next</a><span>|</span><label class="collapse" for="c-38801287">[-]</label><label class="expand" for="c-38801287">[1 more]</label></div><br/><div class="children"><div class="content">Source: I lead a team of a dozen or so and we have over 100 deployed components. We don’t call them microservices, because we aren’t web developers pretending to do architecture and recreating the mistakes of DCOM, CORBA, and Web Services. Most of them are autonomous event sourced components. The others are stand alone web applications that are stitched together with Nginx routing and SSI. The user has no idea they are interacting with 100 apps, but the devs sure do.</div><br/></div></div><div id="38801268" class="c"><input type="checkbox" id="c-38801268" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801211">root</a><span>|</span><a href="#38801264">parent</a><span>|</span><a href="#38801287">prev</a><span>|</span><a href="#38801581">next</a><span>|</span><label class="collapse" for="c-38801268">[-]</label><label class="expand" for="c-38801268">[3 more]</label></div><br/><div class="children"><div class="content">This is wrong. That&#x27;s not how Conway&#x27;s Law works. It’s also not how software design works. But please, by all means, continue to spread disinformation and keep us in the dark ages.</div><br/><div id="38801352" class="c"><input type="checkbox" id="c-38801352" checked=""/><div class="controls bullet"><span class="by">guhcampos</span><span>|</span><a href="#38801211">root</a><span>|</span><a href="#38801268">parent</a><span>|</span><a href="#38801581">next</a><span>|</span><label class="collapse" for="c-38801352">[-]</label><label class="expand" for="c-38801352">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree completely with the comment, but I would possibly change it from &quot;comply with Conway&quot; tô &quot;embrace Conway&quot;.</div><br/><div id="38801760" class="c"><input type="checkbox" id="c-38801760" checked=""/><div class="controls bullet"><span class="by">hmeh</span><span>|</span><a href="#38801211">root</a><span>|</span><a href="#38801352">parent</a><span>|</span><a href="#38801581">next</a><span>|</span><label class="collapse" for="c-38801760">[-]</label><label class="expand" for="c-38801760">[1 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t disagree, then I assume you have a strong understanding of structural design. I assume that you recognize that Conway&#x27;s law is more of a curse, and a warning than it is something to embrace. I assume that you recognize that the only possible way to &quot;embrace conway&#x27;s law&quot; and simultaneously recognize structural design would be to constantly be firing or otherwise disbanding entire teams as components get completed (components that likely won&#x27;t need to be touched frequently because they were designed for a single reason to change). I assume all of that makes perfect sense to you. Yes?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38801581" class="c"><input type="checkbox" id="c-38801581" checked=""/><div class="controls bullet"><span class="by">hiddencost</span><span>|</span><a href="#38801211">prev</a><span>|</span><a href="#38801377">next</a><span>|</span><label class="collapse" for="c-38801581">[-]</label><label class="expand" for="c-38801581">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve read a lot of these arguments.<p>I dunno, I think software engineers have neglected soft skills for too long.<p>&quot;Philosophy X always leads to Y outcome.&quot;<p>&quot;Framework Z does Q.&quot;<p>I bet a lot of software engineers are just bad with people. Coordinating a dozen teams takes work, but people do it all the time successfully.<p>I don&#x27;t think the frameworks are as important as figuring out an approach that works for the people involved.</div><br/><div id="38801638" class="c"><input type="checkbox" id="c-38801638" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#38801581">parent</a><span>|</span><a href="#38801377">next</a><span>|</span><label class="collapse" for="c-38801638">[-]</label><label class="expand" for="c-38801638">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure one of the things that keeps me employed in software is that I&#x27;m good at non-software stuff. So much so that I focus quite a bit less on the software now, and a lot more on the things software does, why, and for whom. That stuff seems a lot more important in the scheme of things; especially when money isn&#x27;t free and people need software to be truly useful and very immediately.<p>Maybe that&#x27;s a typical progression in most software careers, but I wouldn&#x27;t have believed I&#x27;d be here 10 years ago, or maybe even 5. I was always very technical (and I still love that side of things). Now I see the people side of things as far more important and interesting.</div><br/></div></div></div></div><div id="38801377" class="c"><input type="checkbox" id="c-38801377" checked=""/><div class="controls bullet"><span class="by">vvpan</span><span>|</span><a href="#38801581">prev</a><span>|</span><a href="#38801199">next</a><span>|</span><label class="collapse" for="c-38801377">[-]</label><label class="expand" for="c-38801377">[2 more]</label></div><br/><div class="children"><div class="content">Whether it is a function, class, module, application or service I think there is one word for it - encapsulation.</div><br/><div id="38801421" class="c"><input type="checkbox" id="c-38801421" checked=""/><div class="controls bullet"><span class="by">apantel</span><span>|</span><a href="#38801377">parent</a><span>|</span><a href="#38801199">next</a><span>|</span><label class="collapse" for="c-38801421">[-]</label><label class="expand" for="c-38801421">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I would think that the solution to monolith vs microservices would be “neither should be followed because of dogma; encapsulate where it makes sense, when it makes sense”.</div><br/></div></div></div></div><div id="38801199" class="c"><input type="checkbox" id="c-38801199" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#38801377">prev</a><span>|</span><a href="#38801256">next</a><span>|</span><label class="collapse" for="c-38801199">[-]</label><label class="expand" for="c-38801199">[8 more]</label></div><br/><div class="children"><div class="content">The sad thing about these &quot;monolith vs microservice&quot; debates is that to this day we have programming languages which favor shared mutable state, so a program written like this is an absolute hell (or a very leaky abstraction) to distribute. And it doesn&#x27;t have to be like this.<p>Think about it. When your variable is a simple value, like a number or a string or a struct, we treat it as pass-by-copy (even if copy-on-write optimized), typically stack allocated. Remote IO is also pass-by-copy. But in-between those two levels, we have this intermediate pointer&#x2F;handle hell of mutable shared state that the C family of languages promote, both procedural and OOP variety.<p>The original OOP definition is closer to the Actor model which has by-copy messages, but the actual OOP languages we use, like C++, Java, C# all derive philosophically from the way C handles entities on the heap, as this big shared local space you have immediate access to, and can pass around pointers to.<p>And that&#x27;s where all our problems come from. This concept doesn&#x27;t scale. Neither in terms of larger codebases. Nor in terms of distributing an application. It doesn&#x27;t also scale cognitively, which the article mentions, but doesn&#x27;t quite address in this context.</div><br/><div id="38802089" class="c"><input type="checkbox" id="c-38802089" checked=""/><div class="controls bullet"><span class="by">the_gipsy</span><span>|</span><a href="#38801199">parent</a><span>|</span><a href="#38801390">next</a><span>|</span><label class="collapse" for="c-38802089">[-]</label><label class="expand" for="c-38802089">[2 more]</label></div><br/><div class="children"><div class="content">They are a constant sources of bugs, but it&#x27;s not really an architecture matter.</div><br/><div id="38802683" class="c"><input type="checkbox" id="c-38802683" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#38801199">root</a><span>|</span><a href="#38802089">parent</a><span>|</span><a href="#38801390">next</a><span>|</span><label class="collapse" for="c-38802683">[-]</label><label class="expand" for="c-38802683">[1 more]</label></div><br/><div class="children"><div class="content">It is because that&#x27;s literally an architectural choice which prevents you from easily moving out a module from your &quot;monolith&quot; to another machine on the network, and causes the bugs.<p>The language &amp; memory architecture... are an architecture matter.</div><br/></div></div></div></div><div id="38801390" class="c"><input type="checkbox" id="c-38801390" checked=""/><div class="controls bullet"><span class="by">alexalx666</span><span>|</span><a href="#38801199">parent</a><span>|</span><a href="#38802089">prev</a><span>|</span><a href="#38802077">next</a><span>|</span><label class="collapse" for="c-38801390">[-]</label><label class="expand" for="c-38801390">[2 more]</label></div><br/><div class="children"><div class="content">The tradeoffs are great if you are mindful</div><br/><div id="38802710" class="c"><input type="checkbox" id="c-38802710" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#38801199">root</a><span>|</span><a href="#38801390">parent</a><span>|</span><a href="#38802077">next</a><span>|</span><label class="collapse" for="c-38802710">[-]</label><label class="expand" for="c-38802710">[1 more]</label></div><br/><div class="children"><div class="content">Tradeoffs of?</div><br/></div></div></div></div><div id="38802077" class="c"><input type="checkbox" id="c-38802077" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38801199">parent</a><span>|</span><a href="#38801390">prev</a><span>|</span><a href="#38801256">next</a><span>|</span><label class="collapse" for="c-38802077">[-]</label><label class="expand" for="c-38802077">[3 more]</label></div><br/><div class="children"><div class="content">Something I’ve wanted for a while now is a language &#x2F; framework that behaves like networked micro services but without the network overheads.<p>E.g.: the default hosting model might be to have all of the services in a single process with pass-by-copy messages. One could even have multiple instances of a service pinned to CPU cores, with hash-based load balancing so that L2 and L3 caches could be efficiently utilised.<p>The “next tier” could be a multi-process host with shared memory. E.g.: there could be permanent “queue” and “cache” services coupled to ephemeral Web and API services. That way, each “app” could be independently deployed and restarts wouldn’t blow away terabytes of built up cache &#x2F; state. One could even have different programming languages!<p>Last but not least, scale out clusters ought to use RDMA instead of horrifically inefficient JSON-over-HTTPS.<p>Ideally, the exact same code ought to scale to all three hosting paradigms without a rewrite (but perhaps a recompile).<p>Some platforms almost-but-not-quite work this way, such as EJB hosts — they can short circuit networking for local calls. However they’re not truly polyglot as they don’t support non-JVM languages. Similarly Service Fabric has some local-host optimisations but they’re special cases. Kubernetes is polyglot but doesn’t use shared memory and has no single-process mode.</div><br/><div id="38802732" class="c"><input type="checkbox" id="c-38802732" checked=""/><div class="controls bullet"><span class="by">stevedonovan</span><span>|</span><a href="#38801199">root</a><span>|</span><a href="#38802077">parent</a><span>|</span><a href="#38802686">next</a><span>|</span><label class="collapse" for="c-38802732">[-]</label><label class="expand" for="c-38802732">[1 more]</label></div><br/><div class="children"><div class="content">Yes, same feeling I had, but with dual mode; can be compiled as a &#x27;standalone&#x27; service over HTTP&#x2F;REST (or whatever) and _also_ compiled as a classic module with a strictly defined interface.<p>One cool thing about standalone services which needs to be factored in is that they can be spun up and debugged very easily. But for deployment, we pay for all the network latency&#x2F;marshaling overhead, and coordination complexity.<p>So, best of both worlds? As for polyglot, there does have to be a shared platform (C ABI, JVM, etc). (Go doesn&#x27;t play so nicely with other languages due to goroutine stack allocation.)</div><br/></div></div><div id="38802686" class="c"><input type="checkbox" id="c-38802686" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#38801199">root</a><span>|</span><a href="#38802077">parent</a><span>|</span><a href="#38802732">prev</a><span>|</span><a href="#38801256">next</a><span>|</span><label class="collapse" for="c-38802686">[-]</label><label class="expand" for="c-38802686">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m working on a language that&#x27;s like it. But my esoteric stuff aside, the closest production system we have like that is Erlang (and Elixir, if it&#x27;s your thing).</div><br/></div></div></div></div></div></div><div id="38801256" class="c"><input type="checkbox" id="c-38801256" checked=""/><div class="controls bullet"><span class="by">dilawar</span><span>|</span><a href="#38801199">prev</a><span>|</span><a href="#38801162">next</a><span>|</span><label class="collapse" for="c-38801256">[-]</label><label class="expand" for="c-38801256">[1 more]</label></div><br/><div class="children"><div class="content">Some decent pointers that one can keep in mind as rule of thumb. Would love to read some comments that says hey we tried exactly the same but...</div><br/></div></div><div id="38801162" class="c"><input type="checkbox" id="c-38801162" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#38801256">prev</a><span>|</span><a href="#38802068">next</a><span>|</span><label class="collapse" for="c-38801162">[-]</label><label class="expand" for="c-38801162">[7 more]</label></div><br/><div class="children"><div class="content">We can’t measure cognitive load though. Or if we can, no one knows a way to apply that to software projects.</div><br/><div id="38801206" class="c"><input type="checkbox" id="c-38801206" checked=""/><div class="controls bullet"><span class="by">aikiplayer</span><span>|</span><a href="#38801162">parent</a><span>|</span><a href="#38801187">next</a><span>|</span><label class="collapse" for="c-38801206">[-]</label><label class="expand" for="c-38801206">[4 more]</label></div><br/><div class="children"><div class="content">We might not be able to quantitatively measure it but we can run studies to evaluate what individuals and teams can handle.  Human factors people do this and it’s a sub field in industrial engineering.  The military runs these studies and I’d imagine air traffic controllers do them as well, etc.  You sometimes get really surprising results.</div><br/><div id="38801332" class="c"><input type="checkbox" id="c-38801332" checked=""/><div class="controls bullet"><span class="by">lenerdenator</span><span>|</span><a href="#38801162">root</a><span>|</span><a href="#38801206">parent</a><span>|</span><a href="#38801187">next</a><span>|</span><label class="collapse" for="c-38801332">[-]</label><label class="expand" for="c-38801332">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s something I&#x27;ve noticed: the way we treat systems developed to work on data is _completely_ different from systems developed to work on, idk, oil.<p>You can build data refineries (ETF) same as an oil refinery. The difference is, the engineers who build the oil refinery create manuals and standard operating procedures to operate the refinery, because if they don&#x27;t, then the new board operator will press the wrong button and blow out every window in a five-mile radius.<p>When you build a data refinery, no one documents _anything_ no matter how many times you ask engineers on the team to do it. Will it blow up in a massive fireball if you do it wrong? No, but it will corrupt data and have a business consequence. You can keep the 40 different microservices for the data refinery in your head though, right?</div><br/><div id="38801429" class="c"><input type="checkbox" id="c-38801429" checked=""/><div class="controls bullet"><span class="by">pixl97</span><span>|</span><a href="#38801162">root</a><span>|</span><a href="#38801332">parent</a><span>|</span><a href="#38801187">next</a><span>|</span><label class="collapse" for="c-38801429">[-]</label><label class="expand" for="c-38801429">[2 more]</label></div><br/><div class="children"><div class="content">Oil refineries don&#x27;t have backup restore points.</div><br/><div id="38801503" class="c"><input type="checkbox" id="c-38801503" checked=""/><div class="controls bullet"><span class="by">lenerdenator</span><span>|</span><a href="#38801162">root</a><span>|</span><a href="#38801429">parent</a><span>|</span><a href="#38801187">next</a><span>|</span><label class="collapse" for="c-38801503">[-]</label><label class="expand" for="c-38801503">[1 more]</label></div><br/><div class="children"><div class="content">Depending on what exactly it is that you&#x27;re storing or processing, neither does data.<p>Think sensor data and the sensor is a vital signs monitor in a hospital. The service that reads its output and stores it glitches out due to some sort of misclick by a user. It distorts the fact that the patient has an arrhythmia. Or a service that reads off the medication dosages for a patient for a pharmacist is stuck on a single message.</div><br/></div></div></div></div></div></div></div></div><div id="38801187" class="c"><input type="checkbox" id="c-38801187" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#38801162">parent</a><span>|</span><a href="#38801206">prev</a><span>|</span><a href="#38802068">next</a><span>|</span><label class="collapse" for="c-38801187">[-]</label><label class="expand" for="c-38801187">[2 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t and shouldn&#x27;t try to. We can however qualitatively try to see where the wind is blowing.</div><br/><div id="38801208" class="c"><input type="checkbox" id="c-38801208" checked=""/><div class="controls bullet"><span class="by">MichaelZuo</span><span>|</span><a href="#38801162">root</a><span>|</span><a href="#38801187">parent</a><span>|</span><a href="#38802068">next</a><span>|</span><label class="collapse" for="c-38801208">[-]</label><label class="expand" for="c-38801208">[1 more]</label></div><br/><div class="children"><div class="content">How does someone verify their understanding is correct then?</div><br/></div></div></div></div></div></div><div id="38802068" class="c"><input type="checkbox" id="c-38802068" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#38801162">prev</a><span>|</span><a href="#38801097">next</a><span>|</span><label class="collapse" for="c-38802068">[-]</label><label class="expand" for="c-38802068">[1 more]</label></div><br/><div class="children"><div class="content">I feel like we are going to spend many years coping with <i>Team Topologies</i>, a book which idolizes a seeming infinite and vast independence of teams from each other in the name of &#x27;spending things up&#x27; or some such.<p>I love, respect, &amp; cherish the ideas here. But the sound-bite ideas of the book vastly overweigh the practical complexities of development.<p>Yeah, giving each team authority to do their thing is desperately necessary today; there&#x27;s too much organizational confusion &amp; unclear decision making processes. Teams need autonomy. Yes. But the book really seems to have so little to say about how to play together. It doesn&#x27;t talk hardly at all about how to find concordance &amp; to make decisions across teams. What are good common techs to adopt? Microservices as I&#x27;m everyone can pick whatever (Haskell for this, pho for that, &amp; 12 varieties of node) is one organizational end, monolith is another end. The confusion and angst <i>Team Topologies</i> let&#x27;s dwell and build is infinite, because it&#x27;s pretense is that there are many parallel streams of development and that inter-team work is a negative.<p>The books is so good and so important. Because so many orgs are fucked and doing things terribly. Cognitive load is massively over managed and it&#x27;s impossible to do anything to escape the tar pit the shitty ancient overly established pretentious shitbag elders have dictated. But the result of what <i>Team Topologies</i> says is such an opposite and shitty fucked, where cognitive loads expand exponentially because every team is independent &amp; fucking off into their own space, with only vague constraining behavior or nebulous &quot;platform&quot; teams that &quot;support&quot; or maybe dictate to these platforms teams.<p>Never have I seen a book I both respect so highly &amp; think so terrible &amp; awful.</div><br/></div></div><div id="38801097" class="c"><input type="checkbox" id="c-38801097" checked=""/><div class="controls bullet"><span class="by">bobobob420</span><span>|</span><a href="#38802068">prev</a><span>|</span><label class="collapse" for="c-38801097">[-]</label><label class="expand" for="c-38801097">[6 more]</label></div><br/><div class="children"><div class="content">How do you get to third on hn with 8 points and 0 comments in 2 hours?</div><br/><div id="38801143" class="c"><input type="checkbox" id="c-38801143" checked=""/><div class="controls bullet"><span class="by">simlevesque</span><span>|</span><a href="#38801097">parent</a><span>|</span><a href="#38801234">next</a><span>|</span><label class="collapse" for="c-38801143">[-]</label><label class="expand" for="c-38801143">[3 more]</label></div><br/><div class="children"><div class="content">By being the new post with the most points and  comments in 2 hours.<p>If another post would was more recent and had more points it would be higher.<p>These posts get a temporary boost but if the points stay the same while being at the top, it&#x27;ll disappear pretty soon.</div><br/><div id="38801154" class="c"><input type="checkbox" id="c-38801154" checked=""/><div class="controls bullet"><span class="by">quickthrower2</span><span>|</span><a href="#38801097">root</a><span>|</span><a href="#38801143">parent</a><span>|</span><a href="#38801207">next</a><span>|</span><label class="collapse" for="c-38801154">[-]</label><label class="expand" for="c-38801154">[1 more]</label></div><br/><div class="children"><div class="content">I suspect #points is the main factor. And the algorithm wants to surface fresh stuff, otherwise we&#x27;d still all be talking about Sam Altman. Glad we aren&#x27;t :-) (nothing against Sam...)</div><br/></div></div><div id="38801207" class="c"><input type="checkbox" id="c-38801207" checked=""/><div class="controls bullet"><span class="by">bobobob420</span><span>|</span><a href="#38801097">root</a><span>|</span><a href="#38801143">parent</a><span>|</span><a href="#38801154">prev</a><span>|</span><a href="#38801234">next</a><span>|</span><label class="collapse" for="c-38801207">[-]</label><label class="expand" for="c-38801207">[1 more]</label></div><br/><div class="children"><div class="content">Seems pretty easy to bot. Its also a personal blog which adds to suspicion. There is also a new trend which is trying to get on hackernews front page</div><br/></div></div></div></div><div id="38801234" class="c"><input type="checkbox" id="c-38801234" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#38801097">parent</a><span>|</span><a href="#38801143">prev</a><span>|</span><a href="#38801126">next</a><span>|</span><label class="collapse" for="c-38801234">[-]</label><label class="expand" for="c-38801234">[1 more]</label></div><br/><div class="children"><div class="content">Someone at ycombinator boosts and deranks posts. I see it all the time.</div><br/></div></div><div id="38801126" class="c"><input type="checkbox" id="c-38801126" checked=""/><div class="controls bullet"><span class="by">bobobob420</span><span>|</span><a href="#38801097">parent</a><span>|</span><a href="#38801234">prev</a><span>|</span><label class="collapse" for="c-38801126">[-]</label><label class="expand" for="c-38801126">[1 more]</label></div><br/><div class="children"><div class="content">Now second</div><br/></div></div></div></div></div></div></div></div></div></body></html>