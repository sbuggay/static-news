<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707382873907" as="style"/><link rel="stylesheet" href="styles.css?v=1707382873907"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://flawless.dev/essays/when-letting-it-crash-is-not-enough/">When &quot;letting it crash&quot; is not enough</a> <span class="domain">(<a href="https://flawless.dev">flawless.dev</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>37 comments</span></div><br/><div><div id="39299572" class="c"><input type="checkbox" id="c-39299572" checked=""/><div class="controls bullet"><span class="by">MauranKilom</span><span>|</span><a href="#39299073">next</a><span>|</span><label class="collapse" for="c-39299572">[-]</label><label class="expand" for="c-39299572">[1 more]</label></div><br/><div class="children"><div class="content">Two big question marks after reading this and the linked home page (partially pointed out in other comments):<p>- If there&#x27;s a flaw in your application code that causes a crash (as is the motivating example in the essay), then restoring the entire program into the state it was in just before the crash happened would just cause it to crash again ad infinitum. Sure, this model helps against &quot;my VM instance got preempted&quot;, but that&#x27;s a pretty different category of &quot;crash&quot; (and also notably unrelated to supervision trees).<p>- &quot;External&quot; state (like an API endpoint being down&#x2F;returning gibberish) can be part of the reason why your program got into a bad state. In fact, that&#x27;s disproportionately likely, since external &quot;weirdness&quot; is comparatively hard to cover exhaustively in tests. In such a situation, the suggested computation model would never be able to recover even when restarted, because it would forever retain the (bad) API response. Effectively, this is just caching all the non-pure effects of your computation, and we all know about cache invalidation being a hard problem...</div><br/></div></div><div id="39299073" class="c"><input type="checkbox" id="c-39299073" checked=""/><div class="controls bullet"><span class="by">orbital-decay</span><span>|</span><a href="#39299572">prev</a><span>|</span><a href="#39299350">next</a><span>|</span><label class="collapse" for="c-39299073">[-]</label><label class="expand" for="c-39299073">[1 more]</label></div><br/><div class="children"><div class="content">Durable execution and state restoration is also a great way to get close to the crashing point again, though.<p>The entire point of crashing early is to reset the state of the program <i>completely</i>, hoping that the path that crashes it will not be taken too often. (and it only works well in the situations where crashing means negligible interruption of the service) By preserving the state between crashes, you diminish the pool of possible non-crashing states.</div><br/></div></div><div id="39299350" class="c"><input type="checkbox" id="c-39299350" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#39299073">prev</a><span>|</span><a href="#39299023">next</a><span>|</span><label class="collapse" for="c-39299350">[-]</label><label class="expand" for="c-39299350">[3 more]</label></div><br/><div class="children"><div class="content">&gt; This brings me to a recent discovery I made, another approach to dealing with failure that completely blew my mind . It&#x27;s commonly known under the name durable execution, and is so new that most developers never have heard of it.<p>Some feedback: this paragraph lands like a Reddit post from a teenager, who just took a big drag off a joint, and thinks they&#x27;ve invented a new field of science. (And also hasn&#x27;t completed it so isn&#x27;t ready to share it yet!)<p>Of course, everything&#x27;s already been thought of. What you&#x27;ve described so far as durable computing sounds indistinguishable from event sourcing.<p>The code snippet is intriguing, though.  We&#x27;re abstracting event sourcing away from the developer---it happens automatically for <i>every</i> non-purely-functional operation---so the programmer can just write normal code.<p>Though, you&#x27;d have a lot of events, and I&#x27;d wonder about performance and scalability for larger apps.<p>Also, assuming events are at the finest level of granularity, I also imagine this starts to look like the equivalent of some kind of intermittent heap dump.</div><br/><div id="39299543" class="c"><input type="checkbox" id="c-39299543" checked=""/><div class="controls bullet"><span class="by">vilhelm_s</span><span>|</span><a href="#39299350">parent</a><span>|</span><a href="#39299023">next</a><span>|</span><label class="collapse" for="c-39299543">[-]</label><label class="expand" for="c-39299543">[2 more]</label></div><br/><div class="children"><div class="content">They&#x27;re not claming that they invented it, it&#x27;s an existing term. This blogpost lists 14 different projects in the space: <a href="https:&#x2F;&#x2F;www.golem.cloud&#x2F;post&#x2F;the-emerging-landscape-of-durable-computing" rel="nofollow">https:&#x2F;&#x2F;www.golem.cloud&#x2F;post&#x2F;the-emerging-landscape-of-durab...</a></div><br/><div id="39299629" class="c"><input type="checkbox" id="c-39299629" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#39299350">root</a><span>|</span><a href="#39299543">parent</a><span>|</span><a href="#39299023">next</a><span>|</span><label class="collapse" for="c-39299629">[-]</label><label class="expand" for="c-39299629">[1 more]</label></div><br/><div class="children"><div class="content">They do say “so new most developers have never heard of it” though. Which, you know, implies that it’s new…</div><br/></div></div></div></div></div></div><div id="39299023" class="c"><input type="checkbox" id="c-39299023" checked=""/><div class="controls bullet"><span class="by">vinkelhake</span><span>|</span><a href="#39299350">prev</a><span>|</span><a href="#39299536">next</a><span>|</span><label class="collapse" for="c-39299023">[-]</label><label class="expand" for="c-39299023">[1 more]</label></div><br/><div class="children"><div class="content">I implemented something similar at work for a phone handling system. We had a &quot;workflow&quot; system that let clients script how calls should be handled. All side effects that the script was allowed to make happened through an API with functionality like reading DTMF input, playing media, adding another call leg etc.<p>Like the article says, we would record a log of all the interactions with the outside world. The lower level parts of the system had the capability of transferring an in-progress call from one server to another. SIP and RTP traffic would be moved to another server, and finally the workflow log was sent. The server that took over the call would then replay the script and arrive at the same execution state that the first server had before the call was moved. Workflow authors didn&#x27;t have to care about any of this. To them it looked like the call started and ended on the same server.</div><br/></div></div><div id="39299536" class="c"><input type="checkbox" id="c-39299536" checked=""/><div class="controls bullet"><span class="by">albertzeyer</span><span>|</span><a href="#39299023">prev</a><span>|</span><a href="#39298744">next</a><span>|</span><label class="collapse" for="c-39299536">[-]</label><label class="expand" for="c-39299536">[3 more]</label></div><br/><div class="children"><div class="content">As it was mentioned, this sounds very much like time-traveling debuggers like RR, which also records such database.<p>But I don&#x27;t exactly understand: If you exactly recover the same state, don&#x27;t you end up with the same faulty undesirable state? (That&#x27;s what you also get with RR, by intention, to debug the problem.)<p>Clearly, here this is not the intention, i.e. you don&#x27;t want to recover exactly the same state. So, it means, some parts will not be recovered. How would it be decided what parts to recover and what parts not? This seems like an impossible problem to solve in general.<p>And then, the state will not be exactly the same. It might be now in a sane state, but is it the right state that the user wants?</div><br/><div id="39299550" class="c"><input type="checkbox" id="c-39299550" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#39299536">parent</a><span>|</span><a href="#39298744">next</a><span>|</span><label class="collapse" for="c-39299550">[-]</label><label class="expand" for="c-39299550">[2 more]</label></div><br/><div class="children"><div class="content">I guess it insulates you against bugs in the VM implementation, plus against (transient) failures of the host system.</div><br/><div id="39299603" class="c"><input type="checkbox" id="c-39299603" checked=""/><div class="controls bullet"><span class="by">albertzeyer</span><span>|</span><a href="#39299536">root</a><span>|</span><a href="#39299550">parent</a><span>|</span><a href="#39298744">next</a><span>|</span><label class="collapse" for="c-39299603">[-]</label><label class="expand" for="c-39299603">[1 more]</label></div><br/><div class="children"><div class="content">Ah, right, that would be an option to define a clear boundary, i.e. to recover exactly the VM state, but not the OS native state. I was thinking about a native app here, where there is no VM.<p>But this would cover only some specific set up failures, namely where something goes wrong in the host, which you can easily recover by resetting its state and retrying again. This is only a very limited amount of failures. I guess most failures come from bugs in the user code, which would all be state within the VM.<p>Also, maybe your app depends on some resources from network, e.g. some NFS, or maybe some other remote server, or whatever, which you anyway cannot control. This is not easily recoverable then. (Tools like <a href="https:&#x2F;&#x2F;criu.org&#x2F;Main_Page" rel="nofollow">https:&#x2F;&#x2F;criu.org&#x2F;Main_Page</a>, which try to serialize an app state, to be able to recover it later, have the same problem.)</div><br/></div></div></div></div></div></div><div id="39298744" class="c"><input type="checkbox" id="c-39298744" checked=""/><div class="controls bullet"><span class="by">MarkSweep</span><span>|</span><a href="#39299536">prev</a><span>|</span><a href="#39299031">next</a><span>|</span><label class="collapse" for="c-39298744">[-]</label><label class="expand" for="c-39298744">[4 more]</label></div><br/><div class="children"><div class="content">The approach of check-pointing computation such that it is restartable sounds similar to a time-traveling debugger, like rr or WinDbg:<p><a href="https:&#x2F;&#x2F;rr-project.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rr-project.org&#x2F;</a><p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;windows-hardware&#x2F;drivers&#x2F;debuggercmds&#x2F;time-travel-debugging-overview" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;windows-hardware&#x2F;drivers&#x2F;debugge...</a><p>Some Googling found Checkpoint&#x2F;Restore In Userspace, or CRIU. It’s like Flawless, but for Linux processes:<p><a href="https:&#x2F;&#x2F;criu.org&#x2F;Main_Page" rel="nofollow">https:&#x2F;&#x2F;criu.org&#x2F;Main_Page</a><p>I bet that Flawless can make better guarantees about reliability due to constraints of the WebAssembly sandbox.</div><br/><div id="39299369" class="c"><input type="checkbox" id="c-39299369" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#39298744">parent</a><span>|</span><a href="#39299575">next</a><span>|</span><label class="collapse" for="c-39299369">[-]</label><label class="expand" for="c-39299369">[1 more]</label></div><br/><div class="children"><div class="content">Our time travel debugger at undo.io also uses a similar approach.<p>But the world is different for time travel debug, in that you can replay the whole history of the recorded execution (my understanding is that this is not required for Durable Execution) but you cannot resume the <i>real</i> process.<p>In fact, since it&#x27;s used for capturing faults, you wouldn&#x27;t generally want to resume execution - it&#x27;s <i>going</i> to fail the same way (whereas a higher level restart framework might allow you to throw away some bad state and continue the computation - at the cost of not being able to precisely duplicate the bug).</div><br/></div></div><div id="39299575" class="c"><input type="checkbox" id="c-39299575" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#39298744">parent</a><span>|</span><a href="#39299369">prev</a><span>|</span><a href="#39299305">next</a><span>|</span><label class="collapse" for="c-39299575">[-]</label><label class="expand" for="c-39299575">[1 more]</label></div><br/><div class="children"><div class="content">Docker[0] supports CRIU, but it has always been experimental. I always assumed it would be a valuable tool for test cases, but I never used it.<p>[0]: <a href="https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;checkpoint&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;checkpo...</a></div><br/></div></div><div id="39299305" class="c"><input type="checkbox" id="c-39299305" checked=""/><div class="controls bullet"><span class="by">kotborealis</span><span>|</span><a href="#39298744">parent</a><span>|</span><a href="#39299575">prev</a><span>|</span><a href="#39299031">next</a><span>|</span><label class="collapse" for="c-39299305">[-]</label><label class="expand" for="c-39299305">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also an implementation of time-traveling debugging in Qenu[0], which sounds really nice but does not actually work reliably on larger use-cases.<p>[0] <a href="https:&#x2F;&#x2F;www.linux-kvm.org&#x2F;images&#x2F;d&#x2F;d0&#x2F;02x06b-DeterministicReplay.pdf" rel="nofollow">https:&#x2F;&#x2F;www.linux-kvm.org&#x2F;images&#x2F;d&#x2F;d0&#x2F;02x06b-DeterministicRe...</a></div><br/></div></div></div></div><div id="39299031" class="c"><input type="checkbox" id="c-39299031" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39298744">prev</a><span>|</span><a href="#39299649">next</a><span>|</span><label class="collapse" for="c-39299031">[-]</label><label class="expand" for="c-39299031">[1 more]</label></div><br/><div class="children"><div class="content">&gt; .. durable execution, and is so new that most developers never have heard of it.<p>It&#x27;s called checkpoint&#x2F;restart, and was a feature of some early operating systems. Mostly for programs whose run time exceeded the mean time before failure of the system.<p>Tandem&#x27;s whole system concept was built around that.<p>Amusingly, Second Life, of all things, has durable execution of the little LSL programs that make in-world objects go. They&#x27;re checkpointed every minute or two, and if a region crashes, they are restarted, stack, heap, and all. They survive machine crashes and ports to new hardware. Even migration from a dedicated data center to AWS. Some have been running for well over a decade. Internally, they are Mono programs.</div><br/></div></div><div id="39299649" class="c"><input type="checkbox" id="c-39299649" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#39299031">prev</a><span>|</span><a href="#39298589">next</a><span>|</span><label class="collapse" for="c-39299649">[-]</label><label class="expand" for="c-39299649">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been doing this for a long time, except I just write basically a memoize function that I slap onto any old function.<p>It’s not a real error handling solution. I only use it for my quick and dirty projects.<p>Many errors are recoverable but the ones that are not fuck up
this scheme because a human needed to have written a proper error recovery scheme that isn’t just “retry over and over from a previous point.”<p>At the end of the day, you gotta put in manual work for error handling. You can’t rely on your language or any library to create a generic error handler.</div><br/></div></div><div id="39298589" class="c"><input type="checkbox" id="c-39298589" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#39299649">prev</a><span>|</span><a href="#39298854">next</a><span>|</span><label class="collapse" for="c-39298589">[-]</label><label class="expand" for="c-39298589">[8 more]</label></div><br/><div class="children"><div class="content">I thought the idea of &quot;exactly once&quot; was a very questionable claim given what we know about computing, specially distributed.<p>Then somewhere else you see this gem.<p>&gt; Workflows in flawless are written in Rust, in fact they are just regular Rust functions. This means that they can contain arbitrary logic. But instead of native code, the functions are compiled to WebAssembly and executed in a completely deterministic environment.<p>As much as I love Rust, this sounds like, here is a problem, let me throw fancy Rust and WebAssembly and that should fix it.</div><br/><div id="39298761" class="c"><input type="checkbox" id="c-39298761" checked=""/><div class="controls bullet"><span class="by">abrookewood</span><span>|</span><a href="#39298589">parent</a><span>|</span><a href="#39298852">next</a><span>|</span><label class="collapse" for="c-39298761">[-]</label><label class="expand" for="c-39298761">[2 more]</label></div><br/><div class="children"><div class="content">The main page (<a href="https:&#x2F;&#x2F;flawless.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flawless.dev&#x2F;</a>) has a diagram&#x2F;video that shows how it would work and it basically writes any &#x27;side effects&#x27; to a log which is used to track their existence. If they exist in the log, you read them; if they don&#x27;t you run the code that generates them and then log it.<p>It&#x27;s interesting, but I can&#x27;t imagine how it is going to work at scale, both in terms of managing state across a very large application and in terms of running thousands of instances concurrently.</div><br/><div id="39299411" class="c"><input type="checkbox" id="c-39299411" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#39298589">root</a><span>|</span><a href="#39298761">parent</a><span>|</span><a href="#39298852">next</a><span>|</span><label class="collapse" for="c-39299411">[-]</label><label class="expand" for="c-39299411">[1 more]</label></div><br/><div class="children"><div class="content">As the saying goes, &quot;it is turtles all the way down&quot;. How do you ensure the log is &quot;written&quot; and &quot;synced&quot; _exactly once_?</div><br/></div></div></div></div><div id="39298852" class="c"><input type="checkbox" id="c-39298852" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39298589">parent</a><span>|</span><a href="#39298761">prev</a><span>|</span><a href="#39298900">next</a><span>|</span><label class="collapse" for="c-39298852">[-]</label><label class="expand" for="c-39298852">[1 more]</label></div><br/><div class="children"><div class="content">That can absolutely work... if you are confined into a single machine. (In fact, that&#x27;s roughly how cloud instances work.) I see no way to generalize that into a distributed system. In my previous job I worked on a game server engine which solves a very limited version of this problem via virtual actors and it was still way too hard.</div><br/></div></div><div id="39298900" class="c"><input type="checkbox" id="c-39298900" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#39298589">parent</a><span>|</span><a href="#39298852">prev</a><span>|</span><a href="#39298854">next</a><span>|</span><label class="collapse" for="c-39298900">[-]</label><label class="expand" for="c-39298900">[4 more]</label></div><br/><div class="children"><div class="content">Exactly Once is basically a solved problem.  The CAP theorem says you can either get consistency or availability in a system that has network partitions.<p>If you give up consistency, you end up corrupting data every once in a while.<p>If you don’t, then you can have exactly once, but it might take a long time if there’s a network failure.<p>NFSv3 solved this back in the 1980’s.  (V2 and V1 may have, but I don’t know.)<p>It did it without requiring deterministic execution or other programming language innovations, so I share your skepticism about rust and web assembly solving these problems.<p>(I really like rust, and recommend it for pretty much all new systems code.  However, it is not a panacea.)</div><br/><div id="39299183" class="c"><input type="checkbox" id="c-39299183" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39298589">root</a><span>|</span><a href="#39298900">parent</a><span>|</span><a href="#39298854">next</a><span>|</span><label class="collapse" for="c-39299183">[-]</label><label class="expand" for="c-39299183">[3 more]</label></div><br/><div class="children"><div class="content">This comment has some errors in it:<p>1. Exactly Once is absolutely not a solved problem.  CAP says nothing about &#x27;exactly once&#x27;, it&#x27;s about design choices for your data.  But you can do all sorts of side-effectful things when it comes setting the data.<p>2. Giving up consistency does not mean you &quot;corrupt your data every once in awhile&quot;.  I don&#x27;t know why you would say that.  Choosing availability means you have to make decisions about how your data becomes consistent, but nothing about that means it is corrupted.<p>3. Choosing consistency says nothing about &quot;exactly once&quot;.  Consider this basic workflow backed by a consistent database: request comes into service, service sends email, services goes to store that email was sent in consistent database and crashes, user gets crash back, reruns request, email sent again.  Oh so send the email AFTER it&#x27;s stored in the database, well service crashes after saving in database, same problem.</div><br/><div id="39299724" class="c"><input type="checkbox" id="c-39299724" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#39298589">root</a><span>|</span><a href="#39299183">parent</a><span>|</span><a href="#39298854">next</a><span>|</span><label class="collapse" for="c-39299724">[-]</label><label class="expand" for="c-39299724">[2 more]</label></div><br/><div class="children"><div class="content">If your system provides strong consistency, it is possible to build exactly once processing over it.  NFSv3 is an existence proof, and there are plenty of theoretical results showing it is possible.  Roughly speaking, you run the job and install the result in the consistent store iff your output register is null.  If you side effect outside of the exactly once system, and the receiver can’t suppress duplicate notifications then you’re screwed, but the system in the article precludes that, as do many existing systems.<p>As for your other points, with eventual consistency you get weird problems like “I wrote X, then Y, but then read X and the system converged to X, except a week later I read Y, but just from half my fleet, and only for a 30 minute window”.<p>Unless you layer consistency on top of that (which is not always possible), then, tautologically, you don’t get consistency.  In particular, most intuitive application-level invariants are going to be violated in all sorts of bizarre ways that take many pages to explain.<p>In practice, eventual consistency is closer to corrupting than not corrupting, because most application developers aren’t going to follow this conversation, and will use the database wrong.<p>I’m sure you or I could model our program and the storage in TLA+ and confirm we’re correctly maintaining application state, but that doesn’t help most developers.<p>Also, it’s not economically efficient.<p>We’re talking about “only” getting 6 nines instead of 7 because we chose CP instead of AP, but as a side benefit the system is easier to maintain, and it took less than 1&#x2F;10th as much to implement, and has orders of magnitude fewer implementation bugs.</div><br/><div id="39299841" class="c"><input type="checkbox" id="c-39299841" checked=""/><div class="controls bullet"><span class="by">sausagefeet</span><span>|</span><a href="#39298589">root</a><span>|</span><a href="#39299724">parent</a><span>|</span><a href="#39298854">next</a><span>|</span><label class="collapse" for="c-39299841">[-]</label><label class="expand" for="c-39299841">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you side effect outside of the exactly once system, and the receiver can’t suppress duplicate notifications then you’re screwed<p>If you are getting duplicate notifications, then you don&#x27;t have an &quot;exactly once&quot; system, but definition.  Exactly once systems are not possible, bu your own explanation.  You can store data in a durable way such that applying it multiple times is safe, but that is not &quot;exactly once&quot;.  Your options are at-least once or at-most once.  Again, by your own statement: if you have duplicate notifications in your system, you do not have &quot;exactly once&quot;.<p>&gt; As for your other points, with eventual consistency you get weird problems like “I wrote X, then Y, but then read X and the system converged to X, except a week later I read Y, but just from half my fleet, and only for a 30 minute window”.<p>This is not data corruption, this is the semantics of an eventually consistent system. If you don&#x27;t want those semantics, don&#x27;t have an eventually consistent system, but that is entirely different than data corruption.  Developers not understanding the system is different than corruption.<p>I agree that eventual consistent is probably not a good idea for most problems.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39298854" class="c"><input type="checkbox" id="c-39298854" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#39298589">prev</a><span>|</span><a href="#39299578">next</a><span>|</span><label class="collapse" for="c-39298854">[-]</label><label class="expand" for="c-39298854">[3 more]</label></div><br/><div class="children"><div class="content">Flawless sounds a lot like <a href="https:&#x2F;&#x2F;temporal.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;temporal.io&#x2F;</a> .<p>I&#x27;m wondering if it has the same scalability concerns - sticking everything in Postgres is fine at small-ish scale, but what happens when you outgrow Postgres, either because you have higher availability requirements (can&#x27;t handle primary DB restarts) or because of the sheer volume of the workload?</div><br/><div id="39299319" class="c"><input type="checkbox" id="c-39299319" checked=""/><div class="controls bullet"><span class="by">bjconlan</span><span>|</span><a href="#39298854">parent</a><span>|</span><a href="#39299754">next</a><span>|</span><label class="collapse" for="c-39299319">[-]</label><label class="expand" for="c-39299319">[1 more]</label></div><br/><div class="children"><div class="content">Yeah the whole thing reminded me of the blog post they talk about regarding a time travelling debugger...<p><a href="https:&#x2F;&#x2F;temporal.io&#x2F;blog&#x2F;time-travel-debugging-production-code" rel="nofollow">https:&#x2F;&#x2F;temporal.io&#x2F;blog&#x2F;time-travel-debugging-production-co...</a><p>Anyways I wish all the best for flawless as this problem is worth solving&#x2F;popularizing.</div><br/></div></div><div id="39299754" class="c"><input type="checkbox" id="c-39299754" checked=""/><div class="controls bullet"><span class="by">nelsonic</span><span>|</span><a href="#39298854">parent</a><span>|</span><a href="#39299319">prev</a><span>|</span><a href="#39299578">next</a><span>|</span><label class="collapse" for="c-39299754">[-]</label><label class="expand" for="c-39299754">[1 more]</label></div><br/><div class="children"><div class="content">What percentage of apps “outgrow” Postgres?</div><br/></div></div></div></div><div id="39299578" class="c"><input type="checkbox" id="c-39299578" checked=""/><div class="controls bullet"><span class="by">8organicbits</span><span>|</span><a href="#39298854">prev</a><span>|</span><a href="#39299480">next</a><span>|</span><label class="collapse" for="c-39299578">[-]</label><label class="expand" for="c-39299578">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if this would end up with a bloated log. Imagine that you download a large file and then count the occurrences of a word. You wouldn&#x27;t want to save that whole file to the log, after you count occurrences you don&#x27;t need it, but it must stay in the log incase the execution is retried.<p>Maybe you&#x27;d want a wrapper around certain sections to say: only only log the output of this group of statements.</div><br/></div></div><div id="39299480" class="c"><input type="checkbox" id="c-39299480" checked=""/><div class="controls bullet"><span class="by">sirsinsalot</span><span>|</span><a href="#39299578">prev</a><span>|</span><a href="#39299358">next</a><span>|</span><label class="collapse" for="c-39299480">[-]</label><label class="expand" for="c-39299480">[1 more]</label></div><br/><div class="children"><div class="content">Erlang and OTP, as ugly as it is (to me) got a lot right on this front already.</div><br/></div></div><div id="39299358" class="c"><input type="checkbox" id="c-39299358" checked=""/><div class="controls bullet"><span class="by">croo</span><span>|</span><a href="#39299480">prev</a><span>|</span><a href="#39298953">next</a><span>|</span><label class="collapse" for="c-39299358">[-]</label><label class="expand" for="c-39299358">[1 more]</label></div><br/><div class="children"><div class="content">I saw something similar back in 2010 for java but it was marketed as a different product. It was some kind of a debugger which would let me forward and rewind time and the state of the program with a single slider. It was marvelous and totally unusable for the monster java EE stuff we were working on but sounded awesome for sane, smaller projects.</div><br/></div></div><div id="39298953" class="c"><input type="checkbox" id="c-39298953" checked=""/><div class="controls bullet"><span class="by">emadb</span><span>|</span><a href="#39299358">prev</a><span>|</span><a href="#39299117">next</a><span>|</span><label class="collapse" for="c-39298953">[-]</label><label class="expand" for="c-39298953">[1 more]</label></div><br/><div class="children"><div class="content">AFAIK Erlang and Elixir have a way to save the state just before the process is stopped. It should be the `trap_exit` flag on a gen_server that guarantees that the exit message will be managed. In that handler you can save all your state and resume it when the process restarts.</div><br/></div></div><div id="39299117" class="c"><input type="checkbox" id="c-39299117" checked=""/><div class="controls bullet"><span class="by">m0sa</span><span>|</span><a href="#39298953">prev</a><span>|</span><a href="#39299632">next</a><span>|</span><label class="collapse" for="c-39299117">[-]</label><label class="expand" for="c-39299117">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like Azure Durable Functions [0]<p>[0]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;azure-functions&#x2F;durable&#x2F;durable-functions-overview" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;azure&#x2F;azure-functions&#x2F;dura...</a></div><br/></div></div><div id="39299632" class="c"><input type="checkbox" id="c-39299632" checked=""/><div class="controls bullet"><span class="by">gfodor</span><span>|</span><a href="#39299117">prev</a><span>|</span><a href="#39299264">next</a><span>|</span><label class="collapse" for="c-39299632">[-]</label><label class="expand" for="c-39299632">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of Kafka Streams</div><br/></div></div><div id="39299264" class="c"><input type="checkbox" id="c-39299264" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#39299632">prev</a><span>|</span><a href="#39299269">next</a><span>|</span><label class="collapse" for="c-39299264">[-]</label><label class="expand" for="c-39299264">[1 more]</label></div><br/><div class="children"><div class="content">This could also double as an undo&#x2F;redo queue.</div><br/></div></div><div id="39299269" class="c"><input type="checkbox" id="c-39299269" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#39299264">prev</a><span>|</span><a href="#39298959">next</a><span>|</span><label class="collapse" for="c-39299269">[-]</label><label class="expand" for="c-39299269">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t this just Event Sourcing?</div><br/></div></div><div id="39298959" class="c"><input type="checkbox" id="c-39298959" checked=""/><div class="controls bullet"><span class="by">lawik</span><span>|</span><a href="#39299269">prev</a><span>|</span><a href="#39298974">next</a><span>|</span><label class="collapse" for="c-39298959">[-]</label><label class="expand" for="c-39298959">[1 more]</label></div><br/><div class="children"><div class="content">Bit of a cliffhanger style ad. But well set up for the pitch as I know the whole Erlang deal and that part was covered well.<p>I stopped reading somewhere in the presentation of flawless. Ran out of care for the moment. Might revisit it though. Sounds interesting.</div><br/></div></div><div id="39298974" class="c"><input type="checkbox" id="c-39298974" checked=""/><div class="controls bullet"><span class="by">ChrisArchitect</span><span>|</span><a href="#39298959">prev</a><span>|</span><label class="collapse" for="c-39298974">[-]</label><label class="expand" for="c-39298974">[1 more]</label></div><br/><div class="children"><div class="content">(2023)</div><br/></div></div></div></div></div></div></div></body></html>