<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724403664680" as="style"/><link rel="stylesheet" href="styles.css?v=1724403664680"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/boricj/ghidra-delinker-extension">Show HN: A Ghidra extension for exporting parts of a program as object files</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>boricj</span> | <span>37 comments</span></div><br/><div><div id="41321053" class="c"><input type="checkbox" id="c-41321053" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41322141">next</a><span>|</span><label class="collapse" for="c-41321053">[-]</label><label class="expand" for="c-41321053">[2 more]</label></div><br/><div class="children"><div class="content">Oh, great to see this here. I think this is an extremely cool project, and I helped to add MS COFF support. (P.S.: I will note that my initial PR was notably worse than the ELF support that was already present, so if you run into problems with it... probably my fault :P I can see it is being improved, though.) That said, I haven&#x27;t done anything big with it yet. The most fun I had was delinking a Hello World executable compiled with Visual Studio 2003, relinking it to Linux x86 with GCC+glibc, and then relinking <i>that</i> to MinGW+msvcrt again. Doing anything larger than hello world is a bit beyond me yet, though, in part because I&#x27;m actually a pretty big n00b when it comes to Ghidra and haven&#x27;t even really figured out a good way to select the ranges for delinking from a large binary. I should&#x27;ve probably asked someone by now, but oh well. :)<p>Coincidentally, a derivation for this just got merged into Nixpkgs earlier today, so if you&#x27;re using NixOS unstable it&#x27;s possible to install it using ghidra.withExtensions; it is under ghidra-extensions.ghidra-delinker-extension. Only one problem: There was a new version released a few days ago and I didn&#x27;t rebase my PR, so it is out of date. I will try to push an update soon.</div><br/><div id="41321787" class="c"><input type="checkbox" id="c-41321787" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41321053">parent</a><span>|</span><a href="#41322141">next</a><span>|</span><label class="collapse" for="c-41321787">[-]</label><label class="expand" for="c-41321787">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m actually a pretty big n00b when it comes to Ghidra and haven&#x27;t even really figured out a good way to select the ranges for delinking from a large binary.<p>One way to keep track of things to delink is to use folders and fragments inside a program tree. For example, I have a Ghidra program where I&#x27;ve figured out the name and ranges of the various object files that originally made up the executable. These folders or fragments can then be selected as a whole with right-click &gt; Select Addresses.<p>The relocation synthesizer analyzer and the exporter can also be scripted, either independently or using the program&#x27;s tree manager. This removes the need to select by hand the ranges you want as well as invoking manually the analyzer and the exporter.</div><br/></div></div></div></div><div id="41322141" class="c"><input type="checkbox" id="c-41322141" checked=""/><div class="controls bullet"><span class="by">hmfrh</span><span>|</span><a href="#41321053">prev</a><span>|</span><a href="#41321926">next</a><span>|</span><label class="collapse" for="c-41322141">[-]</label><label class="expand" for="c-41322141">[7 more]</label></div><br/><div class="children"><div class="content">How much work is it to figure out which sections of the executable to export?<p>Would it be realistic to be able to export a modern-ish (2008-2015) Win32 game into objects and then compile&#x2F;link it into a full executable again with less than a few hours work?</div><br/><div id="41322702" class="c"><input type="checkbox" id="c-41322702" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41322141">parent</a><span>|</span><a href="#41321926">next</a><span>|</span><label class="collapse" for="c-41322702">[-]</label><label class="expand" for="c-41322702">[6 more]</label></div><br/><div class="children"><div class="content">&gt; How much work is it to figure out which sections of the executable to export?<p>As long as you do not cut across a variable or a function, you can export pretty much however you want, you don&#x27;t have to follow the original object file boundaries. <i>What</i> to export is a separate matter and requires some knowledge about the program. Having debugging symbols makes this much easier, otherwise by the time you&#x27;ve made the Ghidra database accurate enough for exportation you&#x27;ll usually have an idea of where&#x27;s what.<p>&gt; Would it be realistic to be able to export a modern-ish (2008-2015) Win32 game into objects and then compile&#x2F;link it into a full executable again with less than a few hours work?<p>About the user report in my submission, they first raised an issue in early July and by mid-August they got a fully working, functionally identical relinked executable. To be fair, the COFF exporter had a <i>lot</i> of bugs that needed to be fixed and the i386 analyzer needed some touch-ups, things that somebody else should hopefully won&#x27;t stumble over now.<p>I don&#x27;t know how long it would take, but unless you have debugging symbols and are really lucky it will take more than a few hours of work. A skilled reverse-engineer can probably manage to get <i>something</i> executing in that timeframe (even if it crashes halfway during the first loading screen), but it&#x27;s one of these tasks that you won&#x27;t know when it will be done until it is done.</div><br/><div id="41322907" class="c"><input type="checkbox" id="c-41322907" checked=""/><div class="controls bullet"><span class="by">hmfrh</span><span>|</span><a href="#41322141">root</a><span>|</span><a href="#41322702">parent</a><span>|</span><a href="#41321926">next</a><span>|</span><label class="collapse" for="c-41322907">[-]</label><label class="expand" for="c-41322907">[5 more]</label></div><br/><div class="children"><div class="content">&gt; As long as you do not cut across a variable or a function, you can export pretty much however you want, you don&#x27;t have to follow the original object file boundaries.<p>Would it be possible to export basically the entire program at once and then slice off individual functions one by one?<p>Do you have any guides&#x2F;examples of the<p>&gt; Decompilation projects, by splitting a program into multiple object files and reimplementing these Ship of Theseus-style<p>style project?</div><br/><div id="41323404" class="c"><input type="checkbox" id="c-41323404" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41322141">root</a><span>|</span><a href="#41322907">parent</a><span>|</span><a href="#41321926">next</a><span>|</span><label class="collapse" for="c-41323404">[-]</label><label class="expand" for="c-41323404">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Would it be possible to export basically the entire program at once and then slice off individual functions one by one?<p>Yes. The exporters can handle whatever meaningful address selection you can throw at them, including multiple disjoint ranges within the same section. So you can keep carving holes inside your selection until nothing remains of the original program.<p>&gt; Do you have any guides&#x2F;examples of the Ship of Theseus-style style project?<p>Not quite. My own decompilation project is on a hiatus due to one version tracking session too many in a row, so I only have one article on this so far [1] and the way I&#x27;ve done it is a bit wonky.<p>Another user has recently started a decompilation project [2] with a better framework than I&#x27;ve used in that article, but no actual decompilation has taken place there yet. Incidentally, that would also make for a good modding framework, if one decides to not write functionally identical replacement code.<p>[1] <a href="https:&#x2F;&#x2F;boricj.net&#x2F;tenchu1&#x2F;2024&#x2F;05&#x2F;31&#x2F;part-11.html" rel="nofollow">https:&#x2F;&#x2F;boricj.net&#x2F;tenchu1&#x2F;2024&#x2F;05&#x2F;31&#x2F;part-11.html</a> (which is humorously titled &quot;A modding framework powered by the tears of CS101 teachers&quot;)<p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;widberg&#x2F;FUELDecompilation">https:&#x2F;&#x2F;github.com&#x2F;widberg&#x2F;FUELDecompilation</a></div><br/><div id="41323637" class="c"><input type="checkbox" id="c-41323637" checked=""/><div class="controls bullet"><span class="by">hmfrh</span><span>|</span><a href="#41322141">root</a><span>|</span><a href="#41323404">parent</a><span>|</span><a href="#41321926">next</a><span>|</span><label class="collapse" for="c-41323637">[-]</label><label class="expand" for="c-41323637">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Yes. The exporters can handle whatever meaningful address selection you can throw at them, including multiple disjoint ranges within the same section. So you can keep carving holes inside your selection until nothing remains of the original program.<p>Will this also work without painstakingly reversing things in the binary, say in the case of a giant game executable?<p>If possible, I would be very interested in a simple tutorial that takes an arbitrary Windows executable, delinks it and replaces a single function, without all the extra steps necessary to run it on the PS1.<p>It might even be preferable if it worked with MingW, since I&#x27;m on Linux as well.</div><br/><div id="41324042" class="c"><input type="checkbox" id="c-41324042" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41322141">root</a><span>|</span><a href="#41323637">parent</a><span>|</span><a href="#41324035">prev</a><span>|</span><a href="#41321926">next</a><span>|</span><label class="collapse" for="c-41324042">[-]</label><label class="expand" for="c-41324042">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Will this also work without painstakingly reversing things in the binary, say in the case of a giant game executable?<p>You <i>can</i> get away with a Ghidra database that isn&#x27;t accurate, as long as you know what you&#x27;re doing. Basically, as long as the analyzers manage to identify all of the relocation spots inside your exportation, the rest doesn&#x27;t matter that much. You can even get away with missing relocation spots inside your exportation, if you don&#x27;t end up executing that code or accessing that data at run-time (if you do, then exotic undefined behavior ensues).<p>The most important thing here is getting references right and addresses typed as pointers (the type itself doesn&#x27;t matter). I&#x27;m not going to discuss this into more details than that, because it would require a deep understanding of the internal algorithms of the extension. Any shortfall between a less-than-accurate Ghidra database and experience will be filled in by luck.<p>&gt; If possible, I would be very interested in a simple tutorial that takes an arbitrary Windows executable, delinks it and replaces a single function, without all the extra steps necessary to run it on the PS1.<p>It&#x27;s essentially the same steps regardless of the platform. Select the bits you want in your object file, run the analyzer, invoke the exporter, use the linker to create a new program.<p>I&#x27;ve made my Ghidra extension as user-friendly as possible, the rest is standard native development stuff (up to the point where you hit exotic undefined behavior and can&#x27;t figure it out at a glance, hopefully you&#x27;re well acquainted with your debugger if that happens).<p>&gt; It might even be preferable if it worked with MingW, since I&#x27;m on Linux as well.<p>Actually, I&#x27;ve created a native port of a proprietary, statically-linked, Linux a.out i386 to Windows with MinGW [1] using my delinker. It was back when I didn&#x27;t have a COFF object file exporter either, so it was the only toolchain for that target that could ingest ELF object files.<p>That being said, MinGW and MSVC are reportedly only compatible at the C ABI level. Mixing and matching different toolchains can increase the odds of something going wrong, so you&#x27;re probably better off using the toolchain that the program was originally built with (hopefully it runs on Wine).<p>PS: remember that you are throwing your CS 101 handbook into the trashbin when you&#x27;re using a delinker (and its teacher is unlikely to be of much help).<p>[1] <a href="https:&#x2F;&#x2F;boricj.net&#x2F;atari-jaguar-sdk&#x2F;2024&#x2F;01&#x2F;02&#x2F;part-5.html" rel="nofollow">https:&#x2F;&#x2F;boricj.net&#x2F;atari-jaguar-sdk&#x2F;2024&#x2F;01&#x2F;02&#x2F;part-5.html</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41321926" class="c"><input type="checkbox" id="c-41321926" checked=""/><div class="controls bullet"><span class="by">jxjx</span><span>|</span><a href="#41322141">prev</a><span>|</span><a href="#41320791">next</a><span>|</span><label class="collapse" for="c-41321926">[-]</label><label class="expand" for="c-41321926">[2 more]</label></div><br/><div class="children"><div class="content">This sounds very interesting. And is tempting me to delve back into a game reverse engineering project I abandoned a few years back.<p>Do you have a fully worked example of how to use this and then how to make use of its output? Would love to see an end-to-end walkthrough.</div><br/><div id="41322755" class="c"><input type="checkbox" id="c-41322755" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41321926">parent</a><span>|</span><a href="#41320791">next</a><span>|</span><label class="collapse" for="c-41322755">[-]</label><label class="expand" for="c-41322755">[1 more]</label></div><br/><div class="children"><div class="content">There are links to various case studies on my blog inside the README of the repository.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;boricj&#x2F;ghidra-delinker-extension&#x2F;blob&#x2F;master&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;boricj&#x2F;ghidra-delinker-extension&#x2F;blob&#x2F;mas...</a></div><br/></div></div></div></div><div id="41321976" class="c"><input type="checkbox" id="c-41321976" checked=""/><div class="controls bullet"><span class="by">sweeter</span><span>|</span><a href="#41320791">prev</a><span>|</span><a href="#41322806">next</a><span>|</span><label class="collapse" for="c-41321976">[-]</label><label class="expand" for="c-41321976">[5 more]</label></div><br/><div class="children"><div class="content">That sounds like magic, I&#x27;m not going to lie. I have to understand how this is possible.</div><br/><div id="41322519" class="c"><input type="checkbox" id="c-41322519" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41321976">parent</a><span>|</span><a href="#41322844">next</a><span>|</span><label class="collapse" for="c-41322519">[-]</label><label class="expand" for="c-41322519">[3 more]</label></div><br/><div class="children"><div class="content">It is definitely not going to be easy to do for every CPU architecture, but it&#x27;s not as ridiculous as it seems. Basically, the difference between an &quot;object file&quot; and an executable file or shared library is not very large. Often times, except for Microsoft platforms, they are in the same actual file format, e.g. ELF.<p>The big thing is relocations. Object files have granular relocations that executable files don&#x27;t; at least on Windows, executable images just have minimal relocations that point to addresses of code and data that will need to be fixed up if the executable is relocated, but the executable image itself is only able to be relocated with regards to its image base address as a whole unit. In contrast, object files contain symbol-level relocations. To be able to accurately reconstruct this information, you need to annotate the disassembly with somewhat accurate information about symbols.<p>The other big difference with an object file is well, it is not linked. None of the symbols are &quot;resolved&quot;. This is particularly easy to fix actually: during delinking if the symbol is outside of the current scope then it just needs to be replaced with an unresolved symbol, pretty much. Then when relinking, another object file or library needs to provide the symbol so that it can be linked back up.<p>(There are a few smaller differences too, like the lack of an entrypoint, but it really isn&#x27;t a whole lot of significance.)<p>This means that the boundaries for which you carve object files out of an executable image or shared object is actually completely arbitrary. It obviously was segmented into translation units when it was originally compiled, but nothing really cares about those boundaries at the linking stage. (Of course, you probably want to try to figure it out if possible, since it will probably be very hard to do a matching decompilation if your object boundaries are incorrect.)<p>Take this with a grain of salt as despite having literally worked on this problem I feel like I might be messing up some of the details a bit. I&#x27;ve been meaning to write a blog post about object files, though there are actually a couple of good ones already floating around.</div><br/><div id="41322978" class="c"><input type="checkbox" id="c-41322978" checked=""/><div class="controls bullet"><span class="by">fngjdflmdflg</span><span>|</span><a href="#41321976">root</a><span>|</span><a href="#41322519">parent</a><span>|</span><a href="#41322844">next</a><span>|</span><label class="collapse" for="c-41322978">[-]</label><label class="expand" for="c-41322978">[2 more]</label></div><br/><div class="children"><div class="content">&gt;It obviously was segmented into translation units when it was originally compiled, but nothing really cares about those boundaries at the linking stage. (Of course, you probably want to try to figure it out if possible, since it will probably be very hard to do a matching decompilation if your object boundaries are incorrect.)<p>Can you expound on this? Why are the boundaries not important at the linking stage - aren&#x27;t you linking the wrong code then? Or did I not understand the point here?</div><br/><div id="41323492" class="c"><input type="checkbox" id="c-41323492" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41321976">root</a><span>|</span><a href="#41322978">parent</a><span>|</span><a href="#41322844">next</a><span>|</span><label class="collapse" for="c-41323492">[-]</label><label class="expand" for="c-41323492">[1 more]</label></div><br/><div class="children"><div class="content">The boundaries aren&#x27;t important during delinking, as long as you do not cut across a variable or function. To the linker, sections are just arrays of bytes. It doesn&#x27;t care what&#x27;s inside those, all it has to do is lay them out in memory and apply relocations.<p>How you decide to slice up the original program is up to you. It doesn&#x27;t have to follow the boundaries from the original object files.</div><br/></div></div></div></div></div></div><div id="41322844" class="c"><input type="checkbox" id="c-41322844" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41321976">parent</a><span>|</span><a href="#41322519">prev</a><span>|</span><a href="#41322806">next</a><span>|</span><label class="collapse" for="c-41322844">[-]</label><label class="expand" for="c-41322844">[1 more]</label></div><br/><div class="children"><div class="content">To keep things short, object files are made of three parts: relocatable section bytes, relocation tables and a symbol table.<p>When a linker is invoked to generate an executable from a bunch of object files, it will lay out their sections in memory, compute the addresses of the symbols in the virtual address space and apply the relocations based on the final addresses of the symbols onto the section bytes.<p>The trick to delinking is figuring out where those relocations were applied in order to undo them and get back relocatable bytes. Then, you create relocation tables based on what you&#x27;ve just undone as well as a symbol table, package it all and you&#x27;ll get an object file.<p>The really tricky part is the analysis for spotting the relocation spots. I&#x27;m leveraging Ghidra to do the bulk of the work, but it still requires some work to convert references into relocation spots (fairly easy on x86, nightmarishly difficult on MIPS) as well as collecting all the required data and serializing the object file itself, hence this extension to automate all of that.</div><br/></div></div></div></div><div id="41322806" class="c"><input type="checkbox" id="c-41322806" checked=""/><div class="controls bullet"><span class="by">jcul</span><span>|</span><a href="#41321976">prev</a><span>|</span><a href="#41321211">next</a><span>|</span><label class="collapse" for="c-41322806">[-]</label><label class="expand" for="c-41322806">[1 more]</label></div><br/><div class="children"><div class="content">This looks really cool.<p>I don&#x27;t have a real use for it in my current work but in a past life it would have been so useful.<p>Hopefully I&#x27;ll have some time &#x2F; opportunity to try it out soon.</div><br/></div></div><div id="41321211" class="c"><input type="checkbox" id="c-41321211" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#41322806">prev</a><span>|</span><a href="#41322289">next</a><span>|</span><label class="collapse" for="c-41321211">[-]</label><label class="expand" for="c-41321211">[7 more]</label></div><br/><div class="children"><div class="content">It might be interesting to tie this into something I had a daydream about once and then never bothered to actually do: generate header files from debug info (and then possibly have some LLM tidy it up)</div><br/><div id="41321290" class="c"><input type="checkbox" id="c-41321290" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#41321211">parent</a><span>|</span><a href="#41322371">next</a><span>|</span><label class="collapse" for="c-41321290">[-]</label><label class="expand" for="c-41321290">[3 more]</label></div><br/><div class="children"><div class="content">Actually there are a few attempts at this! Here&#x27;s one for Microsoft Program Database:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;wbenny&#x2F;pdbex">https:&#x2F;&#x2F;github.com&#x2F;wbenny&#x2F;pdbex</a><p>As for using an LLM to tidy it up... It doesn&#x27;t seem like there has been a ton of success applying LLM models to reverse engineering yet... A part of me is wondering if this will wind up being a place where the LLM architecture proves insufficient. I&#x27;m not an expert but if I had to place a bet I&#x27;d bet on diffusion models being more interesting for a lot of reverse engineering use cases. That said, it&#x27;s not really the same thing, but with Binary Ninja they have a feature called Sidekick that uses an LLM to try to clean up the disassembly; I&#x27;m kind of unimpressed but maybe it is useful to somebody.</div><br/><div id="41321431" class="c"><input type="checkbox" id="c-41321431" checked=""/><div class="controls bullet"><span class="by">dvdkon</span><span>|</span><a href="#41321211">root</a><span>|</span><a href="#41321290">parent</a><span>|</span><a href="#41322513">next</a><span>|</span><label class="collapse" for="c-41321431">[-]</label><label class="expand" for="c-41321431">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll add my attempt here: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;dvdkon&#x2F;pdb2hpp" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;dvdkon&#x2F;pdb2hpp</a><p>Its output is kind of ugly, limited by limitations of either the PDB format or Microsoft&#x27;s terrible parser library, but I&#x27;ve successfully used it for calling functions from a proprietary DLL.</div><br/></div></div><div id="41322513" class="c"><input type="checkbox" id="c-41322513" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#41321211">root</a><span>|</span><a href="#41321290">parent</a><span>|</span><a href="#41321431">prev</a><span>|</span><a href="#41322371">next</a><span>|</span><label class="collapse" for="c-41322513">[-]</label><label class="expand" for="c-41322513">[1 more]</label></div><br/><div class="children"><div class="content">The idea is more that you use the LLM for quick guesses about behaviour&#x2F;names and so on rather than actually relying on it for reverse engineering as per se.</div><br/></div></div></div></div><div id="41322371" class="c"><input type="checkbox" id="c-41322371" checked=""/><div class="controls bullet"><span class="by">debatem1</span><span>|</span><a href="#41321211">parent</a><span>|</span><a href="#41321290">prev</a><span>|</span><a href="#41321807">next</a><span>|</span><label class="collapse" for="c-41322371">[-]</label><label class="expand" for="c-41322371">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a tool a few years ago which automatically generated and inserted type-aware fuzzers for C APIs from DWARF info: <a href="https:&#x2F;&#x2F;github.com&#x2F;intel&#x2F;fffc">https:&#x2F;&#x2F;github.com&#x2F;intel&#x2F;fffc</a><p>Generating headers and also mutators that you could then modify to meet type constraints was part of that.<p>Edit: just to add onto the LLM side, I can see this labelling anonymous structs or similar but I&#x27;m not sure that&#x27;s a good idea. What might be interesting would be to try to get an LLM to verbalize&#x2F;summarize known type constraints for documentation purposes.</div><br/></div></div><div id="41321807" class="c"><input type="checkbox" id="c-41321807" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#41321211">parent</a><span>|</span><a href="#41322371">prev</a><span>|</span><a href="#41321468">next</a><span>|</span><label class="collapse" for="c-41321807">[-]</label><label class="expand" for="c-41321807">[1 more]</label></div><br/><div class="children"><div class="content">pahole gives you compilable C header files from ELF DWARF information. LLMs seems irrelevant here: either your header files have all the types exported from the executable correctly so they are usable with the original values, or they aren&#x27;t correct&#x2F;complete and having an LLM make up some more doesn&#x27;t help.<p>Ghidra also has native functionality to export its data structures, which it can create from DWARF structures (Right click -&gt; Export to C header).</div><br/></div></div><div id="41321468" class="c"><input type="checkbox" id="c-41321468" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41321211">parent</a><span>|</span><a href="#41321807">prev</a><span>|</span><a href="#41322289">next</a><span>|</span><label class="collapse" for="c-41321468">[-]</label><label class="expand" for="c-41321468">[1 more]</label></div><br/><div class="children"><div class="content">Tangentially, I&#x27;ve considered generating debugging symbols for the exported object files, based on the contents of the Ghidra database, in order to improve the debugging experience when using them.<p>I haven&#x27;t implemented that feature yet because so far I&#x27;ve managed to get by without it. Also, it sounds like a rather deep rabbit hole to fall into and the one I&#x27;m currently inside of is big enough as it is.</div><br/></div></div></div></div><div id="41322289" class="c"><input type="checkbox" id="c-41322289" checked=""/><div class="controls bullet"><span class="by">pinum</span><span>|</span><a href="#41321211">prev</a><span>|</span><a href="#41321786">next</a><span>|</span><label class="collapse" for="c-41322289">[-]</label><label class="expand" for="c-41322289">[2 more]</label></div><br/><div class="children"><div class="content">This looks fantastic and is relevant to some game modding ideas I&#x27;ve had. I love your blog series about decompiling Tenchu too. Thank you for releasing this stuff!</div><br/><div id="41322983" class="c"><input type="checkbox" id="c-41322983" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41322289">parent</a><span>|</span><a href="#41321786">next</a><span>|</span><label class="collapse" for="c-41322983">[-]</label><label class="expand" for="c-41322983">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>I should get back to this project one of these days. I did one version tracking session too many in a row and had to take a break, plus that delinking side-quest keeps snowballing out of control.</div><br/></div></div></div></div><div id="41321786" class="c"><input type="checkbox" id="c-41321786" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#41322289">prev</a><span>|</span><a href="#41321117">next</a><span>|</span><label class="collapse" for="c-41321786">[-]</label><label class="expand" for="c-41321786">[4 more]</label></div><br/><div class="children"><div class="content">So is this a completely fool-proof process? Ie i&#x27;m asking if it&#x27;s guaranteed to succeed or if the analysis is conservative. Ie if some piece&#x2F;datum&#x2F;feature is missing in the ELF then the delinking will fail?</div><br/><div id="41322090" class="c"><input type="checkbox" id="c-41322090" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41321786">parent</a><span>|</span><a href="#41322917">next</a><span>|</span><label class="collapse" for="c-41322090">[-]</label><label class="expand" for="c-41322090">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So is this a completely fool-proof process?<p>That&#x27;s... complicated to answer.<p>My analyzers rely on an accurate Ghidra database, at least for the parts you want to export. While I&#x27;ve put a fair amount of effort into logging the various issues than can crop up which require fixing, they can&#x27;t see what isn&#x27;t there. In particular, missing references and truncation of variables won&#x27;t be detected and will result in exotic undefined behavior.<p>There are ways to track down some of these issues. The best I&#x27;ve found so far is to relink the executable at a different base address and making sure that the original program&#x27;s address ranges are unmapped ; that should lead to segmentation faults when absolute relocation spots are missed that can be debugged (but that only works if your target has a MMU). Truncated variables are very tricky to troubleshoot (especially if you don&#x27;t suspect it) since it&#x27;s the memory following the truncated variable that gets corrupted. An integer that is mistaken for a pointer can also be very tricky to track down, as the integer&#x27;s value will vary depending on the address the target symbol gets, leading to erratic program behavior (that&#x27;s especially an issue for a program loaded very low in the address space).<p>That being said, if the Ghidra database is accurate enough <i>and</i> you export back to the same object file format used originally <i>and</i> you subsequently use it onto the same platform with the same toolchain, you <i>can</i> delink megabytes of program code and data successfully. I consider that if the linker did it, then it should be possible to undo it.<p>Now, if you start cross-delinking to something that doesn&#x27;t match the original program&#x27;s platform and toolchain (like delinking from a Linux i386 ELF executable into a COFF object file and using it with a i386 Windows toolchain) then it&#x27;s another story. If the exporter can express the relocations then you might end up with a working relocatable object file, but you&#x27;ll still have potentially mismatched ABIs to contend with. It can be done, but that&#x27;s not something I would recommend as a first project.<p>TL;DR Depending on what you do and the accuracy of the Ghidra database, it can range from &quot;it just works&quot; all the way to praying to Cthulhu for mercy.</div><br/></div></div><div id="41322917" class="c"><input type="checkbox" id="c-41322917" checked=""/><div class="controls bullet"><span class="by">archgoon</span><span>|</span><a href="#41321786">parent</a><span>|</span><a href="#41322090">prev</a><span>|</span><a href="#41321117">next</a><span>|</span><label class="collapse" for="c-41322917">[-]</label><label class="expand" for="c-41322917">[2 more]</label></div><br/><div class="children"><div class="content">Based on what it seems that you&#x27;re asking, it is not, and cannot be, a foolproof process. consider<p><pre><code>  int getSpecialArrayElement(char *array, uint64 key) {
     i = computeOffset(key);
     return array[i];
  }
</code></pre>
Compute offset can be arbitrarily complex (and probably deliberately hard to analyze if obfuscation is desired). There&#x27;s nothing that prevents this function from accessing arbitrary locations in memory. You don&#x27;t know if this will be accessing symbols that are already defined in memory by the linker short of exhaustively trying all possible inputs (and computeOffset may have turing traps for that).</div><br/><div id="41323283" class="c"><input type="checkbox" id="c-41323283" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41321786">root</a><span>|</span><a href="#41322917">parent</a><span>|</span><a href="#41321117">next</a><span>|</span><label class="collapse" for="c-41323283">[-]</label><label class="expand" for="c-41323283">[1 more]</label></div><br/><div class="children"><div class="content">During delinking we only really care about relocation spots, the actual algorithms of the program are mostly irrelevant.<p>Assuming it doesn&#x27;t reference any other global data and only contains relative jumps and branches, <i>computeOffset()</i> won&#x27;t have any mandatory relocation spots [1] and therefore can be put into an object file as-is. Similarly, <i>getSpecialArrayElement()</i> would only have a relocation for the address of <i>computeOffset()</i> because <i>array</i> is supplied as a parameter, not as a global variable. Furthermore, any data allocated on the heap is transparent during delinking.<p>From my experience, &quot;normal&quot; everyday programs written in high-level languages typically don&#x27;t contain nasty surprises while trying to delink them. That is not to say that obfuscated programs won&#x27;t cause problems, but I haven&#x27;t attempted delinking one so far [2].<p>[1] PC-relative relocations can be trimmed if the source and target are part of the same continuous address range being exported, because in that case the value won&#x27;t change.<p>[2] I do have a pet peeve against developers who cast raw integer constants as pointers on MIPS, because the code sequence may be different than what the HI16&#x2F;LO16 relocation pattern can tolerate and it requires binary patching to fix up (LUI&#x2F;ADDIU versus LUI&#x2F;ORI). If the integer was a multiple of 65536, is passed directly as a parameter to a function call and the compiler elided the second instruction then it can&#x27;t be fixed in place and must be worked around some way, if the original value can&#x27;t be kept (like the address for the scratchpad on the PlayStation for example, as long as you stay on that platform or can map memory there).</div><br/></div></div></div></div></div></div><div id="41321117" class="c"><input type="checkbox" id="c-41321117" checked=""/><div class="controls bullet"><span class="by">toomuchtodo</span><span>|</span><a href="#41321786">prev</a><span>|</span><a href="#41320751">next</a><span>|</span><label class="collapse" for="c-41321117">[-]</label><label class="expand" for="c-41321117">[2 more]</label></div><br/><div class="children"><div class="content">Previous:<p><i>Show HN: A Ghidra extension that turns programs back into object files </i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38852362">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38852362</a> - Jan 2024 (4 comments)</div><br/></div></div><div id="41320751" class="c"><input type="checkbox" id="c-41320751" checked=""/><div class="controls bullet"><span class="by">bigdict</span><span>|</span><a href="#41321117">prev</a><span>|</span><label class="collapse" for="c-41320751">[-]</label><label class="expand" for="c-41320751">[3 more]</label></div><br/><div class="children"><div class="content">See also: objcopy.<p><a href="https:&#x2F;&#x2F;sourceware.org&#x2F;binutils&#x2F;docs&#x2F;binutils&#x2F;objcopy.html" rel="nofollow">https:&#x2F;&#x2F;sourceware.org&#x2F;binutils&#x2F;docs&#x2F;binutils&#x2F;objcopy.html</a></div><br/><div id="41321384" class="c"><input type="checkbox" id="c-41321384" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#41320751">parent</a><span>|</span><a href="#41321753">next</a><span>|</span><label class="collapse" for="c-41321384">[-]</label><label class="expand" for="c-41321384">[1 more]</label></div><br/><div class="children"><div class="content">While objcopy can do many things, it can&#x27;t undo the work of the linker. If relocations aren&#x27;t unapplied and a new relocation table generated, these spots inside the new object file will reference the original program&#x27;s address space, leading to some exotic undefined behavior.<p>Delinking is a subject with very few resources online, but there are a couple of other tools for it out there:<p><pre><code>  - https:&#x2F;&#x2F;github.com&#x2F;endrazine&#x2F;wcc

  - https:&#x2F;&#x2F;github.com&#x2F;jonwil&#x2F;unlinkerida

  - https:&#x2F;&#x2F;github.com&#x2F;jnider&#x2F;delinker</code></pre></div><br/></div></div></div></div></div></div></div></div></div></body></html>