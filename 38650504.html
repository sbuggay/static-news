<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702717273396" as="style"/><link rel="stylesheet" href="styles.css?v=1702717273396"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.youtube.com/watch?v=hBjQ3HqCfxs">Bug in my code from compiler optimization [video]</a> <span class="domain">(<a href="https://www.youtube.com">www.youtube.com</a>)</span></div><div class="subtext"><span>MiguelX413</span> | <span>14 comments</span></div><br/><div><div id="38652233" class="c"><input type="checkbox" id="c-38652233" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#38662479">next</a><span>|</span><label class="collapse" for="c-38652233">[-]</label><label class="expand" for="c-38652233">[7 more]</label></div><br/><div class="children"><div class="content">A simplified recap of the video:<p>He wants code:<p><pre><code>  If x then return y
</code></pre>
With y an unsafe expression, and x always true if y can be evaluated without invoking undefined behaviour.<p>He wrote it as:<p><pre><code>  return x.then_some(y)
</code></pre>
This always calculates y, but throws it away if x is false.<p>By calculating y, he accidentaly gives a proof to the compiler that x must be true.  The proof is of course invalid, but as y is unsafe, the compiler trusts him nevertheless.  So the &#x27;if&#x27; gets optimized away.</div><br/><div id="38662665" class="c"><input type="checkbox" id="c-38662665" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38652233">parent</a><span>|</span><a href="#38661829">next</a><span>|</span><label class="collapse" for="c-38662665">[-]</label><label class="expand" for="c-38662665">[1 more]</label></div><br/><div class="children"><div class="content">As others pointed out, there also exists `bool::then` that always accepts a closure and doesn&#x27;t have this issue. In fact both `bool::then` and `bool::then_some` are originated from a single RFC [1], and people unanimously agreed on `bool::then` but not `bool::then_some`, so the latter spun off its own issue [2]. It seems that `bool::then_some` was eventually accepted mainly due to the lack of better alternatives---there were enough people wanting the value form and other pairs of method names were considered better.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2757">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2757</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;64260">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;64260</a></div><br/></div></div><div id="38661829" class="c"><input type="checkbox" id="c-38661829" checked=""/><div class="controls bullet"><span class="by">EdSchouten</span><span>|</span><a href="#38652233">parent</a><span>|</span><a href="#38662665">prev</a><span>|</span><a href="#38662462">next</a><span>|</span><label class="collapse" for="c-38661829">[-]</label><label class="expand" for="c-38661829">[1 more]</label></div><br/><div class="children"><div class="content">In that sense .then_some() is sort of a footgun. Compared to a regular if-statement it invites people to write code in a less efficient (and in this case an incorrect manner). It could just have taken a closure instead.<p>Edit: it turns out there’s also a .then() that does exactly that.</div><br/></div></div><div id="38662462" class="c"><input type="checkbox" id="c-38662462" checked=""/><div class="controls bullet"><span class="by">perryizgr8</span><span>|</span><a href="#38652233">parent</a><span>|</span><a href="#38661829">prev</a><span>|</span><a href="#38657737">next</a><span>|</span><label class="collapse" for="c-38662462">[-]</label><label class="expand" for="c-38662462">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get how changing to if else fixes this. The compiler can still reason that the condition is always going to be true (and if it isn&#x27;t that is undefined behavior, so f it). And then it will elide the comparison. Same result. The compiler bug here is that for some reason it is not able to apply a valid (lol) optimisation to if else statements. The author should not rely on this. Compiler authors will eventually fix this bug and his game will break again.</div><br/></div></div><div id="38657737" class="c"><input type="checkbox" id="c-38657737" checked=""/><div class="controls bullet"><span class="by">salawat</span><span>|</span><a href="#38652233">parent</a><span>|</span><a href="#38662462">prev</a><span>|</span><a href="#38662479">next</a><span>|</span><label class="collapse" for="c-38657737">[-]</label><label class="expand" for="c-38657737">[3 more]</label></div><br/><div class="children"><div class="content">...That sounds like the compiler writer taking undue liberties, and the programmer assuming the machine is capable of reading intent.<p>Sounds like a great learning experience imo.</div><br/><div id="38659760" class="c"><input type="checkbox" id="c-38659760" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#38652233">root</a><span>|</span><a href="#38657737">parent</a><span>|</span><a href="#38662479">next</a><span>|</span><label class="collapse" for="c-38659760">[-]</label><label class="expand" for="c-38659760">[2 more]</label></div><br/><div class="children"><div class="content">Not really.  An example that explicitly crashes instead of triggering undefined behavior:<p><pre><code>  If n!=0 return 1&#x2F;n
</code></pre>
Is well behaved: Division by zero wont happen.<p><pre><code>  z=1&#x2F;n
  If n!=0 return z
</code></pre>
Is not well behaved.  It will crash when n=0.  What the compiler does is take the existence of z as a proof that n can&#x27;t be 0, and optimize the if away:<p><pre><code>  z=1&#x2F;n
  return z
</code></pre>
Just like division by 0, undefined behaviour (UB) is not allowed.  The difference is:  UB might crash or give a nonsensical result.  You can&#x27;t tell beforehand.  Different versions of a compiler might make different choices of crash vs nonsense. Until recently, the author calculated nonsense, and threw it away, but that was accidental.  It might have crashed too.<p>C had a lot of UB that gets thrown away, until some minor shift in optimizations changes it to a crasher. Compare it to an insanely sharp knife: Powerfull, but the slightest error might take off your fingers, it&#x27;s very hard to know if something is or is not an error, and errors mostly dont cut if your fingers, until surprise surprise they do.<p>Rust is much better: only unsafe code behaves like C&#x27;s crazy knife.  Only when you use unsafe, the rust guarantees go out of the window, because that&#x27;s what the programmer explicitly asked.</div><br/><div id="38662620" class="c"><input type="checkbox" id="c-38662620" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38652233">root</a><span>|</span><a href="#38659760">parent</a><span>|</span><a href="#38662479">next</a><span>|</span><label class="collapse" for="c-38662620">[-]</label><label class="expand" for="c-38662620">[1 more]</label></div><br/><div class="children"><div class="content">When you&#x27;re learning to program, teachers will often tell you &quot;The computer is dumb; it will do exactly what you say, and it can&#x27;t read your intent.&quot; Implicitly, I think most people assume the same of compilers: they&#x27;re dumb, and will translate an unconditional division as an unconditional division, even when it would crash.<p>Instead, compilers seemingly try to make insights into the intent or true meaning of your code, often inaccurately, and change it using ad-hoc unintuitive rules as justification (those being the rules of undefined behavior, and what assumptions the authors are and aren&#x27;t allowed to make about your code). I know they aren&#x27;t actually reading your intent; it&#x27;s just the result of many, many passes that each make seemingly reasonable assumptions, which together may add up to a set of unreasonable ones.<p>&gt; because that&#x27;s what the programmer explicitly asked.<p>No, the programmer didn&#x27;t explicitly ask for their check to be deleted, even with &quot;unsafe&quot; written. There is no request written anywhere. At most, you can say they <i>implied</i> they wanted it by invoking undefined behavior. Probably, though, they just made a mistake, or assumed that behavior was defined when it wasn&#x27;t (e.g. they may have thought division corresponds to a hardware division instruction, modulo optimizations like right shifting for division by 2, constant folding division by 1, etc.)</div><br/></div></div></div></div></div></div></div></div><div id="38662479" class="c"><input type="checkbox" id="c-38662479" checked=""/><div class="controls bullet"><span class="by">SeanAnderson</span><span>|</span><a href="#38652233">prev</a><span>|</span><a href="#38662425">next</a><span>|</span><label class="collapse" for="c-38662479">[-]</label><label class="expand" for="c-38662479">[1 more]</label></div><br/><div class="children"><div class="content">Note that the Rust docs explicitly discourage using `then_some` in the manner described in this video.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;beta&#x2F;std&#x2F;primitive.bool.html#method.then_some" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;beta&#x2F;std&#x2F;primitive.bool.html#metho...</a><p>&gt; Arguments passed to then_some are eagerly evaluated; if you are passing the result of a function call, it is recommended to use then, which is lazily evaluated.</div><br/></div></div><div id="38662425" class="c"><input type="checkbox" id="c-38662425" checked=""/><div class="controls bullet"><span class="by">nliang86</span><span>|</span><a href="#38662479">prev</a><span>|</span><a href="#38662041">next</a><span>|</span><label class="collapse" for="c-38662425">[-]</label><label class="expand" for="c-38662425">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.videogist.co&#x2F;videos&#x2F;insane-bug-in-my-code-from-compiler-optimization-2236" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.videogist.co&#x2F;videos&#x2F;insane-bug-in-my-code-from-c...</a></div><br/></div></div><div id="38662041" class="c"><input type="checkbox" id="c-38662041" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#38662425">prev</a><span>|</span><a href="#38661935">next</a><span>|</span><label class="collapse" for="c-38662041">[-]</label><label class="expand" for="c-38662041">[2 more]</label></div><br/><div class="children"><div class="content">The big questions is why clippy (standard linter) didn&#x27;t catch this. It will complain about expensive expressions in a `.then_some()` because it&#x27;s eager, why not unsafe?</div><br/><div id="38662707" class="c"><input type="checkbox" id="c-38662707" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38662041">parent</a><span>|</span><a href="#38661935">next</a><span>|</span><label class="collapse" for="c-38662707">[-]</label><label class="expand" for="c-38662707">[1 more]</label></div><br/><div class="children"><div class="content">Clippy would only complain about expensive expressions when it can prove that the alternative would be always better than the original (for example, `or_fun_call` [1]). It is not impossible to measure the cost of given expression to suggest that, but that would increase a risk of false positives. The OP has the same challenge---this kind of range analysis can only occur (and currently does occur) much later than Clippy.<p>[1] <a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;master&#x2F;index.html#&#x2F;or_fun_call" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;master&#x2F;index.html#&#x2F;o...</a></div><br/></div></div></div></div><div id="38661935" class="c"><input type="checkbox" id="c-38661935" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#38662041">prev</a><span>|</span><label class="collapse" for="c-38661935">[-]</label><label class="expand" for="c-38661935">[2 more]</label></div><br/><div class="children"><div class="content">You can write this in safe-Rust, with a match. There are only 8 variants, and while it&#x27;s a bit tedious¹, Rust will optimize it to the same code as if you had done a from_raw construction … without the possibility of UB.²<p>¹(but there has to be a crate for this)<p>²<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;W55W1GxvY" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;W55W1GxvY</a></div><br/><div id="38662771" class="c"><input type="checkbox" id="c-38662771" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#38661935">parent</a><span>|</span><label class="collapse" for="c-38662771">[-]</label><label class="expand" for="c-38662771">[1 more]</label></div><br/><div class="children"><div class="content">I wish this wasn&#x27;t downvoted as for me its the right answer.<p>unsafe in rust is a blank cheque for the compiler.  Doing anything complicated in it is almost guaranteed to have UB somewhere.  You decide to disable safety.<p>If possible, write the safe but tedious code.  Then measure.  Only when you&#x27;re sure unsafe is worth it should you take out the big cannon.  Write a km of comments proving this code needs and deserves unsafe.  Writing the tedious code is less time consuming than debugging the mess.<p>I wish the video author documented why he choose unsafe here. Was it measured and worth it in an older version of rust?  Or a folly of youth (which is fine, as long as you learn from it, been there done that paid the time debugging my stupidity)</div><br/></div></div></div></div></div></div></div></div></div></body></html>