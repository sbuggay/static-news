<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738054866593" as="style"/><link rel="stylesheet" href="styles.css?v=1738054866593"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://martin.kleppmann.com/2015/11/05/database-inside-out-at-oredev.html">Turning the Database Inside-Out</a> <span class="domain">(<a href="https://martin.kleppmann.com">martin.kleppmann.com</a>)</span></div><div class="subtext"><span>andection</span> | <span>20 comments</span></div><br/><div><div id="42849518" class="c"><input type="checkbox" id="c-42849518" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#42849626">next</a><span>|</span><label class="collapse" for="c-42849518">[-]</label><label class="expand" for="c-42849518">[8 more]</label></div><br/><div class="children"><div class="content">We did this style on top of plain MSSQL. Each event would have a SQL table which is the primary storage. Then we have workers that listens to new data in tables and updates projections we needed. (Sometimes DB triggers but mostly async workers.)<p>The main issue is &quot;listening to new data in a SQL table&quot;. I wrote this code to achieve it in MSSQL (perhaps it is somehow built into postgres?): <a href="https:&#x2F;&#x2F;github.com&#x2F;vippsas&#x2F;mssql-changefeed">https:&#x2F;&#x2F;github.com&#x2F;vippsas&#x2F;mssql-changefeed</a><p>In my experience this approach is beautiful; as Martins says, our backend code is mostly stateless and functional these days, why have mutable objects in the DB? And the approach is extremely useful for dry-running business logic etc<p>But we didn&#x27;t like the prospect of adopting Kafka wholesale. Having all the data in a SQL DB is extremely convenient for debugging, and since we already used SQL it was a smaller change that was done first where it made most sense and then spread out.<p>It would be great with more DB features targeting this style. Explicit partition event tables (kafka-in-SQL), and writing a projection simply as a SQL query which is inverted into an async trigger by the DB would be awesome. (MSSQL has indexed views, but it cannot be done online...)<p>Materialize is the DB I know about in this territory.</div><br/><div id="42849810" class="c"><input type="checkbox" id="c-42849810" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#42849518">parent</a><span>|</span><a href="#42849619">next</a><span>|</span><label class="collapse" for="c-42849810">[-]</label><label class="expand" for="c-42849810">[2 more]</label></div><br/><div class="children"><div class="content">I use the architecture you described as <i>the</i> go-to architecture for most of so called &quot;business&quot; applications (with PostgreSQL as dbms though).<p>The missing pieces are:<p>- incremental materialized view maintenance<p>- (bi)temporal primary and foreign keys (upcoming in Pg18)<p>Lately I found out about DBSP and Feldera which looks very promising as it is based on sound theory: <a href="https:&#x2F;&#x2F;github.com&#x2F;feldera&#x2F;feldera?tab=readme-ov-file#-theory">https:&#x2F;&#x2F;github.com&#x2F;feldera&#x2F;feldera?tab=readme-ov-file#-theor...</a></div><br/><div id="42849919" class="c"><input type="checkbox" id="c-42849919" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#42849518">root</a><span>|</span><a href="#42849810">parent</a><span>|</span><a href="#42849619">next</a><span>|</span><label class="collapse" for="c-42849919">[-]</label><label class="expand" for="c-42849919">[1 more]</label></div><br/><div class="children"><div class="content">Great link, thanks!<p>What do you do postgres for consuming old events and smoothly transitioning to consuming new events? Anything like an event ID allocated at commit time that is usable? As I talk about in sibling comment..</div><br/></div></div></div></div><div id="42849619" class="c"><input type="checkbox" id="c-42849619" checked=""/><div class="controls bullet"><span class="by">hans_castorp</span><span>|</span><a href="#42849518">parent</a><span>|</span><a href="#42849810">prev</a><span>|</span><a href="#42849633">next</a><span>|</span><label class="collapse" for="c-42849619">[-]</label><label class="expand" for="c-42849619">[4 more]</label></div><br/><div class="children"><div class="content">&gt; perhaps it is somehow built into postgres?<p>Postgres has a built-in listen&#x2F;notify mechanism. The problem with that is, that it doesn&#x27;t guarantee delivery and if no process is listening, notifications will be lost.<p>Most solutions that need something like that use &quot;logical decoding&quot; these days. That&#x27;s the built-in change data capture exposed as a public API as part of the logical replication.</div><br/><div id="42849795" class="c"><input type="checkbox" id="c-42849795" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#42849518">root</a><span>|</span><a href="#42849619">parent</a><span>|</span><a href="#42849633">next</a><span>|</span><label class="collapse" for="c-42849795">[-]</label><label class="expand" for="c-42849795">[3 more]</label></div><br/><div class="children"><div class="content">Yes, listen&#x2F;notify is something very different. We would often write new projections that consumes events from years back and until today.<p>You want sequence numbers that indicate the event&#x27;s position in a partitioned log.<p>Something like &quot;int identity&quot; except that the int is assigned during commit, so that you have guarantee that if you see IDs 5 and 7, then 6 will never show up, so that each consumer can store a cursor of its progress of consuming the table which is safe against inserts.<p>I was hoping to do it using CDC, but Microsoft SQL has a minimum 1 minute delay on CDC which destroys any live data usecase. Perhaps postgres allows listening to the replication log with lower latency?</div><br/><div id="42849841" class="c"><input type="checkbox" id="c-42849841" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#42849518">root</a><span>|</span><a href="#42849795">parent</a><span>|</span><a href="#42849633">next</a><span>|</span><label class="collapse" for="c-42849841">[-]</label><label class="expand" for="c-42849841">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Perhaps postgres allows listening to the replication log with lower latency?<p>Yes, I think that&#x27;s what the &quot;logical decoding&quot; referred to. Postgres can emit a &quot;logical&quot; version of the WAL (something with a stable spec writtten down so that other services can stream and decode it). My understanding was that &quot;logical replication&quot; was designed for low latency situations like creating read replicas.<p>I haven&#x27;t heard of the logical log being preserved for &quot;years back&quot; but that&#x27;s an interesting case...</div><br/><div id="42849926" class="c"><input type="checkbox" id="c-42849926" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#42849518">root</a><span>|</span><a href="#42849841">parent</a><span>|</span><a href="#42849633">next</a><span>|</span><label class="collapse" for="c-42849926">[-]</label><label class="expand" for="c-42849926">[1 more]</label></div><br/><div class="children"><div class="content">That is OK, guess I would write a job to listen to the logical WAL and use it to do an update that writes an event sequence number.</div><br/></div></div></div></div></div></div></div></div><div id="42849633" class="c"><input type="checkbox" id="c-42849633" checked=""/><div class="controls bullet"><span class="by">fzeindl</span><span>|</span><a href="#42849518">parent</a><span>|</span><a href="#42849619">prev</a><span>|</span><a href="#42849626">next</a><span>|</span><label class="collapse" for="c-42849633">[-]</label><label class="expand" for="c-42849633">[1 more]</label></div><br/><div class="children"><div class="content">I have implemented something similar (updating projection from background and serving the projection automatically via REST) and wrote a high-Level article about it <a href="https:&#x2F;&#x2F;www.fabianzeindl.com&#x2F;posts&#x2F;the-api-database-architecture" rel="nofollow">https:&#x2F;&#x2F;www.fabianzeindl.com&#x2F;posts&#x2F;the-api-database-architec...</a></div><br/></div></div></div></div><div id="42849626" class="c"><input type="checkbox" id="c-42849626" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#42849518">prev</a><span>|</span><a href="#42848687">next</a><span>|</span><label class="collapse" for="c-42849626">[-]</label><label class="expand" for="c-42849626">[8 more]</label></div><br/><div class="children"><div class="content">The thing I always get stuck on with these techniques is, how do you handle transactions which perform validations&#x2F;enforce invariants on data when you’re just writing writes to a log and computing materialized views down the line? How can you do essentially, an “add item to shopping cart” if for example, users can only have max 10 items and so you need to validate that there aren’t already 10 items in the cart?</div><br/><div id="42850223" class="c"><input type="checkbox" id="c-42850223" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#42849626">parent</a><span>|</span><a href="#42849858">next</a><span>|</span><label class="collapse" for="c-42850223">[-]</label><label class="expand" for="c-42850223">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking about this as well as these streaming things become more popular. Would you write add-to-cart events and those trigger add-cart events; the latter containing an valid field which will become false after the 10th add-cart. So after that you remove-from-cart which triggers add-cart which then becomes valid again &lt; 11 items? And transactions similarly roll back by running the inverse of what happened after the transaction started. I&#x27;m just thinking out loud. I understand you probably wouldn&#x27;t use this for that, but let&#x27;s have some fun shall we?</div><br/></div></div><div id="42849858" class="c"><input type="checkbox" id="c-42849858" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42849626">parent</a><span>|</span><a href="#42850223">prev</a><span>|</span><a href="#42849857">next</a><span>|</span><label class="collapse" for="c-42849858">[-]</label><label class="expand" for="c-42849858">[1 more]</label></div><br/><div class="children"><div class="content">This kind of thing only works if your whole universe belongs to your database.<p>Transactions and conditional-updates work smoothly if it&#x27;s your customer browsing your shop in your database - up to a point.<p>But I usually end up with partner integrations where those techniques don&#x27;t work.  For instance, partners will just tell you true facts about what happened - a customer quit, or a product was removed from the catalogue.  Your system can&#x27;t reject these just because your Db can&#x27;t or won&#x27;t accept that state change.</div><br/></div></div><div id="42849857" class="c"><input type="checkbox" id="c-42849857" checked=""/><div class="controls bullet"><span class="by">adamcharnock</span><span>|</span><a href="#42849626">parent</a><span>|</span><a href="#42849858">prev</a><span>|</span><a href="#42849686">next</a><span>|</span><label class="collapse" for="c-42849857">[-]</label><label class="expand" for="c-42849857">[1 more]</label></div><br/><div class="children"><div class="content">This all sounds to me very close to the event-sourcing&#x2F;CQRS&#x2F;DDD area of thinking. In which case you look at it in two parts:<p>- Event firing: Here is where you fire an event saying that the thing has happened (i.e. item_added_to_cart, not add_item_to_cart). Crucially, this event states the thing <i>has</i> happened. This isn&#x27;t a request, it is a past-tense statement of fact, which is oddly important. It is therefore at this point where you must do the validation.<p>- Event handing: Here you receive information about an event that has already happened. You don&#x27;t get to argue about it, it <i>has happened</i>. So you either have to handle it, or accept you have an incomplete view of reality. So perhaps you have to accept that the cart can have more than 10 items in some circumstances, in which case you prompt the use to correct the problem before checking out.<p>In fact, this is typically how it goes with this kind of eventual-consistency. First fire the event that is as valid as possible. Then when handing an &#x27;invalid&#x27; event accept that its just got to happen (cart has 11 items now), then prompt the user fix it (if there is one).<p>Not sure how helpful this is here, but thought it a useful perspective.</div><br/></div></div><div id="42849686" class="c"><input type="checkbox" id="c-42849686" checked=""/><div class="controls bullet"><span class="by">nejsjsjsbsb</span><span>|</span><a href="#42849626">parent</a><span>|</span><a href="#42849857">prev</a><span>|</span><a href="#42849647">next</a><span>|</span><label class="collapse" for="c-42849686">[-]</label><label class="expand" for="c-42849686">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t use it for that sort of thing.<p>But if you did you&#x27;d need an aggregatable (commutative) rule.<p>Like you can&#x27;t aggregate P99 metrics. (To see why, it is similar to why you can&#x27;t aggregate P50. You can&#x27;t because a median of a bunch of medians is not the total median)<p>So you measure number of requests of latency &lt; 100ms and number of requests. Both of these aggregate nicely. Divide one by the other. Now you get Pxx for 100ms. So if your P99 target was 100ms you set your 100ms target to 99%.<p>Anyway you&#x27;d need something like this for your shopping cart. It is probably doable as a top 10 (and anything else gets abandoned). Top 10 is aggregatable. You just need an order. Could be added to cart time or price.</div><br/></div></div><div id="42849647" class="c"><input type="checkbox" id="c-42849647" checked=""/><div class="controls bullet"><span class="by">cwalv</span><span>|</span><a href="#42849626">parent</a><span>|</span><a href="#42849686">prev</a><span>|</span><a href="#42848687">next</a><span>|</span><label class="collapse" for="c-42849647">[-]</label><label class="expand" for="c-42849647">[3 more]</label></div><br/><div class="children"><div class="content">You write the &#x27;add item&#x27; event regardless, and when building the &#x27;cart&#x27; view you handle the limit.</div><br/><div id="42850243" class="c"><input type="checkbox" id="c-42850243" checked=""/><div class="controls bullet"><span class="by">RedShift1</span><span>|</span><a href="#42849626">root</a><span>|</span><a href="#42849647">parent</a><span>|</span><a href="#42849730">next</a><span>|</span><label class="collapse" for="c-42850243">[-]</label><label class="expand" for="c-42850243">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like an easy way to run out of storage space</div><br/></div></div><div id="42849730" class="c"><input type="checkbox" id="c-42849730" checked=""/><div class="controls bullet"><span class="by">philbo</span><span>|</span><a href="#42849626">root</a><span>|</span><a href="#42849647">parent</a><span>|</span><a href="#42850243">prev</a><span>|</span><a href="#42848687">next</a><span>|</span><label class="collapse" for="c-42849730">[-]</label><label class="expand" for="c-42849730">[1 more]</label></div><br/><div class="children"><div class="content">Alternatively &quot;invalid cart&quot; could itself become an event.</div><br/></div></div></div></div></div></div><div id="42848687" class="c"><input type="checkbox" id="c-42848687" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#42849626">prev</a><span>|</span><a href="#42848966">next</a><span>|</span><label class="collapse" for="c-42848687">[-]</label><label class="expand" for="c-42848687">[1 more]</label></div><br/><div class="children"><div class="content">(2015)</div><br/></div></div><div id="42848966" class="c"><input type="checkbox" id="c-42848966" checked=""/><div class="controls bullet"><span class="by">swyx</span><span>|</span><a href="#42848687">prev</a><span>|</span><a href="#42838567">next</a><span>|</span><label class="collapse" for="c-42848966">[-]</label><label class="expand" for="c-42848966">[1 more]</label></div><br/><div class="children"><div class="content">relatedly:  <a href="https:&#x2F;&#x2F;restate.dev&#x2F;blog&#x2F;every-system-is-a-log-avoiding-coordination-in-distributed-applications&#x2F;" rel="nofollow">https:&#x2F;&#x2F;restate.dev&#x2F;blog&#x2F;every-system-is-a-log-avoiding-coor...</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42813049">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42813049</a></div><br/></div></div><div id="42838567" class="c"><input type="checkbox" id="c-42838567" checked=""/><div class="controls bullet"><span class="by">jackeyzhang</span><span>|</span><a href="#42848966">prev</a><span>|</span><label class="collapse" for="c-42838567">[-]</label><label class="expand" for="c-42838567">[1 more]</label></div><br/><div class="children"><div class="content">Awesome，very useful</div><br/></div></div></div></div></div></div></div></body></html>