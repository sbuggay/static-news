<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717059669946" as="style"/><link rel="stylesheet" href="styles.css?v=1717059669946"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.nikolasgoebel.com/2024/05/28/duckdb-doesnt-need-data.html">DuckDB Doesn&#x27;t Need Data to Be a Database</a> <span class="domain">(<a href="https://www.nikolasgoebel.com">www.nikolasgoebel.com</a>)</span></div><div class="subtext"><span>tosh</span> | <span>97 comments</span></div><br/><div><div id="40520073" class="c"><input type="checkbox" id="c-40520073" checked=""/><div class="controls bullet"><span class="by">youngbum</span><span>|</span><a href="#40520542">next</a><span>|</span><label class="collapse" for="c-40520073">[-]</label><label class="expand" for="c-40520073">[9 more]</label></div><br/><div class="children"><div class="content">This is the exact reason we applied duckdb and duckdb-wasm into our service.<p>Our team is currently building a form builder SaaS. Most forms have responses under 1,000, but some of them would have more than 50,000 responses.<p>So, when user tries to explore through all responses in our “response sheet” feature,  usually they could be loaded via infinite scrolling (load as they scroll).<p>This uses up to 100MB of network in total if they had to get object arrays of 50,000 rows of data with 50 columns.<p>That was where duckdb kicked in : just store the responses into S3 as parquet file(in our case Cloudflare R2).<p>Then, load the whole file into duckdb-wasm into client. So when you scroll through sheet, instead of getting rows from server, you query rows from local db.<p>This made our sheet feature very efficient and consistent in terms of their speed and memory usage.<p>If network speed and memory is your bottle neck when loading “medium” data into your client, you definitely should give it a try.<p>PS. If you have any questions, feel free to ask!<p>PS. Our service is called Walla, check it out at <a href="https:&#x2F;&#x2F;home.walla.my&#x2F;en" rel="nofollow">https:&#x2F;&#x2F;home.walla.my&#x2F;en</a></div><br/><div id="40521248" class="c"><input type="checkbox" id="c-40521248" checked=""/><div class="controls bullet"><span class="by">tobilg</span><span>|</span><a href="#40520073">parent</a><span>|</span><a href="#40520350">next</a><span>|</span><label class="collapse" for="c-40521248">[-]</label><label class="expand" for="c-40521248">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m currently rewriting <a href="https:&#x2F;&#x2F;github.com&#x2F;ownstats&#x2F;ownstats">https:&#x2F;&#x2F;github.com&#x2F;ownstats&#x2F;ownstats</a> to this model, with a slight difference that I stream Arrow data from a AWS Lambda Function URL into DuckDB WASM in the frontend... Works great.<p>An improvement could be having pre-calculated DuckDB database files that are directly attached from the DuckDB WASM frontend, see <a href="https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;guides&#x2F;network_cloud_storage&#x2F;duckdb_over_https_or_s3.html" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;guides&#x2F;network_cloud_storage&#x2F;duckdb_...</a></div><br/></div></div><div id="40520350" class="c"><input type="checkbox" id="c-40520350" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#40520073">parent</a><span>|</span><a href="#40521248">prev</a><span>|</span><a href="#40520805">next</a><span>|</span><label class="collapse" for="c-40520350">[-]</label><label class="expand" for="c-40520350">[5 more]</label></div><br/><div class="children"><div class="content">&gt; you query rows from local db.<p>But the data is still remote (in object storage) right? If I understand correctly, this works then the first solution because parquet is a much more efficient format to query?</div><br/><div id="40520993" class="c"><input type="checkbox" id="c-40520993" checked=""/><div class="controls bullet"><span class="by">youngbum</span><span>|</span><a href="#40520073">root</a><span>|</span><a href="#40520350">parent</a><span>|</span><a href="#40521038">next</a><span>|</span><label class="collapse" for="c-40520993">[-]</label><label class="expand" for="c-40520993">[1 more]</label></div><br/><div class="children"><div class="content">My comment was a bit ambiguous. So, for sheets where we have to load all data, we would load all columns at once as a parquet file. (I will leave comment for the advantage of this approach in the next comment)<p>On the other hand, let’s say we have to draw a chart from a column. The type chart could be changed by user - they could be Pie charts, means, time series chart, median, table or even dot products. To achieve this goal, we would bring just a column from s3 using duckdb, and apply sql queries from client side, rendering adequate ui.</div><br/></div></div><div id="40521038" class="c"><input type="checkbox" id="c-40521038" checked=""/><div class="controls bullet"><span class="by">youngbum</span><span>|</span><a href="#40520073">root</a><span>|</span><a href="#40520350">parent</a><span>|</span><a href="#40520993">prev</a><span>|</span><a href="#40520664">next</a><span>|</span><label class="collapse" for="c-40521038">[-]</label><label class="expand" for="c-40521038">[1 more]</label></div><br/><div class="children"><div class="content">Long story short, you could either 1) query specific columns using s3-parquet-duckdb stack 2) load parquet file through network, and put it inside local duckdb-wasm instance so that you can do queries from client side</div><br/></div></div><div id="40520664" class="c"><input type="checkbox" id="c-40520664" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#40520073">root</a><span>|</span><a href="#40520350">parent</a><span>|</span><a href="#40521038">prev</a><span>|</span><a href="#40520805">next</a><span>|</span><label class="collapse" for="c-40520664">[-]</label><label class="expand" for="c-40520664">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s probably part of it, but also overhead from small requests and latency from round trips.</div><br/><div id="40521028" class="c"><input type="checkbox" id="c-40521028" checked=""/><div class="controls bullet"><span class="by">youngbum</span><span>|</span><a href="#40520073">root</a><span>|</span><a href="#40520664">parent</a><span>|</span><a href="#40520805">next</a><span>|</span><label class="collapse" for="c-40521028">[-]</label><label class="expand" for="c-40521028">[1 more]</label></div><br/><div class="children"><div class="content">Great point.<p>The advantages of loading “parquet” in “client side” are that 1) you only have to load data once from server and 2) the parquet files are surprisingly well zipped.<p>1) If you load once from server, no more small network requests while you are scrolling a table. Moreover, you could use the same duckdb table to visualize data or show raw data.<p>2) Sending whole data as a parquet file is faster through network than receiving data as json in response.</div><br/></div></div></div></div></div></div><div id="40520805" class="c"><input type="checkbox" id="c-40520805" checked=""/><div class="controls bullet"><span class="by">LunaSea</span><span>|</span><a href="#40520073">parent</a><span>|</span><a href="#40520350">prev</a><span>|</span><a href="#40520542">next</a><span>|</span><label class="collapse" for="c-40520805">[-]</label><label class="expand" for="c-40520805">[2 more]</label></div><br/><div class="children"><div class="content">You wouldn&#x27;t need DuckDB for this, you can simply store the parquet file in S3 and read them using a parquet NPM package.</div><br/><div id="40521070" class="c"><input type="checkbox" id="c-40521070" checked=""/><div class="controls bullet"><span class="by">youngbum</span><span>|</span><a href="#40520073">root</a><span>|</span><a href="#40520805">parent</a><span>|</span><a href="#40520542">next</a><span>|</span><label class="collapse" for="c-40521070">[-]</label><label class="expand" for="c-40521070">[1 more]</label></div><br/><div class="children"><div class="content">Exactly.<p>We have also tried arrow js or parquet wasm, and they were much lighter than duckdb wasm worker.<p>DuckDb however was useful in our case, considering our nature as form builder service, we had to provide features for statistics. It was cool to have OLAPS inside a webworker that could handle (as far as we checked) more than 100,000 rows at ease.</div><br/></div></div></div></div></div></div><div id="40520542" class="c"><input type="checkbox" id="c-40520542" checked=""/><div class="controls bullet"><span class="by">valval</span><span>|</span><a href="#40520073">prev</a><span>|</span><a href="#40520307">next</a><span>|</span><label class="collapse" for="c-40520542">[-]</label><label class="expand" for="c-40520542">[1 more]</label></div><br/><div class="children"><div class="content">Up until this point in my career, I&#x27;ve always wanted to incorporate some of these new age SQL tools into my workflows, but I just never seem to realize the utility.<p>What&#x27;s going on here that wouldn&#x27;t warrant building a processing pipeline that places the data in a more permanent data warehouse and create all the necessary views there?</div><br/></div></div><div id="40520307" class="c"><input type="checkbox" id="c-40520307" checked=""/><div class="controls bullet"><span class="by">mr-karan</span><span>|</span><a href="#40520542">prev</a><span>|</span><a href="#40519882">next</a><span>|</span><label class="collapse" for="c-40520307">[-]</label><label class="expand" for="c-40520307">[2 more]</label></div><br/><div class="children"><div class="content">Curious, why not use httpfs extension and directly read multiple parquet files as demonstrated here[1]?<p><pre><code>  SELECT *
    FROM read_parquet([
      &#x27;s3:&#x2F;&#x2F;bucket&#x2F;file1.parquet&#x27;,
      &#x27;s3:&#x2F;&#x2F;bucket&#x2F;file2.parquet&#x27;
    ]);
</code></pre>
[1]: <a href="https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;extensions&#x2F;httpfs&#x2F;s3api#reading" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;extensions&#x2F;httpfs&#x2F;s3api#reading</a></div><br/><div id="40520460" class="c"><input type="checkbox" id="c-40520460" checked=""/><div class="controls bullet"><span class="by">rcaught</span><span>|</span><a href="#40520307">parent</a><span>|</span><a href="#40519882">next</a><span>|</span><label class="collapse" for="c-40520460">[-]</label><label class="expand" for="c-40520460">[1 more]</label></div><br/><div class="children"><div class="content">The article shows dynamically fetching a database, with database level views, that dynamically fetch data.<p>You&#x27;re just showing a query that dynamically fetches data.</div><br/></div></div></div></div><div id="40519882" class="c"><input type="checkbox" id="c-40519882" checked=""/><div class="controls bullet"><span class="by">jewelry</span><span>|</span><a href="#40520307">prev</a><span>|</span><a href="#40521063">next</a><span>|</span><label class="collapse" for="c-40519882">[-]</label><label class="expand" for="c-40519882">[2 more]</label></div><br/><div class="children"><div class="content">This feels just like Presto&#x2F;Trino to be honest</div><br/><div id="40520396" class="c"><input type="checkbox" id="c-40520396" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#40519882">parent</a><span>|</span><a href="#40521063">next</a><span>|</span><label class="collapse" for="c-40520396">[-]</label><label class="expand" for="c-40520396">[1 more]</label></div><br/><div class="children"><div class="content">They are similar in that you have some data stored somewhere, and you can query it as though it was data stored inside a &#x27;conventional&#x27; database that has it&#x27;s own storage that it manages itself.<p>But whereas Presto&#x2F;Trino&#x2F;Bigquery&#x2F;etc are server-based where queries execute on a cluster of compute nodes, duckdb is something you run locally, in-process.</div><br/></div></div></div></div><div id="40521063" class="c"><input type="checkbox" id="c-40521063" checked=""/><div class="controls bullet"><span class="by">filleokus</span><span>|</span><a href="#40519882">prev</a><span>|</span><a href="#40518662">next</a><span>|</span><label class="collapse" for="c-40521063">[-]</label><label class="expand" for="c-40521063">[2 more]</label></div><br/><div class="children"><div class="content">How stable is the DuckDB file format nowadays? One annoying thing I&#x27;ve experienced (like a year ago) was when I upgraded the rust bindings that produced my DuckDB files, which then couldn&#x27;t be opened with DBeaver because they hadn&#x27;t released a new version yet.<p>I guess you could run into something similar with this solution?</div><br/><div id="40521369" class="c"><input type="checkbox" id="c-40521369" checked=""/><div class="controls bullet"><span class="by">uwemaurer</span><span>|</span><a href="#40521063">parent</a><span>|</span><a href="#40518662">next</a><span>|</span><label class="collapse" for="c-40521369">[-]</label><label class="expand" for="c-40521369">[1 more]</label></div><br/><div class="children"><div class="content">This got a lot better with duckdb 0.10.0<p><a href="https:&#x2F;&#x2F;duckdb.org&#x2F;2024&#x2F;02&#x2F;13&#x2F;announcing-duckdb-0100#backward-compatibility" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;2024&#x2F;02&#x2F;13&#x2F;announcing-duckdb-0100#backwar...</a></div><br/></div></div></div></div><div id="40518662" class="c"><input type="checkbox" id="c-40518662" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#40521063">prev</a><span>|</span><a href="#40521231">next</a><span>|</span><label class="collapse" for="c-40518662">[-]</label><label class="expand" for="c-40518662">[8 more]</label></div><br/><div class="children"><div class="content">Why wouldn&#x27;t you mail your co-worker the SQL text of this query? What is the advantage of the binary database file with no data?</div><br/><div id="40518740" class="c"><input type="checkbox" id="c-40518740" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#40518662">parent</a><span>|</span><a href="#40518743">next</a><span>|</span><label class="collapse" for="c-40518740">[-]</label><label class="expand" for="c-40518740">[2 more]</label></div><br/><div class="children"><div class="content">You then also have to mail them every update to the SQL and hope they&#x27;re handling versioning well<p>With this approach, next time they attach the DB, they automatically see the latest version</div><br/><div id="40519214" class="c"><input type="checkbox" id="c-40519214" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#40518662">root</a><span>|</span><a href="#40518740">parent</a><span>|</span><a href="#40518743">next</a><span>|</span><label class="collapse" for="c-40519214">[-]</label><label class="expand" for="c-40519214">[1 more]</label></div><br/><div class="children"><div class="content">Oh I missed the part where they put that DB file on S3 too and sent a link. I thought they were attaching the DB to the email.<p>Still, I would more readily send people a link to a Gist or playground than a binary DB on S3.</div><br/></div></div></div></div><div id="40518743" class="c"><input type="checkbox" id="c-40518743" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#40518662">parent</a><span>|</span><a href="#40518740">prev</a><span>|</span><a href="#40521231">next</a><span>|</span><label class="collapse" for="c-40518743">[-]</label><label class="expand" for="c-40518743">[5 more]</label></div><br/><div class="children"><div class="content">Or if all your data is in a place like snowflake, you just create a view and send them the name..</div><br/><div id="40519380" class="c"><input type="checkbox" id="c-40519380" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#40518662">root</a><span>|</span><a href="#40518743">parent</a><span>|</span><a href="#40518929">next</a><span>|</span><label class="collapse" for="c-40519380">[-]</label><label class="expand" for="c-40519380">[2 more]</label></div><br/><div class="children"><div class="content">Not a whole lot of operational difference between sending them a snowflake view name or sending an S3 URL but there&#x27;s probably two orders of magnitude cost difference</div><br/><div id="40520698" class="c"><input type="checkbox" id="c-40520698" checked=""/><div class="controls bullet"><span class="by">ramraj07</span><span>|</span><a href="#40518662">root</a><span>|</span><a href="#40519380">parent</a><span>|</span><a href="#40518929">next</a><span>|</span><label class="collapse" for="c-40520698">[-]</label><label class="expand" for="c-40520698">[1 more]</label></div><br/><div class="children"><div class="content">Don’t know what you’re talking about. Used correctly snowflake can be as effective cost wise or cheaper for most orgs’ data needs. Compared to spinning up and down clusters of spark (and maintaining g teams to do this work or paying databricks).</div><br/></div></div></div></div><div id="40518929" class="c"><input type="checkbox" id="c-40518929" checked=""/><div class="controls bullet"><span class="by">banku_brougham</span><span>|</span><a href="#40518662">root</a><span>|</span><a href="#40518743">parent</a><span>|</span><a href="#40519380">prev</a><span>|</span><a href="#40521231">next</a><span>|</span><label class="collapse" for="c-40518929">[-]</label><label class="expand" for="c-40518929">[2 more]</label></div><br/><div class="children"><div class="content">well yeah when you pay the big bucks you can expect all the bells and whistles.</div><br/><div id="40519297" class="c"><input type="checkbox" id="c-40519297" checked=""/><div class="controls bullet"><span class="by">MR4D</span><span>|</span><a href="#40518662">root</a><span>|</span><a href="#40518929">parent</a><span>|</span><a href="#40521231">next</a><span>|</span><label class="collapse" for="c-40519297">[-]</label><label class="expand" for="c-40519297">[1 more]</label></div><br/><div class="children"><div class="content">The future is here, it&#x27;s just not evenly distributed.  Wait a decade (or less) and this will be in open source. Heck, it might already be.</div><br/></div></div></div></div></div></div></div></div><div id="40521231" class="c"><input type="checkbox" id="c-40521231" checked=""/><div class="controls bullet"><span class="by">tobilg</span><span>|</span><a href="#40518662">prev</a><span>|</span><a href="#40516947">next</a><span>|</span><label class="collapse" for="c-40521231">[-]</label><label class="expand" for="c-40521231">[1 more]</label></div><br/><div class="children"><div class="content">You can try DuckDB in your browser via DuckDB WASM with <a href="https:&#x2F;&#x2F;sql-workbench.com" rel="nofollow">https:&#x2F;&#x2F;sql-workbench.com</a></div><br/></div></div><div id="40516947" class="c"><input type="checkbox" id="c-40516947" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#40521231">prev</a><span>|</span><a href="#40520204">next</a><span>|</span><label class="collapse" for="c-40516947">[-]</label><label class="expand" for="c-40516947">[44 more]</label></div><br/><div class="children"><div class="content">Back in the day (early 2000’s), I worked with a DB2 instance that had similar functionality. At the time, they called this feature federated databases. If you had the appropriate wrapper, you could use any data source in a query. Even output from other programs. At the time I used it for including dynamic DNA sequence alignments in queries.<p>IIRC, SQLite can do similar things with virtual tables (with a more limited set of data file types).<p>I always liked this way of working, but I also wonder why it never really took off. Data discovery can be an issue, and I can see the lack of indexing as being a problem.<p>I guess that’s a long winded way to ask: as interesting as this is, what are the use cases where one would really want (or need) to use it?</div><br/><div id="40518013" class="c"><input type="checkbox" id="c-40518013" checked=""/><div class="controls bullet"><span class="by">abraae</span><span>|</span><a href="#40516947">parent</a><span>|</span><a href="#40517028">next</a><span>|</span><label class="collapse" for="c-40518013">[-]</label><label class="expand" for="c-40518013">[36 more]</label></div><br/><div class="children"><div class="content">&gt; I always liked this way of working, but I also wonder why it never really took off.<p>In today&#x27;s new fangled world, a lot of developers don&#x27;t use a lot of the great stuff that RDBMS can provide - stored procedures, SQL constraints, even indexes. The modern mindset seems to be that that stuff belongs in the code layer, above the database. Sometimes it&#x27;s justified as keeping the database vanilla, so that it can be swapped out.<p>In the old days you aimed to keep your database consistent as far as possible, no matter what client was using it. So of course you would use SQL constraints, otherwise people could accidentally corrupt the database using SQL tools, or just with badly written application code.<p>So it&#x27;s not hard to see why more esoteric functions are not widely used.</div><br/><div id="40518211" class="c"><input type="checkbox" id="c-40518211" checked=""/><div class="controls bullet"><span class="by">Arch-TK</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518013">parent</a><span>|</span><a href="#40518598">next</a><span>|</span><label class="collapse" for="c-40518211">[-]</label><label class="expand" for="c-40518211">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard people call the old approach &quot;outdated&quot; and even &quot;wrong&quot; before.<p>It&#x27;s honestly the dumbest situation, where people eagerly use extremely complex databases as if they were indexed KV stores. Completely ignoring about 97% of the features in the process.<p>What&#x27;s especially funny is that half the time a basic KV store would perform better given all the nonsense layered on top.<p>And then there&#x27;s this whole mentality of &quot;we can&#x27;t interface with this database unless we insert a translation layer which converts between relationships between sets of tuples and a graph structure&quot;.<p>It&#x27;s like people have unearthed an ancient technology and have no idea how it&#x27;s intended to be used.</div><br/><div id="40519063" class="c"><input type="checkbox" id="c-40519063" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518211">parent</a><span>|</span><a href="#40519317">next</a><span>|</span><label class="collapse" for="c-40519063">[-]</label><label class="expand" for="c-40519063">[12 more]</label></div><br/><div class="children"><div class="content">Stored procs, triggers and suchlike actually are outdated and mostly wrong. Have you considered that people moved away from them for good reasons, not just ignorance? Hard to source control, impossible to debug, written in weird&#x2F;bad languages, massive blast radius, don’t scale. Usability matters! I have written more TSQL than I would care to admit, and it’s a hell you couldn’t pay me enough to go back to.<p>The “consistency must be enforced at all costs” just turned out not to be true. Worked at many places at moderate scale since my old dba days that don’t use fks. It just doesn’t actually matter, I can’t recall any serious bugs or outages related to dangling rows. Plus, you end up having multiple databases anyway for scale and organizational reasons so fks are useless in that environment anyway.<p>On the other hand, I’m all for indexes and complex querying.  not just k-v.</div><br/><div id="40519945" class="c"><input type="checkbox" id="c-40519945" checked=""/><div class="controls bullet"><span class="by">psadri</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519063">parent</a><span>|</span><a href="#40519858">next</a><span>|</span><label class="collapse" for="c-40519945">[-]</label><label class="expand" for="c-40519945">[1 more]</label></div><br/><div class="children"><div class="content">I think the implementations had a bad DX - but the concepts were not incorrect.  Not enforcing referential integrity, or foregoing schemas all together (hello document stores and then doing the equivalent of SQL joins and aggregations in nested loops within code) is just plain lazy &#x2F; ignorant that comes to bite you in the ass later.</div><br/></div></div><div id="40519858" class="c"><input type="checkbox" id="c-40519858" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519063">parent</a><span>|</span><a href="#40519945">prev</a><span>|</span><a href="#40519223">next</a><span>|</span><label class="collapse" for="c-40519858">[-]</label><label class="expand" for="c-40519858">[3 more]</label></div><br/><div class="children"><div class="content">Hard agree.<p>But I like foreign keys (ON DELETE RESTRICT), they are the last layer of defense against application bugs messing up the database.</div><br/><div id="40519949" class="c"><input type="checkbox" id="c-40519949" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519858">parent</a><span>|</span><a href="#40519223">next</a><span>|</span><label class="collapse" for="c-40519949">[-]</label><label class="expand" for="c-40519949">[2 more]</label></div><br/><div class="children"><div class="content">i totally get that position. I used to be in that camp, but in my last 3 jobs at companies of &gt;10mil users, we had to get rid of FKs for other reasons (perf, dist system stuff). I kind of expected bad data corruption issues.... but they just never happened ¯\_(ツ)_&#x2F;¯. Not sure if that was strong cultures of automated testing, or what. So now i no longer think they&#x27;re worth the tradeoffs.<p>YMMV with this one, i could see how it might pan out differently in other environments</div><br/><div id="40520940" class="c"><input type="checkbox" id="c-40520940" checked=""/><div class="controls bullet"><span class="by">pbowyer</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519949">parent</a><span>|</span><a href="#40519223">next</a><span>|</span><label class="collapse" for="c-40520940">[-]</label><label class="expand" for="c-40520940">[1 more]</label></div><br/><div class="children"><div class="content">Did these involve financial transactions? Other situations I will have dangling rows without issues, but whenever money comes into the picture I like to have as much consistency enforced as I can. But I&#x27;m aware that doesn&#x27;t play nicely with distributed systems.</div><br/></div></div></div></div></div></div><div id="40519223" class="c"><input type="checkbox" id="c-40519223" checked=""/><div class="controls bullet"><span class="by">leoqa</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519063">parent</a><span>|</span><a href="#40519858">prev</a><span>|</span><a href="#40519955">next</a><span>|</span><label class="collapse" for="c-40519223">[-]</label><label class="expand" for="c-40519223">[5 more]</label></div><br/><div class="children"><div class="content">I think you touched on the real reason: we separate services now and they all have different databases. We shifted up to the application layer not because of technical reasons but social reasons.</div><br/><div id="40519518" class="c"><input type="checkbox" id="c-40519518" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519223">parent</a><span>|</span><a href="#40519955">next</a><span>|</span><label class="collapse" for="c-40519518">[-]</label><label class="expand" for="c-40519518">[4 more]</label></div><br/><div class="children"><div class="content">Your timing is off, we as an industry ditched stored procs and friends before (micro)services became a trend. For the reasons I said.<p>I’m not sure why it’s so hard to accept that we stopped using them because they were bad, not for some other gotcha reason (social, ignorance, fads, etc)</div><br/><div id="40519616" class="c"><input type="checkbox" id="c-40519616" checked=""/><div class="controls bullet"><span class="by">btreecat</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519518">parent</a><span>|</span><a href="#40519955">next</a><span>|</span><label class="collapse" for="c-40519616">[-]</label><label class="expand" for="c-40519616">[3 more]</label></div><br/><div class="children"><div class="content">Maybe because claiming they are bad with out explaining why, giving explicit examples, or really digging into the nuance of the more than one feature mentioned makes the claim feel unsubstantiated.</div><br/><div id="40519638" class="c"><input type="checkbox" id="c-40519638" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519616">parent</a><span>|</span><a href="#40519955">next</a><span>|</span><label class="collapse" for="c-40519638">[-]</label><label class="expand" for="c-40519638">[2 more]</label></div><br/><div class="children"><div class="content">Pretty sure I did say why. “ Hard to source control, impossible to debug, written in weird&#x2F;bad languages, massive blast radius, don’t scale. Usability matters! ” and I forgot “generates non obvious non local changes” for triggers.</div><br/><div id="40520581" class="c"><input type="checkbox" id="c-40520581" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519638">parent</a><span>|</span><a href="#40519955">next</a><span>|</span><label class="collapse" for="c-40520581">[-]</label><label class="expand" for="c-40520581">[1 more]</label></div><br/><div class="children"><div class="content">What is so hard to source control with stored procedures, I’ve writing them in text files for over 30years, version controlled in rcs, cvs, svn and git. No problem, it’s just the deployment automation that works a bit different.<p>Also, oracle plsql is way better than ms t-sql, it mostly feels like pascal&#x2F;modula2 with embedded sql statements.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40519729" class="c"><input type="checkbox" id="c-40519729" checked=""/><div class="controls bullet"><span class="by">myaccountonhn</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519063">parent</a><span>|</span><a href="#40519955">prev</a><span>|</span><a href="#40519317">next</a><span>|</span><label class="collapse" for="c-40519729">[-]</label><label class="expand" for="c-40519729">[1 more]</label></div><br/><div class="children"><div class="content">It makes me think that for many projects, recutils would be a better fit if you’re not gonna use the advanced functionality anyway. It should do just fine on medium sized DBs and is so much simpler.</div><br/></div></div></div></div><div id="40519317" class="c"><input type="checkbox" id="c-40519317" checked=""/><div class="controls bullet"><span class="by">jacob019</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518211">parent</a><span>|</span><a href="#40519063">prev</a><span>|</span><a href="#40518598">next</a><span>|</span><label class="collapse" for="c-40519317">[-]</label><label class="expand" for="c-40519317">[1 more]</label></div><br/><div class="children"><div class="content">Yep, that&#x27;s me.  I use sqlite as a key value store.  Usually just two columns per table, a key and value, that I map to a python dict, and pickle the value if I need something more complex.</div><br/></div></div></div></div><div id="40518598" class="c"><input type="checkbox" id="c-40518598" checked=""/><div class="controls bullet"><span class="by">vosper</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518013">parent</a><span>|</span><a href="#40518211">prev</a><span>|</span><a href="#40518952">next</a><span>|</span><label class="collapse" for="c-40518598">[-]</label><label class="expand" for="c-40518598">[8 more]</label></div><br/><div class="children"><div class="content">&gt; In today&#x27;s new fangled world, a lot of developers don&#x27;t use a lot of the great stuff that RDBMS can provide - stored procedures, SQL constraints, even indexes. The modern mindset seems to be that that stuff belongs in the code layer, above the database.<p>Implementing constraints in application code is certainly a lot easier (and easier to test) than in the database. What <i>I</i> want is a database which far stronger constraint capabilities than eg MySQL or Postgres provide, so that my application-level constraints can live in the database where they belong, without compromising ease of development and maintenance.</div><br/><div id="40518841" class="c"><input type="checkbox" id="c-40518841" checked=""/><div class="controls bullet"><span class="by">zie</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518598">parent</a><span>|</span><a href="#40519022">next</a><span>|</span><label class="collapse" for="c-40518841">[-]</label><label class="expand" for="c-40518841">[1 more]</label></div><br/><div class="children"><div class="content">In PostgreSQL you can write pretty much any constraint you wish: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;ddl-constraints.html" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;ddl-constraints.html</a></div><br/></div></div><div id="40519022" class="c"><input type="checkbox" id="c-40519022" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518598">parent</a><span>|</span><a href="#40518841">prev</a><span>|</span><a href="#40518952">next</a><span>|</span><label class="collapse" for="c-40519022">[-]</label><label class="expand" for="c-40519022">[6 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Implementing constraints in application code is certainly a lot easier</i><p>I can’t imagine doing this. You’re basically saying that you will only ever have one program writing to your database.</div><br/><div id="40520404" class="c"><input type="checkbox" id="c-40520404" checked=""/><div class="controls bullet"><span class="by">vineyardmike</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519022">parent</a><span>|</span><a href="#40519428">next</a><span>|</span><label class="collapse" for="c-40520404">[-]</label><label class="expand" for="c-40520404">[4 more]</label></div><br/><div class="children"><div class="content">This is, for many, considered a best practice.<p>The idea being that a single service&#x2F;codebase is controlling interaction with the database. Any read&#x2F;writes should go through that service&#x27;s APIs. Basically a &quot;CreateFoo(a, b, c)&quot; API is a better way to enforce how data is written&#x2F;read vs every service writing their own queries.</div><br/><div id="40520518" class="c"><input type="checkbox" id="c-40520518" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40520404">parent</a><span>|</span><a href="#40519428">next</a><span>|</span><label class="collapse" for="c-40520518">[-]</label><label class="expand" for="c-40520518">[3 more]</label></div><br/><div class="children"><div class="content">It incurs huge costs though:<p>1. Costs of API maintenance - rigid APIs need constant change. To mitigate that people create APIs like GraphQL which is a reimplementation of SQL (ie. a query language).<p>2. Costs of data integration - (micro)systems owning databases need data synchronisation and duplication. What&#x27;s worse - most of the times data synchronisation bypasses service APIs (using tools like CDC etc.) so all efforts to decouple services via APIs are moot.<p>A single data platform (a database) with well governed structure enforced by a DBMS is a compelling alternative to microservices in this context.</div><br/><div id="40521040" class="c"><input type="checkbox" id="c-40521040" checked=""/><div class="controls bullet"><span class="by">vineyardmike</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40520518">parent</a><span>|</span><a href="#40519428">next</a><span>|</span><label class="collapse" for="c-40521040">[-]</label><label class="expand" for="c-40521040">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Costs of API maintenance - rigid APIs need constant change.<p>Rigidity is the point...<p>If you have a &quot;CRUD a Foo&quot; set of APIs, and how you create&#x2F;read a &quot;foo&quot; is defined in that API. Sometimes change is necessary, sometimes the API contract changes, but sometimes just the internal implementation changes (eg new or refactored tables&#x2F;columns). The rigidity of the API ensures that every downstream user of a foo creates&#x2F;reads in the exact same way. It centralizes permissions, overrides (eg. a&#x2F;b testing), rate limiting, transactions, etc. to be homogeneous for everyone. If you want to create&#x2F;read a foo via database queries alone, and the database changes or the business logic changes, then the same issue occurs where all clients need to change, but now it needs to be coordinated everywhere, and you can&#x27;t benefit from a centralized change hiding implementation details.<p>Many people prefer to keep all the logic around enforcing consistency and object lifecycle (application behavior) in the application layer. This allows a single codebase to manage it, and it can be uniformly guarded with tests. Exposing the database itself is really just an example of a leaking implementation details.<p>&gt; To mitigate that people create APIs like GraphQL<p>If you need raw flexible queries, then this is probably the wrong sort of solution. Ideally, the developer of a service already knows what queries will be made, and clients don&#x27;t typically need detailed custom queries. Analytics (typically read-only) should already occur in an offline or read-replica version of the database to not impact production traffic.<p>&gt; (micro)systems owning databases need data synchronisation and duplication.<p>What do you mean? Foo service exposes &quot;CRUD-Foo&quot; apis and is the only service that calls the Foo-storing database. If Foo service is horizontally scaled, then it&#x27;s all the same code, and can safely call foo-db in parallel. If the database needs horizontal scaling, you can just use whatever primitives exist for the database you picked, and foo-service will call it as expected, and the transaction governs the lifecycle of the records.<p>&gt; ...all efforts to decouple services via APIs are moot.<p>To be clear, different services wouldn&#x27;t operate on their own duplicated version of the same shared data, in their own database. They&#x27;d call a defined API to get that data from another service. The whole point of this is to allow each service to define the interface for their data.</div><br/><div id="40521226" class="c"><input type="checkbox" id="c-40521226" checked=""/><div class="controls bullet"><span class="by">mkleczek</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40521040">parent</a><span>|</span><a href="#40519428">next</a><span>|</span><label class="collapse" for="c-40521226">[-]</label><label class="expand" for="c-40521226">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Exposing the database itself is really just an example of a leaking implementation details.<p>This is a mistake that a lot of people make - treating database as an implementation detail.
Relational model and relational calculus&#x2F;algebra were invented for _sharing_ data (not storing). The relational model _is_ the interface. Access to data is abstracted away - swapping storage layer or introducing different indexes or even using foreign data wrappers is transparent to applications.<p>Security and access policies are defined not against API operations but against _data_ - because it is data that you want to protect regardless of what API is used to access it.<p>&gt; To be clear, different services wouldn&#x27;t operate on their own duplicated version of the same shared data, in their own database. They&#x27;d call a defined API to get that data from another service.<p>You mean synchronous calls? This actually leads to what industry calls &quot;distributed spaghetti&quot; and is the worst of both worlds.<p>&gt; The whole point of this is to allow each service to define the interface for their data.<p>The point is that well defined relational database schema and SQL _is_ a very good interface for data. Wrapping it in JSON over HTTP is a step backwards.</div><br/></div></div></div></div></div></div></div></div><div id="40519428" class="c"><input type="checkbox" id="c-40519428" checked=""/><div class="controls bullet"><span class="by">tomrod</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519022">parent</a><span>|</span><a href="#40520404">prev</a><span>|</span><a href="#40518952">next</a><span>|</span><label class="collapse" for="c-40519428">[-]</label><label class="expand" for="c-40519428">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the idea of microservices.</div><br/></div></div></div></div></div></div><div id="40518952" class="c"><input type="checkbox" id="c-40518952" checked=""/><div class="controls bullet"><span class="by">galkk</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518013">parent</a><span>|</span><a href="#40518598">prev</a><span>|</span><a href="#40518978">next</a><span>|</span><label class="collapse" for="c-40518952">[-]</label><label class="expand" for="c-40518952">[4 more]</label></div><br/><div class="children"><div class="content">IMHO stored procedures are evil and they shouldn’t have place in modern development. They are old solution for client server world.</div><br/><div id="40518993" class="c"><input type="checkbox" id="c-40518993" checked=""/><div class="controls bullet"><span class="by">mbreese</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518952">parent</a><span>|</span><a href="#40520601">next</a><span>|</span><label class="collapse" for="c-40518993">[-]</label><label class="expand" for="c-40518993">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you need to have atomic updates for a function. Stored procedures aren’t inherently evil, but are a hold over from when DB admins were a thing and they didn’t trust app developers.<p>Don’t worry, just wait another 5-10 years, they’ll be back in vogue again.</div><br/></div></div><div id="40520601" class="c"><input type="checkbox" id="c-40520601" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518952">parent</a><span>|</span><a href="#40518993">prev</a><span>|</span><a href="#40520846">next</a><span>|</span><label class="collapse" for="c-40520601">[-]</label><label class="expand" for="c-40520601">[1 more]</label></div><br/><div class="children"><div class="content">I don’t get this mentality, they’re just code that lives closed to your data, and can do bulk processing on data in your database way more efficiently than anything living in the application layer.</div><br/></div></div><div id="40520846" class="c"><input type="checkbox" id="c-40520846" checked=""/><div class="controls bullet"><span class="by">LunaSea</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518952">parent</a><span>|</span><a href="#40520601">prev</a><span>|</span><a href="#40518978">next</a><span>|</span><label class="collapse" for="c-40520846">[-]</label><label class="expand" for="c-40520846">[1 more]</label></div><br/><div class="children"><div class="content">- References are triggers<p>- Audit tables are often implemented thanks to triggers<p>- Soft deletes can be easily implemented thanks to triggers</div><br/></div></div></div></div><div id="40518978" class="c"><input type="checkbox" id="c-40518978" checked=""/><div class="controls bullet"><span class="by">banku_brougham</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518013">parent</a><span>|</span><a href="#40518952">prev</a><span>|</span><a href="#40520920">next</a><span>|</span><label class="collapse" for="c-40518978">[-]</label><label class="expand" for="c-40518978">[4 more]</label></div><br/><div class="children"><div class="content">Stored procedures are awful. There, I said it.<p>Its storing transform code in an inscrutible way, hiding pipeline components from downstream users. The rest of your alarms and dq has to be extendend to look into these...<p>Oh an PL&#x2F;SQL requires a huge context switch from whatever you were doing.</div><br/><div id="40519591" class="c"><input type="checkbox" id="c-40519591" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518978">parent</a><span>|</span><a href="#40519545">next</a><span>|</span><label class="collapse" for="c-40519591">[-]</label><label class="expand" for="c-40519591">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit surprised about the flak that stored procs have.  Treat them just like any other, hopefully well documented, API, and they work perfectly fine.  There are pros and cons, just like whether you decide to use react or htmx, python or golang, erlang or lisp, row based database vs column based vs kv, etc.<p>On the other hand, yes, going back to the days of poorly written and documented oracle pl&#x2F;sql stored procs, yes, I shudder too, but then again, that can also be said of a number of public APIs that have been hacked&#x2F;had side effects exposed.</div><br/></div></div><div id="40519545" class="c"><input type="checkbox" id="c-40519545" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518978">parent</a><span>|</span><a href="#40519591">prev</a><span>|</span><a href="#40520920">next</a><span>|</span><label class="collapse" for="c-40519545">[-]</label><label class="expand" for="c-40519545">[2 more]</label></div><br/><div class="children"><div class="content">It’s not a controversial take. They are awful, and thus haven&#x27;t  been used for new development for at least a decade, going on two.</div><br/><div id="40521504" class="c"><input type="checkbox" id="c-40521504" checked=""/><div class="controls bullet"><span class="by">mvc</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40519545">parent</a><span>|</span><a href="#40520920">next</a><span>|</span><label class="collapse" for="c-40521504">[-]</label><label class="expand" for="c-40521504">[1 more]</label></div><br/><div class="children"><div class="content">I generate my pl&#x2F;pgsql using Lisp. Which is another technology that has been dying for decades. The money it generates seems to work just as well as the money I earned writing js.</div><br/></div></div></div></div></div></div><div id="40520920" class="c"><input type="checkbox" id="c-40520920" checked=""/><div class="controls bullet"><span class="by">LunaSea</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518013">parent</a><span>|</span><a href="#40518978">prev</a><span>|</span><a href="#40518793">next</a><span>|</span><label class="collapse" for="c-40520920">[-]</label><label class="expand" for="c-40520920">[1 more]</label></div><br/><div class="children"><div class="content">The reason a lot of more advanced database features aren&#x27;t used is simply because a lot (most?) web developers don&#x27;t know them and have a very light understanding of databases in general.</div><br/></div></div><div id="40518793" class="c"><input type="checkbox" id="c-40518793" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518013">parent</a><span>|</span><a href="#40520920">prev</a><span>|</span><a href="#40519962">next</a><span>|</span><label class="collapse" for="c-40518793">[-]</label><label class="expand" for="c-40518793">[2 more]</label></div><br/><div class="children"><div class="content">People do still use indexes and the basic FK&#x2F;UQ constraints because they&#x27;re add value even when using ORM mappers,etc. I don&#x27;t think that the ideas of changing databases are that prevalent any more (apart from perhaps unit-testing but since db&#x27;s can often be dockerized that&#x27;s also solved now).<p>People don&#x27;t hate stored-procedures (or other custom SQL constraints&#x2F;triggers) per-se, but more the amount of headache they bring when it comes to debugging and keeping in sync with version control.</div><br/><div id="40520445" class="c"><input type="checkbox" id="c-40520445" checked=""/><div class="controls bullet"><span class="by">jasonkester</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518793">parent</a><span>|</span><a href="#40519962">next</a><span>|</span><label class="collapse" for="c-40520445">[-]</label><label class="expand" for="c-40520445">[1 more]</label></div><br/><div class="children"><div class="content">.sql files go into version control just as well as .java files.  And because your build will be blowing all your stored procedures away and rebuilding them as part of the build, you&#x27;ll know at compile time if Junior Dev Jimmy dropped a null constraint or renamed something but didn&#x27;t fix one of the procs.<p>That&#x27;s way easier to debug than if Jimmy also had his query living as a string somewhere in your backend code.<p>Honestly, if this stuff is hard, it&#x27;s because you&#x27;ve made it hard.  I can only assume most people griping about stored procedures don&#x27;t have a &#x2F;sql folder living next to their &#x2F;python or &#x2F;java folder in source control.</div><br/></div></div></div></div><div id="40519962" class="c"><input type="checkbox" id="c-40519962" checked=""/><div class="controls bullet"><span class="by">victor106</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518013">parent</a><span>|</span><a href="#40518793">prev</a><span>|</span><a href="#40518106">next</a><span>|</span><label class="collapse" for="c-40519962">[-]</label><label class="expand" for="c-40519962">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sometimes it&#x27;s justified as keeping the database vanilla, so that it can be swapped out.<p>I understand if it&#x27;s a prototype, I have seen developers of even mature products follow this mentality that they want the DB to be portable. It&#x27;s insane. The reality is that rarely happens and when it does its mostly cause your business is growing. But not knowing (or caring to know) the features your DB offers you and not exploiting it is just laziness.</div><br/></div></div><div id="40518106" class="c"><input type="checkbox" id="c-40518106" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40518013">parent</a><span>|</span><a href="#40519962">prev</a><span>|</span><a href="#40517028">next</a><span>|</span><label class="collapse" for="c-40518106">[-]</label><label class="expand" for="c-40518106">[1 more]</label></div><br/><div class="children"><div class="content">the approach in the article is for analytics &#x2F; DW type use cases, not OTLP. So a dig about kids these days not understanding constraints is not particularly relevant.</div><br/></div></div></div></div><div id="40517028" class="c"><input type="checkbox" id="c-40517028" checked=""/><div class="controls bullet"><span class="by">clscott</span><span>|</span><a href="#40516947">parent</a><span>|</span><a href="#40518013">prev</a><span>|</span><a href="#40521299">next</a><span>|</span><label class="collapse" for="c-40517028">[-]</label><label class="expand" for="c-40517028">[3 more]</label></div><br/><div class="children"><div class="content">Postgres calls these foreign data wrappers (FDW)<p><a href="https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;Foreign_data_wrappers" rel="nofollow">https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;Foreign_data_wrappers</a></div><br/><div id="40517529" class="c"><input type="checkbox" id="c-40517529" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40517028">parent</a><span>|</span><a href="#40521299">next</a><span>|</span><label class="collapse" for="c-40517529">[-]</label><label class="expand" for="c-40517529">[2 more]</label></div><br/><div class="children"><div class="content">Steampipe demonstrates a rather impressive range of scenarios for using FDWs + SQL in place of more traditional ETL and API integrations: <a href="https:&#x2F;&#x2F;steampipe.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;steampipe.io&#x2F;</a></div><br/><div id="40519103" class="c"><input type="checkbox" id="c-40519103" checked=""/><div class="controls bullet"><span class="by">banku_brougham</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40517529">parent</a><span>|</span><a href="#40521299">next</a><span>|</span><label class="collapse" for="c-40519103">[-]</label><label class="expand" for="c-40519103">[1 more]</label></div><br/><div class="children"><div class="content">I like this when I tried it out. The AWS API plugin was neat, query resources with SQL.<p>However, I like to limit my toolset to three things, these days thats duckdb, julia for analysis side, and... OK two things.<p>Oh yeah Trino for our distributed compute.</div><br/></div></div></div></div></div></div><div id="40521299" class="c"><input type="checkbox" id="c-40521299" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#40516947">parent</a><span>|</span><a href="#40517028">prev</a><span>|</span><a href="#40516994">next</a><span>|</span><label class="collapse" for="c-40521299">[-]</label><label class="expand" for="c-40521299">[1 more]</label></div><br/><div class="children"><div class="content">Similar timeline - Oracle had a feature called external tables where you can create a &quot;table&quot; on top of an external flat file and run queries against it. Prior to that we were use awk&#x2F;perl etc and found it to be more performant + all the benefits that SQL brings.</div><br/></div></div><div id="40516994" class="c"><input type="checkbox" id="c-40516994" checked=""/><div class="controls bullet"><span class="by">solidsnack9000</span><span>|</span><a href="#40516947">parent</a><span>|</span><a href="#40521299">prev</a><span>|</span><a href="#40518945">next</a><span>|</span><label class="collapse" for="c-40516994">[-]</label><label class="expand" for="c-40516994">[2 more]</label></div><br/><div class="children"><div class="content">A related functionality is &quot;SQL&#x2F;MED&quot;, a SQL specification for federated databases that has some kind of relationship to medical data historically (I believe one of the use cases is data at one site that another site is allowed to query, in a limited way, data hosted at another site that may not be moved from it).</div><br/><div id="40520433" class="c"><input type="checkbox" id="c-40520433" checked=""/><div class="controls bullet"><span class="by">sixdimensional</span><span>|</span><a href="#40516947">root</a><span>|</span><a href="#40516994">parent</a><span>|</span><a href="#40518945">next</a><span>|</span><label class="collapse" for="c-40520433">[-]</label><label class="expand" for="c-40520433">[1 more]</label></div><br/><div class="children"><div class="content">The MED stands for management of external data, nothing to do with medical data.<p>It’s actually a chapter in the ISO&#x2F;ANSI SQL specification.</div><br/></div></div></div></div><div id="40518945" class="c"><input type="checkbox" id="c-40518945" checked=""/><div class="controls bullet"><span class="by">banku_brougham</span><span>|</span><a href="#40516947">parent</a><span>|</span><a href="#40516994">prev</a><span>|</span><a href="#40520204">next</a><span>|</span><label class="collapse" for="c-40518945">[-]</label><label class="expand" for="c-40518945">[1 more]</label></div><br/><div class="children"><div class="content">sqlite is awesome, obviously. but the api isnt elegant and easy the way duckdb (or postgres) is.  handling dates in sqlite has me googling everything.</div><br/></div></div></div></div><div id="40520204" class="c"><input type="checkbox" id="c-40520204" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#40516947">prev</a><span>|</span><a href="#40517096">next</a><span>|</span><label class="collapse" for="c-40520204">[-]</label><label class="expand" for="c-40520204">[3 more]</label></div><br/><div class="children"><div class="content">Is the `weird_rides.db` file python or some sort of duckdb script?<p>I&#x27;m quite intrigued about DuckDBs ability to read parquet files off of buckets. How good is at at simply ignoring files (e.g, filtering based on info in datafiles paths)?</div><br/><div id="40521532" class="c"><input type="checkbox" id="c-40521532" checked=""/><div class="controls bullet"><span class="by">mvc</span><span>|</span><a href="#40520204">parent</a><span>|</span><a href="#40520262">next</a><span>|</span><label class="collapse" for="c-40521532">[-]</label><label class="expand" for="c-40521532">[1 more]</label></div><br/><div class="children"><div class="content">If the objects in S3 are named according to hive conventions, it will do what you would hope and not read any files with no data to match the query.<p>It will even use range requests in S3 to avoid fetching the entire blob.<p>See here for the details
<a href="https:&#x2F;&#x2F;duckdb.org&#x2F;2021&#x2F;06&#x2F;25&#x2F;querying-parquet.html#automatic-filter--projection-pushdown" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;2021&#x2F;06&#x2F;25&#x2F;querying-parquet.html#automati...</a></div><br/></div></div><div id="40520262" class="c"><input type="checkbox" id="c-40520262" checked=""/><div class="controls bullet"><span class="by">rcaught</span><span>|</span><a href="#40520204">parent</a><span>|</span><a href="#40521532">prev</a><span>|</span><a href="#40517096">next</a><span>|</span><label class="collapse" for="c-40520262">[-]</label><label class="expand" for="c-40520262">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve successfully used it&#x27;s glob support on S3.</div><br/></div></div></div></div><div id="40517096" class="c"><input type="checkbox" id="c-40517096" checked=""/><div class="controls bullet"><span class="by">blyry</span><span>|</span><a href="#40520204">prev</a><span>|</span><a href="#40517480">next</a><span>|</span><label class="collapse" for="c-40517096">[-]</label><label class="expand" for="c-40517096">[1 more]</label></div><br/><div class="children"><div class="content">This is a great feature. We&#x27;ve been able to significantly extend the scope and usefulness of our on-prem SQL Cluster for analytics and reporting with PolyBase by building new transactional systems with cheaper postgres, doing ETLs of third-party data to delta tables in azure storage, and then federating access to them with PolyBase so that nobody in the business has to change how they actually query the data. I&#x27;m sure in another decade we&#x27;ll be fully migrated to some cloud platform but for now, federating the queries is a huge win.</div><br/></div></div><div id="40517480" class="c"><input type="checkbox" id="c-40517480" checked=""/><div class="controls bullet"><span class="by">brutuscat</span><span>|</span><a href="#40517096">prev</a><span>|</span><a href="#40518859">next</a><span>|</span><label class="collapse" for="c-40517480">[-]</label><label class="expand" for="c-40517480">[4 more]</label></div><br/><div class="children"><div class="content">Does it work with some format that supports indexes like Apache carbon data rather than parquet?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;carbondata">https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;carbondata</a></div><br/><div id="40518380" class="c"><input type="checkbox" id="c-40518380" checked=""/><div class="controls bullet"><span class="by">Jgrubb</span><span>|</span><a href="#40517480">parent</a><span>|</span><a href="#40518859">next</a><span>|</span><label class="collapse" for="c-40518380">[-]</label><label class="expand" for="c-40518380">[3 more]</label></div><br/><div class="children"><div class="content">I admit I&#x27;m not crazy deep in this space but I&#x27;m _pretty_ into this space and I&#x27;ve never heard of Carbon.<p>Parquet is kind of winning the OSS columnar format race right now.</div><br/><div id="40521093" class="c"><input type="checkbox" id="c-40521093" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#40517480">root</a><span>|</span><a href="#40518380">parent</a><span>|</span><a href="#40518859">next</a><span>|</span><label class="collapse" for="c-40521093">[-]</label><label class="expand" for="c-40521093">[2 more]</label></div><br/><div class="children"><div class="content">Parquet the most popular columnar format. (owing to support in Spark and various other big data tools, as well as local tools like pandas, polars and duckdb)<p>It&#x27;s technically not the very best format (ORC has some advantages), but it&#x27;s so ubiquitous and good enough -- still far better than than CSV or the next best competing format. I have not heard of Carbon -- it sounds like an interesting niche format, hopefully it&#x27;s gaining ground.<p>It&#x27;s the VHS, not the betamax.</div><br/><div id="40521362" class="c"><input type="checkbox" id="c-40521362" checked=""/><div class="controls bullet"><span class="by">stdbrouw</span><span>|</span><a href="#40517480">root</a><span>|</span><a href="#40521093">parent</a><span>|</span><a href="#40518859">next</a><span>|</span><label class="collapse" for="c-40521362">[-]</label><label class="expand" for="c-40521362">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Good enough&quot; makes it sound like barely a step up from a CSV file. I&#x27;d say its support for various encodings [1] including a great default (dictionary + run length encoding on the indices) and compression algorithms that can be set for each individual column, columnar access, partitioning, a parallelized reader out of the box, in-memory filtering and other ops concurrently with loading in the data (thanks to Arrow) etc. etc. are all really wonderful when working with medium-sized data.<p>[1] <a href="https:&#x2F;&#x2F;parquet.apache.org&#x2F;docs&#x2F;file-format&#x2F;data-pages&#x2F;encodings&#x2F;" rel="nofollow">https:&#x2F;&#x2F;parquet.apache.org&#x2F;docs&#x2F;file-format&#x2F;data-pages&#x2F;encod...</a></div><br/></div></div></div></div></div></div></div></div><div id="40518859" class="c"><input type="checkbox" id="c-40518859" checked=""/><div class="controls bullet"><span class="by">zie</span><span>|</span><a href="#40517480">prev</a><span>|</span><a href="#40516990">next</a><span>|</span><label class="collapse" for="c-40518859">[-]</label><label class="expand" for="c-40518859">[3 more]</label></div><br/><div class="children"><div class="content">For things like this I just export to a sqlite DB file and send that along. This is interesting for AWS&#x2F;S3 datastores though.</div><br/><div id="40521430" class="c"><input type="checkbox" id="c-40521430" checked=""/><div class="controls bullet"><span class="by">tobilg</span><span>|</span><a href="#40518859">parent</a><span>|</span><a href="#40519684">next</a><span>|</span><label class="collapse" for="c-40521430">[-]</label><label class="expand" for="c-40521430">[1 more]</label></div><br/><div class="children"><div class="content">You can do the exact same thing with DuckDB as well...</div><br/></div></div></div></div><div id="40516990" class="c"><input type="checkbox" id="c-40516990" checked=""/><div class="controls bullet"><span class="by">countvonbalzac</span><span>|</span><a href="#40518859">prev</a><span>|</span><a href="#40517489">next</a><span>|</span><label class="collapse" for="c-40516990">[-]</label><label class="expand" for="c-40516990">[7 more]</label></div><br/><div class="children"><div class="content">Does DuckDB cache the S3 downloads? Otherwise it could get pretty expensive, no?</div><br/><div id="40517488" class="c"><input type="checkbox" id="c-40517488" checked=""/><div class="controls bullet"><span class="by">davesque</span><span>|</span><a href="#40516990">parent</a><span>|</span><a href="#40518499">next</a><span>|</span><label class="collapse" for="c-40517488">[-]</label><label class="expand" for="c-40517488">[3 more]</label></div><br/><div class="children"><div class="content">If the parquet file includes any row group stats, then I imagine DuckDB might be able to use those to avoid scanning the entire file.  It&#x27;s definitely possible to request specific sections of a blob stored in S3.  But I&#x27;m not familiar enough with DuckDB to know whether or not it does this.</div><br/><div id="40519706" class="c"><input type="checkbox" id="c-40519706" checked=""/><div class="controls bullet"><span class="by">chrisjc</span><span>|</span><a href="#40516990">root</a><span>|</span><a href="#40517488">parent</a><span>|</span><a href="#40517785">next</a><span>|</span><label class="collapse" for="c-40519706">[-]</label><label class="expand" for="c-40519706">[1 more]</label></div><br/><div class="children"><div class="content">DuckDB can do some pushdowns to certain file formats like parquet, but every release seems to be getting better and better at doing it.<p>Parquet pushdowns combined with Hive structuring is a pretty good combination.<p>There are some HTTP and Metadata caching options in DuckDB, but I haven&#x27;t really figured out how and when they really making a difference.</div><br/></div></div><div id="40517785" class="c"><input type="checkbox" id="c-40517785" checked=""/><div class="controls bullet"><span class="by">akdor1154</span><span>|</span><a href="#40516990">root</a><span>|</span><a href="#40517488">parent</a><span>|</span><a href="#40519706">prev</a><span>|</span><a href="#40518499">next</a><span>|</span><label class="collapse" for="c-40517785">[-]</label><label class="expand" for="c-40517785">[1 more]</label></div><br/><div class="children"><div class="content">It does do that. I can&#x27;t answer OP&#x27;s qn about caching though.</div><br/></div></div></div></div><div id="40518499" class="c"><input type="checkbox" id="c-40518499" checked=""/><div class="controls bullet"><span class="by">orthecreedence</span><span>|</span><a href="#40516990">parent</a><span>|</span><a href="#40517488">prev</a><span>|</span><a href="#40518408">next</a><span>|</span><label class="collapse" for="c-40518499">[-]</label><label class="expand" for="c-40518499">[1 more]</label></div><br/><div class="children"><div class="content">To my understanding, it does not cache (but I haven&#x27;t reviewed the code). &quot;Expensive&quot; here really just means expensive in time. If you&#x27;re running DuckDB on an EC2 instance to query S3 on the same account, it&#x27;s practically free of any other cost. I wouldn&#x27;t bother doing it outside AWS unless it&#x27;s a one-time thing.<p>Running a simple analytics query on ~4B rows across 6.6K parquet files in S3 on an m6a.xl takes around 7 minutes. And you can &quot;index&quot; these queries somewhat by adding dimensions in the path (s3:&#x2F;&#x2F;my-data&#x2F;category=transactions&#x2F;month=2024-05&#x2F;rows1.parquet) which DuckDB will happily query on. So yeah, fairly expensive in time (but cheap for storage!). If you&#x27;re just firehosing data into S3 and can add somewhat descriptive dimensions to your paths, you can optimize it a bit.</div><br/></div></div><div id="40518408" class="c"><input type="checkbox" id="c-40518408" checked=""/><div class="controls bullet"><span class="by">ayhanfuat</span><span>|</span><a href="#40516990">parent</a><span>|</span><a href="#40518499">prev</a><span>|</span><a href="#40517489">next</a><span>|</span><label class="collapse" for="c-40518408">[-]</label><label class="expand" for="c-40518408">[2 more]</label></div><br/><div class="children"><div class="content">I asked this some time ago on their Discord in relation to AWS lambda and the Python client and the answer was that you need to handle caching on your own but it is easy to do with fsspec. I haven’t tried it yet though.</div><br/><div id="40521138" class="c"><input type="checkbox" id="c-40521138" checked=""/><div class="controls bullet"><span class="by">wenc</span><span>|</span><a href="#40516990">root</a><span>|</span><a href="#40518408">parent</a><span>|</span><a href="#40517489">next</a><span>|</span><label class="collapse" for="c-40521138">[-]</label><label class="expand" for="c-40521138">[1 more]</label></div><br/><div class="children"><div class="content">Do you have any details on this?<p>Duckdb over vanilla S3 has latency issues because S3 is optimized for bulk transfers, not random reads. The new AWS S3 Express Zone supports low-latency but there&#x27;s a cost.<p>Caching Parquet reads from vanilla S3 sounds like a good intermediate solution. Most of the time, Parquet files are Hive-partitioned, so it would only entail caching several smaller Parquet files on-demand and not the entire dataset.</div><br/></div></div></div></div></div></div><div id="40517489" class="c"><input type="checkbox" id="c-40517489" checked=""/><div class="controls bullet"><span class="by">dangoodmanUT</span><span>|</span><a href="#40516990">prev</a><span>|</span><a href="#40518090">next</a><span>|</span><label class="collapse" for="c-40517489">[-]</label><label class="expand" for="c-40517489">[2 more]</label></div><br/><div class="children"><div class="content">does view creation still list all files? ime even if not queried, the view would do a lot of s3 calls</div><br/><div id="40520344" class="c"><input type="checkbox" id="c-40520344" checked=""/><div class="controls bullet"><span class="by">rcaught</span><span>|</span><a href="#40517489">parent</a><span>|</span><a href="#40518090">next</a><span>|</span><label class="collapse" for="c-40520344">[-]</label><label class="expand" for="c-40520344">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;sql&#x2F;statements&#x2F;create_view" rel="nofollow">https:&#x2F;&#x2F;duckdb.org&#x2F;docs&#x2F;sql&#x2F;statements&#x2F;create_view</a> - the View is not physically materialized, but the query is run every time the view is referenced in a query.</div><br/></div></div></div></div><div id="40518090" class="c"><input type="checkbox" id="c-40518090" checked=""/><div class="controls bullet"><span class="by">halfcat</span><span>|</span><a href="#40517489">prev</a><span>|</span><a href="#40517836">next</a><span>|</span><label class="collapse" for="c-40518090">[-]</label><label class="expand" for="c-40518090">[2 more]</label></div><br/><div class="children"><div class="content">Conceptually is this sort of a database-agnostic SQL view? Seems like these could be stacked to simplify (or complicate?) an entire ETL pipeline.<p>I haven’t decided where I land on this. In some ways, stacking SQL views looks like it simplifies a bunch of ETL jobs, but I also fear a few things:<p>* It either breaks catastrophically when there’s a change in the source data<p>* Fails silently and just passes the incorrect data along<p>* More challenging to debug than an ETL pipeline where we have a clear point of error, can see the input and output of each stage, etc<p>* Source control of SQL views seems less great than code. Often when we have too many views, you can’t update one without dropping all of the dependencies and recreating them all<p>But I also wonder if I feel this way because I know programming better than SQL</div><br/><div id="40519458" class="c"><input type="checkbox" id="c-40519458" checked=""/><div class="controls bullet"><span class="by">banku_brougham</span><span>|</span><a href="#40518090">parent</a><span>|</span><a href="#40517836">next</a><span>|</span><label class="collapse" for="c-40519458">[-]</label><label class="expand" for="c-40519458">[1 more]</label></div><br/><div class="children"><div class="content">No you are right, views have an use case but they get abused as ersatz orchestration, creating a nested structure that multipkies the amount of needed compute.<p>edit: now I read your question more carefully. I think the s3 data is meant to be managed by other orchestration. This is a quick easy way to share a data source with an analyst, PM or end consumer.<p>I do not expect poster is advocating this as any intermediate stage in a data pipeline.</div><br/></div></div></div></div><div id="40517836" class="c"><input type="checkbox" id="c-40517836" checked=""/><div class="controls bullet"><span class="by">clumsysmurf</span><span>|</span><a href="#40518090">prev</a><span>|</span><a href="#40516494">next</a><span>|</span><label class="collapse" for="c-40517836">[-]</label><label class="expand" for="c-40517836">[1 more]</label></div><br/><div class="children"><div class="content">DuckDB has Swift bindings, but unfortunately, afaik, nothing official for Android. If anyone has gotten it working on Android I&#x27;d love to hear about it.</div><br/></div></div><div id="40516494" class="c"><input type="checkbox" id="c-40516494" checked=""/><div class="controls bullet"><span class="by">jhoechtl</span><span>|</span><a href="#40517836">prev</a><span>|</span><label class="collapse" for="c-40516494">[-]</label><label class="expand" for="c-40516494">[4 more]</label></div><br/><div class="children"><div class="content">Waiting for DDb to be able to read delta tables natively.</div><br/><div id="40516618" class="c"><input type="checkbox" id="c-40516618" checked=""/><div class="controls bullet"><span class="by">NortySpock</span><span>|</span><a href="#40516494">parent</a><span>|</span><label class="collapse" for="c-40516618">[-]</label><label class="expand" for="c-40516618">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;duckdb&#x2F;duckdb_delta">https:&#x2F;&#x2F;github.com&#x2F;duckdb&#x2F;duckdb_delta</a><p>Extension available (read only, apparently)</div><br/><div id="40516961" class="c"><input type="checkbox" id="c-40516961" checked=""/><div class="controls bullet"><span class="by">noone_important</span><span>|</span><a href="#40516494">root</a><span>|</span><a href="#40516618">parent</a><span>|</span><label class="collapse" for="c-40516961">[-]</label><label class="expand" for="c-40516961">[2 more]</label></div><br/><div class="children"><div class="content">I tried to use the extension, but unfortunately i couldn&#x27;t resolve my problems with it. I always run into errors when i try to execute queries on delta tables.</div><br/><div id="40517795" class="c"><input type="checkbox" id="c-40517795" checked=""/><div class="controls bullet"><span class="by">aleatorisch</span><span>|</span><a href="#40516494">root</a><span>|</span><a href="#40516961">parent</a><span>|</span><label class="collapse" for="c-40517795">[-]</label><label class="expand" for="c-40517795">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious what errors you were running into? Mind posting an issue in the repo, or here? Thanks!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>