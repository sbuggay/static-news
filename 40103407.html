<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713776468192" as="style"/><link rel="stylesheet" href="styles.css?v=1713776468192"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://agileotter.blogspot.com/2014/09/programming-is-mostly-thinking.html">Programming Is Mostly Thinking (2014)</a> <span class="domain">(<a href="http://agileotter.blogspot.com">agileotter.blogspot.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>215 comments</span></div><br/><div><div id="40104532" class="c"><input type="checkbox" id="c-40104532" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40104605">next</a><span>|</span><label class="collapse" for="c-40104532">[-]</label><label class="expand" for="c-40104532">[66 more]</label></div><br/><div class="children"><div class="content">Great article. I just want to comment on this quote from the article:<p>&quot;Really good developers do 90% or more of the work before they ever touch the  keyboard;&quot;<p>While that may be true sometimes, I think that ignores the fact that most people can&#x27;t keep a whole lot of constraints and concepts in their head at the same time. So the amount of pure thinking you can do without writing anything at all is extremely limited.<p>My solution to this problem is to actually hit the keyboard almost immediately once I have one or more possible ways to go about a problem, without first fully developing them into a well specified design. And then, I try as many of those as I think necessary, by actually writing the code. With experience, I&#x27;ve found that many times, what I initially thought would be the best solution turned out to be much worse than what was initially a less promising one. Nothing makes problems more apparent than concrete, running code.<p>In other words, I think that rather than just thinking, you need to put your ideas to the test by actually materializing them into code. And only then you can truly appreciate all consequences your ideas have on the final code.<p>This is not an original idea, of course, I think it&#x27;s just another way of describing the idea of software prototyping, or the idea that you should &quot;throw away&quot; your first iteration.<p>In yet different words: writing code should be actually seen as part of the &quot;thinking process&quot;.</div><br/><div id="40112553" class="c"><input type="checkbox" id="c-40112553" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40104895">next</a><span>|</span><label class="collapse" for="c-40112553">[-]</label><label class="expand" for="c-40112553">[1 more]</label></div><br/><div class="children"><div class="content">Also not every task requires deep thought. If you are writing some CRUD, it is usually not going to be all that much thinking, but more touching the keyboard.</div><br/></div></div><div id="40104895" class="c"><input type="checkbox" id="c-40104895" checked=""/><div class="controls bullet"><span class="by">indigoabstract</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40112553">prev</a><span>|</span><a href="#40104646">next</a><span>|</span><label class="collapse" for="c-40104895">[-]</label><label class="expand" for="c-40104895">[27 more]</label></div><br/><div class="children"><div class="content">I had the same thought as I read that line. I think he&#x27;s actually describing Linus Torvalds there, who, legend has it, thought about Git for a month or so and when he was done thinking, he got to work coding and in six days delivered the finished product. And then, on the seventh day he rested.<p>But for the rest of us (especially myself), it seems to be more like an interplay between thinking of what to write, writing it, testing it, thinking some more, changing some minor or major parts of what we wrote, and so on, until it feels good enough.<p>In the end, it&#x27;s a bit of an art, coming up with the final working version.</div><br/><div id="40111831" class="c"><input type="checkbox" id="c-40111831" checked=""/><div class="controls bullet"><span class="by">xiwenc</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40104895">parent</a><span>|</span><a href="#40105985">next</a><span>|</span><label class="collapse" for="c-40111831">[-]</label><label class="expand" for="c-40111831">[1 more]</label></div><br/><div class="children"><div class="content">Git is a special case i would say . Because it is fairly self contained. It had minimal dependencies on external components. It mostly relied on filesystem API. Everything else was “invented” inside of Git.<p>This is special because most real world systems has a lot more dependencies. That’s when experimentation is required. Because one cannot know all relevant API’s beforehand and their behaviors. Therefore the only way is to do it and find out.<p>Algorithms are in essence mathematical problems, therefore is abstract and should be able to be solved in the head or use pen and paper.<p>Reality is that most programming problems are not algorithms but connecting and translating between systems. And these systems are like blackboxes that require exploration.</div><br/></div></div><div id="40105985" class="c"><input type="checkbox" id="c-40105985" checked=""/><div class="controls bullet"><span class="by">alfagre</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40104895">parent</a><span>|</span><a href="#40111831">prev</a><span>|</span><a href="#40106511">next</a><span>|</span><label class="collapse" for="c-40105985">[-]</label><label class="expand" for="c-40105985">[10 more]</label></div><br/><div class="children"><div class="content">I tend to see this as a sign that a design is still too complicated. Keep simplifying, which may include splitting into components that are separately easy to keep in your head.<p>This is really important for maintenance later on. If it&#x27;s too complicated now to keep in your head, how will you ever have a chance to maintain it 3 years down the line? Or explain it to somebody else?</div><br/><div id="40109771" class="c"><input type="checkbox" id="c-40109771" checked=""/><div class="controls bullet"><span class="by">thyrsus</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105985">parent</a><span>|</span><a href="#40106362">next</a><span>|</span><label class="collapse" for="c-40109771">[-]</label><label class="expand" for="c-40109771">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m more than half the time figuring out the environment.  Just as you learn a new language by doing the exercises, I&#x27;m learning a bunch of stuff while I try to port our iptables semantics o firewalld:
[a] gitlab CI&#x2F;CD instead of Jenkins [b] getting firewalld (requires systemd) running in a container [c] the ansible firewalld module doesn&#x27;t support --direct required for destination filtering [d] inventing a test suite for firewall rules, since the prebuilt I&#x27;ve found would involve weeks of yak shaving to get operating.  So I&#x27;m simultaneously learning about four environments&#x2F;languages at once - and this is typical for the kind of project I get assigned.  There&#x27;s a *lot* of exploratory coding happening.  I didn&#x27;t choose this stuff - it&#x27;s part of the new requirements.  I try for simple first, and often the tools don&#x27;t support simple.</div><br/></div></div><div id="40106362" class="c"><input type="checkbox" id="c-40106362" checked=""/><div class="controls bullet"><span class="by">mannykannot</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105985">parent</a><span>|</span><a href="#40109771">prev</a><span>|</span><a href="#40110519">next</a><span>|</span><label class="collapse" for="c-40106362">[-]</label><label class="expand" for="c-40106362">[3 more]</label></div><br/><div class="children"><div class="content">This is the only practical way (IMHO) to do a good job, but there can be an irreducibly complex kernel to a problem which manifests itself in the interactions between components even when each atomic component is simple.</div><br/><div id="40111932" class="c"><input type="checkbox" id="c-40111932" checked=""/><div class="controls bullet"><span class="by">alfagre</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40106362">parent</a><span>|</span><a href="#40110519">next</a><span>|</span><label class="collapse" for="c-40111932">[-]</label><label class="expand" for="c-40111932">[2 more]</label></div><br/><div class="children"><div class="content">Then the component APIs need improvement.</div><br/><div id="40112327" class="c"><input type="checkbox" id="c-40112327" checked=""/><div class="controls bullet"><span class="by">blksv</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40111932">parent</a><span>|</span><a href="#40110519">next</a><span>|</span><label class="collapse" for="c-40112327">[-]</label><label class="expand" for="c-40112327">[1 more]</label></div><br/><div class="children"><div class="content">At the microlevel (where we pass actual data objects between functions), the difference in the amount of work required between designing data layout &quot;on paper&quot; and &quot;in code&quot; is often negligible and not in favor of &quot;paper&quot;, because some important interactions can sneak out of sight.<p>I do data flow diagrams a lot (to understand the domain, figure out dependencies, and draw rough component and procedure boundaries) but leave the details of data formats and APIs to exploratory coding. It still makes me change the diagrams, because I&#x27;ve missed something.</div><br/></div></div></div></div></div></div><div id="40108188" class="c"><input type="checkbox" id="c-40108188" checked=""/><div class="controls bullet"><span class="by">indigoabstract</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105985">parent</a><span>|</span><a href="#40110519">prev</a><span>|</span><a href="#40109372">next</a><span>|</span><label class="collapse" for="c-40108188">[-]</label><label class="expand" for="c-40108188">[2 more]</label></div><br/><div class="children"><div class="content">If you can do that, sure. Architecting a clear design beforehand isn&#x27;t always feasible though, especially when you&#x27;re doing a thing for the first time or you&#x27;re exploring what works and what doesn&#x27;t, like in game programming, for example. And then, there are also the various levels at which designing and implementation takes place.<p>In the end, I find my mental picture is still the most important.
And when that fades after a while, or for code written by someone else, then I just have to go read the code. Though it may exist, so far I haven&#x27;t found a way that&#x27;s obviously better.<p>Some thing I&#x27;ve tried (besides commenting code) are doing diagrams (they lose sync over time) and using AI assistants to explain code (not very useful yet). I didn&#x27;t feel they made the difference, but we have to keep learning in this job.</div><br/><div id="40111942" class="c"><input type="checkbox" id="c-40111942" checked=""/><div class="controls bullet"><span class="by">alfagre</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40108188">parent</a><span>|</span><a href="#40109372">next</a><span>|</span><label class="collapse" for="c-40111942">[-]</label><label class="expand" for="c-40111942">[1 more]</label></div><br/><div class="children"><div class="content">Of course it can be helpful to do some prototyping to see which parts still need design improvements and to understand the problem space better. That&#x27;s part of coming up with the good design and architecture, it takes work!</div><br/></div></div></div></div><div id="40109372" class="c"><input type="checkbox" id="c-40109372" checked=""/><div class="controls bullet"><span class="by">stoperaticless</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105985">parent</a><span>|</span><a href="#40108188">prev</a><span>|</span><a href="#40108328">next</a><span>|</span><label class="collapse" for="c-40109372">[-]</label><label class="expand" for="c-40109372">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes, as code get’s written, it becomes clearer what kind of component split is better, which things can be cleanly separated and which less so.</div><br/></div></div><div id="40108328" class="c"><input type="checkbox" id="c-40108328" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105985">parent</a><span>|</span><a href="#40109372">prev</a><span>|</span><a href="#40106511">next</a><span>|</span><label class="collapse" for="c-40108328">[-]</label><label class="expand" for="c-40108328">[1 more]</label></div><br/><div class="children"><div class="content">The real world bank processes themselves are significantly more complicated than for any one person to hold it in their head. Simplification is important <i>but</i> only until the point it still completes 100% of the required functionality.<p>Code also functions as documentation for the actual process. In many cases “whatever the software do” is the process itself.</div><br/></div></div></div></div><div id="40106511" class="c"><input type="checkbox" id="c-40106511" checked=""/><div class="controls bullet"><span class="by">throw1234651234</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40104895">parent</a><span>|</span><a href="#40105985">prev</a><span>|</span><a href="#40105013">next</a><span>|</span><label class="collapse" for="c-40106511">[-]</label><label class="expand" for="c-40106511">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t do it in my head. I do diagrams, then discuss them with other people until everyone is on the same page. It&#x27;s amazing how convoluted get data from db, do something to it, send it back can get, especially if there is a queue or multiple consumers in play, when it&#x27;s actually the simplest thing in the world, which is why people get over-confident and write super-confusing code.</div><br/><div id="40111218" class="c"><input type="checkbox" id="c-40111218" checked=""/><div class="controls bullet"><span class="by">bigger_cheese</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40106511">parent</a><span>|</span><a href="#40105013">next</a><span>|</span><label class="collapse" for="c-40111218">[-]</label><label class="expand" for="c-40111218">[1 more]</label></div><br/><div class="children"><div class="content">Diagrams are what I tend to use as well, my background is Engineering (the non software kind) for solving engineering problems one of the first thing we are taught to do at uni is to sketch out the problem and I have somewhat carried that habit over when I need to  write a computer program.<p>I map out on paper the logical steps my code needs to follow a bit like a flow chart tracking the change in states.<p>When I write code I&#x27;ll create like a skeleton with placeholder functions I think I&#x27;ll need as stubs and fill them out as I go, I&#x27;m not wedded to the design sometimes I&#x27;ll remove&#x2F; replace etc whole sections as I get further in but it helps me think about it if I have the whole skeleton &quot;on the page&quot;</div><br/></div></div></div></div><div id="40105013" class="c"><input type="checkbox" id="c-40105013" checked=""/><div class="controls bullet"><span class="by">tsss</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40104895">parent</a><span>|</span><a href="#40106511">prev</a><span>|</span><a href="#40108279">next</a><span>|</span><label class="collapse" for="c-40105013">[-]</label><label class="expand" for="c-40105013">[12 more]</label></div><br/><div class="children"><div class="content">Well that explains why Git has such a god awful API. Maybe he should&#x27;ve done some prototyping too.</div><br/><div id="40107780" class="c"><input type="checkbox" id="c-40107780" checked=""/><div class="controls bullet"><span class="by">patmcc</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105013">parent</a><span>|</span><a href="#40105946">next</a><span>|</span><label class="collapse" for="c-40107780">[-]</label><label class="expand" for="c-40107780">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m going to take a stab here: you&#x27;ve never used cvs or svn. git, for all its warts, is quite literally a 10x improvement on those, which is what it was (mostly) competing with.</div><br/><div id="40107938" class="c"><input type="checkbox" id="c-40107938" checked=""/><div class="controls bullet"><span class="by">commandar</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40107780">parent</a><span>|</span><a href="#40108218">next</a><span>|</span><label class="collapse" for="c-40107938">[-]</label><label class="expand" for="c-40107938">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really hard to overstate how much of a sea change git was.<p>It&#x27;s very rare that a new piece of software just completely supplants existing solutions as widely and quickly as git did in the version control space.</div><br/><div id="40112356" class="c"><input type="checkbox" id="c-40112356" checked=""/><div class="controls bullet"><span class="by">fransje26</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40107938">parent</a><span>|</span><a href="#40108218">next</a><span>|</span><label class="collapse" for="c-40112356">[-]</label><label class="expand" for="c-40112356">[1 more]</label></div><br/><div class="children"><div class="content">And all that because the company owning the commercial version control system they had been using free of charge until that point got greedy, and wanted them to start paying for its use.<p>Their greed literally killed their own business model, and brought us a better versioning system.  Bless their greedy heart.</div><br/></div></div></div></div><div id="40108218" class="c"><input type="checkbox" id="c-40108218" checked=""/><div class="controls bullet"><span class="by">dave78</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40107780">parent</a><span>|</span><a href="#40107938">prev</a><span>|</span><a href="#40105946">next</a><span>|</span><label class="collapse" for="c-40108218">[-]</label><label class="expand" for="c-40108218">[2 more]</label></div><br/><div class="children"><div class="content">I started my career with Clearcase (ick) and added CVS for personal projects shortly after. CVS always kind of sucked, even compared with Clearcase. Subversion was a massive improvement, and I was pretty happy with it for a long time. I resisted moving from Subversion to Git for a while but eventually caved like nearly everyone else. After learning it sufficiently, I now enjoy Git, and I think the model it uses is better in nearly every way than Subversion.<p>But the point of the parent of your post is correct, in my opinion. The Git interface sucks. Subversion&#x27;s was much more consistent, and therefore better. Imagine how much better Git could be if it had had a little more thought and consistency put into the interface.<p>I thought it was pretty universally agreed that the Git interface sucks. I&#x27;m surprised to see someone arguing otherwise.</div><br/><div id="40109651" class="c"><input type="checkbox" id="c-40109651" checked=""/><div class="controls bullet"><span class="by">stoperaticless</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40108218">parent</a><span>|</span><a href="#40105946">next</a><span>|</span><label class="collapse" for="c-40109651">[-]</label><label class="expand" for="c-40109651">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I thought it was pretty universally agreed<p>Depends what you consider “universally agreed”.<p>At least one person (me) thinks that: git interface is good enough as is (function&gt;form here), regexps are not too terse - that’s the whole point of them.<p>Related if you squint a lot: <a href="https:&#x2F;&#x2F;prog21.dadgum.com&#x2F;170.html" rel="nofollow">https:&#x2F;&#x2F;prog21.dadgum.com&#x2F;170.html</a></div><br/></div></div></div></div></div></div><div id="40105946" class="c"><input type="checkbox" id="c-40105946" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105013">parent</a><span>|</span><a href="#40107780">prev</a><span>|</span><a href="#40106916">next</a><span>|</span><label class="collapse" for="c-40105946">[-]</label><label class="expand" for="c-40105946">[1 more]</label></div><br/><div class="children"><div class="content">On the other side the hooks system of git is very good api design imo.</div><br/></div></div><div id="40106916" class="c"><input type="checkbox" id="c-40106916" checked=""/><div class="controls bullet"><span class="by">QuercusMax</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105013">parent</a><span>|</span><a href="#40105946">prev</a><span>|</span><a href="#40105339">next</a><span>|</span><label class="collapse" for="c-40106916">[-]</label><label class="expand" for="c-40106916">[2 more]</label></div><br/><div class="children"><div class="content">What do you mean by API? Linus&#x27;s original got didn&#x27;t have an API, just a bunch of low level C commands (&#x27;plumbing&#x27;). The CLI (&#x27;porcelain&#x27;) was originally just wrappers around the plumbing.</div><br/><div id="40107316" class="c"><input type="checkbox" id="c-40107316" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40106916">parent</a><span>|</span><a href="#40105339">next</a><span>|</span><label class="collapse" for="c-40107316">[-]</label><label class="expand" for="c-40107316">[1 more]</label></div><br/><div class="children"><div class="content">Those C functions are the API for git.</div><br/></div></div></div></div><div id="40105339" class="c"><input type="checkbox" id="c-40105339" checked=""/><div class="controls bullet"><span class="by">indigoabstract</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105013">parent</a><span>|</span><a href="#40106916">prev</a><span>|</span><a href="#40107263">next</a><span>|</span><label class="collapse" for="c-40105339">[-]</label><label class="expand" for="c-40105339">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, could be.. IIRC, he said he doesn&#x27;t find version control and databases interesting. So he just did what had to be done, did it quickly and then delegated, so he could get back to more satisfying work.<p>I can relate to that.</div><br/></div></div><div id="40107263" class="c"><input type="checkbox" id="c-40107263" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105013">parent</a><span>|</span><a href="#40105339">prev</a><span>|</span><a href="#40108279">next</a><span>|</span><label class="collapse" for="c-40107263">[-]</label><label class="expand" for="c-40107263">[1 more]</label></div><br/><div class="children"><div class="content">baseless conjecture</div><br/></div></div></div></div><div id="40108279" class="c"><input type="checkbox" id="c-40108279" checked=""/><div class="controls bullet"><span class="by">ant6n</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40104895">parent</a><span>|</span><a href="#40105013">prev</a><span>|</span><a href="#40104646">next</a><span>|</span><label class="collapse" for="c-40108279">[-]</label><label class="expand" for="c-40108279">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; …and when he was done thinking, he got to work coding and in six days delivered the finished product. And then, on the seventh day he rested.<p>How very biblical. “And Torwalds saw everything that he had made, and behold, it was very good. And there was evening, and there was morning—the sixth day.”</div><br/></div></div></div></div><div id="40104646" class="c"><input type="checkbox" id="c-40104646" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40104895">prev</a><span>|</span><a href="#40106769">next</a><span>|</span><label class="collapse" for="c-40104646">[-]</label><label class="expand" for="c-40104646">[9 more]</label></div><br/><div class="children"><div class="content">I tend to iterate.<p>I get a general idea, then start writing code; usually the &quot;sticky&quot; parts, where I anticipate the highest likelihood of trouble.<p>I&#x27;ve learned that I can&#x27;t anticipate all the problems, and I really need to encounter them in practice.<p>This method often means that I need to throw out a <i>lot</i> of work.<p>I seldom write stuff down[0], until I know that I&#x27;m on the right track, which reduces what I call &quot;Concrete Galoshes.&quot;[1]<p>[0] <a href="https:&#x2F;&#x2F;littlegreenviper.com&#x2F;miscellany&#x2F;evolutionary-design-specification&#x2F;" rel="nofollow">https:&#x2F;&#x2F;littlegreenviper.com&#x2F;miscellany&#x2F;evolutionary-design-...</a><p>[1] <a href="https:&#x2F;&#x2F;littlegreenviper.com&#x2F;miscellany&#x2F;concrete-galoshes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;littlegreenviper.com&#x2F;miscellany&#x2F;concrete-galoshes&#x2F;</a></div><br/><div id="40105380" class="c"><input type="checkbox" id="c-40105380" checked=""/><div class="controls bullet"><span class="by">JKCalhoun</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40104646">parent</a><span>|</span><a href="#40106769">next</a><span>|</span><label class="collapse" for="c-40105380">[-]</label><label class="expand" for="c-40105380">[8 more]</label></div><br/><div class="children"><div class="content">I do the same, iterate. When I am happy with the code I imagine I&#x27;ve probably rewritten it roughly three times.<p>Now I could have spent that time &quot;whiteboarding&quot; and it&#x27;s possible I would have come close to the same solution. But whiteboarding in my mind is still guessing, anticipating - coding is of course real.<p>I think that as you gain experience as a programmer you are able to intuit the right way to begin to code a problem, the iterating is still there but more incremental.</div><br/><div id="40105687" class="c"><input type="checkbox" id="c-40105687" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105380">parent</a><span>|</span><a href="#40105497">next</a><span>|</span><label class="collapse" for="c-40105687">[-]</label><label class="expand" for="c-40105687">[2 more]</label></div><br/><div class="children"><div class="content">I think once you are an experienced programmer, beyond being able to break down the target state into chunks of task, you are able to intuit pitfalls&#x2F;blockers within those chunks better than less experienced programmers.<p>An experienced programmer is also more cognizant of the importance of architectural decisions, hitting the balance between keeping things simple vs abstractions and the balance between making things flexible vs YAGNI.<p>Once those important bits are taken care of, rest of it is more or less personal style.</div><br/><div id="40108036" class="c"><input type="checkbox" id="c-40108036" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105687">parent</a><span>|</span><a href="#40105497">next</a><span>|</span><label class="collapse" for="c-40108036">[-]</label><label class="expand" for="c-40108036">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, while I understand rewrite-based iterations, and have certainly done them before, they&#x27;ve gotten less and less common over time because I&#x27;m thinking about projects at higher levels than I used to.  The final design is more and more often what I already have in my head before I start.<p>I never hold all the code designed in my head at once, but it&#x27;s more like multiple linked thoughts.  One idea for the overall structure composed of multiple smaller pieces, then the smaller pieces each have their own design that I can individually hold in my head.  Often recursively down, depending on how big the given project is and how much it naturally breaks down.  There&#x27;s certainly unknowns or bugs as I go, but it&#x27;s usually more like handling an edge case than anything wrong with the design that ends in a rewrite.</div><br/></div></div></div></div><div id="40105497" class="c"><input type="checkbox" id="c-40105497" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105380">parent</a><span>|</span><a href="#40105687">prev</a><span>|</span><a href="#40105569">next</a><span>|</span><label class="collapse" for="c-40105497">[-]</label><label class="expand" for="c-40105497">[3 more]</label></div><br/><div class="children"><div class="content">I don’t think this methodology works, unless we are very experienced.<p>I wanted to work that way, when I was younger, but the results were seldom good.<p><i>Good judgment comes from experience. Experience comes from bad judgment.</i><p>-Attributed to Nasrudin</div><br/><div id="40108065" class="c"><input type="checkbox" id="c-40108065" checked=""/><div class="controls bullet"><span class="by">marktani</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105497">parent</a><span>|</span><a href="#40105569">next</a><span>|</span><label class="collapse" for="c-40108065">[-]</label><label class="expand" for="c-40108065">[2 more]</label></div><br/><div class="children"><div class="content">Who&#x27;s Nasrudin?<p>Apparently this quote has been attributed to an Uncle Zeke :) [0]<p>[0]: <a href="https:&#x2F;&#x2F;quoteinvestigator.com&#x2F;2017&#x2F;02&#x2F;23&#x2F;judgment&#x2F;" rel="nofollow">https:&#x2F;&#x2F;quoteinvestigator.com&#x2F;2017&#x2F;02&#x2F;23&#x2F;judgment&#x2F;</a></div><br/><div id="40108125" class="c"><input type="checkbox" id="c-40108125" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40108065">parent</a><span>|</span><a href="#40105569">next</a><span>|</span><label class="collapse" for="c-40108125">[-]</label><label class="expand" for="c-40108125">[1 more]</label></div><br/><div class="children"><div class="content">Nasrudin (or Nasreddin)[0] is an apocryphal Sufi priest, who is sort of a &quot;collection bin&quot; for wise and witty sayings. Great stories. Lots of humor, and lots of wisdom.<p>One of my &quot;go-tos&quot; from him, is the Smoke Seller[1]. I think that story applies to the Tech Scene.<p>I first heard the GC quote as attributed to Will Rogers, then, to Rita Mae Brown.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Nasreddin" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Nasreddin</a><p>[1] <a href="https:&#x2F;&#x2F;www.tell-a-tale.com&#x2F;nasreddin-hodja-story-smoke-seller&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tell-a-tale.com&#x2F;nasreddin-hodja-story-smoke-sell...</a></div><br/></div></div></div></div></div></div><div id="40105569" class="c"><input type="checkbox" id="c-40105569" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105380">parent</a><span>|</span><a href="#40105497">prev</a><span>|</span><a href="#40106769">next</a><span>|</span><label class="collapse" for="c-40105569">[-]</label><label class="expand" for="c-40105569">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, the same. I rewrite code until I&#x27;m happy with it. When starting new program, it might cause lots of time wasted because I might need to spend weeks rewriting and re-tossing everything until I feel I got it good enough. Tried to do it faster, but I just can&#x27;t. The only way is to write a working code and reflect on it.<p>My only optimization of this process is to use Java and not just throw out everything, but keep refactoring. Idea allows for very quick and safe refactoring cycles, so I can iterate on overall architecture or any selected components.<p>I really envy on people who can get it right first time. I just can&#x27;t, despite having 20 years of programming under my seat. And when time is tight and I need to accept obviously bad design, that what makes me burning out.</div><br/><div id="40106323" class="c"><input type="checkbox" id="c-40106323" checked=""/><div class="controls bullet"><span class="by">shuvuvt5</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105569">parent</a><span>|</span><a href="#40106769">next</a><span>|</span><label class="collapse" for="c-40106323">[-]</label><label class="expand" for="c-40106323">[1 more]</label></div><br/><div class="children"><div class="content">Nobody gets it right the first time.<p>Good design evolves from knowing the problem space.<p>Until you&#x27;ve explored it you don&#x27;t know it.<p>I&#x27;ve seen some really good systems that have been built in one shot. They were all ground up rewrites of other very well known but fatally flawed systems.<p>And even then, within them, much of the architecture had to be reworked or also had some other trade off that had to be made.</div><br/></div></div></div></div></div></div></div></div><div id="40106769" class="c"><input type="checkbox" id="c-40106769" checked=""/><div class="controls bullet"><span class="by">tibbar</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40104646">prev</a><span>|</span><a href="#40104679">next</a><span>|</span><label class="collapse" for="c-40106769">[-]</label><label class="expand" for="c-40106769">[2 more]</label></div><br/><div class="children"><div class="content">The secret to designing entire applications in your head is to be intimately familiar with the underlying platform and gotcha&#x27;s of the technology you&#x27;re using. And the only way to learn <i>those</i> is to spend a lot of time in hands-on coding and active study. It also implies that you&#x27;re using the same technology stack over and over and over again instead of pushing yourself into new areas. There&#x27;s nothing wrong with this; I actually prefer sticking to the same tech stack, so I can focus on the problem itself; but I would note that the kind of &#x27;great developer&#x27; in view here is probably fairly one-dimensional with respect to the tools they use.</div><br/><div id="40109029" class="c"><input type="checkbox" id="c-40109029" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40106769">parent</a><span>|</span><a href="#40104679">next</a><span>|</span><label class="collapse" for="c-40109029">[-]</label><label class="expand" for="c-40109029">[1 more]</label></div><br/><div class="children"><div class="content">You make me feel a lot better about my skill set!</div><br/></div></div></div></div><div id="40104679" class="c"><input type="checkbox" id="c-40104679" checked=""/><div class="controls bullet"><span class="by">lwhi</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40106769">prev</a><span>|</span><a href="#40105634">next</a><span>|</span><label class="collapse" for="c-40104679">[-]</label><label class="expand" for="c-40104679">[1 more]</label></div><br/><div class="children"><div class="content">I think first on a macro level, and use mind maps and diagrams to keep things linked and organised.<p>As I&#x27;ve grown older, the importance of architecture over micro decision has become blindingly apparent.<p>The micro can be optimised. Macro level decisions are often permanent.</div><br/></div></div><div id="40105634" class="c"><input type="checkbox" id="c-40105634" checked=""/><div class="controls bullet"><span class="by">swat535</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40104679">prev</a><span>|</span><a href="#40111444">next</a><span>|</span><label class="collapse" for="c-40105634">[-]</label><label class="expand" for="c-40105634">[4 more]</label></div><br/><div class="children"><div class="content">Right, I always thought this is what TDD is used for, very often I design my code in tests and let it kind of guide my implementation.<p>I kind of imagine what the end result should be in my head (given value A and B, these rows should be X and Y), then write the tests in what I _think_ would be a good api for my system and go from there.<p>The end result is that my code is testable by default and I get to go through multiple cycles on Red -&gt; Green -&gt; Refactor until I end up being happy with.<p>Does anyone else work like this?</div><br/><div id="40111566" class="c"><input type="checkbox" id="c-40111566" checked=""/><div class="controls bullet"><span class="by">sho</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105634">parent</a><span>|</span><a href="#40106347">next</a><span>|</span><label class="collapse" for="c-40111566">[-]</label><label class="expand" for="c-40111566">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes, when I feel like I know the basic domain and can think of something reasonable that I could use as a &quot;north star&quot; test end-point, I work like this. Think anything that could be a unit test, or even a simple functional test. But when I don&#x27;t know the domain, or if it&#x27;s some complex system that I have to come up from scratch, writing tests first often makes no sense at all. Then I&#x27;d usually start literally drawing on paper, or typing descriptions of what it might do, then just start coding, and the tests come much, much later.<p>Right tool for the job, as always! The only thing I can&#x27;t stand is blind zealotry to one way or the other. I&#x27;ve had to work with some real TDD zealots in the past, and long story short, I won&#x27;t work with people like that again.</div><br/></div></div><div id="40106347" class="c"><input type="checkbox" id="c-40106347" checked=""/><div class="controls bullet"><span class="by">shuvuvt5</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105634">parent</a><span>|</span><a href="#40111566">prev</a><span>|</span><a href="#40111444">next</a><span>|</span><label class="collapse" for="c-40106347">[-]</label><label class="expand" for="c-40106347">[2 more]</label></div><br/><div class="children"><div class="content">TDD comes up with some really novel designs sometimes.<p>Like, I expect it should look one way but after I&#x27;m done with a few TDD cycles I&#x27;m at a state that&#x27;s either hard to get there or unnecessary.<p>I think this is why some people don&#x27;t like TDD much, sometimes you have to let go of your ideas, or if you&#x27;re stuck to them, you need to go back much earlier and try again.<p>I kind of like this though, makes it kind of like you&#x27;re following a choose your own adventure book.</div><br/><div id="40111286" class="c"><input type="checkbox" id="c-40111286" checked=""/><div class="controls bullet"><span class="by">gnz00</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40106347">parent</a><span>|</span><a href="#40111444">next</a><span>|</span><label class="collapse" for="c-40111286">[-]</label><label class="expand" for="c-40111286">[1 more]</label></div><br/><div class="children"><div class="content">I prefer to write an initial implementation, and then in the testing process figure out which interfaces simplify my tests, and then I refactor the implementation to use those interfaces. Generally, this avoids unnecessary abstraction, as the interfaces for testing tend to be the same ones you might need for extensibility.</div><br/></div></div></div></div></div></div><div id="40111444" class="c"><input type="checkbox" id="c-40111444" checked=""/><div class="controls bullet"><span class="by">gofreddygo</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40105634">prev</a><span>|</span><a href="#40104675">next</a><span>|</span><label class="collapse" for="c-40111444">[-]</label><label class="expand" for="c-40111444">[1 more]</label></div><br/><div class="children"><div class="content">I agree with the spirit of &quot;writing code&quot; as part of the thinking process but I have to point out a few very dangerous pitfalls there.<p>first is the urge to write the whole prototype yourself from scratch. Not necessary, better avoided. You should just hack some things together, or pick something close to what you want off github. Idea is to have something working. I am a big proponent of implementing my ideas in a spreadsheet, then off to some code.<p>Second is modern software solutions are complex (think kubernetes, cloud provider quirks, authentication, sql&#x2F;nosql, external apis) and easy to get lost in the minutiae, they shroud the original idea and takes strenuous effort to think clearly through the layers. To counter this, I keep a single project in my language of choice with the core business logic. No dependencies. everything else is stubbed or mocked. It runs in the IDE, on my laptop, offline with tests. This extra effort has paid off well to focus on core priorities and identify when bullshit tries to creep in. You could also use diagrams or whatever but working executable code is awesome to have.<p>third is to document my findings. Often I tend to tinker with the prototype way beyond the point of any meaningful threshold. its 2am before i know it and i kinda lose the lessons when i start the next day. Keeping a log  in parallel with building the prototype helps me stay focussed, be clear in what my goals are and avoid repeating the same mistakes.<p>fourth is the rather controversial topic of estimation. When i have a running prototype, I tend to get excited and get too optimistic with my estimates. Rookie mistake. Always pad your estimates one order of magnitude higher. You still need to go through a lot of bs to get it into production. Remember that you will be working with a team, mostly idiots. Linus works alone.</div><br/></div></div><div id="40104675" class="c"><input type="checkbox" id="c-40104675" checked=""/><div class="controls bullet"><span class="by">prerok</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40111444">prev</a><span>|</span><a href="#40107419">next</a><span>|</span><label class="collapse" for="c-40104675">[-]</label><label class="expand" for="c-40104675">[1 more]</label></div><br/><div class="children"><div class="content">I could not agree more, it&#x27;s rare to write a program where you know all the dependencies, libraries you will use and the overall effect to other parts of the program by heart. So, gradual design process is best.<p>I would point out, though, that that part also touched understanding requirements, which is many times a very difficult process. We might have a technical requirement conjured, by someone less knowledgeable about the inner workings, from a customer requirement and the resolution of the technical requirement may not even closely address the end-users&#x27; use-case. So, a lot of time also goes into understanding what it is that the end-users actually need.</div><br/></div></div><div id="40107419" class="c"><input type="checkbox" id="c-40107419" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40104675">prev</a><span>|</span><a href="#40110209">next</a><span>|</span><label class="collapse" for="c-40107419">[-]</label><label class="expand" for="c-40107419">[1 more]</label></div><br/><div class="children"><div class="content">That quote is already a quote in the article. The article author himself writes:<p>&gt; What is really happening?<p>&gt; • Programmers were typing on and off all day. Those 30 minutes are to recreate the net result of all the work they wrote, un-wrote, edited, and reworked through the day. It is not all the effort they put in, it is only the residue of the effort.<p>So at least there the article agrees with you.</div><br/></div></div><div id="40110209" class="c"><input type="checkbox" id="c-40110209" checked=""/><div class="controls bullet"><span class="by">narag</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40107419">prev</a><span>|</span><a href="#40111122">next</a><span>|</span><label class="collapse" for="c-40110209">[-]</label><label class="expand" for="c-40110209">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s more than one way to do it.<p>How I work:<p>- First I make a very general design of modules, taking into account how they are going to communicate with each other, all based in experience with previous systems.<p>- I foresee problematic parts, usually integration points, and write simple programs to validate assumptions and test performance.<p>- I write a skeleton for the main program with a dumbed-down GUI.<p>From that point on, I develop each module and now, yes, there&#x27;s a lot of thinking in advance.</div><br/></div></div><div id="40111122" class="c"><input type="checkbox" id="c-40111122" checked=""/><div class="controls bullet"><span class="by">knodi123</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40110209">prev</a><span>|</span><a href="#40104637">next</a><span>|</span><label class="collapse" for="c-40111122">[-]</label><label class="expand" for="c-40111122">[1 more]</label></div><br/><div class="children"><div class="content">ditto.  My coworkers will sit down at the whiteboard and start making ERDs, and I&#x27;ll just start writing a DB migration and sketching up the models.  They think I&#x27;m crazy, because I have to do rollbacks and recreate my table a few times as I think of more things, and I wind up deleting some code that I already wrote and technically worked.  Who cares?  Time-wise, it comes out the same in the end, and I find and solve more hidden surprises by experimenting than they do by planning what they&#x27;re going to do once they&#x27;re finally ready to type.<p>I think it&#x27;s just two ways of doing the same thing.</div><br/></div></div><div id="40104637" class="c"><input type="checkbox" id="c-40104637" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40111122">prev</a><span>|</span><a href="#40105343">next</a><span>|</span><label class="collapse" for="c-40104637">[-]</label><label class="expand" for="c-40104637">[3 more]</label></div><br/><div class="children"><div class="content">Pen, paper, diagrams.</div><br/><div id="40105468" class="c"><input type="checkbox" id="c-40105468" checked=""/><div class="controls bullet"><span class="by">lwhi</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40104637">parent</a><span>|</span><a href="#40105048">prev</a><span>|</span><a href="#40105343">next</a><span>|</span><label class="collapse" for="c-40105468">[-]</label><label class="expand" for="c-40105468">[1 more]</label></div><br/><div class="children"><div class="content">Xmind and draw.io</div><br/></div></div></div></div><div id="40105343" class="c"><input type="checkbox" id="c-40105343" checked=""/><div class="controls bullet"><span class="by">Aerroon</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40104637">prev</a><span>|</span><a href="#40106259">next</a><span>|</span><label class="collapse" for="c-40105343">[-]</label><label class="expand" for="c-40105343">[1 more]</label></div><br/><div class="children"><div class="content">The way I read that is that only 10% of the work is writing out the actual implementation that you&#x27;re sticking with. How you get there isn&#x27;t as important. Ie someone might want to take notes on paper and draw graphs while others might want to type things out. That&#x27;s all still planning.</div><br/></div></div><div id="40106259" class="c"><input type="checkbox" id="c-40106259" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40105343">prev</a><span>|</span><a href="#40106281">next</a><span>|</span><label class="collapse" for="c-40106259">[-]</label><label class="expand" for="c-40106259">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to second that, especially if combined with a process where a lot of code should get discarded before making it into the repository. Undoing and reconsidering initial ideas is crucial to any creative flow I&#x27;ve had.</div><br/></div></div><div id="40106281" class="c"><input type="checkbox" id="c-40106281" checked=""/><div class="controls bullet"><span class="by">andsmedeiros</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40106259">prev</a><span>|</span><a href="#40110954">next</a><span>|</span><label class="collapse" for="c-40106281">[-]</label><label class="expand" for="c-40106281">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the quote suggests that a programmer would mentally design a whole system before writing any code. As programmers, we are used to thinking in problems as steps needing resolution and that&#x27;s exactly the 90% there. 
When you&#x27;re quickly prototyping to see what fits better as a solution to the problem you&#x27;re facing, you must have already thought what are the requirements, what are the constraints, what would be a reasonable API given your use case. Poking around until you find a reasonable path forward means you have already defined which way is forwards.</div><br/></div></div><div id="40110954" class="c"><input type="checkbox" id="c-40110954" checked=""/><div class="controls bullet"><span class="by">BurningFrog</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40106281">prev</a><span>|</span><a href="#40107374">next</a><span>|</span><label class="collapse" for="c-40110954">[-]</label><label class="expand" for="c-40110954">[1 more]</label></div><br/><div class="children"><div class="content">I used to think a lot before coding.<p>Then I learned TDD, and now I can discover the design while I code. It&#x27;s a huge improvement for me!</div><br/></div></div><div id="40107374" class="c"><input type="checkbox" id="c-40107374" checked=""/><div class="controls bullet"><span class="by">tippytippytango</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40110954">prev</a><span>|</span><a href="#40105173">next</a><span>|</span><label class="collapse" for="c-40107374">[-]</label><label class="expand" for="c-40107374">[1 more]</label></div><br/><div class="children"><div class="content">I also find it critical to start writing immediately. Just my thoughts and research results. I also like to attempt to write code too early. I&#x27;ll get blocked very quickly or realize what I&#x27;m writing won&#x27;t work, and it brings the blockage to the forefront of my mind. If I don&#x27;t try to write code there will be some competing theories in my mind and they won&#x27;t be prioritized correctly.</div><br/></div></div><div id="40105173" class="c"><input type="checkbox" id="c-40105173" checked=""/><div class="controls bullet"><span class="by">devsda</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40107374">prev</a><span>|</span><a href="#40105810">next</a><span>|</span><label class="collapse" for="c-40105173">[-]</label><label class="expand" for="c-40105173">[3 more]</label></div><br/><div class="children"><div class="content">I agree this is how it often goes.<p>But this also makes it difficult to give accurate estimates because you sometimes need to prototype 2,3 or even more designs to workout the 
best option.<p>&gt; writing code should be actually seen as part of the &quot;thinking process&quot;.<p>Unfortunately most of the times  leadership dont&#x27; see things this way. For them the tough work of thinking ends with architecture or another layer down. Then the engineers are responsible only for translating those designs into software <i>just</i> by typing away with a keyboard.<p>This leads to mismatch in delivery expectations between leadership and developers.</div><br/><div id="40105457" class="c"><input type="checkbox" id="c-40105457" checked=""/><div class="controls bullet"><span class="by">lwhi</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105173">parent</a><span>|</span><a href="#40106691">next</a><span>|</span><label class="collapse" for="c-40105457">[-]</label><label class="expand" for="c-40105457">[1 more]</label></div><br/><div class="children"><div class="content">In my opinion, you shouldn&#x27;t need to prototype all of these options .. but you will need to stress test any points where you have uncertainty.<p>The prototype should provide you with cast iron certainty that the final design can be implemented, to avoid wasting a huge amount of effort.</div><br/></div></div><div id="40106691" class="c"><input type="checkbox" id="c-40106691" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105173">parent</a><span>|</span><a href="#40105457">prev</a><span>|</span><a href="#40105810">next</a><span>|</span><label class="collapse" for="c-40106691">[-]</label><label class="expand" for="c-40106691">[1 more]</label></div><br/><div class="children"><div class="content">If you know so little that you have to make 3 prototypes to understand your problem, do you think designing it by any other process will make it possible make an accurate estimate?</div><br/></div></div></div></div><div id="40105810" class="c"><input type="checkbox" id="c-40105810" checked=""/><div class="controls bullet"><span class="by">nick__m</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40105173">prev</a><span>|</span><a href="#40105967">next</a><span>|</span><label class="collapse" for="c-40105810">[-]</label><label class="expand" for="c-40105810">[1 more]</label></div><br/><div class="children"><div class="content">I completely agree with you. This article is on the right track but it completely ignore the importance of exploratory programming to guide that thinking process.</div><br/></div></div><div id="40105967" class="c"><input type="checkbox" id="c-40105967" checked=""/><div class="controls bullet"><span class="by">makerdiety</span><span>|</span><a href="#40104532">parent</a><span>|</span><a href="#40105810">prev</a><span>|</span><a href="#40104605">next</a><span>|</span><label class="collapse" for="c-40105967">[-]</label><label class="expand" for="c-40105967">[4 more]</label></div><br/><div class="children"><div class="content">Mathematics was invented by the human mind to minimize waste and maximize work productivity. By allowing reality mapping abstractions to take precedence over empirical falsifications of propositions.<p>And what most people can&#x27;t do, such as keeping in their heads absolutely all the concepts of a theoretical computer software application, is an indication that real programmers exist on a higher elevation where information technology is literally second nature to them. To put it bluntly and succinctly.<p>For computer software development to be part of thinking, a more intimate fusion between man and machine needs to happen. Instead of the position that a programmer is a separate and autonomous entity from his fungible software.<p>The best programmers simulate machines in their heads, basically.</div><br/><div id="40106728" class="c"><input type="checkbox" id="c-40106728" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40105967">parent</a><span>|</span><a href="#40107196">next</a><span>|</span><label class="collapse" for="c-40106728">[-]</label><label class="expand" for="c-40106728">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The best programmers simulate machines in their heads, basically.<p>Yes, but they still suck at it.<p>That&#x27;s why people create procedures like prototyping, test driven design, type driven design, paper-prototypes, API mocking, and etc.</div><br/><div id="40107725" class="c"><input type="checkbox" id="c-40107725" checked=""/><div class="controls bullet"><span class="by">makerdiety</span><span>|</span><a href="#40104532">root</a><span>|</span><a href="#40106728">parent</a><span>|</span><a href="#40107196">next</a><span>|</span><label class="collapse" for="c-40107725">[-]</label><label class="expand" for="c-40107725">[1 more]</label></div><br/><div class="children"><div class="content">The point is that there are no programmers that can simulate machines in their heads. These elite engineers only exist in theory. Because if they did exist, they would appear so alien and freakish to you that they would never be able to communicate their form of software development paradigms and patterns. These rare type of programmers only exist in the future, assuming we&#x27;re on a timeline toward such a singularity. And we&#x27;re not, except for some exceptions that cultivate a colony away from what is commonly called the tech industry.<p>EDIT: Unless you&#x27;re saying that SOLID, VIPER, TDD, etc. are already alien invaders from a perfect world and only good and skilled humans can adhere to the rules with uncanny accuracy?</div><br/></div></div></div></div></div></div></div></div><div id="40104605" class="c"><input type="checkbox" id="c-40104605" checked=""/><div class="controls bullet"><span class="by">divan</span><span>|</span><a href="#40104532">prev</a><span>|</span><a href="#40112489">next</a><span>|</span><label class="collapse" for="c-40104605">[-]</label><label class="expand" for="c-40104605">[5 more]</label></div><br/><div class="children"><div class="content">Great article!
I&#x27;ve posted it in other comments before, but it&#x27;s worth repeating:<p>The best explanation I&#x27;ve seen is in the book &quot;The Secret Life of Programs&quot; by Jonathan E. Steinhart. I&#x27;ll quote that paragraph verbatim:<p>---<p>Computer programming is a two-step process:<p>1. Understand the universe.<p>2. Explain it to a three-year-old.<p>What does this mean? Well, you can&#x27;t write computer programs to do things that you yourself don&#x27;t understand. For example, you can&#x27;t write a spellchecker if you don&#x27;t know the rules for spelling, and you can&#x27;t write a good action video game if you don&#x27;t know physics. So, the first step in becoming a good computer programmer is to learn as much as you can about everything else. Solutions to problems often come from unexpected places, so don&#x27;t ignore something just because it doesn&#x27;t seem immediately relevant.<p>The second step of the process requires explaining what you know to a machine that has a very rigid view of the world, like young children do. This rigidity in children is really obvious when they&#x27;re about three years old. Let&#x27;s say you&#x27;re trying to get out the door. You ask your child, &quot;Where are your shoes?&quot; The response: &quot;There.&quot; She did answer your question. The problem is, she doesn&#x27;t understand that you&#x27;re really asking her to put her shoes on so that you both can go somewhere. Flexibility and the ability to make inferences are skills that children learn as they grow up. But computers are like Peter Pan: they never grow up.</div><br/><div id="40104951" class="c"><input type="checkbox" id="c-40104951" checked=""/><div class="controls bullet"><span class="by">shkkmo</span><span>|</span><a href="#40104605">parent</a><span>|</span><a href="#40112489">next</a><span>|</span><label class="collapse" for="c-40104951">[-]</label><label class="expand" for="c-40104951">[4 more]</label></div><br/><div class="children"><div class="content">Edit: Aften writing this long nitpicky comment, I have though of a much shorter and simpler point I want to make: Programming is mostly thinking and there are many ways to do the work of thinking. Different people and problems call for different ways of thinking and learning to think&#x2F;program in different ways will give more tools to choose from. Thus I don&#x27;t like arguments that there is one right way that programming happens or should happen.<p>I&#x27;m sorry, but yout entire comment reads like a list of platitudes about programming that don&#x27;t actually match reality.<p>&gt; Well, you can&#x27;t write computer programs to do things that you yourself don&#x27;t understand.<p>Not true. There are many times where writing software to do a thing is how I come to understand how that thing actually works.<p>Additionally, while an understanding of physics helps with modeling physics, much of that physics modeling is done to implement video games and absolute fidelity to reality is not the goal. There is often an exploration of the model space to find the right balance of fidelity, user experience and challenge.<p>Software writing is absolutely mostly thinking, but that doesn&#x27;t mean all or even most of the thinking should al always come first. Computer programming can be an exploratory cognitive tool.<p>&gt; So, the first step in becoming a good computer programmer is to learn as much as you can about everything else. Solutions to problems often come from unexpected places, so don&#x27;t ignore something just because it doesn&#x27;t seem immediately relevant.<p>I&#x27;m all about generalist and autodidacts, but becomming one isn&#x27;t a necessary first step to being a good programmer.<p>&gt; The second step of the process requires explaining what you know to a machine that has a very rigid view of the world, like young children do.<p>Umm... children have &quot;rigid&quot; world views? Do you know any children?<p>&gt; Let&#x27;s say you&#x27;re trying to get out the door. You ask your child, &quot;Where are your shoes?&quot; The response: &quot;There.&quot; She did answer your question.<p>Oh, you don&#x27;t mean rigid, you mean they can&#x27;t always infer social subtexts.<p>&gt; Flexibility and the ability to make inferences are skills that children learn as they grow up. But computers are like Peter Pan: they never grow up.<p>Computes make inferrences all the time. Deriving logical conclusions from known facts is absolutely something computers can be programmed to do and is arguably one of their main uses cases.<p>I have spent time explaining to things to children of various ages, including 3 year olds, and find the experience absolutely nothing like programming a computer.</div><br/><div id="40106479" class="c"><input type="checkbox" id="c-40106479" checked=""/><div class="controls bullet"><span class="by">divan</span><span>|</span><a href="#40104605">root</a><span>|</span><a href="#40104951">parent</a><span>|</span><a href="#40106674">next</a><span>|</span><label class="collapse" for="c-40106479">[-]</label><label class="expand" for="c-40106479">[1 more]</label></div><br/><div class="children"><div class="content">Are you replying to me or to the author of the quote? :)<p>&gt; Software writing is absolutely mostly thinking, but that doesn&#x27;t mean all or even most of the thinking should al always come first. Computer programming can be an exploratory cognitive tool.<p>Absolutely, explaining something to the child also can be exploratory cognitive tool.</div><br/></div></div><div id="40106674" class="c"><input type="checkbox" id="c-40106674" checked=""/><div class="controls bullet"><span class="by">MichaelZuo</span><span>|</span><a href="#40104605">root</a><span>|</span><a href="#40104951">parent</a><span>|</span><a href="#40106479">prev</a><span>|</span><a href="#40112489">next</a><span>|</span><label class="collapse" for="c-40106674">[-]</label><label class="expand" for="c-40106674">[2 more]</label></div><br/><div class="children"><div class="content">I would say very young children up until they acquire concepts like a theory of mind, cause and effect happening outside of their field of observation, and so on, are pretty rigid in many ways like computers. It&#x27;s a valuable insight.<p>Or at least they don&#x27;t make mistakes in exceptionally novel and unusual ways until they&#x27;re a bit older.</div><br/><div id="40109958" class="c"><input type="checkbox" id="c-40109958" checked=""/><div class="controls bullet"><span class="by">shkkmo</span><span>|</span><a href="#40104605">root</a><span>|</span><a href="#40106674">parent</a><span>|</span><a href="#40112489">next</a><span>|</span><label class="collapse" for="c-40109958">[-]</label><label class="expand" for="c-40109958">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I would say very young children up until they acquire concepts like a theory of mind, cause and effect happening outside of their field of observation, and so on, are pretty rigid in many ways like computers. It&#x27;s a valuable insight.<p>I don&#x27;t see any overlapp between the two skill sets, since you do I&#x27;d be curious for examples of where you do see overlap.</div><br/></div></div></div></div></div></div></div></div><div id="40112489" class="c"><input type="checkbox" id="c-40112489" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#40104605">prev</a><span>|</span><a href="#40103687">next</a><span>|</span><label class="collapse" for="c-40112489">[-]</label><label class="expand" for="c-40112489">[1 more]</label></div><br/><div class="children"><div class="content">I studied CS and taught programming 101.<p>In my experience, the main issue with learning to code are all the contexts you have to remember.<p>There is the static type level and the runtime level, all the scopes (class, object, function, nested functions, closures, etc.), the different machines (client, server, or even multiple servers, etc.)<p>That&#x27;s probably the reason why most devs start with dynamic languages and frontend&#x2F;mobile. It can get just as complex as backend development, but at least you can eliminate a bunch of contexts when starting to code, learn what&#x27;s left and then add contexts later.</div><br/></div></div><div id="40103687" class="c"><input type="checkbox" id="c-40103687" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#40112489">prev</a><span>|</span><a href="#40104173">next</a><span>|</span><label class="collapse" for="c-40103687">[-]</label><label class="expand" for="c-40103687">[12 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    I&#x27;m confident enough to tout this number as effectively true, though I should mention that no company I work with has so far been willing to delete a whole day&#x27;s work to prove or disprove this experiment yet.
</code></pre>
Long ago when I was much more tolerant, I had a boss that would review all code changes every night and delete anything he didn&#x27;t like. This same boss also believed that version control was overcomplicated and decided the company should standardize on remote access to a network drive at his house.<p>The effect of this was that I&#x27;d occasionally come in the next morning to find that my previous day&#x27;s work had been deleted. Before I eventually installed an illicit copy of SVN, I got <i>very</i> good at recreating the previous day&#x27;s work. Rarely took more than an hour, including testing all the edge cases.</div><br/><div id="40103823" class="c"><input type="checkbox" id="c-40103823" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#40103687">parent</a><span>|</span><a href="#40104135">next</a><span>|</span><label class="collapse" for="c-40103823">[-]</label><label class="expand" for="c-40103823">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a big sample size, but 2&#x2F;2 of my first embedded jobs both used network shares and copy+paste to version their code. Because I had kind-of PTSD from the first job, I right off asked the boss on the second job if they had a git repository somewhere. He thought that git is the same as Github and told me they don&#x27;t want their code to be public.<p>When they were bought of by some bigger company, we got access to their intranet. I digged through that and found a gitlab instance. So then I just versioned my own code (which I was working on mostly on my own), documented all of it on there, even installed a gitlab runner and had a step-by-step documentary on how to get my code working. When they kicked me out (because I was kind of an asshole, I assume), they asked me to hand over my code. I showed them all of what I did and told them how to reproduce it. After that the boss was kinda impressed and thanked me for my work. Maybe I had a little positive impact on a shitty job by being an asshole and doing stuff the way that I thought would be the right way to do it.<p>Edit: Oh, before I found that gitlab instance I just initialized raw git repositories on their network share and pushed everything to that</div><br/><div id="40110930" class="c"><input type="checkbox" id="c-40110930" checked=""/><div class="controls bullet"><span class="by">denkmoon</span><span>|</span><a href="#40103687">root</a><span>|</span><a href="#40103823">parent</a><span>|</span><a href="#40104135">next</a><span>|</span><label class="collapse" for="c-40110930">[-]</label><label class="expand" for="c-40110930">[2 more]</label></div><br/><div class="children"><div class="content">You got fired and your response is to give them a gift? Fascinating.</div><br/><div id="40111850" class="c"><input type="checkbox" id="c-40111850" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#40103687">root</a><span>|</span><a href="#40110930">parent</a><span>|</span><a href="#40104135">next</a><span>|</span><label class="collapse" for="c-40111850">[-]</label><label class="expand" for="c-40111850">[1 more]</label></div><br/><div class="children"><div class="content">Well, I was severely depressed and was on sick leave for quite some time, but when I was there I just did my job as best as I can. I am not an inherent asshole. I just get triggered hard when some things don&#x27;t work out (no initial training, barely any documentation, people being arrogant). I just want to be better than this myself.</div><br/></div></div></div></div></div></div><div id="40104135" class="c"><input type="checkbox" id="c-40104135" checked=""/><div class="controls bullet"><span class="by">datascienced</span><span>|</span><a href="#40103687">parent</a><span>|</span><a href="#40103823">prev</a><span>|</span><a href="#40105033">next</a><span>|</span><label class="collapse" for="c-40104135">[-]</label><label class="expand" for="c-40104135">[1 more]</label></div><br/><div class="children"><div class="content">Bad boss or zen teacher, we will never know!</div><br/></div></div><div id="40105033" class="c"><input type="checkbox" id="c-40105033" checked=""/><div class="controls bullet"><span class="by">devsda</span><span>|</span><a href="#40103687">parent</a><span>|</span><a href="#40104135">prev</a><span>|</span><a href="#40103707">next</a><span>|</span><label class="collapse" for="c-40105033">[-]</label><label class="expand" for="c-40105033">[3 more]</label></div><br/><div class="children"><div class="content">The bigger problem here is the manager getting involved with  code.<p>Even when done with good intentions, managers being involved in code&#x2F;reviews almost always ends up being net negative for the team.</div><br/><div id="40105363" class="c"><input type="checkbox" id="c-40105363" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#40103687">root</a><span>|</span><a href="#40105033">parent</a><span>|</span><a href="#40103707">next</a><span>|</span><label class="collapse" for="c-40105363">[-]</label><label class="expand" for="c-40105363">[2 more]</label></div><br/><div class="children"><div class="content">Why?</div><br/><div id="40105637" class="c"><input type="checkbox" id="c-40105637" checked=""/><div class="controls bullet"><span class="by">devsda</span><span>|</span><a href="#40103687">root</a><span>|</span><a href="#40105363">parent</a><span>|</span><a href="#40103707">next</a><span>|</span><label class="collapse" for="c-40105637">[-]</label><label class="expand" for="c-40105637">[1 more]</label></div><br/><div class="children"><div class="content">There are many reasons. First a manager is not a peer but brings in a sense of authority into the mix so the discussions will not be honest. Manager&#x27;s inputs have a sense of finality and people will hesitate to comment or override them even when they are questionable.<p>There are human elements too. Even if someone has honest inputs, any (monetary or otherwise) rewards or lack of them will be attributed to those inputs (or lack of them). 
Overall, it just encourages bad behaviours among the team and invites trouble.<p>These should not happen in an ideal world but as we are dealing with people things will be far from ideal.</div><br/></div></div></div></div></div></div><div id="40103707" class="c"><input type="checkbox" id="c-40103707" checked=""/><div class="controls bullet"><span class="by">smackeyacky</span><span>|</span><a href="#40103687">parent</a><span>|</span><a href="#40105033">prev</a><span>|</span><a href="#40103795">next</a><span>|</span><label class="collapse" for="c-40103707">[-]</label><label class="expand" for="c-40103707">[1 more]</label></div><br/><div class="children"><div class="content">Crikey what a sociopath to work for. I’m sorry this happened to you.</div><br/></div></div><div id="40103795" class="c"><input type="checkbox" id="c-40103795" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#40103687">parent</a><span>|</span><a href="#40103707">prev</a><span>|</span><a href="#40104173">next</a><span>|</span><label class="collapse" for="c-40103795">[-]</label><label class="expand" for="c-40103795">[3 more]</label></div><br/><div class="children"><div class="content">Was your work better or worse second time around?</div><br/><div id="40103851" class="c"><input type="checkbox" id="c-40103851" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#40103687">root</a><span>|</span><a href="#40103795">parent</a><span>|</span><a href="#40104173">next</a><span>|</span><label class="collapse" for="c-40103851">[-]</label><label class="expand" for="c-40103851">[2 more]</label></div><br/><div class="children"><div class="content">Probably a bit of both, but hindsight helped. It doesn&#x27;t usually end up exactly the same though. Regardless, whatever I wrote worked well enough that it outlived the company. A former client running it reached out to have it modified last year.</div><br/><div id="40103981" class="c"><input type="checkbox" id="c-40103981" checked=""/><div class="controls bullet"><span class="by">bernardlunn</span><span>|</span><a href="#40103687">root</a><span>|</span><a href="#40103851">parent</a><span>|</span><a href="#40104173">next</a><span>|</span><label class="collapse" for="c-40103981">[-]</label><label class="expand" for="c-40103981">[1 more]</label></div><br/><div class="children"><div class="content">With writing the second version is definitely better, sucks having to redo but improvement makes it worth while.</div><br/></div></div></div></div></div></div></div></div><div id="40104173" class="c"><input type="checkbox" id="c-40104173" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#40103687">prev</a><span>|</span><a href="#40103932">next</a><span>|</span><label class="collapse" for="c-40104173">[-]</label><label class="expand" for="c-40104173">[4 more]</label></div><br/><div class="children"><div class="content">This is a good article to send to non-programmers.  Just as programmers need domain knowledge, those who are trying to get something out of programmers need to understand a bit about it.<p>I think I recognise that tiny diffs that I might commit can be the ones that take hours to create because of the debugging or design or learning involved.  It&#x27;s all so easy to be unimpressed by the quantity of output and having something explained to you is quite different from bashing your head against a brick wall for hours trying to work it out yourself.</div><br/><div id="40104244" class="c"><input type="checkbox" id="c-40104244" checked=""/><div class="controls bullet"><span class="by">figassis</span><span>|</span><a href="#40104173">parent</a><span>|</span><a href="#40103932">next</a><span>|</span><label class="collapse" for="c-40104244">[-]</label><label class="expand" for="c-40104244">[3 more]</label></div><br/><div class="children"><div class="content">This. The smallest pieces of code I’ve put out were usually by far the most time consuming, most impactful and most satisfying after you “get it”. One line commits that improve performance by 100x but took days to find, alongside having to explain during syncs why a ticket is not moving.</div><br/></div></div></div></div><div id="40103932" class="c"><input type="checkbox" id="c-40103932" checked=""/><div class="controls bullet"><span class="by">lordnacho</span><span>|</span><a href="#40104173">prev</a><span>|</span><a href="#40103636">next</a><span>|</span><label class="collapse" for="c-40103932">[-]</label><label class="expand" for="c-40103932">[8 more]</label></div><br/><div class="children"><div class="content">This is why domain knowledge is key. I work in finance, I&#x27;ve sat on trading desks looking at various exchanges, writing code to implement this or that strategy.<p>You can&#x27;t think about what the computer should do if you don&#x27;t know what the business should do.<p>From this perspective, it might make sense to train coders a bit like how we train translators. For example, I have a friend who is a translator. She speaks a bunch of languages, it&#x27;s very impressive. She knows the grammar, idioms, and so on of a wide number of languages, and can pick up new ones like how you or I can pick up a new coding language.<p>But she also spent a significant amount of time learning about the pharmaceutical industry. Stuff about how that business works, what kinds of things they do, different things that interface with translation. So now she works translating medical documents.<p>Lawyers and accountants are another profession where you have a language gap. What I mean is, when you become a professional, you learn the language of your profession, and you learn how to talk in terms of the law, or accounting, or software. What I&#x27;ve always found is that the good professionals are the ones who can give you answers not in terms of their professional language, but in terms of business.<p>Particularly with lawyers, the ones who are less good will tell you every possible outcome, in legalese, leaving you to make a decision about which button to press. The good lawyers will say &quot;yes, there&#x27;s a bunch of minor things that could happen, but in practice every client in your positions does X, because they all have this business goal&quot;.<p>---<p>As for his thought experiment, I recall a case from my first trading job. We had a trader who&#x27;d created a VBA module in Excel. It did some process for looking through stocks for targets to trade. No version control, just saved file on disk.<p>Our new recruit lands on the desk, and one day within a couple of weeks, he somehow deletes the whole VBA module and saves it. All gone, no backup, and IT can&#x27;t do anything either.<p>Our trader colleague goes red. He calms down, but what can you do? You should have backups, and what are you doing with VBA anyway?<p>He sits down and types out the whole thing, as if he were a terminal screen from the 80s printing each character after the next.<p>Boom, done.</div><br/><div id="40105832" class="c"><input type="checkbox" id="c-40105832" checked=""/><div class="controls bullet"><span class="by">sotix</span><span>|</span><a href="#40103932">parent</a><span>|</span><a href="#40103963">next</a><span>|</span><label class="collapse" for="c-40105832">[-]</label><label class="expand" for="c-40105832">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is why domain knowledge is key.
&gt; Lawyers and accountants are another profession where you have a language gap.<p>I fully agree with you. However, my experience as a software engineer with a CPA is that, generally speaking, companies do not care too greatly about that domain knowledge. They’d rather have a software engineer with 15 years working in accounting-related software than someone with my background or similar and then stick them into a room to chat with an accountant for 30 minutes.</div><br/></div></div><div id="40103963" class="c"><input type="checkbox" id="c-40103963" checked=""/><div class="controls bullet"><span class="by">otar</span><span>|</span><a href="#40103932">parent</a><span>|</span><a href="#40105832">prev</a><span>|</span><a href="#40104206">next</a><span>|</span><label class="collapse" for="c-40103963">[-]</label><label class="expand" for="c-40103963">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is why domain knowledge is key.<p>Very true. There’s a huge difference developing in a well known vs. new domain. My mantra is that you have to first be experienced in a domain to be able to craft a good solution.<p>Right now I am pouring most of my time in a fairly new domain, just to get an experience. I sit next to the domain experts (my decision) to quickly accumulate the needed knowledge.</div><br/></div></div><div id="40104206" class="c"><input type="checkbox" id="c-40104206" checked=""/><div class="controls bullet"><span class="by">anal_reactor</span><span>|</span><a href="#40103932">parent</a><span>|</span><a href="#40103963">prev</a><span>|</span><a href="#40105134">next</a><span>|</span><label class="collapse" for="c-40104206">[-]</label><label class="expand" for="c-40104206">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This is why domain knowledge is key.<p>Yeah but in my country all companies have a non-compete clause which makes it completely useless for me to learn any domain-specific knowledge because I won&#x27;t be able to transfer it to my next job if current employer fires me. Therefore I focus on general programming skills because these are transferable across industries.</div><br/><div id="40104250" class="c"><input type="checkbox" id="c-40104250" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40103932">root</a><span>|</span><a href="#40104206">parent</a><span>|</span><a href="#40108694">next</a><span>|</span><label class="collapse" for="c-40104250">[-]</label><label class="expand" for="c-40104250">[1 more]</label></div><br/><div class="children"><div class="content">The transferable skill is learning and getting on top of the business, then translating that to code. Of course you can&#x27;t transfer the actual business rules; every business is different. You just get better and better at asking the right questions. Or you just stick with a company for a long time. There are many businesses that can&#x27;t be picked up in a few weeks. Maybe a few years.</div><br/></div></div><div id="40108694" class="c"><input type="checkbox" id="c-40108694" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40103932">root</a><span>|</span><a href="#40104206">parent</a><span>|</span><a href="#40104250">prev</a><span>|</span><a href="#40107452">next</a><span>|</span><label class="collapse" for="c-40108694">[-]</label><label class="expand" for="c-40108694">[1 more]</label></div><br/><div class="children"><div class="content">In some countries (Austria), the company that you have a non-compete clause with should pay you a salary if you can’t reasonably be employed due to it. So it is not enforced most of the time.</div><br/></div></div><div id="40107452" class="c"><input type="checkbox" id="c-40107452" checked=""/><div class="controls bullet"><span class="by">_dain_</span><span>|</span><a href="#40103932">root</a><span>|</span><a href="#40104206">parent</a><span>|</span><a href="#40108694">prev</a><span>|</span><a href="#40105134">next</a><span>|</span><label class="collapse" for="c-40107452">[-]</label><label class="expand" for="c-40107452">[1 more]</label></div><br/><div class="children"><div class="content">cripes what country is that</div><br/></div></div></div></div><div id="40105134" class="c"><input type="checkbox" id="c-40105134" checked=""/><div class="controls bullet"><span class="by">shkkmo</span><span>|</span><a href="#40103932">parent</a><span>|</span><a href="#40104206">prev</a><span>|</span><a href="#40103636">next</a><span>|</span><label class="collapse" for="c-40105134">[-]</label><label class="expand" for="c-40105134">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is why domain knowledge is key<p>In the comment thread, I keep seeing prescriptions over and over for the one way that programming should work.<p>Computer programming is an incredibly broad discipline that covers such a broad range of types of work. I think it is incredibly hard to make generalizations that actually apply to the whole breadth of what computer programming encompases.<p>Rather than trying learn or teach one perfect one single methodology that applies accross every sub field of programming, I think that one should aim to build a toolbag of approaches and methodologies along with an understanding where they tend to work well.</div><br/></div></div></div></div><div id="40103636" class="c"><input type="checkbox" id="c-40103636" checked=""/><div class="controls bullet"><span class="by">skilled</span><span>|</span><a href="#40103932">prev</a><span>|</span><a href="#40103960">next</a><span>|</span><label class="collapse" for="c-40103636">[-]</label><label class="expand" for="c-40103636">[11 more]</label></div><br/><div class="children"><div class="content">This is laid out pretty early on by Bjourne in his PPP book[0],<p>&gt; We do not assume that you — our reader — want to become a professional programmer and spend the rest of your working life writing code. Even the best programmers — especially the best programmers — spend most of their time not writing
code. Understanding problems takes serious time and often requires significant
intellectual effort. That intellectual challenge is what many programmers refer to
when they say that programming is interesting.<p>Picked up the new edition[1] as it was on the front page recently[2].<p>[0]: <a href="https:&#x2F;&#x2F;www.stroustrup.com&#x2F;PPP2e_Ch01.pdf" rel="nofollow">https:&#x2F;&#x2F;www.stroustrup.com&#x2F;PPP2e_Ch01.pdf</a><p>[1]: <a href="https:&#x2F;&#x2F;www.stroustrup.com&#x2F;programming.html" rel="nofollow">https:&#x2F;&#x2F;www.stroustrup.com&#x2F;programming.html</a><p>[2]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40086779">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40086779</a></div><br/><div id="40103864" class="c"><input type="checkbox" id="c-40103864" checked=""/><div class="controls bullet"><span class="by">silisili</span><span>|</span><a href="#40103636">parent</a><span>|</span><a href="#40103688">next</a><span>|</span><label class="collapse" for="c-40103864">[-]</label><label class="expand" for="c-40103864">[4 more]</label></div><br/><div class="children"><div class="content">I think this is mostly right, but my biggest problem is that it feels like we spend time arguing the same things over and over.  Which DB to use, which language is best, nulls or not in code and in DB, API formatting, log formatting, etc.<p>These aren&#x27;t particularly interesting, and sure it&#x27;s good to revisit them time and again, but these are the types of time sinks I find myself in in the last 3 companies I&#x27;ve worked for that feel like they should be mostly solved.<p>In fact, a company with a strong mindset, even if questionable, is probably way more productive.  If it was set in stone we use Perl, MongoDB, CGI... I&#x27;d probably ultimately be more productive than I&#x27;ve been lately despite the stack.</div><br/><div id="40104151" class="c"><input type="checkbox" id="c-40104151" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#40103636">root</a><span>|</span><a href="#40103864">parent</a><span>|</span><a href="#40103979">next</a><span>|</span><label class="collapse" for="c-40104151">[-]</label><label class="expand" for="c-40104151">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; “If it was set in stone we use Perl, MongoDB, CGI... I&#x27;d probably ultimately be more productive than I&#x27;ve been lately despite the stack.”</i><p>Facebook decided to stick with PHP and MySQL from their early days rather than rewrite, and they’re still today on a stack derived from the original one.<p>It was the right decision IMO. They prioritized product velocity and trusted that issues with the stack could be resolved with money when the time comes.<p>And that’s what they’ve done by any metric. While nominally a PHP family language, Meta’s Hack and its associated homegrown ecosystem provides one of the best developer experiences on the planet, and has scaled up to three billion active users.</div><br/></div></div><div id="40103979" class="c"><input type="checkbox" id="c-40103979" checked=""/><div class="controls bullet"><span class="by">fifilura</span><span>|</span><a href="#40103636">root</a><span>|</span><a href="#40103864">parent</a><span>|</span><a href="#40104151">prev</a><span>|</span><a href="#40104003">next</a><span>|</span><label class="collapse" for="c-40103979">[-]</label><label class="expand" for="c-40103979">[1 more]</label></div><br/><div class="children"><div class="content">I disagree! These decisions are fundamental in the engineering process.<p>Should I use steel, concrete or wood to build this bridge?<p>The mindless coding part starts one year later when you found that your mongoDB does not do joins, and you start implementing this as an extra layer in the client side.</div><br/></div></div><div id="40104003" class="c"><input type="checkbox" id="c-40104003" checked=""/><div class="controls bullet"><span class="by">zrm</span><span>|</span><a href="#40103636">root</a><span>|</span><a href="#40103864">parent</a><span>|</span><a href="#40103979">prev</a><span>|</span><a href="#40103688">next</a><span>|</span><label class="collapse" for="c-40104003">[-]</label><label class="expand" for="c-40104003">[1 more]</label></div><br/><div class="children"><div class="content">What you&#x27;re referring to is politics. Different people have different preferences, often because they&#x27;re more familiar with one of them, or for other possibly good reasons. Somehow you have to decide who wins.</div><br/></div></div></div></div><div id="40103688" class="c"><input type="checkbox" id="c-40103688" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#40103636">parent</a><span>|</span><a href="#40103864">prev</a><span>|</span><a href="#40105113">next</a><span>|</span><label class="collapse" for="c-40103688">[-]</label><label class="expand" for="c-40103688">[5 more]</label></div><br/><div class="children"><div class="content">The hardest part is finding out what _not_ to code, either before (design) or after (learn from prototype or the previous iteration) having written some.</div><br/><div id="40103820" class="c"><input type="checkbox" id="c-40103820" checked=""/><div class="controls bullet"><span class="by">thunderbong</span><span>|</span><a href="#40103636">root</a><span>|</span><a href="#40103688">parent</a><span>|</span><a href="#40105113">next</a><span>|</span><label class="collapse" for="c-40103820">[-]</label><label class="expand" for="c-40103820">[4 more]</label></div><br/><div class="children"><div class="content">No code is faster than no code!</div><br/><div id="40107493" class="c"><input type="checkbox" id="c-40107493" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40103636">root</a><span>|</span><a href="#40103820">parent</a><span>|</span><a href="#40105477">next</a><span>|</span><label class="collapse" for="c-40107493">[-]</label><label class="expand" for="c-40107493">[2 more]</label></div><br/><div class="children"><div class="content">Sometimes you have to write it to understand why you shouldn’t have written it.</div><br/><div id="40109095" class="c"><input type="checkbox" id="c-40109095" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#40103636">root</a><span>|</span><a href="#40107493">parent</a><span>|</span><a href="#40105477">next</a><span>|</span><label class="collapse" for="c-40109095">[-]</label><label class="expand" for="c-40109095">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you knew you shouldn&#x27;t have written it and then did so anyway.</div><br/></div></div></div></div></div></div></div></div><div id="40105113" class="c"><input type="checkbox" id="c-40105113" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#40103636">parent</a><span>|</span><a href="#40103688">prev</a><span>|</span><a href="#40103960">next</a><span>|</span><label class="collapse" for="c-40105113">[-]</label><label class="expand" for="c-40105113">[1 more]</label></div><br/><div class="children"><div class="content">*Bjarne</div><br/></div></div></div></div><div id="40103960" class="c"><input type="checkbox" id="c-40103960" checked=""/><div class="controls bullet"><span class="by">hubraumhugo</span><span>|</span><a href="#40103636">prev</a><span>|</span><a href="#40105190">next</a><span>|</span><label class="collapse" for="c-40103960">[-]</label><label class="expand" for="c-40103960">[7 more]</label></div><br/><div class="children"><div class="content">&gt; how can you experiment with learning on-the-job to create systems where the thinking is optimized?<p>Best optimization is less interruptions as reasearch shows their devastating effect on programming:<p>- 10-15 min to resume work after an interruption<p>- A programmer is likely to get just one uninterrupted 2-hour session in a day<p>- Worst time to interrupt: during edits, searches &amp; comprehension<p>I&#x27;ve been wondering if there&#x27;s a way to track interruptions to showcase this.<p>[0] <a href="http:&#x2F;&#x2F;blog.ninlabs.com&#x2F;2013&#x2F;01&#x2F;programmer-interrupted&#x2F;" rel="nofollow">http:&#x2F;&#x2F;blog.ninlabs.com&#x2F;2013&#x2F;01&#x2F;programmer-interrupted&#x2F;</a></div><br/><div id="40105299" class="c"><input type="checkbox" id="c-40105299" checked=""/><div class="controls bullet"><span class="by">devsda</span><span>|</span><a href="#40103960">parent</a><span>|</span><a href="#40104115">next</a><span>|</span><label class="collapse" for="c-40105299">[-]</label><label class="expand" for="c-40105299">[3 more]</label></div><br/><div class="children"><div class="content">If you ask a manager to hold an hour&#x27;s meeting spread across 6 hours in 10 min slots you will get the funniest looks.<p>Yet developers are expected to complete a few hours of coding task in between an endless barrage of meetings, quick and short pings &amp; syncups over slack&#x2F;zoom.<p>For the few times I&#x27;ve had to work on the weekends at home, I&#x27;ve observed that the difference in the quality of work done over a (distraction free) weekend is much better than that of a hectic weekday.</div><br/><div id="40108682" class="c"><input type="checkbox" id="c-40108682" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#40103960">root</a><span>|</span><a href="#40105299">parent</a><span>|</span><a href="#40112405">next</a><span>|</span><label class="collapse" for="c-40108682">[-]</label><label class="expand" for="c-40108682">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you ask a manager to hold an hour&#x27;s meeting spread across 6 hours in 10 min slots you will get the funniest looks.<p>This is a great analogy I haven’t heard it before. They think it’s like that quick work where you check your calendar and throw in your two cents on an email chain. It’s not. Much more like holding a meeting.</div><br/></div></div><div id="40112405" class="c"><input type="checkbox" id="c-40112405" checked=""/><div class="controls bullet"><span class="by">brailsafe</span><span>|</span><a href="#40103960">root</a><span>|</span><a href="#40105299">parent</a><span>|</span><a href="#40108682">prev</a><span>|</span><a href="#40104115">next</a><span>|</span><label class="collapse" for="c-40112405">[-]</label><label class="expand" for="c-40112405">[1 more]</label></div><br/><div class="children"><div class="content">The horrible trap of this is being able to get so little work done during the day, that you end up risking <i>any</i> but possibly <i>all</i> of your otherwise free time compensating for some company&#x27;s idiotic structure, and this is a catastrophe</div><br/></div></div></div></div><div id="40104115" class="c"><input type="checkbox" id="c-40104115" checked=""/><div class="controls bullet"><span class="by">phreack</span><span>|</span><a href="#40103960">parent</a><span>|</span><a href="#40105299">prev</a><span>|</span><a href="#40103984">next</a><span>|</span><label class="collapse" for="c-40104115">[-]</label><label class="expand" for="c-40104115">[1 more]</label></div><br/><div class="children"><div class="content">This is why I work at night 80% of the time. It&#x27;s absolutely not for everyone, it&#x27;s not for every case, and the other 20% is coordination with daytime people, but the amount of productivity that comes from good uninterrupted hours long sessions is simply unmatched. Once again, not for everyone, probably not for most.</div><br/></div></div><div id="40103984" class="c"><input type="checkbox" id="c-40103984" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#40103960">parent</a><span>|</span><a href="#40104115">prev</a><span>|</span><a href="#40104898">next</a><span>|</span><label class="collapse" for="c-40103984">[-]</label><label class="expand" for="c-40103984">[1 more]</label></div><br/><div class="children"><div class="content">This and a high demand for my time is why I am roughly a magnitude more productive when I am in home office. Nobody bothers me there and if they do I can decide myself when to react.<p>If you want to tackle particularly hard problems and you get an interruption every 10 to 20 minutes you can just shelve the whole thing, because chances are you will just produce bullshit code that produces headache down the line.</div><br/></div></div><div id="40104898" class="c"><input type="checkbox" id="c-40104898" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#40103960">parent</a><span>|</span><a href="#40103984">prev</a><span>|</span><a href="#40105190">next</a><span>|</span><label class="collapse" for="c-40104898">[-]</label><label class="expand" for="c-40104898">[1 more]</label></div><br/><div class="children"><div class="content">I once led a project to develop a tool that tracks how people use their time in a large corporation. We designed it to be privacy-respecting, so it would log that you are using the Web browser, but not the specific URL, which is of course relevant (e.g. Intranet versus fb.com). Every now and then, a pop up would ask the user to self-rate how productive they feel, with a free-text field to comment. Again, not assigned to user IDs in order to respect privacy, or people would start lying to pretend to be super-human.<p>We wrote a Windows front end and a Scala back end for data gathering and roled it out to a group of volunteers (including devs, lawyers and finace people even). Sadly the project ran out of time and budget just as things were getting interesting (after a first round of data analysis), so we never published a paper about it.<p>We also looked at existing tools such as Rescue Time ( <a href="https:&#x2F;&#x2F;www.rescuetime.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.rescuetime.com&#x2F;</a>
 ) but decided an external cloud was not acceptable to store our internal productivity data.</div><br/></div></div></div></div><div id="40105190" class="c"><input type="checkbox" id="c-40105190" checked=""/><div class="controls bullet"><span class="by">xondono</span><span>|</span><a href="#40103960">prev</a><span>|</span><a href="#40103774">next</a><span>|</span><label class="collapse" for="c-40105190">[-]</label><label class="expand" for="c-40105190">[1 more]</label></div><br/><div class="children"><div class="content">“Programming is mostly thinking” is one of these things we tell ourselves like it is some deep truth but it’s the most unproductive of observations.<p>Programming is thinking in the <i>same exact way</i> all knowledge work is thinking:<p>- Design in all it’s forms is mostly thinking<p>- Accounting is mostly thinking<p>- Management in general is mostly thinking<p>The meaningful difference is not the thinking, it’s <i>what are you thinking about</i>.<p>Your manager needs to “debug” people-problems, so they need lots of time with people (i.e. meetings).<p>You are debugging computer problems, so you need lots of time with your computer.<p>There’s an obvious tension there and none of the extremes work, you (and your manager) need to find a way to balance both of your workloads to minimize stepping on each others toes, just like with any other coworker.</div><br/></div></div><div id="40103774" class="c"><input type="checkbox" id="c-40103774" checked=""/><div class="controls bullet"><span class="by">ken47</span><span>|</span><a href="#40105190">prev</a><span>|</span><a href="#40104370">next</a><span>|</span><label class="collapse" for="c-40103774">[-]</label><label class="expand" for="c-40103774">[3 more]</label></div><br/><div class="children"><div class="content"><i>Good</i> programming is <i>sometimes</i> mostly thinking, because &quot;no plan survives first contact with the enemy.&quot; Pragmatic programming is a judicious combination of planning and putting code to IDE, with the balance adapting to the use case.</div><br/><div id="40104395" class="c"><input type="checkbox" id="c-40104395" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#40103774">parent</a><span>|</span><a href="#40104150">next</a><span>|</span><label class="collapse" for="c-40104395">[-]</label><label class="expand" for="c-40104395">[1 more]</label></div><br/><div class="children"><div class="content">This. Programming is mostly reconnaissance, not just thinking. If you don’t write code for days, you’re either fully aware of the problem surface or are just guessing it. There’s not much to think about in the latter case.</div><br/></div></div><div id="40104150" class="c"><input type="checkbox" id="c-40104150" checked=""/><div class="controls bullet"><span class="by">datascienced</span><span>|</span><a href="#40103774">parent</a><span>|</span><a href="#40104395">prev</a><span>|</span><a href="#40104370">next</a><span>|</span><label class="collapse" for="c-40104150">[-]</label><label class="expand" for="c-40104150">[1 more]</label></div><br/><div class="children"><div class="content">The first run with the IDE is like completing a level of a game the first time. The second time it will be quicker.<p>I agree we can expand thinking to “thinking with help from tools”.</div><br/></div></div></div></div><div id="40104370" class="c"><input type="checkbox" id="c-40104370" checked=""/><div class="controls bullet"><span class="by">chadmulligan</span><span>|</span><a href="#40103774">prev</a><span>|</span><a href="#40103881">next</a><span>|</span><label class="collapse" for="c-40104370">[-]</label><label class="expand" for="c-40104370">[1 more]</label></div><br/><div class="children"><div class="content">That’s an iteration of Peter Naur’s « Programming as Theory Building » that has been pivotal in my understanding of what programming really is about.<p>Programming is not about producing programs per se, it is about forming certain insights about affairs of the world, and eventually outputing code that is nothing more than a mere representation of the theory you have built.</div><br/></div></div><div id="40103881" class="c"><input type="checkbox" id="c-40103881" checked=""/><div class="controls bullet"><span class="by">hgyjnbdet</span><span>|</span><a href="#40104370">prev</a><span>|</span><a href="#40104217">next</a><span>|</span><label class="collapse" for="c-40103881">[-]</label><label class="expand" for="c-40103881">[2 more]</label></div><br/><div class="children"><div class="content">Off topic. I&#x27;m not a developer but I do write code at work, on which some important internal processes depend. I get the impression that most people don&#x27;t see what I do as work, engaged as they are in &quot;busy&quot; work. So I&#x27;m glad when I read things like this that my struggles are those of a real developer.</div><br/><div id="40110598" class="c"><input type="checkbox" id="c-40110598" checked=""/><div class="controls bullet"><span class="by">jmpavlec</span><span>|</span><a href="#40103881">parent</a><span>|</span><a href="#40104217">next</a><span>|</span><label class="collapse" for="c-40110598">[-]</label><label class="expand" for="c-40110598">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like you are a &quot;real developer&quot;. Don&#x27;t sell yourself short.</div><br/></div></div></div></div><div id="40104217" class="c"><input type="checkbox" id="c-40104217" checked=""/><div class="controls bullet"><span class="by">openrisk</span><span>|</span><a href="#40103881">prev</a><span>|</span><a href="#40103616">next</a><span>|</span><label class="collapse" for="c-40104217">[-]</label><label class="expand" for="c-40104217">[1 more]</label></div><br/><div class="children"><div class="content">Various programming paradigms (modular programming, object-oriented, functional, test-driven etc) have developed to reduce precisely this cognitive load. The idea being that it is easier to reason and solve problems that are broken down into smaller pieces.<p>But its an incomplete revolution. If you look at the UML diagram of a fully developed application its a mess of interlocked pieces.<p>Things get particularly hard to reason about when you add concurrency.<p>One could hypothesize that programming languages that &quot;help thinking&quot; are more productive &#x2F; popular but not sure how one would test it.</div><br/></div></div><div id="40103616" class="c"><input type="checkbox" id="c-40103616" checked=""/><div class="controls bullet"><span class="by">Almondsetat</span><span>|</span><a href="#40104217">prev</a><span>|</span><a href="#40110741">next</a><span>|</span><label class="collapse" for="c-40103616">[-]</label><label class="expand" for="c-40103616">[42 more]</label></div><br/><div class="children"><div class="content">Developers need to learn how to think algorithmically. I still spend most of my time writing pseudocode and making diagrams (before with pen and paper, now with my iPad). It&#x27;s the programmers&#x27; version of the Abraham Lincoln&#x27;s quote &quot;Give me six hours to chop down a tree and I will spend the first four sharpening the axe.&quot;</div><br/><div id="40104466" class="c"><input type="checkbox" id="c-40104466" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#40103616">parent</a><span>|</span><a href="#40103726">next</a><span>|</span><label class="collapse" for="c-40104466">[-]</label><label class="expand" for="c-40104466">[1 more]</label></div><br/><div class="children"><div class="content">I still use pen and paper. Actually as I progress with my career and knowledge I use pen and paper more and digital counterparts less.<p>It might be me not taking my time to learn Mathematica&#x2F;Julia tho...</div><br/></div></div><div id="40103726" class="c"><input type="checkbox" id="c-40103726" checked=""/><div class="controls bullet"><span class="by">throwaway9021</span><span>|</span><a href="#40103616">parent</a><span>|</span><a href="#40104466">prev</a><span>|</span><a href="#40103725">next</a><span>|</span><label class="collapse" for="c-40103726">[-]</label><label class="expand" for="c-40103726">[4 more]</label></div><br/><div class="children"><div class="content">Do you have any resources for this? especially for the adhd kind - I end up going down rabbit holes in the planning part. How do you deal with information overload and overwhelm OR the exploration exploitation dilemma?</div><br/><div id="40104347" class="c"><input type="checkbox" id="c-40104347" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103726">parent</a><span>|</span><a href="#40103998">next</a><span>|</span><label class="collapse" for="c-40104347">[-]</label><label class="expand" for="c-40104347">[2 more]</label></div><br/><div class="children"><div class="content">There are 2 bad habits in programming: people that start writing code the 1st second, and people that keep thinking and investigating for months without writing any code. My solution to that: just force to do the opposite. In your case: start writing code immediately. Ni matter how bad or good. Look the youtube channel “tsoding daily” he just goes ahead. The code is not always the best, but he gets things done. He does research offline (you can tell) but if you find yourself doing just research, reading and thinking, force yourself to actually start writing code.</div><br/><div id="40104841" class="c"><input type="checkbox" id="c-40104841" checked=""/><div class="controls bullet"><span class="by">lkuty</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104347">parent</a><span>|</span><a href="#40103998">next</a><span>|</span><label class="collapse" for="c-40104841">[-]</label><label class="expand" for="c-40104841">[1 more]</label></div><br/><div class="children"><div class="content">Or his Twitch videos. That he starts writing immediately and that we&#x27;re able to watch the process is great. Moreover the tone is friendly and funny.</div><br/></div></div></div></div><div id="40103998" class="c"><input type="checkbox" id="c-40103998" checked=""/><div class="controls bullet"><span class="by">fifilura</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103726">parent</a><span>|</span><a href="#40104347">prev</a><span>|</span><a href="#40103725">next</a><span>|</span><label class="collapse" for="c-40103998">[-]</label><label class="expand" for="c-40103998">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if good REPL habits could help the ADHD brain?<p>It still feels like you are coding so your brain is attached, but with rapid prototyping you are also designing, moving parts around to see where they would fit best.</div><br/></div></div></div></div><div id="40103725" class="c"><input type="checkbox" id="c-40103725" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#40103616">parent</a><span>|</span><a href="#40103726">prev</a><span>|</span><a href="#40103750">next</a><span>|</span><label class="collapse" for="c-40103725">[-]</label><label class="expand" for="c-40103725">[11 more]</label></div><br/><div class="children"><div class="content">I don’t really know what “think algorithmically means,” but what I’d like to see as a lead engineer is for my seniors to think in terms of maintenance above all else. Nothing clever, nothing coupled, nothing DRY. It should be as dumb and durable as an AK47.</div><br/><div id="40104340" class="c"><input type="checkbox" id="c-40104340" checked=""/><div class="controls bullet"><span class="by">jffhn</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103725">parent</a><span>|</span><a href="#40103896">next</a><span>|</span><label class="collapse" for="c-40104340">[-]</label><label class="expand" for="c-40104340">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I don’t really know what “think algorithmically means,”<p>I would say thinking about algorithms and data structures for algorithmic complexity not to explode.<p>&gt;Nothing clever<p>A lot of devs use nested loops and List.remove()&#x2F;indexOf() instead of maps, etc., the terrible performance gets accepted as the state of the art, and then you have to do complex workarounds not to call some treatments too often, etc., increasing the complexity.<p>Performance yields simplicity: a small increase in cleverness in some code can allow for a large reduction in complexity in all the code that uses it.<p>Whenever I do a library, I make it as fast as I can, for user code to be able to use it as carelessly as possible, and to avoid another library popping up when someone wants better performances.</div><br/></div></div><div id="40103896" class="c"><input type="checkbox" id="c-40103896" checked=""/><div class="controls bullet"><span class="by">weatherlite</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103725">parent</a><span>|</span><a href="#40104340">prev</a><span>|</span><a href="#40104373">next</a><span>|</span><label class="collapse" for="c-40103896">[-]</label><label class="expand" for="c-40103896">[3 more]</label></div><br/><div class="children"><div class="content">We need this to be more prevalent. But the sad fact is most architects try to justify their position and high salaries by creating &quot;robust&quot; software. You know what I mean - factories over factories, micro services and what not. 
If we kept it simple I don&#x27;t think we would need many architects. We would just need experienced devs that know the codebase well and help with PRs and design processes, no need to call such a person &#x27;architect&#x27;, there&#x27;s not much to architect in such a role.</div><br/><div id="40103958" class="c"><input type="checkbox" id="c-40103958" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103896">parent</a><span>|</span><a href="#40104373">next</a><span>|</span><label class="collapse" for="c-40103958">[-]</label><label class="expand" for="c-40103958">[2 more]</label></div><br/><div class="children"><div class="content">I was shown what it means to write robust software by a guy with a PhD in... philosophy out of all things(so a literal <i>philosophiae doctor</i>).<p>Ironically enough it was nothing like what some architecture astronauts wring - just a set of simple to follow rules, like organizing files by domain, using immutable data structures and pure functions where reasonable etc.<p>Also I hadn&#x27;t seen him use dependent types in the one project we worked together on and generics appeared only when it really made sense.<p>Apparently it boils down to using the right tools, not everything you&#x27;ve got at once.</div><br/><div id="40104727" class="c"><input type="checkbox" id="c-40104727" checked=""/><div class="controls bullet"><span class="by">namaria</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103958">parent</a><span>|</span><a href="#40104373">next</a><span>|</span><label class="collapse" for="c-40104727">[-]</label><label class="expand" for="c-40104727">[1 more]</label></div><br/><div class="children"><div class="content">I love how so much of distributed systems&#x2F;robust software wisdom is basically: stop OOP. Go back to lambda.<p>OOP was a great concept initially. Somehow it got equated with the corporate driven insanity of attaching functions to data structures in arbitrary ways, and all the folly that follows. Because &quot;objects&quot; are easy to imagine and pure functions aren&#x27;t? I don&#x27;t know but I&#x27;d like to understand why corporations keep peddling programming paradigms that fundamentally detract from what computer science knows about managing complex distributed systems.</div><br/></div></div></div></div></div></div><div id="40104373" class="c"><input type="checkbox" id="c-40104373" checked=""/><div class="controls bullet"><span class="by">tasuki</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103725">parent</a><span>|</span><a href="#40103896">prev</a><span>|</span><a href="#40103922">next</a><span>|</span><label class="collapse" for="c-40104373">[-]</label><label class="expand" for="c-40104373">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Nothing clever, nothing coupled<p>Yes, simple is good. Simple is not always easy though. A good goal to strive for nevertheless.<p>&gt; nothing DRY<p>That&#x27;s interesting. Would you prefer all the code to be repeated in multiple places?</div><br/><div id="40104689" class="c"><input type="checkbox" id="c-40104689" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104373">parent</a><span>|</span><a href="#40107001">next</a><span>|</span><label class="collapse" for="c-40104689">[-]</label><label class="expand" for="c-40104689">[1 more]</label></div><br/><div class="children"><div class="content">Bit OP but probably means “no fancy silver bullet acronyms”.</div><br/></div></div><div id="40107001" class="c"><input type="checkbox" id="c-40107001" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104373">parent</a><span>|</span><a href="#40104689">prev</a><span>|</span><a href="#40103922">next</a><span>|</span><label class="collapse" for="c-40107001">[-]</label><label class="expand" for="c-40107001">[2 more]</label></div><br/><div class="children"><div class="content">Depends. I haven’t come up with the rubric yet but it’s something like “don&#x27;t abstract out functionality across data types”. I see this all the time: “I did this one thing here with data type A, and I’m doing something similar with data type B; let’s just create some abstraction for both of them!” Invariably it ends up collapsing, and if the whole program is constructed this way, it becomes monstrous to untangle, like exponentially complicated on the order of abstractions. I think it’s just a breathtaking misunderstanding of what DRY means. It’s not literally “don’t repeat yourself”. It’s “encapsulate behaviors that you need to synchronize.”<p>Also, limit your abstractions’ external knowledge to zero.</div><br/><div id="40109467" class="c"><input type="checkbox" id="c-40109467" checked=""/><div class="controls bullet"><span class="by">tasuki</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40107001">parent</a><span>|</span><a href="#40103922">next</a><span>|</span><label class="collapse" for="c-40109467">[-]</label><label class="expand" for="c-40109467">[1 more]</label></div><br/><div class="children"><div class="content">Very good explanation!<p>&gt; “I did this one thing here with data type A, and I’m doing something similar with data type B; let’s just create some abstraction for both of them!”<p>I&#x27;m guilty of this. I even fought hard against the people who wanted to keep the code duplicated for the different data types.<p>&gt; “encapsulate behaviors that you need to synchronize.”<p>I like that!</div><br/></div></div></div></div></div></div><div id="40103922" class="c"><input type="checkbox" id="c-40103922" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103725">parent</a><span>|</span><a href="#40104373">prev</a><span>|</span><a href="#40103750">next</a><span>|</span><label class="collapse" for="c-40103922">[-]</label><label class="expand" for="c-40103922">[2 more]</label></div><br/><div class="children"><div class="content">In my mind this is breaking down the problem into a relevant data structure and algorithms that operate on that data structure.<p>If for instance you used a tree but were constantly looking up an index in the tree you likely needed a flat array instead. The most basic example of this is sorting, obviously but the same basic concepts apply to many many problems.<p>I think the issue that happens in modern times, specially in webdev, is we aren&#x27;t actually solving problems. We are just glueing services together and marshalling data around which fundamentally doesn&#x27;t need to be algorithmic... Most &quot;coders&quot; are glorified secretaries who now just automate what would have been done by a secretary before.<p>Call service A (database&#x2F; S3 etc), remove irrelevant data, send to service B, give feedback.<p>It&#x27;s just significantly harder to do this in a computer than for a human to do it. For instance if I give you a list of names but some of them have letters swapped around you could likely easily see that and correct it. To do that &quot;algorithmically&quot; is likely impossible and hence ML and NLP became a thing. And data validation on user input.<p>So algorithmically in the modern sense is more, follow these steps exactly to produce this outcome and generating user flows where that is the only option.<p>Human do logic much much better than computers but I think the conclusion has become that the worst computer program is probably better at it that the average human. Just look at many niche products catered to X wealth group. I could have a cheap bank account and do exactly what is required by that bank account or I can pay a lot of money and have a private banker that I can call and they will interpret what I say into the actions that actually need to happen... I feel I am struggling to actually write what&#x27;s in my mind but hopefully that gives you an idea...<p>To answer your nothing clever , well clever is relative. If I have some code which is effectively a array and an algorithm to remove index &#x27;X&#x27; from it, would it be &quot;clever&quot; code to you if that array was labeled &quot;Carousel&quot; and I used the exact same generic algorithms to insert or remove elements from the carousel?<p>For most developers these days they expect to have a class of some sort with a .append and .remove function but why isn&#x27;t it just an array of structs which use the exact same functions as every single other array... That people generally will complain that that code is &quot;clever&quot; but in reality it is really dumb. I can see it&#x27;s clearly an array being operated on but OOP has caused brain rot and developers actually don&#x27;t know what that means... Wait maybe that was OPs point... People no longer think algorithmically.<p>---<p>Machine learning, Natural Language Processing</div><br/><div id="40110123" class="c"><input type="checkbox" id="c-40110123" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103922">parent</a><span>|</span><a href="#40103750">next</a><span>|</span><label class="collapse" for="c-40110123">[-]</label><label class="expand" for="c-40110123">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think the issue that happens in modern times, specially in webdev, is we aren&#x27;t actually solving problems. We are just glueing services together and marshalling data around which fundamentally doesn&#x27;t need to be algorithmic...<p>This is true and is the cause of much frustration everywhere. Employers want “good” devs, so they do complicated interviews testing advanced coding ability. And then the actual workload is equal parts gluing CRUD components together, cosmetic changes to keep stakeholders happy, and standing round the water cooler raging at all the organisational things you can’t change.</div><br/></div></div></div></div></div></div><div id="40103715" class="c"><input type="checkbox" id="c-40103715" checked=""/><div class="controls bullet"><span class="by">dorkwood</span><span>|</span><a href="#40103616">parent</a><span>|</span><a href="#40103750">prev</a><span>|</span><a href="#40103934">next</a><span>|</span><label class="collapse" for="c-40103715">[-]</label><label class="expand" for="c-40103715">[4 more]</label></div><br/><div class="children"><div class="content">Does it really take four hours to sharpen an axe? I&#x27;ve never done it.</div><br/><div id="40103732" class="c"><input type="checkbox" id="c-40103732" checked=""/><div class="controls bullet"><span class="by">misswaterfairy</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103715">parent</a><span>|</span><a href="#40105557">next</a><span>|</span><label class="collapse" for="c-40103732">[-]</label><label class="expand" for="c-40103732">[1 more]</label></div><br/><div class="children"><div class="content">Doing it right, with only manual tools, I believe so, remembering back to one of the elder firefighters that taught me (who was also an old-school forester).<p>Takes about 20 minutes to sharpen a chainsaw chain these days though...</div><br/></div></div><div id="40105557" class="c"><input type="checkbox" id="c-40105557" checked=""/><div class="controls bullet"><span class="by">xandrius</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103715">parent</a><span>|</span><a href="#40103732">prev</a><span>|</span><a href="#40103934">next</a><span>|</span><label class="collapse" for="c-40105557">[-]</label><label class="expand" for="c-40105557">[2 more]</label></div><br/><div class="children"><div class="content">10&#x2F;20 minutes to sharpen a pretty dull kitchen knife with some decent whetstones.<p>Also, as someone famous once said: if I had 4 hours to sharpen an axe, I&#x27;d spend 2 hours preparing the whetstones.</div><br/><div id="40110130" class="c"><input type="checkbox" id="c-40110130" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40105557">parent</a><span>|</span><a href="#40103934">next</a><span>|</span><label class="collapse" for="c-40110130">[-]</label><label class="expand" for="c-40110130">[1 more]</label></div><br/><div class="children"><div class="content">If I had 2 hours to prepare whetstones I’d do 1 hour of billable work and then order some whetstones online.</div><br/></div></div></div></div></div></div><div id="40103934" class="c"><input type="checkbox" id="c-40103934" checked=""/><div class="controls bullet"><span class="by">Barrin92</span><span>|</span><a href="#40103616">parent</a><span>|</span><a href="#40103715">prev</a><span>|</span><a href="#40103664">next</a><span>|</span><label class="collapse" for="c-40103934">[-]</label><label class="expand" for="c-40103934">[5 more]</label></div><br/><div class="children"><div class="content">it&#x27;s an odd analogy because programs are complex systems and involve interaction between countless of people. With large software projects you don&#x27;t even know where you want to go or what&#x27;s going to happen until you work. A large project doesn&#x27;t fit into some pre-planned algorithm in anyone&#x27;s head, it&#x27;s a living thing.<p>diagrams and this kind of planning is mostly a waste of time to be honest. You just need to start to work, and rework if necessary. This article is basically the peak of the bell curve meme. It&#x27;s not 90% thinking, it&#x27;s 10% thinking and 90% &quot;just type&quot;.<p>Novelists for example know this very well. Beginners are always obsessed with intellectually planning out their book. The experienced writer will always tell you, stop yapping and start typing.</div><br/><div id="40104027" class="c"><input type="checkbox" id="c-40104027" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103934">parent</a><span>|</span><a href="#40105242">next</a><span>|</span><label class="collapse" for="c-40104027">[-]</label><label class="expand" for="c-40104027">[2 more]</label></div><br/><div class="children"><div class="content">Your part of your comment doesn&#x27;t fit with the rest. With complex projects, you often don&#x27;t even know exactly what you&#x27;re building, it doesn&#x27;t make sense to start coding. You first need to build a conceptual model, discuss it with the interested parties and only then start building. Diagrams are very useful to solidify your design and communicate it to others.</div><br/><div id="40104630" class="c"><input type="checkbox" id="c-40104630" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104027">parent</a><span>|</span><a href="#40105242">next</a><span>|</span><label class="collapse" for="c-40104630">[-]</label><label class="expand" for="c-40104630">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a weird tension between planning and itterating.
You can never forsee anywhere close to enough with just planning. But if you just start without a plan you can easily work yourself into a dead end.
So you need enough planning to avoid the dead ends, whilst starting early enough so you get your reality checks so you have enough information to get to an actual solution.<p>Relevant factors here are how cheaply you can detect failure (in terms of time, material, political capital, team morale) and how easily you can backtrack out of a bad design decision (in terms of political capital, how much other things need to be redone due to coupling, and other limitations).<p>The earlier you can detect bad decisions, and the easier you can revert them, the less planning you need. But sometimes those are difficult.<p>It also suggests that continuous validation and forward looking to detect bad decisions early can be warranted. Something which I myself need to get better at.</div><br/></div></div></div></div><div id="40105242" class="c"><input type="checkbox" id="c-40105242" checked=""/><div class="controls bullet"><span class="by">mkl</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103934">parent</a><span>|</span><a href="#40104027">prev</a><span>|</span><a href="#40110869">next</a><span>|</span><label class="collapse" for="c-40105242">[-]</label><label class="expand" for="c-40105242">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Novelists for example know this very well. Beginners are always obsessed with intellectually planning out their book. The experienced writer will always tell you, stop yapping and start typing.<p>This is not true in general.  Brandon Sanderson for example outlines extensively before writing: <a href="https:&#x2F;&#x2F;faq.brandonsanderson.com&#x2F;knowledge-base&#x2F;can-you-go-into-depth-about-outlining&#x2F;" rel="nofollow">https:&#x2F;&#x2F;faq.brandonsanderson.com&#x2F;knowledge-base&#x2F;can-you-go-i...</a></div><br/></div></div><div id="40110869" class="c"><input type="checkbox" id="c-40110869" checked=""/><div class="controls bullet"><span class="by">citizen_friend</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103934">parent</a><span>|</span><a href="#40105242">prev</a><span>|</span><a href="#40103664">next</a><span>|</span><label class="collapse" for="c-40110869">[-]</label><label class="expand" for="c-40110869">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  You just need to start to work, and rework if necessary<p>And making changes on paper is cheaper than in code.</div><br/></div></div></div></div><div id="40103664" class="c"><input type="checkbox" id="c-40103664" checked=""/><div class="controls bullet"><span class="by">n4r9</span><span>|</span><a href="#40103616">parent</a><span>|</span><a href="#40103934">prev</a><span>|</span><a href="#40110741">next</a><span>|</span><label class="collapse" for="c-40103664">[-]</label><label class="expand" for="c-40103664">[15 more]</label></div><br/><div class="children"><div class="content">Question in my head is, can LLMs think algorithmically?</div><br/><div id="40103978" class="c"><input type="checkbox" id="c-40103978" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103664">parent</a><span>|</span><a href="#40104161">next</a><span>|</span><label class="collapse" for="c-40103978">[-]</label><label class="expand" for="c-40103978">[11 more]</label></div><br/><div class="children"><div class="content">LLMs can&#x27;t think.</div><br/><div id="40104381" class="c"><input type="checkbox" id="c-40104381" checked=""/><div class="controls bullet"><span class="by">tasuki</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103978">parent</a><span>|</span><a href="#40104118">next</a><span>|</span><label class="collapse" for="c-40104381">[-]</label><label class="expand" for="c-40104381">[6 more]</label></div><br/><div class="children"><div class="content">Source?</div><br/><div id="40104546" class="c"><input type="checkbox" id="c-40104546" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104381">parent</a><span>|</span><a href="#40109028">next</a><span>|</span><label class="collapse" for="c-40104546">[-]</label><label class="expand" for="c-40104546">[4 more]</label></div><br/><div class="children"><div class="content">LLMs string together words using probability and randomness. This makes their output sound extremely confident and believable, but it may often be bullshit. This is not comparable to thought as seen in humans and other animals.</div><br/><div id="40105034" class="c"><input type="checkbox" id="c-40105034" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104546">parent</a><span>|</span><a href="#40109028">next</a><span>|</span><label class="collapse" for="c-40105034">[-]</label><label class="expand" for="c-40105034">[3 more]</label></div><br/><div class="children"><div class="content">unfortunately that is exactly what the humans are doing an alarming fraction of the time</div><br/><div id="40105235" class="c"><input type="checkbox" id="c-40105235" checked=""/><div class="controls bullet"><span class="by">yifanl</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40105034">parent</a><span>|</span><a href="#40109028">next</a><span>|</span><label class="collapse" for="c-40105235">[-]</label><label class="expand" for="c-40105235">[2 more]</label></div><br/><div class="children"><div class="content">One of the differences is that humans are very good at not doing word associations if we think they don&#x27;t exist, which makes us able to outperform LLMs even without a hundred billion dollars worth of hardware strapped into our skulls.</div><br/><div id="40105504" class="c"><input type="checkbox" id="c-40105504" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40105235">parent</a><span>|</span><a href="#40109028">next</a><span>|</span><label class="collapse" for="c-40105504">[-]</label><label class="expand" for="c-40105504">[1 more]</label></div><br/><div class="children"><div class="content">that&#x27;s called epistemic humility, or knowing what you don&#x27;t know, or at least keeping your mouth shut, and in my experience actually humans suck at it, in all those forms</div><br/></div></div></div></div></div></div></div></div><div id="40109028" class="c"><input type="checkbox" id="c-40109028" checked=""/><div class="controls bullet"><span class="by">cpeterso</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104381">parent</a><span>|</span><a href="#40104546">prev</a><span>|</span><a href="#40104118">next</a><span>|</span><label class="collapse" for="c-40109028">[-]</label><label class="expand" for="c-40109028">[1 more]</label></div><br/><div class="children"><div class="content">Ask an LLM.</div><br/></div></div></div></div><div id="40104118" class="c"><input type="checkbox" id="c-40104118" checked=""/><div class="controls bullet"><span class="by">FeepingCreature</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103978">parent</a><span>|</span><a href="#40104381">prev</a><span>|</span><a href="#40104161">next</a><span>|</span><label class="collapse" for="c-40104118">[-]</label><label class="expand" for="c-40104118">[4 more]</label></div><br/><div class="children"><div class="content">LLMs can think.</div><br/><div id="40104382" class="c"><input type="checkbox" id="c-40104382" checked=""/><div class="controls bullet"><span class="by">tasuki</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104118">parent</a><span>|</span><a href="#40104161">next</a><span>|</span><label class="collapse" for="c-40104382">[-]</label><label class="expand" for="c-40104382">[3 more]</label></div><br/><div class="children"><div class="content">Source?</div><br/><div id="40108133" class="c"><input type="checkbox" id="c-40108133" checked=""/><div class="controls bullet"><span class="by">FeepingCreature</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104382">parent</a><span>|</span><a href="#40104161">next</a><span>|</span><label class="collapse" for="c-40108133">[-]</label><label class="expand" for="c-40108133">[2 more]</label></div><br/><div class="children"><div class="content">I use them a lot. They sure seem thinky.<p>The other day I had one write a website for me. Totally novel concept. No issues.</div><br/><div id="40109443" class="c"><input type="checkbox" id="c-40109443" checked=""/><div class="controls bullet"><span class="by">tasuki</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40108133">parent</a><span>|</span><a href="#40104161">next</a><span>|</span><label class="collapse" for="c-40109443">[-]</label><label class="expand" for="c-40109443">[1 more]</label></div><br/><div class="children"><div class="content">I have a similar experience. Just thought it&#x27;d be cute to ask you both for sources. Interesting that asking you for sources got me upvoted, while asking the other guy for sources got me downvoted :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40104161" class="c"><input type="checkbox" id="c-40104161" checked=""/><div class="controls bullet"><span class="by">datascienced</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103664">parent</a><span>|</span><a href="#40103978">prev</a><span>|</span><a href="#40104572">next</a><span>|</span><label class="collapse" for="c-40104161">[-]</label><label class="expand" for="c-40104161">[2 more]</label></div><br/><div class="children"><div class="content">Like a bad coder with a great memory, yes</div><br/><div id="40104705" class="c"><input type="checkbox" id="c-40104705" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40104161">parent</a><span>|</span><a href="#40104572">next</a><span>|</span><label class="collapse" for="c-40104705">[-]</label><label class="expand" for="c-40104705">[1 more]</label></div><br/><div class="children"><div class="content">The problem is the word “producing” of the parent comment, where it should be “reproducing”.</div><br/></div></div></div></div><div id="40104572" class="c"><input type="checkbox" id="c-40104572" checked=""/><div class="controls bullet"><span class="by">deepnet</span><span>|</span><a href="#40103616">root</a><span>|</span><a href="#40103664">parent</a><span>|</span><a href="#40104161">prev</a><span>|</span><a href="#40110741">next</a><span>|</span><label class="collapse" for="c-40104572">[-]</label><label class="expand" for="c-40104572">[1 more]</label></div><br/><div class="children"><div class="content">Interesting question.<p>LLMs can be cajoled into producing algorithms.<p>In fact this is the Chain-of-Thought optimisation.<p>LLMs give better results when asked for a series of steps to produce a result than when just asked for the result.<p>To ask if LLMs “think” is an open question and requires a definition of thinking :-)</div><br/></div></div></div></div></div></div><div id="40110741" class="c"><input type="checkbox" id="c-40110741" checked=""/><div class="controls bullet"><span class="by">NoPicklez</span><span>|</span><a href="#40103616">prev</a><span>|</span><a href="#40106745">next</a><span>|</span><label class="collapse" for="c-40110741">[-]</label><label class="expand" for="c-40110741">[1 more]</label></div><br/><div class="children"><div class="content">Programming is mostly thinking just like many other knowledge related jobs, it&#x27;s nothing special. This analogy can be used for most design related jobs, not just software.<p>If I had my client report deleted today, I could rewrite that report in nearly half the time the next day because I remember the way in which I structured the report, the sentences that flowed that didn&#x27;t and the way I conveyed the findings in a neutral way.<p>No different to designing a physical product. You might see the outcome, but you don&#x27;t see the numerous design iterations and compromises that came along the way which speak to the design that came out the end.<p>Furthermore, there are going to be programmers that can write more code with less thought, because they might have many years of pre-thought knowledge and understanding that allows them to execute faster.<p>This article sounds like it was written for a manager that doesn&#x27;t see the value in the work performed, or simply doesn&#x27;t understand design related work.</div><br/></div></div><div id="40106745" class="c"><input type="checkbox" id="c-40106745" checked=""/><div class="controls bullet"><span class="by">perrygeo</span><span>|</span><a href="#40110741">prev</a><span>|</span><a href="#40105564">next</a><span>|</span><label class="collapse" for="c-40106745">[-]</label><label class="expand" for="c-40106745">[1 more]</label></div><br/><div class="children"><div class="content">Writers get a bit dualistic on this topic. It&#x27;s not &quot;sitting in a hammock and dreaming up the the entire project&quot; vs. &quot;hacking it out in a few sprints with no plan&quot;. You can hack on code in the morning, sit in a hammock that afternoon, and deliver production code the next day. It&#x27;s not either-or. It&#x27;s a positive feedback loop between thinking and doing that improves both.</div><br/></div></div><div id="40105564" class="c"><input type="checkbox" id="c-40105564" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#40106745">prev</a><span>|</span><a href="#40104157">next</a><span>|</span><label class="collapse" for="c-40105564">[-]</label><label class="expand" for="c-40105564">[3 more]</label></div><br/><div class="children"><div class="content">Author listed a handful of the thinking aspects that take up the 11&#x2F;12 non-motion work.. but left out naming things!  The amount of time in conversation about naming, or even renaming the things I&#x27;ve already named.. there&#x27;s even a name for it in the extreme, bikeshedding.  Even sometimes I&#x27;ll be fixated on how to phrase the comments for a function or even reformat things for line lengths to fit.<p>Programming is mostly communicating.</div><br/><div id="40105592" class="c"><input type="checkbox" id="c-40105592" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#40105564">parent</a><span>|</span><a href="#40104157">next</a><span>|</span><label class="collapse" for="c-40105592">[-]</label><label class="expand" for="c-40105592">[2 more]</label></div><br/><div class="children"><div class="content">Yep, with seniority programming gradually goes from problem solving to product communication and solution proposition</div><br/><div id="40110875" class="c"><input type="checkbox" id="c-40110875" checked=""/><div class="controls bullet"><span class="by">citizen_friend</span><span>|</span><a href="#40105564">root</a><span>|</span><a href="#40105592">parent</a><span>|</span><a href="#40104157">next</a><span>|</span><label class="collapse" for="c-40110875">[-]</label><label class="expand" for="c-40110875">[1 more]</label></div><br/><div class="children"><div class="content">Seniority in helping large organizations navigate software development, not seniority in actually building software.</div><br/></div></div></div></div></div></div><div id="40104157" class="c"><input type="checkbox" id="c-40104157" checked=""/><div class="controls bullet"><span class="by">doganugurlu</span><span>|</span><a href="#40105564">prev</a><span>|</span><a href="#40103692">next</a><span>|</span><label class="collapse" for="c-40104157">[-]</label><label class="expand" for="c-40104157">[2 more]</label></div><br/><div class="children"><div class="content">In the 2020s, we still have software engineering managers that think of LOC as a success metric.<p>“How long would it take you to type the 6 hours work of diff?” is a great question to force the cognitively lazy software manager to figure out how naive that is.<p>Nowadays I feel great when my PRs have more lines removed than added. And I really question if the added code was worth the added value if it’s the opposite.</div><br/><div id="40104933" class="c"><input type="checkbox" id="c-40104933" checked=""/><div class="controls bullet"><span class="by">masswerk</span><span>|</span><a href="#40104157">parent</a><span>|</span><a href="#40103692">next</a><span>|</span><label class="collapse" for="c-40104933">[-]</label><label class="expand" for="c-40104933">[1 more]</label></div><br/><div class="children"><div class="content">Conversely, how long would it take the average manager to re-utter any directions they gave the previous day?</div><br/></div></div></div></div><div id="40103692" class="c"><input type="checkbox" id="c-40103692" checked=""/><div class="controls bullet"><span class="by">bradley13</span><span>|</span><a href="#40104157">prev</a><span>|</span><a href="#40104100">next</a><span>|</span><label class="collapse" for="c-40103692">[-]</label><label class="expand" for="c-40103692">[4 more]</label></div><br/><div class="children"><div class="content">I would absolutely agree, for any interesting programming problem. Certainly, the kind of programming I enjoy requires lots of thought and planning.<p>That said, don&#x27;t underestimate how much boilerplate code is produced. Yet another webshop, yet another forum, yet another customization of that ERP or CRM system. Crank it out, fast and cheap.<p>Maybe that&#x27;s the difference between &quot;coding&quot; and &quot;programming&quot;?</div><br/><div id="40103832" class="c"><input type="checkbox" id="c-40103832" checked=""/><div class="controls bullet"><span class="by">qwery</span><span>|</span><a href="#40103692">parent</a><span>|</span><a href="#40104518">next</a><span>|</span><label class="collapse" for="c-40103832">[-]</label><label class="expand" for="c-40103832">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Maybe that&#x27;s the difference between &quot;coding&quot; and &quot;programming&quot;?<p>I know I&#x27;m not alone in using these terms to distinguish between each mode of my own work. There is overlap, but coding is typing, remembering names, syntax, etc. whereas programming is design or &quot;mostly thinking&quot;.</div><br/><div id="40103877" class="c"><input type="checkbox" id="c-40103877" checked=""/><div class="controls bullet"><span class="by">runesoerensen</span><span>|</span><a href="#40103692">root</a><span>|</span><a href="#40103832">parent</a><span>|</span><a href="#40104518">next</a><span>|</span><label class="collapse" for="c-40103877">[-]</label><label class="expand" for="c-40103877">[1 more]</label></div><br/><div class="children"><div class="content">I usually think of coding and programming as fairly interchangeable words (vs “developing”, which I think encapsulates both the design&#x2F;thinking and typing&#x2F;coding aspects of the process better)</div><br/></div></div></div></div><div id="40104518" class="c"><input type="checkbox" id="c-40104518" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#40103692">parent</a><span>|</span><a href="#40103832">prev</a><span>|</span><a href="#40104100">next</a><span>|</span><label class="collapse" for="c-40104518">[-]</label><label class="expand" for="c-40104518">[1 more]</label></div><br/><div class="children"><div class="content">Implementing known solutions is less thinking and more typing, but on the other hand it feels like CoPilot and so on is changing that.  If you have something straightforward to build, you know the broad strokes of how it&#x27;s going to come together, the actual output of the code is so greatly accelerated now that whatever thinking is left takes a proportionally higher chunk of time.<p>... and &quot;whatever is left&quot; is the thinking and planning side of things, which even in its diminished role in implementing a known solution, still comes into play every once in a while.</div><br/></div></div></div></div><div id="40104100" class="c"><input type="checkbox" id="c-40104100" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#40103692">prev</a><span>|</span><a href="#40104849">next</a><span>|</span><label class="collapse" for="c-40104100">[-]</label><label class="expand" for="c-40104100">[5 more]</label></div><br/><div class="children"><div class="content">Agree and disagree. Certain programming domains and problems are mostly thinking. Bug fixing is often debugging, reading and comprehension rather than thinking. Shitting out CRUD interfaces after you&#x27;ve done it a few times is not really thinking.<p>Other posters have it right I think. Fluency with the requisite domains greatly reduces the thinking time of programming.</div><br/><div id="40104146" class="c"><input type="checkbox" id="c-40104146" checked=""/><div class="controls bullet"><span class="by">guax</span><span>|</span><a href="#40104100">parent</a><span>|</span><a href="#40104175">next</a><span>|</span><label class="collapse" for="c-40104146">[-]</label><label class="expand" for="c-40104146">[2 more]</label></div><br/><div class="children"><div class="content">Debugging is not thinking? Reading, understanding and reasoning about why something is happening is THE THING thinking is about.<p>Fluency increases the speed in which you move to other subjects but does not reduce your thinking, you&#x27;re going to more complex issues more often.</div><br/><div id="40104280" class="c"><input type="checkbox" id="c-40104280" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#40104100">root</a><span>|</span><a href="#40104146">parent</a><span>|</span><a href="#40104175">next</a><span>|</span><label class="collapse" for="c-40104280">[-]</label><label class="expand" for="c-40104280">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not <i>just</i> thinking though. You&#x27;re not sitting at your desk quietly running simulations in your head, and if a non programmer was watching you debug it would look very busy.</div><br/></div></div></div></div><div id="40104175" class="c"><input type="checkbox" id="c-40104175" checked=""/><div class="controls bullet"><span class="by">makeitdouble</span><span>|</span><a href="#40104100">parent</a><span>|</span><a href="#40104146">prev</a><span>|</span><a href="#40104849">next</a><span>|</span><label class="collapse" for="c-40104175">[-]</label><label class="expand" for="c-40104175">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d wager the more technically fluent people get the more they spend time on thinking about the bigger picture or the edge cases.<p>Bug fixing is probably one of the best example: if you&#x27;re already underwater you&#x27;ll want to bandaid a solution. But the faster you can implement a fix the more you&#x27;ll have leeway, and the more durable you&#x27;ll try to make it, including trying to fix root causes, or prevent similar cases altogether.</div><br/><div id="40104273" class="c"><input type="checkbox" id="c-40104273" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#40104100">root</a><span>|</span><a href="#40104175">parent</a><span>|</span><a href="#40104849">next</a><span>|</span><label class="collapse" for="c-40104273">[-]</label><label class="expand" for="c-40104273">[1 more]</label></div><br/><div class="children"><div class="content">Fluency in bug fixing looks like, &quot;there was an unhandled concurrency error on write in the message importing service therefore I will implement a retry from the point of loading the message&quot; and then you just do that. There are only a few appropriate ways to handle concurrency errors so once you have done it a few times, you are just picking the pattern that fits this particular case.<p>One might say, &quot;yes but if you see so many concurrency related bugs, what is the root cause and why don&#x27;t you do that?&quot; And sometimes the answer is just, &quot;I work on a codebase that is 20 years old with hundreds of services and each one needs to have appropriate error handling on a case by case basis to suit the specific service so the root cause fix is going and doing that 100 times.&quot;</div><br/></div></div></div></div></div></div><div id="40104849" class="c"><input type="checkbox" id="c-40104849" checked=""/><div class="controls bullet"><span class="by">khaledh</span><span>|</span><a href="#40104100">prev</a><span>|</span><a href="#40104239">next</a><span>|</span><label class="collapse" for="c-40104849">[-]</label><label class="expand" for="c-40104849">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Weeks of coding can save you hours of planning.&quot; - Unknown.</div><br/><div id="40104979" class="c"><input type="checkbox" id="c-40104979" checked=""/><div class="controls bullet"><span class="by">runald</span><span>|</span><a href="#40104849">parent</a><span>|</span><a href="#40104239">next</a><span>|</span><label class="collapse" for="c-40104979">[-]</label><label class="expand" for="c-40104979">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Everyone has a meal plan until they get a fruit punch in the face.&quot; -Tyson?</div><br/></div></div></div></div><div id="40104239" class="c"><input type="checkbox" id="c-40104239" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#40104849">prev</a><span>|</span><a href="#40103776">next</a><span>|</span><label class="collapse" for="c-40104239">[-]</label><label class="expand" for="c-40104239">[4 more]</label></div><br/><div class="children"><div class="content">At my previous job, I calculated that over the last year I worked there, I wrote 80 lines of non-test, production code.  80.  About one line per 3-4 days of work.  I think I could have retyped all the code I wrote that year in less than an hour.<p>The rest of the time?  Spent in two daily stand up meetings [1], each at least 40 minutes long (and just shy of half of them lasted longer than three hours).<p>I should also say the code base was C, C++ and Lua, and had nothing to do with the web.<p>[1] Because my new manager <i>hated</i> the one daily standup with other teams, so he insisted on just our team having one.</div><br/><div id="40106069" class="c"><input type="checkbox" id="c-40106069" checked=""/><div class="controls bullet"><span class="by">BossingAround</span><span>|</span><a href="#40104239">parent</a><span>|</span><a href="#40103776">next</a><span>|</span><label class="collapse" for="c-40106069">[-]</label><label class="expand" for="c-40106069">[3 more]</label></div><br/><div class="children"><div class="content">Were the intense daily meetings any help? I can imagine that if there&#x27;s a ticket to be solved, and I can talk about the problem for 40 minutes to more experienced coworkers, that actually speeds up the necessary dev time by quite a lot.<p>Of course, it will probably just devolve into a disengaged group of people that read emails or Slack in another window, so there&#x27;s that.</div><br/><div id="40111445" class="c"><input type="checkbox" id="c-40111445" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#40104239">root</a><span>|</span><a href="#40106069">parent</a><span>|</span><a href="#40107058">next</a><span>|</span><label class="collapse" for="c-40111445">[-]</label><label class="expand" for="c-40111445">[1 more]</label></div><br/><div class="children"><div class="content">Not really.  It was mostly about tests.  Officially, I was a developer for the team (longest one on the team).  Unofficially I was QA, as our new manager shut out QA entirely [1] and I became the &quot;go-to&quot; person for tests.  Never a question about how the system worked as a whole, just test test tests testing tests tests write the new tests did you write the new tests how do we run the tests aaaaaaaaaaah!  Never mind that I thought I had a simple test harness set up, nope.  They were completely baffled by the thought of automation it seems.<p>[1] &quot;Because I don&#x27;t want them to be biased by knowing the implementation when testing&quot; but in reality, quality went to hell.</div><br/></div></div><div id="40107058" class="c"><input type="checkbox" id="c-40107058" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#40104239">root</a><span>|</span><a href="#40106069">parent</a><span>|</span><a href="#40111445">prev</a><span>|</span><a href="#40103776">next</a><span>|</span><label class="collapse" for="c-40107058">[-]</label><label class="expand" for="c-40107058">[1 more]</label></div><br/><div class="children"><div class="content">80% of meetings are useless. Especially long ones.</div><br/></div></div></div></div></div></div><div id="40103776" class="c"><input type="checkbox" id="c-40103776" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#40104239">prev</a><span>|</span><a href="#40103828">next</a><span>|</span><label class="collapse" for="c-40103776">[-]</label><label class="expand" for="c-40103776">[1 more]</label></div><br/><div class="children"><div class="content">I liked &quot;Code is just the residue of the work&quot;</div><br/></div></div><div id="40103828" class="c"><input type="checkbox" id="c-40103828" checked=""/><div class="controls bullet"><span class="by">MartijnBraam</span><span>|</span><a href="#40103776">prev</a><span>|</span><a href="#40104978">next</a><span>|</span><label class="collapse" for="c-40103828">[-]</label><label class="expand" for="c-40103828">[11 more]</label></div><br/><div class="children"><div class="content">Who hasn&#x27;t accidentally thrown away a days worth of work with the wrong rm or git command? It is indeed significantly quicker to recreate a piece of work and usually the code quality improves for me.</div><br/><div id="40103835" class="c"><input type="checkbox" id="c-40103835" checked=""/><div class="controls bullet"><span class="by">nickff</span><span>|</span><a href="#40103828">parent</a><span>|</span><a href="#40105067">next</a><span>|</span><label class="collapse" for="c-40103835">[-]</label><label class="expand" for="c-40103835">[7 more]</label></div><br/><div class="children"><div class="content">I’ve often found it alarming to see how much better the re-do is. I wonder whether I should re-write more code.</div><br/><div id="40108324" class="c"><input type="checkbox" id="c-40108324" checked=""/><div class="controls bullet"><span class="by">CM30</span><span>|</span><a href="#40103828">root</a><span>|</span><a href="#40103835">parent</a><span>|</span><a href="#40105086">next</a><span>|</span><label class="collapse" for="c-40108324">[-]</label><label class="expand" for="c-40108324">[1 more]</label></div><br/><div class="children"><div class="content">I think this was the reasoning behind the adage &quot;make it work, make it right, make it fast&quot; (or something along those lines).<p>You&#x27;d do a fairly rough draft of the project first, just trying to make it do what you intend it to. Then you&#x27;d rewrite it so it works without glaring bugs or issues, then optimise it to make it better&#x2F;more performant&#x2F;more clearly organised after that.</div><br/></div></div><div id="40105086" class="c"><input type="checkbox" id="c-40105086" checked=""/><div class="controls bullet"><span class="by">jll29</span><span>|</span><a href="#40103828">root</a><span>|</span><a href="#40103835">parent</a><span>|</span><a href="#40108324">prev</a><span>|</span><a href="#40104740">next</a><span>|</span><label class="collapse" for="c-40105086">[-]</label><label class="expand" for="c-40105086">[1 more]</label></div><br/><div class="children"><div class="content">In the software engineering literature, there is something known as &quot;second system effect&quot;: the second time a system is designed it will be bloated, over-engineered and ultimately fail, because people want to do it all better, too much so for anyone&#x27;s good.<p>But it seems this is only true for complete system designs from scratch after a first system has already been deployed, not for the small &quot;deleted some code and now I&#x27;m rewriting it quickly&quot; incidents (for which there is no special term yet?).</div><br/></div></div><div id="40104740" class="c"><input type="checkbox" id="c-40104740" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#40103828">root</a><span>|</span><a href="#40103835">parent</a><span>|</span><a href="#40105086">prev</a><span>|</span><a href="#40105067">next</a><span>|</span><label class="collapse" for="c-40104740">[-]</label><label class="expand" for="c-40104740">[4 more]</label></div><br/><div class="children"><div class="content">Absolutely. Parallel to thinking LOC is a good metric, comes with &quot;we have to reuse code&quot; Because lots of people think, writing the code is very expensive. It is not!</div><br/><div id="40105076" class="c"><input type="checkbox" id="c-40105076" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40103828">root</a><span>|</span><a href="#40104740">parent</a><span>|</span><a href="#40105067">next</a><span>|</span><label class="collapse" for="c-40105076">[-]</label><label class="expand" for="c-40105076">[3 more]</label></div><br/><div class="children"><div class="content">writing it is not expensive.  however, fixing the same bug in all the redundant reimplementations, adding the same feature to all of them, and keeping straight the minor differences between them, is expensive</div><br/><div id="40106087" class="c"><input type="checkbox" id="c-40106087" checked=""/><div class="controls bullet"><span class="by">BossingAround</span><span>|</span><a href="#40103828">root</a><span>|</span><a href="#40105076">parent</a><span>|</span><a href="#40105067">next</a><span>|</span><label class="collapse" for="c-40106087">[-]</label><label class="expand" for="c-40106087">[2 more]</label></div><br/><div class="children"><div class="content">Not only fixing the same bug twice, but also fixing bugs that happen because of using the same functionality in different places. For example, possible inconsistency that results from maintaining state in multiple different locations can be a nightmare, esp. in hard-to-debug systems like highly parallelized or distributed architecture.</div><br/><div id="40110386" class="c"><input type="checkbox" id="c-40110386" checked=""/><div class="controls bullet"><span class="by">Akronymus</span><span>|</span><a href="#40103828">root</a><span>|</span><a href="#40106087">parent</a><span>|</span><a href="#40105067">next</a><span>|</span><label class="collapse" for="c-40110386">[-]</label><label class="expand" for="c-40110386">[1 more]</label></div><br/><div class="children"><div class="content">I see &quot;code that looks the same&quot; being treated as &quot;code that means the same&quot; resulting in problems much more often than &quot;code that means the same&quot; being duplicated.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40105067" class="c"><input type="checkbox" id="c-40105067" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40103828">parent</a><span>|</span><a href="#40103835">prev</a><span>|</span><a href="#40103836">next</a><span>|</span><label class="collapse" for="c-40105067">[-]</label><label class="expand" for="c-40105067">[1 more]</label></div><br/><div class="children"><div class="content">i&#x27;ve never lost work to a wrong git command because i know how to use `git reflog` and `gitk`. it&#x27;s possible to lose work with git (by not checking it in, `rm -r`g the work tree with the reflog in it, or having a catastrophic hardware failure) but it is rare enough i haven&#x27;t had it happen yet</div><br/></div></div><div id="40103836" class="c"><input type="checkbox" id="c-40103836" checked=""/><div class="controls bullet"><span class="by">timvdalen</span><span>|</span><a href="#40103828">parent</a><span>|</span><a href="#40105067">prev</a><span>|</span><a href="#40104170">next</a><span>|</span><label class="collapse" for="c-40103836">[-]</label><label class="expand" for="c-40103836">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that can often result in a better-designed refactored version, since you can start with a fully-formed idea!</div><br/></div></div><div id="40104170" class="c"><input type="checkbox" id="c-40104170" checked=""/><div class="controls bullet"><span class="by">datascienced</span><span>|</span><a href="#40103828">parent</a><span>|</span><a href="#40103836">prev</a><span>|</span><a href="#40104978">next</a><span>|</span><label class="collapse" for="c-40104170">[-]</label><label class="expand" for="c-40104170">[1 more]</label></div><br/><div class="children"><div class="content">Not for ages and definitely not since Github- just keep committing and pushing as a backup</div><br/></div></div></div></div><div id="40104978" class="c"><input type="checkbox" id="c-40104978" checked=""/><div class="controls bullet"><span class="by">matthewsinclair</span><span>|</span><a href="#40103828">prev</a><span>|</span><a href="#40103983">next</a><span>|</span><label class="collapse" for="c-40104978">[-]</label><label class="expand" for="c-40104978">[3 more]</label></div><br/><div class="children"><div class="content">This is also relevant in the context of using LLMs to help you code.<p>The way I see it, programming is about “20% syntax and 80% wisdom”. At least as it stands today.<p>LLMs are good (perhaps even great) for the 20% that is syntax related but much less useful for the 80% that is wisdom related.<p>I can certainly see how those ratios might change over time as LLMs (or their progeny) get more and more capable. But for now, that ratio feels about right.</div><br/><div id="40105119" class="c"><input type="checkbox" id="c-40105119" checked=""/><div class="controls bullet"><span class="by">hnthrow289570</span><span>|</span><a href="#40104978">parent</a><span>|</span><a href="#40103983">next</a><span>|</span><label class="collapse" for="c-40105119">[-]</label><label class="expand" for="c-40105119">[2 more]</label></div><br/><div class="children"><div class="content">Sadly like half of that wisdom has to do with avoiding personal stress caused by business processes.</div><br/><div id="40106246" class="c"><input type="checkbox" id="c-40106246" checked=""/><div class="controls bullet"><span class="by">matthewsinclair</span><span>|</span><a href="#40104978">root</a><span>|</span><a href="#40105119">parent</a><span>|</span><a href="#40103983">next</a><span>|</span><label class="collapse" for="c-40106246">[-]</label><label class="expand" for="c-40106246">[1 more]</label></div><br/><div class="children"><div class="content">Well, exactly. That’s kinda my point. Programming is so much more than just writing code. And sadly, some of that other stuff involves dealing with humans and their manifest idiosyncrasies.</div><br/></div></div></div></div></div></div><div id="40103983" class="c"><input type="checkbox" id="c-40103983" checked=""/><div class="controls bullet"><span class="by">willrftaylor</span><span>|</span><a href="#40104978">prev</a><span>|</span><a href="#40104579">next</a><span>|</span><label class="collapse" for="c-40103983">[-]</label><label class="expand" for="c-40103983">[4 more]</label></div><br/><div class="children"><div class="content">Funnily enough this happened to me.<p>Earlier in my career I had a very intense, productive working day and then blundered a rebase command, deleting all my data.<p>Rewriting took only about 20 minutes.<p>However, like an idiot, I deleted it again, in the exact same way!<p>This time I had the muscle memory for which files to open and where to edit, and the whole diff took about 5 minutes to re-add.<p>On the way out to the car park it really made me pause to wonder what on earth I had been doing all day.</div><br/><div id="40104506" class="c"><input type="checkbox" id="c-40104506" checked=""/><div class="controls bullet"><span class="by">alex_smart</span><span>|</span><a href="#40103983">parent</a><span>|</span><a href="#40104119">next</a><span>|</span><label class="collapse" for="c-40104506">[-]</label><label class="expand" for="c-40104506">[1 more]</label></div><br/><div class="children"><div class="content">In case you didn’t know, doesn’t delete the commit. You can use `git reflog` to find the commits you were recently on and recover your code.</div><br/></div></div><div id="40104119" class="c"><input type="checkbox" id="c-40104119" checked=""/><div class="controls bullet"><span class="by">thunfischtoast</span><span>|</span><a href="#40103983">parent</a><span>|</span><a href="#40104506">prev</a><span>|</span><a href="#40104579">next</a><span>|</span><label class="collapse" for="c-40104119">[-]</label><label class="expand" for="c-40104119">[2 more]</label></div><br/><div class="children"><div class="content">Sometimes you really wonder where your time went. You can spend 1 hour writing a perfect function and then the rest of the day figuring out why your import does work in dev and not in prod.<p>I also once butchered the result of 40 hours of work through a loose git history rewrite.
I spent a good hour trying different recovery options (to no avail) and then 2 hours typing everything back in from memory. Maybe it turned out even better then before, because all kind of debugging clutter was removed.</div><br/><div id="40106051" class="c"><input type="checkbox" id="c-40106051" checked=""/><div class="controls bullet"><span class="by">BossingAround</span><span>|</span><a href="#40103983">root</a><span>|</span><a href="#40104119">parent</a><span>|</span><a href="#40104579">next</a><span>|</span><label class="collapse" for="c-40106051">[-]</label><label class="expand" for="c-40106051">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes, I spend an hour writing a perfect function, and then spend another hour re-reading the beauty of it, just to be pointed out how imperfect the function is in the PR review :))</div><br/></div></div></div></div></div></div><div id="40104579" class="c"><input type="checkbox" id="c-40104579" checked=""/><div class="controls bullet"><span class="by">thatjoeoverthr</span><span>|</span><a href="#40103983">prev</a><span>|</span><a href="#40104103">next</a><span>|</span><label class="collapse" for="c-40104579">[-]</label><label class="expand" for="c-40104579">[1 more]</label></div><br/><div class="children"><div class="content">I’ve faced this viscerally with copilot. I picked it up to type for me after a sport injury. Last week, though, I had an experience; I was falling ill and “not all there.” None of the AI tools were of any help. Copilot is like a magical thought finisher, but if I don’t have the thought in the first place, everything stops.</div><br/></div></div><div id="40104103" class="c"><input type="checkbox" id="c-40104103" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#40104579">prev</a><span>|</span><a href="#40109078">next</a><span>|</span><label class="collapse" for="c-40104103">[-]</label><label class="expand" for="c-40104103">[5 more]</label></div><br/><div class="children"><div class="content">This is why I just don&#x27;t care about my keyboard, mouse, monitor etc beyond a baseline of minimum comfort.<p>Typing at an extra 15 wpm won&#x27;t make a lick of difference in how quickly I produce a product, nor will how often my fingers leave the keyboard or how often I look at the screen. Once I&#x27;ve ingested the problem space and parameters, it all happens in my head.</div><br/><div id="40104297" class="c"><input type="checkbox" id="c-40104297" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#40104103">parent</a><span>|</span><a href="#40104177">next</a><span>|</span><label class="collapse" for="c-40104297">[-]</label><label class="expand" for="c-40104297">[3 more]</label></div><br/><div class="children"><div class="content">I often feel that having a &quot;comfortable&quot; keyboard&#x2F;mouse&#x2F;monitor is more important than a fast CPU or a fancy graphics card - just because of that slight extra feeling of pleasure&#x2F;ease that lasts all day long :-).<p>The advantage of them is that my monitors and keyboards usually last a long time  so putting money into them is not as wasteful as putting it into some other components.<p>One thing that surprised me though is that I recently bought a KVM to switch from desktop to laptop instead of a second monitor and this turned out to be both better and much cheaper. I gave away an older monitor to a relative and found that not having to turn to look at a 2nd monitor was actually nicer.   Initially I really didn&#x27;t want to do this and really wanted another screen but I had to admit afterwards that 1 screen + KVM was better for me.<p>RAM and disc space just matter up to the point of having enough so that I&#x27;m not wasting time trying to manage them to get work done.</div><br/><div id="40105234" class="c"><input type="checkbox" id="c-40105234" checked=""/><div class="controls bullet"><span class="by">ripe</span><span>|</span><a href="#40104103">root</a><span>|</span><a href="#40104297">parent</a><span>|</span><a href="#40104177">next</a><span>|</span><label class="collapse" for="c-40105234">[-]</label><label class="expand" for="c-40105234">[2 more]</label></div><br/><div class="children"><div class="content">May I ask which brand of KVM you selected? I have a Dell laptop and want a &quot;docking&quot; configuration for my desk, the simpler the better.</div><br/><div id="40112485" class="c"><input type="checkbox" id="c-40112485" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#40104103">root</a><span>|</span><a href="#40105234">parent</a><span>|</span><a href="#40104177">next</a><span>|</span><label class="collapse" for="c-40112485">[-]</label><label class="expand" for="c-40112485">[1 more]</label></div><br/><div class="children"><div class="content">It was a very cheap thing off Amazon. I&#x27;m in the UK so you might not have it - the brand name is &quot;VPFET KVM Switch 2x1&quot; and it has 4 usb, 1 HDMI outputs and 2x(1 HDMI,1 usb) inputs.<p>It&#x27;s the cheapest in their range, I think (about £30) - they have better ones.<p>Not massively flexible. Has a clicker switch which you could put on the floor if you wanted to let you flip displays. Not super fast at switching.....but it does the job for me. YMMV!<p>I use a 32-inch Viewsonic monitor with this. It&#x27;s the most expensive monitor I&#x27;ve ever bought but it&#x27;s nothing special when you look at what&#x27;s out there. I&#x27;t just lovely to use. :-) I think a purist would complain bitterly about refresh rates or whatever but I just love it and I spend my time reading web pages or code or watching the odd video.</div><br/></div></div></div></div></div></div><div id="40104177" class="c"><input type="checkbox" id="c-40104177" checked=""/><div class="controls bullet"><span class="by">sanitycheck</span><span>|</span><a href="#40104103">parent</a><span>|</span><a href="#40104297">prev</a><span>|</span><a href="#40109078">next</a><span>|</span><label class="collapse" for="c-40104177">[-]</label><label class="expand" for="c-40104177">[1 more]</label></div><br/><div class="children"><div class="content">It probably depends on the project?<p>When I&#x27;m writing something from scratch in a few months I can bash it all out on a small laptop - it is (as you say) all in my head, I just need to turn it into working code.<p>If I&#x27;m faced with some complicated debugging of a big existing system, or I&#x27;ve inherited someone elses project, that gets <i>much</i> easier with a couple of giant monitors to look at numerous files side by side - plus a beefier machine to reduce compile&#x2F;run times as I&#x27;ll need to do that every few mins.<p>You may care more about picking a keyboard &amp; mouse&#x2F;trackpad&#x2F;trackball&#x2F;etc if&#x2F;when you start to experience pain in your wrists&#x2F;hands and realise the potential impact on your career if it worsens! Similar situation with seating and back pain.</div><br/></div></div></div></div><div id="40109078" class="c"><input type="checkbox" id="c-40109078" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#40104103">prev</a><span>|</span><a href="#40105436">next</a><span>|</span><label class="collapse" for="c-40109078">[-]</label><label class="expand" for="c-40109078">[2 more]</label></div><br/><div class="children"><div class="content">&gt; typing and tools are not the most important aid to quick code production<p>I think they are in an indirect way. Being able to touch type reasonably fast prevents the action of typing distracting you from your thoughts, or lagging so far behind your thoughts that it makes it harder to keep your thoughts clear in your mind.<p>Maybe something similar with good tools.</div><br/><div id="40109126" class="c"><input type="checkbox" id="c-40109126" checked=""/><div class="controls bullet"><span class="by">nevertoolate</span><span>|</span><a href="#40109078">parent</a><span>|</span><a href="#40105436">next</a><span>|</span><label class="collapse" for="c-40109126">[-]</label><label class="expand" for="c-40109126">[1 more]</label></div><br/><div class="children"><div class="content">I think OP means that problems are just too hard to solve without thinking Before starting to type. So basically the typing in part is decoupled from the real thinking, and just about picking up half ready ideas from the queue and deserialize it, so to say, as code.</div><br/></div></div></div></div><div id="40105436" class="c"><input type="checkbox" id="c-40105436" checked=""/><div class="controls bullet"><span class="by">JKCalhoun</span><span>|</span><a href="#40109078">prev</a><span>|</span><label class="collapse" for="c-40105436">[-]</label><label class="expand" for="c-40105436">[1 more]</label></div><br/><div class="children"><div class="content">Somehow the post seemed to miss the amount of time I seem to spend on &quot;busy work&quot; in coding. Not meetings and that sort of thing, but just boring, repetitive, non-thinking coding.<p>Stubbing in a routine is fast, but then adding param checking, propagating errors, clean up, adding comments, refactoring sections of code into their own files as the code balloons, etc.<p>There&#x27;s no thinking involved in most of the time I am coding. And thank god. If 11&#x2F;12 of my time was spent twisting my brain into knots to understand the nuances of concurrency or thread-locking I would have lost my hair decades earlier.</div><br/></div></div></div></div></div></div></div></body></html>