<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700298060132" as="style"/><link rel="stylesheet" href="styles.css?v=1700298060132"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lmax-exchange.github.io/disruptor/">LMAX Disruptor – High Performance Inter-Thread Messaging Library</a> <span class="domain">(<a href="https://lmax-exchange.github.io">lmax-exchange.github.io</a>)</span></div><div class="subtext"><span>dgudkov</span> | <span>32 comments</span></div><br/><div><div id="38316826" class="c"><input type="checkbox" id="c-38316826" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#38313924">next</a><span>|</span><label class="collapse" for="c-38316826">[-]</label><label class="expand" for="c-38316826">[3 more]</label></div><br/><div class="children"><div class="content">Every time a new generation plays with the LMAX disruptor, it&#x27;s time to remind them that the modes with multiple producers&#x2F;consumers can have really bad tail latency if your application&#x27;s threading is not designed in the intended way.<p>Disruptor and most other data structures that come from trading are designed to run with thread-per-core systems.  This means systems where there will be no preemption during a critical section.  They can get away with a lot of shenanigans on the concurrency model due to this.  If you are using these data structures and have a thread-per-request model, you&#x27;re probably going to have a bad time.</div><br/><div id="38316857" class="c"><input type="checkbox" id="c-38316857" checked=""/><div class="controls bullet"><span class="by">xoranth</span><span>|</span><a href="#38316826">parent</a><span>|</span><a href="#38313924">next</a><span>|</span><label class="collapse" for="c-38316857">[-]</label><label class="expand" for="c-38316857">[2 more]</label></div><br/><div class="children"><div class="content">In general, what are the advantage of a thread-per-request model? Better load balancing between cores?</div><br/><div id="38316918" class="c"><input type="checkbox" id="c-38316918" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#38316826">root</a><span>|</span><a href="#38316857">parent</a><span>|</span><a href="#38313924">next</a><span>|</span><label class="collapse" for="c-38316918">[-]</label><label class="expand" for="c-38316918">[1 more]</label></div><br/><div class="children"><div class="content">Thread per request can never have better load balancing between cores than a well designed, custom solution.<p>You are essentially asking the operating system to do the scheduling for you. But the OS will never be able to do it perfectly as it has no knowledge of what your application is doing.<p>The main advantage of OS scheduling is that you get pretty good results without having to think about it at all. Pretty good, but never perfect.</div><br/></div></div></div></div></div></div><div id="38313924" class="c"><input type="checkbox" id="c-38313924" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#38316826">prev</a><span>|</span><a href="#38315325">next</a><span>|</span><label class="collapse" for="c-38313924">[-]</label><label class="expand" for="c-38313924">[3 more]</label></div><br/><div class="children"><div class="content">I am working on a C version of the disruptor ringbuffer it is very simple and I need to verify it so it&#x27;s probably not ready for others but it might be interesting. Aligning by 128 bytes has dropped latency and stopped false sharing.<p>I have gotten latencies to 50 nanoseconds and up.<p>disruptor-multi.c(SPMC) and disruptor-multi-producer.c (MPSC)
<a href="https:&#x2F;&#x2F;GitHub.com&#x2F;samsquire&#x2F;assembly">https:&#x2F;&#x2F;GitHub.com&#x2F;samsquire&#x2F;assembly</a><p>I am trying to work out how to support multiple producers and multiple readers (MPMC) at low latency that&#x27;s what I&#x27;m literally working on today.<p>The MPSC and SPMC seem to be working at low latencies.<p>I am hoping to apply actor model to the ringbuffer for communication.<p>I&#x27;m also working on nonblocking lock free barrier. This has latency as low as 42 nanoseconds and up.</div><br/><div id="38315879" class="c"><input type="checkbox" id="c-38315879" checked=""/><div class="controls bullet"><span class="by">cplusplusfellow</span><span>|</span><a href="#38313924">parent</a><span>|</span><a href="#38315325">next</a><span>|</span><label class="collapse" for="c-38315879">[-]</label><label class="expand" for="c-38315879">[2 more]</label></div><br/><div class="children"><div class="content">Do you think it’s possible to obtain this performance with Rust?<p>I’ve been down the path you’re on a few times and I love the pursuit.  Have built my own over the years about 4 times.<p>Hardware was much slower in those days so my lower barrier was 650ns.  Things got worse appreciably as a function of the number of producers I found.<p>Some of my most sleepless nights.  The funnest nights.</div><br/><div id="38316542" class="c"><input type="checkbox" id="c-38316542" checked=""/><div class="controls bullet"><span class="by">topbanana</span><span>|</span><a href="#38313924">root</a><span>|</span><a href="#38315879">parent</a><span>|</span><a href="#38315325">next</a><span>|</span><label class="collapse" for="c-38316542">[-]</label><label class="expand" for="c-38316542">[1 more]</label></div><br/><div class="children"><div class="content">std::collections::vec_deque is implemented as a growable ring buffer so you might like to start there<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;collections&#x2F;vec_deque&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;collections&#x2F;vec_deque&#x2F;index.ht...</a></div><br/></div></div></div></div></div></div><div id="38315325" class="c"><input type="checkbox" id="c-38315325" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38313924">prev</a><span>|</span><a href="#38314320">next</a><span>|</span><label class="collapse" for="c-38315325">[-]</label><label class="expand" for="c-38315325">[1 more]</label></div><br/><div class="children"><div class="content">Related. Others?<p><i>Disruptor: High performance alternative to bounded queues</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36073710">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36073710</a> - May 2023 (1 comment)<p><i>LMAX Disruptor: High performance method for exchanging data between threads</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30778042">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30778042</a> - March 2022 (1 comment)<p><i>The LMAX Architecture</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22369438">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22369438</a> - Feb 2020 (1 comment)<p><i>You could have invented the LMAX Disruptor, if only you were limited enough</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17817254">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17817254</a> - Aug 2018 (29 comments)<p><i>Disruptor: High performance alternative to bounded queues (2011) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12054503">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12054503</a> - July 2016 (27 comments)<p><i>The LMAX Architecture (2011)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9753044">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9753044</a> - June 2015 (4 comments)<p><i>LMAX Disruptor: High Performance Inter-Thread Messaging Library</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8064846">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=8064846</a> - July 2014 (2 comments)<p><i>Serious high-performance and lock-free algorithms (by LMAX devs)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=4022977">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=4022977</a> - May 2012 (17 comments)<p><i>The LMAX Architecture - 100K TPS at Less than 1ms Latency</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3173993">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3173993</a> - Oct 2011 (53 comments)</div><br/></div></div><div id="38314320" class="c"><input type="checkbox" id="c-38314320" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#38315325">prev</a><span>|</span><a href="#38314198">next</a><span>|</span><label class="collapse" for="c-38314320">[-]</label><label class="expand" for="c-38314320">[2 more]</label></div><br/><div class="children"><div class="content">I had implemented more-or-less this same concurrency scheme for an IPS&#x2F;DDoS prevention box ~10 years ago, running on Tilera architecture.  It was fast (batching + separating read &amp; write heads really does help a ton)... but not as fast as Tilera&#x27;s built-in intercore fabric.  It had some limitations but was basically a register store&#x2F;load to access and only like 1 or 2 cycles intercore latency.<p>(Aside, generic atomic operation pro-tip: don&#x27;t if you can help it. Load + local modify + store is always faster than atomic modify, if you can make the memory ordering work out.  And if you can&#x27;t do away with an atomic modify, batch your updates locally to issue fewer of them at least.)</div><br/><div id="38316861" class="c"><input type="checkbox" id="c-38316861" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#38314320">parent</a><span>|</span><a href="#38314198">next</a><span>|</span><label class="collapse" for="c-38316861">[-]</label><label class="expand" for="c-38316861">[1 more]</label></div><br/><div class="children"><div class="content">&gt; batch your updates locally to issue fewer of them at least<p>I don’t know why I never thought of this, brilliant!</div><br/></div></div></div></div><div id="38314198" class="c"><input type="checkbox" id="c-38314198" checked=""/><div class="controls bullet"><span class="by">convexstrictly</span><span>|</span><a href="#38314320">prev</a><span>|</span><a href="#38314078">next</a><span>|</span><label class="collapse" for="c-38314198">[-]</label><label class="expand" for="c-38314198">[1 more]</label></div><br/><div class="children"><div class="content">LMAX - How to Do 100K TPS at Less than 1ms Latency: Video<p><a href="https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;LMAX&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;LMAX&#x2F;</a></div><br/></div></div><div id="38314078" class="c"><input type="checkbox" id="c-38314078" checked=""/><div class="controls bullet"><span class="by">yafetn</span><span>|</span><a href="#38314198">prev</a><span>|</span><a href="#38314891">next</a><span>|</span><label class="collapse" for="c-38314078">[-]</label><label class="expand" for="c-38314078">[1 more]</label></div><br/><div class="children"><div class="content">Semi-related is the Aeron project: <a href="https:&#x2F;&#x2F;github.com&#x2F;real-logic&#x2F;aeron">https:&#x2F;&#x2F;github.com&#x2F;real-logic&#x2F;aeron</a></div><br/></div></div><div id="38314891" class="c"><input type="checkbox" id="c-38314891" checked=""/><div class="controls bullet"><span class="by">vinay_ys</span><span>|</span><a href="#38314078">prev</a><span>|</span><a href="#38314767">next</a><span>|</span><label class="collapse" for="c-38314891">[-]</label><label class="expand" for="c-38314891">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a whole new generation of engineers for whom this is new news. Enjoy!</div><br/></div></div><div id="38314767" class="c"><input type="checkbox" id="c-38314767" checked=""/><div class="controls bullet"><span class="by">jojohohanon</span><span>|</span><a href="#38314891">prev</a><span>|</span><a href="#38314178">next</a><span>|</span><label class="collapse" for="c-38314767">[-]</label><label class="expand" for="c-38314767">[1 more]</label></div><br/><div class="children"><div class="content">I came across this a few years back when numbly watching the dependencies scroll by during some Java install.<p>“Disruptor is a fairly presumptuous name for a package” I thought. So I looked into it. It fed musings and thought experiments for many walks to and from the T.  I love the balance between simplicity and subtlety in the design.<p>If i recall, it was a dependency for log4j, which makes sense for high volume logging.</div><br/></div></div><div id="38315456" class="c"><input type="checkbox" id="c-38315456" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#38314178">prev</a><span>|</span><label class="collapse" for="c-38315456">[-]</label><label class="expand" for="c-38315456">[16 more]</label></div><br/><div class="children"><div class="content">stupid question: how to build a trading system? anyone got a starter guide, resources?</div><br/><div id="38316195" class="c"><input type="checkbox" id="c-38316195" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#38315456">parent</a><span>|</span><a href="#38315740">next</a><span>|</span><label class="collapse" for="c-38316195">[-]</label><label class="expand" for="c-38316195">[12 more]</label></div><br/><div class="children"><div class="content">I built a PoC of a 5us trading system (guaranteed 5us response in every situation) for a brokerage house a long time ago, around the time of LMAX Disruptor. It was one man job and I had to start with nothing (they had no knowledge at all). Fun project and I learned a lot.<p>* full kernel bypass (I even implemented driver for the networking hardware)<p>* everything that could disrupt the application disabled (like SME interrupts, etc.) Memory mapped as huge buffers to prevent tlb lookup failures, etc.<p>* application consists of threads pinned to specified cores<p>* each thread on the path of market data to sending the order is never calling the operating system for anything. When not processing anything it is busy spinning.<p>* all memory preallocated carefully to have it pinned to the local core<p>* data flows from the networking hardware into one core and then passess through cores using disruptor, each core doing further processing and publishing signals to the next core<p>* the main insight was that rather than wait for market signals to then decide what to do, you can precalculate your responses up to and including the actual message to be sent to the exchange.</div><br/><div id="38316905" class="c"><input type="checkbox" id="c-38316905" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316195">parent</a><span>|</span><a href="#38316444">next</a><span>|</span><label class="collapse" for="c-38316905">[-]</label><label class="expand" for="c-38316905">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the main insight was that rather than wait for market signals to then decide what to do, you can precalculate your responses up to and including the actual message to be sent to the exchange.<p>I saw a talk about this dialed up to eleven: the entire processing occurred in a &quot;smart NIC&quot; instead of the CPU. The response would start getting sent even as the inbound packet was still being received. The go&#x2F;no-go decision was effectively just sending the final CRC bytes <i>correctly</i> or deliberately <i>incorrectly</i>, thus invalidating the outbound packet that was already 99% sent.<p>Before that talk I couldn&#x27;t figure out why there was a market for NICs with embedded FPGAs, CPUs and memory.<p>Day traders basically subsidised these things, and now they do efficient packet switching for large cloud providers.<p>Reminds me of how crypto-mining subsidised a lot of GPU development, and now we have 4K ray tracing and AIs thanks to that.</div><br/><div id="38316968" class="c"><input type="checkbox" id="c-38316968" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316905">parent</a><span>|</span><a href="#38316444">next</a><span>|</span><label class="collapse" for="c-38316968">[-]</label><label class="expand" for="c-38316968">[1 more]</label></div><br/><div class="children"><div class="content">Cool! I actually wasn&#x27;t aware about NICs with FPGAs on them. You learn something new every day on HN.<p>My solution wasn&#x27;t as fast and it could never do what you describe (start sending bytes before the packet was fully received). The market signal messages were actually batched together (usually one to 5), compressed with zlib and sent as a single multicast packet.</div><br/></div></div></div></div><div id="38316444" class="c"><input type="checkbox" id="c-38316444" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316195">parent</a><span>|</span><a href="#38316905">prev</a><span>|</span><a href="#38316471">next</a><span>|</span><label class="collapse" for="c-38316444">[-]</label><label class="expand" for="c-38316444">[1 more]</label></div><br/><div class="children"><div class="content">not gonna lie, i have to literally look up the meanings of half the words in your post lol, but you must have been in my position sometime. What did you have to learn in order to build this</div><br/></div></div><div id="38316471" class="c"><input type="checkbox" id="c-38316471" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316195">parent</a><span>|</span><a href="#38316444">prev</a><span>|</span><a href="#38315740">next</a><span>|</span><label class="collapse" for="c-38316471">[-]</label><label class="expand" for="c-38316471">[8 more]</label></div><br/><div class="children"><div class="content">what language do you think would be the backbone for such a system? C&#x2F;C++&#x2F;Golang or something high level like node.js&#x2F;Java</div><br/><div id="38316533" class="c"><input type="checkbox" id="c-38316533" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316471">parent</a><span>|</span><a href="#38315740">next</a><span>|</span><label class="collapse" for="c-38316533">[-]</label><label class="expand" for="c-38316533">[7 more]</label></div><br/><div class="children"><div class="content">Each to their own but if you read and understand the comment above they&#x27;re describing a dedicated OS for the task .. so think about what you&#x27;d choose to write a small task dedicated OS with.<p>Simple C is most likely, ASM is possible, a language such as OCaml generating C to hook into the low level buffers would be intriguing ... the list is long and largely determined by the experience preference of whoever tackles it.<p>The major features for performance are to allocate and manage all memory from the start .. determine your thresholds of performance and put everything required together on cold start so as to avoid any thrashing at runtime.</div><br/><div id="38316725" class="c"><input type="checkbox" id="c-38316725" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316533">parent</a><span>|</span><a href="#38315740">next</a><span>|</span><label class="collapse" for="c-38316725">[-]</label><label class="expand" for="c-38316725">[6 more]</label></div><br/><div class="children"><div class="content">You are surprisingly accurate.<p>I used combination of Common Lisp (SBCL), ANSI C and assembly (not much assembly, though, only very small pieces that I had trouble emitting other ways).<p>The main application was in Lisp, it would start up and set up the environment (using some low level code written in C&#x2F;assembly).<p>But everything on the path of the market signal to order would be highly optimised native machine code, but some of that code would be written in C and some of it would be compiled at runtime with Lisp.<p>Parsing the incoming multicast feed from the exchange was implemented with Lisp emitting super efficient machine code (almost no  function calls) based on a bunch of XML files describing the messages. I shamelessly stole the idea from the book Practical Common Lisp (really good if you want to get into Lisp).<p>Things like business rules would be compiled into decision trees using current market situation and decision trees would be reorganised, optimised and compiled into machine code and inserted into the processing path. Most of the time a very large decision tree with hundreds of complex decisions (for example, taking into account market volatility) could be distilled to just couple branching instructions. This decision tree compilation would happen after every market signal, up to 10 thousand times a second (the exchange had a basic tick of 1&#x2F;10000 of a second giving me guaranteed 100us before the next market signal).<p>Same with actual algorithms -- I wrote a small DSL for the traders and this DSL would be compiled with Lisp to machine an inserted into the processing path.<p>Some parts of the framework would be built with Lisp, too. It was easier for me to write a DSL and then compile it to machine than to write it in C.<p>If you want to understand one principle from all this is to look at all instructions and especially branches that you have between receiving the signal and emitting the order and try to figure out if you can eliminate it and if you can&#x27;t, try to find ways to do it ahead of time even if doing it ahead of time requires a lot more effort.</div><br/><div id="38316810" class="c"><input type="checkbox" id="c-38316810" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316725">parent</a><span>|</span><a href="#38317099">next</a><span>|</span><label class="collapse" for="c-38316810">[-]</label><label class="expand" for="c-38316810">[4 more]</label></div><br/><div class="children"><div class="content">Not my first rodeo :-)<p>I too made a real time hardware level trading system back in the day, on the back of building a multi channel seismic aquisition system with a custom RealtimeOS talking to a bunch of DSP cards that each sampled a trailing flotation cable that each had multiple microphones with the entire grid going toward building up a profile of the seafloor and layers underneath along with bobbing boat|cable cancelation, etc.<p>Very similar architectures in many ways - with rolling DSP filters in place of trading response algorithms .. etc.<p>Lisp -&gt; ASM or Lisp -&gt; C either way code generation from a higher language was a good way to get the heavy lifting done.</div><br/><div id="38316884" class="c"><input type="checkbox" id="c-38316884" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316810">parent</a><span>|</span><a href="#38316933">next</a><span>|</span><label class="collapse" for="c-38316884">[-]</label><label class="expand" for="c-38316884">[1 more]</label></div><br/><div class="children"><div class="content">Cool project!<p>I guess when different people try to achieve extreme low latency or efficiency, the solutions start to converge into small number of ideas.</div><br/></div></div><div id="38316933" class="c"><input type="checkbox" id="c-38316933" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316810">parent</a><span>|</span><a href="#38316884">prev</a><span>|</span><a href="#38317099">next</a><span>|</span><label class="collapse" for="c-38316933">[-]</label><label class="expand" for="c-38316933">[2 more]</label></div><br/><div class="children"><div class="content">what would you do if you wanna run all this on a web server instead? sorry if thats the wrong question. how does your system interact with say android or ios clients or a webapp with ui</div><br/><div id="38317125" class="c"><input type="checkbox" id="c-38317125" checked=""/><div class="controls bullet"><span class="by">onetimeuse92304</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316933">parent</a><span>|</span><a href="#38317099">next</a><span>|</span><label class="collapse" for="c-38317125">[-]</label><label class="expand" for="c-38317125">[1 more]</label></div><br/><div class="children"><div class="content">If you have a project that you want to see done, you will be more likely to succeed using some more traditional architecture.<p>What I described is chasing latency at all costs. The costs are hardware costs, maintainability costs, development costs, inefficiency (yes, a lot more CPU is used than what is needed just to run the critical path fast). This is very extreme situation and it would be very unlikely to be a good tradeoff for your application.<p>If you have a lot of clients connecting there are different tradeoffs to think about and different possible architectures to evaluate, but I can&#x27;t help you not knowing what your problem is.</div><br/></div></div></div></div></div></div><div id="38317099" class="c"><input type="checkbox" id="c-38317099" checked=""/><div class="controls bullet"><span class="by">waynesonfire</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38316725">parent</a><span>|</span><a href="#38316810">prev</a><span>|</span><a href="#38315740">next</a><span>|</span><label class="collapse" for="c-38317099">[-]</label><label class="expand" for="c-38317099">[1 more]</label></div><br/><div class="children"><div class="content">&gt; implemented with Lisp emitting super efficient machine code<p>I&#x27;m really intrigued by your usage of Lisp. It&#x27;s on my bucket list to learn and your post is very inspiring.<p>When you say Lisp was emitting machine code; are you referring to the machine code the Lisp compiler emitted for your Lisp application or was your Lisp application acting as a sort of JIT compiler and actually emitting machine code?<p>Maybe you can reference the section in Practical Common Lisp that introduces the idea?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38315740" class="c"><input type="checkbox" id="c-38315740" checked=""/><div class="controls bullet"><span class="by">cwalv</span><span>|</span><a href="#38315456">parent</a><span>|</span><a href="#38316195">prev</a><span>|</span><a href="#38316157">next</a><span>|</span><label class="collapse" for="c-38315740">[-]</label><label class="expand" for="c-38315740">[2 more]</label></div><br/><div class="children"><div class="content">Not a real system, obviously, but a high level overview of what it does: <a href="https:&#x2F;&#x2F;www.kalzumeus.com&#x2F;2015&#x2F;10&#x2F;30&#x2F;developing-in-stockfighter-with-no-trading-experience&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.kalzumeus.com&#x2F;2015&#x2F;10&#x2F;30&#x2F;developing-in-stockfigh...</a></div><br/><div id="38316465" class="c"><input type="checkbox" id="c-38316465" checked=""/><div class="controls bullet"><span class="by">vivzkestrel</span><span>|</span><a href="#38315456">root</a><span>|</span><a href="#38315740">parent</a><span>|</span><a href="#38316157">next</a><span>|</span><label class="collapse" for="c-38316465">[-]</label><label class="expand" for="c-38316465">[1 more]</label></div><br/><div class="children"><div class="content">thank you for sharing, it has a few code snippets here and there. Would you be aware of a course or something (Google didnt help) that teaches how to build one from the ground up</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>