<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715072455713" as="style"/><link rel="stylesheet" href="styles.css?v=1715072455713"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://go.dev/blog/chacha8rand?hn=1">Secure Randomness in Go 1.22</a> <span class="domain">(<a href="https://go.dev">go.dev</a>)</span></div><div class="subtext"><span>rsc</span> | <span>24 comments</span></div><br/><div><div id="40283441" class="c"><input type="checkbox" id="c-40283441" checked=""/><div class="controls bullet"><span class="by">nickcw</span><span>|</span><a href="#40283594">next</a><span>|</span><label class="collapse" for="c-40283441">[-]</label><label class="expand" for="c-40283441">[2 more]</label></div><br/><div class="children"><div class="content">From the article<p>&gt; Go aims to help developers write code that is secure by default. When we observe a common mistake with security consequences, we look for ways to reduce the risk of that mistake or eliminate it entirely. In this case, math&#x2F;rand’s global generator was far too predictable, leading to serious problems in a variety of contexts.<p>&gt; For example, when Go 1.20 deprecated math&#x2F;rand’s Read, we heard from developers who discovered (thanks to tooling pointing out use of deprecated functionality) they had been using it in places where crypto&#x2F;rand’s Read was definitely needed, like generating key material.<p>I made exactly this mistake in rclone. I refactored some code which was using the Read function from crypt&#x2F;rand and during the process the import got automatically changed (probably by goimports when mixing code which did use math&#x2F;rand) to math&#x2F;rand. So it changed from using a secure random number generator to a deterministic one rclone seeded with the time of day. I didn&#x27;t notice in the diffs :-( Hence<p><a href="https:&#x2F;&#x2F;www.cvedetails.com&#x2F;cve&#x2F;CVE-2020-28924&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cvedetails.com&#x2F;cve&#x2F;CVE-2020-28924&#x2F;</a><p>So this change gets a big :+1: from me.</div><br/><div id="40283561" class="c"><input type="checkbox" id="c-40283561" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40283441">parent</a><span>|</span><a href="#40283594">next</a><span>|</span><label class="collapse" for="c-40283561">[-]</label><label class="expand" for="c-40283561">[1 more]</label></div><br/><div class="children"><div class="content">Would not have happened in C# which uses distinct Random (and Random.Shared) as PRNG and RandomNumberGenerator[0] as CSPRNG even when mixing namespaces.<p>Also has corresponding analyzer rule if you want to enforce this project-wide[1].<p>[0] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.security.cryptography.randomnumbergenerator" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;api&#x2F;system.security...</a><p>[1] <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fundamentals&#x2F;code-analysis&#x2F;quality-rules&#x2F;ca5394" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fundamentals&#x2F;code-a...</a></div><br/></div></div></div></div><div id="40283594" class="c"><input type="checkbox" id="c-40283594" checked=""/><div class="controls bullet"><span class="by">barnabee</span><span>|</span><a href="#40283441">prev</a><span>|</span><a href="#40283463">next</a><span>|</span><label class="collapse" for="c-40283594">[-]</label><label class="expand" for="c-40283594">[1 more]</label></div><br/><div class="children"><div class="content">&gt; a lightly modified version of Daniel J. Bernstein’s ChaCha stream cipher. ChaCha is widely used in a 20-round form called ChaCha20, including in TLS and SSH. Jean-Philippe Aumasson’s paper “Too Much Crypto” argues persuasively that the 8-round form ChaCha8 is secure too (and it’s roughly 2.5X faster)<p>Call me paranoid but my mind immediately jumps to the question of whether this paper can be trusted or if it has been planted by a TLA to intentionally weaken crypto.<p>I don&#x27;t know Jean-Philippe, or much about them, but they seem to be both an experienced cryptographer and someone who has founded a company that is close to many government-adjacent organisations (UNHCR, banks, payment services, defence contractors—and that&#x27;s just from the home page [0]) and therefore could easily have been exposed to persuasive state actors.<p>Does anyone know more about the security of the 8-round form and whether we should be concerned?<p>[0] <a href="https:&#x2F;&#x2F;www.taurushq.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.taurushq.com&#x2F;</a></div><br/></div></div><div id="40283463" class="c"><input type="checkbox" id="c-40283463" checked=""/><div class="controls bullet"><span class="by">room271</span><span>|</span><a href="#40283594">prev</a><span>|</span><a href="#40273969">next</a><span>|</span><label class="collapse" for="c-40283463">[-]</label><label class="expand" for="c-40283463">[1 more]</label></div><br/><div class="children"><div class="content">Russell Cox consistently produces excellent technical blogs and proposals (and work). If you want to improve the clarity of your writing and thinking, he is a great place to start.</div><br/></div></div><div id="40273969" class="c"><input type="checkbox" id="c-40273969" checked=""/><div class="controls bullet"><span class="by">rsc</span><span>|</span><a href="#40283463">prev</a><span>|</span><a href="#40282898">next</a><span>|</span><label class="collapse" for="c-40273969">[-]</label><label class="expand" for="c-40273969">[1 more]</label></div><br/><div class="children"><div class="content">(This was posted last week by spacey at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40237491">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40237491</a> as well, but that post seems to have been incorrectly buried as a duplicate of <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40224864">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40224864</a>. The two go.dev blog posts are two in a series but quite different: this one is about efficient secure random number generator algorithms, while the earlier one was about Go API design.)</div><br/></div></div><div id="40282898" class="c"><input type="checkbox" id="c-40282898" checked=""/><div class="controls bullet"><span class="by">supakeen</span><span>|</span><a href="#40273969">prev</a><span>|</span><a href="#40282948">next</a><span>|</span><label class="collapse" for="c-40282898">[-]</label><label class="expand" for="c-40282898">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve often thought about why the default implementation of many randoms around programming languages is to use LSFRs, MTs, and other fast RNGs in the 2020s.<p>It seems to be better to err on the side of &#x27;people dont know if they want a PRNG or a CSPRNG&#x27; and switch the default to the latter with an explicit choice for the former for people that know what they need :)</div><br/><div id="40283514" class="c"><input type="checkbox" id="c-40283514" checked=""/><div class="controls bullet"><span class="by">gwd</span><span>|</span><a href="#40282898">parent</a><span>|</span><a href="#40283595">next</a><span>|</span><label class="collapse" for="c-40283514">[-]</label><label class="expand" for="c-40283514">[1 more]</label></div><br/><div class="children"><div class="content">Recently I started using a new golang library that generated random IDs for different components of a complex data structure.  My own use case had tens of thousands of components, and profiling revealed that a significant chunk of the time initializing the data structure was in crypto&#x2F;rand&#x27;s Read(), which on my Macbook was executing system calls.  Patching the library to use math&#x2F;rand&#x27;s Read() instead increased performance significantly.<p>In addition to math&#x2F;rand being faster, I was worried about exhausting the system&#x27;s entropy pool for no good reason: in this case, the only possible reason to have the ID&#x27;s be random would be to serialize and de-serialize the data structure, then add more components later; which I had no intention of doing.<p>Not sure exactly how the timing of the changes mentioned in this blog compare to my experience -- possibly I was using an  older version of the library, and this would make crypto&#x2F;rand basically indistinguishable from math&#x2F;rand, in which case, sure, why not. :-)</div><br/></div></div><div id="40283595" class="c"><input type="checkbox" id="c-40283595" checked=""/><div class="controls bullet"><span class="by">TimWolla</span><span>|</span><a href="#40282898">parent</a><span>|</span><a href="#40283514">prev</a><span>|</span><a href="#40282956">next</a><span>|</span><label class="collapse" for="c-40283595">[-]</label><label class="expand" for="c-40283595">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It seems to be better to err on the side of &#x27;people dont know if they want a PRNG or a CSPRNG&#x27; and switch the default to the latter with an explicit choice for the former for people that know what they need :)<p>That’s exactly what we did in PHP 8.2 [1] with the new object-oriented randomness API: If you as the developer don’t make an explicit choice for the random engine to use, you’ll get the CSPRNG.<p>Now unfortunately the hard part is convincing folks to migrate to the new API - or even from the global Mt19937 instance using mt_rand() to the CSPRNG using random_int() which is already available since 7.0.<p>[1] <a href="https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;8.2&#x2F;en.php#random_extension" rel="nofollow">https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;8.2&#x2F;en.php#random_extension</a></div><br/></div></div><div id="40282956" class="c"><input type="checkbox" id="c-40282956" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40282898">parent</a><span>|</span><a href="#40283595">prev</a><span>|</span><a href="#40282939">next</a><span>|</span><label class="collapse" for="c-40282956">[-]</label><label class="expand" for="c-40282956">[2 more]</label></div><br/><div class="children"><div class="content">One of the better arguments for using a CSPRNG (here, ChaCha8) is that they benchmark it within a factor of 2 of PCG.  The state is still comparatively large (64 bytes vs 16), but not nearly as bad as something like mt19937 or the old Go PRNG.  (If the CSPRNG was much much slower, which is generally true for CSPRNGs other than the reduced-round ChaCha variant, it becomes a less appealing default.)</div><br/><div id="40283428" class="c"><input type="checkbox" id="c-40283428" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#40282898">root</a><span>|</span><a href="#40282956">parent</a><span>|</span><a href="#40282939">next</a><span>|</span><label class="collapse" for="c-40283428">[-]</label><label class="expand" for="c-40283428">[1 more]</label></div><br/><div class="children"><div class="content">I know posting &quot;I agree&quot; is not generally welcomed on here, but ChaCha8 is really underappreciated as a MCMC&#x2F;general simulation random number generator. It&#x27;s fast, it&#x27;s pretty easy on cache, and it won&#x27;t bias your results, modulo future cryptanalysis.</div><br/></div></div></div></div><div id="40282939" class="c"><input type="checkbox" id="c-40282939" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#40282898">parent</a><span>|</span><a href="#40282956">prev</a><span>|</span><a href="#40282948">next</a><span>|</span><label class="collapse" for="c-40282939">[-]</label><label class="expand" for="c-40282939">[4 more]</label></div><br/><div class="children"><div class="content">Whats are other cases where you would need the former? I can only think of fixed seeding for things that need reproducible results (e.g tests, verifications).<p>I think theres another little force that pushes people towards the PRNG even when they don&#x27;t need seeding: CSPRNG api always includes an error you need to handle; in case the sys call fails or you run out of entropy.<p>I&#x27;m curious how often crpyto.Rand read fails? How much random do I have to read to exhaust the entropy of a modern system? I&#x27;ve never seen it fail over billions of requests (dd does fine too). Perhaps a Must&#x2F;panic style API default makes sense for most use-cases?<p>Edit to add: I took a look at the secrets package in python (<a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;secrets.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;secrets.html</a>) not a single mention of how it can throw. Just doesn&#x27;t happen in practice?</div><br/><div id="40283237" class="c"><input type="checkbox" id="c-40283237" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40282898">root</a><span>|</span><a href="#40282939">parent</a><span>|</span><a href="#40282966">next</a><span>|</span><label class="collapse" for="c-40283237">[-]</label><label class="expand" for="c-40283237">[2 more]</label></div><br/><div class="children"><div class="content">&gt; CSPRNG api always includes an error you need to handle; in case the sys call fails<p>A user-side CSPRNG — which is the point of adding a ChaCha8 PRNG to math&#x2F;rand — performs no syscall outside of seeding (unless it supports reseeding).<p>&gt; you run out of entropy.<p>Running out of entropy has never been a thing except in the fevered minds of linux kernel developers.</div><br/><div id="40283345" class="c"><input type="checkbox" id="c-40283345" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#40282898">root</a><span>|</span><a href="#40283237">parent</a><span>|</span><a href="#40282966">next</a><span>|</span><label class="collapse" for="c-40283345">[-]</label><label class="expand" for="c-40283345">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Running out of entropy has never been a thing except in the fevered minds of linux kernel developers.<p>Linux used user input and network jitter to generate random numbers, not a pure pseudo random number generator. For a perfectly  deterministic pseudo random number generator entropy is only required for seeding and even then you can avoid it if you have no problem with others reproducing the same chain of numbers.</div><br/></div></div></div></div><div id="40282966" class="c"><input type="checkbox" id="c-40282966" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40282898">root</a><span>|</span><a href="#40282939">parent</a><span>|</span><a href="#40283237">prev</a><span>|</span><a href="#40282948">next</a><span>|</span><label class="collapse" for="c-40282966">[-]</label><label class="expand" for="c-40282966">[1 more]</label></div><br/><div class="children"><div class="content">&gt; CSPRNG api always includes an error you need to handle (in case the sys call fails or you run out of entropy).<p>&gt; Perhaps a Must&#x2F;panic style API makes sense?<p>Yes, CSPRNGs APIs should be infallible.</div><br/></div></div></div></div></div></div><div id="40282948" class="c"><input type="checkbox" id="c-40282948" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#40282898">prev</a><span>|</span><a href="#40282974">next</a><span>|</span><label class="collapse" for="c-40282948">[-]</label><label class="expand" for="c-40282948">[6 more]</label></div><br/><div class="children"><div class="content">Even in the worst case benchmark the new strategy is only about half as slow as an insecure random number generator. However most benchmarks were much closer.<p>Go is doing the right balance between safety and performance for the standard library (and for the apps built on top of it). Hopefully other ecosystems follow suit.<p>If an application needs fast insecure random numbers - they should implement an app internal generator themselves. Having insecure randoms within easy reach is a footgun we can put away.</div><br/><div id="40282983" class="c"><input type="checkbox" id="c-40282983" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#40282948">parent</a><span>|</span><a href="#40282974">next</a><span>|</span><label class="collapse" for="c-40282983">[-]</label><label class="expand" for="c-40282983">[5 more]</label></div><br/><div class="children"><div class="content">Except this honestly seems worse.<p>Encouraging people to assume the &quot;random&quot; primitive is cryptographically secure is just encouraging bad practice. Making math&#x2F;rand&#x2F;v2 cryptographically secure <i>might</i> solve a problem, but it&#x27;s now making something which doesn&#x27;t <i>look</i> like it&#x27;s promises security &quot;okay&quot;.<p>`math&#x2F;rand` functions in general though do not have the convention of being cryptographically secure - changing them so they are is just making a change to make bad code do the right thing, potentially masking the fact that if we&#x27;re making that obvious mistake, what others are we also making?</div><br/><div id="40283012" class="c"><input type="checkbox" id="c-40283012" checked=""/><div class="controls bullet"><span class="by">nasretdinov</span><span>|</span><a href="#40282948">root</a><span>|</span><a href="#40282983">parent</a><span>|</span><a href="#40283041">next</a><span>|</span><label class="collapse" for="c-40283012">[-]</label><label class="expand" for="c-40283012">[2 more]</label></div><br/><div class="children"><div class="content">I think authors already did admit that introducing two rand packages was a mistake, so they&#x27;re now just correcting (most) programs automatically so that the existing packages become more secure, and raising awareness that math&#x2F;rand should no longer be used. I think it&#x27;s the best they can do in this situation</div><br/><div id="40283195" class="c"><input type="checkbox" id="c-40283195" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40282948">root</a><span>|</span><a href="#40283012">parent</a><span>|</span><a href="#40283041">next</a><span>|</span><label class="collapse" for="c-40283195">[-]</label><label class="expand" for="c-40283195">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re also choosing to make math&#x2F;rand&#x2F;v2 use the cryptographic generator.</div><br/></div></div></div></div><div id="40283041" class="c"><input type="checkbox" id="c-40283041" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#40282948">root</a><span>|</span><a href="#40282983">parent</a><span>|</span><a href="#40283012">prev</a><span>|</span><a href="#40282974">next</a><span>|</span><label class="collapse" for="c-40283041">[-]</label><label class="expand" for="c-40283041">[2 more]</label></div><br/><div class="children"><div class="content">The article explains this rationale very clearly:<p>&gt; Using Go 1.20, that mistake is a serious security problem that merits a detailed investigation to understand the damage. Where were the keys used? How were the keys exposed? Were other random outputs exposed that might allow an attacker to derive the keys? And so on. Using Go 1.22, that mistake is just a mistake.<p>It is not masking a mistake - you should be using a CSPRNG in security sensitive contexts, however if you screw up the collateral damage is much lower. You should be detecting this mistake with static analysis and code audits rather then observing  the random number generator on prod.</div><br/><div id="40283184" class="c"><input type="checkbox" id="c-40283184" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#40282948">root</a><span>|</span><a href="#40283041">parent</a><span>|</span><a href="#40282974">next</a><span>|</span><label class="collapse" for="c-40283184">[-]</label><label class="expand" for="c-40283184">[1 more]</label></div><br/><div class="children"><div class="content">Right but that&#x27;s the point. There&#x27;s genuine and useful uses for predictable random number generators in a lot of contexts. This would be, conventionally, what I&#x27;m reach to a math&#x2F;rand (or equivalent in other languages) for.<p>Whereas `crypto&#x2F;rand` is very obviously &quot;the CSPRNG function&quot;.<p>I understand the motivation, but if we&#x27;re trying to find bad code why not go further and just require people to put &#x2F;&#x2F;go:I AM NOT DOING CRYPTOGRAPHY at the top of files which use math&#x2F;rand or something?<p>It&#x27;s unloading the gun but not worrying that people are still pointing it around and clicking the trigger.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>