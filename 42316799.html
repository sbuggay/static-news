<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733389256624" as="style"/><link rel="stylesheet" href="styles.css?v=1733389256624"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jpcamara.com/2024/12/01/speeding-up-ruby.html">Speeding up Ruby by rewriting C in Ruby</a> <span class="domain">(<a href="https://jpcamara.com">jpcamara.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>103 comments</span></div><br/><div><div id="42326269" class="c"><input type="checkbox" id="c-42326269" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#42321605">next</a><span>|</span><label class="collapse" for="c-42326269">[-]</label><label class="expand" for="c-42326269">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Python was the slowest language in the benchmark, and yet at the same time it’s the most used language on Github as of October 2024.<p>Interesting that there seems to be a correlation between a language being slow and it being popular.</div><br/><div id="42326307" class="c"><input type="checkbox" id="c-42326307" checked=""/><div class="controls bullet"><span class="by">remedan</span><span>|</span><a href="#42326269">parent</a><span>|</span><a href="#42321605">next</a><span>|</span><label class="collapse" for="c-42326307">[-]</label><label class="expand" for="c-42326307">[1 more]</label></div><br/><div class="children"><div class="content">Does that correlation hold if you look at let&#x27;s say the top 20 popular languages?</div><br/></div></div></div></div><div id="42321605" class="c"><input type="checkbox" id="c-42321605" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#42326269">prev</a><span>|</span><a href="#42326065">next</a><span>|</span><label class="collapse" for="c-42321605">[-]</label><label class="expand" for="c-42321605">[3 more]</label></div><br/><div class="children"><div class="content">FTA: The loop example iterates 1 billion times, utilizing a nested loop:<p><pre><code>  u = ARGV[0].to_i       
  r = rand(10_000)                          
  a = Array.new(10_000, 0)                 
 
  (0...10_000).each do |i|                     
    (0...100_000).each do |j|               
      a[i] += j % u                     
    end
    a[i] += r                      
  end
 
  puts a[r]
</code></pre>
Weird benchmark. Hand-optimized, I guess this benchmark will spend over 99% of its time in the first two lines.<p>If you do liveliness analysis on array elements you’ll discover that it is possible to remove the entire outer loop, turning the program into:<p><pre><code>  u = ARGV[0].to_i       
  r = rand(10_000)                                         
                    
  (0...100_000).each do |j|               
    a += j % u                     
  end
  a += r                      
  
  puts a
</code></pre>
Are there compilers that do this kind of analysis?<p>Even though <i>u</i> isn’t known at compile time, that inner loop can be replaced by a few instructions, too, but that’s a more standard optimization that, I suspect, the likes of <i>clang</i> may be close to making.</div><br/><div id="42322200" class="c"><input type="checkbox" id="c-42322200" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42321605">parent</a><span>|</span><a href="#42323010">next</a><span>|</span><label class="collapse" for="c-42322200">[-]</label><label class="expand" for="c-42322200">[1 more]</label></div><br/><div class="children"><div class="content">Compilers don&#x27;t do liveness analysis on individual array elements. It&#x27;s too much data to keep track of and would probably only be useful in incorrect code like this.<p>I used to work on an AI compiler where liveness analysis of individual tensor elements actually <i>would</i> have been useful. We still didn&#x27;t do it because the compilation time&#x2F;memory requirements would be insane.</div><br/></div></div><div id="42323010" class="c"><input type="checkbox" id="c-42323010" checked=""/><div class="controls bullet"><span class="by">hatthew</span><span>|</span><a href="#42321605">parent</a><span>|</span><a href="#42322200">prev</a><span>|</span><a href="#42326065">next</a><span>|</span><label class="collapse" for="c-42323010">[-]</label><label class="expand" for="c-42323010">[1 more]</label></div><br/><div class="children"><div class="content">Closed form that works for most cases:<p><pre><code>    result = ((u * (u - 1)) &#x2F; 2 * (100000&#x2F;u)) + (100000%u * (100000%u - 1) &#x2F; 2) + r)</code></pre></div><br/></div></div></div></div><div id="42326065" class="c"><input type="checkbox" id="c-42326065" checked=""/><div class="controls bullet"><span class="by">block_dagger</span><span>|</span><a href="#42321605">prev</a><span>|</span><a href="#42321064">next</a><span>|</span><label class="collapse" for="c-42326065">[-]</label><label class="expand" for="c-42326065">[1 more]</label></div><br/><div class="children"><div class="content">After all these years, I still love Ruby. Thank you Matz!</div><br/></div></div><div id="42321064" class="c"><input type="checkbox" id="c-42321064" checked=""/><div class="controls bullet"><span class="by">Lammy</span><span>|</span><a href="#42326065">prev</a><span>|</span><a href="#42320830">next</a><span>|</span><label class="collapse" for="c-42321064">[-]</label><label class="expand" for="c-42321064">[4 more]</label></div><br/><div class="children"><div class="content">&gt; There was a PR to improve the performance of `Integer#succ` in early 2024, which helped me understand why anyone would ever use it: “We use `Integer#succ` when we rewrite loop methods in Ruby (e.g. `Integer#times` and `Array#each`) because `opt_succ (i = i.succ)` is faster to dispatch on the interpreter than `putobject 1; opt_plus (i += 1)`.”<p>I find myself using `#succ` most often for readability reasons, not just for performance. Here&#x27;s an example where I use it twice in my UUID library&#x27;s `#bytes` method to keep my brain in “bit slicing mode” when reading the code. I need to loop 16 times (`0xF.succ`) and then within that loop divide things by 256 (`0xFF.succ`): <a href="https:&#x2F;&#x2F;github.com&#x2F;okeeblow&#x2F;DistorteD&#x2F;blob&#x2F;ba48d10&#x2F;Globe%20Glitter&#x2F;lib&#x2F;globeglitter&#x2F;inner_spirit.rb#L215-L229">https:&#x2F;&#x2F;github.com&#x2F;okeeblow&#x2F;DistorteD&#x2F;blob&#x2F;ba48d10&#x2F;Globe%20G...</a></div><br/><div id="42322864" class="c"><input type="checkbox" id="c-42322864" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#42321064">parent</a><span>|</span><a href="#42320830">next</a><span>|</span><label class="collapse" for="c-42322864">[-]</label><label class="expand" for="c-42322864">[3 more]</label></div><br/><div class="children"><div class="content">Why do you find 0xF.succ better than 0x10 in this case?</div><br/><div id="42323034" class="c"><input type="checkbox" id="c-42323034" checked=""/><div class="controls bullet"><span class="by">Lammy</span><span>|</span><a href="#42321064">root</a><span>|</span><a href="#42322864">parent</a><span>|</span><a href="#42320830">next</a><span>|</span><label class="collapse" for="c-42323034">[-]</label><label class="expand" for="c-42323034">[2 more]</label></div><br/><div class="children"><div class="content">Because of how I&#x27;m used to thinking of the internal 128-bit UUID&#x2F;GUID value as a whole:<p><pre><code>  irb&gt; 0xFFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF.bit_length =&gt; 128</code></pre></div><br/><div id="42324890" class="c"><input type="checkbox" id="c-42324890" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#42321064">root</a><span>|</span><a href="#42323034">parent</a><span>|</span><a href="#42320830">next</a><span>|</span><label class="collapse" for="c-42324890">[-]</label><label class="expand" for="c-42324890">[1 more]</label></div><br/><div class="children"><div class="content">... 0 to 127 &lt; 128</div><br/></div></div></div></div></div></div></div></div><div id="42320830" class="c"><input type="checkbox" id="c-42320830" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#42321064">prev</a><span>|</span><a href="#42318237">next</a><span>|</span><label class="collapse" for="c-42320830">[-]</label><label class="expand" for="c-42320830">[9 more]</label></div><br/><div class="children"><div class="content">Woah, Ruby has become fast, like really fast. What&#x27;s even more impressive is TruffleRuby, damn!</div><br/><div id="42321187" class="c"><input type="checkbox" id="c-42321187" checked=""/><div class="controls bullet"><span class="by">knowitnone</span><span>|</span><a href="#42320830">parent</a><span>|</span><a href="#42321544">next</a><span>|</span><label class="collapse" for="c-42321187">[-]</label><label class="expand" for="c-42321187">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s Oracle <a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;truffleruby">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;truffleruby</a> Double Damn!</div><br/><div id="42323293" class="c"><input type="checkbox" id="c-42323293" checked=""/><div class="controls bullet"><span class="by">Twirrim</span><span>|</span><a href="#42320830">root</a><span>|</span><a href="#42321187">parent</a><span>|</span><a href="#42321544">next</a><span>|</span><label class="collapse" for="c-42323293">[-]</label><label class="expand" for="c-42323293">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s open source under Eclipse Public License version 2.0, GNU General Public License version 2, or GNU Lesser General Public License version 2.1.<p>Making it easily fork-able should Oracle choose to do something users dislike.</div><br/></div></div></div></div><div id="42321544" class="c"><input type="checkbox" id="c-42321544" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#42320830">parent</a><span>|</span><a href="#42321187">prev</a><span>|</span><a href="#42318237">next</a><span>|</span><label class="collapse" for="c-42321544">[-]</label><label class="expand" for="c-42321544">[6 more]</label></div><br/><div class="children"><div class="content">Note that Rails doesn&#x27;t work on Truffle and from what I understand, won&#x27;t anytime soon.<p>Which is disappointing since it has the highest likelihood of making the biggest impact to Ruby perf.</div><br/><div id="42321611" class="c"><input type="checkbox" id="c-42321611" checked=""/><div class="controls bullet"><span class="by">uamgeoalsk</span><span>|</span><a href="#42320830">root</a><span>|</span><a href="#42321544">parent</a><span>|</span><a href="#42318237">next</a><span>|</span><label class="collapse" for="c-42321611">[-]</label><label class="expand" for="c-42321611">[5 more]</label></div><br/><div class="children"><div class="content">Huh, what exactly doesn&#x27;t work? Their own readme says &quot;TruffleRuby runs Rails and is compatible with many gems, including C extensions.&quot; (<a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;truffleruby">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;truffleruby</a>)</div><br/><div id="42321752" class="c"><input type="checkbox" id="c-42321752" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#42320830">root</a><span>|</span><a href="#42321611">parent</a><span>|</span><a href="#42318237">next</a><span>|</span><label class="collapse" for="c-42321752">[-]</label><label class="expand" for="c-42321752">[4 more]</label></div><br/><div class="children"><div class="content">Truffle:<p><pre><code>  TruffleRuby is not 100% compatible with MRI 3.2 yet
</code></pre>
Rails:<p><pre><code>  Rails 8 will require Ruby 3.2.0 or newer
</code></pre>
<a href="https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;truffleruby">https:&#x2F;&#x2F;github.com&#x2F;oracle&#x2F;truffleruby</a><p><a href="https:&#x2F;&#x2F;rubyonrails.org&#x2F;2024&#x2F;9&#x2F;27&#x2F;this-week-in-rails" rel="nofollow">https:&#x2F;&#x2F;rubyonrails.org&#x2F;2024&#x2F;9&#x2F;27&#x2F;this-week-in-rails</a></div><br/><div id="42325037" class="c"><input type="checkbox" id="c-42325037" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42320830">root</a><span>|</span><a href="#42321752">parent</a><span>|</span><a href="#42322089">next</a><span>|</span><label class="collapse" for="c-42325037">[-]</label><label class="expand" for="c-42325037">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t mean Rails won&#x27;t run on TruffleRuby. TruffleRuby may not implement 100% of MRI 3.2, but that doesn&#x27;t mean it doesn&#x27;t implement all the parts that Rails needs.</div><br/></div></div><div id="42322089" class="c"><input type="checkbox" id="c-42322089" checked=""/><div class="controls bullet"><span class="by">hotpocket777</span><span>|</span><a href="#42320830">root</a><span>|</span><a href="#42321752">parent</a><span>|</span><a href="#42325037">prev</a><span>|</span><a href="#42318237">next</a><span>|</span><label class="collapse" for="c-42322089">[-]</label><label class="expand" for="c-42322089">[2 more]</label></div><br/><div class="children"><div class="content">Is it possible that those two statements taken together means truffleruby can run rails 8?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42318237" class="c"><input type="checkbox" id="c-42318237" checked=""/><div class="controls bullet"><span class="by">Imustaskforhelp</span><span>|</span><a href="#42320830">prev</a><span>|</span><a href="#42323506">next</a><span>|</span><label class="collapse" for="c-42318237">[-]</label><label class="expand" for="c-42318237">[1 more]</label></div><br/><div class="children"><div class="content">super interesting , actually I am also a contributer of the <a href="https:&#x2F;&#x2F;github.com&#x2F;bddicken&#x2F;languages">https:&#x2F;&#x2F;github.com&#x2F;bddicken&#x2F;languages</a> and after I had tried to create a lua approach , I started to think of truffleruby as it was mentioned somewhere but unfortunately when I had run the code of main.rb , there was virtually no significant difference b&#x2F;w truffleruby and main.rb  (sometimes normal ruby was faster than truffleruby)<p>I am not sure if the benchmark that you had provided showing the speed of truffleruby were made after the changes that you have made.<p>I would really appreciate it if I could verify the benchmark<p>and maybe try to add it to the main <a href="https:&#x2F;&#x2F;github.com&#x2F;bddicken&#x2F;languages">https:&#x2F;&#x2F;github.com&#x2F;bddicken&#x2F;languages</a> as a commit as well , because the truffleruby implementation actually is faster than the node js and goes close to bun or even golang for that matter which is nuts.<p>This was a fun post to skim through , definitely bookmarking it.</div><br/></div></div><div id="42323506" class="c"><input type="checkbox" id="c-42323506" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#42318237">prev</a><span>|</span><a href="#42318494">next</a><span>|</span><label class="collapse" for="c-42323506">[-]</label><label class="expand" for="c-42323506">[2 more]</label></div><br/><div class="children"><div class="content">The article refers to upcoming versions of Ruby.  For the curious, looks[1] like ruby 3.4.0 will be released this Christmas, and ruby 3.5.0 next Christmas.<p>Also, I&#x27;m wondering what effect Python&#x27;s minimal JIT [2] has coming for this type of loop.  Python 3.13 needs to be built with the JIT enabled, so it would be interesting if someone who has built it runs the benchmarks.<p>[1] <a href="https:&#x2F;&#x2F;www.ruby-lang.org&#x2F;en&#x2F;downloads&#x2F;releases&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.ruby-lang.org&#x2F;en&#x2F;downloads&#x2F;releases&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;drew.silcock.dev&#x2F;blog&#x2F;everything-you-need-to-know-about-python-3-13&#x2F;#jit-just-in-time-compiler" rel="nofollow">https:&#x2F;&#x2F;drew.silcock.dev&#x2F;blog&#x2F;everything-you-need-to-know-ab...</a></div><br/><div id="42325782" class="c"><input type="checkbox" id="c-42325782" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#42323506">parent</a><span>|</span><a href="#42318494">next</a><span>|</span><label class="collapse" for="c-42325782">[-]</label><label class="expand" for="c-42325782">[1 more]</label></div><br/><div class="children"><div class="content">Ruby is always released on Christmas, it&#x27;s a predictable and cute schedule.<p>But perf improvements can and do drop in point releases too, afair.</div><br/></div></div></div></div><div id="42318494" class="c"><input type="checkbox" id="c-42318494" checked=""/><div class="controls bullet"><span class="by">jeremy_k</span><span>|</span><a href="#42323506">prev</a><span>|</span><a href="#42324381">next</a><span>|</span><label class="collapse" for="c-42318494">[-]</label><label class="expand" for="c-42318494">[2 more]</label></div><br/><div class="children"><div class="content">Super interesting. I didn&#x27;t know that YJIT was written in Rust.</div><br/><div id="42325792" class="c"><input type="checkbox" id="c-42325792" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#42318494">parent</a><span>|</span><a href="#42324381">next</a><span>|</span><label class="collapse" for="c-42325792">[-]</label><label class="expand" for="c-42325792">[1 more]</label></div><br/><div class="children"><div class="content">It was initially written in C then ported to rust[0], which seems like it was a good idea. The downside is that it may not be enabled at build time if you don&#x27;t have the right toolchain&#x2F;platform, but that seems a good trade off.<p>0: <a href="https:&#x2F;&#x2F;shopify.engineering&#x2F;porting-yjit-ruby-compiler-to-rust" rel="nofollow">https:&#x2F;&#x2F;shopify.engineering&#x2F;porting-yjit-ruby-compiler-to-ru...</a></div><br/></div></div></div></div><div id="42324381" class="c"><input type="checkbox" id="c-42324381" checked=""/><div class="controls bullet"><span class="by">tgmatt</span><span>|</span><a href="#42318494">prev</a><span>|</span><a href="#42321783">next</a><span>|</span><label class="collapse" for="c-42324381">[-]</label><label class="expand" for="c-42324381">[1 more]</label></div><br/><div class="children"><div class="content">Another language comparison repo that&#x27;s been going for longer with more languages <a href="https:&#x2F;&#x2F;github.com&#x2F;niklas-heer&#x2F;speed-comparison">https:&#x2F;&#x2F;github.com&#x2F;niklas-heer&#x2F;speed-comparison</a>.</div><br/></div></div><div id="42321783" class="c"><input type="checkbox" id="c-42321783" checked=""/><div class="controls bullet"><span class="by">smileson2</span><span>|</span><a href="#42324381">prev</a><span>|</span><a href="#42321141">next</a><span>|</span><label class="collapse" for="c-42321783">[-]</label><label class="expand" for="c-42321783">[1 more]</label></div><br/><div class="children"><div class="content">Game changing for my advent of code solutions which look surprisingly similar</div><br/></div></div><div id="42321141" class="c"><input type="checkbox" id="c-42321141" checked=""/><div class="controls bullet"><span class="by">knowitnone</span><span>|</span><a href="#42321783">prev</a><span>|</span><a href="#42318189">next</a><span>|</span><label class="collapse" for="c-42321141">[-]</label><label class="expand" for="c-42321141">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a little surprised that Node is beating Deno. Interesting that Java would be faster than Kotlin since both run on jvm.</div><br/><div id="42326250" class="c"><input type="checkbox" id="c-42326250" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#42321141">parent</a><span>|</span><a href="#42322316">next</a><span>|</span><label class="collapse" for="c-42326250">[-]</label><label class="expand" for="c-42326250">[1 more]</label></div><br/><div class="children"><div class="content">“Faster”.<p>&gt; Ran each three times and used the lowest timing for each. Timings taken on an M3 Macbook pro with 16 gb RAM using the &#x2F;usr&#x2F;bin&#x2F;time command. Input value of 40 given to each.<p>Not even using JMH. I highly doubt accuracy of the “benchmark”.</div><br/></div></div><div id="42322316" class="c"><input type="checkbox" id="c-42322316" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42321141">parent</a><span>|</span><a href="#42326250">prev</a><span>|</span><a href="#42321259">next</a><span>|</span><label class="collapse" for="c-42322316">[-]</label><label class="expand" for="c-42322316">[2 more]</label></div><br/><div class="children"><div class="content">That is one of the differences between a platform systems language, and guest languages.<p>You only have to check the additional bytecode that gets generated, to work around the features not natively supported.</div><br/><div id="42326262" class="c"><input type="checkbox" id="c-42326262" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#42321141">root</a><span>|</span><a href="#42322316">parent</a><span>|</span><a href="#42321259">next</a><span>|</span><label class="collapse" for="c-42326262">[-]</label><label class="expand" for="c-42326262">[1 more]</label></div><br/><div class="children"><div class="content">Which difference? It is literally same code, it doesn’t even use any Kotlin std goodies.</div><br/></div></div></div></div><div id="42321259" class="c"><input type="checkbox" id="c-42321259" checked=""/><div class="controls bullet"><span class="by">entropicdrifter</span><span>|</span><a href="#42321141">parent</a><span>|</span><a href="#42322316">prev</a><span>|</span><a href="#42318189">next</a><span>|</span><label class="collapse" for="c-42321259">[-]</label><label class="expand" for="c-42321259">[1 more]</label></div><br/><div class="children"><div class="content">I mean, the JVM&#x27;s been optimized specifically for Java since the Bronze Ages at this point, it&#x27;s not <i>that</i> surprising</div><br/></div></div></div></div><div id="42318189" class="c"><input type="checkbox" id="c-42318189" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#42321141">prev</a><span>|</span><a href="#42319006">next</a><span>|</span><label class="collapse" for="c-42318189">[-]</label><label class="expand" for="c-42318189">[7 more]</label></div><br/><div class="children"><div class="content">&gt;This got me thinking that it would be interesting to see a kind of “YJIT standard library” emerge, where core ruby functionality run in C could be swapped out for Ruby implementations for use by people using YJIT.<p>This actually makes me feel sad because it reminded me of Chris Seaton. The idea isn&#x27;t new and Chris has been promoting it during his time working on TruffleRuby. I think the idea goes back even further to Rubinius.<p>It is also nice to see TruffleRuby being very fast and YJIT still has lots of headroom to grow. I remember one obstacle with it running rails was memory usage. I wonder if that is still the case.</div><br/><div id="42326154" class="c"><input type="checkbox" id="c-42326154" checked=""/><div class="controls bullet"><span class="by">Lio</span><span>|</span><a href="#42318189">parent</a><span>|</span><a href="#42318388">next</a><span>|</span><label class="collapse" for="c-42326154">[-]</label><label class="expand" for="c-42326154">[1 more]</label></div><br/><div class="children"><div class="content">I think jRuby takes a similar approach.<p>It’s possible to write gems which will use underlying C on MRI or Java when running on jRuby.<p>It would be interesting to know if a “pure” would also help jRuby too.</div><br/></div></div><div id="42318388" class="c"><input type="checkbox" id="c-42318388" checked=""/><div class="controls bullet"><span class="by">Asmod4n</span><span>|</span><a href="#42318189">parent</a><span>|</span><a href="#42326154">prev</a><span>|</span><a href="#42322445">next</a><span>|</span><label class="collapse" for="c-42318388">[-]</label><label class="expand" for="c-42318388">[2 more]</label></div><br/><div class="children"><div class="content">One of the amazing things truffle ruby does is handle c extensions like ruby code, meaning C is interpreted and not compiled in a traditional sense.<p>This makes way for jitting c code to make it way faster than the author has written it.</div><br/><div id="42319199" class="c"><input type="checkbox" id="c-42319199" checked=""/><div class="controls bullet"><span class="by">pantulis</span><span>|</span><a href="#42318189">root</a><span>|</span><a href="#42318388">parent</a><span>|</span><a href="#42322445">next</a><span>|</span><label class="collapse" for="c-42319199">[-]</label><label class="expand" for="c-42319199">[1 more]</label></div><br/><div class="children"><div class="content">Amazing indeed!</div><br/></div></div></div></div><div id="42322445" class="c"><input type="checkbox" id="c-42322445" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#42318189">parent</a><span>|</span><a href="#42318388">prev</a><span>|</span><a href="#42322905">next</a><span>|</span><label class="collapse" for="c-42322445">[-]</label><label class="expand" for="c-42322445">[1 more]</label></div><br/><div class="children"><div class="content">Yup, Rubinius was probably the most widely known implementation of Ruby&#x27;s standard library in Ruby. Too bad it was slower than MRI.</div><br/></div></div><div id="42322905" class="c"><input type="checkbox" id="c-42322905" checked=""/><div class="controls bullet"><span class="by">e12e</span><span>|</span><a href="#42318189">parent</a><span>|</span><a href="#42322445">prev</a><span>|</span><a href="#42319449">next</a><span>|</span><label class="collapse" for="c-42322905">[-]</label><label class="expand" for="c-42322905">[1 more]</label></div><br/><div class="children"><div class="content">I thought maybe mruby had a mostly ruby stdlib - but I guess it&#x27;s c ported over from mri?</div><br/></div></div></div></div><div id="42319006" class="c"><input type="checkbox" id="c-42319006" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42318189">prev</a><span>|</span><a href="#42319054">next</a><span>|</span><label class="collapse" for="c-42319006">[-]</label><label class="expand" for="c-42319006">[13 more]</label></div><br/><div class="children"><div class="content">&quot;In most ways, these types of benchmarks are meaningless. Python was the slowest language in the benchmark, and yet at the same time it’s the most used language on Github as of October 2024.&quot;<p>First, this indicates some sort of deep confusion about the purpose of benchmarks in the first place. Benchmarks are performance tests, not popularity tests. And I don&#x27;t think I&#x27;m just jumping on a bit of bad wording, because I see this idea in its various forms a lot poking out in a lot of conversations. Python is popular because there are many aspects to it, among which is the fact that yes, it really is a rather slow language, but the positives <i>outweigh</i> it for many purposes. They don&#x27;t <i>cancel</i> it. Python&#x27;s other positive aspects do not speed it up; indeed, they&#x27;re actually critically tied to why it is slow in the first place. If they were not, Python would not be slow. It has had a lot of work done on it over the years, after all.<p>Secondly, I think people sort of chant &quot;microbenchmarks are <i>useless</i>&quot;, but they aren&#x27;t <i>useless</i>. I find that microbenchmark actually represents some fairly realistic representation of the relative performance of those various languages. What they are not is totally determinative. You can&#x27;t divide one language&#x27;s microbenchmark on this test by another to get a &quot;Python is 160x slower than C&quot;. This is, in fact, not an accurate assessment; if you want a single unified number, 40-50 is much closer. But &quot;useless&quot; is <i>way</i> too strong. No language is so wonderful on all other dimensions that it can have something as basic as a function call be dozens of times slower than some other language and yet keep up with that other language in general. (Assuming both languages have had production-quality optimizations applied to them and one of them isn&#x27;t some very very young language.) It is a real fact about these languages, it is not a huge outlier, and it is a problem I&#x27;ve encountered in real codebases before when I needed to literally optimize out function calls in a dynamic scripting language to speed up certain code to acceptable levels, because function calls in dynamic scripting languages really are expensive in a way that really can matter. It shouldn&#x27;t be overestimated and used to derive silly &quot;x times faster&#x2F;slower&quot; values, but at the same time, if you&#x27;re dismissing these sorts of things, you&#x27;re throwing away real data. There are no languages that are just as fast as C, except gee golly they just happen to have this one thing where function calls are 1000 times slower for no reason even though everything else is C-speed. These performance differences are reasonably correlated.</div><br/><div id="42319674" class="c"><input type="checkbox" id="c-42319674" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#42319006">parent</a><span>|</span><a href="#42319942">next</a><span>|</span><label class="collapse" for="c-42319674">[-]</label><label class="expand" for="c-42319674">[8 more]</label></div><br/><div class="children"><div class="content">&gt; First, this indicates some sort of deep confusion about the purpose of benchmarks in the first place. Benchmarks are performance tests, not popularity tests.<p>I don&#x27;t think it indicates a deep confusion.  I think it leaves a simple point unsaid because it&#x27;s so strongly implied (related to what you say):<p>Python may be very low in benchmarks, but clearly it has <i>acceptable performance</i> for a very large subset of applications.  As a result, a whole lot of us can ignore the benchmarks.<p>Even in domains where one would have shuddered at this before.  My students are launching a satellite into low earth orbit that has its primary flight computer running python.  Yes, sometimes this does waste a few hundred milliseconds and it wastes several milliwatts on average.  But even in the constrained environment of a tiny microcontroller in low earth orbit, language performance doesn&#x27;t really matter to us.<p>We wouldn&#x27;t pay any kind of cost (financial or giving up any features) to make it 10x better.</div><br/><div id="42325869" class="c"><input type="checkbox" id="c-42325869" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#42319006">root</a><span>|</span><a href="#42319674">parent</a><span>|</span><a href="#42321899">next</a><span>|</span><label class="collapse" for="c-42325869">[-]</label><label class="expand" for="c-42325869">[2 more]</label></div><br/><div class="children"><div class="content">&gt; My students are launching a satellite into low earth orbit that has its primary flight computer running python. Yes, sometimes this does waste a few hundred milliseconds<p>Never mind performance, would it not be good to at least machine check <i>some</i> static properties? 
A dynamic language is not a good choice for anything mission critical IMHO.</div><br/><div id="42326278" class="c"><input type="checkbox" id="c-42326278" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#42319006">root</a><span>|</span><a href="#42325869">parent</a><span>|</span><a href="#42321899">next</a><span>|</span><label class="collapse" for="c-42326278">[-]</label><label class="expand" for="c-42326278">[1 more]</label></div><br/><div class="children"><div class="content">Python has had since Mypy and Pyright since forever.</div><br/></div></div></div></div><div id="42321899" class="c"><input type="checkbox" id="c-42321899" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42319006">root</a><span>|</span><a href="#42319674">parent</a><span>|</span><a href="#42325869">prev</a><span>|</span><a href="#42320737">next</a><span>|</span><label class="collapse" for="c-42321899">[-]</label><label class="expand" for="c-42321899">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t jump on it except for the number of times I&#x27;ve been discussing this online and people completely seriously counter &quot;Python is a fairly slow language&quot; with &quot;But it&#x27;s popular!&quot;<p>Fuzzy one-dimensional thinking that classifies languages on a &quot;good&quot; and &quot;bad&quot; axis is quite endemic in this industry. And for those people, you can counter &quot;X is slow&quot; with &quot;X has good library support&quot;, and disprove &quot;X lacks good tooling&quot; with &quot;But X has a good type system&quot;, because all they hear is that you said something is &quot;good&quot; but they have a reason why it&#x27;s &quot;bad&quot;, or vice versa.<p>Keep an eye out for it.</div><br/></div></div><div id="42320737" class="c"><input type="checkbox" id="c-42320737" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319006">root</a><span>|</span><a href="#42319674">parent</a><span>|</span><a href="#42321899">prev</a><span>|</span><a href="#42320696">next</a><span>|</span><label class="collapse" for="c-42320737">[-]</label><label class="expand" for="c-42320737">[1 more]</label></div><br/><div class="children"><div class="content"><i>otoh</i> When performance doesn&#x27;t matter, it doesn&#x27;t matter.<p><i>otoh</i> When the title is &quot;Speeding up Ruby&quot; we are kind-of presuming it matters.</div><br/></div></div><div id="42320696" class="c"><input type="checkbox" id="c-42320696" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42319006">root</a><span>|</span><a href="#42319674">parent</a><span>|</span><a href="#42320737">prev</a><span>|</span><a href="#42319942">next</a><span>|</span><label class="collapse" for="c-42320696">[-]</label><label class="expand" for="c-42320696">[3 more]</label></div><br/><div class="children"><div class="content">&quot;My students&quot; - so there&#x27;s really nothing on the line except a grade then, yeah? That&#x27;s why you wouldn&#x27;t pay any cost to make it 10x better, because there&#x27;s no catastrophic consequence if it fails. But sometimes wasting a few milliwatts on average is the difference between success and failure.<p>I&#x27;ve built an autonomous drone using Matlab. It worked but it was a research project, so when it came down to making the thing real and putting our reputation on the line, we couldn&#x27;t keep going down that route -- we couldn&#x27;t afford the interpreter overhead, the GC pauses, and all the other nonsense. That aircraft was designed to be as efficient as possible, so we could literally measure the inefficiency from the choice of language in terms of how much it cost in extra battery weight and therefore decreased range.<p>If you can afford that, great, you have the freedom to run your satellite in whatever language. If not, then yeah you&#x27;re going to choose a different language if it means extra performance, more runtime, greater range, etc.</div><br/><div id="42322267" class="c"><input type="checkbox" id="c-42322267" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#42319006">root</a><span>|</span><a href="#42320696">parent</a><span>|</span><a href="#42319942">next</a><span>|</span><label class="collapse" for="c-42322267">[-]</label><label class="expand" for="c-42322267">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;My students&quot; - so there&#x27;s really nothing on the line except a grade then, yeah? That&#x27;s why you wouldn&#x27;t pay any cost to make it 10x better, because there&#x27;s no catastrophic consequence if it fails. But sometimes wasting a few milliwatts on average is the difference between success and failure.<p>Years of effort from a large team is worth something, as is the tens of thousands of dollars we&#x27;re spending.  We expect a return on that investment of data and mission success.  We&#x27;re spending a lot of money to improve odds of success.<p>But even in this power constrained application, a few milliwatts is nothing.  (Nearly half the time, it&#x27;s literally nothing, because we&#x27;d have to use power to run heaters anyways.  Most of the rest of the time, we&#x27;re in the sun, so there&#x27;s a lot of power around, too).  The marginal benefit to saving a milliwatt is zero, so unless the marginal cost is also zero we&#x27;re not doing it.<p>&gt; That aircraft was designed to be as efficient as possible, so we could literally measure the inefficiency from the choice of language in terms of how much it cost in extra battery weight and therefore decreased range<p>If this is a rotorcraft of some sort, that seems silly.  It&#x27;s hard to waste enough power to be more than rounding error compared to what large brushless motors take.</div><br/><div id="42324536" class="c"><input type="checkbox" id="c-42324536" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42319006">root</a><span>|</span><a href="#42322267">parent</a><span>|</span><a href="#42319942">next</a><span>|</span><label class="collapse" for="c-42324536">[-]</label><label class="expand" for="c-42324536">[1 more]</label></div><br/><div class="children"><div class="content">If you have enough power from the sun and enough compute, are you really that resource constrained?<p>Let me ask you, why do you think most real-time mission critical projects are not typically done in Python?<p>&gt; If this is a rotorcraft of some sort, that seems silly. It&#x27;s hard to waste enough power to be more than rounding error compared to what large brushless motors take.<p>It was a glider trying to fly as long as possible, so no motors, no solar power either. It got to the point that we could not even execute the motion planner fast enough in Matlab given the performance demands of the craft, we had to resort to Mex, and at that point we might as well have been writing in C. Which we did.</div><br/></div></div></div></div></div></div></div></div><div id="42319942" class="c"><input type="checkbox" id="c-42319942" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319006">parent</a><span>|</span><a href="#42319674">prev</a><span>|</span><a href="#42323997">next</a><span>|</span><label class="collapse" for="c-42319942">[-]</label><label class="expand" for="c-42319942">[1 more]</label></div><br/><div class="children"><div class="content">&gt; people sort of chant &quot;microbenchmarks are useless&quot;, but they aren&#x27;t useless.<p>They might be !<p>(They aren&#x27;t necessarily useless. It depends. It depends what one is looking for. It depends <i>etc etc</i>)<p>&gt; You can&#x27;t divide one language&#x27;s microbenchmark on this test by another to get a &quot;Python is 160x slower than C&quot;.<p>Sure you can !<p><a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;performance&#x2F;comparable.html#geometric-mean" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;...</a><p>— and —<p>Table 4, page 139<p><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3687997.3695638" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3687997.3695638</a><p>— and then one has — &quot;<i>[A]</i> Python is 160x slower than C&quot; not &quot;<i>[THE]</i> Python is 160x slower than C&quot;.<p>Something multiple and tentative not something singular and definitive.</div><br/></div></div><div id="42323997" class="c"><input type="checkbox" id="c-42323997" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42319006">parent</a><span>|</span><a href="#42319942">prev</a><span>|</span><a href="#42319576">next</a><span>|</span><label class="collapse" for="c-42323997">[-]</label><label class="expand" for="c-42323997">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Benchmarks are performance tests, not popularity tests.<p>But presumably they&#x27;re meant to test something that matters. And the popularity suggests that what&#x27;s being tested in this case doesn&#x27;t.<p>&gt; But &quot;useless&quot; is way too strong. No language is so wonderful on all other dimensions that it can have something as basic as a function call be dozens of times slower than some other language and yet keep up with that other language in general.<p>And yet Python does keep up with C in general. You might object that when a Python-based system outperforms a C-based system it&#x27;s not running the same algorithm, or it&#x27;s not really Python, and that would be technically true, but seemingly not in a way that matters.<p>&gt; if you&#x27;re dismissing these sorts of things, you&#x27;re throwing away real data<p>Everything is data. The most important part of programming is often ignoring the things that aren&#x27;t important.</div><br/></div></div><div id="42319576" class="c"><input type="checkbox" id="c-42319576" checked=""/><div class="controls bullet"><span class="by">chikere232</span><span>|</span><a href="#42319006">parent</a><span>|</span><a href="#42323997">prev</a><span>|</span><a href="#42319447">next</a><span>|</span><label class="collapse" for="c-42319576">[-]</label><label class="expand" for="c-42319576">[1 more]</label></div><br/><div class="children"><div class="content">very true.<p>Also, for a lot of the areas where languages like python or ruby aren&#x27;t great choices because of performance, they would <i>also</i> not be great choices because of the cost of maintaining untyped code, or in python&#x27;s case the cost of maintaining code in a language that keeps making breaking changes in minor versions.<p>Script with scripting languages, build other things in other languages</div><br/></div></div></div></div><div id="42319054" class="c"><input type="checkbox" id="c-42319054" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#42319006">prev</a><span>|</span><a href="#42319529">next</a><span>|</span><label class="collapse" for="c-42319054">[-]</label><label class="expand" for="c-42319054">[3 more]</label></div><br/><div class="children"><div class="content">It seems like it&#x27;s been a while since I&#x27;ve seen one of these language benchmark things.<p><a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;...</a> seems like the latest iteration of what used to be a pretty popular one, now with fewer languages and more self-deprecation.</div><br/><div id="42319806" class="c"><input type="checkbox" id="c-42319806" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319054">parent</a><span>|</span><a href="#42319456">next</a><span>|</span><label class="collapse" for="c-42319806">[-]</label><label class="expand" for="c-42319806">[1 more]</label></div><br/><div class="children"><div class="content">&gt; fewer languages<p>Maybe you&#x27;ve only noticed the dozen in-your-face on the home page?<p>The charts have shown ~27 for a decade or so.<p>There&#x27;s another half-dozen more in the site map.</div><br/></div></div></div></div><div id="42319529" class="c"><input type="checkbox" id="c-42319529" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319054">prev</a><span>|</span><a href="#42319802">next</a><span>|</span><label class="collapse" for="c-42319529">[-]</label><label class="expand" for="c-42319529">[11 more]</label></div><br/><div class="children"><div class="content">&gt; a fun visualization of each language’s performance<p>The effect is similar to dragging a string past a cat: complete distraction — unable to avoid focusing on the movement — unable to extract any information from the movement.<p>To understand the measurements, cover the &quot;fun visualization&quot; and read the numbers in the single column data table.<p>(Unfortunately we aren&#x27;t able to scan down the column of numbers, because the language implementation name is shown first.)<p>Previously: &lt;blink&gt;<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;blink_element" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;blink_elem...</a></div><br/><div id="42319606" class="c"><input type="checkbox" id="c-42319606" checked=""/><div class="controls bullet"><span class="by">chikere232</span><span>|</span><a href="#42319529">parent</a><span>|</span><a href="#42321509">next</a><span>|</span><label class="collapse" for="c-42319606">[-]</label><label class="expand" for="c-42319606">[9 more]</label></div><br/><div class="children"><div class="content">It does visualise how big the difference is though</div><br/><div id="42319656" class="c"><input type="checkbox" id="c-42319656" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319529">root</a><span>|</span><a href="#42319606">parent</a><span>|</span><a href="#42321509">next</a><span>|</span><label class="collapse" for="c-42319656">[-]</label><label class="expand" for="c-42319656">[8 more]</label></div><br/><div class="children"><div class="content">Cover up the single column of lang&#x2F;secs and then try to read how big the difference is between java and php from the moving circles.<p>You would have no problem doing that with a [<i>typo</i> histogram should say bar chart].</div><br/><div id="42320217" class="c"><input type="checkbox" id="c-42320217" checked=""/><div class="controls bullet"><span class="by">MeetingsBrowser</span><span>|</span><a href="#42319529">root</a><span>|</span><a href="#42319656">parent</a><span>|</span><a href="#42320214">prev</a><span>|</span><a href="#42321686">next</a><span>|</span><label class="collapse" for="c-42320217">[-]</label><label class="expand" for="c-42320217">[4 more]</label></div><br/><div class="children"><div class="content">Cover the labels on the histogram and try to read how big the difference is between java and php....</div><br/><div id="42320397" class="c"><input type="checkbox" id="c-42320397" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319529">root</a><span>|</span><a href="#42320217">parent</a><span>|</span><a href="#42321686">next</a><span>|</span><label class="collapse" for="c-42320397">[-]</label><label class="expand" for="c-42320397">[3 more]</label></div><br/><div class="children"><div class="content">We can read the relative difference from the length of the bars because the bars are stable.</div><br/><div id="42320906" class="c"><input type="checkbox" id="c-42320906" checked=""/><div class="controls bullet"><span class="by">MeetingsBrowser</span><span>|</span><a href="#42319529">root</a><span>|</span><a href="#42320397">parent</a><span>|</span><a href="#42321686">next</a><span>|</span><label class="collapse" for="c-42320906">[-]</label><label class="expand" for="c-42320906">[2 more]</label></div><br/><div class="children"><div class="content">I can see the relative difference in speed between the two balls.</div><br/><div id="42321154" class="c"><input type="checkbox" id="c-42321154" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319529">root</a><span>|</span><a href="#42320906">parent</a><span>|</span><a href="#42321686">next</a><span>|</span><label class="collapse" for="c-42321154">[-]</label><label class="expand" for="c-42321154">[1 more]</label></div><br/><div class="children"><div class="content">&quot;The first principle is that you must not fool yourself and you are the easiest person to fool.&quot;<p>:-)</div><br/></div></div></div></div></div></div></div></div><div id="42321686" class="c"><input type="checkbox" id="c-42321686" checked=""/><div class="controls bullet"><span class="by">chikere232</span><span>|</span><a href="#42319529">root</a><span>|</span><a href="#42319656">parent</a><span>|</span><a href="#42320217">prev</a><span>|</span><a href="#42321509">next</a><span>|</span><label class="collapse" for="c-42321686">[-]</label><label class="expand" for="c-42321686">[2 more]</label></div><br/><div class="children"><div class="content">PHP looks much slower</div><br/><div id="42322681" class="c"><input type="checkbox" id="c-42322681" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319529">root</a><span>|</span><a href="#42321686">parent</a><span>|</span><a href="#42321509">next</a><span>|</span><label class="collapse" for="c-42322681">[-]</label><label class="expand" for="c-42322681">[1 more]</label></div><br/><div class="children"><div class="content">The question is: How much slower?<p>We could try to count how many times the java circle crosses left-to-right and right-to-left, in the time it takes for the PHP circle to cross left-to-right once.<p>That&#x27;s error prone but should be approximately correct after a couple of attempts.<p>That&#x27;s work we&#x27;re forced to do because the &quot;fun visualization&quot; is uninformative.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42319802" class="c"><input type="checkbox" id="c-42319802" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#42319529">prev</a><span>|</span><a href="#42322293">next</a><span>|</span><label class="collapse" for="c-42319802">[-]</label><label class="expand" for="c-42319802">[15 more]</label></div><br/><div class="children"><div class="content">Dart - I see it mentioned (and perf looks impressive), but is it widely adopted?<p>Also, would have loved to see LuaJIT (interpreted lang) &amp; Crystal (static Ruby like language) included just for comparison sake.</div><br/><div id="42319957" class="c"><input type="checkbox" id="c-42319957" checked=""/><div class="controls bullet"><span class="by">suby</span><span>|</span><a href="#42319802">parent</a><span>|</span><a href="#42320733">next</a><span>|</span><label class="collapse" for="c-42319957">[-]</label><label class="expand" for="c-42319957">[9 more]</label></div><br/><div class="children"><div class="content">It looks like a more complete breakdown is here. Crystal ranks just below Dart at 0.5413 (Dart was 0.5295). Luajit was 0.8056. I&#x27;m surprised Luajit does worse than Dart. Actually I am surprised Dart is beating out languages like C# too.<p><a href="http:&#x2F;&#x2F;benjdd.com&#x2F;languages2" rel="nofollow">http:&#x2F;&#x2F;benjdd.com&#x2F;languages2</a></div><br/><div id="42320512" class="c"><input type="checkbox" id="c-42320512" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42319957">parent</a><span>|</span><a href="#42320142">next</a><span>|</span><label class="collapse" for="c-42320512">[-]</label><label class="expand" for="c-42320512">[1 more]</label></div><br/><div class="children"><div class="content">Dart&#x27;s VM was designed by the team (I think not just the one guy, but maybe I&#x27;m wrong on that and it really is just Lars Bak) that designed most of the truly notable VMs that have ever existed: Self, Smalltalk Strongtalk, Java Hotspot, and JavaScript V8. It also features an ahead-of-time compiler mode in addition to a world-class JIT and interpreter, allowing for hot reload during development.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Lars_Bak_(computer_programmer)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Lars_Bak_(computer_programme...</a><p>It was stuck with a bad rep for being the language that was never going to replace JavaScript in the browser, and then was merely a transpiler no one was going to use, before it found a new life as the language for Flutter, which has driven a lot of its syntax and semantics improvements since, with built-in VM support for extremely efficient object templating (used by the reactive UI framework).</div><br/></div></div><div id="42320142" class="c"><input type="checkbox" id="c-42320142" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42319957">parent</a><span>|</span><a href="#42320512">prev</a><span>|</span><a href="#42320952">next</a><span>|</span><label class="collapse" for="c-42320142">[-]</label><label class="expand" for="c-42320142">[1 more]</label></div><br/><div class="children"><div class="content">Maybe that dozen lines of code isn&#x27;t sufficient to characterize performance differences?<p>Nearly 25 years ago, nested loops and fibs.<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20010424150558&#x2F;http:&#x2F;&#x2F;www.bagley.org&#x2F;~doug&#x2F;shootout&#x2F;bench&#x2F;nestedloop&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20010424150558&#x2F;http:&#x2F;&#x2F;www.bagley...</a><p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20010124092800&#x2F;http:&#x2F;&#x2F;www.bagley.org&#x2F;~doug&#x2F;shootout&#x2F;bench&#x2F;fibo&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20010124092800&#x2F;http:&#x2F;&#x2F;www.bagley...</a><p>It&#x27;s been a long time since the benchmarks game showed those.</div><br/></div></div><div id="42320952" class="c"><input type="checkbox" id="c-42320952" checked=""/><div class="controls bullet"><span class="by">lern_too_spel</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42319957">parent</a><span>|</span><a href="#42320142">prev</a><span>|</span><a href="#42321306">next</a><span>|</span><label class="collapse" for="c-42320952">[-]</label><label class="expand" for="c-42320952">[4 more]</label></div><br/><div class="children"><div class="content">Runtime startup isn&#x27;t amortized.</div><br/><div id="42322749" class="c"><input type="checkbox" id="c-42322749" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42320952">parent</a><span>|</span><a href="#42321306">next</a><span>|</span><label class="collapse" for="c-42322749">[-]</label><label class="expand" for="c-42322749">[3 more]</label></div><br/><div class="children"><div class="content">How do you know?</div><br/><div id="42323434" class="c"><input type="checkbox" id="c-42323434" checked=""/><div class="controls bullet"><span class="by">lern_too_spel</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42322749">parent</a><span>|</span><a href="#42321306">next</a><span>|</span><label class="collapse" for="c-42323434">[-]</label><label class="expand" for="c-42323434">[2 more]</label></div><br/><div class="children"><div class="content">The methodology is documented in the link of the comment I responded to.</div><br/><div id="42323940" class="c"><input type="checkbox" id="c-42323940" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42323434">parent</a><span>|</span><a href="#42321306">next</a><span>|</span><label class="collapse" for="c-42323940">[-]</label><label class="expand" for="c-42323940">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps you mean that &quot;the methodology&quot; does not include an explicit step intended to amortize runtime startup.<p>Perhaps the tiny tiny programs none-the-less took enough time that startup was amortized.</div><br/></div></div></div></div></div></div></div></div><div id="42321306" class="c"><input type="checkbox" id="c-42321306" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42319957">parent</a><span>|</span><a href="#42320952">prev</a><span>|</span><a href="#42321532">next</a><span>|</span><label class="collapse" for="c-42321306">[-]</label><label class="expand" for="c-42321306">[1 more]</label></div><br/><div class="children"><div class="content">This nested loops microbenchmark only measures in-loop integer division optimizations on ARM64 - there are division fault handling differences which are ARM64 specific which introduce significant variance between compilers of comparable capability.<p>On x86_64 I expect the numbers would have been much closer and within measurement error. The top half is within 0.5-0.59s - there really isn&#x27;t much you can do inside such a loop, almost nothing happens there.<p>As Isaac pointed out in a sibling comment - it&#x27;s best to pick specific microbenchmarks, a selection of languages and implementations that interest you and dissect those - it will tell you much more.</div><br/></div></div><div id="42321532" class="c"><input type="checkbox" id="c-42321532" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42319957">parent</a><span>|</span><a href="#42321306">prev</a><span>|</span><a href="#42320733">next</a><span>|</span><label class="collapse" for="c-42321532">[-]</label><label class="expand" for="c-42321532">[1 more]</label></div><br/><div class="children"><div class="content">I wonder why C++ isn&#x27;t in that list but a bunch of languages no one uses are.</div><br/></div></div></div></div><div id="42320733" class="c"><input type="checkbox" id="c-42320733" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#42319802">parent</a><span>|</span><a href="#42319957">prev</a><span>|</span><a href="#42319833">next</a><span>|</span><label class="collapse" for="c-42320733">[-]</label><label class="expand" for="c-42320733">[3 more]</label></div><br/><div class="children"><div class="content">Been using pure Dart since last year, it&#x27;s a lovely language that has it&#x27;s quirks. I like it.<p>It&#x27;s fast and flexible.</div><br/><div id="42321051" class="c"><input type="checkbox" id="c-42321051" checked=""/><div class="controls bullet"><span class="by">contagiousflow</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42320733">parent</a><span>|</span><a href="#42319833">next</a><span>|</span><label class="collapse" for="c-42321051">[-]</label><label class="expand" for="c-42321051">[2 more]</label></div><br/><div class="children"><div class="content">Have you used it for anything other than Flutter? I recently did a Flutter project and I&#x27;m interested in using dart more now.</div><br/><div id="42321356" class="c"><input type="checkbox" id="c-42321356" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#42319802">root</a><span>|</span><a href="#42321051">parent</a><span>|</span><a href="#42319833">next</a><span>|</span><label class="collapse" for="c-42321356">[-]</label><label class="expand" for="c-42321356">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s what I meant with pure Dart. I&#x27;ve created cli&#x27;s with it and a little api-only server.</div><br/></div></div></div></div></div></div><div id="42319833" class="c"><input type="checkbox" id="c-42319833" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42319802">parent</a><span>|</span><a href="#42320733">prev</a><span>|</span><a href="#42321516">next</a><span>|</span><label class="collapse" for="c-42319833">[-]</label><label class="expand" for="c-42319833">[1 more]</label></div><br/><div class="children"><div class="content">fwiw<p><a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;fastest&#x2F;dartexe-dartjit.html" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;...</a></div><br/></div></div></div></div><div id="42322817" class="c"><input type="checkbox" id="c-42322817" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#42318320">prev</a><span>|</span><a href="#42320627">next</a><span>|</span><label class="collapse" for="c-42322817">[-]</label><label class="expand" for="c-42322817">[5 more]</label></div><br/><div class="children"><div class="content">Although being slow, Python has a saving grace: it doesn&#x27;t have a huge virtual machine like Java, so it can in many situations provide a better experience.</div><br/><div id="42322879" class="c"><input type="checkbox" id="c-42322879" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42322817">parent</a><span>|</span><a href="#42323227">next</a><span>|</span><label class="collapse" for="c-42322879">[-]</label><label class="expand" for="c-42322879">[3 more]</label></div><br/><div class="children"><div class="content">Does JavaME have a &quot;huge virtual machine&quot; ?<p><a href="https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;javameoverview.html" rel="nofollow">https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;javameoverview.html</a><p>Do you mean CPython or PyPy or MicroPython or ?</div><br/><div id="42322969" class="c"><input type="checkbox" id="c-42322969" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#42322817">root</a><span>|</span><a href="#42322879">parent</a><span>|</span><a href="#42323227">next</a><span>|</span><label class="collapse" for="c-42322969">[-]</label><label class="expand" for="c-42322969">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Does JavaME have a &quot;huge virtual machine&quot;<p>Yes, compared to Python.<p>&gt; Do you mean CPython or PyPy<p>Python standard virtual machine is called CPython, just look at the official web page.</div><br/><div id="42324354" class="c"><input type="checkbox" id="c-42324354" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42322817">root</a><span>|</span><a href="#42322969">parent</a><span>|</span><a href="#42323227">next</a><span>|</span><label class="collapse" for="c-42324354">[-]</label><label class="expand" for="c-42324354">[1 more]</label></div><br/><div class="children"><div class="content">I imagine we need a nuts and bolts definition of &quot;virtual machine&quot; before we can make a comparison.</div><br/></div></div></div></div></div></div></div></div><div id="42320627" class="c"><input type="checkbox" id="c-42320627" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#42322817">prev</a><span>|</span><label class="collapse" for="c-42320627">[-]</label><label class="expand" for="c-42320627">[12 more]</label></div><br/><div class="children"><div class="content">This kind of benchmark doesn&#x27;t make sense for Python because it is measuring the speed of pure code written in the language. However, and here is the important point, most python code rely on compiled libraries to run fast. The heavy lifting in ML code is done in C, and Python is used only as a glue language. Even for web development this is also the case, Python is only calling a bunch of libraries, many of those being written in C.</div><br/><div id="42321168" class="c"><input type="checkbox" id="c-42321168" checked=""/><div class="controls bullet"><span class="by">chucke</span><span>|</span><a href="#42320627">parent</a><span>|</span><a href="#42326041">next</a><span>|</span><label class="collapse" for="c-42321168">[-]</label><label class="expand" for="c-42321168">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not true. Sure, many hot path functions dealing with tensor calculations are done in numpy functions, but etl and args&#x2F;results are python objects and functions. And most web development libs are pure python (flask, django, etc)</div><br/><div id="42322081" class="c"><input type="checkbox" id="c-42322081" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#42320627">root</a><span>|</span><a href="#42321168">parent</a><span>|</span><a href="#42323747">next</a><span>|</span><label class="collapse" for="c-42322081">[-]</label><label class="expand" for="c-42322081">[4 more]</label></div><br/><div class="children"><div class="content">For performance, hot paths are the only ones that matter.</div><br/><div id="42322215" class="c"><input type="checkbox" id="c-42322215" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42320627">root</a><span>|</span><a href="#42322081">parent</a><span>|</span><a href="#42323747">next</a><span>|</span><label class="collapse" for="c-42322215">[-]</label><label class="expand" for="c-42322215">[3 more]</label></div><br/><div class="children"><div class="content">Sure, but only a small subset of problems <i>have</i> a hot path. You can easily offload huge tensor operations to C. That&#x27;s the best possible case. More usually the &quot;hot path&quot; is fairly evenly distributed through your entire codebase. If you offload the hot path to C you&#x27;ll end up rewriting the whole thing in C.</div><br/><div id="42322987" class="c"><input type="checkbox" id="c-42322987" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#42320627">root</a><span>|</span><a href="#42322215">parent</a><span>|</span><a href="#42323747">next</a><span>|</span><label class="collapse" for="c-42322987">[-]</label><label class="expand" for="c-42322987">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;hot path&quot; is fairly evenly distributed<p>No, hot paths are seldom fairly evenly distributed, even on non-numeric applications. In most cases they will be in a small number of locations.</div><br/><div id="42325712" class="c"><input type="checkbox" id="c-42325712" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42320627">root</a><span>|</span><a href="#42322987">parent</a><span>|</span><a href="#42323747">next</a><span>|</span><label class="collapse" for="c-42325712">[-]</label><label class="expand" for="c-42325712">[1 more]</label></div><br/><div class="children"><div class="content">Not in my experience.</div><br/></div></div></div></div></div></div></div></div><div id="42323747" class="c"><input type="checkbox" id="c-42323747" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#42320627">root</a><span>|</span><a href="#42321168">parent</a><span>|</span><a href="#42322081">prev</a><span>|</span><a href="#42326041">next</a><span>|</span><label class="collapse" for="c-42323747">[-]</label><label class="expand" for="c-42323747">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this is a benchmark of recursion and tight loops doing integer math on array members. Nontrivial recursion is nonidiomatic in Python, and tight loops doing integer math on array members will probably  be done via one of the many libraries that do one or more of optimizing, jitting, or move those to GPU (Numpy, Taichi, Numba, etc.)</div><br/></div></div></div></div><div id="42326041" class="c"><input type="checkbox" id="c-42326041" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#42320627">parent</a><span>|</span><a href="#42321168">prev</a><span>|</span><a href="#42321678">next</a><span>|</span><label class="collapse" for="c-42326041">[-]</label><label class="expand" for="c-42326041">[1 more]</label></div><br/><div class="children"><div class="content">Yet this particular blog post shows how Ruby-writen-in-Ruby is faster than Ruby-written-in-C because it&#x27;s more optimizable.</div><br/></div></div><div id="42321678" class="c"><input type="checkbox" id="c-42321678" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42320627">parent</a><span>|</span><a href="#42326041">prev</a><span>|</span><a href="#42320664">next</a><span>|</span><label class="collapse" for="c-42321678">[-]</label><label class="expand" for="c-42321678">[1 more]</label></div><br/><div class="children"><div class="content">Any language with FFI (which is like all of them, these days) has the same exact issue, the only difference being how common it is to drop into C or other fast compiled language for parts of the code.<p>And this kind of benchmark is the one that tells you <i>why</i> this is different across different languages.</div><br/></div></div><div id="42320664" class="c"><input type="checkbox" id="c-42320664" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#42320627">parent</a><span>|</span><a href="#42321678">prev</a><span>|</span><a href="#42321159">next</a><span>|</span><label class="collapse" for="c-42320664">[-]</label><label class="expand" for="c-42320664">[1 more]</label></div><br/><div class="children"><div class="content"><i>aka</i> Python is as fast as C when it is C.</div><br/></div></div><div id="42321159" class="c"><input type="checkbox" id="c-42321159" checked=""/><div class="controls bullet"><span class="by">knowitnone</span><span>|</span><a href="#42320627">parent</a><span>|</span><a href="#42320664">prev</a><span>|</span><a href="#42322010">next</a><span>|</span><label class="collapse" for="c-42321159">[-]</label><label class="expand" for="c-42321159">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know. Ruby is able to call C too so it&#x27;s a wash?</div><br/></div></div><div id="42322010" class="c"><input type="checkbox" id="c-42322010" checked=""/><div class="controls bullet"><span class="by">ModernMech</span><span>|</span><a href="#42320627">parent</a><span>|</span><a href="#42321159">prev</a><span>|</span><label class="collapse" for="c-42322010">[-]</label><label class="expand" for="c-42322010">[1 more]</label></div><br/><div class="children"><div class="content">Yes, if you pull out all the optimization tricks for Python, it will be faster than vanilla Python. And yet it&#x27;s <i>still</i> 6x slower (by my measurement) than naive code written in a compiled language like Rust without any libraries.</div><br/></div></div></div></div></div></div></div></div></div></body></html>