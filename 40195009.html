<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714467680628" as="style"/><link rel="stylesheet" href="styles.css?v=1714467680628"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://csvbase.com/blog/9">You can&#x27;t just assume UTF-8</a> <span class="domain">(<a href="https://csvbase.com">csvbase.com</a>)</span></div><div class="subtext"><span>calpaterson</span> | <span>221 comments</span></div><br/><div><div id="40204729" class="c"><input type="checkbox" id="c-40204729" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40204933">next</a><span>|</span><label class="collapse" for="c-40204729">[-]</label><label class="expand" for="c-40204729">[120 more]</label></div><br/><div class="children"><div class="content">How about assume utf-8, and if someone has some binary file they&#x27;d rather a program interpret as some other format, they turn it into utf-8 using a standalone program first. Instead of burning this guess-what-bytes-they-might-like nonsense into all the software.<p>We don&#x27;t go &quot;oh that input that&#x27;s supposed to be json? It looks like a malformed csv file, let&#x27;s silently have a go at fixing that up for you&quot;. Or at least we shouldn&#x27;t, some software probably does.</div><br/><div id="40205376" class="c"><input type="checkbox" id="c-40205376" checked=""/><div class="controls bullet"><span class="by">ezoe</span><span>|</span><a href="#40204729">parent</a><span>|</span><a href="#40204873">next</a><span>|</span><label class="collapse" for="c-40205376">[-]</label><label class="expand" for="c-40205376">[23 more]</label></div><br/><div class="children"><div class="content">I doubt you can handle UTF-8 properly with that attitude.<p>The problems is, there is one very popular OS which is very hard to enforce UTF-8 everywhere, Microsoft Windows.<p>It&#x27;s very hard to ensure all the software stack you are depending on it use Unicode version of Win32 API. Actually the native character encoding in Windows is UTF-16 so you can&#x27;t just assume UTF-8. If you&#x27;re writing low level code, you have to convert UTF-8 to UTF-16 and back. Even if you don&#x27;t you have to ensure all the low level code you are depending on it do the same for you.<p>Oh and don&#x27;t forget about the Unicode Normalizations. There is no THE UTF-8. There are bunch of UTF-8s with different Unicode normalizations. Apple macOS use NFD while other mostly use NFC.<p>These are Just some examples. When people living in ASCII world casually said &quot;I just assume UTF-8&quot;, in reality, you still assume it&#x27;s ASCII.</div><br/><div id="40206958" class="c"><input type="checkbox" id="c-40206958" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205376">parent</a><span>|</span><a href="#40206504">next</a><span>|</span><label class="collapse" for="c-40206958">[-]</label><label class="expand" for="c-40206958">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Apple macOS use NFD while other mostly use NFC.<p>It&#x27;s actually worse than that.<p>Older versions of mac did enforce NFD for file names, but more recent names don&#x27;t, at least  at the OS level. But many apple programs, such as finder _will_ use NFD. Except that it isn&#x27;t even Unicode standardized NFD, it is Apple&#x27;s own modified version of it. And this can cause issues when for example you create a file in finder, then search for it using `find`, and type the name of the file the exact same way, but it can&#x27;t find the file because find got an NFC form, but the actual file is in NFD.<p>OTOH, in many applications, you don&#x27;t really care about the normalization form used. For example, if you are parsing a CSV, you probably don&#x27;t need to worry about if one of the cells using using a single code point or two code points to represent that accented e.</div><br/><div id="40207681" class="c"><input type="checkbox" id="c-40207681" checked=""/><div class="controls bullet"><span class="by">ezoe</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206958">parent</a><span>|</span><a href="#40207373">next</a><span>|</span><label class="collapse" for="c-40207681">[-]</label><label class="expand" for="c-40207681">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I know that but omit it to make my comment shorter. The world will be a slightly better if there is no macOS.</div><br/></div></div><div id="40207373" class="c"><input type="checkbox" id="c-40207373" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206958">parent</a><span>|</span><a href="#40207681">prev</a><span>|</span><a href="#40206504">next</a><span>|</span><label class="collapse" for="c-40207373">[-]</label><label class="expand" for="c-40207373">[2 more]</label></div><br/><div class="children"><div class="content">Thanks, yet another quantum of knowledge that makes one&#x27;s life irreversibly ever so slightly worse. But not as bad as encryption (and learning all the terrible ways most applications have broken implementations in)</div><br/><div id="40208507" class="c"><input type="checkbox" id="c-40208507" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207373">parent</a><span>|</span><a href="#40206504">next</a><span>|</span><label class="collapse" for="c-40208507">[-]</label><label class="expand" for="c-40208507">[1 more]</label></div><br/><div class="children"><div class="content">&gt; most applications have broken implementations<p>What applications? Almost nobody writes their own implementations of encryption nowadays (nor should they). You mean openssl is &quot;broken&quot;?</div><br/></div></div></div></div></div></div><div id="40206504" class="c"><input type="checkbox" id="c-40206504" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205376">parent</a><span>|</span><a href="#40206958">prev</a><span>|</span><a href="#40208648">next</a><span>|</span><label class="collapse" for="c-40206504">[-]</label><label class="expand" for="c-40206504">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Actually the native character encoding in Windows is UTF-16 so you can&#x27;t just assume UTF-8. If you&#x27;re writing low level code, you have to convert UTF-8 to UTF-16 and back.<p>Yes. You should convert your strings. Thankfully, UTF-16 is very difficult to confuse with UTF-8 because they&#x27;re completely incompatible encodings. Conversion is (or should be) a relatively simple process in basically any modern language or environment. And personally, I&#x27;ve never run into a problem where the difference between NFC and NFD mattered. (Do you have an example?). The different forms are (or should be) visually completely identical for the user - at least on modern computers with decent unicode fonts.<p>The largest problem with UTF-8 (and its biggest strength) is how similar it is to ASCII. It is for this reason we should consider emoji to be a wonderful gift to software correctness everywhere. Correctly handling emoji requires that your software can handle unicode correctly - because they need multi-unit encoding with both UTF-16 and UTF-8. And emoji won&#x27;t render correctly unless your software can also handle grapheme clusters.<p>&gt; When people living in ASCII world casually said &quot;I just assume UTF-8&quot;, in reality, you still assume it&#x27;s ASCII.<p>Check! If your application deals with text, throw your favorite multi-codepoint emoji into your unit testing data. (Mine is the polar bear). Users love emoji, and your software should handle it correctly. There&#x27;s no excuse! Even the windows filesystem passes this test today.</div><br/><div id="40207650" class="c"><input type="checkbox" id="c-40207650" checked=""/><div class="controls bullet"><span class="by">hnfong</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206504">parent</a><span>|</span><a href="#40207670">next</a><span>|</span><label class="collapse" for="c-40207650">[-]</label><label class="expand" for="c-40207650">[3 more]</label></div><br/><div class="children"><div class="content">This.<p>My native language uses some additional CJK chars on plane 2, and before ~2010s a lot of software had glitches beyond the basic plane of unicode. I am forever grateful for the &quot;Gen Z&quot; who pushed for Emojis.<p>Javascript&#x27;s String.length is still semantically broken though. Too bad it&#x27;s part of a unchangeable spec...</div><br/><div id="40208656" class="c"><input type="checkbox" id="c-40208656" checked=""/><div class="controls bullet"><span class="by">CryZe</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207650">parent</a><span>|</span><a href="#40207775">next</a><span>|</span><label class="collapse" for="c-40208656">[-]</label><label class="expand" for="c-40208656">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s Intl.Segmenter now which does Unicode Segmentation to count the amount of graphemes for example: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Intl&#x2F;Segmenter&#x2F;Segmenter#grapheme" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>Though you are right in that I don&#x27;t know of a built-in way to count Unicode Scalar Values (USVs).</div><br/></div></div><div id="40207775" class="c"><input type="checkbox" id="c-40207775" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207650">parent</a><span>|</span><a href="#40208656">prev</a><span>|</span><a href="#40207670">next</a><span>|</span><label class="collapse" for="c-40207775">[-]</label><label class="expand" for="c-40207775">[1 more]</label></div><br/><div class="children"><div class="content">Yep. I don&#x27;t use eslint, but if I did I would want a lint against any use of string.length. Its almost never what you want. Especially now that javascript supports unicode through [...str].</div><br/></div></div></div></div><div id="40207670" class="c"><input type="checkbox" id="c-40207670" checked=""/><div class="controls bullet"><span class="by">ezoe</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206504">parent</a><span>|</span><a href="#40207650">prev</a><span>|</span><a href="#40207451">next</a><span>|</span><label class="collapse" for="c-40207670">[-]</label><label class="expand" for="c-40207670">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s one good thing emoji bring to the software developers mind set.<p>Before emoji, if somebody open a bug report like: &quot;Your software doesn&#x27;t handle UTF-8 correctly. It doesn&#x27;t handle Japanese.&quot;,<p>the response was &quot;Huh? We don&#x27;t bother to support Japanese. Go pound sand. Close ticket with wontfix.&quot;.<p>Now it&#x27;s &quot;Your software doesn&#x27;t handle UTF-8 correctly. It doesn&#x27;t handle emoji&quot; and we&#x27;re like &quot;Oh shit! My software can&#x27;t handle my beloved emoji!&quot;</div><br/></div></div><div id="40207451" class="c"><input type="checkbox" id="c-40207451" checked=""/><div class="controls bullet"><span class="by">eclipticplane</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206504">parent</a><span>|</span><a href="#40207670">prev</a><span>|</span><a href="#40206741">next</a><span>|</span><label class="collapse" for="c-40207451">[-]</label><label class="expand" for="c-40207451">[3 more]</label></div><br/><div class="children"><div class="content">&gt; (Mine is the polar bear).<p>Mine is the crying emoji.<p>And after enough failures in breaking the system, the 100 emoji.</div><br/><div id="40207827" class="c"><input type="checkbox" id="c-40207827" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207451">parent</a><span>|</span><a href="#40206741">next</a><span>|</span><label class="collapse" for="c-40207827">[-]</label><label class="expand" for="c-40207827">[2 more]</label></div><br/><div class="children"><div class="content">Those are ok, but both of those emoji are represented as a single unicode codepoint. Some bugs (particularly UI bugs) only show up when multiple unicode characters combine to form a single grapheme cluster. I&#x27;d recommend something fancier.<p>I just tried it in gnome-terminal, and while the crying emoji works fine, polar bear or a country flag causes weird issues.</div><br/><div id="40208593" class="c"><input type="checkbox" id="c-40208593" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207827">parent</a><span>|</span><a href="#40206741">next</a><span>|</span><label class="collapse" for="c-40208593">[-]</label><label class="expand" for="c-40208593">[1 more]</label></div><br/><div class="children"><div class="content">Crying emoji but with a different skin color?</div><br/></div></div></div></div></div></div><div id="40206741" class="c"><input type="checkbox" id="c-40206741" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206504">parent</a><span>|</span><a href="#40207451">prev</a><span>|</span><a href="#40208648">next</a><span>|</span><label class="collapse" for="c-40206741">[-]</label><label class="expand" for="c-40206741">[3 more]</label></div><br/><div class="children"><div class="content">&gt; your software should handle it correctly. There&#x27;s no excuse!<p>It is valid for the presentation of compound emoji can fallback to their component parts. You can&#x27;t expect every platform to have an up to date database of every novel combination. A better test is emoji with color modifiers. Another good one is grandfathered symbols with both a text and emoji presentation and forcing the chosen glyph with the variant selector prefix.</div><br/><div id="40207371" class="c"><input type="checkbox" id="c-40207371" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206741">parent</a><span>|</span><a href="#40208648">next</a><span>|</span><label class="collapse" for="c-40207371">[-]</label><label class="expand" for="c-40207371">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You can&#x27;t expect every platform to have an up to date database of every novel combination.<p>On modern desktop OSes and smart phones, I do expect my platform to have an up-to-date unicode database &amp; font set. Certainly for something like the unicode polar bear, which was added in 2020. I&#x27;ll begrudgingly look the other way for terminals, embedded systems and maybe video games... but generally it should just work everywhere.<p>Server code generally shouldn&#x27;t interact with unicode grapheme clusters at all. I&#x27;m struggling to think of any common, valid reason to use a unicode character database in &#x27;normal&#x27; backend server code.<p>&gt; Another good one is grandfathered symbols with both a text and emoji presentation and forcing the chosen glyph with the variant selector prefix.<p>I didn&#x27;t know about that one. I&#x27;ll have to try it out.</div><br/></div></div></div></div></div></div><div id="40208648" class="c"><input type="checkbox" id="c-40208648" checked=""/><div class="controls bullet"><span class="by">0xEF</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205376">parent</a><span>|</span><a href="#40206504">prev</a><span>|</span><a href="#40207547">next</a><span>|</span><label class="collapse" for="c-40208648">[-]</label><label class="expand" for="c-40208648">[1 more]</label></div><br/><div class="children"><div class="content">Do you know of a resource that explains character encoding in greater detail? Just for my own curiosity. I am learning web development and boy, they brow beat UTF-8 upon us which okay, I&#x27;ll make sure that call is in my meta data, but none bother to explain how or why we got to that point, or why it seems so splintered.</div><br/></div></div><div id="40207547" class="c"><input type="checkbox" id="c-40207547" checked=""/><div class="controls bullet"><span class="by">surfingdino</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205376">parent</a><span>|</span><a href="#40208648">prev</a><span>|</span><a href="#40207213">next</a><span>|</span><label class="collapse" for="c-40207547">[-]</label><label class="expand" for="c-40207547">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft Windows is a source of many a headache for me as almost every other client I write code for has to deal with data created by humans using MS Office. Ordinary users could be excused, because they are not devs but even devs don&#x27;t see a difference between ASCII and UTF-8 and continue to write code today as if it was 1986 and nobody needed to support accented characters.</div><br/></div></div><div id="40207213" class="c"><input type="checkbox" id="c-40207213" checked=""/><div class="controls bullet"><span class="by">morpheuskafka</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205376">parent</a><span>|</span><a href="#40207547">prev</a><span>|</span><a href="#40205839">next</a><span>|</span><label class="collapse" for="c-40207213">[-]</label><label class="expand" for="c-40207213">[1 more]</label></div><br/><div class="children"><div class="content">I got a ticket about some &quot;folders with Chinese characters&quot; showing up on an SMB share at work, my first thought was a Unicode issue and sure enough when you combine two UTF-8&#x2F;ASCII A-z code points together as one UTF-16 code point, it will usually wind up in the CJK Common Ideographs range of Unicode. Some crappy software had evidently bypassed the appropriate Windows APIs and just directly wrote a C-style ASCII string onto the filesystem without realizing that NTFS is UTF-16.</div><br/></div></div><div id="40205839" class="c"><input type="checkbox" id="c-40205839" checked=""/><div class="controls bullet"><span class="by">dgellow</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205376">parent</a><span>|</span><a href="#40207213">prev</a><span>|</span><a href="#40206631">next</a><span>|</span><label class="collapse" for="c-40205839">[-]</label><label class="expand" for="c-40205839">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been sharing it multiple times but I love it: WTF-16 spec <a href="https:&#x2F;&#x2F;simonsapin.github.io&#x2F;wtf-8&#x2F;#ill-formed-utf-16" rel="nofollow">https:&#x2F;&#x2F;simonsapin.github.io&#x2F;wtf-8&#x2F;#ill-formed-utf-16</a></div><br/></div></div><div id="40206631" class="c"><input type="checkbox" id="c-40206631" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205376">parent</a><span>|</span><a href="#40205839">prev</a><span>|</span><a href="#40206316">next</a><span>|</span><label class="collapse" for="c-40206631">[-]</label><label class="expand" for="c-40206631">[1 more]</label></div><br/><div class="children"><div class="content">We make some B2B software running on Windows, integrating with customer systems. We get a lot of interesting files.<p>About a decade ago I wrote some utility code for reading files, where it&#x27;ll try to detect BOM first, if not scan for invalid UTF-8 sequences. If none are found assume UTF-8 else assume Windows-1252. Worked well for us so far.<p>Still get the occasional flat file in Windows-1252 with one random field containing UTF-8, so some special handling is needed for those cases. But that&#x27;s rare.<p>Fortunately we don&#x27;t have to worry about normalization for the most part. If we&#x27;re parsing then any delimiters will be one of the usual suspects and the rest data.</div><br/></div></div><div id="40206316" class="c"><input type="checkbox" id="c-40206316" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205376">parent</a><span>|</span><a href="#40206631">prev</a><span>|</span><a href="#40204873">next</a><span>|</span><label class="collapse" for="c-40206316">[-]</label><label class="expand" for="c-40206316">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you&#x27;re writing low level code, you have to convert UTF-8 to UTF-16 and back.<p>It depends. If you&#x27;re writing an app, just add the necessary incantation to your manifest, and all the narrow char APIs start talking UTF-8 to you.<p>For a library, yeah.</div><br/><div id="40208633" class="c"><input type="checkbox" id="c-40208633" checked=""/><div class="controls bullet"><span class="by">ezoe</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206316">parent</a><span>|</span><a href="#40204873">next</a><span>|</span><label class="collapse" for="c-40208633">[-]</label><label class="expand" for="c-40208633">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t be surprised such UTF-8 locale program will break so bad on Windows with default language set to Japanese.</div><br/></div></div></div></div></div></div><div id="40204873" class="c"><input type="checkbox" id="c-40204873" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#40204729">parent</a><span>|</span><a href="#40205376">prev</a><span>|</span><a href="#40206650">next</a><span>|</span><label class="collapse" for="c-40204873">[-]</label><label class="expand" for="c-40204873">[42 more]</label></div><br/><div class="children"><div class="content">Agreed. Continuing to support other encodings is like insisting that cars should continue to have cassette tape players.<p>It’s much easier to tell the people with old cassette tapes to rip them, rather than try to put a tape player in every car.</div><br/><div id="40205115" class="c"><input type="checkbox" id="c-40205115" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40204873">parent</a><span>|</span><a href="#40205271">next</a><span>|</span><label class="collapse" for="c-40205115">[-]</label><label class="expand" for="c-40205115">[10 more]</label></div><br/><div class="children"><div class="content">&gt; It’s much easier to tell the people with old cassette tapes to rip them<p>I assume you mean &quot;rip them&quot;, as in transcode to a different format?<p>In that case, you need a tool that takes the old input format(s) and convert them to the new format.<p>For text files, you&#x27;d need a tool that takes the old text files with various encodings and converts them to UTF-8.<p>Isn&#x27;t the point of the article to describe how an engineer would create such a tool?</div><br/><div id="40205594" class="c"><input type="checkbox" id="c-40205594" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205115">parent</a><span>|</span><a href="#40205220">next</a><span>|</span><label class="collapse" for="c-40205594">[-]</label><label class="expand" for="c-40205594">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Isn&#x27;t the point of the article to describe how an engineer would create such a tool?<p>Honestly, no, because the tool that it&#x27;s suggesting how to write isn&#x27;t one that will even come close to doing a good job.<p>If you want to write such a tool, the first thing you need to do is to understand what the correct answer is. And to do that, you need to sample your input set to figure out what the correct answer should be for several inputs where it matters. There&#x27;s unfortunately no easy way to avoid that work; universal charset detection isn&#x27;t really a thing that works all that well.</div><br/><div id="40205634" class="c"><input type="checkbox" id="c-40205634" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205594">parent</a><span>|</span><a href="#40205770">next</a><span>|</span><label class="collapse" for="c-40205634">[-]</label><label class="expand" for="c-40205634">[1 more]</label></div><br/><div class="children"><div class="content">I agree 100% on the technical issues.<p>But the point of the article is not the same thing as how well it achieved its goals.</div><br/></div></div><div id="40205770" class="c"><input type="checkbox" id="c-40205770" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205594">parent</a><span>|</span><a href="#40205634">prev</a><span>|</span><a href="#40205220">next</a><span>|</span><label class="collapse" for="c-40205770">[-]</label><label class="expand" for="c-40205770">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt;universal charset detection isn&#x27;t really a thing that works all that well.</i><p>This seems like something LLMs would be good at. A mundane use of them, but I bet they&#x27;d be really good at determining that the input has the wrong encoding. Then the program would iterate through encodings, from most probable to least, and select the one that the LLM likes the most. Granted, this means your tool will be 1GB or more. But hey, thems the breaks.</div><br/><div id="40205874" class="c"><input type="checkbox" id="c-40205874" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205770">parent</a><span>|</span><a href="#40205220">next</a><span>|</span><label class="collapse" for="c-40205874">[-]</label><label class="expand" for="c-40205874">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that could be an interesting use of LLMs. It could at least tell you which languages might be present in the input text.<p>In the 1980s, we had a version of 7-bit ASCII in Sweden where the three extra Swedish vowels &quot;åäö&quot; were represented by &quot;{}|&quot;.<p>So what might look like regular US 7-bit ASCII should be interpreted as the Swedish version if the text is in Swedish with &quot;{}|&quot; where &quot;åäö&quot; normally goes.</div><br/></div></div></div></div></div></div><div id="40205220" class="c"><input type="checkbox" id="c-40205220" checked=""/><div class="controls bullet"><span class="by">0xffff2</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205115">parent</a><span>|</span><a href="#40205594">prev</a><span>|</span><a href="#40206044">next</a><span>|</span><label class="collapse" for="c-40205220">[-]</label><label class="expand" for="c-40205220">[3 more]</label></div><br/><div class="children"><div class="content">A tool whose purpose is to transcode should be asking the user to select explicit input and output formats, not guessing.</div><br/><div id="40205256" class="c"><input type="checkbox" id="c-40205256" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205220">parent</a><span>|</span><a href="#40207591">next</a><span>|</span><label class="collapse" for="c-40205256">[-]</label><label class="expand" for="c-40205256">[1 more]</label></div><br/><div class="children"><div class="content">&gt; should be asking the user to select explicit input and output formats<p>It depends on the requirements.<p>If you&#x27;re hired by a company to convert millions of old textfiles, they might want you to do it as well as possible using heuristics without any human input as a starting point.</div><br/></div></div><div id="40207591" class="c"><input type="checkbox" id="c-40207591" checked=""/><div class="controls bullet"><span class="by">tempaccount1234</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205220">parent</a><span>|</span><a href="#40205256">prev</a><span>|</span><a href="#40206044">next</a><span>|</span><label class="collapse" for="c-40207591">[-]</label><label class="expand" for="c-40207591">[1 more]</label></div><br/><div class="children"><div class="content">Unless the input is such garbage that asking the user is pointless (like a lot of web sources) and fixing manually is too time expensive.<p>It becomes easier to just use <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;ftfy&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;ftfy&#x2F;</a> on the input.</div><br/></div></div></div></div><div id="40206044" class="c"><input type="checkbox" id="c-40206044" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205115">parent</a><span>|</span><a href="#40205220">prev</a><span>|</span><a href="#40205271">next</a><span>|</span><label class="collapse" for="c-40206044">[-]</label><label class="expand" for="c-40206044">[2 more]</label></div><br/><div class="children"><div class="content">No you don’t, <i>they</i> (the ones with the piles of old mixtapes) do.</div><br/><div id="40206120" class="c"><input type="checkbox" id="c-40206120" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206044">parent</a><span>|</span><a href="#40205271">next</a><span>|</span><label class="collapse" for="c-40206120">[-]</label><label class="expand" for="c-40206120">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m an engineer. I&#x27;m sometimes hired by <i>they</i> to create tools like that.</div><br/></div></div></div></div></div></div><div id="40205271" class="c"><input type="checkbox" id="c-40205271" checked=""/><div class="controls bullet"><span class="by">gwervc</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40204873">parent</a><span>|</span><a href="#40205115">prev</a><span>|</span><a href="#40206650">next</a><span>|</span><label class="collapse" for="c-40205271">[-]</label><label class="expand" for="c-40205271">[31 more]</label></div><br/><div class="children"><div class="content">UTF-8 uses 50% more bytes than UFT-16 to encode Chinese or Japanese texts.</div><br/><div id="40205538" class="c"><input type="checkbox" id="c-40205538" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205271">parent</a><span>|</span><a href="#40205752">next</a><span>|</span><label class="collapse" for="c-40205538">[-]</label><label class="expand" for="c-40205538">[3 more]</label></div><br/><div class="children"><div class="content">Only with &quot;pure&quot; CJK text in a flat text file; for most real-world situations you&#x27;ll have enough ASCII text that UTF-8 will be smaller: HMTL&#x2F;XML tags, email headers, things like that. I did some tests a few years back, and wasn&#x27;t really able to come up with a real-world situation where UTF-16 is smaller. I&#x27;m sure some situations exist, but by and large, CJK users are better off with UTF-8.</div><br/><div id="40206594" class="c"><input type="checkbox" id="c-40206594" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205538">parent</a><span>|</span><a href="#40207232">next</a><span>|</span><label class="collapse" for="c-40206594">[-]</label><label class="expand" for="c-40206594">[1 more]</label></div><br/><div class="children"><div class="content">Yep. I&#x27;m a heavy user of CJK languages and I don&#x27;t give a damn about the slightly increased plaintext storage. Give me UTF-8 any day, every day. Legacy two-byte encodings can&#x27;t represent all of the historical glyphs anyway, so there&#x27;s no room for nationalist crap here.</div><br/></div></div><div id="40207232" class="c"><input type="checkbox" id="c-40207232" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205538">parent</a><span>|</span><a href="#40206594">prev</a><span>|</span><a href="#40205752">next</a><span>|</span><label class="collapse" for="c-40207232">[-]</label><label class="expand" for="c-40207232">[1 more]</label></div><br/><div class="children"><div class="content">Databases tend to pack rows efficiently enough that there are scenarios where this is noticeable.</div><br/></div></div></div></div><div id="40205752" class="c"><input type="checkbox" id="c-40205752" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205271">parent</a><span>|</span><a href="#40205538">prev</a><span>|</span><a href="#40205348">next</a><span>|</span><label class="collapse" for="c-40205752">[-]</label><label class="expand" for="c-40205752">[1 more]</label></div><br/><div class="children"><div class="content">Only for dense CJK text, and even then if you compress the difference goes away
<a href="https:&#x2F;&#x2F;utf8everywhere.org&#x2F;#asian" rel="nofollow">https:&#x2F;&#x2F;utf8everywhere.org&#x2F;#asian</a></div><br/></div></div><div id="40205348" class="c"><input type="checkbox" id="c-40205348" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205271">parent</a><span>|</span><a href="#40205752">prev</a><span>|</span><a href="#40206043">next</a><span>|</span><label class="collapse" for="c-40205348">[-]</label><label class="expand" for="c-40205348">[24 more]</label></div><br/><div class="children"><div class="content">Which basically never matters and in any case where it actually does, gzip will make it equal again.</div><br/><div id="40205449" class="c"><input type="checkbox" id="c-40205449" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205348">parent</a><span>|</span><a href="#40205439">prev</a><span>|</span><a href="#40206043">next</a><span>|</span><label class="collapse" for="c-40205449">[-]</label><label class="expand" for="c-40205449">[22 more]</label></div><br/><div class="children"><div class="content">zip-then-encrypt leaks information about the plaintext. if it&#x27;s life or death, better not to compress at all</div><br/><div id="40206491" class="c"><input type="checkbox" id="c-40206491" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205449">parent</a><span>|</span><a href="#40207398">next</a><span>|</span><label class="collapse" for="c-40206491">[-]</label><label class="expand" for="c-40206491">[4 more]</label></div><br/><div class="children"><div class="content">Only when the attacker can choose part of the plaintext and do the same thing over and over again with different chosen plaintexts to compare results.<p>Yes, there are scenarios where that matters. However the vast majority of usecases of utf-8 don&#x27;t fit that or even use encryption at all.</div><br/><div id="40207218" class="c"><input type="checkbox" id="c-40207218" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206491">parent</a><span>|</span><a href="#40207398">next</a><span>|</span><label class="collapse" for="c-40207218">[-]</label><label class="expand" for="c-40207218">[3 more]</label></div><br/><div class="children"><div class="content">That is not the only way. There are other ways of knowing partial contents of files and changes to files, depending on the situation. If the document is a known form in which one of five boxes is checked by the sender, it&#x27;s probably not hard to rule out certain selections based on the ciphertext length, if not pin down the contents exactly.</div><br/><div id="40207720" class="c"><input type="checkbox" id="c-40207720" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207218">parent</a><span>|</span><a href="#40207398">next</a><span>|</span><label class="collapse" for="c-40207720">[-]</label><label class="expand" for="c-40207720">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure i entirely understand your example (if there are 5 checkboxes and 1 checked, presumably length would be the same regardless which one of those are checked). However to your broader point, i agree there exist scenarios along those lines (e.g. fingerprinting known communication based on length), however most of them apply even better when not using compression.</div><br/><div id="40207936" class="c"><input type="checkbox" id="c-40207936" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207720">parent</a><span>|</span><a href="#40207398">next</a><span>|</span><label class="collapse" for="c-40207936">[-]</label><label class="expand" for="c-40207936">[1 more]</label></div><br/><div class="children"><div class="content">The checkbox example is completely plausible. There is no guarantee that all checkboxes lead to the same number of bytes changed in the file when checked. What if the format makes a note of the page number wherever a checkbox is checked? 1X could be two bytes and 15X would be three.<p>And even if the format only stored the checkbox states as a single bit each (unlikely), compression algorithms don&#x27;t care. They will behave differently on different byte sequences, which can easily lead to a difference in output length.<p>Also, it&#x27;s already been done with voice calls with no attacker-controlled data: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20080901185111&#x2F;https:&#x2F;&#x2F;technology.newscientist.com&#x2F;channel&#x2F;tech&#x2F;dn14124-compressed-web-phone-calls-are-easy-to-bug.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20080901185111&#x2F;https:&#x2F;&#x2F;technolog...</a></div><br/></div></div></div></div></div></div></div></div><div id="40207398" class="c"><input type="checkbox" id="c-40207398" checked=""/><div class="controls bullet"><span class="by">thwarted</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205449">parent</a><span>|</span><a href="#40206491">prev</a><span>|</span><a href="#40205612">next</a><span>|</span><label class="collapse" for="c-40207398">[-]</label><label class="expand" for="c-40207398">[1 more]</label></div><br/><div class="children"><div class="content">Encryption is completely unrelated to the task at hand, which is text encoding and compressing, and text encoding is not encryption.</div><br/></div></div><div id="40205612" class="c"><input type="checkbox" id="c-40205612" checked=""/><div class="controls bullet"><span class="by">tnmom</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205449">parent</a><span>|</span><a href="#40207398">prev</a><span>|</span><a href="#40206043">next</a><span>|</span><label class="collapse" for="c-40205612">[-]</label><label class="expand" for="c-40205612">[16 more]</label></div><br/><div class="children"><div class="content">Huh, never heard that before. Does it leak more information than just encrypting without zipping? Struggling to imagine how this attack works.</div><br/><div id="40205950" class="c"><input type="checkbox" id="c-40205950" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205612">parent</a><span>|</span><a href="#40206538">next</a><span>|</span><label class="collapse" for="c-40205950">[-]</label><label class="expand" for="c-40205950">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an extension of the chosen-plaintext attack, and so requires the attacker to be able to send custom text that they know is in the encrypted payload. If the unencrypted payload is &quot;our-secret-data :::: some user specified text&quot;, then the attacker can eventually determine the contents of our-secret-data by observing how the size of the encrypted response changes as they change the text when the compression step matches up with a part of the secret data. It can be defeated by adding random-length padding after compression and before the encryption step, though.</div><br/></div></div><div id="40206538" class="c"><input type="checkbox" id="c-40206538" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205612">parent</a><span>|</span><a href="#40205950">prev</a><span>|</span><a href="#40206125">next</a><span>|</span><label class="collapse" for="c-40206538">[-]</label><label class="expand" for="c-40206538">[1 more]</label></div><br/><div class="children"><div class="content">Essentially if you zip something, repeated text will be deduplicated.<p>For example &quot;FooFoo&quot; will be smaller than &quot;FooBar&quot; since there is a repeated pattern in the first one.<p>The attacker can look at the file size and make guesses about how repetitive the text is if they know what the uncompressed or normal size is.<p>This gets more powerful if the attacker can insert some of their own plaintext.<p>For example if the plaintext is &quot;Foo&quot; and the attacker inserts &quot;Fo&quot; (giving &quot;FooFo&quot;) the result will be smaller than if they inserted zq where there is no pattern. By making lots of guesses the attacker can figure out the secret part of the text a little bit at a time just by observing the size of the ciphertext after inserting different guesses.</div><br/></div></div><div id="40206125" class="c"><input type="checkbox" id="c-40206125" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205612">parent</a><span>|</span><a href="#40206538">prev</a><span>|</span><a href="#40205664">next</a><span>|</span><label class="collapse" for="c-40206125">[-]</label><label class="expand" for="c-40206125">[1 more]</label></div><br/><div class="children"><div class="content">Yes, of course it leaks more information than encryption without compression, because that’s <i>just encryption</i> which doesn’t leak anything.<p>In an enormous number of real world cases adversaries can end up including attacker-controller input alongside secret data. In that case you can guess at secret data and if you guess correctly, you get smaller compressed output. But even without that, imagine the worst case: a 1TB file that compresses to a handful of bytes. Pretty clearly the overwhelming majority of the text is just duplicate bytes. That’s information which is leaked.</div><br/></div></div><div id="40205664" class="c"><input type="checkbox" id="c-40205664" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205612">parent</a><span>|</span><a href="#40206125">prev</a><span>|</span><a href="#40206043">next</a><span>|</span><label class="collapse" for="c-40205664">[-]</label><label class="expand" for="c-40205664">[12 more]</label></div><br/><div class="children"><div class="content">Encrypting without zipping doesn&#x27;t leak any information about the content. You can&#x27;t rule out certain byte sequences (other than by total length) just by looking at the ciphertext length.<p>If &quot;oui&quot; compresses to two bytes and &quot;non&quot; compresses to one byte, and then you go over them with a stream cipher, which is which:<p>A: ;<p>B: *&amp;</div><br/><div id="40205805" class="c"><input type="checkbox" id="c-40205805" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205664">parent</a><span>|</span><a href="#40206184">next</a><span>|</span><label class="collapse" for="c-40205805">[-]</label><label class="expand" for="c-40205805">[8 more]</label></div><br/><div class="children"><div class="content">This has nothing to do with compression.  If you use &quot;yes&quot; and &quot;no&quot; instead of &quot;oui&quot; and &quot;non&quot; (which just happen to be three characters each) and you compress &quot;yes&quot; to &quot;T&quot; and &quot;no&quot; to &quot;F&quot; then the uncompressed text will be the leaky one.</div><br/><div id="40206132" class="c"><input type="checkbox" id="c-40206132" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205805">parent</a><span>|</span><a href="#40206184">next</a><span>|</span><label class="collapse" for="c-40206132">[-]</label><label class="expand" for="c-40206132">[7 more]</label></div><br/><div class="children"><div class="content">It’s an example meant to prove the idea.</div><br/><div id="40206437" class="c"><input type="checkbox" id="c-40206437" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206132">parent</a><span>|</span><a href="#40206184">next</a><span>|</span><label class="collapse" for="c-40206437">[-]</label><label class="expand" for="c-40206437">[6 more]</label></div><br/><div class="children"><div class="content">Yes, and my example was an example meant to prove the opposite idea.  The point is that it is irrelevant whether you compress or not.  You can leak information either way.</div><br/><div id="40207306" class="c"><input type="checkbox" id="c-40207306" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206437">parent</a><span>|</span><a href="#40206184">next</a><span>|</span><label class="collapse" for="c-40207306">[-]</label><label class="expand" for="c-40207306">[5 more]</label></div><br/><div class="children"><div class="content">I leak the length of my phone call and you leak:<p>1. the length of your phone call; and<p>2. what language you were speaking; oh and<p>3. half the words you said<p>(i.e. pwned)<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20080901185111&#x2F;https:&#x2F;&#x2F;technology.newscientist.com&#x2F;channel&#x2F;tech&#x2F;dn14124-compressed-web-phone-calls-are-easy-to-bug.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20080901185111&#x2F;https:&#x2F;&#x2F;technolog...</a></div><br/><div id="40207893" class="c"><input type="checkbox" id="c-40207893" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207306">parent</a><span>|</span><a href="#40206184">next</a><span>|</span><label class="collapse" for="c-40207893">[-]</label><label class="expand" for="c-40207893">[4 more]</label></div><br/><div class="children"><div class="content">&gt; you leak [a bunch of stuff]<p>How?  Remember, the uncompressed text gets encrypted too.</div><br/><div id="40207967" class="c"><input type="checkbox" id="c-40207967" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207893">parent</a><span>|</span><a href="#40206184">next</a><span>|</span><label class="collapse" for="c-40207967">[-]</label><label class="expand" for="c-40207967">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in the article if you would bother to read it LOL. &quot;simply measuring the size of packets without decoding them can identify whole words and phrases with a high rate of accuracy . . . [the researchers] can search for chosen phrases within the encrypted data&quot;</div><br/><div id="40208013" class="c"><input type="checkbox" id="c-40208013" checked=""/><div class="controls bullet"><span class="by">lisper</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207967">parent</a><span>|</span><a href="#40206184">next</a><span>|</span><label class="collapse" for="c-40208013">[-]</label><label class="expand" for="c-40208013">[2 more]</label></div><br/><div class="children"><div class="content">Ah.<p>That article is about voice calls.  Totally different topic.  Nothing to do with UTF-8.</div><br/><div id="40208338" class="c"><input type="checkbox" id="c-40208338" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40208013">parent</a><span>|</span><a href="#40206184">next</a><span>|</span><label class="collapse" for="c-40208338">[-]</label><label class="expand" for="c-40208338">[1 more]</label></div><br/><div class="children"><div class="content">You seem to struggle with abstractions. By the way, how would you have felt if you didn&#x27;t have breakfast this morning? Just wondering.<p>Let&#x27;s put our thinking caps on and consider what would happen if that same insecure voice call were encoded as little packets of text (UTF-8, even! Gasp!). Let&#x27;s try to think of what might happen!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40206184" class="c"><input type="checkbox" id="c-40206184" checked=""/><div class="controls bullet"><span class="by">BalinKing</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205664">parent</a><span>|</span><a href="#40205805">prev</a><span>|</span><a href="#40206043">next</a><span>|</span><label class="collapse" for="c-40206184">[-]</label><label class="expand" for="c-40206184">[3 more]</label></div><br/><div class="children"><div class="content">Cryptography noob here: I&#x27;m confused by &quot;Encrypting without zipping doesn&#x27;t leak any information about the content.&quot; Logically speaking, if we compress first and therefore &quot;the content&quot; will now refer to &quot;the zipped content&quot;, doesn&#x27;t this mean we still can&#x27;t get any useful information?</div><br/><div id="40206572" class="c"><input type="checkbox" id="c-40206572" checked=""/><div class="controls bullet"><span class="by">thadt</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206184">parent</a><span>|</span><a href="#40206568">next</a><span>|</span><label class="collapse" for="c-40206572">[-]</label><label class="expand" for="c-40206572">[1 more]</label></div><br/><div class="children"><div class="content">Not OP, but &#x27;zipping and encrypting&#x27; one thing (a file for example) does not leak information by itself. The problem comes when an adversary is able to see the length of your encrypted data, and then can see how that length changes over time - especially if the attacker can control part of the input fed to the compressor.<p>So if you compressed the string &quot;Bob likes yams&quot; and I could convince you to append a string to it and compress again, then I could see how much the compressed length changed.<p>If the string I gave you was something already in your data then the string would compress more than it would if the string I gave you was not already in your data - &quot;Bob likes yams and potatoes&quot; will be larger than &quot;Bob likes yams likes Bob&quot;.<p>If the only thing I can see about your data is the length and how it changes under compression - and I can get you to compress that along with data that I hand to you - then eventually I can learn the secret parts of your data.</div><br/></div></div><div id="40206568" class="c"><input type="checkbox" id="c-40206568" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206184">parent</a><span>|</span><a href="#40206572">prev</a><span>|</span><a href="#40206043">next</a><span>|</span><label class="collapse" for="c-40206568">[-]</label><label class="expand" for="c-40206568">[1 more]</label></div><br/><div class="children"><div class="content">Encryption generally leaks the size of the plaintext.<p>This is true in both the compressed and non-compressed case. However with compression the size of the plaintext depends on the contents, so the leak of the size can matter more than when not using compression.<p>Even without compression this can matter sometimes. Imagine compressing &quot;yes&quot; vs &quot;no&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40206043" class="c"><input type="checkbox" id="c-40206043" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205271">parent</a><span>|</span><a href="#40205348">prev</a><span>|</span><a href="#40207377">next</a><span>|</span><label class="collapse" for="c-40206043">[-]</label><label class="expand" for="c-40206043">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a small price to pay for:<p>- not having to worry about byte order;<p>- and cruft like surrogate pairs;<p>- being able to pass the text through 8 bit string representations and even manipulate it as 8 bit in certain useful ways<p>Add bitmapped graphics to any text, and it will dominate the size.<p>Size of text is just noise in the world of streaming video, terabyte drives, fiber to the home ...</div><br/></div></div><div id="40207377" class="c"><input type="checkbox" id="c-40207377" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205271">parent</a><span>|</span><a href="#40206043">prev</a><span>|</span><a href="#40206650">next</a><span>|</span><label class="collapse" for="c-40207377">[-]</label><label class="expand" for="c-40207377">[1 more]</label></div><br/><div class="children"><div class="content">This comment is factually accurate and you snowflakes should stop downvoting it.</div><br/></div></div></div></div></div></div><div id="40206650" class="c"><input type="checkbox" id="c-40206650" checked=""/><div class="controls bullet"><span class="by">998244353</span><span>|</span><a href="#40204729">parent</a><span>|</span><a href="#40204873">prev</a><span>|</span><a href="#40205068">next</a><span>|</span><label class="collapse" for="c-40206650">[-]</label><label class="expand" for="c-40206650">[12 more]</label></div><br/><div class="children"><div class="content">Non-technical users don&#x27;t want to do that, and won&#x27;t understand any of that. That&#x27;s the unfortunate reality of developing software for people.<p>If Excel generates CSV files with some Windows-1234 encoding, then my &quot;import data from CSV&quot; function needs to handle that, in one way or another. A significant number of people generate CSV files from Excel and if these people upload these files into my application and I assume an incorrect encoding, they won&#x27;t care that Microsoft is using obsolete or weird defaults. They will see it as a bug in <i>my</i> program and demand that I fix <i>my</i> software. Even if Excel offers them a choice in encoding, they won&#x27;t understand any of that and more importantly <i>they don&#x27;t want to deal with that right now, they just want the thing to work</i>.</div><br/><div id="40207880" class="c"><input type="checkbox" id="c-40207880" checked=""/><div class="controls bullet"><span class="by">berkes</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206650">parent</a><span>|</span><a href="#40206923">next</a><span>|</span><label class="collapse" for="c-40207880">[-]</label><label class="expand" for="c-40207880">[1 more]</label></div><br/><div class="children"><div class="content">&gt; then my &quot;import data from CSV&quot; function needs to handle that, in one way or another.<p>It doesn&#x27;t. Well, maybe &quot;another&quot;.<p>Your function or even app doesn&#x27;t need to handle it. Here&#x27;s what we did on a bookkeeping app: remove all the heuristics, edge cases, broken-csv-handling and validation from all the CVS ingress points.<p>Add one service that did one thing: receive a CSV, and normalize it. All ingress points could now assume a clean, valid, UTF8 input. 
It removed thousands of LOCs, hundreds of issues from the backlog. It made debugging easy and it greatly helped the clients even.<p>At some point, we offered their import runs for download, we added the [original name]_clean.csv our normalized versions. Got praise for that. Clients loved that, as they were often well aware of their internal mess of broken CVSs.</div><br/></div></div><div id="40206923" class="c"><input type="checkbox" id="c-40206923" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206650">parent</a><span>|</span><a href="#40207880">prev</a><span>|</span><a href="#40207626">next</a><span>|</span><label class="collapse" for="c-40206923">[-]</label><label class="expand" for="c-40206923">[2 more]</label></div><br/><div class="children"><div class="content">OTOH if no one ever pushes back against entropy, your great-grandkids will still be dealing with Windows-1234 problems in 2100.</div><br/><div id="40207649" class="c"><input type="checkbox" id="c-40207649" checked=""/><div class="controls bullet"><span class="by">vincnetas</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206923">parent</a><span>|</span><a href="#40207626">next</a><span>|</span><label class="collapse" for="c-40207649">[-]</label><label class="expand" for="c-40207649">[1 more]</label></div><br/><div class="children"><div class="content">Hot to push back against entropy?<p>Could this work? Implement handling of ancient excel files in your SaaS product, but charge extra dollar for parsing legacy formats and provide information how to export correct files from excel next time :)</div><br/></div></div></div></div><div id="40207626" class="c"><input type="checkbox" id="c-40207626" checked=""/><div class="controls bullet"><span class="by">vaylian</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206650">parent</a><span>|</span><a href="#40206923">prev</a><span>|</span><a href="#40206676">next</a><span>|</span><label class="collapse" for="c-40207626">[-]</label><label class="expand" for="c-40207626">[2 more]</label></div><br/><div class="children"><div class="content">Plus, Excel really likes to use semicolons instead of commas for comma-separated-files. That&#x27;s another idiosyncrasy that programmers need to take into account.</div><br/><div id="40208279" class="c"><input type="checkbox" id="c-40208279" checked=""/><div class="controls bullet"><span class="by">iggldiggl</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207626">parent</a><span>|</span><a href="#40206676">next</a><span>|</span><label class="collapse" for="c-40208279">[-]</label><label class="expand" for="c-40208279">[1 more]</label></div><br/><div class="children"><div class="content">I think that happens mainly in those locales where a comma is the traditional decimal separator and the dot gets used for 1000s grouping.</div><br/></div></div></div></div><div id="40206676" class="c"><input type="checkbox" id="c-40206676" checked=""/><div class="controls bullet"><span class="by">unclebucknasty</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206650">parent</a><span>|</span><a href="#40207626">prev</a><span>|</span><a href="#40205068">next</a><span>|</span><label class="collapse" for="c-40206676">[-]</label><label class="expand" for="c-40206676">[6 more]</label></div><br/><div class="children"><div class="content">&gt;<i>A significant number of people generate CSV files from Excel and if these people upload these files into my application and I assume an incorrect encoding...</i><p>What if you just gave them instructions?</div><br/><div id="40206714" class="c"><input type="checkbox" id="c-40206714" checked=""/><div class="controls bullet"><span class="by">nkrisc</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206676">parent</a><span>|</span><a href="#40206717">next</a><span>|</span><label class="collapse" for="c-40206714">[-]</label><label class="expand" for="c-40206714">[2 more]</label></div><br/><div class="children"><div class="content">They’ll probably switch to the application that does it for them and just works, instead of the one telling them to do something they don’t really understand.</div><br/><div id="40207461" class="c"><input type="checkbox" id="c-40207461" checked=""/><div class="controls bullet"><span class="by">unclebucknasty</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206714">parent</a><span>|</span><a href="#40206717">next</a><span>|</span><label class="collapse" for="c-40207461">[-]</label><label class="expand" for="c-40207461">[1 more]</label></div><br/><div class="children"><div class="content">Selecting UTF-8 from a dropdown on the export doesn&#x27;t seem too onerous an ask. If that&#x27;s the differentiator between you and your competitors, then you might have bigger problems.</div><br/></div></div></div></div><div id="40206717" class="c"><input type="checkbox" id="c-40206717" checked=""/><div class="controls bullet"><span class="by">carlosjobim</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206676">parent</a><span>|</span><a href="#40206714">prev</a><span>|</span><a href="#40205068">next</a><span>|</span><label class="collapse" for="c-40206717">[-]</label><label class="expand" for="c-40206717">[3 more]</label></div><br/><div class="children"><div class="content">I think most people would rather get in their car, drive to the ocean, board a ship and join the navy, and come back after a few years abroad - than following some instructions on how to use the computer.</div><br/><div id="40208306" class="c"><input type="checkbox" id="c-40208306" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206717">parent</a><span>|</span><a href="#40207492">next</a><span>|</span><label class="collapse" for="c-40208306">[-]</label><label class="expand" for="c-40208306">[1 more]</label></div><br/><div class="children"><div class="content">Joining the navy and then be obliged to follow instructions on so many things you&#x27;d normally never even be ordered to do (because now you&#x27;re in the Navy, sailor! and there are three ways to do any thing: the right way, the wrong way, and the Navy way, and guess which way we use here in the Navy?), just to not follow some instructions on how to use the computer... is something I can actually imagine some people doing.</div><br/></div></div><div id="40207492" class="c"><input type="checkbox" id="c-40207492" checked=""/><div class="controls bullet"><span class="by">unclebucknasty</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206717">parent</a><span>|</span><a href="#40208306">prev</a><span>|</span><a href="#40205068">next</a><span>|</span><label class="collapse" for="c-40207492">[-]</label><label class="expand" for="c-40207492">[1 more]</label></div><br/><div class="children"><div class="content">Pretty funny, and probably some truth to that being a user sentiment.<p>OTOH, they have to follow <i>some</i> process to use the software. For just the CSV export, they already have to ensure column orders, values, formats, maybe headers, etc. Selecting UTF-8 from a dropdown seems like the easy part.</div><br/></div></div></div></div></div></div></div></div><div id="40205068" class="c"><input type="checkbox" id="c-40205068" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204729">parent</a><span>|</span><a href="#40206650">prev</a><span>|</span><a href="#40205194">next</a><span>|</span><label class="collapse" for="c-40205068">[-]</label><label class="expand" for="c-40205068">[7 more]</label></div><br/><div class="children"><div class="content">&gt; they turn it into utf-8 using a standalone program first<p>I took the article to be for people who would be writing that &quot;standalone program&quot;?<p>I have certainly been in a position where I was the person who had to deal with input text files with unknown encodings. There was no-one else to hand off the problem to.</div><br/><div id="40205190" class="c"><input type="checkbox" id="c-40205190" checked=""/><div class="controls bullet"><span class="by">0xffff2</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205068">parent</a><span>|</span><a href="#40205194">next</a><span>|</span><label class="collapse" for="c-40205190">[-]</label><label class="expand" for="c-40205190">[6 more]</label></div><br/><div class="children"><div class="content">In that case, you should be explicitly asking the user what the input format is.</div><br/><div id="40205397" class="c"><input type="checkbox" id="c-40205397" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205190">parent</a><span>|</span><a href="#40206579">next</a><span>|</span><label class="collapse" for="c-40205397">[-]</label><label class="expand" for="c-40205397">[3 more]</label></div><br/><div class="children"><div class="content">&gt; you should be explicitly asking the user what the input format is.<p>Me: &quot;I&#x27;ll make the program stop and ask the user.&quot;<p>Customer: &quot;No. We have 10 million files. Start by using heuristics for batch processing.&quot;</div><br/><div id="40205861" class="c"><input type="checkbox" id="c-40205861" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205397">parent</a><span>|</span><a href="#40206579">next</a><span>|</span><label class="collapse" for="c-40205861">[-]</label><label class="expand" for="c-40205861">[2 more]</label></div><br/><div class="children"><div class="content">And it&#x27;s usually worse, we have 10 million files coming from sources neither we nor our users control.<p>Or &quot;what do you mean ask them, they barely know what a jpeg is?!&quot;</div><br/><div id="40207045" class="c"><input type="checkbox" id="c-40207045" checked=""/><div class="controls bullet"><span class="by">MichaelZuo</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205861">parent</a><span>|</span><a href="#40206579">next</a><span>|</span><label class="collapse" for="c-40207045">[-]</label><label class="expand" for="c-40207045">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s someone that must be paying your invoices? Charge them extra for the extra work that needs to be done to sort things out.</div><br/></div></div></div></div></div></div><div id="40206579" class="c"><input type="checkbox" id="c-40206579" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205190">parent</a><span>|</span><a href="#40205397">prev</a><span>|</span><a href="#40205304">next</a><span>|</span><label class="collapse" for="c-40206579">[-]</label><label class="expand" for="c-40206579">[1 more]</label></div><br/><div class="children"><div class="content">Heckin no thank you!<p>The FCC ULS database records are stored in a combination of no fewer than three different encodings(1252, UTF8, and something else for a handful of German names) that vary per record.<p>When I brought this up they said something to the effect of: it&#x27;s already unicodes it has tilde letters!</div><br/></div></div><div id="40205304" class="c"><input type="checkbox" id="c-40205304" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205190">parent</a><span>|</span><a href="#40206579">prev</a><span>|</span><a href="#40205194">next</a><span>|</span><label class="collapse" for="c-40205304">[-]</label><label class="expand" for="c-40205304">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I dunno, got it from a friend on a USB stick&quot;</div><br/></div></div></div></div></div></div><div id="40205194" class="c"><input type="checkbox" id="c-40205194" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#40204729">parent</a><span>|</span><a href="#40205068">prev</a><span>|</span><a href="#40207408">next</a><span>|</span><label class="collapse" for="c-40205194">[-]</label><label class="expand" for="c-40205194">[29 more]</label></div><br/><div class="children"><div class="content">&gt; We don&#x27;t go &quot;oh that input that&#x27;s supposed to be json? It looks like a malformed csv file, let&#x27;s silently have a go at fixing that up for you&quot;. Or at least we shouldn&#x27;t, some software probably does.<p>What ever happened to the Robustness Principle[1]? I think the entire comment section of this article has forgotten it. IMO the best software accepts many formats and &quot;deals with it,&quot; or at least attempts to, rather than just exiting with &quot;Hahah, Error 19923 Wrong Input Format. Try again, loser.&quot;<p>1: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robustness_principle" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robustness_principle</a></div><br/><div id="40205273" class="c"><input type="checkbox" id="c-40205273" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40205350">next</a><span>|</span><label class="collapse" for="c-40205273">[-]</label><label class="expand" for="c-40205273">[8 more]</label></div><br/><div class="children"><div class="content">We collectively discovered that we were underestimating the long term costs, by a <i>lot</i>, so its lustre has faded. This is in some sense relatively recent, so word is still getting around, as the programming world does not move as quickly as it fancies itself to.<p>If you&#x27;d like to see why, read the HTML 5 parsing portion of the spec. Slowly and carefully. Try to understand what is going on and why. A skim will not reveal the issue.  You will come to a much greater understanding of the problem.
Some study of what had happened when we tried to upgrade TCP (not the 4-&gt;6 transition, that&#x27;s its own thing) and why the only two protocols that can practically exist on the Internet anymore are TCP and UDP may also be of interest.</div><br/><div id="40205529" class="c"><input type="checkbox" id="c-40205529" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205273">parent</a><span>|</span><a href="#40207258">next</a><span>|</span><label class="collapse" for="c-40205529">[-]</label><label class="expand" for="c-40205529">[1 more]</label></div><br/><div class="children"><div class="content">RFC 9413 “maintaining robust protocols” <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;rfc9413&#x2F;" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;rfc9413&#x2F;</a> 
was originally titled “The Harmful Consequences of the Robustness Principle
(draft-thomson-postel-was-wrong)”
<a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;draft-thomson-postel-was-wrong&#x2F;" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;draft-thomson-postel-was-wr...</a> and it has several examples</div><br/></div></div><div id="40207258" class="c"><input type="checkbox" id="c-40207258" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205273">parent</a><span>|</span><a href="#40205529">prev</a><span>|</span><a href="#40205492">next</a><span>|</span><label class="collapse" for="c-40207258">[-]</label><label class="expand" for="c-40207258">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t HTML5 prove that such an approach was more effective tho?<p>HTML was a massive success, while at the same time when we tried having a strict spec with XHTML, we failed miserably.<p>I mean, the purist in me wants strictness but it seems lousyness wins.</div><br/><div id="40207520" class="c"><input type="checkbox" id="c-40207520" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207258">parent</a><span>|</span><a href="#40205492">next</a><span>|</span><label class="collapse" for="c-40207520">[-]</label><label class="expand" for="c-40207520">[1 more]</label></div><br/><div class="children"><div class="content">I think the particular domain matters.<p>The explosion of the web happened in no small part because of how easy it was to write some HTML and get a basic, working webpage out of it.  If you nested some tags the wrong way and the browser just put up an error page, rather than doing a (usually) pretty good job figuring out what you actually meant, people would get frustrated faster and not bother with it at all.<p>But imagine if our C&#x2F;C++&#x2F;Java&#x2F;Rust&#x2F;Go&#x2F;etc. compilers were like &quot;syntax error, but ehhhhh you <i>probably</i> meant to put a closing brace there, so let&#x27;s just pretend you did&quot;.  That would be a nightmare of bugs and security issues.<p>The difficulty in drawing a line in the sand and sticking to the spec, though, is that of user blame.  Let&#x27;s say you implement a spec perfectly -- even if you are the originator of the spec -- and then someone comes along and builds something of their own that writes out files that don&#x27;t conform to the spec.  Your software throws up an error and says &quot;invalid file&quot;, but the other piece of software can read it back in just fine.  Users don&#x27;t know or care about specifications; they just know that your software &quot;doesn&#x27;t work&quot; for the files they have, and the other software does.  If you try to tell them that the file is bad, and the other software has a bug, they really won&#x27;t care.</div><br/></div></div></div></div><div id="40205492" class="c"><input type="checkbox" id="c-40205492" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205273">parent</a><span>|</span><a href="#40207258">prev</a><span>|</span><a href="#40205350">next</a><span>|</span><label class="collapse" for="c-40205492">[-]</label><label class="expand" for="c-40205492">[4 more]</label></div><br/><div class="children"><div class="content">Can you give a hint as to what the issue is that one should find reading a portion of the HTML 5 spec? Or is it genuinely unexplainable without experiencing something first-hand?</div><br/><div id="40205566" class="c"><input type="checkbox" id="c-40205566" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205492">parent</a><span>|</span><a href="#40205350">next</a><span>|</span><label class="collapse" for="c-40205566">[-]</label><label class="expand" for="c-40205566">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;&gt; the best software accepts many formats and &quot;deals with it,&quot;<p>&gt;&gt; We collectively discovered that we were underestimating the long term costs, by a lot, so its lustre has faded.<p>&gt;&gt; If you&#x27;d like to see why, read the HTML 5 parsing portion of the spec.<p>&gt; Can you give a hint as to what the issue is that one should find reading a portion of the HTML 5 spec<p>I think the point was that the HTML 5 spec tries to parse all kinds of weird input instead of drawing a line in the sand and forcing the input to follow a simple format?</div><br/><div id="40205889" class="c"><input type="checkbox" id="c-40205889" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205566">parent</a><span>|</span><a href="#40205350">next</a><span>|</span><label class="collapse" for="c-40205889">[-]</label><label class="expand" for="c-40205889">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s ungodly complicated to be sure but websites from 30 years ago also still render unmodified so it&#x27;s hard to say it&#x27;s bad all of the time.</div><br/><div id="40206162" class="c"><input type="checkbox" id="c-40206162" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205889">parent</a><span>|</span><a href="#40205350">next</a><span>|</span><label class="collapse" for="c-40206162">[-]</label><label class="expand" for="c-40206162">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t bad. In fact it&#x27;s quite good. But it is very much a case of closing the barn door after the animals got out. You see in the standard that the effort was put to corral them back in, and I&#x27;m very glad they did, but it certainly was not free.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40205350" class="c"><input type="checkbox" id="c-40205350" checked=""/><div class="controls bullet"><span class="by">travisb</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40205273">prev</a><span>|</span><a href="#40206608">next</a><span>|</span><label class="collapse" for="c-40205350">[-]</label><label class="expand" for="c-40205350">[1 more]</label></div><br/><div class="children"><div class="content">Among other things, security became a concern.<p>Being lenient is all well and good when the consequences are mild. When the consequences of misinterpreting or interpreting differently to a second implementation becomes costly, such as a security exploit, then the Robustness Principle becomes less obviously a win.<p>It&#x27;s important to understand that every implementation will try to fix-up formatting problems in their own way unique to their particular implementation. From that you get various desync or reinterpretation attacks (eg. HTTP request smuggling).</div><br/></div></div><div id="40206608" class="c"><input type="checkbox" id="c-40206608" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40205350">prev</a><span>|</span><a href="#40206004">next</a><span>|</span><label class="collapse" for="c-40206608">[-]</label><label class="expand" for="c-40206608">[1 more]</label></div><br/><div class="children"><div class="content">That is fine in contexts where a wrong guess does no harm.<p>But that is not always the case, and e.g. silently &quot;fixing&quot; text encoding issues can often corrupt the data if you get it wrong.<p>By all means offer options of you want, but if you do flag <i>very clearly</i> to the user that they&#x27;re taking a risk of corrupting the data unless any errors are <i>very</i> apparent and trivial to undo.</div><br/></div></div><div id="40206004" class="c"><input type="checkbox" id="c-40206004" checked=""/><div class="controls bullet"><span class="by">david422</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40206608">prev</a><span>|</span><a href="#40205420">next</a><span>|</span><label class="collapse" for="c-40206004">[-]</label><label class="expand" for="c-40206004">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;deals with it,&quot;<p>This basically loses data integrity if it&#x27;s wrong though.<p>You <i>might</i> want to do that with human input if it&#x27;s helpful to the user - ie user enters a phone number and you strip dashes etc. But if it&#x27;s machine to machine, it should just follow the spec.</div><br/></div></div><div id="40205420" class="c"><input type="checkbox" id="c-40205420" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40206004">prev</a><span>|</span><a href="#40205508">next</a><span>|</span><label class="collapse" for="c-40205420">[-]</label><label class="expand" for="c-40205420">[9 more]</label></div><br/><div class="children"><div class="content">It was a horrible idea. The real robustness principle is &quot;Follow the spec&quot;.</div><br/><div id="40205455" class="c"><input type="checkbox" id="c-40205455" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205420">parent</a><span>|</span><a href="#40205508">next</a><span>|</span><label class="collapse" for="c-40205455">[-]</label><label class="expand" for="c-40205455">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried telling users &quot;sorry, your file isn&#x27;t to spec&quot;, and they say &quot;but it works with &lt;competitor&gt;&quot;, and that ideology flies right out the window, along with their money.</div><br/><div id="40205825" class="c"><input type="checkbox" id="c-40205825" checked=""/><div class="controls bullet"><span class="by">ryandrake</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205455">parent</a><span>|</span><a href="#40206164">next</a><span>|</span><label class="collapse" for="c-40205825">[-]</label><label class="expand" for="c-40205825">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. &quot;Accepting and trying&quot; is how a lot of popular software won their market. Look at HN&#x27;s favorite media player, VLC. In the past, media player software were horrible, refusing to play all but the most tightly constrained set of allowed containers&#x2F;codecs. I remember spending the early 2000s trying to get Windows Media Player to play MPEGs by downloading codec packs and trying to cast secret spells into the Windows Registry. Yuck! Then along comes VLC which accepts whatever you throw at it, and that software is basically everywhere now. You can throw line noise at VLC and it will try its best to play something!</div><br/></div></div><div id="40206164" class="c"><input type="checkbox" id="c-40206164" checked=""/><div class="controls bullet"><span class="by">silotis</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205455">parent</a><span>|</span><a href="#40205825">prev</a><span>|</span><a href="#40206133">next</a><span>|</span><label class="collapse" for="c-40206164">[-]</label><label class="expand" for="c-40206164">[2 more]</label></div><br/><div class="children"><div class="content">The trick is to enforce conformance right from the start in the first implementation of a format. Shipping a product that doesn&#x27;t interop with the existing tools is a non-starter so the devs will have to fix their shit first.<p>As you say, unfortunately the genie cannot be put back in the bottle for formats that already have defective implementations in the wild.</div><br/><div id="40207360" class="c"><input type="checkbox" id="c-40207360" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206164">parent</a><span>|</span><a href="#40206133">next</a><span>|</span><label class="collapse" for="c-40207360">[-]</label><label class="expand" for="c-40207360">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that unless you restrict everyone else you&#x27;ll get your own product not to interact with *new&quot; tools too.<p>E.g. you produce valid .wat files, but my software which also outputs those has some bits screwed up.<p>My program can read both .wat but yours can&#x27;t, but I have 5% market share.<p>Your users complain they sometimes receive files your software can&#x27;t read while the competitor can. Do you tell them &quot;well that file is invalid, tell whoever sent it to you to change the software they use&quot;?<p>The genie can&#x27;t stay in the bottle unless you have some sort of certification authority and even that may not be enough (see USB)</div><br/></div></div></div></div><div id="40206133" class="c"><input type="checkbox" id="c-40206133" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205455">parent</a><span>|</span><a href="#40206164">prev</a><span>|</span><a href="#40206398">next</a><span>|</span><label class="collapse" for="c-40206133">[-]</label><label class="expand" for="c-40206133">[2 more]</label></div><br/><div class="children"><div class="content">People will pay you to do all kinds of terrible not-robust things.</div><br/><div id="40208336" class="c"><input type="checkbox" id="c-40208336" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206133">parent</a><span>|</span><a href="#40206398">next</a><span>|</span><label class="collapse" for="c-40208336">[-]</label><label class="expand" for="c-40208336">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and that&#x27;s why Postel&#x27;s law is more of an empirical observation (a law of nature, if you will) on which software survives and which doesn&#x27;t. You may dislike it but that won&#x27;t make it go away.</div><br/></div></div></div></div><div id="40206398" class="c"><input type="checkbox" id="c-40206398" checked=""/><div class="controls bullet"><span class="by">jimjimjim</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205455">parent</a><span>|</span><a href="#40206133">prev</a><span>|</span><a href="#40205807">next</a><span>|</span><label class="collapse" for="c-40206398">[-]</label><label class="expand" for="c-40206398">[1 more]</label></div><br/><div class="children"><div class="content">This is the answer.<p>The customer does not know. They just want it to work. They may be using something that someone else gave them. The original source system of the file may not be changeable. But most importantly, their boss just wants it to work. or else.</div><br/></div></div><div id="40205807" class="c"><input type="checkbox" id="c-40205807" checked=""/><div class="controls bullet"><span class="by">pixl97</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205455">parent</a><span>|</span><a href="#40206398">prev</a><span>|</span><a href="#40205508">next</a><span>|</span><label class="collapse" for="c-40205807">[-]</label><label class="expand" for="c-40205807">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s when you ask to see their file, then hack &lt;competitors&gt; system.</div><br/></div></div></div></div></div></div><div id="40205508" class="c"><input type="checkbox" id="c-40205508" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40205420">prev</a><span>|</span><a href="#40207503">next</a><span>|</span><label class="collapse" for="c-40205508">[-]</label><label class="expand" for="c-40205508">[1 more]</label></div><br/><div class="children"><div class="content">Seems like you&#x27;ve uploaded a jpeg. Let me OCR that into CSV for you. Hmm, no text found. Let&#x27;s pass it to a multimodal LLM.</div><br/></div></div><div id="40207503" class="c"><input type="checkbox" id="c-40207503" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40205508">prev</a><span>|</span><a href="#40207287">next</a><span>|</span><label class="collapse" for="c-40207503">[-]</label><label class="expand" for="c-40207503">[1 more]</label></div><br/><div class="children"><div class="content">The article addresses this, that current thinking in many places is that the robustness principle &#x2F; Postel&#x27;s Law maybe wasn&#x27;t the best idea.<p>If you reject malformed input, then the person who created it has to go back and fix it and try again.  If you interpret malformed input the best you can (and get it right), then everyone else implementing the same thing in the future now also has to implement your heuristics and workarounds.  The malformed input effectively becomes a part of the spec.<p>This is why HTML &amp; CSS are the garbage dump they are today, and why different browsers still don&#x27;t always display pages exactly alike.  The reason HTML5 exists is because people finally just gave up and decided to standardize all the broken behavior that was floating around in the wild.  Pre-HTML5, the web was an outright dumpster fire of browser compatibility issues (as opposed to the mere garbage dump we have today).<p>Anyway, it&#x27;s not really important to try to convince you that Postel&#x27;s Law is bad; what&#x27;s important is that you know that many people are starting to think it&#x27;s bad, and there&#x27;s no longer any strong consensus that it was ever a good thing.</div><br/></div></div><div id="40207287" class="c"><input type="checkbox" id="c-40207287" checked=""/><div class="controls bullet"><span class="by">lamontcg</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40207503">prev</a><span>|</span><a href="#40206078">next</a><span>|</span><label class="collapse" for="c-40207287">[-]</label><label class="expand" for="c-40207287">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve lived through dealing with non-UTF8 encoding issues and it was a truly gigantic pain in the ass.  I&#x27;m much more on the side now of people who only want to deal with UTF8 and fully support software that tells any other encoding to go pound sand.  The harder life gets for people who use other encodings (yes, particularly Microsoft) the more incentive they have to eventually get on board and stop costing everyone time and effort managing all this nonsense.</div><br/></div></div><div id="40206078" class="c"><input type="checkbox" id="c-40206078" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40207287">prev</a><span>|</span><a href="#40206275">next</a><span>|</span><label class="collapse" for="c-40206078">[-]</label><label class="expand" for="c-40206078">[3 more]</label></div><br/><div class="children"><div class="content">What happened to it:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robustness_principle#Criticism" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robustness_principle#Criticism</a><p>Postel&#x27;s Law doesn&#x27;t pass a software engineering smell test.<p>The idea that software should guess and repair bad inputs is deeply flawed. It is a security threat and a source of enshittification.</div><br/><div id="40206501" class="c"><input type="checkbox" id="c-40206501" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206078">parent</a><span>|</span><a href="#40206275">next</a><span>|</span><label class="collapse" for="c-40206501">[-]</label><label class="expand" for="c-40206501">[2 more]</label></div><br/><div class="children"><div class="content">&gt; enshittification<p>I am so over this word.</div><br/><div id="40207735" class="c"><input type="checkbox" id="c-40207735" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40206501">parent</a><span>|</span><a href="#40206275">next</a><span>|</span><label class="collapse" for="c-40207735">[-]</label><label class="expand" for="c-40207735">[1 more]</label></div><br/><div class="children"><div class="content">I put a TODO item in my calendar for December 2024 to stop using it. :)</div><br/></div></div></div></div></div></div><div id="40206275" class="c"><input type="checkbox" id="c-40206275" checked=""/><div class="controls bullet"><span class="by">jppittma</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40206078">prev</a><span>|</span><a href="#40205560">next</a><span>|</span><label class="collapse" for="c-40206275">[-]</label><label class="expand" for="c-40206275">[1 more]</label></div><br/><div class="children"><div class="content">I think people have collectively decided that they want their programs stupid and predictable, rather than smart and unwieldy.</div><br/></div></div><div id="40205560" class="c"><input type="checkbox" id="c-40205560" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40205194">parent</a><span>|</span><a href="#40206275">prev</a><span>|</span><a href="#40207408">next</a><span>|</span><label class="collapse" for="c-40205560">[-]</label><label class="expand" for="c-40205560">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What ever happened to the Robustness Principle<p>Bush hid the facts</div><br/></div></div></div></div><div id="40207408" class="c"><input type="checkbox" id="c-40207408" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40204729">parent</a><span>|</span><a href="#40205194">prev</a><span>|</span><a href="#40205040">next</a><span>|</span><label class="collapse" for="c-40207408">[-]</label><label class="expand" for="c-40207408">[1 more]</label></div><br/><div class="children"><div class="content">Solutions that require lots of unrelated people to start doing something a different way are not really solutions.</div><br/></div></div><div id="40205040" class="c"><input type="checkbox" id="c-40205040" checked=""/><div class="controls bullet"><span class="by">amarshall</span><span>|</span><a href="#40204729">parent</a><span>|</span><a href="#40207408">prev</a><span>|</span><a href="#40207470">next</a><span>|</span><label class="collapse" for="c-40205040">[-]</label><label class="expand" for="c-40205040">[1 more]</label></div><br/><div class="children"><div class="content">&gt; some software probably does.<p>Browsers do, kind of <a href="https:&#x2F;&#x2F;mimesniff.spec.whatwg.org&#x2F;#rules-for-identifying-an-unknown-mime-type" rel="nofollow">https:&#x2F;&#x2F;mimesniff.spec.whatwg.org&#x2F;#rules-for-identifying-an-...</a></div><br/></div></div><div id="40207470" class="c"><input type="checkbox" id="c-40207470" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#40204729">parent</a><span>|</span><a href="#40205040">prev</a><span>|</span><a href="#40205931">next</a><span>|</span><label class="collapse" for="c-40207470">[-]</label><label class="expand" for="c-40207470">[3 more]</label></div><br/><div class="children"><div class="content">&gt; We don&#x27;t go &quot;oh that input that&#x27;s supposed to be json? It looks like a malformed csv file, let&#x27;s silently have a go at fixing that up for you&quot;. Or at least we shouldn&#x27;t, some software probably does.<p>Browsers used to have a menu option to choose the encoding you wanted to use to decode the page.<p>In Firefox, that&#x27;s been replaced by the magic option &quot;Repair Text Encoding&quot;. There is no justification for this.<p>They seem to be in the process of disabling that option too:<p>&gt; Note: On most modern pages, the Repair Text Encoding menu item will be greyed-out because character encoding changes are not supported.<p>( <a href="https:&#x2F;&#x2F;support.mozilla.org&#x2F;en-US&#x2F;kb&#x2F;text-encoding-no-longer-available-firefox-menu" rel="nofollow">https:&#x2F;&#x2F;support.mozilla.org&#x2F;en-US&#x2F;kb&#x2F;text-encoding-no-longer...</a> )<p>This note is logical gibberish; encoding isn&#x27;t something that has to be supported by the <i>page</i>. Decoding is a choice by the browser!</div><br/><div id="40208116" class="c"><input type="checkbox" id="c-40208116" checked=""/><div class="controls bullet"><span class="by">shiomiru</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207470">parent</a><span>|</span><a href="#40208092">next</a><span>|</span><label class="collapse" for="c-40208116">[-]</label><label class="expand" for="c-40208116">[1 more]</label></div><br/><div class="children"><div class="content">It seems the decision was made in the name of security:<p><a href="https:&#x2F;&#x2F;hsivonen.fi&#x2F;no-encoding-menu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hsivonen.fi&#x2F;no-encoding-menu&#x2F;</a><p>&gt; Supporting the specific manually-selectable encodings caused significant complexity in the HTML parser when trying to support the feature securely (i.e. not allowing certain encodings to be overridden). With the current approach, the parser needs to know of one flag to force chardetng, which the parser has to be able to run in other situations anyway, to run.<p>&gt; Elaborate UI surface for a niche feature risks the whole feature getting removed<p>&gt; Telemetry [...] suggested that users aren’t that good at choosing correctly manually.<p>In other words, it&#x27;s trying to protect users from themselves by dumbing down the browser. (Never mind that people who know what they are doing have probably also turned off telemetry...)</div><br/></div></div><div id="40208092" class="c"><input type="checkbox" id="c-40208092" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#40204729">root</a><span>|</span><a href="#40207470">parent</a><span>|</span><a href="#40208116">prev</a><span>|</span><a href="#40205931">next</a><span>|</span><label class="collapse" for="c-40208092">[-]</label><label class="expand" for="c-40208092">[1 more]</label></div><br/><div class="children"><div class="content">Probably because most websites now send a correct encoding header or meta Tag, so the user changing can only make it wrong. (Assuming no encoding header is wrong, which happens in reality)</div><br/></div></div></div></div><div id="40205931" class="c"><input type="checkbox" id="c-40205931" checked=""/><div class="controls bullet"><span class="by">SuperNinKenDo</span><span>|</span><a href="#40204729">parent</a><span>|</span><a href="#40207470">prev</a><span>|</span><a href="#40204933">next</a><span>|</span><label class="collapse" for="c-40205931">[-]</label><label class="expand" for="c-40205931">[1 more]</label></div><br/><div class="children"><div class="content">Not every encoding can make a round trip through Unicode without you writing ad hoc handling code for every single one. There&#x27;s a number of reasons some of these are still in use and Unicode destroying information is one of them.</div><br/></div></div></div></div><div id="40204933" class="c"><input type="checkbox" id="c-40204933" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40204729">prev</a><span>|</span><a href="#40208665">next</a><span>|</span><label class="collapse" for="c-40204933">[-]</label><label class="expand" for="c-40204933">[23 more]</label></div><br/><div class="children"><div class="content">If you give me a computer timestamp without a timezone, I can and will assume it&#x27;s in UTC. It might not be, but if it&#x27;s not and I process it as though it is, and the sender doesn&#x27;t like the results, that&#x27;s on them. I&#x27;m willing to spend approximately zero effort trying to guess what nonstandard thing they&#x27;re trying to send me unless they&#x27;re paying me or my company a whole lot of money, in which case I&#x27;ll convert it to UTC upon import and continue on from there.<p>Same with UTF-8. Life&#x27;s too short for bothering with anything else today. I&#x27;ll deal with some weird janky encoding for the right price, but the first thing I&#x27;d do is convert it to UTF-8. Damned if I&#x27;m going to complicate the innards of my code with special case code paths for non-UTF-8.<p>If there were some inherent issue with UTF-8 that made it significantly worse than some other encoding for a given task, I&#x27;d be sympathetic to that explanation and wouldn&#x27;t be such a pain in the neck about this. For instance, if it were the case that it did a bad job of encoding Mandarin or Urdu or Xhosa or Persian, and the people who use those languages strongly preferred to use something else, I&#x27;d understand. However, I&#x27;ve never heard a viable explanation for <i>not</i> using UTF-8 other than legacy software support, and if you want to continue to use something ancient and weird, it&#x27;s on you to adapt it to the rest of the world because they&#x27;re definitely not going to adapt the world to you.</div><br/><div id="40205852" class="c"><input type="checkbox" id="c-40205852" checked=""/><div class="controls bullet"><span class="by">hnick</span><span>|</span><a href="#40204933">parent</a><span>|</span><a href="#40205048">next</a><span>|</span><label class="collapse" for="c-40205852">[-]</label><label class="expand" for="c-40205852">[3 more]</label></div><br/><div class="children"><div class="content">It depends on the domain. If you are writing calendar software, it is legitimate to have &quot;floating time&quot; i.e. your medication reminder is at 7pm every day, regardless of time zone, travel, or anything else.<p>Unfortunately Google and many other companies have decided UTC is the only way, so this causes issues with ICS files that use that format sometimes when they are generating their helpful popups in the GMail inbox.</div><br/><div id="40206561" class="c"><input type="checkbox" id="c-40206561" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205852">parent</a><span>|</span><a href="#40205048">next</a><span>|</span><label class="collapse" for="c-40206561">[-]</label><label class="expand" for="c-40206561">[2 more]</label></div><br/><div class="children"><div class="content">Those aren’t timestamps. They’re descriptions of how to select them.</div><br/><div id="40206754" class="c"><input type="checkbox" id="c-40206754" checked=""/><div class="controls bullet"><span class="by">hnick</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40206561">parent</a><span>|</span><a href="#40205048">next</a><span>|</span><label class="collapse" for="c-40206754">[-]</label><label class="expand" for="c-40206754">[1 more]</label></div><br/><div class="children"><div class="content">Oh yes true. Somehow I missed that important detail.</div><br/></div></div></div></div></div></div><div id="40205048" class="c"><input type="checkbox" id="c-40205048" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40204933">parent</a><span>|</span><a href="#40205852">prev</a><span>|</span><a href="#40208585">next</a><span>|</span><label class="collapse" for="c-40205048">[-]</label><label class="expand" for="c-40205048">[14 more]</label></div><br/><div class="children"><div class="content">&gt; For instance, if it were the case that it did a bad job of encoding Mandarin<p>I don&#x27;t know if you picked this example on purpose, but using UTF-8 to encode Chinese is 50% larger than the old encoding (GB2312). I remember people cared about this like twenty years ago. I don&#x27;t know of anyone that still cares about this encoding inefficiency. Any compression algorithm is able to remove such encoding inefficiency while using negligible CPU to decompress.</div><br/><div id="40205182" class="c"><input type="checkbox" id="c-40205182" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205048">parent</a><span>|</span><a href="#40205456">next</a><span>|</span><label class="collapse" for="c-40205182">[-]</label><label class="expand" for="c-40205182">[7 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t seem like the worst issue imaginable. I doubt there are too many cases where every byte counts, text uses a significant portion of the available space, and compression is unavailable or inefficient. If we were still cramming floppies full of text files destined for very slow computers, that&#x27;d be one thing. Web pages full of uncompressed text are still either so small that it&#x27;s a moot point or so huge with JS, images, and fonts that the relative text size isn&#x27;t that significant.<p>Which is all to say that you&#x27;re right, but I can&#x27;t imagine that it&#x27;s more than a theoretical nuisance outside some extremely niche cases.</div><br/><div id="40205364" class="c"><input type="checkbox" id="c-40205364" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205182">parent</a><span>|</span><a href="#40205456">next</a><span>|</span><label class="collapse" for="c-40205364">[-]</label><label class="expand" for="c-40205364">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Web pages full of uncompressed text<p>Are basically non existent. Almost all modern web servers transparently compress html. Sending uncompressed text over the wire is extremely rare.</div><br/><div id="40205483" class="c"><input type="checkbox" id="c-40205483" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205364">parent</a><span>|</span><a href="#40205456">next</a><span>|</span><label class="collapse" for="c-40205483">[-]</label><label class="expand" for="c-40205483">[5 more]</label></div><br/><div class="children"><div class="content">They shouldn&#x27;t be non-existent. Zip-then-encrypt is not secure due to information leakage.<p>EDIT: also, it&#x27;s not safe—message length is dependent on the values of the plaintext bytes, period. i&#x27;m not saying don&#x27;t live dangerously, i&#x27;m just saying live dangerously knowing</div><br/><div id="40205617" class="c"><input type="checkbox" id="c-40205617" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205483">parent</a><span>|</span><a href="#40206453">next</a><span>|</span><label class="collapse" for="c-40205617">[-]</label><label class="expand" for="c-40205617">[1 more]</label></div><br/><div class="children"><div class="content">The information leakage problem occurs when compression is done in the TLS layer, because then the compression context includes both headers (with cookies) and bodies (containing potentially attacker-controlled data). But if you do compression at the HTTP layer using its Transfer-Encoding then the compression context only covers the body, which is safe.</div><br/></div></div><div id="40206453" class="c"><input type="checkbox" id="c-40206453" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205483">parent</a><span>|</span><a href="#40205617">prev</a><span>|</span><a href="#40205692">next</a><span>|</span><label class="collapse" for="c-40206453">[-]</label><label class="expand" for="c-40206453">[1 more]</label></div><br/><div class="children"><div class="content">What you are talking about is generally referred to as the &quot;BREACH&quot; attack. While there may theoretically be scenarios where it is relavent, in practise it almost never is so the industry has largely decided to ignore it (its important to distinguish this from the CRIME attack which is about http headers instead of the response body which has a much higher liklihood of being exploitable while still being hard).<p>The reason its usually safe is that to exploit you need:<p>- a secret inside the html file<p>- the secret has to stay constant and cannot change (since it is adaptive attack. CSRF tokens and similar things usually change on every request so cannot be attacked)<p>- the attacker has to have a method to inject something into the html file and repeat it for different payloads<p>- the attacker has to be able to see how many bytes the response is (or some other side channel)<p>- the attacker is not one of the ends of the communication (no point to attack yourself)<p>Having all these requirements met is very unlikely.</div><br/></div></div><div id="40205692" class="c"><input type="checkbox" id="c-40205692" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205483">parent</a><span>|</span><a href="#40206453">prev</a><span>|</span><a href="#40205456">next</a><span>|</span><label class="collapse" for="c-40205692">[-]</label><label class="expand" for="c-40205692">[2 more]</label></div><br/><div class="children"><div class="content">Do you often send raw bitmaps for the same reason?</div><br/><div id="40207866" class="c"><input type="checkbox" id="c-40207866" checked=""/><div class="controls bullet"><span class="by">iraqmtpizza</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205692">parent</a><span>|</span><a href="#40205456">next</a><span>|</span><label class="collapse" for="c-40207866">[-]</label><label class="expand" for="c-40207866">[1 more]</label></div><br/><div class="children"><div class="content">Do you often get completely pwned and have your encrypted calls transcribed by people eating doughnuts because you thought it was safe to compress sensitive data before encrypting? <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20080901185111&#x2F;https:&#x2F;&#x2F;technology.newscientist.com&#x2F;channel&#x2F;tech&#x2F;dn14124-compressed-web-phone-calls-are-easy-to-bug.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20080901185111&#x2F;https:&#x2F;&#x2F;technolog...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40205456" class="c"><input type="checkbox" id="c-40205456" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205048">parent</a><span>|</span><a href="#40205182">prev</a><span>|</span><a href="#40205087">next</a><span>|</span><label class="collapse" for="c-40205456">[-]</label><label class="expand" for="c-40205456">[4 more]</label></div><br/><div class="children"><div class="content">For Asian languages, UTF-8 is basically the same size as any other encoding when compressed[0] (and you should be using compression if you care about space) so in practice there is no data size advantage to using non-standard encodings.<p>[0] <a href="https:&#x2F;&#x2F;utf8everywhere.org&#x2F;#asian" rel="nofollow">https:&#x2F;&#x2F;utf8everywhere.org&#x2F;#asian</a></div><br/><div id="40206363" class="c"><input type="checkbox" id="c-40206363" checked=""/><div class="controls bullet"><span class="by">neild</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205456">parent</a><span>|</span><a href="#40205087">next</a><span>|</span><label class="collapse" for="c-40206363">[-]</label><label class="expand" for="c-40206363">[3 more]</label></div><br/><div class="children"><div class="content">In addition, Chinese characters encode more information than English letters, so a text written in Chinese will generally consume fewer bytes than the same text in English even when using UTF-8.<p>(Consider: Horse is five letters, but 馬 is one character. Even at three bytes per character, Chinese wins.)</div><br/><div id="40207474" class="c"><input type="checkbox" id="c-40207474" checked=""/><div class="controls bullet"><span class="by">Panzer04</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40206363">parent</a><span>|</span><a href="#40206570">next</a><span>|</span><label class="collapse" for="c-40207474">[-]</label><label class="expand" for="c-40207474">[1 more]</label></div><br/><div class="children"><div class="content">Presumably that derives from the overhead of encoding an english character as a full byte? Given there&#x27;s only 26 characters normally, you could fit that into 5 bits instead, which funnily enough does actually line up with the chinese character encoding (5x5 vs 1x24).</div><br/></div></div><div id="40206570" class="c"><input type="checkbox" id="c-40206570" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40206363">parent</a><span>|</span><a href="#40207474">prev</a><span>|</span><a href="#40205087">next</a><span>|</span><label class="collapse" for="c-40206570">[-]</label><label class="expand" for="c-40206570">[1 more]</label></div><br/><div class="children"><div class="content">True, but even then you wouldn’t want to store it egregiously badly.</div><br/></div></div></div></div></div></div><div id="40205087" class="c"><input type="checkbox" id="c-40205087" checked=""/><div class="controls bullet"><span class="by">PeterisP</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205048">parent</a><span>|</span><a href="#40205456">prev</a><span>|</span><a href="#40208585">next</a><span>|</span><label class="collapse" for="c-40205087">[-]</label><label class="expand" for="c-40205087">[2 more]</label></div><br/><div class="children"><div class="content">A key aspect is that nowadays we rarely encode pure text - while other encodings are more efficient for encoding pure Mandarin, nowadays a &quot;Mandarin document&quot; may be an HTML or JSON or XML file where less than half of the characters are from CJK codespace, and the rest come from all the formatting overhead which is in the 7-bit ASCII range, and UTF-8 works great for such combined content.</div><br/><div id="40205183" class="c"><input type="checkbox" id="c-40205183" checked=""/><div class="controls bullet"><span class="by">tomoyoirl</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40205087">parent</a><span>|</span><a href="#40208585">next</a><span>|</span><label class="collapse" for="c-40205183">[-]</label><label class="expand" for="c-40205183">[1 more]</label></div><br/><div class="children"><div class="content">To say nothing of mod_gzip</div><br/></div></div></div></div></div></div><div id="40208585" class="c"><input type="checkbox" id="c-40208585" checked=""/><div class="controls bullet"><span class="by">logrot</span><span>|</span><a href="#40204933">parent</a><span>|</span><a href="#40205048">prev</a><span>|</span><a href="#40206888">next</a><span>|</span><label class="collapse" for="c-40208585">[-]</label><label class="expand" for="c-40208585">[1 more]</label></div><br/><div class="children"><div class="content">Fundamentally I agree, but sadly the world isn&#x27;t that simple.<p>You usually end up with having to deal with whatever eccentric sh!t that ultimately comes from the same source as the payment for the job.</div><br/></div></div><div id="40206888" class="c"><input type="checkbox" id="c-40206888" checked=""/><div class="controls bullet"><span class="by">LaffertyDev</span><span>|</span><a href="#40204933">parent</a><span>|</span><a href="#40208585">prev</a><span>|</span><a href="#40208665">next</a><span>|</span><label class="collapse" for="c-40206888">[-]</label><label class="expand" for="c-40206888">[4 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t help myself. The grandest of nitpicks is coming your way. I&#x27;m sorry.<p>&gt;  If you give me a computer timestamp without a timezone, I can and will assume it&#x27;s in UTC.<p>Do you mean, give you an _offset_? `2024-04-29T14:03:06.0000-8:00` the `-8:00` is an offset. It only tells you what time this stamp occurred relative to standard time. It does not tell you anything about the region or zone itself. While I have consumed APIs that give me the timezone context as part of the response, none of them are part of the timestamp itself.<p>The only time you should assume a timestamp is UTC is if it has the `z` at the end (assuming 8601) or is otherwise marked as UTC. Without that, you have absolutely no information about where or when the time has occurred -- it is local time. And if your software assumes a local timestamp is UTC, then I argue it is not the sender of that timestamp&#x27;s problem that your software is broken.<p>My desire to meet you at 4pm has no bearing on if the DST switchover has happened, or my government decides to change the timezone rules, or if {any other way the offset for a zone can change for future or past times}. My reminder to take my medicine at 7pm is not centered on UTC or my physical location on the planet. Its just at 7pm. Every day. If I go from New York to Paris then no, I do not want your software to tell me my medicine is actually supposed to be at Midnight. Its 7pm.<p>But, assuming you aren&#x27;t doing any future scheduling, calendar appointments, bookings, ticket sales, transportation departure, human-centric logs, or any of the other ways Local Time is incredibly useful -- ignore away.</div><br/><div id="40207299" class="c"><input type="checkbox" id="c-40207299" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40206888">parent</a><span>|</span><a href="#40207071">next</a><span>|</span><label class="collapse" for="c-40207299">[-]</label><label class="expand" for="c-40207299">[1 more]</label></div><br/><div class="children"><div class="content">As I mentioned in another reply, &quot;remind me every day at 7PM&quot; isn&#x27;t a timestamp. It&#x27;s a formula for how to determine when the next timestamp is going to occur. Even those examples are too narrow, because it&#x27;s really closer to &quot;remind me the next time you notice that it&#x27;s after 7PM wherever I happen to be, including if that&#x27;s when I cross a time zone and jump instantly from 6:30PM to 7:30PM&quot;.<p>Consider my statement more in the context of logs of past events. The only time you can reasonably assume a given file is in a particular non-UTC TZ is when it came from a person sitting in your same city, from data they collected manually, and you&#x27;re confident that person isn&#x27;t a time geek who uses UTC for everything. Otherwise there&#x27;s no other sane default when lacking TZ&#x2F;offset data. (I know they&#x27;re not the same, but they&#x27;re similar in the sense that they can let you convert timestamps from one TZ to another).</div><br/></div></div><div id="40207071" class="c"><input type="checkbox" id="c-40207071" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40206888">parent</a><span>|</span><a href="#40207299">prev</a><span>|</span><a href="#40208665">next</a><span>|</span><label class="collapse" for="c-40207071">[-]</label><label class="expand" for="c-40207071">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always nice to see someone who actually understands time.<p>&quot;Convert to UTC and then throw away the time zone&quot; only works when you need to record a specific moment in time so it&#x27;s crazy how often it&#x27;s recommended as the universal solution. It really isn&#x27;t that hard to store (datetime, zone) and now you&#x27;re not throwing away information if you ever need to do date math.</div><br/><div id="40208078" class="c"><input type="checkbox" id="c-40208078" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40204933">root</a><span>|</span><a href="#40207071">parent</a><span>|</span><a href="#40208665">next</a><span>|</span><label class="collapse" for="c-40208078">[-]</label><label class="expand" for="c-40208078">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve been trying to convince people forever to store time zones with timestamps when appropriate. If you record events from around the world and don&#x27;t record what time zone they happened in you can&#x27;t even answer basic questions like &quot;what proportion happened before lunch time?&quot;<p>People love simple rules and they will absolutely take things too far. Most developers learn &quot;just use UTC!&quot; and think that&#x27;s the last thing they ever need to learn about time.</div><br/></div></div></div></div></div></div></div></div><div id="40208665" class="c"><input type="checkbox" id="c-40208665" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#40204933">prev</a><span>|</span><a href="#40205976">next</a><span>|</span><label class="collapse" for="c-40208665">[-]</label><label class="expand" for="c-40208665">[1 more]</label></div><br/><div class="children"><div class="content">Dear lazyweb: I think I read something about Postel&#x27;s Law being essential to the internet&#x27;s success -- maybe this was also IPv6 related? Does anyone else remember this?</div><br/></div></div><div id="40205976" class="c"><input type="checkbox" id="c-40205976" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40208665">prev</a><span>|</span><a href="#40205912">next</a><span>|</span><label class="collapse" for="c-40205976">[-]</label><label class="expand" for="c-40205976">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, you can&#x27;t assume UTF-8.<p>What you do, rather, is drop support for non-UTF-8.<p>Work with tech-stacks whose text handling is based strictly around Unicode and UTF-8, and find enough opportunities that way that you don&#x27;t have to care about anything else.<p>Let the customers who cling to data in weird encodings go to someone who makes it a nice to support that.</div><br/></div></div><div id="40205912" class="c"><input type="checkbox" id="c-40205912" checked=""/><div class="controls bullet"><span class="by">hnick</span><span>|</span><a href="#40205976">prev</a><span>|</span><a href="#40206149">next</a><span>|</span><label class="collapse" for="c-40205912">[-]</label><label class="expand" for="c-40205912">[1 more]</label></div><br/><div class="children"><div class="content">Based on my past role, you can&#x27;t even assume UTF-8 when the file says it&#x27;s UTF-8.<p>Clients would constantly send CSV or other files with an explicit BOM or other marking indicating UTF-8 but the parser would choke since they just output native Windows-1252 or similar into it. I think some programs just spit it out since it&#x27;s standard.</div><br/></div></div><div id="40206149" class="c"><input type="checkbox" id="c-40206149" checked=""/><div class="controls bullet"><span class="by">djha-skin</span><span>|</span><a href="#40205912">prev</a><span>|</span><a href="#40195050">next</a><span>|</span><label class="collapse" for="c-40206149">[-]</label><label class="expand" for="c-40206149">[5 more]</label></div><br/><div class="children"><div class="content">Joel spolsky spoke against this exact statistics-based approach when he wrote about unicode[1]:<p>&gt; What do web browsers do if they don’t find any Content-Type, either in the http headers or the meta tag? Internet Explorer actually does something quite interesting: it tries to guess, <i>based on the frequency in which various bytes appear in typical text in typical encodings of various languages</i>, what language and encoding was used. Because the various old 8 bit code pages tended to put their national letters in different ranges between 128 and 255, and because every human language has a different characteristic histogram of letter usage, this actually has a chance of working. It’s truly weird, but it does seem to work often enough that naïve web-page writers who never knew they needed a Content-Type header look at their page in a web browser and it looks ok, <i>until one day, they write something that doesn’t exactly conform to the letter-frequency-distribution of their native language</i>, and Internet Explorer decides it’s Korean and displays it thusly, proving, I think, the point that Postel’s Law about being “conservative in what you emit and liberal in what you accept” is quite frankly not a good engineering principle.<p>1: <a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2003&#x2F;10&#x2F;08&#x2F;the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2003&#x2F;10&#x2F;08&#x2F;the-absolute-minim...</a></div><br/><div id="40208381" class="c"><input type="checkbox" id="c-40208381" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40206149">parent</a><span>|</span><a href="#40207599">next</a><span>|</span><label class="collapse" for="c-40208381">[-]</label><label class="expand" for="c-40208381">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s enca library (and cli tool) which does that. I used it often before UTF-8 became overwhelming. The situation was especially dire with Russian encodings. There were three 1-byte encodings which were quite wide-spread: KOI8-R mostly found in unixes, CP866 used in DOS and CP1251 used in Windows. What&#x27;s worse, with Windows you sometimes had to deal with both CP866 and CP1251 because it includes DOS subsystem with separate codepage.</div><br/></div></div><div id="40207599" class="c"><input type="checkbox" id="c-40207599" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40206149">parent</a><span>|</span><a href="#40208381">prev</a><span>|</span><a href="#40206548">next</a><span>|</span><label class="collapse" for="c-40207599">[-]</label><label class="expand" for="c-40207599">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think he was speaking against the statistics-based approach itself, just against Postel&#x27;s Law in general.<p>Ideally people would see gibberish (or an error message) immediately if they don&#x27;t provide an encoding; then they&#x27;ll know something is wrong, figure it out, fix it, and never have the issue again.<p>But if we&#x27;re in a situation where we <i>already</i> have lots and lots of text documents that don&#x27;t have an encoding specified, and we believe it&#x27;s not feasible to require everyone to fix that, then it&#x27;s actually pretty amazing that we can often correctly guess the encoding.</div><br/></div></div><div id="40206548" class="c"><input type="checkbox" id="c-40206548" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#40206149">parent</a><span>|</span><a href="#40207599">prev</a><span>|</span><a href="#40206824">next</a><span>|</span><label class="collapse" for="c-40206548">[-]</label><label class="expand" for="c-40206548">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. I used this technique at Mozilla in 2010 when processing Firefox add-ons, and it misidentified scripts as having the wrong encoding pretty frequently. There&#x27;s far less weird encoding out there than there are false positives from statistics-based approaches.</div><br/></div></div><div id="40206824" class="c"><input type="checkbox" id="c-40206824" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#40206149">parent</a><span>|</span><a href="#40206548">prev</a><span>|</span><a href="#40195050">next</a><span>|</span><label class="collapse" for="c-40206824">[-]</label><label class="expand" for="c-40206824">[1 more]</label></div><br/><div class="children"><div class="content">20 years old, but still true.</div><br/></div></div></div></div><div id="40195050" class="c"><input type="checkbox" id="c-40195050" checked=""/><div class="controls bullet"><span class="by">bhaney</span><span>|</span><a href="#40206149">prev</a><span>|</span><a href="#40208366">next</a><span>|</span><label class="collapse" for="c-40195050">[-]</label><label class="expand" for="c-40195050">[21 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just gonna assume UTF-8</div><br/><div id="40204642" class="c"><input type="checkbox" id="c-40204642" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#40195050">parent</a><span>|</span><a href="#40195154">next</a><span>|</span><label class="collapse" for="c-40204642">[-]</label><label class="expand" for="c-40204642">[15 more]</label></div><br/><div class="children"><div class="content">I&#x27;m disappointed that the article doesn&#x27;t discuss this in more detail. <i>Most byte sequences are not valid UTF-8.</i> If you can decode a message as UTF-8 with no errors, that is almost certainly the correct encoding to use; it&#x27;s extremely unlikely that some text in another encoding just happened to be perfectly valid as UTF-8. (The converse is not true; most 8-bit text encodings will happily decode UTF-8 sequences to nonsense strings like ðŸš©.)<p>If UTF-8 decoding fails, <i>then</i> it&#x27;s time to pull out the fancy statistical tools to (unreliably) guess an encoding. But that should be a fallback, not the first thing you try.</div><br/><div id="40205970" class="c"><input type="checkbox" id="c-40205970" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40204642">parent</a><span>|</span><a href="#40205141">next</a><span>|</span><label class="collapse" for="c-40205970">[-]</label><label class="expand" for="c-40205970">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If UTF-8 decoding fails, then it&#x27;s time to pull out the fancy statistical tools to (unreliably) guess an encoding.<p>Don&#x27;t really even need to do that.  There&#x27;s only a handful other encodings still in common use, just try each of them as fallbacks and see which one works without errors, and you&#x27;ll manage the vast majority of what&#x27;s not UTF-8.<p>(We recently did just that for a system that handles unreliable input, I think I remember our fallback only has 3 additional encodings before it gives up and it&#x27;s been working fine)</div><br/><div id="40207610" class="c"><input type="checkbox" id="c-40207610" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205970">parent</a><span>|</span><a href="#40206839">next</a><span>|</span><label class="collapse" for="c-40207610">[-]</label><label class="expand" for="c-40207610">[1 more]</label></div><br/><div class="children"><div class="content">The person you&#x27;re replying to sort of addresses this, though not completely.<p>Since UTF-8 is a variable-length encoding, it somewhat naturally has some error detection built in.  Fixed-length encodings don&#x27;t really have that, and for some of them, any byte value, 0 to 255, in any position, is valid.  (Some have a few byte values that are invalid or reserved, but the point still stands.)<p>So you could very easily pick a &quot;next most common encoding&quot; after UTF-8 fails, try it, find that it works (that is, no bytes are invalid in that encoding), but it turns out that&#x27;s still not actually the correct encoding.  The statistics-based approach will nearly always yield better results.  Even a statistics-based approach that restricts you to a few possible encodings that you know are most likely will do better.</div><br/></div></div><div id="40206839" class="c"><input type="checkbox" id="c-40206839" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205970">parent</a><span>|</span><a href="#40207610">prev</a><span>|</span><a href="#40205141">next</a><span>|</span><label class="collapse" for="c-40206839">[-]</label><label class="expand" for="c-40206839">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately Windows code page 1252 has no invalid bytes, so it will always succeed.  You&#x27;d better try that one last.</div><br/><div id="40207259" class="c"><input type="checkbox" id="c-40207259" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40206839">parent</a><span>|</span><a href="#40205141">next</a><span>|</span><label class="collapse" for="c-40207259">[-]</label><label class="expand" for="c-40207259">[1 more]</label></div><br/><div class="children"><div class="content">81, 8D, 8F, 90, 9D are invalid.</div><br/></div></div></div></div></div></div><div id="40205141" class="c"><input type="checkbox" id="c-40205141" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40204642">parent</a><span>|</span><a href="#40205970">prev</a><span>|</span><a href="#40195154">next</a><span>|</span><label class="collapse" for="c-40205141">[-]</label><label class="expand" for="c-40205141">[10 more]</label></div><br/><div class="children"><div class="content">Not <i>extremely</i> unlikely. Many charsets decode fine as UTF-8 as long as the message happens to fit in ASCII.</div><br/><div id="40205488" class="c"><input type="checkbox" id="c-40205488" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205141">parent</a><span>|</span><a href="#40207645">next</a><span>|</span><label class="collapse" for="c-40205488">[-]</label><label class="expand" for="c-40205488">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Many charsets decode fine as UTF-8 as long as the message happens to fit in ASCII.<p>At which point the message is effectively ASCII. UTF-8 is a superset of ASCII, so &quot;decoding&quot; ASCII as UTF-8 is fine.<p>(Yes, I know there are some Japanese text encodings where 0x5c is decoded as &quot;¥&quot; instead of &quot;\&quot;. But they&#x27;re sometimes treated as backslashes even though they look like ¥ symbols so handling them &quot;correctly&quot; is complicated.)</div><br/><div id="40208272" class="c"><input type="checkbox" id="c-40208272" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205488">parent</a><span>|</span><a href="#40208378">next</a><span>|</span><label class="collapse" for="c-40208272">[-]</label><label class="expand" for="c-40208272">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Fun&quot; fact: some video subtitle formats (ASS specifically) use &quot;text{\b1}bold&quot; to format things — but since they were primarily used to subtitle Japanese anime, this frequently became &quot;text{¥b1}bold&quot;.  Which is all good and well, <i>except when those subtitles moved to UTF-8 they kept the ¥</i>.  So now you have to support ¥ (0xC2 0xA5) as a markup&#x2F;control character in those subtitles.</div><br/></div></div><div id="40208378" class="c"><input type="checkbox" id="c-40208378" checked=""/><div class="controls bullet"><span class="by">jwilk</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205488">parent</a><span>|</span><a href="#40208272">prev</a><span>|</span><a href="#40205997">next</a><span>|</span><label class="collapse" for="c-40208378">[-]</label><label class="expand" for="c-40208378">[1 more]</label></div><br/><div class="children"><div class="content">ISO-2022-JP (sometimes?) disguises perfectly as ASCII:<p><pre><code>  $ echo は | iconv -t ISO-2022-JP | hd
  00000000  1b 24 42 24 4f 1b 28 42  0a                       |.$B$O.(B.|
  00000009</code></pre></div><br/></div></div><div id="40205997" class="c"><input type="checkbox" id="c-40205997" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205488">parent</a><span>|</span><a href="#40208378">prev</a><span>|</span><a href="#40207645">next</a><span>|</span><label class="collapse" for="c-40205997">[-]</label><label class="expand" for="c-40205997">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing they&#x27;re thinking of Extended ASCII (the 8-bit one that&#x27;s actually multiple different encodings, but the lower half is shared with 7-bit ASCII and so that part does fit in UTF-8 while the upper half likely won&#x27;t if the message actually uses it).</div><br/></div></div></div></div><div id="40207645" class="c"><input type="checkbox" id="c-40207645" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205141">parent</a><span>|</span><a href="#40205488">prev</a><span>|</span><a href="#40205651">next</a><span>|</span><label class="collapse" for="c-40207645">[-]</label><label class="expand" for="c-40207645">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m skeptical.  Any charset that uses bytes 128-255 as characters is unlikely to successfully decode to UTF-8.  Are there really many others that only use 0-127, or most text ends up only using 0-127?</div><br/></div></div><div id="40205651" class="c"><input type="checkbox" id="c-40205651" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205141">parent</a><span>|</span><a href="#40207645">prev</a><span>|</span><a href="#40205319">next</a><span>|</span><label class="collapse" for="c-40205651">[-]</label><label class="expand" for="c-40205651">[1 more]</label></div><br/><div class="children"><div class="content">The definition GP is using most likely refers to non-ASCII sequences that validly decode as UTF-8, because virtually every major charset in practical use has ASCII as a subset.</div><br/></div></div><div id="40205319" class="c"><input type="checkbox" id="c-40205319" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205141">parent</a><span>|</span><a href="#40205651">prev</a><span>|</span><a href="#40205484">next</a><span>|</span><label class="collapse" for="c-40205319">[-]</label><label class="expand" for="c-40205319">[2 more]</label></div><br/><div class="children"><div class="content">such encodings are also UTF-8 then, are they not?</div><br/><div id="40207265" class="c"><input type="checkbox" id="c-40207265" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205319">parent</a><span>|</span><a href="#40205484">next</a><span>|</span><label class="collapse" for="c-40207265">[-]</label><label class="expand" for="c-40207265">[1 more]</label></div><br/><div class="children"><div class="content">I think there are a bunch of encodings that just repurposed a few ASCII characters as different characters - someone on this page was giving the example of some Swedish encoding where {}| were replaced with three accented Swedish letters. There are probably a bunch of others. In those cases, the text will decode fine as UTF-8, but it will display the wrong thing.</div><br/></div></div></div></div><div id="40205484" class="c"><input type="checkbox" id="c-40205484" checked=""/><div class="controls bullet"><span class="by">srj</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40205141">parent</a><span>|</span><a href="#40205319">prev</a><span>|</span><a href="#40195154">next</a><span>|</span><label class="collapse" for="c-40205484">[-]</label><label class="expand" for="c-40205484">[1 more]</label></div><br/><div class="children"><div class="content">A distinction without a difference?</div><br/></div></div></div></div></div></div><div id="40195154" class="c"><input type="checkbox" id="c-40195154" checked=""/><div class="controls bullet"><span class="by">calpaterson</span><span>|</span><a href="#40195050">parent</a><span>|</span><a href="#40204642">prev</a><span>|</span><a href="#40206079">next</a><span>|</span><label class="collapse" for="c-40195154">[-]</label><label class="expand" for="c-40195154">[4 more]</label></div><br/><div class="children"><div class="content">榥\ue0af侬펭懃䒥亷</div><br/><div id="40195421" class="c"><input type="checkbox" id="c-40195421" checked=""/><div class="controls bullet"><span class="by">bhaney</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40195154">parent</a><span>|</span><a href="#40206079">next</a><span>|</span><label class="collapse" for="c-40195421">[-]</label><label class="expand" for="c-40195421">[3 more]</label></div><br/><div class="children"><div class="content">And a good day to you too, my friend whose input I&#x27;m going to discard</div><br/><div id="40208294" class="c"><input type="checkbox" id="c-40208294" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40195421">parent</a><span>|</span><a href="#40206079">next</a><span>|</span><label class="collapse" for="c-40208294">[-]</label><label class="expand" for="c-40208294">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s garbage anyway, which you can (non-reliably) guess by there being a Korean character in the middle of C&#x2F;J kanji.  (Kanji are not completely gone from Korean, but mostly.)</div><br/><div id="40208446" class="c"><input type="checkbox" id="c-40208446" checked=""/><div class="controls bullet"><span class="by">calpaterson</span><span>|</span><a href="#40195050">root</a><span>|</span><a href="#40208294">parent</a><span>|</span><a href="#40206079">next</a><span>|</span><label class="collapse" for="c-40208446">[-]</label><label class="expand" for="c-40208446">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s mojibake for &quot;probably a bad idea&quot; [in Chinese]</div><br/></div></div></div></div></div></div></div></div><div id="40206079" class="c"><input type="checkbox" id="c-40206079" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#40195050">parent</a><span>|</span><a href="#40195154">prev</a><span>|</span><a href="#40208366">next</a><span>|</span><label class="collapse" for="c-40206079">[-]</label><label class="expand" for="c-40206079">[1 more]</label></div><br/><div class="children"><div class="content">You can’t just do that! &#x2F;s</div><br/></div></div></div></div><div id="40208366" class="c"><input type="checkbox" id="c-40208366" checked=""/><div class="controls bullet"><span class="by">tanin</span><span>|</span><a href="#40195050">prev</a><span>|</span><a href="#40204854">next</a><span>|</span><label class="collapse" for="c-40208366">[-]</label><label class="expand" for="c-40208366">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually having this issue where users import CSV files that don&#x27;t seem to be valid. DuckDB would throw out an error like: Invalid Closing Quote: found non trimable byte after quote at line 34, Invalid Input Error: Invalid unicode (byte sequence mismatch) detected in value construction, Value with unterminated quote found<p>One example: pgAdmin can export a database table into a CSV... but the CSV isn&#x27;t valid for DuckDB to consume. Because, for some odd reason, pgAdmin uses a single quote to escape a double quote.<p>This blog is pretty timely. Thank you for writing it!</div><br/></div></div><div id="40204854" class="c"><input type="checkbox" id="c-40204854" checked=""/><div class="controls bullet"><span class="by">groestl</span><span>|</span><a href="#40208366">prev</a><span>|</span><a href="#40208445">next</a><span>|</span><label class="collapse" for="c-40204854">[-]</label><label class="expand" for="c-40204854">[1 more]</label></div><br/><div class="children"><div class="content">I will assume it, I will enforce it where I can, and I will fight tooth and nail should push come to shove.<p>I got 99 problems, but charsets aint one of them.</div><br/></div></div><div id="40208445" class="c"><input type="checkbox" id="c-40208445" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#40204854">prev</a><span>|</span><a href="#40204875">next</a><span>|</span><label class="collapse" for="c-40208445">[-]</label><label class="expand" for="c-40208445">[1 more]</label></div><br/><div class="children"><div class="content">The article&#x27;s pretty weird for presenting little-endian UTF-16 as normal and barely even mentioning that big-endian is an option (in fact, seems to refer to it as &quot;backwards&quot;), even though big-endian is a much more human readable format.</div><br/></div></div><div id="40204875" class="c"><input type="checkbox" id="c-40204875" checked=""/><div class="controls bullet"><span class="by">zadokshi</span><span>|</span><a href="#40208445">prev</a><span>|</span><a href="#40208142">next</a><span>|</span><label class="collapse" for="c-40204875">[-]</label><label class="expand" for="c-40204875">[1 more]</label></div><br/><div class="children"><div class="content">Better to assume UTF8 and fail with a clear message&#x2F;warning. Sure you can offer to guess to help the end user if it fails, but as other people have pointed out, it’s been standard for a long time now. Even python caved and accepted it as the default:  <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0686&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0686&#x2F;</a></div><br/></div></div><div id="40208142" class="c"><input type="checkbox" id="c-40208142" checked=""/><div class="controls bullet"><span class="by">vkaku</span><span>|</span><a href="#40204875">prev</a><span>|</span><a href="#40208547">next</a><span>|</span><label class="collapse" for="c-40208142">[-]</label><label class="expand" for="c-40208142">[1 more]</label></div><br/><div class="children"><div class="content">The probability of web content not in UTF-8 is increasingly getting lower and lower.<p>Last I tracked, as of this month, 0.3% of surveyed web pages used Shift JIS. It has been declining steadily. I really hope people move to UTF-8. While it is important to understand how the code pages and encodings helped, I think it&#x27;s a good time to actually start moving a lot of applications to use UTF-8. I am perfectly okay if people want to use UTF-16 (the OG Unicode) and it&#x27;s extensions alternatively, especially for Asian applications.<p>Yes, historic data preservation requires a different strategy than designing stuff for the future. It is okay to however migrate to these encodings and keep giving old data and software new life.</div><br/></div></div><div id="40208547" class="c"><input type="checkbox" id="c-40208547" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#40208142">prev</a><span>|</span><a href="#40204673">next</a><span>|</span><label class="collapse" for="c-40208547">[-]</label><label class="expand" for="c-40208547">[1 more]</label></div><br/><div class="children"><div class="content">30 years ago: &quot;you can&#x27;t just assume ASCII&quot;<p>Today: &quot;you can&#x27;t just assume UTF-8&quot;<p>The more things change, the more they stay the same...</div><br/></div></div><div id="40204673" class="c"><input type="checkbox" id="c-40204673" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#40208547">prev</a><span>|</span><a href="#40207841">next</a><span>|</span><label class="collapse" for="c-40204673">[-]</label><label class="expand" for="c-40204673">[9 more]</label></div><br/><div class="children"><div class="content">Off-topic, but the bit numbering convention is deliciously confusing.<p>Little-endian bytes (lowest byte is leftmost) and big-endian bits (bits contributing less numerical value are rightmost) are normal, but the bits are referenced&#x2F;numbered little-endian (first bit is leftmost even though it contributes the most numerical value). When I first read the numbering convention I thought it was going to be a breath of fresh air of someone using the much more sane, but non-standard, little-endian bits with little-endian bytes, but it was actually another layered twist. Hopefully someday English can write numbers little-endian, which is objectively superior, and do away with this whole mess.</div><br/><div id="40204800" class="c"><input type="checkbox" id="c-40204800" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40204673">parent</a><span>|</span><a href="#40207841">next</a><span>|</span><label class="collapse" for="c-40204800">[-]</label><label class="expand" for="c-40204800">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Hopefully someday English can write numbers little-endian, which is objectively superior<p>Upon reading this, I threw my laptop out the window.</div><br/><div id="40205198" class="c"><input type="checkbox" id="c-40205198" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#40204673">root</a><span>|</span><a href="#40204800">parent</a><span>|</span><a href="#40206833">next</a><span>|</span><label class="collapse" for="c-40205198">[-]</label><label class="expand" for="c-40205198">[6 more]</label></div><br/><div class="children"><div class="content">It actually is if we did not need to consider historical baggage.<p>Especially in programming where we already use in-band encoding like 0x to denote a hex string or 0b to denote a binary string. I like using 1{s}, e.g. 1x to denote a little-endian hex string and 1b to denote a little-endian binary string, to denote little-endian encoding.<p>But, even ignoring programming, it is still better in normal use. The Arabic language got it right writing little-endian (Arabic numbers are written the same, but Arabic is a right-to-left language so it is actually little-endian), and the European languages just stole it stupid by copying the form instead of the function.</div><br/><div id="40205493" class="c"><input type="checkbox" id="c-40205493" checked=""/><div class="controls bullet"><span class="by">filmor</span><span>|</span><a href="#40204673">root</a><span>|</span><a href="#40205198">parent</a><span>|</span><a href="#40206395">next</a><span>|</span><label class="collapse" for="c-40205493">[-]</label><label class="expand" for="c-40205493">[4 more]</label></div><br/><div class="children"><div class="content">Arabian numerals are derived from Indian scripts, which are written left to right, yet the order of digits is already the same we have today.</div><br/><div id="40205972" class="c"><input type="checkbox" id="c-40205972" checked=""/><div class="controls bullet"><span class="by">pezezin</span><span>|</span><a href="#40204673">root</a><span>|</span><a href="#40205493">parent</a><span>|</span><a href="#40206395">next</a><span>|</span><label class="collapse" for="c-40205972">[-]</label><label class="expand" for="c-40205972">[3 more]</label></div><br/><div class="children"><div class="content">Not to mention that in most (all?) spoken languages numbers are big-endian.</div><br/><div id="40206076" class="c"><input type="checkbox" id="c-40206076" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#40204673">root</a><span>|</span><a href="#40205972">parent</a><span>|</span><a href="#40206327">next</a><span>|</span><label class="collapse" for="c-40206076">[-]</label><label class="expand" for="c-40206076">[1 more]</label></div><br/><div class="children"><div class="content">From what I have seen, low numbers in Arabic are spoken&#x2F;written little-endian (twenty five is five and twenty). Apparently German as well. The internet claims that historically large numbers in Arabic were also written out (as in when using number words rather than numerals) little-endian.</div><br/></div></div><div id="40206327" class="c"><input type="checkbox" id="c-40206327" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#40204673">root</a><span>|</span><a href="#40205972">parent</a><span>|</span><a href="#40206076">prev</a><span>|</span><a href="#40206395">next</a><span>|</span><label class="collapse" for="c-40206327">[-]</label><label class="expand" for="c-40206327">[1 more]</label></div><br/><div class="children"><div class="content">Numbers below 100 in German are little-endian. 85 is &quot;fünfundachtzig&quot; (five-and-eighty).</div><br/></div></div></div></div></div></div><div id="40206395" class="c"><input type="checkbox" id="c-40206395" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40204673">root</a><span>|</span><a href="#40205198">parent</a><span>|</span><a href="#40205493">prev</a><span>|</span><a href="#40206833">next</a><span>|</span><label class="collapse" for="c-40206395">[-]</label><label class="expand" for="c-40206395">[1 more]</label></div><br/><div class="children"><div class="content"><i>&quot;Although generally found in text written with the Arabic abjad (&quot;alphabet&quot;), numbers written with these numerals also place the most-significant digit to the left, so they read from left to right (though digits are not always said in order from most to least significant[10]). The requisite changes in reading direction are found in text that mixes left-to-right writing systems with right-to-left systems.&quot;</i><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hindu%E2%80%93Arabic_numeral_system#Positional_notation" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hindu%E2%80%93Arabic_numeral_s...</a></div><br/></div></div></div></div><div id="40206833" class="c"><input type="checkbox" id="c-40206833" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#40204673">root</a><span>|</span><a href="#40204800">parent</a><span>|</span><a href="#40205198">prev</a><span>|</span><a href="#40207841">next</a><span>|</span><label class="collapse" for="c-40206833">[-]</label><label class="expand" for="c-40206833">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Upon reading this, I threw my laptop out the window.<p>And having shattered the dirty window, your room was enlightened.</div><br/></div></div></div></div></div></div><div id="40207841" class="c"><input type="checkbox" id="c-40207841" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40204673">prev</a><span>|</span><a href="#40204929">next</a><span>|</span><label class="collapse" for="c-40207841">[-]</label><label class="expand" for="c-40207841">[2 more]</label></div><br/><div class="children"><div class="content">The post seems to assume that only UTF-16 has Byte Order Marks, but as pointless as it sounds, UTF-8 has a BOM too (EF BB BF). It seems to be a Windows thing though, haven&#x27;t seen it in the wild anywhere else (and also rarely on Windows - since text editors typically allow to save UTF-8 files with or without BOM. I guess it depends on the text editor which of those is the default).</div><br/><div id="40207938" class="c"><input type="checkbox" id="c-40207938" checked=""/><div class="controls bullet"><span class="by">calpaterson</span><span>|</span><a href="#40207841">parent</a><span>|</span><a href="#40204929">next</a><span>|</span><label class="collapse" for="c-40207938">[-]</label><label class="expand" for="c-40207938">[1 more]</label></div><br/><div class="children"><div class="content">Yes you&#x27;re right, UTF-8 technically does as well.  I&#x27;ve never seen them in real life either.<p>UTF-16 BOMs do have a useful function as I recall: they really help Excel detect your character encoding (Excel is awful at detecting character encoding).</div><br/></div></div></div></div><div id="40204929" class="c"><input type="checkbox" id="c-40204929" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#40207841">prev</a><span>|</span><a href="#40204653">next</a><span>|</span><label class="collapse" for="c-40204929">[-]</label><label class="expand" for="c-40204929">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s turtles all the way down and at every level you use utf-8, it&#x27;s hard to see how any input with a different encoding (for the same underlying text) will not be detected before any unintended side effects were invoked.<p>At this point, I don&#x27;t see any sufficiently good reason to not use utf-8 exclusively in any new system. Conversions to and from other encodings would only be done at well defined boundaries when I&#x27;m calling into dependencies that require non utf-8 input for whatever reason.</div><br/></div></div><div id="40204653" class="c"><input type="checkbox" id="c-40204653" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40204929">prev</a><span>|</span><a href="#40205639">next</a><span>|</span><label class="collapse" for="c-40204653">[-]</label><label class="expand" for="c-40204653">[1 more]</label></div><br/><div class="children"><div class="content">Default UTF-8 is better than the linked suggestion of using a heuristic, but failing catastrophic when old data is encountered is unacceptable. There <i>must</i> be a fallback.<p>(Note that the heuristic for &quot;is this intended to be UTF-8&quot; is pretty reliable, but most other encoding-detection heuristics are very bad quality)</div><br/></div></div><div id="40205639" class="c"><input type="checkbox" id="c-40205639" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#40204653">prev</a><span>|</span><a href="#40204677">next</a><span>|</span><label class="collapse" for="c-40205639">[-]</label><label class="expand" for="c-40205639">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t just assume UTF-8, but you can <i>verify</i> that it is almost surely encoded in UTF-8 unlike other legacy encodings. Which makes UTF-8 the first and foremost consideration.</div><br/></div></div><div id="40204677" class="c"><input type="checkbox" id="c-40204677" checked=""/><div class="controls bullet"><span class="by">bandyaboot</span><span>|</span><a href="#40205639">prev</a><span>|</span><a href="#40208396">next</a><span>|</span><label class="collapse" for="c-40204677">[-]</label><label class="expand" for="c-40204677">[8 more]</label></div><br/><div class="children"><div class="content">&gt; In the most popular character encoding, UTF-8, character number 65 (&quot;A&quot;) is written:<p>&gt; 01000001<p>&gt; Only the second and final bits are 1, or &quot;on&quot;.<p>Isn’t it more accurate to say that the first and penultimate bits are 1, or “on”?</div><br/><div id="40208537" class="c"><input type="checkbox" id="c-40208537" checked=""/><div class="controls bullet"><span class="by">skerit</span><span>|</span><a href="#40204677">parent</a><span>|</span><a href="#40204698">next</a><span>|</span><label class="collapse" for="c-40208537">[-]</label><label class="expand" for="c-40208537">[1 more]</label></div><br/><div class="children"><div class="content">This confused me too. Until reading this I didn&#x27;t even think much about how I read binary numbers right-to-left by default.</div><br/></div></div><div id="40204698" class="c"><input type="checkbox" id="c-40204698" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204677">parent</a><span>|</span><a href="#40208537">prev</a><span>|</span><a href="#40208396">next</a><span>|</span><label class="collapse" for="c-40204698">[-]</label><label class="expand" for="c-40204698">[6 more]</label></div><br/><div class="children"><div class="content">It depends on whether your bit numbering is like x86 (your description), or PowerPC (left most bit is 0).</div><br/><div id="40206872" class="c"><input type="checkbox" id="c-40206872" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#40204677">root</a><span>|</span><a href="#40204698">parent</a><span>|</span><a href="#40204725">next</a><span>|</span><label class="collapse" for="c-40206872">[-]</label><label class="expand" for="c-40206872">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for giving me an example of an architecture where the bits are labelled backwards, I&#x27;d never encountered that before.  I&#x27;ve always appreciated that the bit number represents 2 to the power of that number.</div><br/></div></div><div id="40204725" class="c"><input type="checkbox" id="c-40204725" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#40204677">root</a><span>|</span><a href="#40204698">parent</a><span>|</span><a href="#40206872">prev</a><span>|</span><a href="#40204881">next</a><span>|</span><label class="collapse" for="c-40204725">[-]</label><label class="expand" for="c-40204725">[3 more]</label></div><br/><div class="children"><div class="content">Basically everyone uses x86 bit numbering. It has the pleasant property that the place value of every bit is always 2^n (or -2^n for a sign bit), and zero-extending a value doesn&#x27;t change the numbering of its bits.</div><br/><div id="40206884" class="c"><input type="checkbox" id="c-40206884" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#40204677">root</a><span>|</span><a href="#40204725">parent</a><span>|</span><a href="#40204839">next</a><span>|</span><label class="collapse" for="c-40206884">[-]</label><label class="expand" for="c-40206884">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a mistake to call it x86 bit numbering, it&#x27;s way older than that.</div><br/></div></div><div id="40204839" class="c"><input type="checkbox" id="c-40204839" checked=""/><div class="controls bullet"><span class="by">fl7305</span><span>|</span><a href="#40204677">root</a><span>|</span><a href="#40204725">parent</a><span>|</span><a href="#40206884">prev</a><span>|</span><a href="#40204881">next</a><span>|</span><label class="collapse" for="c-40204839">[-]</label><label class="expand" for="c-40204839">[1 more]</label></div><br/><div class="children"><div class="content">Sure, it is by far the industry standard.<p>It works much better for handling discrete integers.<p>Once you get into bitfield instructions it is nice to have bit 0 be the &quot;left most bit&quot;.</div><br/></div></div></div></div><div id="40204881" class="c"><input type="checkbox" id="c-40204881" checked=""/><div class="controls bullet"><span class="by">bandyaboot</span><span>|</span><a href="#40204677">root</a><span>|</span><a href="#40204698">parent</a><span>|</span><a href="#40204725">prev</a><span>|</span><a href="#40208396">next</a><span>|</span><label class="collapse" for="c-40204881">[-]</label><label class="expand" for="c-40204881">[1 more]</label></div><br/><div class="children"><div class="content">The more I thought it through, even assuming x86, I guess there’s just no “correct” way to casually reference bit positions when we read them in the opposite order from the machine. Are they being referenced from the perspective of a human consumer of text, or the machine’s perspective as a consumer of bits? If I were writing that content, I’d have a difficult time deciding on which to use. If I were writing for a lay person, referencing left-to-right seems obvious, but in this case where the audience is primarily developers, it becomes much less obvious.</div><br/></div></div></div></div></div></div><div id="40208396" class="c"><input type="checkbox" id="c-40208396" checked=""/><div class="controls bullet"><span class="by">mihaaly</span><span>|</span><a href="#40204677">prev</a><span>|</span><a href="#40204695">next</a><span>|</span><label class="collapse" for="c-40208396">[-]</label><label class="expand" for="c-40208396">[1 more]</label></div><br/><div class="children"><div class="content">Excellent article, good content, good length, enlightened subtexts and references, joy to read.</div><br/></div></div><div id="40204695" class="c"><input type="checkbox" id="c-40204695" checked=""/><div class="controls bullet"><span class="by">vitaut</span><span>|</span><a href="#40208396">prev</a><span>|</span><a href="#40208222">next</a><span>|</span><label class="collapse" for="c-40204695">[-]</label><label class="expand" for="c-40204695">[1 more]</label></div><br/><div class="children"><div class="content">This is so spectacularly outdated. KOI-8 has been dead for ages.</div><br/></div></div><div id="40208222" class="c"><input type="checkbox" id="c-40208222" checked=""/><div class="controls bullet"><span class="by">eqvinox</span><span>|</span><a href="#40204695">prev</a><span>|</span><a href="#40205219">next</a><span>|</span><label class="collapse" for="c-40208222">[-]</label><label class="expand" for="c-40208222">[1 more]</label></div><br/><div class="children"><div class="content">The solution, obviously, is to train an LLM to recognize the character set.</div><br/></div></div><div id="40205219" class="c"><input type="checkbox" id="c-40205219" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40208222">prev</a><span>|</span><a href="#40204638">next</a><span>|</span><label class="collapse" for="c-40205219">[-]</label><label class="expand" for="c-40205219">[3 more]</label></div><br/><div class="children"><div class="content">There is a pretty successful world language standard: English.</div><br/><div id="40205374" class="c"><input type="checkbox" id="c-40205374" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#40205219">parent</a><span>|</span><a href="#40204638">next</a><span>|</span><label class="collapse" for="c-40205374">[-]</label><label class="expand" for="c-40205374">[2 more]</label></div><br/><div class="children"><div class="content">Kids these days. Latin was a much more elegant standard.</div><br/><div id="40206848" class="c"><input type="checkbox" id="c-40206848" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#40205219">root</a><span>|</span><a href="#40205374">parent</a><span>|</span><a href="#40204638">next</a><span>|</span><label class="collapse" for="c-40206848">[-]</label><label class="expand" for="c-40206848">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, but: Quis legentibus scribit?</div><br/></div></div></div></div></div></div><div id="40204638" class="c"><input type="checkbox" id="c-40204638" checked=""/><div class="controls bullet"><span class="by">pronoiac</span><span>|</span><a href="#40205219">prev</a><span>|</span><a href="#40206607">next</a><span>|</span><label class="collapse" for="c-40204638">[-]</label><label class="expand" for="c-40204638">[1 more]</label></div><br/><div class="children"><div class="content">Archive copy: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240429061925&#x2F;https:&#x2F;&#x2F;csvbase.com&#x2F;blog&#x2F;9" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240429061925&#x2F;https:&#x2F;&#x2F;csvbase.c...</a></div><br/></div></div><div id="40206607" class="c"><input type="checkbox" id="c-40206607" checked=""/><div class="controls bullet"><span class="by">pylua</span><span>|</span><a href="#40204638">prev</a><span>|</span><a href="#40204666">next</a><span>|</span><label class="collapse" for="c-40206607">[-]</label><label class="expand" for="c-40206607">[4 more]</label></div><br/><div class="children"><div class="content">Stupid question: how are the headers passed for http? What encoding describes the encoding ?</div><br/><div id="40206856" class="c"><input type="checkbox" id="c-40206856" checked=""/><div class="controls bullet"><span class="by">a57721</span><span>|</span><a href="#40206607">parent</a><span>|</span><a href="#40206857">next</a><span>|</span><label class="collapse" for="c-40206856">[-]</label><label class="expand" for="c-40206856">[1 more]</label></div><br/><div class="children"><div class="content">The RFCs for HTTP require headers to be in US-ASCII.</div><br/></div></div><div id="40206857" class="c"><input type="checkbox" id="c-40206857" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#40206607">parent</a><span>|</span><a href="#40206856">prev</a><span>|</span><a href="#40206913">next</a><span>|</span><label class="collapse" for="c-40206857">[-]</label><label class="expand" for="c-40206857">[1 more]</label></div><br/><div class="children"><div class="content">I think the headers are pure ASCII, which as noted is a subset of almost all encodings.</div><br/></div></div></div></div><div id="40204666" class="c"><input type="checkbox" id="c-40204666" checked=""/><div class="controls bullet"><span class="by">dandigangi</span><span>|</span><a href="#40206607">prev</a><span>|</span><a href="#40206358">next</a><span>|</span><label class="collapse" for="c-40204666">[-]</label><label class="expand" for="c-40204666">[1 more]</label></div><br/><div class="children"><div class="content">Except I can</div><br/></div></div><div id="40206358" class="c"><input type="checkbox" id="c-40206358" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40204666">prev</a><span>|</span><a href="#40206152">next</a><span>|</span><label class="collapse" for="c-40206358">[-]</label><label class="expand" for="c-40206358">[2 more]</label></div><br/><div class="children"><div class="content">Java and Javascript both use UTF-16 for internal string representation, even though JSON specifies UTF-8. Windows APIs too. I&#x27;m still not sure why, but it means that one char uses at least 2 bytes even if it&#x27;s in the ASCII range.</div><br/><div id="40206898" class="c"><input type="checkbox" id="c-40206898" checked=""/><div class="controls bullet"><span class="by">mark-r</span><span>|</span><a href="#40206358">parent</a><span>|</span><a href="#40206152">next</a><span>|</span><label class="collapse" for="c-40206898">[-]</label><label class="expand" for="c-40206898">[1 more]</label></div><br/><div class="children"><div class="content">Early adopters of Unicode used the first available encoding, UCS-2.  UTF-16 is an extension of that to handle the increased range of code points that came later.</div><br/></div></div></div></div><div id="40204999" class="c"><input type="checkbox" id="c-40204999" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#40205234">prev</a><span>|</span><label class="collapse" for="c-40204999">[-]</label><label class="expand" for="c-40204999">[4 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen discussion of this point yet, but the post completely fails to provide any data to back up its assertion that charset detection heuristics works, because the feedback I&#x27;ve seen from people who actually work with charsets is that it largely <i>doesn&#x27;t</i> (especially if you&#x27;re based on naive one-byte frequency analysis). Okay, sure, it works if you want to distinguish between KOI8-R and Windows-1252, but what about Windows-1252 and Windows-1257?<p>See for example this effort in building a universal charset detector in Gecko: <a href="https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1551276" rel="nofollow">https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=1551276</a></div><br/><div id="40205128" class="c"><input type="checkbox" id="c-40205128" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40204999">parent</a><span>|</span><a href="#40205189">next</a><span>|</span><label class="collapse" for="c-40205128">[-]</label><label class="expand" for="c-40205128">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done some charset detection, although it&#x27;s been a while. Heuristics kind of work for somethings --- I&#x27;m a big fan of if it&#x27;s decodable as utf-8, it&#x27;s probably utf-8, unless there&#x27;s zero bytes (in most text). If there&#x27;s a lot of zero bytes, maybe it&#x27;s UCS-2 or UTF-16, and you can try to figure out the byte order and if it decodes as utf-16.<p>If it doesn&#x27;t fit in those categories, you&#x27;ve got a much harder guessing game. But usually you can&#x27;t actually ask the source what it is, because they probably don&#x27;t know and might not understand the question or might not be contactable. Usually, you have to guess something, so you may as well take someone else&#x27;s work to guess, if you don&#x27;t have better information.</div><br/></div></div><div id="40205189" class="c"><input type="checkbox" id="c-40205189" checked=""/><div class="controls bullet"><span class="by">renhanxue</span><span>|</span><a href="#40204999">parent</a><span>|</span><a href="#40205128">prev</a><span>|</span><label class="collapse" for="c-40205189">[-]</label><label class="expand" for="c-40205189">[2 more]</label></div><br/><div class="children"><div class="content">Yeah. The fantastic python library ftfy (&quot;fixes text for you&quot;, <a href="https:&#x2F;&#x2F;ftfy.readthedocs.io&#x2F;en&#x2F;latest&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;ftfy.readthedocs.io&#x2F;en&#x2F;latest&#x2F;index.html</a>), designed to fix mangled Unicode (mojibake, of many different varieties), mentions in its docs that heuristic encoding guessers are the cause of many of the problems ftfy is designed to fix. It&#x27;s magical, by the way.<p>It has an entire section of its documentation dedicated to why you should not use heuristic charset detection: <a href="https:&#x2F;&#x2F;ftfy.readthedocs.io&#x2F;en&#x2F;latest&#x2F;avoid.html#don-t-use-chardet" rel="nofollow">https:&#x2F;&#x2F;ftfy.readthedocs.io&#x2F;en&#x2F;latest&#x2F;avoid.html#don-t-use-c...</a></div><br/><div id="40206861" class="c"><input type="checkbox" id="c-40206861" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#40204999">root</a><span>|</span><a href="#40205189">parent</a><span>|</span><label class="collapse" for="c-40206861">[-]</label><label class="expand" for="c-40206861">[1 more]</label></div><br/><div class="children"><div class="content">That section explains why not to use a specific naive charset detection library that doesn&#x27;t have a strong prior for UTF-8. There&#x27;s no basis for extrapolating that further.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>