<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725958871810" as="style"/><link rel="stylesheet" href="styles.css?v=1725958871810"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://planetscale.com/blog/btrees-and-database-indexes">B-Trees and Database Indexes</a> <span class="domain">(<a href="https://planetscale.com">planetscale.com</a>)</span></div><div class="subtext"><span>samlambert</span> | <span>42 comments</span></div><br/><div><div id="41492708" class="c"><input type="checkbox" id="c-41492708" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41498639">next</a><span>|</span><label class="collapse" for="c-41492708">[-]</label><label class="expand" for="c-41492708">[4 more]</label></div><br/><div class="children"><div class="content">I realized after a few years of doing it that my strategy for keeping Wikis useful is to treat them as B-Trees.<p>When the landing page gets too full&#x2F;too many outgoing links, I start pushing links and paragraphs down into the child pages, to leave space for a fair share of timely links and on-boarding docs.<p>Similar and older links get pushed down into the sibling that best represents the topic. Then if the destination page is now too big, similar and older links get pushed down to their children.  Eventually all of the outdated docs are three levels down from the landing page, where only historians and experts will see them. And sometimes as we finally decide how part of the system really should work, siblings get combined into one page, minus the speculative work that gets pushed down deeper in the tree. It works remarkably well. At the end of the day documentation is a search problem.<p>I highly recommend it for a Friday afternoon exercise when you want to be productive but you know starting a new task is a complete waste of time.</div><br/><div id="41493275" class="c"><input type="checkbox" id="c-41493275" checked=""/><div class="controls bullet"><span class="by">caseyohara</span><span>|</span><a href="#41492708">parent</a><span>|</span><a href="#41498639">next</a><span>|</span><label class="collapse" for="c-41493275">[-]</label><label class="expand" for="c-41493275">[3 more]</label></div><br/><div class="children"><div class="content">Do you have a recommendation for Wiki software you like to use? My team is in need of an internal knowledge base, and I like the structure of wikis. Most of the SaaS products I&#x27;ve tried or looked at are a bit too shiny&#x2F;fancy and don&#x27;t seem to match my mental model of how a wiki-style knowledge base should work.</div><br/><div id="41495363" class="c"><input type="checkbox" id="c-41495363" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41492708">root</a><span>|</span><a href="#41493275">parent</a><span>|</span><a href="#41496309">next</a><span>|</span><label class="collapse" for="c-41495363">[-]</label><label class="expand" for="c-41495363">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it really matters which you use. I&#x27;ve unfortunately been stuck in Atlassian for ages.<p>But if you were shopping for one, from the standpoint of keeping the docs working being able see missing pages and see incoming links to a page are both pretty helpful.  I kinda miss the latter.</div><br/></div></div><div id="41496309" class="c"><input type="checkbox" id="c-41496309" checked=""/><div class="controls bullet"><span class="by">shnock</span><span>|</span><a href="#41492708">root</a><span>|</span><a href="#41493275">parent</a><span>|</span><a href="#41495363">prev</a><span>|</span><a href="#41498639">next</a><span>|</span><label class="collapse" for="c-41496309">[-]</label><label class="expand" for="c-41496309">[1 more]</label></div><br/><div class="children"><div class="content">Confluence, but we&#x27;re already in deep w Atlassian</div><br/></div></div></div></div></div></div><div id="41498639" class="c"><input type="checkbox" id="c-41498639" checked=""/><div class="controls bullet"><span class="by">tnvmadhav</span><span>|</span><a href="#41492708">prev</a><span>|</span><a href="#41495797">next</a><span>|</span><label class="collapse" for="c-41498639">[-]</label><label class="expand" for="c-41498639">[1 more]</label></div><br/><div class="children"><div class="content">great piece of education. The interactive demos like these help a lot.</div><br/></div></div><div id="41495797" class="c"><input type="checkbox" id="c-41495797" checked=""/><div class="controls bullet"><span class="by">benwilber0</span><span>|</span><a href="#41498639">prev</a><span>|</span><a href="#41497453">next</a><span>|</span><label class="collapse" for="c-41495797">[-]</label><label class="expand" for="c-41495797">[16 more]</label></div><br/><div class="children"><div class="content">This is why you should _never_ make your UUID column the primary key.<p>For one, it&#x27;s enormous.  Now you have to copy that 128bit int to every side of the relation.<p>Two, in most cases it&#x27;s completely random. Unless you had the forethought to use something other than UUIDv4 (gen_random_uuid).  So now you just have a bunch of humongous random numbers clogging up your indexes and duplicated everywhere for no good reason.<p>Use regular bigserial (64bit) PKs for internal table relations and UUIDs (128bit) for application-level identifiers and natural keys.  Your database will be very happy!</div><br/><div id="41495856" class="c"><input type="checkbox" id="c-41495856" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#41495797">parent</a><span>|</span><a href="#41498191">next</a><span>|</span><label class="collapse" for="c-41495856">[-]</label><label class="expand" for="c-41495856">[1 more]</label></div><br/><div class="children"><div class="content">If you sort UUIDs, there will be a lot of common prefixes. B-trees implicitly sort data so you can factor common prefix from all keys of B-tree page.<p>But!<p>UUIDs are random and B-tree will have increased fragmentation after a short while.<p>I once tried to insert a puny 1 million scale free graph edges into a B-tree (BerkeleyDB) in 1K batches and it failed miserably - I&#x27;ve waited for an hour and then killed it. LSM trees were an orders of magnitude faster at 100K edges, so BDB had shown that B-trees are no match there.<p>B-trees are semi-static data structures, they are hard to rebuild incrementally if data is random. But they shine if input keys are sorted.<p>Use UUIDs as you like to use them if your storage engine is LSM tree. Use staged sorting (LSM tree in disguise) if you ue B-tree.</div><br/></div></div><div id="41498191" class="c"><input type="checkbox" id="c-41498191" checked=""/><div class="controls bullet"><span class="by">fabian2k</span><span>|</span><a href="#41495797">parent</a><span>|</span><a href="#41495856">prev</a><span>|</span><a href="#41495817">next</a><span>|</span><label class="collapse" for="c-41498191">[-]</label><label class="expand" for="c-41498191">[1 more]</label></div><br/><div class="children"><div class="content">There are cases where it is really useful to have only universally unique IDs, e.g. if you have multi-tenant systems and at some point you need to move tenants to a different server&#x2F;instance or merge tenants on the same DB.</div><br/></div></div><div id="41495817" class="c"><input type="checkbox" id="c-41495817" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#41495797">parent</a><span>|</span><a href="#41498191">prev</a><span>|</span><a href="#41495837">next</a><span>|</span><label class="collapse" for="c-41495817">[-]</label><label class="expand" for="c-41495817">[2 more]</label></div><br/><div class="children"><div class="content">Won&#x27;t you still need indexes on those UUIDs anyway? And possibly have to do more joins to resolve them?</div><br/><div id="41495822" class="c"><input type="checkbox" id="c-41495822" checked=""/><div class="controls bullet"><span class="by">benwilber0</span><span>|</span><a href="#41495797">root</a><span>|</span><a href="#41495817">parent</a><span>|</span><a href="#41495837">next</a><span>|</span><label class="collapse" for="c-41495822">[-]</label><label class="expand" for="c-41495822">[1 more]</label></div><br/><div class="children"><div class="content">You only need 1 index on the UUID.  Instead of everywhere the UUID is referenced from other tables</div><br/></div></div></div></div><div id="41495837" class="c"><input type="checkbox" id="c-41495837" checked=""/><div class="controls bullet"><span class="by">Sophistifunk</span><span>|</span><a href="#41495797">parent</a><span>|</span><a href="#41495817">prev</a><span>|</span><a href="#41497087">next</a><span>|</span><label class="collapse" for="c-41495837">[-]</label><label class="expand" for="c-41495837">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very interesting to me that we have to keep telling people this, but it hasn&#x27;t become part of the &quot;hive folk knowledge&quot; we all seem to develop. I think DB vendors have been sleeping on an opportunity to encourage better practices.</div><br/><div id="41496062" class="c"><input type="checkbox" id="c-41496062" checked=""/><div class="controls bullet"><span class="by">paxys</span><span>|</span><a href="#41495797">root</a><span>|</span><a href="#41495837">parent</a><span>|</span><a href="#41497087">next</a><span>|</span><label class="collapse" for="c-41496062">[-]</label><label class="expand" for="c-41496062">[1 more]</label></div><br/><div class="children"><div class="content">DB vendors haven&#x27;t done enough to offer ID generation as a core part of their system. Ideally &quot;what ID do I use for this object&quot; shouldn&#x27;t even be a consideration, because <i>of course</i> the database should handle it. It is the system of record after all. Yet your options are pretty much limited to UUID or a basic incremental counter that fails to meet any real world production constraints.</div><br/></div></div></div></div><div id="41497087" class="c"><input type="checkbox" id="c-41497087" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#41495797">parent</a><span>|</span><a href="#41495837">prev</a><span>|</span><a href="#41497221">next</a><span>|</span><label class="collapse" for="c-41497087">[-]</label><label class="expand" for="c-41497087">[4 more]</label></div><br/><div class="children"><div class="content">Nothing wrong with 128bits primary key. Postgres is a horrible DB that can’t order rows on disk, so it doesn’t matter if you use UUIDs or not, you’re SOL.<p>In fact, you could use 512bits primary key with MySQL and still, range queries would be 10x faster and 10x less space in ram than in Postgres. This article explains why that is.</div><br/><div id="41497552" class="c"><input type="checkbox" id="c-41497552" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41495797">root</a><span>|</span><a href="#41497087">parent</a><span>|</span><a href="#41497346">next</a><span>|</span><label class="collapse" for="c-41497552">[-]</label><label class="expand" for="c-41497552">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Nothing wrong with 128bits primary key. Postgres is a horrible DB that can’t order rows on disk, so it doesn’t matter if you use UUIDs or not, you’re SOL.<p>Why do you believe a database should order rows on disk?</div><br/><div id="41497923" class="c"><input type="checkbox" id="c-41497923" checked=""/><div class="controls bullet"><span class="by">stoperaticless</span><span>|</span><a href="#41495797">root</a><span>|</span><a href="#41497552">parent</a><span>|</span><a href="#41497346">next</a><span>|</span><label class="collapse" for="c-41497923">[-]</label><label class="expand" for="c-41497923">[1 more]</label></div><br/><div class="children"><div class="content">1. Faster access by that column.
2. Other DBs allow it&#x2F;default to it.</div><br/></div></div></div></div><div id="41497346" class="c"><input type="checkbox" id="c-41497346" checked=""/><div class="controls bullet"><span class="by">jashmatthews</span><span>|</span><a href="#41495797">root</a><span>|</span><a href="#41497087">parent</a><span>|</span><a href="#41497552">prev</a><span>|</span><a href="#41497221">next</a><span>|</span><label class="collapse" for="c-41497346">[-]</label><label class="expand" for="c-41497346">[1 more]</label></div><br/><div class="children"><div class="content">Clustered tables and sequential keys have their own downsides though like lock contention on the &quot;last&quot; page.</div><br/></div></div></div></div><div id="41497221" class="c"><input type="checkbox" id="c-41497221" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#41495797">parent</a><span>|</span><a href="#41497087">prev</a><span>|</span><a href="#41496164">next</a><span>|</span><label class="collapse" for="c-41497221">[-]</label><label class="expand" for="c-41497221">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re assuming that people store UUIDs as 128-bit int. That&#x27;s overly generous. I know people who use varchar without a second thought, more than doubling the storage requirement!</div><br/></div></div><div id="41496164" class="c"><input type="checkbox" id="c-41496164" checked=""/><div class="controls bullet"><span class="by">wbsun</span><span>|</span><a href="#41495797">parent</a><span>|</span><a href="#41497221">prev</a><span>|</span><a href="#41497453">next</a><span>|</span><label class="collapse" for="c-41496164">[-]</label><label class="expand" for="c-41496164">[4 more]</label></div><br/><div class="children"><div class="content">Isn’t there also hash based index for random keys?</div><br/><div id="41496378" class="c"><input type="checkbox" id="c-41496378" checked=""/><div class="controls bullet"><span class="by">benwilber0</span><span>|</span><a href="#41495797">root</a><span>|</span><a href="#41496164">parent</a><span>|</span><a href="#41497453">next</a><span>|</span><label class="collapse" for="c-41496378">[-]</label><label class="expand" for="c-41496378">[3 more]</label></div><br/><div class="children"><div class="content">Maybe?  idk.  Not in Postgres.   The default index is a B-Tree. A hash-based index would be terrible for disk-seeking, in any case.</div><br/><div id="41496937" class="c"><input type="checkbox" id="c-41496937" checked=""/><div class="controls bullet"><span class="by">eurleif</span><span>|</span><a href="#41495797">root</a><span>|</span><a href="#41496378">parent</a><span>|</span><a href="#41497453">next</a><span>|</span><label class="collapse" for="c-41496937">[-]</label><label class="expand" for="c-41496937">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;indexes-types.html#INDEXES-TYPES-HASH" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;indexes-types.html#I...</a></div><br/><div id="41497053" class="c"><input type="checkbox" id="c-41497053" checked=""/><div class="controls bullet"><span class="by">benwilber0</span><span>|</span><a href="#41495797">root</a><span>|</span><a href="#41496937">parent</a><span>|</span><a href="#41497453">next</a><span>|</span><label class="collapse" for="c-41497053">[-]</label><label class="expand" for="c-41497053">[1 more]</label></div><br/><div class="children"><div class="content">Probably the worst PK index of all time.   There&#x27;s a reason why it&#x27;s barely ever used.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41497453" class="c"><input type="checkbox" id="c-41497453" checked=""/><div class="controls bullet"><span class="by">dorbodwolf</span><span>|</span><a href="#41495797">prev</a><span>|</span><a href="#41498355">next</a><span>|</span><label class="collapse" for="c-41497453">[-]</label><label class="expand" for="c-41497453">[1 more]</label></div><br/><div class="children"><div class="content">If our disk block and B-tree node is 16k, and our keys, values, and child pointers are all 8 bits, this means we could store 682 key&#x2F;values with 683 child pointers per node. A three level tree could store over 300 million key&#x2F;value pairs (682 × 682 × 682 = 317,214,568). —— Should be 8 bytes per element?</div><br/></div></div><div id="41498355" class="c"><input type="checkbox" id="c-41498355" checked=""/><div class="controls bullet"><span class="by">misonic</span><span>|</span><a href="#41497453">prev</a><span>|</span><a href="#41496272">next</a><span>|</span><label class="collapse" for="c-41498355">[-]</label><label class="expand" for="c-41498355">[1 more]</label></div><br/><div class="children"><div class="content">may I ask what the v0, v1, ...v10 mean in those graphs? different pages?</div><br/></div></div><div id="41496272" class="c"><input type="checkbox" id="c-41496272" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#41498355">prev</a><span>|</span><a href="#41496446">next</a><span>|</span><label class="collapse" for="c-41496272">[-]</label><label class="expand" for="c-41496272">[1 more]</label></div><br/><div class="children"><div class="content">Awesome article!<p>I only wished that the reference to InnoDB storing data in the B tree itself is otherwise referred to as a clustered index.<p>MyISAM before it was non-clustered.<p>Oracle and others let you choose.</div><br/></div></div><div id="41496446" class="c"><input type="checkbox" id="c-41496446" checked=""/><div class="controls bullet"><span class="by">is_true</span><span>|</span><a href="#41496272">prev</a><span>|</span><a href="#41495748">next</a><span>|</span><label class="collapse" for="c-41496446">[-]</label><label class="expand" for="c-41496446">[2 more]</label></div><br/><div class="children"><div class="content">The cookie modal doesn&#x27;t work on Firefox mobile and it takes half the height.<p>Why don&#x27;t let the user set that up on their browser</div><br/><div id="41496934" class="c"><input type="checkbox" id="c-41496934" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#41496446">parent</a><span>|</span><a href="#41495748">next</a><span>|</span><label class="collapse" for="c-41496934">[-]</label><label class="expand" for="c-41496934">[1 more]</label></div><br/><div class="children"><div class="content">Or Chromium mobile</div><br/></div></div></div></div><div id="41495748" class="c"><input type="checkbox" id="c-41495748" checked=""/><div class="controls bullet"><span class="by">yosri-xp</span><span>|</span><a href="#41496446">prev</a><span>|</span><a href="#41491982">next</a><span>|</span><label class="collapse" for="c-41495748">[-]</label><label class="expand" for="c-41495748">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the amazing visual, Me and my team had worked on BTree+ indexing support on the top of Aerospike as we have different huge data sets 5T of data and each data set belong to an X property which suppose to have its own order table indexing.<p>The challenging part was evicting the expired keys from the BTree+ where the inserted keys would have TTL  therefore we decided to fuse only one level branch and within the first sibling leaf nodes as it would be expensive if we perform clean up all the way up which would cause high lock contention and slow things down substantially specially when keys get inserted&#x2F;deleted&#x2F;updated.<p>Also we had to do sharding on top of the BTree+ to speed things up and reduce the high lock contention, that way we know what shard the the keys belong to and we lock the branch before performing any CUD, That way  we can perform high concurrent operations on multiple shards&#x2F;branches.<p>The clean up process might have some caveat and the Btree+ ends up unbalanced. We had to provide rebuild indexing feature so that would fix all the gaps if necessary to avoid extra clean up operations.<p>Again Thanks for the visuals.</div><br/></div></div><div id="41491982" class="c"><input type="checkbox" id="c-41491982" checked=""/><div class="controls bullet"><span class="by">VeejayRampay</span><span>|</span><a href="#41495748">prev</a><span>|</span><a href="#41497779">next</a><span>|</span><label class="collapse" for="c-41491982">[-]</label><label class="expand" for="c-41491982">[9 more]</label></div><br/><div class="children"><div class="content">beautiful interactive visualizations, this is top shelf in terms of pedagogy and vulgarization</div><br/><div id="41492284" class="c"><input type="checkbox" id="c-41492284" checked=""/><div class="controls bullet"><span class="by">eclectic29</span><span>|</span><a href="#41491982">parent</a><span>|</span><a href="#41492117">next</a><span>|</span><label class="collapse" for="c-41492284">[-]</label><label class="expand" for="c-41492284">[7 more]</label></div><br/><div class="children"><div class="content">Slightly off topic: Learnt a new word today &#x27;vulgarization&#x27; which seems to have a completely different meaning from the obvious. Thanks.</div><br/><div id="41492466" class="c"><input type="checkbox" id="c-41492466" checked=""/><div class="controls bullet"><span class="by">egwynn</span><span>|</span><a href="#41491982">root</a><span>|</span><a href="#41492284">parent</a><span>|</span><a href="#41492117">next</a><span>|</span><label class="collapse" for="c-41492466">[-]</label><label class="expand" for="c-41492466">[6 more]</label></div><br/><div class="children"><div class="content">Note that, in the abstract, “vulgar” means “common” (as in “vulgar latin”). Indeed, its negative connotations come from that same sense: “common” people are unrefined.</div><br/><div id="41492649" class="c"><input type="checkbox" id="c-41492649" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41491982">root</a><span>|</span><a href="#41492466">parent</a><span>|</span><a href="#41492117">next</a><span>|</span><label class="collapse" for="c-41492649">[-]</label><label class="expand" for="c-41492649">[5 more]</label></div><br/><div class="children"><div class="content">The association between vulgarity and propriety (and class distinctions) sort of ruins that word, particularly in the english speaking west.<p>I wonder if that&#x27;s as big of a problem in the romance languages (which all treat left&#x2F;right the same way - left = bad, right = good)</div><br/><div id="41494766" class="c"><input type="checkbox" id="c-41494766" checked=""/><div class="controls bullet"><span class="by">LtdJorge</span><span>|</span><a href="#41491982">root</a><span>|</span><a href="#41492649">parent</a><span>|</span><a href="#41492898">next</a><span>|</span><label class="collapse" for="c-41494766">[-]</label><label class="expand" for="c-41494766">[1 more]</label></div><br/><div class="children"><div class="content">Yes, in Spanish vulgar is used as inappropriate. We have &quot;el vulgo&quot; (el pueblo, the people), which kinda teaches you the correct meaning, popular, unrefined. But &quot;vulgo&quot; is seldomly used.</div><br/></div></div><div id="41492898" class="c"><input type="checkbox" id="c-41492898" checked=""/><div class="controls bullet"><span class="by">jjgreen</span><span>|</span><a href="#41491982">root</a><span>|</span><a href="#41492649">parent</a><span>|</span><a href="#41494766">prev</a><span>|</span><a href="#41492117">next</a><span>|</span><label class="collapse" for="c-41492898">[-]</label><label class="expand" for="c-41492898">[3 more]</label></div><br/><div class="children"><div class="content">Indeed: are you sinister or dexterous?</div><br/><div id="41495367" class="c"><input type="checkbox" id="c-41495367" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#41491982">root</a><span>|</span><a href="#41492898">parent</a><span>|</span><a href="#41493696">next</a><span>|</span><label class="collapse" for="c-41495367">[-]</label><label class="expand" for="c-41495367">[1 more]</label></div><br/><div class="children"><div class="content">As a left-handed contrarian, I’ve always enjoyed that sinister and left handed go hand in hand.</div><br/></div></div><div id="41493696" class="c"><input type="checkbox" id="c-41493696" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41491982">root</a><span>|</span><a href="#41492898">parent</a><span>|</span><a href="#41495367">prev</a><span>|</span><a href="#41492117">next</a><span>|</span><label class="collapse" for="c-41493696">[-]</label><label class="expand" for="c-41493696">[1 more]</label></div><br/><div class="children"><div class="content">In French the same word for “right” means the same notion in English for<p>- direction<p>- straight ahead<p>- civics<p>- propriety</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41492117" class="c"><input type="checkbox" id="c-41492117" checked=""/><div class="controls bullet"><span class="by">bddicken</span><span>|</span><a href="#41491982">parent</a><span>|</span><a href="#41492284">prev</a><span>|</span><a href="#41497779">next</a><span>|</span><label class="collapse" for="c-41492117">[-]</label><label class="expand" for="c-41492117">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the goal! Thanks for the kind words.</div><br/></div></div></div></div></div></div></div></div></div></body></html>