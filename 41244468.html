<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723712457157" as="style"/><link rel="stylesheet" href="styles.css?v=1723712457157"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://syndicate-lang.org/about/">The Syndicated Actor Model</a> <span class="domain">(<a href="https://syndicate-lang.org">syndicate-lang.org</a>)</span></div><div class="subtext"><span>sph</span> | <span>37 comments</span></div><br/><div><div id="41248151" class="c"><input type="checkbox" id="c-41248151" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#41245242">next</a><span>|</span><label class="collapse" for="c-41248151">[-]</label><label class="expand" for="c-41248151">[2 more]</label></div><br/><div class="children"><div class="content">Interesting! I don&#x27;t think I quite understand how this compares to the vat model of actors that was used in E and what tuplespaces are contributing here. I guess I&#x27;d just need to sit down and try using the language.<p>See also Goblins, an actor model + object capability system inspired by a lot of the same stuff (like E) that uses the Preserves-derived Syrup format for encoding messages over the network. <a href="https:&#x2F;&#x2F;spritely.institute&#x2F;goblins&#x2F;" rel="nofollow">https:&#x2F;&#x2F;spritely.institute&#x2F;goblins&#x2F;</a><p>There&#x27;s also a standard in development for communicating capabilities over the network called OCapN: <a href="https:&#x2F;&#x2F;ocapn.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ocapn.org&#x2F;</a></div><br/><div id="41249658" class="c"><input type="checkbox" id="c-41249658" checked=""/><div class="controls bullet"><span class="by">dannyobrien</span><span>|</span><a href="#41248151">parent</a><span>|</span><a href="#41245242">next</a><span>|</span><label class="collapse" for="c-41249658">[-]</label><label class="expand" for="c-41249658">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s some pre-existing crossover with the projects (e.g. Spritely&#x2F;Ocapn&#x27;s Syrup serialisation format is a version of Syndicate&#x27;s Preserves)
<a href="https:&#x2F;&#x2F;preserves.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;preserves.dev&#x2F;</a>
<a href="https:&#x2F;&#x2F;gitlab.com&#x2F;spritely&#x2F;syrup" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;spritely&#x2F;syrup</a></div><br/></div></div></div></div><div id="41245242" class="c"><input type="checkbox" id="c-41245242" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#41248151">prev</a><span>|</span><a href="#41246903">next</a><span>|</span><label class="collapse" for="c-41245242">[-]</label><label class="expand" for="c-41245242">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Ambients-like treatment of system boundaries<p>Probably more in the thesis, but at a glance this mention isn&#x27;t further defined or referenced.  The <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ambient_calculus" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ambient_calculus</a> is quite beautiful and IMHO doesn&#x27;t get the attention it deserves.  Undergrad as far as I know never covers it, and most people I meet have never heard of it.  AFAIK tuplespaces also are not usually taught, and people that <i>have</i> heard of it tend to dismiss it as &quot;just some obsolete old java thing&quot; because the most popular implementation probably does fit in that category.  A shame since this is really cool stuff.<p>One problem that I see with all 3 technologies (ambients, tuplespaces, and syndicate) is that they sit somewhere at the intersection of  datastructures &#x2F; infrastructure &#x2F; frameworks, but don&#x27;t have clear and obvious deployment options.  Compare this with say, akka on kubernetes.  No matter how cool your tech is, this is an immediate non-starter for everything except academic investigation or low-level systems programming.  Synit for user-space sounds neat, but if syndicate is generally a better model than Akka and additionally productionizing the other great ideas of past concurrency research, then it would be awesome to see the gap for other use-cases addressed.</div><br/><div id="41246691" class="c"><input type="checkbox" id="c-41246691" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41245242">parent</a><span>|</span><a href="#41246903">next</a><span>|</span><label class="collapse" for="c-41246691">[-]</label><label class="expand" for="c-41246691">[4 more]</label></div><br/><div class="children"><div class="content">Ambients seem indeed cool and this is where I first heard about them.<p>&gt; One problem that I see with all 3 technologies (ambients, tuplespaces, and syndicate) is that they sit somewhere at the intersection of datastructures &#x2F; infrastructure &#x2F; frameworks, but don&#x27;t have clear and obvious deployment options.<p>I disagree. I think it&#x27;s simply still science fiction and the cutting edge of distributed research which isn&#x27;t very popular in academia these days. Actors (1978) are just now barely becoming mainstream with the hype of Elixir and rediscovery of Erlang, even though the world still runs on multithreaded C and dead locks.<p>The tech is cool, but no one is being paid just yet to create practical languages and environments out of this. As in many other scientific endeavours, mainstream programming paradigms tend to lag 20 or 30 years compared to the research.</div><br/><div id="41251102" class="c"><input type="checkbox" id="c-41251102" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#41245242">root</a><span>|</span><a href="#41246691">parent</a><span>|</span><a href="#41246903">next</a><span>|</span><label class="collapse" for="c-41251102">[-]</label><label class="expand" for="c-41251102">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s been an increasing interest in the Fediverse and local-first programming. Not quite mainstream, but they are well out of the academia.<p>I have never heard of these ideas about the Syndicated Actor, but they seem like they might hold answers for issues in the Fediverse and make implementing local-first software more practical,.<p>We have things with synchronizing state between web clients and servers and jump though all kinds of hoops with that (example, Relay), and I wonder if this would help with that. Lumen (Elixir on WASM) has stalled in development and LiveView is popular, but maybe with this, that is not what we want to do anyways.<p>We have things like event-driven architecture, microservices, and DDD, but maybe that results from using narrowly-scoped primitives that isn&#x27;t suitable for everything. But we use it for adjacent use-cases because that is all we have for commercial languages.<p>I&#x27;d love to see how this can work out in Elixir.</div><br/><div id="41253101" class="c"><input type="checkbox" id="c-41253101" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#41245242">root</a><span>|</span><a href="#41251102">parent</a><span>|</span><a href="#41246903">next</a><span>|</span><label class="collapse" for="c-41253101">[-]</label><label class="expand" for="c-41253101">[2 more]</label></div><br/><div class="children"><div class="content">In a lot of ways elixir still seems like it’s waiting for the killer app, and yeah, things along these lines feel like a natural fit.</div><br/><div id="41253727" class="c"><input type="checkbox" id="c-41253727" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41245242">root</a><span>|</span><a href="#41253101">parent</a><span>|</span><a href="#41246903">next</a><span>|</span><label class="collapse" for="c-41253727">[-]</label><label class="expand" for="c-41253727">[1 more]</label></div><br/><div class="children"><div class="content">Phoenix Live View is the killer app IMO.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41246903" class="c"><input type="checkbox" id="c-41246903" checked=""/><div class="controls bullet"><span class="by">butterisgood</span><span>|</span><a href="#41245242">prev</a><span>|</span><a href="#41245218">next</a><span>|</span><label class="collapse" for="c-41246903">[-]</label><label class="expand" for="c-41246903">[4 more]</label></div><br/><div class="children"><div class="content">This sounds like a modern Linda which is itself a coordination language between parallel actors reduced down to a very simplified model of pattern matching and &quot;pub&#x2F;sub&quot;.<p>This kind of parallel programming fell out of favor with PVM and MPI kind of taking over the space in the late 90s, but I suspect Tuplespaces were just a bit ahead of their time.<p>Things like this can potentially really help with the observability of distributed systems, which has been a huge pain especially in areas of eventual consistency.</div><br/><div id="41247071" class="c"><input type="checkbox" id="c-41247071" checked=""/><div class="controls bullet"><span class="by">kayo_20211030</span><span>|</span><a href="#41246903">parent</a><span>|</span><a href="#41250803">next</a><span>|</span><label class="collapse" for="c-41247071">[-]</label><label class="expand" for="c-41247071">[1 more]</label></div><br/><div class="children"><div class="content">Agree. I thought the concept of tuplespaces was super interesting and, unfortunately and definitely, ahead of its time. IBM had some decent papers on it.</div><br/></div></div><div id="41250803" class="c"><input type="checkbox" id="c-41250803" checked=""/><div class="controls bullet"><span class="by">jjtheblunt</span><span>|</span><a href="#41246903">parent</a><span>|</span><a href="#41247071">prev</a><span>|</span><a href="#41248612">next</a><span>|</span><label class="collapse" for="c-41250803">[-]</label><label class="expand" for="c-41250803">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;worrydream.com&#x2F;refs&#x2F;Carriero_1989_-_Linda_in_Context.pdf" rel="nofollow">https:&#x2F;&#x2F;worrydream.com&#x2F;refs&#x2F;Carriero_1989_-_Linda_in_Context...</a></div><br/></div></div><div id="41248612" class="c"><input type="checkbox" id="c-41248612" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#41246903">parent</a><span>|</span><a href="#41250803">prev</a><span>|</span><a href="#41245218">next</a><span>|</span><label class="collapse" for="c-41248612">[-]</label><label class="expand" for="c-41248612">[1 more]</label></div><br/><div class="children"><div class="content">I see eventual consistency here as a bit of copout. it really does limit the applicability of the approach by making really not obvious when things are starting to decohere. Someone else mentioned Alvaro in this thread, and I think thats a really fruitful body of work to look for answers that don&#x27;t require a strong central serialization agent. Monotonicity, vector clocks, multi-panos style domain partitioning, these are partial answers for making this kind of thing be a foundation you can reason about and still scale.</div><br/></div></div></div></div><div id="41245218" class="c"><input type="checkbox" id="c-41245218" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#41246903">prev</a><span>|</span><a href="#41245954">next</a><span>|</span><label class="collapse" for="c-41245218">[-]</label><label class="expand" for="c-41245218">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very interested in concurrency and new paradigms from a pragmatic perspective. Maybe it&#x27;s because I&#x27;m practically minded, but I don&#x27;t have the energy to parse this type of content (and that&#x27;s ok, not blaming anyone).<p>That said, I really, really appreciate when I can see a tangible piece of code that solves a real problem. In the case of concurrency, perhaps a hello world from an actor, ping pong, a chat room, cancellation, timeout or similar. Show something that&#x27;s easy to do in this model, which is tedious to do in different models. (This shouldn&#x27;t be hard to find, since concurrency is ridiculously easy to get wrong in most languages).<p>If a partial goal is to engage practicians, then code samples is very effective. I usually don&#x27;t need the full theory to grok code even in a foreign paradigm. If I can get an initial sense and I like it, then I am infinitely more willing to read up on the theory. Now, unfortunately, you&#x27;re missing out on one very curious, albeit lazy, reader.<p>For the record, the closest I could find was some pseudo-code[1]. If there&#x27;s more please share!<p>[1]: <a href="https:&#x2F;&#x2F;synit.org&#x2F;book&#x2F;syndicated-actor-model.html" rel="nofollow">https:&#x2F;&#x2F;synit.org&#x2F;book&#x2F;syndicated-actor-model.html</a><p>EDIT: I&#x27;m stupid, there are a couple of examples on the linked page if you scroll down. I wish there were more!</div><br/><div id="41245982" class="c"><input type="checkbox" id="c-41245982" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41245218">parent</a><span>|</span><a href="#41252115">next</a><span>|</span><label class="collapse" for="c-41245982">[-]</label><label class="expand" for="c-41245982">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m very interested in concurrency and new paradigms from a pragmatic perspective.<p>Tell me about it. I also lack formal education, and a lot of advanced research into distributed communication models is basically expressed in alien languages to me, i.e. pi-calculus, rho-calculus, even Hewitt&#x27;s research. It is both fun and a bit frustrating trying to figure out how they would work in practice from formal academic papers.<p>This one has a lot of actual Racket code though, you might want to read the history section for some practical examples.</div><br/></div></div><div id="41246730" class="c"><input type="checkbox" id="c-41246730" checked=""/><div class="controls bullet"><span class="by">metadaemon</span><span>|</span><a href="#41245218">parent</a><span>|</span><a href="#41252115">prev</a><span>|</span><a href="#41245954">next</a><span>|</span><label class="collapse" for="c-41246730">[-]</label><label class="expand" for="c-41246730">[1 more]</label></div><br/><div class="children"><div class="content">I clicked around on Tony&#x27;s site and found this listing of Syndicate related repositories: <a href="https:&#x2F;&#x2F;syndicate-lang.org&#x2F;code&#x2F;repos&#x2F;" rel="nofollow">https:&#x2F;&#x2F;syndicate-lang.org&#x2F;code&#x2F;repos&#x2F;</a></div><br/></div></div></div></div><div id="41245954" class="c"><input type="checkbox" id="c-41245954" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#41245218">prev</a><span>|</span><a href="#41249239">next</a><span>|</span><label class="collapse" for="c-41245954">[-]</label><label class="expand" for="c-41245954">[5 more]</label></div><br/><div class="children"><div class="content">I think my favorite Actor framework is Microsoft&#x27;s Orleans, which uses a &quot;Virtual Actor&quot; model. It is mainly implemented in C#, and EA implemented their own version in Java then Kotlin called Orbit, but it feels very straight forward for what it does, it was also used extensively to scale the Halo online servers.<p>Decent articles on Orleans and Virtual Actor model.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;orleans&#x2F;overview" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;orleans&#x2F;overview</a><p><a href="https:&#x2F;&#x2F;darlean.io&#x2F;the-virtual-actor-model&#x2F;" rel="nofollow">https:&#x2F;&#x2F;darlean.io&#x2F;the-virtual-actor-model&#x2F;</a><p>Discussion on Orbit by EA:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31192795">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31192795</a><p>This basically makes C# behave Erlang esque. You can have a single server running until load kicks off, and even if you destroy a node, spinning it up again is easy. Nodes maintain their own state and can be across systems as needed. You can also do zero-downtime updating like in Erlang. It&#x27;s really neat. I assume Syndicated Actor Model solves a similar problem, but it looks like they make use of an MQ as needed.<p>What&#x27;s funny about Orbit though is the Akka devs wrote some sort of &quot;hit&quot; piece about why their model is fine, and you don&#x27;t need Virtual Actors.</div><br/><div id="41247582" class="c"><input type="checkbox" id="c-41247582" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#41245954">parent</a><span>|</span><a href="#41252129">next</a><span>|</span><label class="collapse" for="c-41247582">[-]</label><label class="expand" for="c-41247582">[1 more]</label></div><br/><div class="children"><div class="content">I like the constraints these models impose for some applications, but I don&#x27;t see them as fundamentally revolutionizing the application development space. You are still ultimately responsible for persisting every last byte of state that these virtual actors embody. Much of this looks like &quot;How to Draw an Owl&quot; [0] to me.<p>You could tie your own hands in approximately same way in a typical monolithic codebase by spinning out some Actor&#x2F;Grain base types and enforcing a similar execution model around their implementations.<p>[0]: <a href="https:&#x2F;&#x2F;knowyourmeme.com&#x2F;memes&#x2F;how-to-draw-an-owl" rel="nofollow">https:&#x2F;&#x2F;knowyourmeme.com&#x2F;memes&#x2F;how-to-draw-an-owl</a></div><br/></div></div><div id="41247464" class="c"><input type="checkbox" id="c-41247464" checked=""/><div class="controls bullet"><span class="by">binalpatel</span><span>|</span><a href="#41245954">parent</a><span>|</span><a href="#41252129">prev</a><span>|</span><a href="#41249239">next</a><span>|</span><label class="collapse" for="c-41247464">[-]</label><label class="expand" for="c-41247464">[2 more]</label></div><br/><div class="children"><div class="content">Virtual actors are so nice, Dapr[1] uses them as well. You can get hack together something like a virtual actor with Ray too but I&#x27;m hoping their actors eventually evolve into something like virtual actors eventually.<p>[1] <a href="https:&#x2F;&#x2F;docs.dapr.io&#x2F;developing-applications&#x2F;building-blocks&#x2F;actors&#x2F;actors-overview&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.dapr.io&#x2F;developing-applications&#x2F;building-blocks...</a></div><br/><div id="41248149" class="c"><input type="checkbox" id="c-41248149" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#41245954">root</a><span>|</span><a href="#41247464">parent</a><span>|</span><a href="#41249239">next</a><span>|</span><label class="collapse" for="c-41248149">[-]</label><label class="expand" for="c-41248149">[1 more]</label></div><br/><div class="children"><div class="content">Whats funny to me is Dapr is also by Microsoft, but at least you can use it with other languages too.</div><br/></div></div></div></div></div></div><div id="41249239" class="c"><input type="checkbox" id="c-41249239" checked=""/><div class="controls bullet"><span class="by">discreteevent</span><span>|</span><a href="#41245954">prev</a><span>|</span><a href="#41246328">next</a><span>|</span><label class="collapse" for="c-41249239">[-]</label><label class="expand" for="c-41249239">[1 more]</label></div><br/><div class="children"><div class="content">Possibly similar (but I don&#x27;t understand the Syndicated Actor  Model well enough yet to be sure): Data Distribution Service (DDS)<p><a href="https:&#x2F;&#x2F;www.dds-foundation.org&#x2F;what-is-dds-3&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.dds-foundation.org&#x2F;what-is-dds-3&#x2F;</a></div><br/></div></div><div id="41246328" class="c"><input type="checkbox" id="c-41246328" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#41249239">prev</a><span>|</span><a href="#41250198">next</a><span>|</span><label class="collapse" for="c-41246328">[-]</label><label class="expand" for="c-41246328">[1 more]</label></div><br/><div class="children"><div class="content">As an aside, I&#x27;m a big fan of this site&#x27;s imitation of neoplasticism as a form of web design</div><br/></div></div><div id="41250198" class="c"><input type="checkbox" id="c-41250198" checked=""/><div class="controls bullet"><span class="by">rjpruitt16</span><span>|</span><a href="#41246328">prev</a><span>|</span><a href="#41244871">next</a><span>|</span><label class="collapse" for="c-41250198">[-]</label><label class="expand" for="c-41250198">[1 more]</label></div><br/><div class="children"><div class="content">I am surprise to see no implementation in erlang, elixir, and gleam</div><br/></div></div><div id="41244871" class="c"><input type="checkbox" id="c-41244871" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41250198">prev</a><span>|</span><label class="collapse" for="c-41244871">[-]</label><label class="expand" for="c-41244871">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll attempt a tl;dr of this project:<p>Carl Hewitt&#x27;s actor model (often seen in Erlang, Akka &amp; co.) uses message-passing to communicate between concurrent actors, but doesn&#x27;t easily allow for state synchronization or dynamic topologies of actors.<p>Tuple Spaces [<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Tuple_space" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Tuple_space</a>] are another paradigm for distributed communication where message tuples are stored into distributed shared &quot;space&quot; and processes can pull messages that match a certain pattern. Very much like how biological cell communicate between each other, which allows for dynamic topologies, but you lose any concept of ordering (message X came before message Y)<p>The Syndicated Actor model is an attempt at bridging the two ideas to dynamically allow neighbouring actors to coordinate and communicate with each other using something like pub&#x2F;sub.<p>---<p>The history page is very much worth reading: <a href="https:&#x2F;&#x2F;syndicate-lang.org&#x2F;about&#x2F;history&#x2F;" rel="nofollow">https:&#x2F;&#x2F;syndicate-lang.org&#x2F;about&#x2F;history&#x2F;</a><p>Here&#x27;s the author&#x27;s doctoral thesis: <a href="https:&#x2F;&#x2F;syndicate-lang.org&#x2F;papers&#x2F;conversational-concurrency-201712310922.pdf" rel="nofollow">https:&#x2F;&#x2F;syndicate-lang.org&#x2F;papers&#x2F;conversational-concurrency...</a><p>And SYNIT, a reactive layer for Linux which aims to replace most user-space subsystems with this model: <a href="https:&#x2F;&#x2F;synit.org&#x2F;book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;synit.org&#x2F;book&#x2F;</a></div><br/><div id="41246436" class="c"><input type="checkbox" id="c-41246436" checked=""/><div class="controls bullet"><span class="by">svieira</span><span>|</span><a href="#41244871">parent</a><span>|</span><a href="#41252177">next</a><span>|</span><label class="collapse" for="c-41246436">[-]</label><label class="expand" for="c-41246436">[1 more]</label></div><br/><div class="children"><div class="content">The author also directly relates this to Datalog and its descendants, so if you like Peter Alvaro&#x27;s work this may be worth looking into more<p>&gt; State management via dataspaces is directly comparable to a distributed datalog-based system, and enjoys many of the same benefits.<p><a href="https:&#x2F;&#x2F;syndicate-lang.org&#x2F;about&#x2F;syndicate-in-context&#x2F;" rel="nofollow">https:&#x2F;&#x2F;syndicate-lang.org&#x2F;about&#x2F;syndicate-in-context&#x2F;</a></div><br/></div></div><div id="41252177" class="c"><input type="checkbox" id="c-41252177" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#41244871">parent</a><span>|</span><a href="#41246436">prev</a><span>|</span><a href="#41245705">next</a><span>|</span><label class="collapse" for="c-41252177">[-]</label><label class="expand" for="c-41252177">[2 more]</label></div><br/><div class="children"><div class="content">This sounds awfully similar to Scoped Propogators. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40916193">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40916193</a></div><br/><div id="41253771" class="c"><input type="checkbox" id="c-41253771" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41244871">root</a><span>|</span><a href="#41252177">parent</a><span>|</span><a href="#41245705">next</a><span>|</span><label class="collapse" for="c-41253771">[-]</label><label class="expand" for="c-41253771">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, they are not at all the same thing, though I have been entertaining the idea of building a propagator with this model.</div><br/></div></div></div></div><div id="41245705" class="c"><input type="checkbox" id="c-41245705" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#41244871">parent</a><span>|</span><a href="#41252177">prev</a><span>|</span><a href="#41250581">next</a><span>|</span><label class="collapse" for="c-41245705">[-]</label><label class="expand" for="c-41245705">[8 more]</label></div><br/><div class="children"><div class="content">I tried to understand Tuple Space a few times but I don&#x27;t get it.<p>I understand Erlang and the actor model and how distributed processes work, but what is unique in the Tuple Space aspect? I vaguely recall getting it but it doesn&#x27;t register for me now.<p>Maybe it&#x27;s because Erlang already has pub&#x2F;sub for every &#x27;thing?&#x27;</div><br/><div id="41246121" class="c"><input type="checkbox" id="c-41246121" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#41244871">root</a><span>|</span><a href="#41245705">parent</a><span>|</span><a href="#41250581">next</a><span>|</span><label class="collapse" for="c-41246121">[-]</label><label class="expand" for="c-41246121">[7 more]</label></div><br/><div class="children"><div class="content">In Erlang you have a PID and send messages directly to it. The topology is a directed graph.<p>Process in a tuple space just communicate through shared memory. Messages have no address. And processes can write or pattern match messages from this shared memory space.<p><pre><code>    Process A:
    put({&quot;foo&quot;, &quot;bar&quot;, 123})
    put({&quot;foo&quot;, &quot;quux&quot;, 456})

    Process B, later:
    get({&quot;foo&quot;, ?x, 123})
    # here x = &quot;bar&quot;
</code></pre>
Imagine a cell communicating with others by squirting out molecules meant for no one in particular, and having external receptors to match specific other molecules.<p>This allows actors that have not been designed to work with each other to communicate, just by sharing the same tuple space.</div><br/><div id="41247484" class="c"><input type="checkbox" id="c-41247484" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41244871">root</a><span>|</span><a href="#41246121">parent</a><span>|</span><a href="#41246768">next</a><span>|</span><label class="collapse" for="c-41247484">[-]</label><label class="expand" for="c-41247484">[5 more]</label></div><br/><div class="children"><div class="content">This sounds like you effectively have a global schema (in the DB sense) that all actors have to be consistent with, causing everything to be coupled with everything.</div><br/><div id="41247941" class="c"><input type="checkbox" id="c-41247941" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#41244871">root</a><span>|</span><a href="#41247484">parent</a><span>|</span><a href="#41246768">next</a><span>|</span><label class="collapse" for="c-41247941">[-]</label><label class="expand" for="c-41247941">[4 more]</label></div><br/><div class="children"><div class="content">They’re coupled only as far as agreeing on a message format constitutes coupling, which is something you have to do in any actor system anyway.  Bigger issue is that tuplespaces tend to be centralized, so it is very much like an app listening to table events in a db, but without a predefined schema.  It’s more like pub&#x2F;sub except one subscribes by message structure, not channel identity.</div><br/><div id="41248175" class="c"><input type="checkbox" id="c-41248175" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41244871">root</a><span>|</span><a href="#41247941">parent</a><span>|</span><a href="#41246768">next</a><span>|</span><label class="collapse" for="c-41248175">[-]</label><label class="expand" for="c-41248175">[3 more]</label></div><br/><div class="children"><div class="content">You also have to prevent unrelated actors from choosing overlapping (conflicting) message formats. In other words, you can’t decide on a new message format without knowledge of all already existing message formats.</div><br/><div id="41248538" class="c"><input type="checkbox" id="c-41248538" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#41244871">root</a><span>|</span><a href="#41248175">parent</a><span>|</span><a href="#41246768">next</a><span>|</span><label class="collapse" for="c-41248538">[-]</label><label class="expand" for="c-41248538">[2 more]</label></div><br/><div class="children"><div class="content">or you can just use namespaces</div><br/><div id="41248585" class="c"><input type="checkbox" id="c-41248585" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41244871">root</a><span>|</span><a href="#41248538">parent</a><span>|</span><a href="#41246768">next</a><span>|</span><label class="collapse" for="c-41248585">[-]</label><label class="expand" for="c-41248585">[1 more]</label></div><br/><div class="children"><div class="content">This would seem to counter “This allows actors that have not been designed to work with each other to communicate, just by sharing the same tuple space.” Alternatively, I don’t see the big difference to just using separate message queues with pattern-based retrieval. In the end, you always have to design who communicates with who in which format.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41246768" class="c"><input type="checkbox" id="c-41246768" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#41244871">root</a><span>|</span><a href="#41246121">parent</a><span>|</span><a href="#41247484">prev</a><span>|</span><a href="#41250581">next</a><span>|</span><label class="collapse" for="c-41246768">[-]</label><label class="expand" for="c-41246768">[1 more]</label></div><br/><div class="children"><div class="content">So like an implicit global mnesia accessed by &quot;tuples&quot; &#x2F; some identity?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>