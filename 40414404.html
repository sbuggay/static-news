<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716282065083" as="style"/><link rel="stylesheet" href="styles.css?v=1716282065083"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2405.10387">Grothendieck’s use of equality</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>golol</span> | <span>114 comments</span></div><br/><div><div id="40415731" class="c"><input type="checkbox" id="c-40415731" checked=""/><div class="controls bullet"><span class="by">generationP</span><span>|</span><a href="#40416710">next</a><span>|</span><label class="collapse" for="c-40415731">[-]</label><label class="expand" for="c-40415731">[51 more]</label></div><br/><div class="children"><div class="content">This is probably better known here under the name of implicit type conversions. Strictly speaking, the rational number 1 is not the same as the integer 1; we just have a conversion map that preserves all the relevant properties. It&#x27;s all fun and games until there are 1000 types and 10000 conversion maps involved and the relevant diagrams no longer commute (i.e., it depends what order you go).</div><br/><div id="40417876" class="c"><input type="checkbox" id="c-40417876" checked=""/><div class="controls bullet"><span class="by">reaperman</span><span>|</span><a href="#40415731">parent</a><span>|</span><a href="#40417249">next</a><span>|</span><label class="collapse" for="c-40417876">[-]</label><label class="expand" for="c-40417876">[5 more]</label></div><br/><div class="children"><div class="content">&gt; (i.e., it depends what order you go)<p>At the risk of utterly derailing this with irrelevant discussion: path-dependent systems are particularly tricky for some people IMHO. I think in a more state-based way, and my first rigorous dive into path-dependent calculation was during my chemical engineering degree -- I learned to be extremely vigilant about memorizing what was path-dependent and triple-checking if that affected the situation I was calculating.<p>I do wish there was more rigorous exposure to them at lower levels of education and younger age. Because while I&#x27;m perfectly capable of handling path-dependent systems with proper focus and effort, my brain doesn&#x27;t feel &quot;native&quot; when deriving solutions around those spaces - it feels similar to being &quot;fluent enough&quot; in another language. I feel this way about a lot of things -- I really feel I&#x27;d have been happier and more fulfilled if I&#x27;d been immersed in super rigorous first-principles education beginning around age 8-9. I didn&#x27;t do well with things like &quot;memorize this procedure for doing long division&quot; and did much better with conceptual derivations of physics&#x2F;math&#x2F;science&#x2F;historical arcs, etc.</div><br/><div id="40418640" class="c"><input type="checkbox" id="c-40418640" checked=""/><div class="controls bullet"><span class="by">generationP</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417876">parent</a><span>|</span><a href="#40417249">next</a><span>|</span><label class="collapse" for="c-40418640">[-]</label><label class="expand" for="c-40418640">[4 more]</label></div><br/><div class="children"><div class="content">The problem is that no one thinks of type conversions as taking any explicit paths! It&#x27;s one thing to view the actual process of long division as path-dependent (something everyone who learns about Gröbner bases is familiar with, as at the right level of generality even the result is path-dependent); it&#x27;s another thing to apply the same intuition to the way the inputs are parsed. (You said divide 3 by 2 with remainder? Sure, the quotient is 3&#x2F;2 and the remainder is 0. Problem?)</div><br/><div id="40420036" class="c"><input type="checkbox" id="c-40420036" checked=""/><div class="controls bullet"><span class="by">reaperman</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40418640">parent</a><span>|</span><a href="#40420282">next</a><span>|</span><label class="collapse" for="c-40420036">[-]</label><label class="expand" for="c-40420036">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The problem is that no one thinks of type conversions as taking any explicit paths!</i><p>Indeed. This is super surprising to me and I’m adding the topic to my “study” list. I had no idea until today - I easily could imagine it’s possible if some of the type conversions are “lossy” (e.g. maps to lists), but I have a strong feeling that simpified lossy conversions are not what is being referenced.</div><br/><div id="40422683" class="c"><input type="checkbox" id="c-40422683" checked=""/><div class="controls bullet"><span class="by">generationP</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40420036">parent</a><span>|</span><a href="#40420282">next</a><span>|</span><label class="collapse" for="c-40422683">[-]</label><label class="expand" for="c-40422683">[1 more]</label></div><br/><div class="children"><div class="content">Most of Buzzard&#x27;s examples are indeed lossless (even bijective) conversions, but the notation mathematicians use (and programming languages often support) makes it look like they are completely absent, which comes back to bite you. In mathematics, it bites you when you want to actually compute your function and realize you don&#x27;t remember how all those canonical arrows go. In programming, it bites you when the default conversions the compiler inserts aren&#x27;t the ones you meant.</div><br/></div></div></div></div><div id="40420282" class="c"><input type="checkbox" id="c-40420282" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40418640">parent</a><span>|</span><a href="#40420036">prev</a><span>|</span><a href="#40417249">next</a><span>|</span><label class="collapse" for="c-40420282">[-]</label><label class="expand" for="c-40420282">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t that the intuition behind homotopy type theory — that equivalence is a path between types?<p>(And related, eg, cubical type theory.)</div><br/></div></div></div></div></div></div><div id="40417249" class="c"><input type="checkbox" id="c-40417249" checked=""/><div class="controls bullet"><span class="by">nico</span><span>|</span><a href="#40415731">parent</a><span>|</span><a href="#40417876">prev</a><span>|</span><a href="#40415827">next</a><span>|</span><label class="collapse" for="c-40417249">[-]</label><label class="expand" for="c-40417249">[7 more]</label></div><br/><div class="children"><div class="content">Or when your formulas on Google sheets start failing because you do 1-1 and the result is not 0, and then you spend 30 minutes creating new sheets, searching the web and double checking everything, until you realize that the value on the cell wasn’t 1, but 1.<p>This happened to me yesterday</div><br/><div id="40417254" class="c"><input type="checkbox" id="c-40417254" checked=""/><div class="controls bullet"><span class="by">boppo1</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417249">parent</a><span>|</span><a href="#40415827">next</a><span>|</span><label class="collapse" for="c-40417254">[-]</label><label class="expand" for="c-40417254">[6 more]</label></div><br/><div class="children"><div class="content">Can you elaborate?</div><br/><div id="40417355" class="c"><input type="checkbox" id="c-40417355" checked=""/><div class="controls bullet"><span class="by">nico</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417254">parent</a><span>|</span><a href="#40417313">next</a><span>|</span><label class="collapse" for="c-40417355">[-]</label><label class="expand" for="c-40417355">[4 more]</label></div><br/><div class="children"><div class="content">Now I noticed that the period at the end of the paragraph is a bit unfortunate<p>The value was 1. which I guess is shorthand for 1.0 and it’s technically not the same value as 1<p>On top of that, sometimes values like 0.961727 will be shown as 1, so sometimes you think that the value in the cell you are referring to is a 1 but instead it’s something close to it<p>In particular I was making a list of array positions from 1 to 32 and calculating x,y coordinates from the position using the formulas (x = (i-1) % width, y = (i-1)&#x2F;width)<p>Some of the coordinates were wrong, and it was because the i values were not integers, which I couldn’t tell just by looking at the sheet, and only realized it when double clicked on the cells</div><br/><div id="40420268" class="c"><input type="checkbox" id="c-40420268" checked=""/><div class="controls bullet"><span class="by">jkaptur</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417355">parent</a><span>|</span><a href="#40420906">next</a><span>|</span><label class="collapse" for="c-40420268">[-]</label><label class="expand" for="c-40420268">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s frustrating that there isn&#x27;t an easy way to see the &quot;canonical&quot; value and format of a cell (in Sheets or Excel).<p>Just looking at a cell, it&#x27;s not trivial to see if it&#x27;s the number 1 or the string 1 (you can enter text by using a leading apostrophe, but that&#x27;s not the <i>only</i> way to get text in a cell!). Numbers and strings have different alignments by default, but that can be overridden. The numeric value of  the string 1 is 0 if you&#x27;re using the SUM formula, but it&#x27;s 1 if you use +. In other words, =A1+A2 does not necessarily equal =SUM(A1:A2)<p>Then you can format numbers however you like. For example, dates are stored in spreadsheets as days since an epoch (not the Unix epoch). So you can have the number 2 in a spreadsheet cell, then format it as a date, but just the day of the month, and it can appear as 1.<p>There&#x27;s rounding, which bit you. 0.95 can appear as 1 if you display fewer decimal places.<p>Finally, there&#x27;s the fact that the calculation is done like IEEE 754. Programmers are used to floating point numbers and the fact that properties like associativity don&#x27;t apply, but that&#x27;s not obvious to everyone.</div><br/><div id="40422945" class="c"><input type="checkbox" id="c-40422945" checked=""/><div class="controls bullet"><span class="by">nico</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40420268">parent</a><span>|</span><a href="#40420906">next</a><span>|</span><label class="collapse" for="c-40422945">[-]</label><label class="expand" for="c-40422945">[1 more]</label></div><br/><div class="children"><div class="content">You definitely know a lot about mangling data with spreadsheets!<p>&gt; Programmers are used to floating point numbers and the fact that properties like associativity don&#x27;t apply, but that&#x27;s not obvious to everyone<p>One of my first programming assignments in college was to simulate a pool table. I had to go ask the TA what the hell was wrong with my code, the balls would never bounce because their distances to anything were never 0… fun times</div><br/></div></div></div></div><div id="40420906" class="c"><input type="checkbox" id="c-40420906" checked=""/><div class="controls bullet"><span class="by">boppo1</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417355">parent</a><span>|</span><a href="#40420268">prev</a><span>|</span><a href="#40417313">next</a><span>|</span><label class="collapse" for="c-40420906">[-]</label><label class="expand" for="c-40420906">[1 more]</label></div><br/><div class="children"><div class="content">Thank you!</div><br/></div></div></div></div><div id="40417313" class="c"><input type="checkbox" id="c-40417313" checked=""/><div class="controls bullet"><span class="by">gatane</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417254">parent</a><span>|</span><a href="#40417355">prev</a><span>|</span><a href="#40415827">next</a><span>|</span><label class="collapse" for="c-40417313">[-]</label><label class="expand" for="c-40417313">[1 more]</label></div><br/><div class="children"><div class="content">1 vs 1.0 ???</div><br/></div></div></div></div></div></div><div id="40415827" class="c"><input type="checkbox" id="c-40415827" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40415731">parent</a><span>|</span><a href="#40417249">prev</a><span>|</span><a href="#40420419">next</a><span>|</span><label class="collapse" for="c-40415827">[-]</label><label class="expand" for="c-40415827">[4 more]</label></div><br/><div class="children"><div class="content">I assume you mean any random enterprise codebase? Because that is any random enterprise codebase.</div><br/><div id="40418992" class="c"><input type="checkbox" id="c-40418992" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40415827">parent</a><span>|</span><a href="#40419014">next</a><span>|</span><label class="collapse" for="c-40418992">[-]</label><label class="expand" for="c-40418992">[1 more]</label></div><br/><div class="children"><div class="content">In other areas, one might compare code jurisdictions, where presumably all the legislative clauses share a common vocabulary (and probably even conceptual framework), with common law jurisdictions, where all the legislative clauses occur in different centuries and thus one adds &quot;picking a parallel transport&quot; between the legal languages of the times (and jurisdictions) to the difficulties of adjudication.</div><br/></div></div><div id="40419014" class="c"><input type="checkbox" id="c-40419014" checked=""/><div class="controls bullet"><span class="by">om8</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40415827">parent</a><span>|</span><a href="#40418992">prev</a><span>|</span><a href="#40420419">next</a><span>|</span><label class="collapse" for="c-40419014">[-]</label><label class="expand" for="c-40419014">[2 more]</label></div><br/><div class="children"><div class="content">Not if you use a language that bans implicit type conversions (like go)</div><br/><div id="40421046" class="c"><input type="checkbox" id="c-40421046" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40419014">parent</a><span>|</span><a href="#40420419">next</a><span>|</span><label class="collapse" for="c-40421046">[-]</label><label class="expand" for="c-40421046">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking in <i>much</i> more abstract terms. You have information from a webflow, at some point converted to an XML message, converted to database entry, again to a JSON document, combined with an Azure workitem, then sent to Salesforce.<p>At any one point the data can interact with other systems, travel through codebases each seeing the data through their types, legacy APIs, the same-(ish) new-(ish) RPC API and in each service the data is represented in its own internal quirky way.<p>Sure, throw Go in that mix, hell at this point the more merrier! :)</div><br/></div></div></div></div></div></div><div id="40420419" class="c"><input type="checkbox" id="c-40420419" checked=""/><div class="controls bullet"><span class="by">AlecBG</span><span>|</span><a href="#40415731">parent</a><span>|</span><a href="#40415827">prev</a><span>|</span><a href="#40419103">next</a><span>|</span><label class="collapse" for="c-40420419">[-]</label><label class="expand" for="c-40420419">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I agree. That sort of type conversion involves inclusions, while the examples Buzzard talked about involved isomorphisms</div><br/><div id="40420818" class="c"><input type="checkbox" id="c-40420818" checked=""/><div class="controls bullet"><span class="by">types_vs_sets</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40420419">parent</a><span>|</span><a href="#40419103">next</a><span>|</span><label class="collapse" for="c-40420818">[-]</label><label class="expand" for="c-40420818">[1 more]</label></div><br/><div class="children"><div class="content">Inclusions are a form of isomorphism. In the more common developments of elementary arithmetic, Q is <i>constructed</i> from Z, and in particular the subset of integral rational numbers are technically a different ring from Z. The conversion Z \to Q in particular is an isomorphism from Z to that subset.<p>Type conversions in every day programming languages though sometimes not only fail to be surjective, they can also fail to be injective, for example int32 -&gt; float32.<p>type-conversions and &quot;implicit isomorphisms&quot; differ because the former does not need to be invertible, but they agree in that they are implicit maps, that are often performed without thought by the user. So I think that the type-conversions analogy is pretty good in that it captures the idea that implicit conversions, when composed in different ways from A to B, can arrive at various values, even if each stage along the way the choices seemed natural.</div><br/></div></div></div></div><div id="40419103" class="c"><input type="checkbox" id="c-40419103" checked=""/><div class="controls bullet"><span class="by">belter</span><span>|</span><a href="#40415731">parent</a><span>|</span><a href="#40420419">prev</a><span>|</span><a href="#40417551">next</a><span>|</span><label class="collapse" for="c-40419103">[-]</label><label class="expand" for="c-40419103">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Strictly speaking, the rational number 1 is not the same as the integer 1<p>So does that mean you can have different 0 zero&#x27;s ?</div><br/><div id="40422318" class="c"><input type="checkbox" id="c-40422318" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40419103">parent</a><span>|</span><a href="#40422067">next</a><span>|</span><label class="collapse" for="c-40422318">[-]</label><label class="expand" for="c-40422318">[5 more]</label></div><br/><div class="children"><div class="content">Yes.  0&#x2F;1, 0&#x2F;2, 0&#x2F;3 are all different in some sense, but they belong in the same equivalence class.</div><br/><div id="40425057" class="c"><input type="checkbox" id="c-40425057" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40422318">parent</a><span>|</span><a href="#40425500">next</a><span>|</span><label class="collapse" for="c-40425057">[-]</label><label class="expand" for="c-40425057">[3 more]</label></div><br/><div class="children"><div class="content">Even there, it would help to not apply the zero numerator equivalence class too early.<p>I.e. 2&#x2F;3, 2&#x2F;5, 2&#x2F;7 are the numbers that divide 2 to get 3, 5 and 7 respectively.<p>Likewise, with full consistency, 0&#x2F;1, 0&#x2F;2, 0&#x2F;3 cannot be reduced using common factors (the core equivalence for ratios), so have different ratio normal forms, and are the numbers that when they divide 0 produce 1, 2, and 3 respectively. All consistently.<p>The advantage of not applying zero numerator equivalence too early, is that you get reversibility, associativity and commutivity consistency in intermediate calculations even when zeros appear in ratios.<p>You can still apply zero numerator ratio equivalence to final values, but avoid a lot of reordering of intermediate calculations required to avoid errors if you had applied it earlier.<p>Of course, if you are coding it doesn&#x27;t help that you are unlikely to find any numerical libraries, functions or numeric data types, that don&#x27;t assume division by zero is an error, inf, or NaN, and that all zeros divided by non-zero numbers are equivalent to 0. So you simply can&#x27;t get the benefits of holding off on that equivalence.<p>You have to do a lot of reasoning and reordering to ensure generally correct results, as apposed to &quot;I am sure it will be fine&quot; results.<p>I find it very surprising that this separate treatment of factor reduced equivalence, and zero numerator (and zero denominator) equivalences, on ratios, is not taught more explicitly. They are very different kinds of equivalence, with very different impacts on calculation paths.</div><br/><div id="40425277" class="c"><input type="checkbox" id="c-40425277" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40425057">parent</a><span>|</span><a href="#40425492">next</a><span>|</span><label class="collapse" for="c-40425277">[-]</label><label class="expand" for="c-40425277">[1 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>I was actually toying with writing a rational number library going in the direction you sketch out.  My inspiration was a trick in computational geometry for dealing with points at infinity.  I think it&#x27;s called homogeneous coordinates.<p>My point was to treat both p and q in p&#x2F;q as symmetrically as possible.<p>Oh, I remember now: the motivating example was to write a nice implementation of an optimal player for the &#x27;guessing game&#x27; for rational numbers.<p>One player, Alice, commits to a (rational) number.  The other player, Bob, makes guesses, and Alice answers whether the guess was too high, too low or was correct.  Bob can solve this in O(log p + log q).  And the continued-fraction-based strategy Bob wants to use is generally symmetrical between p and q.  So I was looking into expressing the code as symmetrically as possible, too.</div><br/></div></div><div id="40425492" class="c"><input type="checkbox" id="c-40425492" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40425057">parent</a><span>|</span><a href="#40425277">prev</a><span>|</span><a href="#40425500">next</a><span>|</span><label class="collapse" for="c-40425492">[-]</label><label class="expand" for="c-40425492">[1 more]</label></div><br/><div class="children"><div class="content">How is the case of the zero numerator special? When you take any fraction 0&#x2F;n with n&gt;0 and reduce it by the greatest common factor, you get 0&#x2F;1.</div><br/></div></div></div></div><div id="40425500" class="c"><input type="checkbox" id="c-40425500" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40422318">parent</a><span>|</span><a href="#40425057">prev</a><span>|</span><a href="#40422067">next</a><span>|</span><label class="collapse" for="c-40425500">[-]</label><label class="expand" for="c-40425500">[1 more]</label></div><br/><div class="children"><div class="content">Which can be made &quot;visible&quot; by substituting 0 with e.g. `1 - 1`:<p><pre><code>   0&#x2F;1 = (1 - 1)&#x2F;1 = 1&#x2F;1 - 1&#x2F;1
   0&#x2F;2 = (1 - 1)&#x2F;2 = 1&#x2F;2 - 1&#x2F;2
   ...</code></pre></div><br/></div></div></div></div><div id="40422067" class="c"><input type="checkbox" id="c-40422067" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40419103">parent</a><span>|</span><a href="#40422318">prev</a><span>|</span><a href="#40419446">next</a><span>|</span><label class="collapse" for="c-40422067">[-]</label><label class="expand" for="c-40422067">[1 more]</label></div><br/><div class="children"><div class="content">Note how your parent comment has specified &quot;rational&quot; 1 and &quot;integer&quot; 1.  They use the symbol 1 for two similar concepts: We all &quot;know&quot; that 1 + 1 = 2 and 1.0 + 1.0 = 2.0.  I have deliberately specified 1 for an int and 1.0 for a rational.  Now we have two different representations for two very similar but not identical concepts.<p>At which point does 1 + a tiny amount cease to be an integer? By definition that tiny amount can have any magnitude and 1 plus anything will cease to be an integer.  That is the property that defines an integer.  Integers have subsequent &quot;behaviours&quot; that other types of numbers might lack.<p>You have picked zero&#x2F;0.  Now that is a sodding complicated concept 8)  There are lots of things called zero but no more nor less than any other.<p>Zero might be defined by: 1 - 1 = 0.  I have £1 in my bank account and I pay out £1 for a very small flower, my bank balance is now £0.  Lovely model, all good except that interest calcs intervened and I actually have a balance of £0.00031.  Blast.  My pretty integer has morphed into a bloody complicated ... well is it a rational thingie or a ... what is it?<p>Now I want to withdraw my balance.  I put a shiny £1 in, bought something and I have some change.  What on earth does a 0.031p coin look like?  Obviously, it doesn&#x27;t exist.  My lovely integer account has gone rational.<p>Symbols mean what we agree on with some carefully and well chosen language.  Mathematicians seem to think they are the ultimate aces at using spoken and written language to make formal definitions, derivations and so on.  That is a bit unfair, obviously.  We all believe that what we think is communicable in some way.  Perhaps it is but I suspect that it isn&#x27;t always.<p>Have a jolly good think about what zero, nothing, 0 and so on really mean.  Concepts and their description to others is a really hard problem, that some funky symbols sort of helps with.<p>Yes there are loads of things called zero.  If I had to guess: infinitely things are zero!  Which infinity I could not say.</div><br/></div></div><div id="40419446" class="c"><input type="checkbox" id="c-40419446" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40419103">parent</a><span>|</span><a href="#40422067">prev</a><span>|</span><a href="#40417551">next</a><span>|</span><label class="collapse" for="c-40419446">[-]</label><label class="expand" for="c-40419446">[1 more]</label></div><br/><div class="children"><div class="content">Yes</div><br/></div></div></div></div><div id="40417551" class="c"><input type="checkbox" id="c-40417551" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40415731">parent</a><span>|</span><a href="#40419103">prev</a><span>|</span><a href="#40420343">next</a><span>|</span><label class="collapse" for="c-40417551">[-]</label><label class="expand" for="c-40417551">[17 more]</label></div><br/><div class="children"><div class="content">1 is an integer, a rational number, a positive integer, an odd integer, a power of 2, etc.</div><br/><div id="40417611" class="c"><input type="checkbox" id="c-40417611" checked=""/><div class="controls bullet"><span class="by">sharkbot</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417551">parent</a><span>|</span><a href="#40421526">next</a><span>|</span><label class="collapse" for="c-40417611">[-]</label><label class="expand" for="c-40417611">[14 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also a complex number, a Unicode character, an ASCII character, an Extended ASCII character, a glyph, the multiplicative identity element, a raster image, ...<p>The GP point is correct; we implicitly convert between all these representations naturally and quickly, but there are interesting branches of mathematics that consider those conversions explicitly and find nuances (eg, category theory).</div><br/><div id="40418214" class="c"><input type="checkbox" id="c-40418214" checked=""/><div class="controls bullet"><span class="by">passion__desire</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417611">parent</a><span>|</span><a href="#40422191">next</a><span>|</span><label class="collapse" for="c-40418214">[-]</label><label class="expand" for="c-40418214">[1 more]</label></div><br/><div class="children"><div class="content">All the examples of shadows mentioned by Douglas in the video [0]:<p>Traditional Shadow from Sunlight: A tree casting a shadow in bright sunlight during the summer, characterized by the typical darkening on the ground.<p>Snow Shadow: Occurs in winter when a tree intercepts snowflakes, resulting in an absence of snow under the tree despite being surrounded by snow. This is likened to a shadow because it mimics the visual absence typical of shadows, even though caused by a different kind of blockage.<p>Rain Shadow: Explained with the example of the Cascade Mountains, where the mountains block rain clouds leading to dry conditions on the leeward side, effectively creating a &quot;shadow&quot; where rain is absent due to the geographical barrier.<p>Car Shadow by a Truck: Described during highway driving, where a large truck casts a &quot;shadow&quot; by preventing cars behind it from passing. This &quot;shadow&quot; is the area in front of the truck where cars tend to stay clear due to the difficulty in passing the truck.<p>Shadow Cast by England Due to the Gulf Stream: This is a metaphorical shadow, where England blocks the warm Gulf Stream from reaching certain areas, resulting in colder temperatures on one side, while allowing it to pass above to northern Norway, warming it. This is referred to as the &quot;shadow of England&quot; on the coast of Norway, influenced by the flow of water rather than light.<p>These examples use the concept of &quot;shadow&quot; in various physical and metaphorical contexts, showing disruptions in different types of flows (light, snow, rain, traffic, and ocean currents) caused by obstructions.<p>[0] : <a href="https:&#x2F;&#x2F;youtu.be&#x2F;LnTVzB5S8m4?t=973" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;LnTVzB5S8m4?t=973</a></div><br/></div></div><div id="40422191" class="c"><input type="checkbox" id="c-40422191" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417611">parent</a><span>|</span><a href="#40418214">prev</a><span>|</span><a href="#40418585">next</a><span>|</span><label class="collapse" for="c-40422191">[-]</label><label class="expand" for="c-40422191">[3 more]</label></div><br/><div class="children"><div class="content">Mathematics is surprisingly weakly typed.<p>For example, the &quot;2&quot; in &quot;2π&quot; is not the same type of &quot;2&quot; as in x^2 or 2x generally. Yet, physicists (to pick a random group) will blend in these factors, resulting in nonsense. As a random example, one of the Einstein field equations has &quot;8π&quot; in it. Eight <i>what!?</i> What aspect of the universe is this counting out eight of -- a weirdly large integer constant? This actually ought to be &quot;4(2pi)&quot;, and then &quot;4&quot; is the number of spacetime dimensions, which makes a lot more sense.<p>Similarly, in at least one place the square of the pseudoscalar (I^2) was treated as a plain -1 integer constant and accidentally &quot;folded&quot; into other unrelated integer constants. This causes issues when moving from 2D to 3D to 4D.</div><br/><div id="40422738" class="c"><input type="checkbox" id="c-40422738" checked=""/><div class="controls bullet"><span class="by">generationP</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40422191">parent</a><span>|</span><a href="#40422350">next</a><span>|</span><label class="collapse" for="c-40422738">[-]</label><label class="expand" for="c-40422738">[1 more]</label></div><br/><div class="children"><div class="content">These examples miss the mark somewhat. The &quot;2&quot; in &quot;2π&quot; can mean several things (the nonnegative integer 2, the integer 2, the rational 2, the real 2) that are all commonly identified but are different. The &quot;2&quot; in &quot;x^2&quot; usually means the nonnegative integer 2. The &quot;2&quot; in &quot;2x&quot; can usually mean the nonnegative integer or the integer 2, but also the other 2&#x27;s depending on what x is. The problem is not that the meaning of 2 varies across different expressions, but that it can vary within each single expression.<p>The best example is perhaps the polynomial ring R[x][y], which consists of polynomials in the variable y over the ring of polynomials in the variable x over the real numbers. Any algebraist would tell you that it is obviously just the two-variable polynomial ring R[x, y] in disguise, because you can factor out all the y-powers and then the coefficients will be polynomials in x. But the rings are very much not the same at the level of implementation, and every time you use their &quot;equality&quot; (canonical isomorphy), you need to keep the actual conversion map (the isomorphism) in the back of your mind.</div><br/></div></div><div id="40422350" class="c"><input type="checkbox" id="c-40422350" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40422191">parent</a><span>|</span><a href="#40422738">prev</a><span>|</span><a href="#40418585">next</a><span>|</span><label class="collapse" for="c-40422350">[-]</label><label class="expand" for="c-40422350">[1 more]</label></div><br/><div class="children"><div class="content">Haskell shows (one way of) how you can have numerical literals like 2 that can be used with many different types, but still be strongly statically typed.<p>That by itself isn&#x27;t a problem.  But making all the other confusions you mention is a problem.</div><br/></div></div></div></div><div id="40418585" class="c"><input type="checkbox" id="c-40418585" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417611">parent</a><span>|</span><a href="#40422191">prev</a><span>|</span><a href="#40417756">next</a><span>|</span><label class="collapse" for="c-40418585">[-]</label><label class="expand" for="c-40418585">[6 more]</label></div><br/><div class="children"><div class="content">Saying 1 is both an integer and a rational number is wildly different from saying it is both an integer and an ASCII character. Z is a subset of Q. ASCII characters don’t overlap with either.<p>When you construct numbers using sets under ZFC axioms or inside lambda calculus what you get is representation. But 1 is just 1.</div><br/><div id="40418725" class="c"><input type="checkbox" id="c-40418725" checked=""/><div class="controls bullet"><span class="by">pitched</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40418585">parent</a><span>|</span><a href="#40417756">next</a><span>|</span><label class="collapse" for="c-40418725">[-]</label><label class="expand" for="c-40418725">[5 more]</label></div><br/><div class="children"><div class="content">Your keyboard has a button with ‘1’ printed on it. When you push that, you don’t always get an integer or a rational number. You can convert what you get to either. So there must be overlap with ASCII somehow?</div><br/><div id="40418843" class="c"><input type="checkbox" id="c-40418843" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40418725">parent</a><span>|</span><a href="#40417756">next</a><span>|</span><label class="collapse" for="c-40418843">[-]</label><label class="expand" for="c-40418843">[4 more]</label></div><br/><div class="children"><div class="content">There is some overlap in some sense somehow, but not in any literal sense unlike in the sense in which all elements of Z are elements of Q.</div><br/><div id="40423246" class="c"><input type="checkbox" id="c-40423246" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40418843">parent</a><span>|</span><a href="#40417756">next</a><span>|</span><label class="collapse" for="c-40423246">[-]</label><label class="expand" for="c-40423246">[3 more]</label></div><br/><div class="children"><div class="content">By any common set-theoretic construction of Q (e.g., equivalence classes of integer pairs under cross-multiplication), 1 as an element of Z is not literally an element of Q: 1 ∈ Q merely <i>corresponds</i> to 1 ∈ Z, and this correspondence is carefully designed to preserve the ring operations of Z within a certain subset of Q. In this case, the distinction is so negligible that eliding it is harmless, but the whole point of the article is that such elisions can become harmful in more complex constructions.<p>1 ∈ Z and ASCII &#x27;1&#x27; can similarly be seen as corresponding in terms of having the same glyph when displayed. But of course, there are far fewer meaningful operations common to the two.</div><br/><div id="40424972" class="c"><input type="checkbox" id="c-40424972" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40423246">parent</a><span>|</span><a href="#40417756">next</a><span>|</span><label class="collapse" for="c-40424972">[-]</label><label class="expand" for="c-40424972">[2 more]</label></div><br/><div class="children"><div class="content">1 is not a set, any set-theoretic construction of 1 is not literally 1.</div><br/><div id="40425490" class="c"><input type="checkbox" id="c-40425490" checked=""/><div class="controls bullet"><span class="by">hanche</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40424972">parent</a><span>|</span><a href="#40417756">next</a><span>|</span><label class="collapse" for="c-40425490">[-]</label><label class="expand" for="c-40425490">[1 more]</label></div><br/><div class="children"><div class="content">I am not sure I understand what you mean by “literally” here. For sure, if you use Zermelo–Fraenkel set theory as the foundation of mathematics, as is commonly done, every mathematical object is a set. The first definition of 1 encountered in that setting is the singleton set {0}, where 0 is the empty set. (And 2={0,1}, 3={0,1,2} and so forth – you get the picture.)
This is precisely the sort of thing this is all about: The natural numbers are uniquely described up to unique isomorphism by some variant of the Peano axioms after all.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40417756" class="c"><input type="checkbox" id="c-40417756" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417611">parent</a><span>|</span><a href="#40418585">prev</a><span>|</span><a href="#40421526">next</a><span>|</span><label class="collapse" for="c-40417756">[-]</label><label class="expand" for="c-40417756">[3 more]</label></div><br/><div class="children"><div class="content">But the integers are a subset of the rationals, which are a subset of the reals, which are a subset of the complex numbers. Looking only at the objects <i>and not their operations</i> 1 (integer) = 1 (rational) = 1 (real) = 1 (complex). Moreover, when we do account for the operations, we also see that 1 + 1 = 2 and 1 * 1 = 1 in every one of those systems. This isn&#x27;t just a coincidence, of course; it&#x27;s by design.<p>However, the way you arrive at 1 + 1 = 2 is <i>not</i> the same (though I suppose you could short-circuit the algorithm). Rational addition requires finding a common denominator, while integer addition doesn&#x27;t. They achieve the same result when the inputs are integers, and again this is by design, but the process isn&#x27;t the same. Ditto real addition vs. rational and complex addition vs. real.<p>In higher-level mathematics, the operations on the objects become definitional. We don&#x27;t look at just a set of things, we look at a set of things and the set of operations upon those things. Thus &quot;1 with integer addition and integer multiplication&quot; becomes the object under consideration (even if it&#x27;s just contextually understood) instead of simply 1. This is why they don&#x27;t satisfy higher-level notions of equivalence, even if they intentionally do satisfy simple equality as taught in grade school.<p>Of course, the entire point of the submitted paper is to examine this in detail.</div><br/><div id="40418595" class="c"><input type="checkbox" id="c-40418595" checked=""/><div class="controls bullet"><span class="by">generationP</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417756">parent</a><span>|</span><a href="#40417897">next</a><span>|</span><label class="collapse" for="c-40418595">[-]</label><label class="expand" for="c-40418595">[1 more]</label></div><br/><div class="children"><div class="content">This is not the point of the article. Even at the level of the objects themselves, 1 : integer is not 1 : rational. The latter is an ordered pair (1, 1) of two coprime positive integers, or an equivalence class of ordered pairs up to cancelling. Some ugly hackery is required to really make the integers <i>equal</i> to their respective rationals, and its consequences aren&#x27;t great either (just imagine that <i>some</i> rationals are pairs while others are not -- that&#x27;s what you get if you forcibly replace the rational k&#x2F;1 by the integer k), and no one wants to do that.</div><br/></div></div><div id="40417897" class="c"><input type="checkbox" id="c-40417897" checked=""/><div class="controls bullet"><span class="by">JadeNB</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417756">parent</a><span>|</span><a href="#40418595">prev</a><span>|</span><a href="#40421526">next</a><span>|</span><label class="collapse" for="c-40417897">[-]</label><label class="expand" for="c-40417897">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But the integers are a subset of the rationals, which are a subset of the reals, which are a subset of the complex numbers.<p>It depends on definitions, and, in some sense, the point of the common approach to mathematics is not just that one does not, but that one cannot, ask such questions.  One approach is to look at natural numbers set theoretically, starting with 0 = ∅; to define integers as equivalence classes of pairs of natural numbers; to define rational numbers as equivalence classes of certain pairs of integers; and to define real numbers as equivalence classes of Cauchy sequences of rational numbers.  In each of these cases there is an obvious injection which we are used to regarding as inclusion, but most of mathematics is set up to make it meaningless even to <i>ask</i> whether the natural number 1 is the same as the integer 1 is the same as ….<p>That is to say, if you&#x27;re working on an application where encoding details are important, then you can and will ask such questions; but if I am writing a paper about natural numbers, I do not have to worry about the fact that, for some choice of encoding, the number 2 = {∅, {∅}} is the same as the ordered pair (0, 0) = {0, {0, 0}} = {∅, {∅}}, and in fact it is meaningless to test whether 2 &quot;equals&quot; (0, 0).  The philosophy of studiously avoiding such meaningless questions leads some to avoid even testing for equality, as opposed to isomorphism; failing to do so used to be referred to in category-theoretic circles as &quot;evil&quot;, although, as the nLab points out if you try to go to <a href="https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;evil" rel="nofollow">https:&#x2F;&#x2F;ncatlab.org&#x2F;nlab&#x2F;show&#x2F;evil</a> , it seems common nowadays to avoid such language.</div><br/></div></div></div></div></div></div><div id="40421526" class="c"><input type="checkbox" id="c-40421526" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40417551">parent</a><span>|</span><a href="#40417611">prev</a><span>|</span><a href="#40420343">next</a><span>|</span><label class="collapse" for="c-40421526">[-]</label><label class="expand" for="c-40421526">[2 more]</label></div><br/><div class="children"><div class="content">There are multiple things that we denote using a particular symbol: 1.  1 in and of itself is not a single concept.  You could replace the symbol 1 with any other, even the sound of a fart and the concepts still remain the same.  Given that we somehow agree that a fart sound shall be the way that we refer to a concept&#x2F;object&#x2F;thing.<p>It&#x27;s a largely useful conceit to use 1 for all of those objects and more besides.  It makes talking about them easier but we do have to be careful to use the correct rule-set for their manipulation.<p>I would personally prefer to see 1.0 for &quot;rational 1&quot; or perhaps 1. but that would require a convoluted sentence to avoid 1. being at the end of the sentence, unless we allow for: 1.!  Well, that would work but what about 1.?  Oh for ffs, I mean: 1..<p>One notes that one&#x27;s own ones may not be the same as one&#x27;s other ones.<p>If only I could spin &quot;won&quot;, &quot;own&quot; and perhaps &quot;wan&quot; into that last sentence!  ... Right, I&#x27;ve wedged in own.  Needs some work 8)</div><br/><div id="40422507" class="c"><input type="checkbox" id="c-40422507" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40421526">parent</a><span>|</span><a href="#40420343">next</a><span>|</span><label class="collapse" for="c-40422507">[-]</label><label class="expand" for="c-40422507">[1 more]</label></div><br/><div class="children"><div class="content">Well, you give give 1.0 for the rational one.  But what about the real or complex one?  Or what about the Gaussian Integer?  What about the 2-adic one, or the 3-adic one, or any other p-adic one?  What about the different kinds of floating point numbers?<p>I don&#x27;t think the rational one is special enough that we need to different notation just for her and for her alone.  (Though that specific distinction can make sense in some contexts.  Just not universally.)</div><br/></div></div></div></div></div></div><div id="40420343" class="c"><input type="checkbox" id="c-40420343" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#40415731">parent</a><span>|</span><a href="#40417551">prev</a><span>|</span><a href="#40416710">next</a><span>|</span><label class="collapse" for="c-40420343">[-]</label><label class="expand" for="c-40420343">[7 more]</label></div><br/><div class="children"><div class="content">This doesn’t sound right to me. The rational numbers are a superset of the integers. We know that there’s only one 1 in the rational numbers, then it must be the same 1 object as the 1 in the integers.<p>The statement “3&#x2F;3 is in Z” is true. There’s no conversion happening: 3&#x2F;3 is a notation for 1, just like 0.999… is a notation for 1. Many notations, but only one 1 object.<p>The case of R x R^2 = R^3 is different because the Cartesian product is <i>defined</i> to produce a set of ordered pairs. So it cannot give rise to a set of triples any more than a dog can give birth to a cat. So either x is not a Cartesian product or = is isomorphism not equality.</div><br/><div id="40424629" class="c"><input type="checkbox" id="c-40424629" checked=""/><div class="controls bullet"><span class="by">jasomill</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40420343">parent</a><span>|</span><a href="#40422018">next</a><span>|</span><label class="collapse" for="c-40424629">[-]</label><label class="expand" for="c-40424629">[1 more]</label></div><br/><div class="children"><div class="content">0.999… always reminds me of my favorite definition of the real numbers:<p>“A <i>real number</i> is a quantity <i>x</i> that has a <i>decimal expansion</i><p><i>x</i> = <i>n</i> + 0.<i>d</i>₁<i>d</i>₂<i>d</i>₃…, (1)<p>where <i>n</i> is an integer, each <i>d</i>ᵢ is a digit between 0 and 9, and the sequence of digits doesn&#x27;t end with infinitely many 9s. The representation (1) means that<p><i>n</i> + <i>d</i>₁&#x2F;10 + <i>d</i>₂&#x2F;100 + ⋯ + <i>d</i>ₖ&#x2F;10^k ≤ <i>x</i> &lt; <i>n</i> + <i>d</i>₁&#x2F;10 + <i>d</i>₂&#x2F;100 + ⋯ + <i>d</i>ₖ&#x2F;10^k + 1&#x2F;10^k<p>for all positive integers <i>k</i>.”[1]<p>Defining the reals in terms of binary expansion is left as an exercise for the reader[2].<p>[1] Knuth, <i>The Art of Computer Programming</i>, Volume 1, Third Edition, p. 21.<p>[2] <i>Ibid.</i>, p. 25, exercise 5.</div><br/></div></div><div id="40422018" class="c"><input type="checkbox" id="c-40422018" checked=""/><div class="controls bullet"><span class="by">ndriscoll</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40420343">parent</a><span>|</span><a href="#40424629">prev</a><span>|</span><a href="#40420868">next</a><span>|</span><label class="collapse" for="c-40422018">[-]</label><label class="expand" for="c-40422018">[3 more]</label></div><br/><div class="children"><div class="content">Q is (usually) a set of equivalence classes of ZxZ\{0}, so obviously it&#x27;s not a superset of Z since they&#x27;re not even the same types of things.<p>There is however a canonical embedding of Z into Q, sending n to the class of (n,1).</div><br/><div id="40424422" class="c"><input type="checkbox" id="c-40424422" checked=""/><div class="controls bullet"><span class="by">tobbe2064</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40422018">parent</a><span>|</span><a href="#40420868">next</a><span>|</span><label class="collapse" for="c-40424422">[-]</label><label class="expand" for="c-40424422">[2 more]</label></div><br/><div class="children"><div class="content">Most people define it as the smallest set extending (the smallest set extending Z\{0} where * is invertible) where + is invertible</div><br/><div id="40425182" class="c"><input type="checkbox" id="c-40425182" checked=""/><div class="controls bullet"><span class="by">red_trumpet</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40424422">parent</a><span>|</span><a href="#40420868">next</a><span>|</span><label class="collapse" for="c-40425182">[-]</label><label class="expand" for="c-40425182">[1 more]</label></div><br/><div class="children"><div class="content">But such a set is not unique...</div><br/></div></div></div></div></div></div><div id="40420868" class="c"><input type="checkbox" id="c-40420868" checked=""/><div class="controls bullet"><span class="by">perforator</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40420343">parent</a><span>|</span><a href="#40422018">prev</a><span>|</span><a href="#40422306">next</a><span>|</span><label class="collapse" for="c-40420868">[-]</label><label class="expand" for="c-40420868">[1 more]</label></div><br/><div class="children"><div class="content">Your statements such as<p>&gt; We know that there’s only one 1 in the rational numbers, then it must be the same 1 object as the 1 in the integers.
&gt; The statement “3&#x2F;3 is in Z” is true.<p>make it sound very trivial while in reality it is not. I do not quite understand your example with R^3 but the <i>defined</i> applies equally to your statements. There are many ways to define and think about the objects you mentioned -- there is not one single truth. Unless you are a devoted platonist, in which case, it&#x27;s still like your opinion, man.</div><br/></div></div><div id="40422306" class="c"><input type="checkbox" id="c-40422306" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40415731">root</a><span>|</span><a href="#40420343">parent</a><span>|</span><a href="#40420868">prev</a><span>|</span><a href="#40416710">next</a><span>|</span><label class="collapse" for="c-40422306">[-]</label><label class="expand" for="c-40422306">[1 more]</label></div><br/><div class="children"><div class="content">You can easily define a Cartesian product that works on more than two sets at a time.  See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cartesian_product#Cartesian_products_of_several_sets" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cartesian_product#Cartesian_pr...</a></div><br/></div></div></div></div></div></div><div id="40416710" class="c"><input type="checkbox" id="c-40416710" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#40415731">prev</a><span>|</span><a href="#40415680">next</a><span>|</span><label class="collapse" for="c-40416710">[-]</label><label class="expand" for="c-40416710">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m typing this after reading their section on page 6 about the &quot;pentagon axiom&quot;. They write that RxR^2, R^2xR, and R^3 are isomorphic, but not literally equal under different constructions, because (a,(b,c)) is different from ((a,b), c), and that this is a problem. I feel like math kinda gets this wrong by treating sets as meaningful objects on their own. Physics gets it closer to correct because it tries to be &quot;covariant&quot;, where the meaningful answers to questions have to either have units on them or be totally unitless e.g. irrespective of coordinate system.<p>The two spaces Rx(RxR) and (RxR)xR have many isomorphisms between them (every possible coordinate change, for instance). But what matters, what makes them &quot;canonically isomorphic&quot;, is not isomorphisms in how they are _constructed_ but in how they are _used_. When you write an element as (a,b,c), what you mean is that when you are asked for the values of three possible projections you will answer with the values a, b, and c. Regardless of how you define your product spaces, the product of (a), (b), and (c) are going to produce three projections that give the same answers when they are used (if not, you built them wrong). Hence they are indistinguishable, hence canonically isomorphic.<p>This is exactly the way that physics always treats coordinates: sure, you can write down a function like V(x), but it&#x27;s really a function from &quot;points&quot; in x to &quot;points&quot; in V, which happens to be temporarily written in terms of a coordinate system on x and a coordinate system on V.  We just write it as V(x) because we&#x27;re usually going to use it that way later. Any unitless predictions you get to any actual question are necessarily unchanged by those choices of coordinate systems (whereas if they have units then they are measured in one of the coordinate systems).<p>So I would say that (a,(b,c)) and ((a,b), c) are just two different coordinate systems for R^3. But necessarily any math you do with R^3 can&#x27;t depend on the choice of coordinates. There is probably a way to write that by putting something like &quot;units&quot; on every term and then expecting the results of any calculation to be unitless.</div><br/><div id="40416737" class="c"><input type="checkbox" id="c-40416737" checked=""/><div class="controls bullet"><span class="by">generationP</span><span>|</span><a href="#40416710">parent</a><span>|</span><a href="#40416889">next</a><span>|</span><label class="collapse" for="c-40416737">[-]</label><label class="expand" for="c-40416737">[5 more]</label></div><br/><div class="children"><div class="content">This is exactly the &quot;specification by universal property&quot; that the author is talking about. In your case, it&#x27;s saying &quot;a 3-dimensional vector space is a vector space with three chosen vectors e, f, g and three linear maps x, y, z such that each vector v equals x(v) e + y(v) f + z(v) g&quot;. But as the author points out, not everything follows from universal properties, and when it does, there is often several universal properties defining the same object, and that sameness itself needs to be shown.</div><br/><div id="40416893" class="c"><input type="checkbox" id="c-40416893" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#40416710">root</a><span>|</span><a href="#40416737">parent</a><span>|</span><a href="#40416889">next</a><span>|</span><label class="collapse" for="c-40416893">[-]</label><label class="expand" for="c-40416893">[4 more]</label></div><br/><div class="children"><div class="content">Yes, I know it&#x27;s the meaning of it, but I&#x27;m saying that the presence of &quot;units&quot; allows you to sort of... operationalize it? In a way that removes the ambiguity about what&#x27;s going on. Or like, in theory. I dunno it&#x27;s a comment on the internet lol.</div><br/><div id="40422558" class="c"><input type="checkbox" id="c-40422558" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40416710">root</a><span>|</span><a href="#40416893">parent</a><span>|</span><a href="#40416889">next</a><span>|</span><label class="collapse" for="c-40422558">[-]</label><label class="expand" for="c-40422558">[3 more]</label></div><br/><div class="children"><div class="content">Units help with some common cases, but units still don&#x27;t allow you to distinguish between, say, energy, work and torque.</div><br/><div id="40423276" class="c"><input type="checkbox" id="c-40423276" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#40416710">root</a><span>|</span><a href="#40422558">parent</a><span>|</span><a href="#40416889">next</a><span>|</span><label class="collapse" for="c-40423276">[-]</label><label class="expand" for="c-40423276">[2 more]</label></div><br/><div class="children"><div class="content">I think that is due to insufficient imaginativeness. For example, energy and work are the same units but energy is an absolute quantity while work is a delta. So arguably work should be a sort of tangent element of the energy, rather than the same thing. There&#x27;s no distinction in flat space but if you e.g. changed coordinates such that energy was on the surface of a sphere, then work is a spherical displacement instead, which is a totally different class of objects.<p>Likewise, torque is only in the same units because we don&#x27;t regard radians as a unit, but we should. They are distinctly different.</div><br/><div id="40423324" class="c"><input type="checkbox" id="c-40423324" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40416710">root</a><span>|</span><a href="#40423276">parent</a><span>|</span><a href="#40416889">next</a><span>|</span><label class="collapse" for="c-40423324">[-]</label><label class="expand" for="c-40423324">[1 more]</label></div><br/><div class="children"><div class="content">Radians can be seen as a ratio of two lengths, the length of your arc and the length of the circumference of the unit circle.  All units cancel in such ratios.<p>&gt; There&#x27;s no distinction in flat space but if you e.g. changed units such that energy was on the surface of a sphere, then work is a spherical displacement instead, which is a totally different class of objects.<p>Well, maybe.  But in other circumstances you want to treat eg heat and work interchangeably.  Just look at <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Work_(thermodynamics)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Work_(thermodynamics)</a> and <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Work_(physics)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Work_(physics)</a> and <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Work_(electric_field)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Work_(electric_field)</a><p>Basically, how much you _want_ to encode in your type system depends on the needs of your application.  (Approximately all type systems can be made to work for all applications.  But they differ in the degree of convenience and error proneness.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40416889" class="c"><input type="checkbox" id="c-40416889" checked=""/><div class="controls bullet"><span class="by">yau8edq12i</span><span>|</span><a href="#40416710">parent</a><span>|</span><a href="#40416737">prev</a><span>|</span><a href="#40418395">next</a><span>|</span><label class="collapse" for="c-40416889">[-]</label><label class="expand" for="c-40416889">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s the first time that I witness this comic <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;793&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;793&#x2F;</a> happening but with math as a target.</div><br/></div></div><div id="40418395" class="c"><input type="checkbox" id="c-40418395" checked=""/><div class="controls bullet"><span class="by">mathgradthrow</span><span>|</span><a href="#40416710">parent</a><span>|</span><a href="#40416889">prev</a><span>|</span><a href="#40415680">next</a><span>|</span><label class="collapse" for="c-40418395">[-]</label><label class="expand" for="c-40418395">[3 more]</label></div><br/><div class="children"><div class="content">You use R^3 in your example of why coordinates don&#x27;t matter. R^3 can be covered by <i>one</i> chart. Maybe your argument would be more convincing if you pick a different manifold. I have no idea what your complaint is otherwise.</div><br/><div id="40418459" class="c"><input type="checkbox" id="c-40418459" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#40416710">root</a><span>|</span><a href="#40418395">parent</a><span>|</span><a href="#40415680">next</a><span>|</span><label class="collapse" for="c-40418459">[-]</label><label class="expand" for="c-40418459">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not talking about charts of R^3; I&#x27;m talking about the different isomorphic constructions of products like ((a, b), c) and (a, (b, c)) as being a sort of &#x27;choice of coordinate system&#x27; on the isomorphic class of objects.</div><br/><div id="40419531" class="c"><input type="checkbox" id="c-40419531" checked=""/><div class="controls bullet"><span class="by">mathgradthrow</span><span>|</span><a href="#40416710">root</a><span>|</span><a href="#40418459">parent</a><span>|</span><a href="#40415680">next</a><span>|</span><label class="collapse" for="c-40419531">[-]</label><label class="expand" for="c-40419531">[1 more]</label></div><br/><div class="children"><div class="content">yes, and these choices dont matter individually, but how these choices glue together does, in fact, depend on all of them collectively.</div><br/></div></div></div></div></div></div></div></div><div id="40415680" class="c"><input type="checkbox" id="c-40415680" checked=""/><div class="controls bullet"><span class="by">fmap</span><span>|</span><a href="#40416710">prev</a><span>|</span><a href="#40424115">next</a><span>|</span><label class="collapse" for="c-40415680">[-]</label><label class="expand" for="c-40415680">[19 more]</label></div><br/><div class="children"><div class="content">For this particular question we have a great answer in the form of homotopy type theory. It handles all the complications that the author mentions. This is one of the reasons type theorists were excited about HoTT in the first place.<p>The only problem is that the author is working in Lean and apparently* dismissive of non-classical type theory. So now we&#x27;re back to lamenting that equality in type theory is broken...<p>*) I&#x27;m going by second hand accounts here, please correct me if you think this statement is too strong.</div><br/><div id="40416102" class="c"><input type="checkbox" id="c-40416102" checked=""/><div class="controls bullet"><span class="by">cwzwarich</span><span>|</span><a href="#40415680">parent</a><span>|</span><a href="#40418798">next</a><span>|</span><label class="collapse" for="c-40416102">[-]</label><label class="expand" for="c-40416102">[7 more]</label></div><br/><div class="children"><div class="content">&gt; For this particular question we have a great answer in the form of homotopy type theory. It handles all the complications that the author mentions. This is one of the reasons type theorists were excited about HoTT in the first place.<p>Arguably, Homotopy type theory still doesn&#x27;t solve the problem, because while it strengthens the consequences of isomorphism it doesn&#x27;t distinguish between &quot;isomorphism&quot; and &quot;canonical isomorphism&quot;, whereas (some?) mathematicians informally seem to think that there&#x27;s a meaningful difference.<p>&gt; The only problem is that the author is working in Lean and apparently* dismissive of non-classical type theory. So now we&#x27;re back to lamenting that equality in type theory is broken...<p>In my opinion, Lean made a number pragmatic choices (impredicative Prop, non-classical logic including the axiom of global choice, uniqueness of identity proofs, etc.) that enable the practical formalization of mathematics as actually done by the vast majority of mathematicians who don&#x27;t research logic, type theory, or category theory.<p>It&#x27;s far from established that this is possible at all with homotopy type theory, yet alone whether it would actually be easier or more economical to do so. And even if this state of affairs is permanent, homotopy type theory itself would still be an interesting topic of study like any other field of mathematics.</div><br/><div id="40420969" class="c"><input type="checkbox" id="c-40420969" checked=""/><div class="controls bullet"><span class="by">fmap</span><span>|</span><a href="#40415680">root</a><span>|</span><a href="#40416102">parent</a><span>|</span><a href="#40416462">next</a><span>|</span><label class="collapse" for="c-40420969">[-]</label><label class="expand" for="c-40420969">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it doesn&#x27;t distinguish between &quot;isomorphism&quot; and &quot;canonical isomorphism&quot;<p>You can distinguish these concepts in (higher )category theory, where isomorphisms are morphisms in groupoids and canonical isomorphisms are contractible spaces of morphisms. These sound like complicated concepts, but in HoTT you can discover the same phenomena as paths in types (i.e., equality) and a simple definition of contractibility which looks and works almost exactly like unique existence.<p>&gt; In my opinion, Lean made a number pragmatic choices (impredicative Prop, non-classical logic including the axiom of global choice, uniqueness of identity proofs, etc.) that enable the practical formalization of mathematics as actually done by the vast majority of mathematicians who don&#x27;t research logic, type theory, or category theory.<p>The authors of Lean are brilliant and I&#x27;m extremely happy that more mathematicians are looking into formalisations and recognizing the additional challenges that this brings. At the same time, it&#x27;s a little bit depressing that we had finally gotten a good answer to many (not all!) of these additional challenges only to then retreat back to familiar ground.<p>Anyway, there were several responses to my original comment and instead of answering each individually, I&#x27;m just going to point to the article itself. The big example from section 5 is that of localisations of R-algebras. Here is how this whole discussion changes in HoTT:<p>1) We have a path R[1&#x2F;f][1&#x2F;g] = R[1&#x2F;fg], therefore the original theorem is applicable in the case that the paper mentions.<p>2) The statements in terms of &quot;an arbitrary localisation&quot; and &quot;for all particular localisations&quot; are equivalent.<p>3) ...and this is essentially because in HoTT there is a way to define <i>the</i> localisation of an R-algebra at a multiplicative subset. This is a higher-inductive type and the problematic aspects of the definition in classical mathematics stem from the fact that this is not (automatically) a Set. A higher-inductive definition is a definition by a universal property, yet you can work with this in the same way as you would with a concrete construction and the theorems that the article mentions are provable.<p>---<p>There is much more that can be said here and it&#x27;s not all positive. The only point I want to make is that everybody who ever formalised anything substantial is well aware of the problem the article talks about: you need to pick the correct definitions to formalise, you can&#x27;t just translate a random math textbook and expect it to work. Usually, you need to pick the correct generalisation of a statement which actually applies in all the cases where you need to use it.<p>Type theory is actually especially difficult here, because equality in type theory lacks many of the nice properties that you would expect it to have, on top of issues around isomorphisms and equality that are left vague in many textbooks&#x2F;papers&#x2F;etc. HoTT really does solve <i>this</i> issue. It presents a host of new questions and it&#x27;s almost certain that we haven&#x27;t found the best presentation of these ideas yet, but even the presentation we have solves the problems that the author talks about <i>in this article</i>.</div><br/><div id="40425562" class="c"><input type="checkbox" id="c-40425562" checked=""/><div class="controls bullet"><span class="by">aureianimus</span><span>|</span><a href="#40415680">root</a><span>|</span><a href="#40420969">parent</a><span>|</span><a href="#40416462">next</a><span>|</span><label class="collapse" for="c-40425562">[-]</label><label class="expand" for="c-40425562">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to hear a little bit more on what you think the downsides are? (Or a recommendation for a resource to read up on this?)</div><br/></div></div></div></div><div id="40416462" class="c"><input type="checkbox" id="c-40416462" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#40415680">root</a><span>|</span><a href="#40416102">parent</a><span>|</span><a href="#40420969">prev</a><span>|</span><a href="#40418798">next</a><span>|</span><label class="collapse" for="c-40416462">[-]</label><label class="expand" for="c-40416462">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Canonical&quot; refers largely to the names we give to things, so that we maximize the extent to which an isomorphism maps the object named A in X to the object named A in Y. And also to choosing an isomorphism that embeds in a different isomorphism (of superstructures) that isn&#x27;t strictly the topic of the current question.<p>I don&#x27;t think anyone thinks canonical isomorphisms are mathematically controversial (except some people having fun with studying scenarios where more than one isomorphism is equally canonical, and other meta studies), they are a convenient communication shorthand for avoiding boring details.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Isomorphism_theorems" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Isomorphism_theorems</a></div><br/><div id="40417872" class="c"><input type="checkbox" id="c-40417872" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#40415680">root</a><span>|</span><a href="#40416462">parent</a><span>|</span><a href="#40419734">next</a><span>|</span><label class="collapse" for="c-40417872">[-]</label><label class="expand" for="c-40417872">[1 more]</label></div><br/><div class="children"><div class="content">I think the original author makes a good case that a) the shorthand approach isn’t going to fly as we formalise b) different mathematicians mean different things by canonical and these details matter when trying to combining results and that therefore 3) it would be better to provide a proper definition of what you’re talking about and give it an unambiguous name.</div><br/></div></div><div id="40419734" class="c"><input type="checkbox" id="c-40419734" checked=""/><div class="controls bullet"><span class="by">euiq</span><span>|</span><a href="#40415680">root</a><span>|</span><a href="#40416462">parent</a><span>|</span><a href="#40417872">prev</a><span>|</span><a href="#40418798">next</a><span>|</span><label class="collapse" for="c-40419734">[-]</label><label class="expand" for="c-40419734">[2 more]</label></div><br/><div class="children"><div class="content">let me guess: you haven&#x27;t read the article, have you?</div><br/><div id="40425574" class="c"><input type="checkbox" id="c-40425574" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#40415680">root</a><span>|</span><a href="#40419734">parent</a><span>|</span><a href="#40418798">next</a><span>|</span><label class="collapse" for="c-40425574">[-]</label><label class="expand" for="c-40425574">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Please don&#x27;t comment on whether someone read an article. &quot;Did you even read the article? It mentions that&quot; can be shortened to &quot;The article mentions that&quot;.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a></div><br/></div></div></div></div></div></div></div></div><div id="40418798" class="c"><input type="checkbox" id="c-40418798" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40415680">parent</a><span>|</span><a href="#40416102">prev</a><span>|</span><a href="#40416634">next</a><span>|</span><label class="collapse" for="c-40418798">[-]</label><label class="expand" for="c-40418798">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It handles all the complications that the author mentions. This is one of the reasons type theorists were excited about HoTT in the first place.<p>It&#x27;s not that simple, Buzzard actually seems to be quite familiar with HoTT.  The HoTT schtick of defining equality between types as isomorphism does &#x27;handle&#x27; these issues for you in the sense that they are treated rigorously, but there&#x27;s no free lunch in that.  You still need to do all the usual work establishing compatibility of values, functions etc. with the relevant isomorphisms, so other than the presentation being somewhat more straightforward there is not much of a gain in usability.</div><br/></div></div><div id="40416634" class="c"><input type="checkbox" id="c-40416634" checked=""/><div class="controls bullet"><span class="by">jhanschoo</span><span>|</span><a href="#40415680">parent</a><span>|</span><a href="#40418798">prev</a><span>|</span><a href="#40415931">next</a><span>|</span><label class="collapse" for="c-40416634">[-]</label><label class="expand" for="c-40416634">[1 more]</label></div><br/><div class="children"><div class="content">Can you elaborate more on how you think HoTT can solve the issue Buzzard mentions that when formalizing informal mathematics, the author frequently has a model (or, a particular construction) in mind and requires properties present in the model, and then claims that this is true for all &quot;canonically equivalent&quot; objects without actually spending time explicating the abstract nonsense required to properly specify the properties that canonically equivalent objects preserve, for their developement? (see: a product vs. the product)<p>Edit: and furthermore, the situation where the obvious choice of universal property (read: level of isomorphism) was a poor one, in their attempt to formalize localizations.</div><br/></div></div><div id="40415931" class="c"><input type="checkbox" id="c-40415931" checked=""/><div class="controls bullet"><span class="by">bumbledraven</span><span>|</span><a href="#40415680">parent</a><span>|</span><a href="#40416634">prev</a><span>|</span><a href="#40416564">next</a><span>|</span><label class="collapse" for="c-40415931">[-]</label><label class="expand" for="c-40415931">[1 more]</label></div><br/><div class="children"><div class="content">For reference, the paper mentions the term &quot;homotopy&quot; exactly once, in this sentence:<p>&gt; The set-theoretic definition is too strong (Cauchy reals and Dedekind reals are certainly not equal as sets) and the homotopy type theoretic definition is too weak (things can be equal in more than one way, in contrast to Grothendieck’s usage of the term).</div><br/></div></div><div id="40416564" class="c"><input type="checkbox" id="c-40416564" checked=""/><div class="controls bullet"><span class="by">voxl</span><span>|</span><a href="#40415680">parent</a><span>|</span><a href="#40415931">prev</a><span>|</span><a href="#40417821">next</a><span>|</span><label class="collapse" for="c-40416564">[-]</label><label class="expand" for="c-40416564">[1 more]</label></div><br/><div class="children"><div class="content">Classical versus non-classical has nothing to do with it. HoTT does not work to capture what a mathematician means by &quot;unique isomorphism&quot; because witnesses of equality in HoTT are very much not unique.</div><br/></div></div><div id="40417821" class="c"><input type="checkbox" id="c-40417821" checked=""/><div class="controls bullet"><span class="by">nicklecompte</span><span>|</span><a href="#40415680">parent</a><span>|</span><a href="#40416564">prev</a><span>|</span><a href="#40418376">next</a><span>|</span><label class="collapse" for="c-40417821">[-]</label><label class="expand" for="c-40417821">[2 more]</label></div><br/><div class="children"><div class="content">I think HOTT helps remove a lot of the footguns and computational hairiness around using type-theoretic mathematics. But the issues Buzzard is talking about are really more profound than that.
This relates to a much deeper (but familiar and nontechnical) philosophical problem: you assign a symbol to a thing, and read two sentences that refer to the same symbol (&quot;up to isomorphism&quot;), but not necessarily the same thing. If the sentences contradict each other, is it because they disagree on the meaning of the symbol, or do they disagree on the essence of the thing? There is a strong argument that most debates about free will and consciousness are really about what poorly-understood thing(s) we are assigning to the symbol. Worse, this makes such debates ripe for bad faith, where flaws in an argument are defended by implicitly changing the meaning of the symbol.<p>In the context of &quot;&quot;&quot;simple&quot;&quot;&quot; mathematics, preverbal toddlers and chimpanzees clearly have an innate understanding of quantity and order. It&#x27;s only after children fully develop this innate understanding that there&#x27;s any point in teaching them &quot;one,&quot; &quot;two,&quot; &quot;three,&quot; and thereby giving them the <i>tools</i> for handling larger numbers. I don&#x27;t think it makes sense to say that toddlers understand the Peano axioms. Rather, Peano formulated the axioms based on his own (highly sophisticated) innate understanding of number. But given he spent decades of pondering the topic, it seems like Peano&#x27;s abstract conception of &quot;number&quot; became different from (say) Kronecker&#x27;s, or other constructivists&#x2F;etc. Simply slapping the word &quot;integer&quot; on two different concepts and pointing out that they coincide for quantities we can comprehend doesn&#x27;t actually do anything by itself to address the discrepancy in concept revealed by Peano allowing unbounded integers and Kronecker&#x27;s skepticism. (The best argument against constructivism is essentially sociological and pragmatic, not &quot;mathematically rational.&quot;)<p>Zooming out a bit, I suspect we (scientifically-informed laypeople + many scientists) badly misunderstand the link between language and human cognition. It seems more likely to me that we have extremely advanced chimpanzee brains that make all sorts of sophisticated chimpanzee deductions, including the extremely difficult question of &quot;what is a number?&quot;, but to be shared (and critically investigated) these deductions have to be squished into language, as a woefully insufficient compromise. And I think a lot of philosophical - and metamathematical - confusion can be understood as a discrepancy between our chimpanzee brains having a largely rigorous understanding of something, but running into limits with our Broca&#x27;s and Wernicke&#x27;s areas, limits which may or may not be fixed by &quot;technological development&quot; in human language. (Don&#x27;t even get me started on GPT...)</div><br/><div id="40424790" class="c"><input type="checkbox" id="c-40424790" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#40415680">root</a><span>|</span><a href="#40417821">parent</a><span>|</span><a href="#40418376">next</a><span>|</span><label class="collapse" for="c-40424790">[-]</label><label class="expand" for="c-40424790">[1 more]</label></div><br/><div class="children"><div class="content">The level of insights and clearness in your message,  and most comments in this thread actually,  is surprising great compared to what I often read on HN.<p>Thank you very much for this</div><br/></div></div></div></div><div id="40418376" class="c"><input type="checkbox" id="c-40418376" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#40415680">parent</a><span>|</span><a href="#40417821">prev</a><span>|</span><a href="#40417029">next</a><span>|</span><label class="collapse" for="c-40418376">[-]</label><label class="expand" for="c-40418376">[1 more]</label></div><br/><div class="children"><div class="content">The fact that Buzzard is writing this paper at all to me shows a much higher degree of respect than before --- see how humble the overview is. I think this is great progress!</div><br/></div></div><div id="40417029" class="c"><input type="checkbox" id="c-40417029" checked=""/><div class="controls bullet"><span class="by">YetAnotherNick</span><span>|</span><a href="#40415680">parent</a><span>|</span><a href="#40418376">prev</a><span>|</span><a href="#40424115">next</a><span>|</span><label class="collapse" for="c-40417029">[-]</label><label class="expand" for="c-40417029">[4 more]</label></div><br/><div class="children"><div class="content">I think 99.9% of the people talking about HoTT haven&#x27;t used HoTT in practice. They just see isomorphism is equivalent to equivalence(or something similar), comes up with a mental model and think this is the main contribution of HoTT, whereas isomorphism is a well studied thing even before formal set theory was a thing. HoTT gets weird and anyone who has tried any tool to prove anything in HoTT knows this, and this is the reason why it didn&#x27;t got adopted even though many leading tools like lean worked hard to implement it.</div><br/><div id="40418452" class="c"><input type="checkbox" id="c-40418452" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#40415680">root</a><span>|</span><a href="#40417029">parent</a><span>|</span><a href="#40417108">next</a><span>|</span><label class="collapse" for="c-40418452">[-]</label><label class="expand" for="c-40418452">[2 more]</label></div><br/><div class="children"><div class="content">Have you used it? If yes, could you elaborate? Or if you haven&#x27;t, can you point to any recent source on what it&#x27;s like to be using HoTT in 2024?</div><br/><div id="40420231" class="c"><input type="checkbox" id="c-40420231" checked=""/><div class="controls bullet"><span class="by">YetAnotherNick</span><span>|</span><a href="#40415680">root</a><span>|</span><a href="#40418452">parent</a><span>|</span><a href="#40417108">next</a><span>|</span><label class="collapse" for="c-40420231">[-]</label><label class="expand" for="c-40420231">[1 more]</label></div><br/><div class="children"><div class="content">[1] is the only video which I would say I found any bit accessible. But to be honest even after spending days, I couldn&#x27;t grok it. And in my observation, different implementations of HoTT are quite different from each other.<p>[1]: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=x4cz1OgpU3M" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=x4cz1OgpU3M</a></div><br/></div></div></div></div></div></div></div></div><div id="40424115" class="c"><input type="checkbox" id="c-40424115" checked=""/><div class="controls bullet"><span class="by">_as_text</span><span>|</span><a href="#40415680">prev</a><span>|</span><a href="#40423434">next</a><span>|</span><label class="collapse" for="c-40424115">[-]</label><label class="expand" for="c-40424115">[1 more]</label></div><br/><div class="children"><div class="content">I really like this. I remember my first serious math book, which was this old-school set theory and topology book, and being all excited about learning set theory up until I encountered iterated Cartesian product, and was forced to accept that ((x, y), z) and (x, (y, z)) are supposed to be indistinguishable to me. An answer on StackExchange said that &quot;you will never, ever, ever need to worry about the details of set theory&quot;, but I still did.</div><br/></div></div><div id="40417918" class="c"><input type="checkbox" id="c-40417918" checked=""/><div class="controls bullet"><span class="by">abeppu</span><span>|</span><a href="#40423434">prev</a><span>|</span><a href="#40424632">next</a><span>|</span><label class="collapse" for="c-40417918">[-]</label><label class="expand" for="c-40417918">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t actually dug up the source, so I&#x27;m not sure if the gaps here are related, but GC Rota apparently claimed that one reason the umbral calculus remained mysterious for as long as it did was about ambiguities with `=`.<p>&gt; Rota later stated that much confusion resulted from the failure to distinguish between three equivalence relations that occur frequently in this topic, all of which were denoted by &quot;=&quot;.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Umbral_calculus#The_modern_umbral_calculus" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Umbral_calculus#The_modern_umb...</a></div><br/><div id="40425546" class="c"><input type="checkbox" id="c-40425546" checked=""/><div class="controls bullet"><span class="by">dan_mctree</span><span>|</span><a href="#40417918">parent</a><span>|</span><a href="#40424632">next</a><span>|</span><label class="collapse" for="c-40425546">[-]</label><label class="expand" for="c-40425546">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s so much ambiguous context that goes into your average &#x27;=&#x27;, even when just talking about your standard functions on real numbers. You&#x27;ll see it being used for anything from:<p>- We&#x27;ve found these to be equal<p>- We&#x27;re hypothesizing this to be equal<p>- These are approximately equal<p>- These are defined to be equal<p>- This is a way to calculate something else, whether it&#x27;s equal is up to your philosophy (a^2+b^2=c^2)<p>- I&#x27;m transforming my function into something else that looks different but is exactly the same<p>- I&#x27;m transforming my function into something else that is the same for some of the stuff I care about (but for example does not work anymore for negative numbers, complex nrs, etc.)<p>- I&#x27;m transforming my function into something else, but it&#x27;s actually a trapdoor, and you can&#x27;t convert it back.<p>- This is kind of on average true within an extremely simplified context or we know it&#x27;s not true at all, but we&#x27;ll pretend for simplification (looking at you physics)<p>- We are trying to check if these two are equal<p>- This is equal, but only within a context where these variables follow some constraints mentioned somewhere else entirely<p>- This is equal, but, we&#x27;re not going to say whether you can or can&#x27;t replace the variables with functions or whether it supports complex nrs, negative nrs,  non-integers, etc.<p>A lot of this is usually kind of clear from context, but some of these differences are a nightmare if you want to code it out</div><br/></div></div></div></div><div id="40424632" class="c"><input type="checkbox" id="c-40424632" checked=""/><div class="controls bullet"><span class="by">giardini</span><span>|</span><a href="#40417918">prev</a><span>|</span><a href="#40417977">next</a><span>|</span><label class="collapse" for="c-40424632">[-]</label><label class="expand" for="c-40424632">[2 more]</label></div><br/><div class="children"><div class="content">And I thought &quot;Grothendieck&quot; was a German social disease! I&#x27;m getting a real education here on HN!</div><br/><div id="40425584" class="c"><input type="checkbox" id="c-40425584" checked=""/><div class="controls bullet"><span class="by">hanche</span><span>|</span><a href="#40424632">parent</a><span>|</span><a href="#40417977">next</a><span>|</span><label class="collapse" for="c-40425584">[-]</label><label class="expand" for="c-40425584">[1 more]</label></div><br/><div class="children"><div class="content">The story of Grothendieck is really fascinating. He was a superstar in algebraic geometry, only to suddenly reject the endeavor of mathematics and going off to grow vegetables in the Pyrenees. He also demanded that all notes from his lectures be destroyed. But those notes existed in so many hands, I don’t think many people (if any) complied.</div><br/></div></div></div></div><div id="40417977" class="c"><input type="checkbox" id="c-40417977" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#40424632">prev</a><span>|</span><a href="#40417419">next</a><span>|</span><label class="collapse" for="c-40417977">[-]</label><label class="expand" for="c-40417977">[3 more]</label></div><br/><div class="children"><div class="content">I was just thinking about something adjacent to this the other day. I had this half-baked idea that you could classify all the &quot;types&quot; built out of, say (R, ×, →) by algebraically replacing each copy of R with a finite set of cardinality <i>a</i> and then counting the cardinality of the entire type expression. So you&#x27;d formally associate, say, R^3 with the algebraic term a^3, and that holds regardless of how you rearrange R^3 = R^2 × R or R × R^2 or whatever. I liked the idea because it seemed (?) to derive non-obvious set theoretic equivalences, for free: such as<p><pre><code>    R -&gt; (R -&gt; R)  ~   (a^a)^a = a^(a^2)
    R^2 -&gt; R       ~   a^(a^2)

    (R -&gt; R)^2     ~   (a^a)^2 = a^(2a)
    R -&gt; R^2       ~   a^(2a)
</code></pre>
The first equivalence is between a &quot;curried&quot;, partial-application, function form of a function of two arguments, and the &quot;uncurried&quot; form which takes a tuple argument. The second equivalence is between a pair of real functions and a path in the plane R^2—the two functions getting identified with the coordinate paths x(t) and y(t). (Remember the cardinality of distinct functions over finite sets S -&gt; T is |T|^|S|).<p>And I think you can take this further, I&#x27;m not sure how far, for example by associating different formal parameters a,b,c... for different abstract types S,T,U... Is this a trick that&#x27;s already known, in type theory?<p>(My motivation was to try to classify the &quot;complexity&quot;, &quot;size&quot;, of higher-ordered functions over the reals. The inspiration&#x27;s that you&#x27;re imagining a numerical approximation on a grid of size <i>a</i> for (a finite subinterval in) each copy of R: then that cardinality relates to the memory size of the numerical algorithm, working inside that space. And you could interpret the asymptotic growth of the formal function, as a complexity measure of the space.  If you think of R^n -&gt; R as a &quot;larger&quot; function space than R -&gt; R^n, that observation maps to a^(a^n) being an asymptotically faster-growing function (of &#x27;a&#x27;) than (a^n)^a = a^(na). And similarly the functionals, (R -&gt; R) -&gt; R, and function operators (like differential operators) (R -&gt; R) -&gt; (R -&gt; R), form a hierarchy of increasing &quot;size&quot;).</div><br/><div id="40418848" class="c"><input type="checkbox" id="c-40418848" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#40417977">parent</a><span>|</span><a href="#40424540">next</a><span>|</span><label class="collapse" for="c-40418848">[-]</label><label class="expand" for="c-40418848">[1 more]</label></div><br/><div class="children"><div class="content">The connection between type isomorphisms and algebraic equalities is known and explored in a variety of interesting ways.<p>I don&#x27;t know the precise history of the development of the notation and vocabulary, but there&#x27;s a reason types like A+B are notated with a plus symbol and called &quot;sums&quot;. Similarly for products. And it may surprise you (or not) to learn that people sometimes call A -&gt; B an exponential type, and even notate it with superscript notation.<p>One of my favorites is the result that the binary tree type is isomorphic to septuples of binary trees, which you can arrive at by using the definition of binary trees as the fixed point solution of T = 1 + T*T and deriving T = T^7 with some algebra. [0]<p>[0] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;math&#x2F;9405205" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;math&#x2F;9405205</a></div><br/></div></div><div id="40424540" class="c"><input type="checkbox" id="c-40424540" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#40417977">parent</a><span>|</span><a href="#40418848">prev</a><span>|</span><a href="#40417419">next</a><span>|</span><label class="collapse" for="c-40424540">[-]</label><label class="expand" for="c-40424540">[1 more]</label></div><br/><div class="children"><div class="content">This has been studied under the name algebraic data types.</div><br/></div></div></div></div><div id="40417419" class="c"><input type="checkbox" id="c-40417419" checked=""/><div class="controls bullet"><span class="by">hackandthink</span><span>|</span><a href="#40417977">prev</a><span>|</span><a href="#40416517">next</a><span>|</span><label class="collapse" for="c-40417419">[-]</label><label class="expand" for="c-40417419">[2 more]</label></div><br/><div class="children"><div class="content">This is an excellent text to understand mathematical structuralism.<p>But it feels anticlimactic.<p>At the beginning there are fundamental problems with mathematical equality.<p>In the end, there is no great new idea but only the observation that in algebraic geometry some proofs have holes (two kinds), but they can be filled (quite) schematically.</div><br/><div id="40418721" class="c"><input type="checkbox" id="c-40418721" checked=""/><div class="controls bullet"><span class="by">ducttapecrown</span><span>|</span><a href="#40417419">parent</a><span>|</span><a href="#40416517">next</a><span>|</span><label class="collapse" for="c-40418721">[-]</label><label class="expand" for="c-40418721">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Some proofs&quot; are the proof used to verify that the definition of an affine scheme makes sense, and the author motions in the direction that <i>every</i> single proof in algebraic geometry uses identically wrong arguments when using the language of &quot;canonical&quot; maps.<p>Thus the replication crisis of mathematics is revealed. In the words of John Conway: a map is canonical if you and your office neighbor write down the same map.</div><br/></div></div></div></div><div id="40416517" class="c"><input type="checkbox" id="c-40416517" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#40417419">prev</a><span>|</span><a href="#40422001">next</a><span>|</span><label class="collapse" for="c-40416517">[-]</label><label class="expand" for="c-40416517">[1 more]</label></div><br/><div class="children"><div class="content">&quot;When is one thing equal to some other thing?&quot;<p>Barry Mazur
June 12, 2007<p><a href="https:&#x2F;&#x2F;bpb-us-e1.wpmucdn.com&#x2F;sites.harvard.edu&#x2F;dist&#x2F;a&#x2F;189&#x2F;files&#x2F;2023&#x2F;01&#x2F;When-is-one-thing-equal-to-some-other-thing.pdf" rel="nofollow">https:&#x2F;&#x2F;bpb-us-e1.wpmucdn.com&#x2F;sites.harvard.edu&#x2F;dist&#x2F;a&#x2F;189&#x2F;f...</a><p><a href="https:&#x2F;&#x2F;people.math.osu.edu&#x2F;cogdell.1&#x2F;6112-Mazur-www.pdf" rel="nofollow">https:&#x2F;&#x2F;people.math.osu.edu&#x2F;cogdell.1&#x2F;6112-Mazur-www.pdf</a></div><br/></div></div><div id="40422001" class="c"><input type="checkbox" id="c-40422001" checked=""/><div class="controls bullet"><span class="by">joewferrara</span><span>|</span><a href="#40416517">prev</a><span>|</span><a href="#40417053">next</a><span>|</span><label class="collapse" for="c-40422001">[-]</label><label class="expand" for="c-40422001">[1 more]</label></div><br/><div class="children"><div class="content">kevin buzzard is a very good(usually math) expositor with a bent towards programming. love it</div><br/></div></div><div id="40417053" class="c"><input type="checkbox" id="c-40417053" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#40422001">prev</a><span>|</span><a href="#40415693">next</a><span>|</span><label class="collapse" for="c-40417053">[-]</label><label class="expand" for="c-40417053">[4 more]</label></div><br/><div class="children"><div class="content">This is a very old consideration (cf <a href="https:&#x2F;&#x2F;www.jstor.org&#x2F;stable&#x2F;2183530" rel="nofollow">https:&#x2F;&#x2F;www.jstor.org&#x2F;stable&#x2F;2183530</a>).<p>If you want to frame a &#x27;universal defining property&#x27;, you have to frame it in some language.  The definition, therefore, is inevitably idiosyncratic to that language, and, if you specify the same property using a different language, the definition is going to change.  What&#x27;s more, the two definitions can be incommensurable.<p>And---all you have done is translate from the object language to the meet language--leaving the definitions of the terms of the meta language completely unexplicated.<p>The solution to this is as old too---like &quot;point&quot;, &quot;line&quot;, etc, these terms can--and arguably should--remain completely <i>un</i>-defined.</div><br/><div id="40417078" class="c"><input type="checkbox" id="c-40417078" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#40417053">parent</a><span>|</span><a href="#40419033">next</a><span>|</span><label class="collapse" for="c-40417078">[-]</label><label class="expand" for="c-40417078">[2 more]</label></div><br/><div class="children"><div class="content">whence did you learn this idiom of &quot;the meet language&quot;???<p>i have <i>working</i> definitions of line, point, etc.. in terms of dimensions. but I have some issues with the precise definition of &quot;dimension&quot; due to having picked up the concept of &quot;density&quot;. I cannot say what&#x27;s the difference between density and dimension</div><br/><div id="40423537" class="c"><input type="checkbox" id="c-40423537" checked=""/><div class="controls bullet"><span class="by">jhanschoo</span><span>|</span><a href="#40417053">root</a><span>|</span><a href="#40417078">parent</a><span>|</span><a href="#40419033">next</a><span>|</span><label class="collapse" for="c-40423537">[-]</label><label class="expand" for="c-40423537">[1 more]</label></div><br/><div class="children"><div class="content">Meet here is shorthand the comment author is using for: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Join_and_meet" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Join_and_meet</a><p>You should read it as: &quot;the largest group of properties that both languages agree about said abstractly defined mathematical object.&quot;</div><br/></div></div></div></div><div id="40419033" class="c"><input type="checkbox" id="c-40419033" checked=""/><div class="controls bullet"><span class="by">yau8edq12i</span><span>|</span><a href="#40417053">parent</a><span>|</span><a href="#40417078">prev</a><span>|</span><a href="#40415693">next</a><span>|</span><label class="collapse" for="c-40419033">[-]</label><label class="expand" for="c-40419033">[1 more]</label></div><br/><div class="children"><div class="content">How can you frame a paper from 1965 as &quot;very old&quot; when the linked article is about Grothendieck, who started his math PhD in 1950 (and presumably studied math before that)?</div><br/></div></div></div></div><div id="40415693" class="c"><input type="checkbox" id="c-40415693" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#40417053">prev</a><span>|</span><a href="#40417127">next</a><span>|</span><label class="collapse" for="c-40415693">[-]</label><label class="expand" for="c-40415693">[4 more]</label></div><br/><div class="children"><div class="content">Equality can be philosophically troubling, but as a practical matter, what you care about is the indiscernibility of identicals, and if every property you use follows from a universal property, then equal up to isomorphism is just equal. So every Rubik&#x27;s cube is equal considered as a group of face rotations, and there&#x27;s only one Rubik&#x27;s cube, but if you care about chemical properties of sticker glue, they&#x27;re no longer equal.</div><br/><div id="40417911" class="c"><input type="checkbox" id="c-40417911" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#40415693">parent</a><span>|</span><a href="#40419736">next</a><span>|</span><label class="collapse" for="c-40417911">[-]</label><label class="expand" for="c-40417911">[1 more]</label></div><br/><div class="children"><div class="content">Something the author points out: sometimes theorems directly rely on specific constructions of mathematical objects, which are then used to establish things that do not mention the construction.</div><br/></div></div><div id="40419736" class="c"><input type="checkbox" id="c-40419736" checked=""/><div class="controls bullet"><span class="by">passion__desire</span><span>|</span><a href="#40415693">parent</a><span>|</span><a href="#40417911">prev</a><span>|</span><a href="#40415879">next</a><span>|</span><label class="collapse" for="c-40419736">[-]</label><label class="expand" for="c-40419736">[1 more]</label></div><br/><div class="children"><div class="content">The glue point reminds me of Benacerraf problem.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Benacerraf%27s_identification_problem" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Benacerraf%27s_identificatio...</a></div><br/></div></div></div></div><div id="40417127" class="c"><input type="checkbox" id="c-40417127" checked=""/><div class="controls bullet"><span class="by">ysofunny</span><span>|</span><a href="#40415693">prev</a><span>|</span><a href="#40416245">next</a><span>|</span><label class="collapse" for="c-40417127">[-]</label><label class="expand" for="c-40417127">[2 more]</label></div><br/><div class="children"><div class="content">reminicscent of Euler&#x27;s use of Pi?<p>I recall that Euler would write Pi but sometimes he meant 2*pi, or possibly pi&#x2F;2 depending on context</div><br/></div></div><div id="40416245" class="c"><input type="checkbox" id="c-40416245" checked=""/><div class="controls bullet"><span class="by">nyc111</span><span>|</span><a href="#40417127">prev</a><span>|</span><label class="collapse" for="c-40416245">[-]</label><label class="expand" for="c-40416245">[10 more]</label></div><br/><div class="children"><div class="content">When this subject comes up I always think that the equality sign is loaded. It can mean, definition, equality, identity, and proportionality. How come this state of the equality sign is not mentioned in the paper?</div><br/><div id="40416556" class="c"><input type="checkbox" id="c-40416556" checked=""/><div class="controls bullet"><span class="by">mxmlnkn</span><span>|</span><a href="#40416245">parent</a><span>|</span><a href="#40419011">next</a><span>|</span><label class="collapse" for="c-40416556">[-]</label><label class="expand" for="c-40416556">[3 more]</label></div><br/><div class="children"><div class="content">As far as I remember, that&#x27;s not a problem in math:<p>:= definition
≡ identity
= equality
∝ proportionality</div><br/><div id="40416853" class="c"><input type="checkbox" id="c-40416853" checked=""/><div class="controls bullet"><span class="by">nyc111</span><span>|</span><a href="#40416245">root</a><span>|</span><a href="#40416556">parent</a><span>|</span><a href="#40419011">next</a><span>|</span><label class="collapse" for="c-40416853">[-]</label><label class="expand" for="c-40416853">[2 more]</label></div><br/><div class="children"><div class="content">But this is how it works:<p>= definition = identity = equality = proportionality</div><br/><div id="40419756" class="c"><input type="checkbox" id="c-40419756" checked=""/><div class="controls bullet"><span class="by">Twisol</span><span>|</span><a href="#40416245">root</a><span>|</span><a href="#40416853">parent</a><span>|</span><a href="#40419011">next</a><span>|</span><label class="collapse" for="c-40419756">[-]</label><label class="expand" for="c-40419756">[1 more]</label></div><br/><div class="children"><div class="content">Big-O notation is a famous example where = is some flavor of (asymptotic) proportionality, and it catches a lot of people out when they first learn about it.</div><br/></div></div></div></div></div></div><div id="40419011" class="c"><input type="checkbox" id="c-40419011" checked=""/><div class="controls bullet"><span class="by">yau8edq12i</span><span>|</span><a href="#40416245">parent</a><span>|</span><a href="#40416556">prev</a><span>|</span><a href="#40416506">next</a><span>|</span><label class="collapse" for="c-40419011">[-]</label><label class="expand" for="c-40419011">[5 more]</label></div><br/><div class="children"><div class="content">As a mathematician, I have never, ever seen the equal sign used to denote proportionality. I cannot tell what you mean by &quot;identity&quot; that wouldn&#x27;t be equality. And a definition in the sense you seem to mean is, indeed, also an equality. I guess this issue not mentioned in the paper because it doesn&#x27;t exist.</div><br/><div id="40425523" class="c"><input type="checkbox" id="c-40425523" checked=""/><div class="controls bullet"><span class="by">xanderlewis</span><span>|</span><a href="#40416245">root</a><span>|</span><a href="#40419011">parent</a><span>|</span><a href="#40419955">next</a><span>|</span><label class="collapse" for="c-40425523">[-]</label><label class="expand" for="c-40425523">[1 more]</label></div><br/><div class="children"><div class="content">I agree it’s not really used symbolically, but isn’t it referring to the difference between, say:<p>(x + y)(x - y) = x^2 - y^2<p>(an identity, since it’s true for every x and every y) and something more arbitrary like<p>3x^2 + 2x - 7 = 0<p>(an equation certainly not valid for all x and whose solutions are sought).<p>Of course, really, the first one is a straightforward equality missing some universal quantification at the front… so maybe that’s just what the triple equals sign would be short for in this case.</div><br/></div></div><div id="40419955" class="c"><input type="checkbox" id="c-40419955" checked=""/><div class="controls bullet"><span class="by">ducttapecrown</span><span>|</span><a href="#40416245">root</a><span>|</span><a href="#40419011">parent</a><span>|</span><a href="#40425523">prev</a><span>|</span><a href="#40416506">next</a><span>|</span><label class="collapse" for="c-40419955">[-]</label><label class="expand" for="c-40419955">[3 more]</label></div><br/><div class="children"><div class="content">[x:y] = [lx:ly]<p>and I suppose the model of localization discussed in the article above counts as well.</div><br/><div id="40420483" class="c"><input type="checkbox" id="c-40420483" checked=""/><div class="controls bullet"><span class="by">yau8edq12i</span><span>|</span><a href="#40416245">root</a><span>|</span><a href="#40419955">parent</a><span>|</span><a href="#40416506">next</a><span>|</span><label class="collapse" for="c-40420483">[-]</label><label class="expand" for="c-40420483">[2 more]</label></div><br/><div class="children"><div class="content">... What? That&#x27;s just symbol soup. What are you trying to write? Do it in latex if it helps.</div><br/><div id="40425323" class="c"><input type="checkbox" id="c-40425323" checked=""/><div class="controls bullet"><span class="by">laurent_du</span><span>|</span><a href="#40416245">root</a><span>|</span><a href="#40420483">parent</a><span>|</span><a href="#40416506">next</a><span>|</span><label class="collapse" for="c-40425323">[-]</label><label class="expand" for="c-40425323">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not symbol soup, it&#x27;s projective coordinates. Did you claim to be a mathematician? I merely have a PhD in Mathematics and a few papers in peer-review journals, so, unlike you, not a real mathematician, and I immediately understood the point.</div><br/></div></div></div></div></div></div></div></div><div id="40416506" class="c"><input type="checkbox" id="c-40416506" checked=""/><div class="controls bullet"><span class="by">mikhailfranco</span><span>|</span><a href="#40416245">parent</a><span>|</span><a href="#40419011">prev</a><span>|</span><label class="collapse" for="c-40416506">[-]</label><label class="expand" for="c-40416506">[1 more]</label></div><br/><div class="children"><div class="content"><i>up to (non-)unique isomorphism</i></div><br/></div></div></div></div></div></div></div></div></div></body></html>