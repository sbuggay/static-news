<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717059669946" as="style"/><link rel="stylesheet" href="styles.css?v=1717059669946"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://dashbit.co/blog/elixir-ml-s1-2024-mlir-arrow-instructor">Elixir and Machine Learning in 2024 so far: MLIR, Arrow, structured LLM, etc.</a> <span class="domain">(<a href="https://dashbit.co">dashbit.co</a>)</span></div><div class="subtext"><span>clessg</span> | <span>57 comments</span></div><br/><div><div id="40516100" class="c"><input type="checkbox" id="c-40516100" checked=""/><div class="controls bullet"><span class="by">mrdoops</span><span>|</span><a href="#40514674">next</a><span>|</span><label class="collapse" for="c-40516100">[-]</label><label class="expand" for="c-40516100">[7 more]</label></div><br/><div class="children"><div class="content">IMO the big win for Elixir&#x2F;Nx&#x2F;Bumblebee&#x2F;etc is that you can do batched distributed inference out of the box without deploying anything separate to your app or hitting an API. Massive complexity reduction and you can more easily scale up or down. <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;nx&#x2F;Nx.Serving.html#content" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;nx&#x2F;Nx.Serving.html#content</a><p>And there&#x27;s also a scale to 0 story for when you&#x27;re not using that GPU at all: <a href="https:&#x2F;&#x2F;github.com&#x2F;phoenixframework&#x2F;flame">https:&#x2F;&#x2F;github.com&#x2F;phoenixframework&#x2F;flame</a><p>1 language&#x2F;toolchain. 1 deployable app. Real time and distributed machine learning baked in. 1 dev can go really far.</div><br/><div id="40517293" class="c"><input type="checkbox" id="c-40517293" checked=""/><div class="controls bullet"><span class="by">6gvONxR4sf7o</span><span>|</span><a href="#40516100">parent</a><span>|</span><a href="#40514674">next</a><span>|</span><label class="collapse" for="c-40517293">[-]</label><label class="expand" for="c-40517293">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been really curious about BEAM languages but never made the leap. How well does it manage heterogeneous compute? I&#x27;m used to other languages making me define what happens on CPU vs GPU and defining cross-machine talk around those kinds of considerations.<p>What parts of that does elixir (and company) allow me to not write? Is there a good balance between abstractions when it comes to still maybe wanting control over what goes where (heteregeneity)?<p>Super curious and kinda looking for an excuse here :)</div><br/><div id="40517510" class="c"><input type="checkbox" id="c-40517510" checked=""/><div class="controls bullet"><span class="by">elbasti</span><span>|</span><a href="#40516100">root</a><span>|</span><a href="#40517293">parent</a><span>|</span><a href="#40517798">next</a><span>|</span><label class="collapse" for="c-40517510">[-]</label><label class="expand" for="c-40517510">[3 more]</label></div><br/><div class="children"><div class="content">The BEAM is pretty high level, and it&#x27;s REALLY good at managing distributed compute at the thread or device level.<p>If you have a parallelizeable workflow, it&#x27;s very easy to make it (properly!) parallel locally, where by &quot;properly&quot; I mean having supervision trees, sane restart behavior, etc.<p>And once you have that you can extend that parallelism to different nodes in a network (with the same sanity around supervision and discovery) basically for free. Like, one-line-of-code for free.<p>Nonetheless, it&#x27;s all message-passing, and so pretty high level. AFAIK it&#x27;s not designed for parallelizing compute at GPU scale.<p>That being said, if you have multiple GPUs and multiple machines that have to <i>coordinate</i> between them, Elixir&#x2F;Erlang is pretty much perfect.</div><br/><div id="40519186" class="c"><input type="checkbox" id="c-40519186" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#40516100">root</a><span>|</span><a href="#40517510">parent</a><span>|</span><a href="#40519398">next</a><span>|</span><label class="collapse" for="c-40519186">[-]</label><label class="expand" for="c-40519186">[1 more]</label></div><br/><div class="children"><div class="content">If you have a multistage workflow with concurrent and possibly heterogenous requests that hit all the time you can very easily batch and distribute the workflow among compute resources in &quot;the most natural way possible&quot; easily, without having to resort to grace periods, etc. which introduce latency.  I think that would be much harder to accomplish with java.</div><br/></div></div><div id="40519398" class="c"><input type="checkbox" id="c-40519398" checked=""/><div class="controls bullet"><span class="by">inawarminister</span><span>|</span><a href="#40516100">root</a><span>|</span><a href="#40517510">parent</a><span>|</span><a href="#40519186">prev</a><span>|</span><a href="#40517798">next</a><span>|</span><label class="collapse" for="c-40519398">[-]</label><label class="expand" for="c-40519398">[1 more]</label></div><br/><div class="children"><div class="content">I think Numerical Elixir (NX) allows for GPU programming. It uses XLA for scheduling computation?</div><br/></div></div></div></div><div id="40517798" class="c"><input type="checkbox" id="c-40517798" checked=""/><div class="controls bullet"><span class="by">itronitron</span><span>|</span><a href="#40516100">root</a><span>|</span><a href="#40517293">parent</a><span>|</span><a href="#40517510">prev</a><span>|</span><a href="#40517355">next</a><span>|</span><label class="collapse" for="c-40517798">[-]</label><label class="expand" for="c-40517798">[1 more]</label></div><br/><div class="children"><div class="content">You might want to look at the java aparapi project<p><i>Aparapi allows Java developers to take advantage of the compute power of GPU and APU devices by executing data parallel code fragments on the GPU rather than being confined to the local CPU. It does this by converting Java bytecode to OpenCL at runtime and executing on the GPU, if for any reason Aparapi can&#x27;t execute on the GPU it will execute in a Java thread pool.</i><p><a href="https:&#x2F;&#x2F;aparapi.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aparapi.github.io&#x2F;</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;aparapi&#x2F;aparapi">https:&#x2F;&#x2F;github.com&#x2F;aparapi&#x2F;aparapi</a><p>but avoid the non-official fork which sometimes comes up in search results.</div><br/></div></div><div id="40517355" class="c"><input type="checkbox" id="c-40517355" checked=""/><div class="controls bullet"><span class="by">ricketycricket</span><span>|</span><a href="#40516100">root</a><span>|</span><a href="#40517293">parent</a><span>|</span><a href="#40517798">prev</a><span>|</span><a href="#40514674">next</a><span>|</span><label class="collapse" for="c-40517355">[-]</label><label class="expand" for="c-40517355">[1 more]</label></div><br/><div class="children"><div class="content">May not answer all your questions, but this may be a good starting point: <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;nx&#x2F;Nx.Defn.html" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;nx&#x2F;Nx.Defn.html</a></div><br/></div></div></div></div></div></div><div id="40514674" class="c"><input type="checkbox" id="c-40514674" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#40516100">prev</a><span>|</span><a href="#40514171">next</a><span>|</span><label class="collapse" for="c-40514674">[-]</label><label class="expand" for="c-40514674">[19 more]</label></div><br/><div class="children"><div class="content">From a &quot;marketing strategy&quot; point of view, I wonder what the thinking is in investing in this stuff so heavily when Python seems to be kind of the go-to? Will they be able to create a &quot;good enough&quot; environment to do that kind of work with Elixir? Is it just someone or a company scratching their own itch?<p>This is a genuine question - I don&#x27;t know much about &quot;AI stuff&quot;, but do know something about the economics of programming languages and I&#x27;m &quot;intellectually curious&quot; about what is driving this and what the goals are, rather than critical of Elixir. I love working with BEAM and miss it.</div><br/><div id="40515821" class="c"><input type="checkbox" id="c-40515821" checked=""/><div class="controls bullet"><span class="by">andy_ppp</span><span>|</span><a href="#40514674">parent</a><span>|</span><a href="#40514902">next</a><span>|</span><label class="collapse" for="c-40515821">[-]</label><label class="expand" for="c-40515821">[1 more]</label></div><br/><div class="children"><div class="content">I actually think the BEAM is an ideal environment for machine learning, sharding things across machines. The only thing I’m not sure of is if PyTorch etc. are more optimised than XLA the backend Axon uses… would be good to see some performance comparisons of a big LLM running on both. For everything else I’d suggest Elixir was a better experience.</div><br/></div></div><div id="40514902" class="c"><input type="checkbox" id="c-40514902" checked=""/><div class="controls bullet"><span class="by">PaulStatezny</span><span>|</span><a href="#40514674">parent</a><span>|</span><a href="#40515821">prev</a><span>|</span><a href="#40516785">next</a><span>|</span><label class="collapse" for="c-40514902">[-]</label><label class="expand" for="c-40514902">[8 more]</label></div><br/><div class="children"><div class="content">One factor may be that a few years back the language creator (José Valim, also the author of this article) announced that the language is basically &quot;completed&quot;, and that they would shift focus to other things like developer tooling and other projects outside of the language itself.<p>José is quite prolific, so I think it&#x27;s natural that he moves on to things like this. It&#x27;s hard to know what reception will be like until you build it.</div><br/><div id="40515236" class="c"><input type="checkbox" id="c-40515236" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40514902">parent</a><span>|</span><a href="#40516664">next</a><span>|</span><label class="collapse" for="c-40515236">[-]</label><label class="expand" for="c-40515236">[4 more]</label></div><br/><div class="children"><div class="content">From a strictly &quot;marketing&quot; point of view, if  you want to grow the language and ecosystem, it seems the successful move is to stake out a place where you&#x27;re likely to win.<p>I think often this happens more or less by accident rather than conscious design - but think of something like PHP which made it really easy to whip up quick web pages, or Rails which drive Ruby adoption for a better, more structured, but still dynamic and quick web programming experience.<p>And I suppose part of those happy accidents are people just hacking on something they think is cool, so I wouldn&#x27;t stress too much about the &quot;marketing aspect&quot;. I&#x27;m just curious what drove it.</div><br/><div id="40521434" class="c"><input type="checkbox" id="c-40521434" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40515236">parent</a><span>|</span><a href="#40515595">next</a><span>|</span><label class="collapse" for="c-40521434">[-]</label><label class="expand" for="c-40521434">[1 more]</label></div><br/><div class="children"><div class="content">I have always considered helping the community grow into a diverse ecosystem to be my main responsibility (the Python community being a great example here).<p>This particular effort started because some people got together and realized that we could do it! Do it in a way that felt part of Elixir and not just a bunch of bindings to C libraries.<p>We honestly never had the expectation that we had to beat Python (otherwise we would simply not have started). Early on, we were not even sure if we could be better at one single thing. However, 3 years later, we do have features that would be quite hard or impossible to implement in Python. For example:<p>* Nx Serving - <a href="https:&#x2F;&#x2F;hexdocs.pm&#x2F;nx&#x2F;Nx.Serving.html" rel="nofollow">https:&#x2F;&#x2F;hexdocs.pm&#x2F;nx&#x2F;Nx.Serving.html</a> - allows you to serve machine learning models, across nodes and GPUs, with concurrency, batching, and partitioning, and it has zero dependencies<p>* Livebook - <a href="https:&#x2F;&#x2F;livebook.dev" rel="nofollow">https:&#x2F;&#x2F;livebook.dev</a> - brings  truly reproducible workflows (hard to achieve in Python due to mutability), smart cells, and other fresh ideas<p>* A more cohesive ecosystem - Nx, Scholar, Explorer, etc all play together, zero-copy and all, because they are the only players in town<p>Of course, there are also things that Python can do, that we cannot. The most obvious ones being:<p>* In Python, integration with C code is easier, and that matters a lot in this space. Python also allows C to call Python, and that&#x27;s just not possible in the Erlang VM<p>* Huge ecosystem, everything happens in Python first<p>At the end of the day, what drives me is that the Erlang VM offers a unique set of features, and combining them with different problems have historically lead to interesting and elegant solutions. Which drives more people to join, experiment, run in production, and create new things.</div><br/></div></div><div id="40515595" class="c"><input type="checkbox" id="c-40515595" checked=""/><div class="controls bullet"><span class="by">jolux</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40515236">parent</a><span>|</span><a href="#40521434">prev</a><span>|</span><a href="#40516664">next</a><span>|</span><label class="collapse" for="c-40515595">[-]</label><label class="expand" for="c-40515595">[2 more]</label></div><br/><div class="children"><div class="content">My guess is that Jose and the core team are both personally interested in the big wave of ML stuff we&#x27;ve been experiencing recently and also want to demonstrate that Elixir is a viable platform for doing this work to teams which have adopted Elixir and are interested in ML but don&#x27;t want to add a bunch of Python into their codebase.</div><br/><div id="40515894" class="c"><input type="checkbox" id="c-40515894" checked=""/><div class="controls bullet"><span class="by">barrell</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40515595">parent</a><span>|</span><a href="#40516664">next</a><span>|</span><label class="collapse" for="c-40515894">[-]</label><label class="expand" for="c-40515894">[1 more]</label></div><br/><div class="children"><div class="content">I would also guess that Elixir led to some crazy things they didn’t even imagine possible with web, like phoenixs live view [1]. Even if they don’t have explicit ideas of how it will impact ML, it’ll be really interesting to try.<p>[1]: <a href="https:&#x2F;&#x2F;phoenixframework.org&#x2F;blog&#x2F;phoenix-liveview-1.0-released" rel="nofollow">https:&#x2F;&#x2F;phoenixframework.org&#x2F;blog&#x2F;phoenix-liveview-1.0-relea...</a></div><br/></div></div></div></div></div></div><div id="40516664" class="c"><input type="checkbox" id="c-40516664" checked=""/><div class="controls bullet"><span class="by">bhaney</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40514902">parent</a><span>|</span><a href="#40515236">prev</a><span>|</span><a href="#40516785">next</a><span>|</span><label class="collapse" for="c-40516664">[-]</label><label class="expand" for="c-40516664">[3 more]</label></div><br/><div class="children"><div class="content">&gt; a few years back the language creator announced that the language is basically &quot;completed&quot;<p>And then began adding an entire static type system to the language</div><br/><div id="40521262" class="c"><input type="checkbox" id="c-40521262" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40516664">parent</a><span>|</span><a href="#40517549">next</a><span>|</span><label class="collapse" for="c-40521262">[-]</label><label class="expand" for="c-40521262">[1 more]</label></div><br/><div class="children"><div class="content">Correct. When I did the presentation, I did mention we attempted to type Elixir and failed. Therefore, the idea of saying the language was &quot;complete&quot; was precisely to signal the community that most of the work would happen in the ecosystem and not by directly changing the language. Especially because:<p>* The language was designed to extensible - see how Numerical Elixir can compile Elixir to the GPU and it didn&#x27;t require changes to the language (we improved the language based on some needs but it was never a blocker)<p>* A lot of the hard work that makes Elixir better every year is actually happening on the Erlang VM, which we mostly get to leverage by doing nothing (for example, Elixir &quot;got&quot; a JIT since I said we were complete and we had to change nothing)<p>I&#x27;d say the definition of &quot;completed&quot; still holds, because we haven&#x27;t announced changes to the language yet, but if the work on the type system succeeds, then we will introduce a new typing annotation, which is definitely big enough to void the label after 7-8 years.</div><br/></div></div><div id="40517549" class="c"><input type="checkbox" id="c-40517549" checked=""/><div class="controls bullet"><span class="by">elbasti</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40516664">parent</a><span>|</span><a href="#40521262">prev</a><span>|</span><a href="#40516785">next</a><span>|</span><label class="collapse" for="c-40517549">[-]</label><label class="expand" for="c-40517549">[1 more]</label></div><br/><div class="children"><div class="content">Strictly optional and without changing the language API, fwiw. So about as smooth&#x2F;painless an experience as possible.<p>Its addition into the next minor verision (1.17) will bring warnings that address some of the most common footguns in the language, like comparing structs.</div><br/></div></div></div></div></div></div><div id="40516785" class="c"><input type="checkbox" id="c-40516785" checked=""/><div class="controls bullet"><span class="by">regulation_d</span><span>|</span><a href="#40514674">parent</a><span>|</span><a href="#40514902">prev</a><span>|</span><a href="#40517356">next</a><span>|</span><label class="collapse" for="c-40516785">[-]</label><label class="expand" for="c-40516785">[1 more]</label></div><br/><div class="children"><div class="content">We use Elixir for our primary application, with a fair amount of Python code to manage our ML pipelines. But we also need real-time inference and it&#x27;s really convenient&#x2F;performant to be able to just do that in-app. So I, for one, am very grateful for the work that&#x27;s been done provide the level of tooling in Elixir. It has worked quite well for us.</div><br/></div></div><div id="40517356" class="c"><input type="checkbox" id="c-40517356" checked=""/><div class="controls bullet"><span class="by">TJSomething</span><span>|</span><a href="#40514674">parent</a><span>|</span><a href="#40516785">prev</a><span>|</span><a href="#40515447">next</a><span>|</span><label class="collapse" for="c-40517356">[-]</label><label class="expand" for="c-40517356">[2 more]</label></div><br/><div class="children"><div class="content">I feel like a big audience would be people moving away from Spark.</div><br/><div id="40518040" class="c"><input type="checkbox" id="c-40518040" checked=""/><div class="controls bullet"><span class="by">vvpan</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40517356">parent</a><span>|</span><a href="#40515447">next</a><span>|</span><label class="collapse" for="c-40518040">[-]</label><label class="expand" for="c-40518040">[1 more]</label></div><br/><div class="children"><div class="content">Can you provide a little more context, I am curious.</div><br/></div></div></div></div><div id="40515447" class="c"><input type="checkbox" id="c-40515447" checked=""/><div class="controls bullet"><span class="by">dpflan</span><span>|</span><a href="#40514674">parent</a><span>|</span><a href="#40517356">prev</a><span>|</span><a href="#40514785">next</a><span>|</span><label class="collapse" for="c-40515447">[-]</label><label class="expand" for="c-40515447">[1 more]</label></div><br/><div class="children"><div class="content">Jose may show up here and answer your questions... <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;user?id=josevalim">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;user?id=josevalim</a></div><br/></div></div><div id="40514785" class="c"><input type="checkbox" id="c-40514785" checked=""/><div class="controls bullet"><span class="by">jsiva</span><span>|</span><a href="#40514674">parent</a><span>|</span><a href="#40515447">prev</a><span>|</span><a href="#40517059">next</a><span>|</span><label class="collapse" for="c-40514785">[-]</label><label class="expand" for="c-40514785">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t say I know much about AI stuff or BEAM. But my best guess is that elixir native ML should integrate well with OTP&#x27;s distributed computing capabilities. As an outsider to the elixir ecosystem, I&#x27;ve seen glimpses of elixir ML here and there but no mention of attempting to bridge the python ML ecosystem into elixir.</div><br/></div></div><div id="40517059" class="c"><input type="checkbox" id="c-40517059" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40514674">parent</a><span>|</span><a href="#40514785">prev</a><span>|</span><a href="#40514171">next</a><span>|</span><label class="collapse" for="c-40517059">[-]</label><label class="expand" for="c-40517059">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very serious. The BEAM had a problem in that it lacked solid number-crunching libraries, so some folks solved that, and when they did distributed ML-capabilities kind of just fell out as a neat bonus so some folks did that too.<p>So now it&#x27;s integrated into the basic Livebook, just boot it and go to that example and you have a transcriber or whatever as boilerplate to play around with. Want something else from Huggingface? Just switch out a couple of strings referencing that model and all the rest is sorted for you, except if the tokenizer or whatever doesn&#x27;t follow a particular format but in that case you just upload it to some free web service and make a PR with the result and reference that version hash specifically and it&#x27;ll work.<p>Python is awful for sharding, concurrency, distribution, that kind of thing. With the BEAM you can trivially cluster with an instance on a dedicated GPU-outfitted machine that runs the LLM models or what have you and there you have named processes that control process pools for running queries and they&#x27;ll be immediately available to any BEAM that clusters with it. Fine, you&#x27;ll do some VPN or something that requires a bit of experience with networking, but compared to building a robust, distributed system in Python it&#x27;s easy mode.<p>I don&#x27;t know what the goals are, but I perceive the Nx&#x2F;Bumblebee&#x2F;BEAM platform as obviously better than Python for building production systems. There might be advantages to Python when creating and training models, I&#x27;m not sure, but if you already have the models and need to serve more than one, and want the latency to be low so the characteristically slow response feels a little faster, and don&#x27;t already have a big Kubernetes system for running many Python applications in a distributed manner, then this is for you and it&#x27;ll be better than good enough until you&#x27;ve created a rather large success.</div><br/><div id="40517320" class="c"><input type="checkbox" id="c-40517320" checked=""/><div class="controls bullet"><span class="by">ricketycricket</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40517059">parent</a><span>|</span><a href="#40514171">next</a><span>|</span><label class="collapse" for="c-40517320">[-]</label><label class="expand" for="c-40517320">[2 more]</label></div><br/><div class="children"><div class="content">&gt; except if the tokenizer or whatever doesn&#x27;t follow a particular format but in that case you just upload it to some free web service and make a PR with the result and reference that version hash specifically and it&#x27;ll work.<p>May I ask to which service you are referring?</div><br/><div id="40520426" class="c"><input type="checkbox" id="c-40520426" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40514674">root</a><span>|</span><a href="#40517320">parent</a><span>|</span><a href="#40514171">next</a><span>|</span><label class="collapse" for="c-40520426">[-]</label><label class="expand" for="c-40520426">[1 more]</label></div><br/><div class="children"><div class="content">This one: <a href="https:&#x2F;&#x2F;jonatanklosko-bumblebee-tools.hf.space&#x2F;apps&#x2F;tokenizer-generator" rel="nofollow">https:&#x2F;&#x2F;jonatanklosko-bumblebee-tools.hf.space&#x2F;apps&#x2F;tokenize...</a><p>It&#x27;s linked in the Bumblebee README. Seems broken at the moment, maybe the PR it made is more informative: <a href="https:&#x2F;&#x2F;huggingface.co&#x2F;Neprox&#x2F;STT-Swedish-Whisper&#x2F;discussions&#x2F;3" rel="nofollow">https:&#x2F;&#x2F;huggingface.co&#x2F;Neprox&#x2F;STT-Swedish-Whisper&#x2F;discussion...</a></div><br/></div></div></div></div></div></div></div></div><div id="40514171" class="c"><input type="checkbox" id="c-40514171" checked=""/><div class="controls bullet"><span class="by">bnchrch</span><span>|</span><a href="#40514674">prev</a><span>|</span><a href="#40520648">next</a><span>|</span><label class="collapse" for="c-40514171">[-]</label><label class="expand" for="c-40514171">[1 more]</label></div><br/><div class="children"><div class="content">I think Elixir might have the most wonderful community out there.<p>Really cool to see the concerted effort in parallel going into both ML problem space, and into introducing typing.</div><br/></div></div><div id="40516530" class="c"><input type="checkbox" id="c-40516530" checked=""/><div class="controls bullet"><span class="by">melodyogonna</span><span>|</span><a href="#40520648">prev</a><span>|</span><a href="#40517701">next</a><span>|</span><label class="collapse" for="c-40516530">[-]</label><label class="expand" for="c-40516530">[2 more]</label></div><br/><div class="children"><div class="content">MLIR enables so much potential to systems that use it</div><br/><div id="40517624" class="c"><input type="checkbox" id="c-40517624" checked=""/><div class="controls bullet"><span class="by">tonyhb</span><span>|</span><a href="#40516530">parent</a><span>|</span><a href="#40517701">next</a><span>|</span><label class="collapse" for="c-40517624">[-]</label><label class="expand" for="c-40517624">[1 more]</label></div><br/><div class="children"><div class="content">MLIR is cool and has an exciting future for sure.</div><br/></div></div></div></div><div id="40517701" class="c"><input type="checkbox" id="c-40517701" checked=""/><div class="controls bullet"><span class="by">dpflan</span><span>|</span><a href="#40516530">prev</a><span>|</span><a href="#40520780">next</a><span>|</span><label class="collapse" for="c-40517701">[-]</label><label class="expand" for="c-40517701">[2 more]</label></div><br/><div class="children"><div class="content">To the author, I noticed a typo: a misspelling of &quot;meachine&quot; instead of &quot;machine&quot;<p>&quot;&quot;&quot;
These features bring Numerical Elixir and its ability to setup distributed model serving, over CPUs and GPUs, to traditional meachine learning algorithms, allowing developers and data practitioners to tackle a wider number of problems within the Elixir ecosystem.
&quot;&quot;&quot;</div><br/><div id="40521197" class="c"><input type="checkbox" id="c-40521197" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#40517701">parent</a><span>|</span><a href="#40520780">next</a><span>|</span><label class="collapse" for="c-40521197">[-]</label><label class="expand" for="c-40521197">[1 more]</label></div><br/><div class="children"><div class="content">Thank you.</div><br/></div></div></div></div><div id="40520780" class="c"><input type="checkbox" id="c-40520780" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#40517701">prev</a><span>|</span><a href="#40516946">next</a><span>|</span><label class="collapse" for="c-40520780">[-]</label><label class="expand" for="c-40520780">[1 more]</label></div><br/><div class="children"><div class="content">And with Elixir&#x27;s gradual type system [1] coming soon, this is looking to be quite an eventful year for José and Team.  Bravo!<p>[1] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2306.06391" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2306.06391</a></div><br/></div></div><div id="40516946" class="c"><input type="checkbox" id="c-40516946" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#40520780">prev</a><span>|</span><a href="#40514950">next</a><span>|</span><label class="collapse" for="c-40516946">[-]</label><label class="expand" for="c-40516946">[8 more]</label></div><br/><div class="children"><div class="content">My experience with Elixir onboarding was meh. Spent hours trying to setup the LSP in VSCode and Neovim. Their pseudo-official LSP (elixir-ls) didn&#x27;t work at all. I even made a post about it on Reddit, Github, and here. No one really knew what was going on.<p>Even with Haskell you have something like ghcup and you&#x27;re good to go. Not to mention Rust&#x27;s amazing Cargo and Go&#x27;s tooling as well.<p>So far, Elixir has been even more challenging to just get up and running than Common Lisp!<p>By the way, the official Elixir website recommends using Homebrew to install it. But almost everyone in the Github issues and comments says ASDF is the way to go.</div><br/><div id="40517184" class="c"><input type="checkbox" id="c-40517184" checked=""/><div class="controls bullet"><span class="by">clessg</span><span>|</span><a href="#40516946">parent</a><span>|</span><a href="#40517163">next</a><span>|</span><label class="collapse" for="c-40517184">[-]</label><label class="expand" for="c-40517184">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, the LSP situation remains a sore point, which is deeply unfortunate. One of the big reasons I like Gleam! Luckily, there are new contenders popping up to hopefully solve the issues with elixir-ls: try <a href="https:&#x2F;&#x2F;github.com&#x2F;elixir-tools&#x2F;next-ls">https:&#x2F;&#x2F;github.com&#x2F;elixir-tools&#x2F;next-ls</a> or <a href="https:&#x2F;&#x2F;github.com&#x2F;lexical-lsp&#x2F;lexical">https:&#x2F;&#x2F;github.com&#x2F;lexical-lsp&#x2F;lexical</a>. They might give a better experience. In fact, the creator of Elixir recently started directly sponsoring next-ls, so it&#x27;s probably a safe enough bet.<p>&gt; By the way, the official Elixir website recommends using Homebrew to install it. But almost everyone in the Github issues and comments says ASDF is the way to go.<p>The Elixir website is right. Just use Homebrew until you find a real need for asdf or similar tools. It&#x27;s far simpler.<p>asdf (or mise[0]) is merely a way to manage different runtime versions between various projects, you would use it the same way as one might use rbenv&#x2F;rvm, nvm&#x2F;n, pyenv, or even Docker&#x2F;nix, and so on. You don&#x27;t need it until you have several ongoing projects requiring different runtime versions. If you reach that point, great! It&#x27;ll be worth the effort then, and it isn&#x27;t difficult.<p>Personally, I just use Homebrew Elixir for easy ad-hoc access to iex&#x2F;livebook. If I truly need reproducible environments, devbox[1] (a sort of nix wrapper) is nice and extremely straightforward.<p>Tl;dr: Just use Homebrew. If your requirements expand beyond that, you probably have far more challenging problems than installing asdf (or whatever).<p>[0] <a href="https:&#x2F;&#x2F;mise.jdx.dev&#x2F;dev-tools&#x2F;comparison-to-asdf.html" rel="nofollow">https:&#x2F;&#x2F;mise.jdx.dev&#x2F;dev-tools&#x2F;comparison-to-asdf.html</a><p>[1] <a href="https:&#x2F;&#x2F;www.jetify.com&#x2F;devbox" rel="nofollow">https:&#x2F;&#x2F;www.jetify.com&#x2F;devbox</a></div><br/><div id="40517353" class="c"><input type="checkbox" id="c-40517353" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#40516946">root</a><span>|</span><a href="#40517184">parent</a><span>|</span><a href="#40517163">next</a><span>|</span><label class="collapse" for="c-40517353">[-]</label><label class="expand" for="c-40517353">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! I just checked out devbox, it&#x27;s so great to have a more user-friendly nix for people like me who don&#x27;t want to mess with nix!<p>Also, great point about Gleam! What I like about it, other than types and JS compilation, is exactly the tooling! The devs clearly understood that tooling is extremely important these days and have focused on that. If it&#x27;s truly inter-operable with Elixir&#x2F;Erlang libs, I&#x27;ll probably just use Gleam instead.</div><br/></div></div></div></div><div id="40517163" class="c"><input type="checkbox" id="c-40517163" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40516946">parent</a><span>|</span><a href="#40517184">prev</a><span>|</span><a href="#40514950">next</a><span>|</span><label class="collapse" for="c-40517163">[-]</label><label class="expand" for="c-40517163">[5 more]</label></div><br/><div class="children"><div class="content">ASDF is easy to use once you&#x27;ve learned a few of the basic commands, and that way you&#x27;ll have an easy time when new versions come out and want to check out new features. Like the built-in JSON parser, the gradual typing when it drops, things like that.<p>If you built something useful you might not want to upgrade it just to look at the new stuff, and if you built nothing and just drop into iex a couple of times per year it&#x27;ll still be easier to pull in the latest BEAM and Elixir versions and play around than figuring out if Homebrew has the new version, and if so, whether it installs nicely over the old or not.<p>I don&#x27;t think I&#x27;ve got the LSP running, might check tomorrow. It&#x27;s OK, the IDE autocompletes some things and for me development basically happens in the REPL and then gets pasted into tests and the project anyway. And iex has good autocomplete and help functions and so on.<p>Edit: A hurdle might be to install the GUI libraries needed for Observer, but you&#x27;ll probably be able to search out an incantation for your operating system once you&#x27;re into doing stuff with process trees.</div><br/><div id="40517384" class="c"><input type="checkbox" id="c-40517384" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#40516946">root</a><span>|</span><a href="#40517163">parent</a><span>|</span><a href="#40514950">next</a><span>|</span><label class="collapse" for="c-40517384">[-]</label><label class="expand" for="c-40517384">[4 more]</label></div><br/><div class="children"><div class="content">I think the Python dev style I adopted can&#x27;t  be easily ported to Elixir. In Python, I rely heavily on an LSP because I want to fiddle with a lot of functions&#x2F;classes located deeply in libraries. In VSCode, I simply press CMD and click on any function (or in Neovim, I `gf` or `gd` it). I thought it&#x27;d make even more sense in Elixir because apparently everything is a module. Am I missing something? How do you use iex efficiently?</div><br/><div id="40517439" class="c"><input type="checkbox" id="c-40517439" checked=""/><div class="controls bullet"><span class="by">ricketycricket</span><span>|</span><a href="#40516946">root</a><span>|</span><a href="#40517384">parent</a><span>|</span><a href="#40519542">next</a><span>|</span><label class="collapse" for="c-40517439">[-]</label><label class="expand" for="c-40517439">[2 more]</label></div><br/><div class="children"><div class="content">Sorry you are having so many issues. That has not been my experience with elixir-ls either locally or in Codespaces. Just want to say that when you do get it working, it does indeed have that and many more features. If you are interested, the Elixir slack is very active and helpful and there is a #language-server channel.</div><br/><div id="40517742" class="c"><input type="checkbox" id="c-40517742" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#40516946">root</a><span>|</span><a href="#40517439">parent</a><span>|</span><a href="#40519542">next</a><span>|</span><label class="collapse" for="c-40517742">[-]</label><label class="expand" for="c-40517742">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! It seems the Elixir LSP does provide useful features... I&#x27;m worried  that even after getting it working on my Mac, the same troubles happen again when I move to remote machines. I&#x27;ll try the Elixir slack!</div><br/></div></div></div></div><div id="40519542" class="c"><input type="checkbox" id="c-40519542" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#40516946">root</a><span>|</span><a href="#40517384">parent</a><span>|</span><a href="#40517439">prev</a><span>|</span><a href="#40514950">next</a><span>|</span><label class="collapse" for="c-40519542">[-]</label><label class="expand" for="c-40519542">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not missing anything. It <i>should</i> be a better experience, it just isn&#x27;t yet.  Sorry.  I hope development on the possibilities accelerates!</div><br/></div></div></div></div></div></div></div></div><div id="40514950" class="c"><input type="checkbox" id="c-40514950" checked=""/><div class="controls bullet"><span class="by">bluevlahblah</span><span>|</span><a href="#40516946">prev</a><span>|</span><label class="collapse" for="c-40514950">[-]</label><label class="expand" for="c-40514950">[15 more]</label></div><br/><div class="children"><div class="content">People have to realise these are mostly for hobby. It is really hard to get these working with other libraries.<p>Take explorer, it’s a mess trying to implement dplyr verbs in elixir. Anyone trying to use it is going to hit its limitations sooner or later. I tried migrating to it from polars but it is too frustrating.. gave up after some time.<p>Why will people use half baked libraries instead of python ? I will stick to Keres&#x2F;pytorch, polars, etc</div><br/><div id="40520943" class="c"><input type="checkbox" id="c-40520943" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#40514950">parent</a><span>|</span><a href="#40515194">next</a><span>|</span><label class="collapse" for="c-40520943">[-]</label><label class="expand" for="c-40520943">[1 more]</label></div><br/><div class="children"><div class="content">&gt; People have to realise these are mostly for hobby. It is really hard to get these working with other libraries.<p>I have been dealing with this type of feedback for almost 20 years at this point: &quot;This library doesn&#x27;t work for my needs, so the conclusion is that it is hobby&#x2F;not useful&#x2F;etc for everyone&quot;. In your experience, we are not there yet (and we may never be), but the generalization does not hold.<p>Take Explorer, it was the first library of the bunch to be used in production because it was created by Chris Grainger to write data pipelines at his company. And the blog post does include the link to a talk on production usage.<p>Other projects, like Nx, started as an experiment, but nowadays it is used in production quite a bit and we spend a lot of the time refining it based on feedback we receive.<p>No one is claiming those libraries are complete. It is still pre-1.0. But we claim to be evolving and improving based on feedback. So if anyone wants to try something different than Python, and you can afford to engage, give feedback to maintainers, and even contribute, then you will hopefully have a good time and be closer to running it in production too.</div><br/></div></div><div id="40515194" class="c"><input type="checkbox" id="c-40515194" checked=""/><div class="controls bullet"><span class="by">barrell</span><span>|</span><a href="#40514950">parent</a><span>|</span><a href="#40520943">prev</a><span>|</span><a href="#40519181">next</a><span>|</span><label class="collapse" for="c-40515194">[-]</label><label class="expand" for="c-40515194">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been considering using elixir for a while. With these libraries, it’s now entirely feasible to move my backend over to elixir, getting rid of 95% of my python code in the process. The tasks leftover that still need python can easily each fit in their own &lt;100 line file and work just as well using other languages to process the data. Most of it needs to be run on a gpu anyways so it’s already sandboxed wrt deployments<p>It’s not an all or nothing game, and I rue the day that I decided to do everything in python just because I needed a couple LoC to call a python module.</div><br/></div></div><div id="40519181" class="c"><input type="checkbox" id="c-40519181" checked=""/><div class="controls bullet"><span class="by">seanmor5</span><span>|</span><a href="#40514950">parent</a><span>|</span><a href="#40515194">prev</a><span>|</span><a href="#40514971">next</a><span>|</span><label class="collapse" for="c-40519181">[-]</label><label class="expand" for="c-40519181">[2 more]</label></div><br/><div class="children"><div class="content">To be fair to the creators of “half baked” libraries, you’re comparing our work to frameworks with several years head start with the backing of trillion dollar organizations (excluding polars). To have convinced ANYBODY to successfully make the switch is, to me, both somewhat of a miracle and an indication that there is a legitimate market for this work. I think it also dispels the hobby claim<p>As for your issues with Explorer, perhaps it is not the library, but your knowledge of Elixir that was a little too half baked? ;)</div><br/><div id="40520187" class="c"><input type="checkbox" id="c-40520187" checked=""/><div class="controls bullet"><span class="by">elicksaur</span><span>|</span><a href="#40514950">root</a><span>|</span><a href="#40519181">parent</a><span>|</span><a href="#40514971">next</a><span>|</span><label class="collapse" for="c-40520187">[-]</label><label class="expand" for="c-40520187">[1 more]</label></div><br/><div class="children"><div class="content">Telling someone they’re ignorant probably doesn’t get them to use your tech. Not the person you’re replying to; I use elixir everyday at work.<p>The biggest barrier to adoption of these libraries I can see is that there is not a wealth of resources to solve the actual problem the person is experiencing.<p>Googling “dyplr verbs in python” there’s a towards data science post that’s the 6th result. It has step by step code examples to get you started with what I guess the person is looking for.<p>Googling “dyplr verbs in elixir”, you get the explorer library’s GitHub page and docs as results. I see there’s an example on the first page, but docs present as a high barrier to entry. For better or worse, hand-holding helps get people using the thing, and there’s a SEO-fueled ton of python hand-holding resources out there.<p>I’m sure you’re aware of these things as the author of the book mentioned, but buying a book is a step for someone who’s already sold on learning the language&#x2F;framework. Having google-able content is much more useful to get people in the door and in the day-to-day work looking something up.<p>Until something “cool” and well-known is made with Nx&#x2F;Axon and friends, they’re gonna be seen as second-class to most people who aren’t elixir diehards. Somehow everyone in elixir-land recs these, but never has anything they actually use them for.<p>There’s also the switching cost. Most Python ML compute is actually done in C&#x2F;off-loaded to gpu, so its speed is ok and not greatly constrained by the language choice. Python does have multiprocessing stuff which, while annoying in my experience, makes parallelizing stuff possible. Again, thinking from an outsider’s perspective, there doesn’t seem to be a “must have” reason to use elixir when they’ve already been working in python.</div><br/></div></div></div></div><div id="40514971" class="c"><input type="checkbox" id="c-40514971" checked=""/><div class="controls bullet"><span class="by">victorbjorklund</span><span>|</span><a href="#40514950">parent</a><span>|</span><a href="#40519181">prev</a><span>|</span><a href="#40514996">next</a><span>|</span><label class="collapse" for="c-40514971">[-]</label><label class="expand" for="c-40514971">[4 more]</label></div><br/><div class="children"><div class="content">At this point is isnt trying to convert a happy python user like you. Rather to give tools to teams whose app is already in Elixir and the devs knows Elixir. Instead of bringing in Python to the mix you can use Elixir</div><br/><div id="40520239" class="c"><input type="checkbox" id="c-40520239" checked=""/><div class="controls bullet"><span class="by">elicksaur</span><span>|</span><a href="#40514950">root</a><span>|</span><a href="#40514971">parent</a><span>|</span><a href="#40514996">next</a><span>|</span><label class="collapse" for="c-40520239">[-]</label><label class="expand" for="c-40520239">[3 more]</label></div><br/><div class="children"><div class="content">Elixir dev you are describing and we use Python for ML stuff because it’s easier to work with the more documented frameworks. These libraries just aren’t “there” yet, and I think it’s important to be honest about that. I’ve tried extending&#x2F;converting to them, and it just wasn’t worth it yet.</div><br/><div id="40521132" class="c"><input type="checkbox" id="c-40521132" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#40514950">root</a><span>|</span><a href="#40520239">parent</a><span>|</span><a href="#40521174">next</a><span>|</span><label class="collapse" for="c-40521132">[-]</label><label class="expand" for="c-40521132">[1 more]</label></div><br/><div class="children"><div class="content">&gt; These libraries just aren’t “there” yet, and I think it’s important to be honest about that.<p>Exactly. These projects are still during early adoption stage.<p>While it is production-ready and many are doing so, getting there requires improving documentation, discussing roadmaps with maintainers about a feature you may need (perhaps even contributing it), giving presentations (at your company or at events), and so forth. This can be exciting to some, but a distraction for others. There is certainly plenty of work ahead.</div><br/></div></div></div></div></div></div><div id="40514996" class="c"><input type="checkbox" id="c-40514996" checked=""/><div class="controls bullet"><span class="by">ch4s3</span><span>|</span><a href="#40514950">parent</a><span>|</span><a href="#40514971">prev</a><span>|</span><a href="#40515521">next</a><span>|</span><label class="collapse" for="c-40514996">[-]</label><label class="expand" for="c-40514996">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think a lot of people are using these in production yet, but you can&#x27;t become fully baked without spending some time being half baked.<p>Sometimes though it&#x27;s nice to have most of your stuff in one language.</div><br/></div></div><div id="40515521" class="c"><input type="checkbox" id="c-40515521" checked=""/><div class="controls bullet"><span class="by">jolux</span><span>|</span><a href="#40514950">parent</a><span>|</span><a href="#40514996">prev</a><span>|</span><a href="#40518098">next</a><span>|</span><label class="collapse" for="c-40515521">[-]</label><label class="expand" for="c-40515521">[1 more]</label></div><br/><div class="children"><div class="content">Explorer is still pre-1.0.</div><br/></div></div><div id="40518098" class="c"><input type="checkbox" id="c-40518098" checked=""/><div class="controls bullet"><span class="by">vvpan</span><span>|</span><a href="#40514950">parent</a><span>|</span><a href="#40515521">prev</a><span>|</span><label class="collapse" for="c-40518098">[-]</label><label class="expand" for="c-40518098">[4 more]</label></div><br/><div class="children"><div class="content">I think most of the replies to your post suggest that you are correct, even though the downvotes are unfortunate.</div><br/><div id="40519569" class="c"><input type="checkbox" id="c-40519569" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#40514950">root</a><span>|</span><a href="#40518098">parent</a><span>|</span><a href="#40518986">next</a><span>|</span><label class="collapse" for="c-40519569">[-]</label><label class="expand" for="c-40519569">[1 more]</label></div><br/><div class="children"><div class="content">The downvotes are for the attitude.  If you expected all alternative software options to be strictly better than their replacements we would never get anywhere in terms of DX.  Someone has to be brave and be an early adopted and put in the sweat to get shit to work and this guy is just taking potshots instead of making pull requests.</div><br/></div></div><div id="40518986" class="c"><input type="checkbox" id="c-40518986" checked=""/><div class="controls bullet"><span class="by">prophesi</span><span>|</span><a href="#40514950">root</a><span>|</span><a href="#40518098">parent</a><span>|</span><a href="#40519569">prev</a><span>|</span><a href="#40519269">next</a><span>|</span><label class="collapse" for="c-40518986">[-]</label><label class="expand" for="c-40518986">[1 more]</label></div><br/><div class="children"><div class="content">If you suggest what they&#x27;re correct in and how the replies support your theory, I think the downvotes would be rectified and everyone involved would leave with a better understanding of the topic.</div><br/></div></div><div id="40519269" class="c"><input type="checkbox" id="c-40519269" checked=""/><div class="controls bullet"><span class="by">bluevlahblah</span><span>|</span><a href="#40514950">root</a><span>|</span><a href="#40518098">parent</a><span>|</span><a href="#40518986">prev</a><span>|</span><label class="collapse" for="c-40519269">[-]</label><label class="expand" for="c-40519269">[1 more]</label></div><br/><div class="children"><div class="content">That’s ok, truth is bitter. People may fall for hype sometimes. Maintainers of the project can refute what I am saying but they won’t as this the truth.<p>- In current explorer one cannot  write user defined functions,  plugins. 
- They don’t even have it in roadmap. 
- Also the exposed functionality is always lagging when compared to polars.<p>- elixir, nx, explorer,distributed, etc nice keywords - reality is it is still early for them. Better to stay away for production apps in case of ai&#x2F;ml unless people  are connecting to OpenAI and writing chat apps for which they won’t need any of the above except elixir.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>