<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726045273281" as="style"/><link rel="stylesheet" href="styles.css?v=1726045273281"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.16elt.com/2024/09/07/future-proof-code/">On over-engineering; finding the right balance</a> <span class="domain">(<a href="https://www.16elt.com">www.16elt.com</a>)</span></div><div class="subtext"><span>BerislavLopac</span> | <span>18 comments</span></div><br/><div><div id="41509444" class="c"><input type="checkbox" id="c-41509444" checked=""/><div class="controls bullet"><span class="by">djtango</span><span>|</span><a href="#41508912">next</a><span>|</span><label class="collapse" for="c-41509444">[-]</label><label class="expand" for="c-41509444">[1 more]</label></div><br/><div class="children"><div class="content">For the Vehicle example the conclusion wasn&#x27;t that the Vehicle abstraction was premature, it was to prefer Composition and Interfaces over Inheritance which is a well discussed idea around OO design.<p>The Vehicle example is relatable to day to day work but for me the Vehicle abstraction seems reasonable. The mistake is not that a Bike is or isn&#x27;t a vehicle but rather that the abstractions should align with the business usage: a bicycle doesn&#x27;t share much in common with a car, the company just wants to rent them out.<p>So most the stuff that they will share in common will be around the sales&#x2F;rental part of the business logic. You wouldn&#x27;t expect them to really be displayed together anywhere either. So I wouldn&#x27;t be trying to force a Bike into a Vehicle, I&#x27;d be looking for the seams related to the truly common operations on Bikes vs Cars and look to extract interfaces or extend polymorphism there</div><br/></div></div><div id="41508912" class="c"><input type="checkbox" id="c-41508912" checked=""/><div class="controls bullet"><span class="by">cbanek</span><span>|</span><a href="#41509444">prev</a><span>|</span><a href="#41509021">next</a><span>|</span><label class="collapse" for="c-41508912">[-]</label><label class="expand" for="c-41508912">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never been bitten by an interface that is too simple.
I&#x27;ve never had a bug in code that I didn&#x27;t need to write.<p>Don&#x27;t try to solve future problems.  You&#x27;ll have the problem that the problem you solved isn&#x27;t the problem that needs solving, and then the problem that needs solving.<p>If anything, overly simplistic solutions sometimes make me feel like I&#x27;m repeating myself, but really since the code is so easy it always feels possible to refactor it.  That&#x27;s a good place to be, much better than afraid to change something because it&#x27;s too generic to know if you&#x27;ll break something.<p>Everyone has an opinion on an interface that is easy to understand, and not over-engineered (bikeshedding).</div><br/><div id="41509119" class="c"><input type="checkbox" id="c-41509119" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#41508912">parent</a><span>|</span><a href="#41509250">next</a><span>|</span><label class="collapse" for="c-41509119">[-]</label><label class="expand" for="c-41509119">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve definitely been bitten by <i>designs</i> that were too simple in critical areas. Interfaces can always be added to and code can always be deduplicated later. But an accretion of kludges around an insufficient set of core functionality is absolutely worse than having a little extra functionality that you end up deleting later.<p>Don&#x27;t try to solve <i>speculative</i> future problems. But if you are pretty sure you&#x27;re going to need something in the future, you should probably take it into consideration in your design.</div><br/><div id="41509471" class="c"><input type="checkbox" id="c-41509471" checked=""/><div class="controls bullet"><span class="by">djtango</span><span>|</span><a href="#41508912">root</a><span>|</span><a href="#41509119">parent</a><span>|</span><a href="#41509209">next</a><span>|</span><label class="collapse" for="c-41509471">[-]</label><label class="expand" for="c-41509471">[1 more]</label></div><br/><div class="children"><div class="content">Yes, during a rewrite of a product I had a (new) team member scream YAGNI at me with supercilious delight when I pointed out all functions needed to account for the full primary key of (id, territory) rather than just (id) because we will definitely be needing it imminently although the current build only worked with data for one territory.<p>We then had to spend a long time cleaning up the mess when lo and behold, we needed to add more territories to the dataset.<p>I think we&#x27;ve swung too far in the wrong direction when it comes to &quot;premature abstraction&quot; and yagni.<p>The only acceptable reason I&#x27;ve seen for writing bad code is &quot;we might not be here tomorrow&quot; but that is literally only valid for extremely young startups and even then those decisions could ripple and indirectly kill the company in the future when they&#x27;re no longer able to pay off the tech debt in time</div><br/></div></div><div id="41509209" class="c"><input type="checkbox" id="c-41509209" checked=""/><div class="controls bullet"><span class="by">cbanek</span><span>|</span><a href="#41508912">root</a><span>|</span><a href="#41509119">parent</a><span>|</span><a href="#41509471">prev</a><span>|</span><a href="#41509250">next</a><span>|</span><label class="collapse" for="c-41509209">[-]</label><label class="expand" for="c-41509209">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But an accretion of kludges around an insufficient set of core functionality is absolutely worse than having a little extra functionality that you end up deleting later.<p>I agree that an accretion of kludges is bad.  The problem here comes down to usually the skill of the programmer when the new work comes up.  To people who don&#x27;t understand the code, they are more likely to make what they think is a simple kludge than actually refactor to solve the problem &quot;correctly&quot;, which usually involves more thought and creativity.<p>Whereas extra functionality usually increases the code surface area, and once published as a public interface to a library, is very costly and painful to delete.  Then it festers as complications to new code that is added have to assume this extra functionality is used rather than not.</div><br/></div></div></div></div><div id="41509250" class="c"><input type="checkbox" id="c-41509250" checked=""/><div class="controls bullet"><span class="by">gwervc</span><span>|</span><a href="#41508912">parent</a><span>|</span><a href="#41509119">prev</a><span>|</span><a href="#41509021">next</a><span>|</span><label class="collapse" for="c-41509250">[-]</label><label class="expand" for="c-41509250">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If anything, overly simplistic solutions sometimes make me feel like I&#x27;m repeating myself, but really since the code is so easy it always feels possible to refactor it.<p>This is way underrated. I&#x27;ve been on a project that was in one hand quite over-engineered, quick and dirty on the other hand. The thing is tech leads insisted on factoring absolutely everything. So you had a component (not compliant with solid&#x27;s O) that dealt with 2 cases, needed two more cases added. And this is where it all breaks. I wish we could have dumbly copy pasted the thing two more times instead of having to deal with the weird and unforcasted interactions.</div><br/></div></div></div></div><div id="41509021" class="c"><input type="checkbox" id="c-41509021" checked=""/><div class="controls bullet"><span class="by">bjornsing</span><span>|</span><a href="#41508912">prev</a><span>|</span><a href="#41509240">next</a><span>|</span><label class="collapse" for="c-41509021">[-]</label><label class="expand" for="c-41509021">[1 more]</label></div><br/><div class="children"><div class="content">The right balance will look very different in different parts of a system. In general the lower levels of a system need to be more generic, and higher levels more specific. One often overlooked guiding principle is that when you’re building large systems it’s important to be able to “finish” some parts of the system and be “done” with them, otherwise your mental “context window” will just grow forever until not even the brightest among us can make any progress.</div><br/></div></div><div id="41509240" class="c"><input type="checkbox" id="c-41509240" checked=""/><div class="controls bullet"><span class="by">bubblebeard</span><span>|</span><a href="#41509021">prev</a><span>|</span><a href="#41509421">next</a><span>|</span><label class="collapse" for="c-41509240">[-]</label><label class="expand" for="c-41509240">[1 more]</label></div><br/><div class="children"><div class="content">I constantly try to improve how I write my code. The last couple of years I’ve been involved in a couple of projects that’s required rebuilding a few times over because the project managers kept changing directions and was always in a hurry.<p>For one project I eventually managed to convince them to let our team write a more general purpose library to conserve time in the future. And this has paid itself of several times over.<p>When we write code it’s important we do consider how it may be utilised in the future. Since we cannot make exact predictions it’s better to make methods as small as possible instead to reduce the amount of time spent on refactoring (since this is unavoidable). This also helps us to create solid, more future proof, tests for our business logic.<p>You don’t need to follow a strict set of design rules, but general guidelines is a good idea. Like trying to follow SRP, avoiding more than x nubmer of lines for your method bodies and trying to avoid nestled code.</div><br/></div></div><div id="41509421" class="c"><input type="checkbox" id="c-41509421" checked=""/><div class="controls bullet"><span class="by">qnleigh</span><span>|</span><a href="#41509240">prev</a><span>|</span><a href="#41509241">next</a><span>|</span><label class="collapse" for="c-41509421">[-]</label><label class="expand" for="c-41509421">[1 more]</label></div><br/><div class="children"><div class="content">I wish there were a big list of example situations like these to pour over. One could write a whole book on this topic (maybe someone already has). I spend so much time thinking about design decisions like these, but rarely get to hear someone else&#x27;s thought process.</div><br/></div></div><div id="41509241" class="c"><input type="checkbox" id="c-41509241" checked=""/><div class="controls bullet"><span class="by">vrnvu</span><span>|</span><a href="#41509421">prev</a><span>|</span><a href="#41509144">next</a><span>|</span><label class="collapse" for="c-41509241">[-]</label><label class="expand" for="c-41509241">[1 more]</label></div><br/><div class="children"><div class="content">Why does introducing interfaces and vtables have to be the right abstraction? Given the example, the simplest solution is best. If you don’t need runtime semantics, just write simple code.<p>The Cons of a &quot;simple&quot; solution:
&gt; As you add features, the class becomes more cluttered.
But if it&#x27;s a feature, it shouldn&#x27;t be considered clutter. Clutter usually comes from over-engineering, not necessary additions.<p>&gt; Each method does one specific thing. That seems fine until you realize your interface is full of shallow, one-off methods. That makes it hard to maintain and extend.
However, each method is efficient and tailored to solve a specific feature, which boosts performance. Plus, if there&#x27;s a bug, it&#x27;s easy to find and fix since each method has a clear path.<p>Also, to maintain a clear designed API, I suggest following some data-oriented recommendations, like designing functions to take lists of elements instead of single elements.</div><br/></div></div><div id="41509144" class="c"><input type="checkbox" id="c-41509144" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#41509241">prev</a><span>|</span><a href="#41509193">next</a><span>|</span><label class="collapse" for="c-41509144">[-]</label><label class="expand" for="c-41509144">[1 more]</label></div><br/><div class="children"><div class="content">&gt; public void RemoveItems(Func&lt;Item, bool&gt; condition)<p>Tangential, but remember that you can&#x27;t generally push this condition over a database connection. You&#x27;ve just forced your code to be best-case O(n).<p>Using structured queries as far as possible is useful for performance. But consider what happens if you create a Predicate structure, and someone adds a field without updating the Remove function to match... Perhaps a recursive discriminated union is the way to go, for languages that fail compilation when not all branches are covered? Positional arguments in other languages?</div><br/></div></div><div id="41509193" class="c"><input type="checkbox" id="c-41509193" checked=""/><div class="controls bullet"><span class="by">tlonny</span><span>|</span><a href="#41509144">prev</a><span>|</span><a href="#41509085">next</a><span>|</span><label class="collapse" for="c-41509193">[-]</label><label class="expand" for="c-41509193">[1 more]</label></div><br/><div class="children"><div class="content">Re: the shopping cart example<p>&gt; This approach is good for now. But, it will limit you later. Your code will quickly get out of control.<p>Will it? If we need to be able to “delete via X”, it sure feels more maintainable to have this feature supported via an explicit, named method vs. inlining it as an anonymous closure (as recommended by the “balanced” solution).</div><br/></div></div><div id="41509085" class="c"><input type="checkbox" id="c-41509085" checked=""/><div class="controls bullet"><span class="by">imron</span><span>|</span><a href="#41509193">prev</a><span>|</span><a href="#41509167">next</a><span>|</span><label class="collapse" for="c-41509085">[-]</label><label class="expand" for="c-41509085">[1 more]</label></div><br/><div class="children"><div class="content">My favorite article on this topic is “semantic compression” [0] by Casey Muratori.<p>0: <a href="https:&#x2F;&#x2F;caseymuratori.com&#x2F;blog_0015" rel="nofollow">https:&#x2F;&#x2F;caseymuratori.com&#x2F;blog_0015</a></div><br/></div></div><div id="41509167" class="c"><input type="checkbox" id="c-41509167" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#41509085">prev</a><span>|</span><a href="#41509132">next</a><span>|</span><label class="collapse" for="c-41509167">[-]</label><label class="expand" for="c-41509167">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s simple: understand what the goals of your team are for the current year. Write the code with supporting those goals in mind.</div><br/><div id="41509235" class="c"><input type="checkbox" id="c-41509235" checked=""/><div class="controls bullet"><span class="by">cbanek</span><span>|</span><a href="#41509167">parent</a><span>|</span><a href="#41509132">next</a><span>|</span><label class="collapse" for="c-41509235">[-]</label><label class="expand" for="c-41509235">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting you call out a year as a time span.  I have no idea what the goals will be in a year, let alone how I&#x27;ll code it.  A year seems like a really long time, but also just short enough to justify adding extra work in early.  My timeframe is more like a week to a month.  Obviously different orgs will have different time windows for real reasons.</div><br/><div id="41509363" class="c"><input type="checkbox" id="c-41509363" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#41509167">root</a><span>|</span><a href="#41509235">parent</a><span>|</span><a href="#41509132">next</a><span>|</span><label class="collapse" for="c-41509363">[-]</label><label class="expand" for="c-41509363">[1 more]</label></div><br/><div class="children"><div class="content">Most companies have a revenue goal for the current year. From that revenue goal you can infer what software capabilities need to be obtained.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>