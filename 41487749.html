<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726045273281" as="style"/><link rel="stylesheet" href="styles.css?v=1726045273281"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gabevenberg.com/posts/cli-renaissance/">The Modern CLI Renaissance</a> <span class="domain">(<a href="https://gabevenberg.com">gabevenberg.com</a>)</span></div><div class="subtext"><span>theshrike79</span> | <span>62 comments</span></div><br/><div><div id="41509478" class="c"><input type="checkbox" id="c-41509478" checked=""/><div class="controls bullet"><span class="by">yonisto</span><span>|</span><a href="#41508679">next</a><span>|</span><label class="collapse" for="c-41509478">[-]</label><label class="expand" for="c-41509478">[1 more]</label></div><br/><div class="children"><div class="content">In my case I found it 20x times easier to hack a CLI tool that I can easily move around the organization that has mixture of Windows, Macs and Linux. Installation is just .zst file away.</div><br/></div></div><div id="41508679" class="c"><input type="checkbox" id="c-41508679" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#41509478">prev</a><span>|</span><a href="#41508120">next</a><span>|</span><label class="collapse" for="c-41508679">[-]</label><label class="expand" for="c-41508679">[22 more]</label></div><br/><div class="children"><div class="content">To summarize: The people who ruined native GUIs moved to HTML pages. After ruining HTML pages they are now moving to terminals.<p>In this very thread we&#x27;re seeing people say &quot;Well sure, but why not add ...&quot;.<p>The reason why the CLI is good is because it _can&#x27;t_ do most things people want it to do. Which means you have to think when making an application.<p>Please, if you&#x27;re one of the people &#x27;modernizing&#x27; the terminal stop and think why the terminal is valuable. Don&#x27;t make it into another of the long line of UIs which have been destroyed by modern developers.</div><br/><div id="41509226" class="c"><input type="checkbox" id="c-41509226" checked=""/><div class="controls bullet"><span class="by">tazu</span><span>|</span><a href="#41508679">parent</a><span>|</span><a href="#41509306">next</a><span>|</span><label class="collapse" for="c-41509226">[-]</label><label class="expand" for="c-41509226">[1 more]</label></div><br/><div class="children"><div class="content">This is why Textualize[1] concerns me. I&#x27;ve tried a few of the applications using their framework, and they have <i>noticable keypress latency</i>. I didn&#x27;t think it was possible to make a bloated TUI, but they have somehow succeeded. This might just be a Python thing because of the GIL, because VisiData[2] has the same problem. It&#x27;s physically jarring to use VisiData because it&#x27;s such a cool idea, but takes 500ms to register key presses in my 120hz terminal emulator.<p>It&#x27;s reminiscent of scroll-jacking, excessive animation, and other web GUI bloat, just translated to TUIs.<p>[1]: <a href="https:&#x2F;&#x2F;www.textualize.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.textualize.io&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;www.visidata.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.visidata.org&#x2F;</a></div><br/></div></div><div id="41509306" class="c"><input type="checkbox" id="c-41509306" checked=""/><div class="controls bullet"><span class="by">contrarian1234</span><span>|</span><a href="#41508679">parent</a><span>|</span><a href="#41509226">prev</a><span>|</span><a href="#41508937">next</a><span>|</span><label class="collapse" for="c-41509306">[-]</label><label class="expand" for="c-41509306">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a general issue of developers with tricked out machines and fast internet connections developing software for everyone else. The reason the CLI is fast is not because it was carefully engineered that way, but because most of the software was developed when computers were slower than the chip you&#x27;d find in a washing-machine these days<p>example: flatpak. Last I tried - tab-outcompleting to install a package makes a network request for the application list. This ofcourse means you don&#x27;t have to maintain a cache like `apt` and certainly makes things easier. I&#x27;m sure this makes sense if you&#x27;re on your macbook pro in a cafe in Cupertino. But it was nearly unusable (whole CLI locks up and hangs) from my Core m3 computer tethered to a shitty network in a 2nd tier city in China.</div><br/></div></div><div id="41508937" class="c"><input type="checkbox" id="c-41508937" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41508679">parent</a><span>|</span><a href="#41509306">prev</a><span>|</span><a href="#41509413">next</a><span>|</span><label class="collapse" for="c-41508937">[-]</label><label class="expand" for="c-41508937">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The reason why the CLI is good is because it _can&#x27;t_ do most things people want it to do.<p>-1. You’ve lost me here. 
The reason why CLI is good because it solves problems that even modern GUIs can’t, not because of some artificial limitations or lack of convenient defaults.<p>&gt; Which means you have to think when making an application.<p>“Think” and “remember obscure syntax that greyheads keep on a paper under their mattress” are two different things. I agree with the author that sensible defaults are severely lacking from some of the tools.</div><br/><div id="41509111" class="c"><input type="checkbox" id="c-41509111" checked=""/><div class="controls bullet"><span class="by">ulbu</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41508937">parent</a><span>|</span><a href="#41509403">next</a><span>|</span><label class="collapse" for="c-41509111">[-]</label><label class="expand" for="c-41509111">[1 more]</label></div><br/><div class="children"><div class="content">one great property of the terminal is that it’s not a continuous canvas. it’s a grid of discrete cells, just as it is natural for computers to be. instead of laying interactive objects out in virtual space, you’re pushed to think in discrete states and discrete actions. so I say cli is, indeed, good in part due of its limitations.<p>edit: i’ll add that continuousness of guis is actually its limitation. a terminal interface is indexable, a gui is not. so what looks like freedom is actually a different structure. a gui is more general, as real numbers are more general than whole numbers. but to get to whole numbers, you have to re-constrain real numbers. this is left up to the developer to create a constraining framework. and it’s a path of less resistance to not do this. 
most data we deal with is discrete. so a continuous representation of it is a mismatch of structures. terminals force you to stay in that same discrete space. so your solutions are from the getgo closer in fit to your data.<p>it’s important to match up the structure of your interactive surface with the structure of your domain. it’s a common principle we talk about too little.</div><br/></div></div><div id="41509403" class="c"><input type="checkbox" id="c-41509403" checked=""/><div class="controls bullet"><span class="by">oulipo</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41508937">parent</a><span>|</span><a href="#41509111">prev</a><span>|</span><a href="#41509292">next</a><span>|</span><label class="collapse" for="c-41509403">[-]</label><label class="expand" for="c-41509403">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, they conflate the fact that the CLI tool is just a &quot;programmable API view&quot; of an app, and that GUI is more of a &quot;interaction view&quot;, with the fact that it can or cannot do some stuff<p>Now with AI and better design, nothing in theory would prevent us to &quot;script UI apps&quot; like we do with terminal, you could say<p>&quot;take a screenshot of my webpage with Chrome | set it in isometric with nice shadow using Photoshop | send it on my iPhone Twitter app&quot;<p>and you would get the same pipeline<p>of course &quot;UI apps&quot; just have too many input &#x2F; output possibilities, and you wouldn&#x27;t want to have &quot;--flags&quot; everywhere for every possibility<p>But that&#x27;s where &quot;natural language as a universal API&quot; applies, or perhaps just a better design for interaction with UI apps</div><br/></div></div><div id="41509426" class="c"><input type="checkbox" id="c-41509426" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41508937">parent</a><span>|</span><a href="#41509292">prev</a><span>|</span><a href="#41509413">next</a><span>|</span><label class="collapse" for="c-41509426">[-]</label><label class="expand" for="c-41509426">[1 more]</label></div><br/><div class="children"><div class="content">Yes they can, since Xerox PARC and Genera, it is called a REPL and scripting.</div><br/></div></div></div></div><div id="41509413" class="c"><input type="checkbox" id="c-41509413" checked=""/><div class="controls bullet"><span class="by">oulipo</span><span>|</span><a href="#41508679">parent</a><span>|</span><a href="#41508937">prev</a><span>|</span><a href="#41508820">next</a><span>|</span><label class="collapse" for="c-41509413">[-]</label><label class="expand" for="c-41509413">[2 more]</label></div><br/><div class="children"><div class="content">You conflate the fact that the CLI tool is just a &quot;programmable API view&quot; of an app, and that GUI is more of a &quot;interaction view&quot;, with the fact that it can or cannot do some stuff
Now with AI and better design, nothing in theory would prevent us to &quot;script UI apps&quot; like we do with terminal, you could say<p>&quot;take a screenshot of my webpage with Chrome | set it in isometric with nice shadow using Photoshop | send it on my iPhone Twitter app&quot;<p>and you would get the same pipeline<p>of course &quot;UI apps&quot; just have too many input &#x2F; output possibilities, and you wouldn&#x27;t want to have &quot;--flags&quot; everywhere for every possibility<p>But that&#x27;s where &quot;natural language as a universal API&quot; applies, or perhaps just a better design for interaction with UI apps</div><br/><div id="41509431" class="c"><input type="checkbox" id="c-41509431" checked=""/><div class="controls bullet"><span class="by">oulipo</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41509413">parent</a><span>|</span><a href="#41508820">next</a><span>|</span><label class="collapse" for="c-41509431">[-]</label><label class="expand" for="c-41509431">[1 more]</label></div><br/><div class="children"><div class="content">in theory, if computers were really &quot;smart&quot; (and I&#x27;m not talking about AI, but just better design), you could define that pipeline and it would JIT-build an optimized binary that does the equivalent of your pipeline for each app, so that it would still be an optimized process<p>Eg. each &quot;UI app&quot; would just become a big API of all input&#x2F;output possibilities, and &quot;interactive mouse &#x2F; keyboard &#x2F; visual interaction&quot; would just be one possibility among others<p>Your computer would know how to pipe between each app, optimize it if possible, and give you what you want</div><br/></div></div></div></div><div id="41508820" class="c"><input type="checkbox" id="c-41508820" checked=""/><div class="controls bullet"><span class="by">kvark</span><span>|</span><a href="#41508679">parent</a><span>|</span><a href="#41509413">prev</a><span>|</span><a href="#41509418">next</a><span>|</span><label class="collapse" for="c-41508820">[-]</label><label class="expand" for="c-41508820">[1 more]</label></div><br/><div class="children"><div class="content">Having a standard CLI is definitely helpful. But does it have to be so hard to use? At what point would we acknowledge that we are being hostage by some random ideas put into ancient software, which just happened to survive?<p>I don&#x27;t think calling for a stop of experimentation is the way. Nobody is going to take away your vi and bash any time soon.</div><br/></div></div><div id="41509418" class="c"><input type="checkbox" id="c-41509418" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41508679">parent</a><span>|</span><a href="#41508820">prev</a><span>|</span><a href="#41509470">next</a><span>|</span><label class="collapse" for="c-41509418">[-]</label><label class="expand" for="c-41509418">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much so, I really don&#x27;t get those rainbow terminals full of fluff running after each command.<p>Then to top that, we had TUIs up to the mid-1990&#x27;s because we couldn&#x27;t afford anything else, it was the best many of us could have, given the bugdet and the astronomical cost of anything with a graphics display attached to the computer.<p>I really don&#x27;t get the coolness of reproducing this experience, I was more than happy to move away from this as soon as I could afford to.</div><br/></div></div><div id="41509470" class="c"><input type="checkbox" id="c-41509470" checked=""/><div class="controls bullet"><span class="by">Zababa</span><span>|</span><a href="#41508679">parent</a><span>|</span><a href="#41509418">prev</a><span>|</span><a href="#41509145">next</a><span>|</span><label class="collapse" for="c-41509470">[-]</label><label class="expand" for="c-41509470">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is what the article says, and I don&#x27;t think terminals are getting &quot;ruined&quot;. The trend of TUi is a bit worrying (usually you get a better looking but worse GUI), but the tools are great. fzf is great, fd is great, rg is great. Some TUIs are great too, lazygit and lazydocker being good examples.<p>&gt; The reason why the CLI is good is because it _can&#x27;t_ do most things people want it to do. Which means you have to think when making an application.<p>I don&#x27;t think this is true at all. If I had to say why the CLI is good, I would mention:<p>- speed<p>- composability, as in I can grep for something and then do other operations<p>- ease of development, it&#x27;s very easy to make a small tool for my usage</div><br/></div></div><div id="41509145" class="c"><input type="checkbox" id="c-41509145" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41508679">parent</a><span>|</span><a href="#41509470">prev</a><span>|</span><a href="#41509216">next</a><span>|</span><label class="collapse" for="c-41509145">[-]</label><label class="expand" for="c-41509145">[2 more]</label></div><br/><div class="children"><div class="content">The terminal is valuable just because it has applications that are easy to do or even only possible in it. Specifically, a full-duplex interactivity at a low data rate. I don&#x27;t think any current &quot;modernization&quot; proposals threatened that so far, the biggest contender would be any image support but it isn&#x27;t meant to be used every time anyway.</div><br/><div id="41509210" class="c"><input type="checkbox" id="c-41509210" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41509145">parent</a><span>|</span><a href="#41509216">next</a><span>|</span><label class="collapse" for="c-41509210">[-]</label><label class="expand" for="c-41509210">[1 more]</label></div><br/><div class="children"><div class="content">TBH I would love a pixel framebuffer standard for terminals that&#x27;s fast enough to run things like Doom, emulators, or simple UI applications in the terminal. The Sixels standard exists but has a too complicated pixel encoding.</div><br/></div></div></div></div><div id="41509216" class="c"><input type="checkbox" id="c-41509216" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#41508679">parent</a><span>|</span><a href="#41509145">prev</a><span>|</span><a href="#41508120">next</a><span>|</span><label class="collapse" for="c-41509216">[-]</label><label class="expand" for="c-41509216">[7 more]</label></div><br/><div class="children"><div class="content">As someone who is working on modernizing the command line, I think it is entirely possible to strike a balance.<p>- the command line is just byte streams<p>Shells like Elvish, Nushell, Powershell and my own shell, Murex, support typed pipelines and that brings a great number of enhancements. Like native support for JSON, CSV and other data formats. Thus meaning you can have a unified syntax for handling different files rather than remembering a dozen different tools and their specific idiosyncrasies, eg `jq`, `awk`, etc<p>- readline is dated<p>We can do better than the typical shell interface. The popularity of tools like `fzf` and `starship` show that people do actually find modern TUIs useful<p>- rendered text is static<p>Lets say you view a JSON file in Firefox, you can expand and collapse specific branches of that JSON file. I&#x27;d love to be able to do that with JSON in the terminal. And not just JSON, tools like `tree` could benefit from that too.<p>Collapsible trees is a feature I&#x27;m working on implementing in my terminal emulator and it&#x27;s completely optional. ie by default the tree renders the same way any other terminal would render that clump of text. Except you can then optionally collapse branches just like you can with code in an IDE or comments in HN.<p>---<p>I love the command line. I&#x27;ve been using it for 30+ years and written so many tools for fellow CLI enthusasts. But even I think an ideal world would be us moving away from grid based virtual teletype interfaces pushing communicating via raw bytes and with in-band control codes, and instead switch to something more robust. But that&#x27;s never going to happen. Heck, even things like job control (ie when you hit ^z) is non-trivial to implement at a shell level. It requires multiple signals (each originating from a different sender), and 3 different hierarchies of process ID registration. Frankly, it&#x27;s amazing any of this stuff still works. And that&#x27;s before we touch on the plethora of competing standards to test what client (ie terminal emulator) is connected to that &quot;virtual typewriter&quot;.</div><br/><div id="41509284" class="c"><input type="checkbox" id="c-41509284" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41509216">parent</a><span>|</span><a href="#41509437">next</a><span>|</span><label class="collapse" for="c-41509284">[-]</label><label class="expand" for="c-41509284">[3 more]</label></div><br/><div class="children"><div class="content">But how many of these new tools are robust when there&#x27;s high latency? The advantage of good old POSIX shell is it works on cheap routers, the latest HPC systems, the system next to me and the system of the literal other side of the world, and everything in between.</div><br/><div id="41509325" class="c"><input type="checkbox" id="c-41509325" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41509284">parent</a><span>|</span><a href="#41509437">next</a><span>|</span><label class="collapse" for="c-41509325">[-]</label><label class="expand" for="c-41509325">[2 more]</label></div><br/><div class="children"><div class="content">Being realistic - how often is that a problem?For some people working on specific domains yes. But why are a large number of developers who _dont_ have those restrictions held back by ensuring that your terminal works properly over 9600 baud</div><br/><div id="41509335" class="c"><input type="checkbox" id="c-41509335" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41509325">parent</a><span>|</span><a href="#41509437">next</a><span>|</span><label class="collapse" for="c-41509335">[-]</label><label class="expand" for="c-41509335">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Being realistic - how often is that a problem?<p>I have 800ms RTTs on airplanes. Character-by-character editing is painful. Old-fashioned line-buffering makes the experience much better. It&#x27;d be nice not to give up this capability.</div><br/></div></div></div></div></div></div><div id="41509437" class="c"><input type="checkbox" id="c-41509437" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41509216">parent</a><span>|</span><a href="#41509284">prev</a><span>|</span><a href="#41509489">next</a><span>|</span><label class="collapse" for="c-41509437">[-]</label><label class="expand" for="c-41509437">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Shells like Elvish, Nushell, Powershell and my own shell, Murex......<p>Except nothing of this is really new, this is how REPLs in Xerox PARC worstations, ETHZ and Genera used to work.<p>The novelty of these shells is a side effect of UNIX wiping out the alternatives.</div><br/></div></div><div id="41509489" class="c"><input type="checkbox" id="c-41509489" checked=""/><div class="controls bullet"><span class="by">Zababa</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41509216">parent</a><span>|</span><a href="#41509437">prev</a><span>|</span><a href="#41509359">next</a><span>|</span><label class="collapse" for="c-41509489">[-]</label><label class="expand" for="c-41509489">[1 more]</label></div><br/><div class="children"><div class="content">&gt; rendered text is static<p>The way I see it is that you&#x27;re making it dynamic by entering other commands. This doesn&#x27;t really feel dynamic when you don&#x27;t know what to enter, but the more fluency you achieve, the more dynamic&#x2F;in the flow it feels.</div><br/></div></div><div id="41509359" class="c"><input type="checkbox" id="c-41509359" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#41508679">root</a><span>|</span><a href="#41509216">parent</a><span>|</span><a href="#41509489">prev</a><span>|</span><a href="#41508120">next</a><span>|</span><label class="collapse" for="c-41509359">[-]</label><label class="expand" for="c-41509359">[1 more]</label></div><br/><div class="children"><div class="content">&gt; - readline is dated<p>But at least it was --- pre-GPLv3, pre-prompt_toolkit, etc. --- a standard. It would be nice to again have a single de-facto standard line editing system that I could<p>1) customize <i>once</i>, for all my programs, and<p>2) compose with other programs (e.g. shells embedding in other programs).<p>It&#x27;d also be nice for it to be friendly to high-latency connections.<p>But alas, we&#x27;re heading towards a world in which the terminal is just a GUI with Minecraft pixels.</div><br/></div></div></div></div></div></div><div id="41508120" class="c"><input type="checkbox" id="c-41508120" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41508679">prev</a><span>|</span><a href="#41508058">next</a><span>|</span><label class="collapse" for="c-41508120">[-]</label><label class="expand" for="c-41508120">[4 more]</label></div><br/><div class="children"><div class="content">The stale field of terminals is also getting new developments. My particular favorite is Kitty input protocol that allows terminals to use such 21-st century functionality as accurate key press reporting: <a href="https:&#x2F;&#x2F;sw.kovidgoyal.net&#x2F;kitty&#x2F;keyboard-protocol&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sw.kovidgoyal.net&#x2F;kitty&#x2F;keyboard-protocol&#x2F;</a></div><br/><div id="41508164" class="c"><input type="checkbox" id="c-41508164" checked=""/><div class="controls bullet"><span class="by">sweeter</span><span>|</span><a href="#41508120">parent</a><span>|</span><a href="#41508754">next</a><span>|</span><label class="collapse" for="c-41508164">[-]</label><label class="expand" for="c-41508164">[2 more]</label></div><br/><div class="children"><div class="content">Kitty has done great work in this regard. The Keyboard Protocol and the Image Protocol is top notch. Accurate keys was a much needed change. The image protocol blows sixel and ascii out of the water. The thing that baffles me is that so many people are resistant to these two things because they don&#x27;t like the lead dev.</div><br/><div id="41508951" class="c"><input type="checkbox" id="c-41508951" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#41508120">root</a><span>|</span><a href="#41508164">parent</a><span>|</span><a href="#41508754">next</a><span>|</span><label class="collapse" for="c-41508951">[-]</label><label class="expand" for="c-41508951">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The thing that baffles me is that so many people are resistant to these two things because they don&#x27;t like the lead dev.<p>Who’s the developer of kitty… oh.<p>It’s the guy who said he’ll single-handedly going to keep Python 2 alive?</div><br/></div></div></div></div><div id="41508754" class="c"><input type="checkbox" id="c-41508754" checked=""/><div class="controls bullet"><span class="by">goodpoint</span><span>|</span><a href="#41508120">parent</a><span>|</span><a href="#41508164">prev</a><span>|</span><a href="#41508058">next</a><span>|</span><label class="collapse" for="c-41508754">[-]</label><label class="expand" for="c-41508754">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;security&quot; practices of kitty are dubious: <a href="https:&#x2F;&#x2F;github.com&#x2F;kovidgoyal&#x2F;kitty&#x2F;pull&#x2F;3544">https:&#x2F;&#x2F;github.com&#x2F;kovidgoyal&#x2F;kitty&#x2F;pull&#x2F;3544</a></div><br/></div></div></div></div><div id="41508058" class="c"><input type="checkbox" id="c-41508058" checked=""/><div class="controls bullet"><span class="by">terminaltrove</span><span>|</span><a href="#41508120">prev</a><span>|</span><a href="#41508835">next</a><span>|</span><label class="collapse" for="c-41508058">[-]</label><label class="expand" for="c-41508058">[3 more]</label></div><br/><div class="children"><div class="content">Excellent article of what is going on in the terminal space, agree on the TUI section where we are seeing lots of terminal tools being built in Rust and Go and libraries such as Ratatui [1] and Bubble Tea [2] becoming new modern alternatives to ncurses for building TUIs.<p>Python has Textualize which is also very popular for building terminal user interfaces [3]<p>And we&#x27;ve noticed this renaissance as well of new CLI and TUI tools that we list on Terminal Trove [4].<p>[1] <a href="https:&#x2F;&#x2F;ratatui.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ratatui.rs&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;charmbracelet&#x2F;bubbletea">https:&#x2F;&#x2F;github.com&#x2F;charmbracelet&#x2F;bubbletea</a><p>[3] <a href="https:&#x2F;&#x2F;textual.textualize.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;textual.textualize.io&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;terminaltrove.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;terminaltrove.com&#x2F;</a></div><br/><div id="41508674" class="c"><input type="checkbox" id="c-41508674" checked=""/><div class="controls bullet"><span class="by">euroderf</span><span>|</span><a href="#41508058">parent</a><span>|</span><a href="#41509243">next</a><span>|</span><label class="collapse" for="c-41508674">[-]</label><label class="expand" for="c-41508674">[1 more]</label></div><br/><div class="children"><div class="content">Ratatui is a great name. The landing page needs a rat!</div><br/></div></div><div id="41509243" class="c"><input type="checkbox" id="c-41509243" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#41508058">parent</a><span>|</span><a href="#41508674">prev</a><span>|</span><a href="#41508835">next</a><span>|</span><label class="collapse" for="c-41509243">[-]</label><label class="expand" for="c-41509243">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been disappointing me lately that we&#x27;ve all given up on terminfo --- or at least forgotten what it was for. Most of these new libraries just hardcode escape sequences. It&#x27;d be more future-proof and customizable for users to consult a terminal database like programs used to do, yes? Maybe it doesn&#x27;t matter: the world has mostly converged on xterm-based control sequences. But what about newer capabilities? Without either a central terminfo database or some kind of standard way to query feature availability, we end up with an explosion of ad-hoc and opaque logic.</div><br/></div></div></div></div><div id="41508835" class="c"><input type="checkbox" id="c-41508835" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#41508058">prev</a><span>|</span><a href="#41508172">next</a><span>|</span><label class="collapse" for="c-41508835">[-]</label><label class="expand" for="c-41508835">[2 more]</label></div><br/><div class="children"><div class="content">One interesting idea, in the Platform Engineering space (inside companies), is using TUIs to take advantage of credentials that may already be available on the developer&#x27;s laptop. If you serve an internal app as a webapp, then you either need for the webapp to have a service user (icky audit logs) or waste lots of time setting up OAuth-style login flows so the webapp can authenticate as the user (and maybe IT doesn&#x27;t like the idea anyway). Or, you write something that runs on the dev&#x27;s laptop, and make use of the credentials that are already available locally, easy-peasy. Auth is simple, use the audit mechanisms that are already in place, easy.</div><br/><div id="41509341" class="c"><input type="checkbox" id="c-41509341" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41508835">parent</a><span>|</span><a href="#41508172">next</a><span>|</span><label class="collapse" for="c-41509341">[-]</label><label class="expand" for="c-41509341">[1 more]</label></div><br/><div class="children"><div class="content">&gt; waste lots of time setting up OAuth-style login flows so the webapp can authenticate as the user<p>Being real - if you can’t manage an oauth library in 2024, you probably shouldn’t be deploying these kinds of apps, it’s about 30 lines of code in go, JavaScript or c# , and they’re just the languages I’ve implemented it in.</div><br/></div></div></div></div><div id="41508172" class="c"><input type="checkbox" id="c-41508172" checked=""/><div class="controls bullet"><span class="by">JimDabell</span><span>|</span><a href="#41508835">prev</a><span>|</span><a href="#41508780">next</a><span>|</span><label class="collapse" for="c-41508172">[-]</label><label class="expand" for="c-41508172">[13 more]</label></div><br/><div class="children"><div class="content">I would be very happy to see shells shed the idea that everything needs to be done in the context of emulating a terminal from the 70s. But even though new shells exist, I always end up writing shell scripts in ancient Bourne because I want them to run out of the box instead of requiring a third-party shell to be installed. Is there no appetite for a new default shell that could be adopted by Linux, macOS, and BSDs?</div><br/><div id="41509475" class="c"><input type="checkbox" id="c-41509475" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#41508172">parent</a><span>|</span><a href="#41508890">next</a><span>|</span><label class="collapse" for="c-41509475">[-]</label><label class="expand" for="c-41509475">[1 more]</label></div><br/><div class="children"><div class="content">Switching away from being bash compatible would be really unexpected. Too many existing scripts and websites explaining how to do things. Maybe something like <a href="http:&#x2F;&#x2F;www.oilshell.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.oilshell.org&#x2F;</a> has a chance though?<p>If we were breaking away from the old style shells completely, then <a href="https:&#x2F;&#x2F;www.nushell.sh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.nushell.sh&#x2F;</a> would be my preferred upgrade.</div><br/></div></div><div id="41508890" class="c"><input type="checkbox" id="c-41508890" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#41508172">parent</a><span>|</span><a href="#41509475">prev</a><span>|</span><a href="#41509312">next</a><span>|</span><label class="collapse" for="c-41508890">[-]</label><label class="expand" for="c-41508890">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I would be very happy to see shells shed the idea that everything needs to be done in the context of emulating a terminal from the 70s.<p>In Emacs, there is a big difference between M-x vterm (which emulates a 70s terminal), M-x shell (which <i>doesn’t</i> emulate a terminal, but still runs e.g. bash underneath), and M-x eshell (which replaces bash etc. completely, and thus offers  abstractions like “cd into an ssh: path”, “cp this file from an ssh: path”, “pipe this file through an Emacs function”, etc. that you normally don’t expect). If you’re into alternative ways of working with shells this might be interesting.<p>(With that said, I myself went back to a “real” terminal. These days I’m using Zsh in iTerm2.)</div><br/></div></div><div id="41509312" class="c"><input type="checkbox" id="c-41509312" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#41508172">parent</a><span>|</span><a href="#41508890">prev</a><span>|</span><a href="#41508323">next</a><span>|</span><label class="collapse" for="c-41509312">[-]</label><label class="expand" for="c-41509312">[1 more]</label></div><br/><div class="children"><div class="content">Over what timeframe do you expect this to happen? It&#x27;ll take at least 10 years for a new default on all systems (which is a challenge in of itself) to propagate to the point where you could rely on it.<p>There&#x27;s also the question of what new language is worth the cost of the transition period (no new shell I&#x27;ve seen justifies the change).</div><br/></div></div><div id="41508323" class="c"><input type="checkbox" id="c-41508323" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#41508172">parent</a><span>|</span><a href="#41509312">prev</a><span>|</span><a href="#41508533">next</a><span>|</span><label class="collapse" for="c-41508323">[-]</label><label class="expand" for="c-41508323">[2 more]</label></div><br/><div class="children"><div class="content">You could be the first! Fork Ubuntu, leave everything else the same, but have it run `fish` as the default shell with `bash` as a fallback.<p>Alternatively, you could install default Ubuntu and run <a href="https:&#x2F;&#x2F;github.com&#x2F;hiAndrewQuinn&#x2F;shell-bling-ubuntu">https:&#x2F;&#x2F;github.com&#x2F;hiAndrewQuinn&#x2F;shell-bling-ubuntu</a> to switch your terminal to fish, kitty, and get a whole slew of other niceties in there by default. I found myself doing this a lot at my last job in VMs, which is why I have this set of shell scripts lying around and easy to audit.</div><br/><div id="41508745" class="c"><input type="checkbox" id="c-41508745" checked=""/><div class="controls bullet"><span class="by">dotancohen</span><span>|</span><a href="#41508172">root</a><span>|</span><a href="#41508323">parent</a><span>|</span><a href="#41508533">next</a><span>|</span><label class="collapse" for="c-41508745">[-]</label><label class="expand" for="c-41508745">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve really modernized the CLI there. I&#x27;ve been resisting doing that because I SSH into other machines often enough, but with your script I might just start. Thank you, nice work!<p>As another big rg and tree (and ncdu, do you know of this) user, I highly suggest rotating one monitor 90 degrees. These tools with long output really benefit, as does web browsing, coding, and even the ability to see an entire page of a PDF without scrolling or making it tiny.</div><br/></div></div></div></div><div id="41508533" class="c"><input type="checkbox" id="c-41508533" checked=""/><div class="controls bullet"><span class="by">sakjur</span><span>|</span><a href="#41508172">parent</a><span>|</span><a href="#41508323">prev</a><span>|</span><a href="#41508874">next</a><span>|</span><label class="collapse" for="c-41508533">[-]</label><label class="expand" for="c-41508533">[3 more]</label></div><br/><div class="children"><div class="content">Having been recently exposed to PowerShell, I’m quite impressed by the balance they’ve struck in developing a new shell. I wouldn’t want to switch out Bash for PowerShell, but that’s mostly based on the same reasoning as you have (I can’t be bothered to install new shells everywhere).<p>Though in a sense I think the most viable solution would be almost the opposite for UNIX: a reduced (and strict) shell syntax intended to be the target of crosscompilation rather than manual use. If it’d be possible to make that a subset of the standardized sh, there’d be automatic compatibility from the start and adoption wouldn’t need to happen on the consumer side.<p>Still, we have binaries already. Binaries are much more capable than what I’m suggesting, though they are platform dependent. A variant of WASM, maybe?</div><br/><div id="41509200" class="c"><input type="checkbox" id="c-41509200" checked=""/><div class="controls bullet"><span class="by">Timwi</span><span>|</span><a href="#41508172">root</a><span>|</span><a href="#41508533">parent</a><span>|</span><a href="#41508874">next</a><span>|</span><label class="collapse" for="c-41509200">[-]</label><label class="expand" for="c-41509200">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Binaries are much more capable than what I’m suggesting, though they are platform dependent.<p>Not if they&#x27;re .NET&#x2F;IL&#x2F;CLR (which is an ECMA standard).</div><br/><div id="41509491" class="c"><input type="checkbox" id="c-41509491" checked=""/><div class="controls bullet"><span class="by">sakjur</span><span>|</span><a href="#41508172">root</a><span>|</span><a href="#41509200">parent</a><span>|</span><a href="#41508874">next</a><span>|</span><label class="collapse" for="c-41509491">[-]</label><label class="expand" for="c-41509491">[1 more]</label></div><br/><div class="children"><div class="content">Fair, though that’s still dependent on having a platform that follow that spec, in this case the common denominator for the platforms in question is POSIX rather than CLR.</div><br/></div></div></div></div></div></div><div id="41508874" class="c"><input type="checkbox" id="c-41508874" checked=""/><div class="controls bullet"><span class="by">jrimbault</span><span>|</span><a href="#41508172">parent</a><span>|</span><a href="#41508533">prev</a><span>|</span><a href="#41508645">next</a><span>|</span><label class="collapse" for="c-41508874">[-]</label><label class="expand" for="c-41508874">[1 more]</label></div><br/><div class="children"><div class="content">The Redox project uses their own Ion shell <a href="https:&#x2F;&#x2F;doc.redox-os.org&#x2F;ion-manual&#x2F;" rel="nofollow">https:&#x2F;&#x2F;doc.redox-os.org&#x2F;ion-manual&#x2F;</a> which isn&#x27;t posix</div><br/></div></div><div id="41508645" class="c"><input type="checkbox" id="c-41508645" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41508172">parent</a><span>|</span><a href="#41508874">prev</a><span>|</span><a href="#41508780">next</a><span>|</span><label class="collapse" for="c-41508645">[-]</label><label class="expand" for="c-41508645">[3 more]</label></div><br/><div class="children"><div class="content">IMHO instead of offering a builtin programming language, shells should make it easy to launch scripts written in &#x27;foreign&#x27; languages (maybe via a more informative shebang block at the top). I want to write my &#x27;shell scripts&#x27; in Python, Typescript or Lua and those scripts should work on any shell and on any platform (including Windows outside WSL).</div><br/><div id="41508671" class="c"><input type="checkbox" id="c-41508671" checked=""/><div class="controls bullet"><span class="by">dotancohen</span><span>|</span><a href="#41508172">root</a><span>|</span><a href="#41508645">parent</a><span>|</span><a href="#41508780">next</a><span>|</span><label class="collapse" for="c-41508671">[-]</label><label class="expand" for="c-41508671">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what &#x2F;usr&#x2F;bin&#x2F;env is for: a standard path to reference interpreters.<p>There is still the issue of the proper interpreter actually being installed, however.</div><br/><div id="41509178" class="c"><input type="checkbox" id="c-41509178" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41508172">root</a><span>|</span><a href="#41508671">parent</a><span>|</span><a href="#41508780">next</a><span>|</span><label class="collapse" for="c-41509178">[-]</label><label class="expand" for="c-41509178">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There is still the issue of the proper interpreter actually being installed, however.<p>Yeah, that&#x27;s what I mean with &quot;make it easy&quot;. The script header should announce requirements (like what language and language version it is written in, and the shell should be able to ensure those requirements before running the script - without ignoring security aspects of course). E.g. every script should be able to bootstrap itself, no matter what programming language is used (and that might even include compiled languages).</div><br/></div></div></div></div></div></div></div></div><div id="41508780" class="c"><input type="checkbox" id="c-41508780" checked=""/><div class="controls bullet"><span class="by">bradgessler</span><span>|</span><a href="#41508172">prev</a><span>|</span><a href="#41508011">next</a><span>|</span><label class="collapse" for="c-41508780">[-]</label><label class="expand" for="c-41508780">[2 more]</label></div><br/><div class="children"><div class="content">I’ve been working on <a href="https:&#x2F;&#x2F;terminalwire.com" rel="nofollow">https:&#x2F;&#x2F;terminalwire.com</a> to scratch my own itch making it easier to add command-line interfaces into my own web apps.<p>If I pull this off, building out a CLI that’s as high quality as GitHub &amp; Stripe’s should be trivial since it won’t require building out a web API and it can be dropped into existing web frameworks.<p>It won’t be as fast as a CLI that runs locally, but that’s kinda not the point of terminal apps that primarily interact with web services.<p>I have a private beta for folks working on commercial SaaS products that want to deploy a CLI, but don’t want to deal with building out an API.</div><br/><div id="41508939" class="c"><input type="checkbox" id="c-41508939" checked=""/><div class="controls bullet"><span class="by">edem</span><span>|</span><a href="#41508780">parent</a><span>|</span><a href="#41508011">next</a><span>|</span><label class="collapse" for="c-41508939">[-]</label><label class="expand" for="c-41508939">[1 more]</label></div><br/><div class="children"><div class="content">Why ruby?</div><br/></div></div></div></div><div id="41508011" class="c"><input type="checkbox" id="c-41508011" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#41508780">prev</a><span>|</span><a href="#41507989">next</a><span>|</span><label class="collapse" for="c-41508011">[-]</label><label class="expand" for="c-41508011">[2 more]</label></div><br/><div class="children"><div class="content">As far as I know, TUI is the only way to build a statically linked app that can be controlled with a mouse. If you&#x27;re running in a terminal that supports sixel, that covers a huge class of apps. And you get lots of bonuses like excellent cross platform support and running over a network. It&#x27;s honestly a compelling platform even without the nostalgia factor.</div><br/><div id="41508499" class="c"><input type="checkbox" id="c-41508499" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#41508011">parent</a><span>|</span><a href="#41507989">next</a><span>|</span><label class="collapse" for="c-41508499">[-]</label><label class="expand" for="c-41508499">[1 more]</label></div><br/><div class="children"><div class="content">Interesting... never thought of that angle. Mouse control is pretty important.</div><br/></div></div></div></div><div id="41507989" class="c"><input type="checkbox" id="c-41507989" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#41508011">prev</a><span>|</span><a href="#41508108">next</a><span>|</span><label class="collapse" for="c-41507989">[-]</label><label class="expand" for="c-41507989">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m loving how coreutils is getting improved and with how TUIs are exploding. It&#x27;s just been a breath of fresh air. I hate to reach for my mouse.<p>Side note: in vim you can press K to see the help page for a specific function. The default is the man page but some plugins will fix this though I&#x27;m not aware of one that&#x27;s let me get away from documents and help files completely (I&#x27;d love to pick up docs of the codebase I&#x27;m working on. Anyone know of something that will?)<p>But one thing I want to stress, the defaults of these tools should be the same as the originals as much as possible. This makes them more effective and adoption seamless.<p>To give two examples fd and ripgrep default to respecting your .gitignore file. If you&#x27;re not expecting this you can easily land yourself in trouble. Sure, it&#x27;s in the readme but people are installing through their package managers so it doesn&#x27;t matter. I&#x27;m glad the option exists, but don&#x27;t make it the fucking default! We have aliases for that stuff. It&#x27;s always better to error in the direction of too much output than too little. Output can be parsed and searched, but you can&#x27;t when it&#x27;s not there.<p>Btw, here&#x27;s what pacman says<p><pre><code>  extra&#x2F;fd 10.2.0-1
    Simple, fast and user - friendly alternative to find
  extra&#x2F;ripgrep 14.1.0-1
    A search tool that combines the usability of ag with the raw speed of grep
</code></pre>
So I&#x27;m surprised people are surprised that people think you can just alias find or grep, since they are advertised as such and this is also what&#x27;s said through word of mouth. (Yes, people should open man pages and visit the GitHub, but let&#x27;s be real about our expectations)</div><br/><div id="41508222" class="c"><input type="checkbox" id="c-41508222" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41507989">parent</a><span>|</span><a href="#41508108">next</a><span>|</span><label class="collapse" for="c-41508222">[-]</label><label class="expand" for="c-41508222">[4 more]</label></div><br/><div class="children"><div class="content">I strongly disagree. Neither of those tools claim to be drop-in replacements. They’re more like a reinvention of the older tools given what we’ve learned in the many decades since the originals came out, and tailored for the common use cases today. It’s rare that I want to grep, say, the node_modules directory in a JS project. The default of showing the results that git says are my own code is very useful. And as you say, there are aliases if you want to get off the beaten path.</div><br/><div id="41508569" class="c"><input type="checkbox" id="c-41508569" checked=""/><div class="controls bullet"><span class="by">godelski</span><span>|</span><a href="#41507989">root</a><span>|</span><a href="#41508222">parent</a><span>|</span><a href="#41508108">next</a><span>|</span><label class="collapse" for="c-41508569">[-]</label><label class="expand" for="c-41508569">[3 more]</label></div><br/><div class="children"><div class="content">Disagree all you want, you still shouldn&#x27;t be surprised people aren&#x27;t expecting this<p>fd: <a href="https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;fd&#x2F;issues?q=gitignore+">https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;fd&#x2F;issues?q=gitignore+</a><p>And I stand by it is strictly better for the __default__ to be unfiltered. This is what people expect in general.<p><pre><code>  &gt; tailored for the common use cases today.
</code></pre>
*YOUR* common usecases. Grep, sure, it is rare that I want to grep a binary file. But I do want to grep configs and secrets. I do want to find binaries all the time. There are many different ways to program and expecting everyone to program like you or even remotely like you is naive. There&#x27;s so many things under the sun.<p>Failure analysis is critical when designing anything. So let me rephrase<p><pre><code>  Which do you think is a better mode of failure?
  1) Not finding files you are expecting to find
  2) Finding more files than you expect to find
</code></pre>
Or for ripgrep, grepping fewer files than you expect to vs grepping more files than you expect to.<p>It is very hard to argue for one considering we have regex to filter which files we want... not to mention pipes and all sorts of common tools including the tools themselves.</div><br/><div id="41508843" class="c"><input type="checkbox" id="c-41508843" checked=""/><div class="controls bullet"><span class="by">setopt</span><span>|</span><a href="#41507989">root</a><span>|</span><a href="#41508569">parent</a><span>|</span><a href="#41508108">next</a><span>|</span><label class="collapse" for="c-41508843">[-]</label><label class="expand" for="c-41508843">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps the best of both worlds would just be to write a warning to stderr by default that files in .gitignore have been ignored (only if such a file is applied)?</div><br/><div id="41509239" class="c"><input type="checkbox" id="c-41509239" checked=""/><div class="controls bullet"><span class="by">Timwi</span><span>|</span><a href="#41507989">root</a><span>|</span><a href="#41508843">parent</a><span>|</span><a href="#41508108">next</a><span>|</span><label class="collapse" for="c-41509239">[-]</label><label class="expand" for="c-41509239">[1 more]</label></div><br/><div class="children"><div class="content">Or just have a command-line option to specify an ignore file. That&#x27;s strictly more useful because then you&#x27;re not arbitrarily limited to files named “.gitignore”.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41508108" class="c"><input type="checkbox" id="c-41508108" checked=""/><div class="controls bullet"><span class="by">sandreas</span><span>|</span><a href="#41507989">prev</a><span>|</span><a href="#41509130">next</a><span>|</span><label class="collapse" for="c-41508108">[-]</label><label class="expand" for="c-41508108">[1 more]</label></div><br/><div class="children"><div class="content">Great article, especially the awesome tools collection at the bottom. I&#x27;m barely missing any of my daily drivers:<p><pre><code>  # dra - automatically download release assets from github
  # example: dra download -a &quot;dundee&#x2F;gdu&quot; -I &quot;gdu&quot; --output &quot;$HOME&#x2F;bin&quot;
  devmatteini&#x2F;dra
  
  # gdu - disk usage analyzer similar to ncdu but faster
  dundee&#x2F;gdu
  
  # glow - terminal markdown reader
  charmbracelet&#x2F;glow
  
  # jless - json viewer
  PaulJuliusMartinez&#x2F;jless
  
  # lazydocker - terminal docker management ui
  jesseduffield&#x2F;lazydocker
  
  # lazygit - terminal git management ui
  jesseduffield&#x2F;lazygit
  
  # rga - ripgrep-all, grep for PDF
  phiresky&#x2F;ripgrep-all</code></pre></div><br/></div></div><div id="41509130" class="c"><input type="checkbox" id="c-41509130" checked=""/><div class="controls bullet"><span class="by">surfingdino</span><span>|</span><a href="#41508108">prev</a><span>|</span><a href="#41508850">next</a><span>|</span><label class="collapse" for="c-41509130">[-]</label><label class="expand" for="c-41509130">[1 more]</label></div><br/><div class="children"><div class="content">The reason why cli commands are written in C is the fact that the OS is written in C. There is a lot of inertia, because it is more efficient to have the operating system and the tools for it written in the same language. We may be entering a transitional phase with new tools written, old tools rewritten in Rust. Some of the innovation or simplification highlighted in the article remind me of the chaos of the Unix wars which led to POSIX. I wouldn&#x27;t chuck out the tools we have though. Modernise them, but keep their functionality. What many critics of CLI tools do not realise is that there is a lot of power hiding in that complexity. Familiarise yourself with xargs or parallel commands to see that quite often learning them given you results faster than reimplementing them.</div><br/></div></div><div id="41508850" class="c"><input type="checkbox" id="c-41508850" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41509130">prev</a><span>|</span><a href="#41508589">next</a><span>|</span><label class="collapse" for="c-41508850">[-]</label><label class="expand" for="c-41508850">[1 more]</label></div><br/><div class="children"><div class="content">Meh. If any, for Make, clone this and read the files:<p><pre><code>    git clone git:&#x2F;&#x2F;bitreich.org&#x2F;english_knight
</code></pre>
On the rest, nvi&#x2F;vim and vis (vis is nice to cool with Sam-like extructural regexen) are 
more than enough. Nvi as the uberfast vi clone with Unicode support, and vim for 
Common Lisp with Slimv.<p>On TUI tools, there&#x27;s mc, ncdu... those are useful. A lot of them aren&#x27;t. Finch vs an IRC client
and Bitlbee, for instance, swirc + bitlbee it&#x27;s far more usable, with FInch I always had to do 
voodoo with the panes.</div><br/></div></div><div id="41508589" class="c"><input type="checkbox" id="c-41508589" checked=""/><div class="controls bullet"><span class="by">throwaway984393</span><span>|</span><a href="#41508850">prev</a><span>|</span><label class="collapse" for="c-41508589">[-]</label><label class="expand" for="c-41508589">[4 more]</label></div><br/><div class="children"><div class="content">CLI renaissance, or new dark age? The advent of the Web as the modern application platform of choice destroyed the advancement of graphical user interfaces. We now live in a bizarre world of CLIs when we should be using GUIs.<p>Before the Web, and during its rise, there was a vast array of productivity tools designed to allow users to do more work, faster, and better, through graphical interfaces. It would have been ridiculous to release a program to users with only a command line interface. We left the dark ages of terminals behind, and pushed into new territory, advancing what users could do with computers.<p>But once the Web began to develop the capabilities of browsers further, Web programming began to teach young programmers that the web was the only place that needed a graphical interface, because the web was a &quot;universal&quot; graphical application interface (lol, if you don&#x27;t count the browser wars)<p>This delighted programmers, as they never really liked making graphical interfaces. Logic and functions were more fun to write than user interfaces (which only made the users - not developers - happier).<p>This was then hammered home when Markdown was widely adopted for its simplicity, inspiring a sort of text-based Stockholm-syndrome. People started to claim bizarre things, like that the command line and Markdown were preferable (or even superior) to GUIs and WYSIWYGs in almost all cases. More languages were adopted that had no inherent graphics capabilities, and the devs moved ever further towards text.<p>So the web has unintentionally set back computer science and user productivity by decades. Until browsers lose the spotlight, this will probably continue, and non-web GUIs will continue to be that ugly thing you only write if you <i>have</i> to. Users will continue to languish in these half baked solutions, slaves to the solutions that are presented to them. And devs will continue to create text interfaces that only they enjoy.<p>Rather than rethinking old ideas and creating new ones, we are simply doubling down on the past.</div><br/><div id="41509458" class="c"><input type="checkbox" id="c-41509458" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41508589">parent</a><span>|</span><a href="#41509342">next</a><span>|</span><label class="collapse" for="c-41509458">[-]</label><label class="expand" for="c-41509458">[1 more]</label></div><br/><div class="children"><div class="content">Having been using computers since the mid 1980&#x27;s, new dark age in some sense, yeah.</div><br/></div></div><div id="41509342" class="c"><input type="checkbox" id="c-41509342" checked=""/><div class="controls bullet"><span class="by">bool3max</span><span>|</span><a href="#41508589">parent</a><span>|</span><a href="#41509458">prev</a><span>|</span><a href="#41509268">next</a><span>|</span><label class="collapse" for="c-41509342">[-]</label><label class="expand" for="c-41509342">[1 more]</label></div><br/><div class="children"><div class="content">This was all bound to happen anyway if not due to the &quot;Web&quot; then due to some other platform that would&#x27;ve evolved the same capabilities eventually.</div><br/></div></div><div id="41509268" class="c"><input type="checkbox" id="c-41509268" checked=""/><div class="controls bullet"><span class="by">Timwi</span><span>|</span><a href="#41508589">parent</a><span>|</span><a href="#41509342">prev</a><span>|</span><label class="collapse" for="c-41509268">[-]</label><label class="expand" for="c-41509268">[1 more]</label></div><br/><div class="children"><div class="content">Thank you, this really needed saying. I was wondering if I was the only one who saw it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>