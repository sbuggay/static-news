<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738141265766" as="style"/><link rel="stylesheet" href="styles.css?v=1738141265766"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jimmyhmiller.github.io/discovery-coding">Discovery Coding</a> <span class="domain">(<a href="https://jimmyhmiller.github.io">jimmyhmiller.github.io</a>)</span></div><div class="subtext"><span>surprisetalk</span> | <span>59 comments</span></div><br/><div><div id="42861799" class="c"><input type="checkbox" id="c-42861799" checked=""/><div class="controls bullet"><span class="by">lubujackson</span><span>|</span><a href="#42860577">next</a><span>|</span><label class="collapse" for="c-42861799">[-]</label><label class="expand" for="c-42861799">[2 more]</label></div><br/><div class="children"><div class="content">Someone said on HN a while back that this sort of approach is the most sensible, because any design doc is just an incomplete abstraction until you get in the weeds to see where all the tricky parts are. Programming is literally writing plans for a computer to do a thing, so writing a document about everything you need to write the plan is an exercise in frustration. And if you DO spend a lot of time making a perfect document, you&#x27;ve put in far more work than simply hacking around a bit to explore the problem space. Because only by fully exploring a problem can you confidently estimate how long it will take to write the real code. Often times after the first draft I just need to clean things up a bit or only half complete a bad solution before improving it. Yes, there are times you need to sit and have a think first, but less often than you might imagine.<p>Of course, at a certain scale and team size a tedious document IS the fastest way to do things... but god help you if you work on a shared code base like that.<p>I&#x27;ve always thought the rigid TDD approach and similar anti-coding styles really lend themselves to people that would rather not be programming. Or at least have a touch of the OCD and can&#x27;t stand to not have a unit test for every line of code. Because it really is a lot more work both up front and in maintenance to live that way.<p>Cyber-paper is cheap, so don&#x27;t be afraid to write some extra lines on it.</div><br/><div id="42862375" class="c"><input type="checkbox" id="c-42862375" checked=""/><div class="controls bullet"><span class="by">fhd2</span><span>|</span><a href="#42861799">parent</a><span>|</span><a href="#42860577">next</a><span>|</span><label class="collapse" for="c-42862375">[-]</label><label class="expand" for="c-42862375">[1 more]</label></div><br/><div class="children"><div class="content">TDD is being done in weird ways by lots of people from what I&#x27;ve seen. I always understood the book&#x27;s advice to never write code without a test as both aspirational, and productivity advice, not a hard rule.<p>My first job predated (at least our knowledge of) TDD and unit test frameworks. We would write little programs that would include some of our code and exercise them a bit during development. Later when everything was working and integrated, we&#x27;d throw it away. I believe that used to be called scaffolding (before Rails gave that term a different meaning).<p>When I got into unit testing and some degree of TDD a while later, I kinda kept the same spirit. The unit tests help me build the thing without needing ten steps to test that it works. Sure, I keep the tests, but primarily as documentation on how the parts of the system that are covered should behave. And when it&#x27;s significantly easier to test something manually than to write a unit test, I tend towards that.<p>In languages that have good REPLs, I tend to write fewer tests, cause they function as a universal test scaffold.<p>Trying to reach 100 % test coverage and using unit tests for QA strikes me as strange. They&#x27;re at most useful to quickly detect regressions. But most of these monster test suites become a burden over time from my experience. A pragmatic test suite rarely does. There&#x27;s a lot of potential in having the right balance between unit tests, integration tests and manual testing. There&#x27;s a lot of time wasted if the balance is off.<p>With this mindset, I totally write tests for a prototype if it looks like it&#x27;ll save me time. Not even close to 100 % coverage though.</div><br/></div></div></div></div><div id="42860577" class="c"><input type="checkbox" id="c-42860577" checked=""/><div class="controls bullet"><span class="by">CobrastanJorji</span><span>|</span><a href="#42861799">prev</a><span>|</span><a href="#42861126">next</a><span>|</span><label class="collapse" for="c-42860577">[-]</label><label class="expand" for="c-42860577">[14 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s a dangerous philosophy for professional work. You know what happens to code that works? It ships.<p>If you code out a solution to the problem in order to discover the problem space, I think the idea here is that you then can go back and write a better solution that accounts for all of the stuff you discovered via refactoring and whatnot. But you&#x27;re not going to do that refactoring. You&#x27;re going to ship it. Because it works and you don&#x27;t know of any problems with it. Are there scaling problems? Probably, you haven&#x27;t run into any yet. Does your solution fit whatever requirements other interested parties might have? Who knows! We didn&#x27;t do any designing or thinking about the problem yet.</div><br/><div id="42861758" class="c"><input type="checkbox" id="c-42861758" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42860640">next</a><span>|</span><label class="collapse" for="c-42861758">[-]</label><label class="expand" for="c-42861758">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;You know what happens to code that works? It ships.<p>there is nothing wrong with that, it is up to the developer and a team to enforce  and gatekeep quality<p>or up to the business user to accept working code</div><br/></div></div><div id="42860640" class="c"><input type="checkbox" id="c-42860640" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42861758">prev</a><span>|</span><a href="#42860867">next</a><span>|</span><label class="collapse" for="c-42860640">[-]</label><label class="expand" for="c-42860640">[1 more]</label></div><br/><div class="children"><div class="content">Discovery code doesn&#x27;t have to be bad code. My rule of abstractions is that I defer them until they are needed, even if I know that they <i>will</i> be needed in the next sprint or whatever. I&#x27;ll do a much better job making a precise abstraction when faced with an existing solution and a new problem.<p>Even if discovery code were bad code; I&#x27;ll take &quot;bad&quot; code 8 out 10 times if the competition is abstractions for abstractions&#x27; sake (which &quot;good&quot; code often is). Bad code is often simple and direct, and therefore simple to comprehend and fix. Fancy code is a game of jenga.<p>Also, requirements often change by the next sprint - so my well-laid plains would be moot either way.</div><br/></div></div><div id="42860867" class="c"><input type="checkbox" id="c-42860867" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42860640">prev</a><span>|</span><a href="#42861356">next</a><span>|</span><label class="collapse" for="c-42860867">[-]</label><label class="expand" for="c-42860867">[1 more]</label></div><br/><div class="children"><div class="content">Any person who would not go back and do that necessary redesign is unfit to call themselves a craftsperson.<p>Any organization that would not demand you do that necessary redesign is a organization unfit for producing critical systems.<p>Any organization that would go even further and prevent&#x2F;de-prioritize you from doing that necessary redesign is unfit to call whatever it is that they do “engineering”.<p>Why would you want to work at such a dystopian hellscape if you have the choice?<p>Note that this is only about shipping the known incomplete design to customers because it “works”.<p>And to get ahead of it, yes, startups selling systems held together by spit and twine are perfect examples of “unfit for critical systems”; you should not bet critical things on them until they mature.</div><br/></div></div><div id="42861356" class="c"><input type="checkbox" id="c-42861356" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42860867">prev</a><span>|</span><a href="#42861601">next</a><span>|</span><label class="collapse" for="c-42861356">[-]</label><label class="expand" for="c-42861356">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You know what happens to code that works? It ships.<p>That&#x27;s a process problem. Even professional writers have &quot;drafts&quot;, you shouldn&#x27;t be shipping first-draft code regardless. I guess maybe you are the equivalent of a 2 cent rag, and then product sucks, but we won&#x27;t get into all the ways you can suck as a software org...<p>Programming is neither writing an article nor designing an engine, its somewhere in the middle. You can apply &quot;discovery&quot; or &quot;drafting&quot; to the professional process as much as you can apply engineering design paradigms. The formal act of writing (unit) testing provides this opportunity, I find, to take the &quot;discovery&quot; implementations, harness them in specific &quot;design&quot; requirements, and produce a polished product.<p>TDD had this backwards, design then develop, as if that would somehow produce fantastic designs (it doesn&#x27;t, just a lot of test code). BDD (Behavior Driven Development) is better here, you aren&#x27;t driven by your tests as much as your <i>behaviors</i>. You may discover them, but once you do you test that they continue to work correctly.</div><br/></div></div><div id="42861601" class="c"><input type="checkbox" id="c-42861601" checked=""/><div class="controls bullet"><span class="by">BobbyTables2</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42861356">prev</a><span>|</span><a href="#42860822">next</a><span>|</span><label class="collapse" for="c-42861601">[-]</label><label class="expand" for="c-42861601">[1 more]</label></div><br/><div class="children"><div class="content">It’s very simple.<p>As soon as the code works, tell absolutely no one.<p>Then rewrite it….</div><br/></div></div><div id="42860822" class="c"><input type="checkbox" id="c-42860822" checked=""/><div class="controls bullet"><span class="by">heddycrow</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42861601">prev</a><span>|</span><a href="#42861613">next</a><span>|</span><label class="collapse" for="c-42860822">[-]</label><label class="expand" for="c-42860822">[1 more]</label></div><br/><div class="children"><div class="content">So better to do all discovery in a system&#x2F;tool that has no risk of being shipped like excel, whiteboard, design document, conversation, human brain, etc?<p>Am I going to ship it and not address scaling, refactoring, etc? What about discovery outside a code environment forces our hand on this?<p>Feels a bit to me like the real issue is not where discovery takes place but that crucial discovery steps are skipped for whatever reason.<p>I&#x27;m stuck somewhere in or around 1 &amp; 2 below.<p>1) those other systems for discovery suck at capturing behaviors of complex systems compared to working code in motion. Happy to discuss, but I&#x27;d love if this were an obvious conclusion somewhere in the neighborhood of The Map is Not The Kingdom trope<p>2) skipping important steps in discovery sucks no matter where it occur. I&#x27;ve seen this institutionalized&#x2F;practiced at both ends of the philosophical spectrum. I wasn&#x27;t being sarcastic or facetious (much) about the questions above.<p>I&#x27;d love it if someone could help me move somewhere past the above.  I think I might sleep better at night.</div><br/></div></div><div id="42861613" class="c"><input type="checkbox" id="c-42861613" checked=""/><div class="controls bullet"><span class="by">pizza</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42860822">prev</a><span>|</span><a href="#42860667">next</a><span>|</span><label class="collapse" for="c-42861613">[-]</label><label class="expand" for="c-42861613">[1 more]</label></div><br/><div class="children"><div class="content">But not taking this philosophy is dangerous if you&#x27;re trying to do something better than professionals.</div><br/></div></div><div id="42860667" class="c"><input type="checkbox" id="c-42860667" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42861613">prev</a><span>|</span><a href="#42862328">next</a><span>|</span><label class="collapse" for="c-42860667">[-]</label><label class="expand" for="c-42860667">[1 more]</label></div><br/><div class="children"><div class="content">This is basically waterfall and agile in a nutshell.<p>The extreme end of the other side of the spectrum is research and documentation to the extreme, coming up with a rigid, long development process that doesn&#x27;t readily allow for any sort of iteration.<p>The only real question is what is the difference between a working prototype that gets thrown away and an actual MVP. You need buy in from the business up front, otherwise you won&#x27;t be given the option to refactor or redo parts, you&#x27;ll be told it is good enough and there are features that need shipping.</div><br/></div></div><div id="42862328" class="c"><input type="checkbox" id="c-42862328" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42860667">prev</a><span>|</span><a href="#42861008">next</a><span>|</span><label class="collapse" for="c-42862328">[-]</label><label class="expand" for="c-42862328">[1 more]</label></div><br/><div class="children"><div class="content">One way to protect against this is to explore in a language that your coworkers don&#x27;t care about. Once the concept is proved, you can rewrite in whatever they prefer.</div><br/></div></div><div id="42861008" class="c"><input type="checkbox" id="c-42861008" checked=""/><div class="controls bullet"><span class="by">Jcampuzano2</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42862328">prev</a><span>|</span><a href="#42861856">next</a><span>|</span><label class="collapse" for="c-42861008">[-]</label><label class="expand" for="c-42861008">[1 more]</label></div><br/><div class="children"><div class="content">If this were the prominent mentality, some of the greatest pieces of software there are would never have existed because they would run into too many brick walls to even try.<p>Do you never go back and redesign things later? Can we not ship unless we have all ends neatly tied up?</div><br/></div></div><div id="42862071" class="c"><input type="checkbox" id="c-42862071" checked=""/><div class="controls bullet"><span class="by">all2</span><span>|</span><a href="#42860577">parent</a><span>|</span><a href="#42861856">prev</a><span>|</span><a href="#42861012">next</a><span>|</span><label class="collapse" for="c-42862071">[-]</label><label class="expand" for="c-42862071">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You know what happens to code that works? It ships.<p>The axiom I share with other engineers (real engineers) is &quot;the first working solution is the final solution.</div><br/></div></div></div></div><div id="42861126" class="c"><input type="checkbox" id="c-42861126" checked=""/><div class="controls bullet"><span class="by">tibbar</span><span>|</span><a href="#42860577">prev</a><span>|</span><a href="#42862299">next</a><span>|</span><label class="collapse" for="c-42861126">[-]</label><label class="expand" for="c-42861126">[4 more]</label></div><br/><div class="children"><div class="content">One trick I find helpful is to <i>start</i> by coding a subset of the problem with the goal of understanding the structure better. A brute-force solution, a simulation, a visualization of data, etc. And then use the discoveries of that process to do the real planning.</div><br/><div id="42861341" class="c"><input type="checkbox" id="c-42861341" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#42861126">parent</a><span>|</span><a href="#42862299">next</a><span>|</span><label class="collapse" for="c-42861341">[-]</label><label class="expand" for="c-42861341">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard this sort of activity called &quot;pathfinding&quot;.</div><br/><div id="42862310" class="c"><input type="checkbox" id="c-42862310" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#42861126">root</a><span>|</span><a href="#42861341">parent</a><span>|</span><a href="#42861469">next</a><span>|</span><label class="collapse" for="c-42862310">[-]</label><label class="expand" for="c-42862310">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a &quot;spike&quot; in Agile parlance, if you want to sell this approach to agile people</div><br/></div></div><div id="42861469" class="c"><input type="checkbox" id="c-42861469" checked=""/><div class="controls bullet"><span class="by">dr_kiszonka</span><span>|</span><a href="#42861126">root</a><span>|</span><a href="#42861341">parent</a><span>|</span><a href="#42862310">prev</a><span>|</span><a href="#42862299">next</a><span>|</span><label class="collapse" for="c-42861469">[-]</label><label class="expand" for="c-42861469">[1 more]</label></div><br/><div class="children"><div class="content">I usually &quot;play around with&quot; with a problem or data, but &quot;pathfinding&quot; sounds much better.</div><br/></div></div></div></div></div></div><div id="42862299" class="c"><input type="checkbox" id="c-42862299" checked=""/><div class="controls bullet"><span class="by">dusted</span><span>|</span><a href="#42861126">prev</a><span>|</span><a href="#42862500">next</a><span>|</span><label class="collapse" for="c-42862299">[-]</label><label class="expand" for="c-42862299">[1 more]</label></div><br/><div class="children"><div class="content">I call this exploratory programming, though my approach aligns more with the article I posted here, than with the Wikipedia definition.<p>I primarily use this method as a step preceding the actual production-quality implementation. It’s not like a prototype—I don’t throw everything away when I’m done. Instead, I extract the valuable parts: the learned concepts, the finished algorithms, and the relevant functions or classes. Unit tests are often written as part of setting up the problem, so I lift those out as well.<p>I’ve greatly enjoyed this approach, particularly in JavaScript&amp;|TypeScript. Typically, I solve the difficult parts in a live environment and extract the solutions when I find them. I used to use my own &quot;live environment&quot; (hedon.js), but I eventually reversed the approach and built an environment around the built-in Node.js REPL (@dusted&#x2F;debugrepl). I include this, at least during debugging and development builds, allowing me to live-code within a running system while having access to most, if not all, of the already-implemented parts of the program.<p>This approach lets me iterate at the function-call or expression level rather than following the traditional cycle of modifying code, restarting the program, reestablishing state, and triggering the desired call, something that annoys me to no end for all the obvious reasons.</div><br/></div></div><div id="42862500" class="c"><input type="checkbox" id="c-42862500" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#42862299">prev</a><span>|</span><a href="#42862786">next</a><span>|</span><label class="collapse" for="c-42862500">[-]</label><label class="expand" for="c-42862500">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of the alleged programming approach of Dr. Joe Armstrong of Erlang fame (RIP): write a program, then rewrite it, then rewrite it, and so on until it&#x27;s good enough.<p>That&#x27;s also how I tend to program, though usually as an accidental consequence of my ADD brain getting distracted, then being entirely dissatisfied with my code (or worse: I was too clever with it and it&#x27;s indecipherable) when I come back to it, prompting yet another rewrite.</div><br/></div></div><div id="42862786" class="c"><input type="checkbox" id="c-42862786" checked=""/><div class="controls bullet"><span class="by">molteanu</span><span>|</span><a href="#42862500">prev</a><span>|</span><a href="#42861302">next</a><span>|</span><label class="collapse" for="c-42862786">[-]</label><label class="expand" for="c-42862786">[1 more]</label></div><br/><div class="children"><div class="content">For a similar set of ideas, see &quot;A high-velocity style of software development&quot;.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42414911">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42414911</a></div><br/></div></div><div id="42861302" class="c"><input type="checkbox" id="c-42861302" checked=""/><div class="controls bullet"><span class="by">hi-wintermute</span><span>|</span><a href="#42862786">prev</a><span>|</span><a href="#42862316">next</a><span>|</span><label class="collapse" for="c-42861302">[-]</label><label class="expand" for="c-42861302">[3 more]</label></div><br/><div class="children"><div class="content">This reminds me of a tongue-in-cheek phrase we used to use in college.<p>&quot;Hours of coding can save minutes of planning.&quot;<p>&quot;Discovery Coding&quot; sounds fun, but be careful with your time!</div><br/><div id="42862337" class="c"><input type="checkbox" id="c-42862337" checked=""/><div class="controls bullet"><span class="by">esperent</span><span>|</span><a href="#42861302">parent</a><span>|</span><a href="#42862692">next</a><span>|</span><label class="collapse" for="c-42862337">[-]</label><label class="expand" for="c-42862337">[1 more]</label></div><br/><div class="children"><div class="content">&gt; careful with your time!<p>In my experience, this aphorism applies equally to any form of coding, and probably to nearly any complex human activity.<p>If you love writing outlines and plans, you can just as well waste time on that as the discovery coder does in their pathfinding. Not to mention the amount of time you can waste on refactoring and reorganizing.</div><br/></div></div><div id="42862692" class="c"><input type="checkbox" id="c-42862692" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#42861302">parent</a><span>|</span><a href="#42862337">prev</a><span>|</span><a href="#42862316">next</a><span>|</span><label class="collapse" for="c-42862692">[-]</label><label class="expand" for="c-42862692">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t plan what you dont know. That&#x27;s the point, you discover&#x2F;explore what you need in order to make a proper plan.</div><br/></div></div></div></div><div id="42862316" class="c"><input type="checkbox" id="c-42862316" checked=""/><div class="controls bullet"><span class="by">TheGoodBarn</span><span>|</span><a href="#42861302">prev</a><span>|</span><a href="#42861337">next</a><span>|</span><label class="collapse" for="c-42862316">[-]</label><label class="expand" for="c-42862316">[1 more]</label></div><br/><div class="children"><div class="content">I am an avid discovery coder and was actually day dreaming an outline for a similar article on my way home on the bus today. I think this is an extremely important concept at all levels of engineering and something we all need to adopt at one point or another in our careers &#x2F; practice.<p>I think it follows a few topics, &quot;the art of the POC&#x2F;Spike&quot; or just exploratory coding. These things give us a tangible hands on approach for understanding the codebase, and I think lend to better empathy and understanding of a software system and less rash criticisms of projects that may be unfamiliar.<p>This is particularly relevant to me right now as I am discovery coding a fairly large project at my company and working with product to lay out design and project planning. Whats difficult to express from my current standing is how the early stages of these types of projects are more milestone &#x2F; broad based rather than isolated small key pieces. Sure I can spend a week delivering design, architecture, epic, outline docs for all the known and unknown features of the project (and I am). But at the same time I need to discover and test out base case &#x2F; happy path solutions to the core business problem to more accurately understand the scope of the project.<p>I think its something I particularly love about being a TL &#x2F; IC at my company. I have the flexibility and trust to &quot;figure it out&quot; and the working arrangement to provide adequate professional documentation at the appropriate time. I am fortunate to have that buy in from leadership and certainly recognize it as a unique situation.<p>All that being said:<p>1. Learn how to effectively isolate and run arbitrary parts of your system for YOUR understanding and learning
2. Make it work, make it right, make it fast.
3. Learn to summarize and document your findings in a suitable fashion for your situation
4. Encourage this throughout your team. Useful in all aspects from bug triage to greenfield work</div><br/></div></div><div id="42861337" class="c"><input type="checkbox" id="c-42861337" checked=""/><div class="controls bullet"><span class="by">chriscbr</span><span>|</span><a href="#42862316">prev</a><span>|</span><a href="#42862509">next</a><span>|</span><label class="collapse" for="c-42861337">[-]</label><label class="expand" for="c-42861337">[3 more]</label></div><br/><div class="children"><div class="content">I really appreciate this essay.<p>I&#x27;ve never been a [traditional] artist, but I reckon that those working in the arts, and even areas of the programming world where experimentation is more fundamental (indie game development, perhaps?), would intuit the importance of discovery coding.<p>Even when you&#x27;re writing code for hairy business problems with huge numbers of constraints and edge cases, it&#x27;s entirely possible to support programmers that prefer discovery coding. The key is fast iteration loops. The ability to run the entire application, and all of its dependencies, locally on your own machine. In my opinion, that&#x27;s the biggest line in the sand. Once your program has to be deployed to a testing environment in order to be tested, it becomes an order of magnitude harder to use a debugger, or intercept network traffic, or inspect profilers, or do test driven development. It&#x27;s like sketching someone with a pencil and eraser, but there are 5-10 second delays between when you remove your pencil and when the line appears.<p>Unfortunately, it seems like many big tech companies, even that would seem to use very modern development tooling otherwise, still tend to make local development a second class citizen. And so, discovery coders are second class citizens as well.</div><br/><div id="42861460" class="c"><input type="checkbox" id="c-42861460" checked=""/><div class="controls bullet"><span class="by">pj_mukh</span><span>|</span><a href="#42861337">parent</a><span>|</span><a href="#42862718">next</a><span>|</span><label class="collapse" for="c-42861460">[-]</label><label class="expand" for="c-42861460">[1 more]</label></div><br/><div class="children"><div class="content">Yea, TIL, I&#x27;m a discovery coder. Always found planning early in Greenfield projects kind a pointless. Planning is almost step 3 or 4. I almost always prototype the most difficult&#x2F;opaque parts, build operations around testing and revising (how do you something is good enough?), and then plan out the rest.</div><br/></div></div><div id="42862718" class="c"><input type="checkbox" id="c-42862718" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#42861337">parent</a><span>|</span><a href="#42861460">prev</a><span>|</span><a href="#42862509">next</a><span>|</span><label class="collapse" for="c-42862718">[-]</label><label class="expand" for="c-42862718">[1 more]</label></div><br/><div class="children"><div class="content">Hard agree on local development. I always make apps run locally and include a readme that describes all the steps for someone else to run it locally as well.<p>Ideally that should be as simple as adding a local app settings file (described in readme so people don&#x27;t have to start reading the code to figure out what to put in it) for secrets and other local stuff (make sure the app isn&#x27;t trying to send emails locally etc), and running Docker compose up. If there are significantly more steps than that there better be good reasons for them.</div><br/></div></div></div></div><div id="42862509" class="c"><input type="checkbox" id="c-42862509" checked=""/><div class="controls bullet"><span class="by">webprofusion</span><span>|</span><a href="#42861337">prev</a><span>|</span><a href="#42862383">next</a><span>|</span><label class="collapse" for="c-42862509">[-]</label><label class="expand" for="c-42862509">[2 more]</label></div><br/><div class="children"><div class="content">Guilty, but as with anything there is a right time to use it and a time to most definitely avoid it. If you are working with others in particular there is very little room to wing it.<p>Experienced devs can do so in a first pass to flesh out an idea before letting the team get involved, but thereafter the design immediately becomes rigid. Inexperienced devs can wing it to learn in an exploratory way, but their work is unlikely to be re-purposable.</div><br/><div id="42862676" class="c"><input type="checkbox" id="c-42862676" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#42862509">parent</a><span>|</span><a href="#42862383">next</a><span>|</span><label class="collapse" for="c-42862676">[-]</label><label class="expand" for="c-42862676">[1 more]</label></div><br/><div class="children"><div class="content">If you keep the first thing you happen to write while exploring I don&#x27;t think it qualifies as exploration&#x2F;discovery. Then it&#x27;s just regular code monkeying.</div><br/></div></div></div></div><div id="42862383" class="c"><input type="checkbox" id="c-42862383" checked=""/><div class="controls bullet"><span class="by">quick_brown_fox</span><span>|</span><a href="#42862509">prev</a><span>|</span><a href="#42862525">next</a><span>|</span><label class="collapse" for="c-42862383">[-]</label><label class="expand" for="c-42862383">[1 more]</label></div><br/><div class="children"><div class="content">Related concepts in Peter Naur&#x27;s &quot;Programming as Theory Building&quot; [0] or Gerald Sussman&#x27;s &quot;Problem Solving by debugging-almost Right Plans&quot; [1]<p>[0] <a href="https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;Naur.pdf" rel="nofollow">https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;Naur.pdf</a>
[1] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2MYzvQ1v8Ww" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2MYzvQ1v8Ww</a></div><br/></div></div><div id="42862525" class="c"><input type="checkbox" id="c-42862525" checked=""/><div class="controls bullet"><span class="by">fitsumbelay</span><span>|</span><a href="#42862383">prev</a><span>|</span><a href="#42862051">next</a><span>|</span><label class="collapse" for="c-42862525">[-]</label><label class="expand" for="c-42862525">[1 more]</label></div><br/><div class="children"><div class="content">Feels unnecessary to call it _____ coding and try to bless it with the air of methodology when it&#x27;s just hacking or jamming just as you would on guitar or a drawing or other manual creative activity. you&#x27;re just moving forward with whatever level of intuition your experiences and learnings afford you :shrugs:</div><br/></div></div><div id="42862051" class="c"><input type="checkbox" id="c-42862051" checked=""/><div class="controls bullet"><span class="by">pants2</span><span>|</span><a href="#42862525">prev</a><span>|</span><a href="#42862291">next</a><span>|</span><label class="collapse" for="c-42862051">[-]</label><label class="expand" for="c-42862051">[1 more]</label></div><br/><div class="children"><div class="content">My workflow these days is too start by writing a Python notebook that solves the problem. There&#x27;s no faster way to iterate on writing something. Once it works I usually have o1 Pro write tests, clean it up, and then convert it to whatever language I actually need it written in.</div><br/></div></div><div id="42862291" class="c"><input type="checkbox" id="c-42862291" checked=""/><div class="controls bullet"><span class="by">or_am_i</span><span>|</span><a href="#42862051">prev</a><span>|</span><a href="#42862092">next</a><span>|</span><label class="collapse" for="c-42862291">[-]</label><label class="expand" for="c-42862291">[1 more]</label></div><br/><div class="children"><div class="content">Am an &quot;outliner&quot;, currently working together with a &quot;discovery coder&quot; on a project. We are half a year in and have no common working build, just my &quot;outline&quot; and a bunch of non-integrated throwaway discovery bits. I do believe that eventually they will produce the solution, but it is very hard to reason about the timeline in such a setup.</div><br/></div></div><div id="42862092" class="c"><input type="checkbox" id="c-42862092" checked=""/><div class="controls bullet"><span class="by">melvinroest</span><span>|</span><a href="#42862291">prev</a><span>|</span><a href="#42862608">next</a><span>|</span><label class="collapse" for="c-42862092">[-]</label><label class="expand" for="c-42862092">[1 more]</label></div><br/><div class="children"><div class="content">In Pharo discovery coding is really encouraged. I personally like it for writing scrapers and&#x2F;or web tests (I use Selenium in Pharo). I once had an improvized talk about it [1]. Nowadays, I&#x27;m back to Python and JavaScript due to their ecosystems, but for discoverability coding and Selenium-based testing&#x2F;scraping, I still think the interactive experience in Pharo is unmatched.<p>[1] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;FeFrt-kdvms?si=g12m7aZtDWtMMgwJ&amp;t=2270" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;FeFrt-kdvms?si=g12m7aZtDWtMMgwJ&amp;t=2270</a></div><br/></div></div><div id="42862608" class="c"><input type="checkbox" id="c-42862608" checked=""/><div class="controls bullet"><span class="by">submeta</span><span>|</span><a href="#42862092">prev</a><span>|</span><a href="#42861609">next</a><span>|</span><label class="collapse" for="c-42862608">[-]</label><label class="expand" for="c-42862608">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Discovery coding is a practice of understanding a problem by writing code first, rather than attempting to do some design process or thinking beforehand<p>When you write larger systems you better start making up your mind about the domain, understand it, come up with concepts and names that make sense instead of starting to code right away. Yeah, there are problem domains where an exploratory approach makes sense, but not when you create a product or a conplex system.</div><br/><div id="42862649" class="c"><input type="checkbox" id="c-42862649" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#42862608">parent</a><span>|</span><a href="#42861609">next</a><span>|</span><label class="collapse" for="c-42862649">[-]</label><label class="expand" for="c-42862649">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t even read the article but the way I use this is to familiarize myself with new stuff. You can&#x27;t plan a system when you have no idea how it&#x27;s going to work. That&#x27;s why it&#x27;s called discovery, you just write code and see how things work, then you refactor or just throw out everything and start from scratch once you feel ready to actually build the thing.<p>If you just write whatever you happen to come up with and keep it that&#x27;s just regular code monkeying.<p>It&#x27;s also not a technique you use for an entire system, hopefully you&#x27;re able to plan most things. But maybe a part of it integrates with a complex api you haven&#x27;t used before, then it&#x27;s nice to just take some time to figure out how that api really works at a level that&#x27;s hard to achieve just by skimming the docs.</div><br/><div id="42862707" class="c"><input type="checkbox" id="c-42862707" checked=""/><div class="controls bullet"><span class="by">submeta</span><span>|</span><a href="#42862608">root</a><span>|</span><a href="#42862649">parent</a><span>|</span><a href="#42861609">next</a><span>|</span><label class="collapse" for="c-42862707">[-]</label><label class="expand" for="c-42862707">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.</div><br/></div></div></div></div></div></div><div id="42861609" class="c"><input type="checkbox" id="c-42861609" checked=""/><div class="controls bullet"><span class="by">andruc</span><span>|</span><a href="#42862608">prev</a><span>|</span><a href="#42862466">next</a><span>|</span><label class="collapse" for="c-42861609">[-]</label><label class="expand" for="c-42861609">[3 more]</label></div><br/><div class="children"><div class="content">Casey Muratori talks about this in his Handmade Hero videos. I believe he calls it exploration-based programming.</div><br/><div id="42862106" class="c"><input type="checkbox" id="c-42862106" checked=""/><div class="controls bullet"><span class="by">Yoofie</span><span>|</span><a href="#42861609">parent</a><span>|</span><a href="#42862183">prev</a><span>|</span><a href="#42862466">next</a><span>|</span><label class="collapse" for="c-42862106">[-]</label><label class="expand" for="c-42862106">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, this is not a new concept and I remember seeing one of his videos that explains this concept really well. Here the relevant video from 9 years ago for those uninitiated:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;jlcmxvQfzKQ?si=zmKT9a3yK5R4Wmg4" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;jlcmxvQfzKQ?si=zmKT9a3yK5R4Wmg4</a></div><br/></div></div></div></div><div id="42862466" class="c"><input type="checkbox" id="c-42862466" checked=""/><div class="controls bullet"><span class="by">mbrezu</span><span>|</span><a href="#42861609">prev</a><span>|</span><a href="#42861855">next</a><span>|</span><label class="collapse" for="c-42862466">[-]</label><label class="expand" for="c-42862466">[1 more]</label></div><br/><div class="children"><div class="content">How is this different from <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exploratory_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exploratory_programming</a>?</div><br/></div></div><div id="42861855" class="c"><input type="checkbox" id="c-42861855" checked=""/><div class="controls bullet"><span class="by">TheCapeGreek</span><span>|</span><a href="#42862466">prev</a><span>|</span><a href="#42861837">next</a><span>|</span><label class="collapse" for="c-42861855">[-]</label><label class="expand" for="c-42861855">[1 more]</label></div><br/><div class="children"><div class="content">Never thought of it this way, but it makes sense. My default response to probing&#x2F;planning type questions from business is &quot;uhhh no clue, I have to dive into the code first and find out&quot; precisely because of this.</div><br/></div></div><div id="42861837" class="c"><input type="checkbox" id="c-42861837" checked=""/><div class="controls bullet"><span class="by">block_dagger</span><span>|</span><a href="#42861855">prev</a><span>|</span><a href="#42860347">next</a><span>|</span><label class="collapse" for="c-42861837">[-]</label><label class="expand" for="c-42861837">[1 more]</label></div><br/><div class="children"><div class="content">Interesting piece. As a coder and writer (hardcore outliner here), I’ve thought about this too.<p>I wonder about writing user stories for fiction. If software is something people use to realize an outcome, fiction is also something readers consume to realize an outcome. What might a “reader story” look like for some of our favorite novels? What kind of impression or change does a writer seek to produce in a reader’s mind? Such documentation could be valuable, similar to requirements documentation.<p>Aside to the author: King’s first name is spelled with a “ph.” Sorry, long time fan here :)</div><br/></div></div><div id="42860347" class="c"><input type="checkbox" id="c-42860347" checked=""/><div class="controls bullet"><span class="by">nullorempty</span><span>|</span><a href="#42861837">prev</a><span>|</span><a href="#42862035">next</a><span>|</span><label class="collapse" for="c-42860347">[-]</label><label class="expand" for="c-42860347">[3 more]</label></div><br/><div class="children"><div class="content">Discovery coding may be fine, but discovery architecture is a disaster.</div><br/><div id="42861006" class="c"><input type="checkbox" id="c-42861006" checked=""/><div class="controls bullet"><span class="by">xmprt</span><span>|</span><a href="#42860347">parent</a><span>|</span><a href="#42860476">next</a><span>|</span><label class="collapse" for="c-42861006">[-]</label><label class="expand" for="c-42861006">[1 more]</label></div><br/><div class="children"><div class="content">Nah. I&#x27;d almost argue that discovery coding is what helps define the architecture. I&#x27;ve seen way too many cases of over complexity designing a system for scale that will never be hit which results in an architecture that is too rigid to add new features to. If you do discovery coding you would realize the real bottlenecks and functionality that&#x27;s required and can build an architecture that addresses those concerns instead of just designing for design&#x27;s sake.</div><br/></div></div><div id="42860476" class="c"><input type="checkbox" id="c-42860476" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#42860347">parent</a><span>|</span><a href="#42861006">prev</a><span>|</span><a href="#42862035">next</a><span>|</span><label class="collapse" for="c-42860476">[-]</label><label class="expand" for="c-42860476">[1 more]</label></div><br/><div class="children"><div class="content">Yes and no. A lot depends on <i>who</i> the architect is.</div><br/></div></div></div></div><div id="42862202" class="c"><input type="checkbox" id="c-42862202" checked=""/><div class="controls bullet"><span class="by">tlarkworthy</span><span>|</span><a href="#42862035">prev</a><span>|</span><a href="#42861713">next</a><span>|</span><label class="collapse" for="c-42862202">[-]</label><label class="expand" for="c-42862202">[1 more]</label></div><br/><div class="children"><div class="content">I think if you also try to constrain yourself to only building orthogonal components it leads to a needs-based Lego set. I think it is difficult to see the underlying symmetry in a problem space if you design top-down.</div><br/></div></div><div id="42861713" class="c"><input type="checkbox" id="c-42861713" checked=""/><div class="controls bullet"><span class="by">stackghost</span><span>|</span><a href="#42862202">prev</a><span>|</span><a href="#42861589">next</a><span>|</span><label class="collapse" for="c-42861713">[-]</label><label class="expand" for="c-42861713">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp, with its excellent REPL, is great for this type of exploratory work.  The ability to build up a function from the inside out, and to build systems and classes from functions, again from the inside out, trivially creating mocks and ad-hoc tests as you go, is fantastic DX.</div><br/></div></div><div id="42861589" class="c"><input type="checkbox" id="c-42861589" checked=""/><div class="controls bullet"><span class="by">ziofill</span><span>|</span><a href="#42861713">prev</a><span>|</span><a href="#42861737">next</a><span>|</span><label class="collapse" for="c-42861589">[-]</label><label class="expand" for="c-42861589">[1 more]</label></div><br/><div class="children"><div class="content">I feel I finally can put a name to my coding style! Incidentally, I also like to pretend classes and functions exist even if they don’t. Of course my discovery code won’t work, but I can go very far and discover a lot of useful information this way.</div><br/></div></div><div id="42861737" class="c"><input type="checkbox" id="c-42861737" checked=""/><div class="controls bullet"><span class="by">rakejake</span><span>|</span><a href="#42861589">prev</a><span>|</span><a href="#42862218">next</a><span>|</span><label class="collapse" for="c-42861737">[-]</label><label class="expand" for="c-42861737">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, some projects are very suited to discovery coding.<p>For my Machine Learning projects, I usually run a bunch of experiments either using pytest or directly on jupyter. I tend to plot out stuff and try out different types of feature engineering. Once I have nailed the approach, I then port a subset of this to a different jupyter notebook or python script, which is cleaner and more readable. This is because ML experiments are compute bottlenecked. So I want to ensure I spend enough time to pick the best features and model.<p>At work (which is not ML-related), I tend to do much less discovery coding because most of the unknowns are business related - does this API (owned by another team) scale, what is the correct place for this business logic etc. And, doing a viable Proof of Concept is time consuming, so I&#x27;d rather spend the time sweating out the nitty-gritties with product. The Discovery here must happen in the discussion with Product or other stakeholders because that is the expensive part. This is also why Product changing the Spec once the project is underway is infuriating. Sometimes a good chunk of the discovery is nullified.</div><br/></div></div><div id="42862218" class="c"><input type="checkbox" id="c-42862218" checked=""/><div class="controls bullet"><span class="by">pierrec</span><span>|</span><a href="#42861737">prev</a><span>|</span><a href="#42861353">next</a><span>|</span><label class="collapse" for="c-42862218">[-]</label><label class="expand" for="c-42862218">[1 more]</label></div><br/><div class="children"><div class="content">I always appreciate someone coining a useful expression, but I gotta say, sometimes these coiners are trying a bit too hard, no? I think I&#x27;ll stick with &quot;exploration-based&quot;, &quot;exploratory&quot; or &quot;explorative&quot; programming, which are commonly used and all sound less awkward to me than than &quot;discovery coding&quot;. But hey, if that&#x27;s what people flock to I&#x27;ll get with the times! I&#x27;ve always used a combination of both approaches and the descriptions made here are great.</div><br/></div></div><div id="42861353" class="c"><input type="checkbox" id="c-42861353" checked=""/><div class="controls bullet"><span class="by">x3n0ph3n3</span><span>|</span><a href="#42862218">prev</a><span>|</span><a href="#42861910">next</a><span>|</span><label class="collapse" for="c-42861353">[-]</label><label class="expand" for="c-42861353">[1 more]</label></div><br/><div class="children"><div class="content">This is how I&#x27;ve operated for most of my career and I partly attribute my success and productivity with it.</div><br/></div></div><div id="42861910" class="c"><input type="checkbox" id="c-42861910" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#42861353">prev</a><span>|</span><a href="#42860574">next</a><span>|</span><label class="collapse" for="c-42861910">[-]</label><label class="expand" for="c-42861910">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For some reason, we have no such distinction in programming, so I am here to introduce it.<p>What? Of course there is. Exploratory programming and just writing code without big or even little design is (or was?) incredibly common. It doesn’t scale beyond one or two programmers so we don’t talk about it very much, but popular products like Minecraft originated this was, and almost definitely lots of one off useful tools fall into this category as well.<p>Even in big products, proof of concepts or prototypes can and are often done this way.<p>is incredibly</div><br/></div></div></div></div></div></div></div></body></html>