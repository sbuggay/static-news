<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722502852513" as="style"/><link rel="stylesheet" href="styles.css?v=1722502852513"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ogiekako.vercel.app/blog/find_mkdir_tc">`find` + `mkdir` is Turing complete</a> <span class="domain">(<a href="https://ogiekako.vercel.app">ogiekako.vercel.app</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>93 comments</span></div><br/><div><div id="41121377" class="c"><input type="checkbox" id="c-41121377" checked=""/><div class="controls bullet"><span class="by">IncRnd</span><span>|</span><a href="#41117089">next</a><span>|</span><label class="collapse" for="c-41121377">[-]</label><label class="expand" for="c-41121377">[1 more]</label></div><br/><div class="children"><div class="content">From the top of the page:<p>find + mkdir is Turing complete (retracted)
The proof is flawed and I retract the claim that I proved that find + mkdir is Turing complete. See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41117141">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41117141</a>. I will update the article if I could fix the proof.</div><br/></div></div><div id="41117089" class="c"><input type="checkbox" id="c-41117089" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#41121377">prev</a><span>|</span><a href="#41118525">next</a><span>|</span><label class="collapse" for="c-41117089">[-]</label><label class="expand" for="c-41117089">[13 more]</label></div><br/><div class="children"><div class="content">So can you implement Folders with it?<p><a href="https:&#x2F;&#x2F;www.danieltemkin.com&#x2F;Esolangs&#x2F;Folders&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.danieltemkin.com&#x2F;Esolangs&#x2F;Folders&#x2F;</a></div><br/><div id="41117826" class="c"><input type="checkbox" id="c-41117826" checked=""/><div class="controls bullet"><span class="by">dspillett</span><span>|</span><a href="#41117089">parent</a><span>|</span><a href="#41117112">next</a><span>|</span><label class="collapse" for="c-41117826">[-]</label><label class="expand" for="c-41117826">[11 more]</label></div><br/><div class="children"><div class="content"><i>&gt; In Windows, folders are entirely free in terms of disk space! For proof, create say 352,449 folders and get properties on it.</i><p>To be that guy for a moment: well, hackchewally…¹<p>Directory entries do take up space in the MFT, but that doesn&#x27;t show up in explorer which is only counting allocated blocks elsewhere. You will eventually hit a space issue creating empty directories as the MTF grows to accept their allocation.<p>You can do similar tricks with small files. Create an empty text file and check, it will show 0 bytes size and 0 bytes on disk. Put in ~400 bytes of text and check again: explorer will show 400 bytes in length but 0 size on disk because the data is in the directory entry in the pre-allocated MFT. Double up that data, and it will be big enough that a block on the disk is allocated: in properties in Explorer you&#x27;ll now see 800 bytes length and 4,096 bytes (one block) on disk. Drop it back to 400 bytes and it won&#x27;t move the data back into the MFT, you&#x27;ll now see 400 bytes length, 4096 bytes consumed on disk.<p>--<p>[1] though don&#x27;t let this put you off enjoying the splendid thing overall!</div><br/><div id="41126803" class="c"><input type="checkbox" id="c-41126803" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41117826">parent</a><span>|</span><a href="#41117858">next</a><span>|</span><label class="collapse" for="c-41126803">[-]</label><label class="expand" for="c-41126803">[1 more]</label></div><br/><div class="children"><div class="content">NTFS is very much an old school file system design, where most&#x2F;all metadata is stuffed into predefined regions on the disk. NTFS&#x27;s MFT, in particular, can and does grow as needed (though it never shrinks!), but as entries in the MFT vanish, that space is just waiting for future allocations. It makes it a bit difficult to tell what an empty directory or file &quot;really&quot; takes, because when it&#x27;s just part of the MFT, there&#x27;s (usually) no change in used&#x2F;free disk space just by creating them.<p>In the Unix land, the same sort of thing exists with file systems such as ext4 and UFS2: they also depend on predefined regions for metadata. If you&#x27;d like to venture into ZFS, however, (almost) all metadata is dynamically created and destroyed on an as-needed basis, and as such, ZFS always reports the on-disk usage by counting both user data and metadata. It&#x27;s easy to see a directory grow to many megabytes by just creating a lot of empty files inside of it.</div><br/></div></div><div id="41117858" class="c"><input type="checkbox" id="c-41117858" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41117826">parent</a><span>|</span><a href="#41126803">prev</a><span>|</span><a href="#41118747">next</a><span>|</span><label class="collapse" for="c-41117858">[-]</label><label class="expand" for="c-41117858">[1 more]</label></div><br/><div class="children"><div class="content">Remember that esolangs are arguably the &quot;purest&quot; medium of artistic expression for programming, and that artworks often are about challenging or confronting implicit assumptions. Or to put it differently: yes, that is indeed the joke :).<p>Thank you for elaborating the technical details though (plus I did not know the small file trick, that&#x27;s a neat bit of trivia).</div><br/></div></div><div id="41118747" class="c"><input type="checkbox" id="c-41118747" checked=""/><div class="controls bullet"><span class="by">sumtechguy</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41117826">parent</a><span>|</span><a href="#41117858">prev</a><span>|</span><a href="#41119111">next</a><span>|</span><label class="collapse" for="c-41118747">[-]</label><label class="expand" for="c-41118747">[4 more]</label></div><br/><div class="children"><div class="content">Also MFT can also grow in size if you exceed the current allocated size.  Depending on your version of windows that growth rate is different.  Also once the MFT grows it will not shrink.  The tools for MFT cleanup are rather poor.  With the usual recommendation of &#x27;just format a new drive and start over&#x27;.</div><br/><div id="41120024" class="c"><input type="checkbox" id="c-41120024" checked=""/><div class="controls bullet"><span class="by">philistine</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41118747">parent</a><span>|</span><a href="#41119111">next</a><span>|</span><label class="collapse" for="c-41120024">[-]</label><label class="expand" for="c-41120024">[3 more]</label></div><br/><div class="children"><div class="content">Apple finally managed to switch its file system and escape the pains of late 80s technology. When will Microsoft replace NTFS?</div><br/><div id="41126772" class="c"><input type="checkbox" id="c-41126772" checked=""/><div class="controls bullet"><span class="by">Negitivefrags</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41120024">parent</a><span>|</span><a href="#41120135">next</a><span>|</span><label class="collapse" for="c-41126772">[-]</label><label class="expand" for="c-41126772">[1 more]</label></div><br/><div class="children"><div class="content">In theory ReFS is the replacement. It hasn’t seen large uptake though.</div><br/></div></div><div id="41120135" class="c"><input type="checkbox" id="c-41120135" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41120024">parent</a><span>|</span><a href="#41126772">prev</a><span>|</span><a href="#41119111">next</a><span>|</span><label class="collapse" for="c-41120135">[-]</label><label class="expand" for="c-41120135">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Don&#x27;t touch if it works&quot; (c) &#x2F;s</div><br/></div></div></div></div></div></div><div id="41119111" class="c"><input type="checkbox" id="c-41119111" checked=""/><div class="controls bullet"><span class="by">lelandfe</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41117826">parent</a><span>|</span><a href="#41118747">prev</a><span>|</span><a href="#41119563">next</a><span>|</span><label class="collapse" for="c-41119111">[-]</label><label class="expand" for="c-41119111">[1 more]</label></div><br/><div class="children"><div class="content">Master File Table</div><br/></div></div><div id="41119563" class="c"><input type="checkbox" id="c-41119563" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41117826">parent</a><span>|</span><a href="#41119111">prev</a><span>|</span><a href="#41117112">next</a><span>|</span><label class="collapse" for="c-41119563">[-]</label><label class="expand" for="c-41119563">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Disk manufacturers hate this simple trick for free data storage.&quot;</div><br/><div id="41120232" class="c"><input type="checkbox" id="c-41120232" checked=""/><div class="controls bullet"><span class="by">dspillett</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41119563">parent</a><span>|</span><a href="#41123211">next</a><span>|</span><label class="collapse" for="c-41120232">[-]</label><label class="expand" for="c-41120232">[1 more]</label></div><br/><div class="children"><div class="content">Oh, that might make a great April 1st release: a mirror filesystem module for WinFSP that splits files into 500 byte chunks on disk. “See, we saved that 4Mbyte photo to the new filesystem, and it, using the NTFS infinite space for small files trick, made it take absolutely <i>zero</i> disk space! Now we&#x27;ll make a sub-folder and drop a few more files in that, and look, they show as taking no space in the magic backing store but can be properly opened as normal!”.<p>Drop it on youtube or tt, get your popular friends (this might scupper me, if anyone I know is an online influenza they have the good sense not to let me know about such proclivities!) to make a review of it, and see how far and wide it spreads with people either in on the joke or idiots just parroting it for views.</div><br/></div></div><div id="41123211" class="c"><input type="checkbox" id="c-41123211" checked=""/><div class="controls bullet"><span class="by">devbent</span><span>|</span><a href="#41117089">root</a><span>|</span><a href="#41119563">parent</a><span>|</span><a href="#41120232">prev</a><span>|</span><a href="#41117112">next</a><span>|</span><label class="collapse" for="c-41123211">[-]</label><label class="expand" for="c-41123211">[1 more]</label></div><br/><div class="children"><div class="content">Back in the days of dos, I use one of the disK compression utilities to store 20 MB on a regular 3.5-in floppy. The entire 20 MB consisted of metadata for the compression system!</div><br/></div></div></div></div></div></div><div id="41117112" class="c"><input type="checkbox" id="c-41117112" checked=""/><div class="controls bullet"><span class="by">Moosturm</span><span>|</span><a href="#41117089">parent</a><span>|</span><a href="#41117826">prev</a><span>|</span><a href="#41118525">next</a><span>|</span><label class="collapse" for="c-41117112">[-]</label><label class="expand" for="c-41117112">[1 more]</label></div><br/><div class="children"><div class="content">This is phenomenal</div><br/></div></div></div></div><div id="41118525" class="c"><input type="checkbox" id="c-41118525" checked=""/><div class="controls bullet"><span class="by">indigo0086</span><span>|</span><a href="#41117089">prev</a><span>|</span><a href="#41116980">next</a><span>|</span><label class="collapse" for="c-41118525">[-]</label><label class="expand" for="c-41118525">[1 more]</label></div><br/><div class="children"><div class="content">Retracted
&gt;The proof is flawed and I retract the claim that I proved that find + mkdir is Turing complete</div><br/></div></div><div id="41116980" class="c"><input type="checkbox" id="c-41116980" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41118525">prev</a><span>|</span><a href="#41116364">next</a><span>|</span><label class="collapse" for="c-41116980">[-]</label><label class="expand" for="c-41116980">[43 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand how this shows Turing completeness. The implementation of the rule 110 automaton seems to be limited by both width (not Turing complete because there is a finite number of states of a given width) and iteration limit (not be Turning complete because it always terminates).<p>Can you write an implementation of rule 110 with arbitrary (i.e. unbounded) width and depth?</div><br/><div id="41117076" class="c"><input type="checkbox" id="c-41117076" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#41116980">parent</a><span>|</span><a href="#41117360">next</a><span>|</span><label class="collapse" for="c-41117076">[-]</label><label class="expand" for="c-41117076">[39 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still ok if the implementation limits it rather than the concept. I mean, your computer has finite memory rather than infinite tape, so it doesn&#x27;t meet that requirement either regardless of language&#x2F;method.</div><br/><div id="41117141" class="c"><input type="checkbox" id="c-41117141" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117076">parent</a><span>|</span><a href="#41118874">next</a><span>|</span><label class="collapse" for="c-41117141">[-]</label><label class="expand" for="c-41117141">[35 more]</label></div><br/><div class="children"><div class="content">I am not talking about limitations of find or mkdir like other commenters are.<p>I can write a Python program that simulates rule 110 with unbounded state width and unbounded iteration depth. I might not be able to <i>execute</i> it on any computer (it&#x27;s going to run out of memory at some point), but I can still reason about it and its behavior with a (theoretical) infinite memory.  After reading the blog post, I am not convinced I can write such a program using `find` and `mkdir`, since the provided example uses explicit limits for WIDTH and ITER in the program itself.</div><br/><div id="41127041" class="c"><input type="checkbox" id="c-41127041" checked=""/><div class="controls bullet"><span class="by">ogiekako2</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117141">parent</a><span>|</span><a href="#41117350">next</a><span>|</span><label class="collapse" for="c-41127041">[-]</label><label class="expand" for="c-41127041">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for your comment on my article. I think I&#x27;ve managed to fix the proof by implementing a tag system. Would you (anyone) mind reviewing my code [1][2]? The key point is using back references, which I think gave us capabilities beyond regular expressions to achieve Turing completeness. However, I&#x27;m not very familiar with tag systems, and I&#x27;m worried I might have missed something.<p>[1] <a href="https:&#x2F;&#x2F;onecompiler.com&#x2F;bash&#x2F;42mux2442" rel="nofollow">https:&#x2F;&#x2F;onecompiler.com&#x2F;bash&#x2F;42mux2442</a>
[2] <a href="https:&#x2F;&#x2F;onecompiler.com&#x2F;bash&#x2F;42mux3nf8" rel="nofollow">https:&#x2F;&#x2F;onecompiler.com&#x2F;bash&#x2F;42mux3nf8</a></div><br/></div></div><div id="41117350" class="c"><input type="checkbox" id="c-41117350" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117141">parent</a><span>|</span><a href="#41127041">prev</a><span>|</span><a href="#41127230">next</a><span>|</span><label class="collapse" for="c-41117350">[-]</label><label class="expand" for="c-41117350">[28 more]</label></div><br/><div class="children"><div class="content">The same argument would make C non turing complete. Because the size of pointers is a compile time constant and because everything needs to have an address that puts a large, but hard limit on tape length.<p>There are ways to argue arround that, e.g. C might be able to interface with a infinite tape file via the stantard library, and maybe strict aliasing and pointer provenance let&#x27;s you create a system where bit identical pointers can be different. But the mental model most people have of C wouldn&#x27;t be turing complete.</div><br/><div id="41117467" class="c"><input type="checkbox" id="c-41117467" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117350">parent</a><span>|</span><a href="#41117401">next</a><span>|</span><label class="collapse" for="c-41117467">[-]</label><label class="expand" for="c-41117467">[19 more]</label></div><br/><div class="children"><div class="content">While strictly speaking true I don&#x27;t think it is the same argument at all. You are talking about a restriction of the runtime (much like mkdir argument length or maximum filesystem depth), even though it leaks into the standard because standard people care about physical hardware, not theoretical ones.<p>The WIDTH and ITER limit being actual constants that are part of the program makes all the difference compared to C pointer limitations that are part of the execution environment.</div><br/><div id="41118106" class="c"><input type="checkbox" id="c-41118106" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117467">parent</a><span>|</span><a href="#41117509">next</a><span>|</span><label class="collapse" for="c-41118106">[-]</label><label class="expand" for="c-41118106">[14 more]</label></div><br/><div class="children"><div class="content">But C is not Turing-complete, because its numbers (and pointers) are <i>required</i> to have an arbitrary limit which itself must be representable and useable in C. Python, on the other hand, has no such requirement and you could imagine an implementation that could grow indefinitely (well, until it ran out of the physical universe). C is prohibited from doing that, there is always a theoretical limit present. You can set that limit hella high, but it&#x27;s still there.</div><br/><div id="41118749" class="c"><input type="checkbox" id="c-41118749" checked=""/><div class="controls bullet"><span class="by">a_cardboard_box</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41118106">parent</a><span>|</span><a href="#41123257">next</a><span>|</span><label class="collapse" for="c-41118749">[-]</label><label class="expand" for="c-41118749">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still not comparable to mkdir and find.<p>The arbitrary limit in C is not fixed by the code. So if you run out of space on a 32-bit machine with sizeof(size_t) == 4, you can run <i>the same code</i> on a 64-bit machine with sizeof(size_t) == 8. With mkdir and find, you have to change <i>the code</i> to do this.<p>You can translate any Turing Machine into a <i>single</i> C program, which will behave identically so long as you have enough memory. You cannot do this if you need to change the program when the amount of memory changes.</div><br/><div id="41118823" class="c"><input type="checkbox" id="c-41118823" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41118749">parent</a><span>|</span><a href="#41123257">next</a><span>|</span><label class="collapse" for="c-41118823">[-]</label><label class="expand" for="c-41118823">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue that the process of taking a C program and compiling and running it on ever larger pointer sizes it turing complete, but not a single iteration of this process.</div><br/></div></div></div></div><div id="41123257" class="c"><input type="checkbox" id="c-41123257" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41118106">parent</a><span>|</span><a href="#41118749">prev</a><span>|</span><a href="#41118247">next</a><span>|</span><label class="collapse" for="c-41123257">[-]</label><label class="expand" for="c-41123257">[1 more]</label></div><br/><div class="children"><div class="content">A C program which doesn’t inspect its pointer representations can conceivably use unlimited memory. For pointer values whose representation can be statically determined to be uninspected by the program, the C implementation can use memory locations outside of the representable address space, and thus make unlimited memory accessible. Functionally there is no need for self-contained C programs to ever inspect their pointer representation.</div><br/></div></div><div id="41118247" class="c"><input type="checkbox" id="c-41118247" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41118106">parent</a><span>|</span><a href="#41123257">prev</a><span>|</span><a href="#41117509">next</a><span>|</span><label class="collapse" for="c-41118247">[-]</label><label class="expand" for="c-41118247">[10 more]</label></div><br/><div class="children"><div class="content">&quot;Python&quot;  doesn&#x27;t exist though. It&#x27;s silly to claim that Python is more powerful just because it doesn&#x27;t tell you what it&#x27;s going to do (run on some limited hardware) and C lets you choose. Reality is fundamentally, necessarily different from theory. Everything real is a mere approximation of theory, and vice versa. Even Turing&#x27;s machine is limited by all the paper in the universes, unless you ignore reality (which is fine!).
It&#x27;s false precision to say that C in reality with bounded pointers is different from C with unbounded pointers, but Python in reality with secretly bounded pointers is the same as Python with unbounded pointers.</div><br/><div id="41118478" class="c"><input type="checkbox" id="c-41118478" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41118247">parent</a><span>|</span><a href="#41117509">next</a><span>|</span><label class="collapse" for="c-41118478">[-]</label><label class="expand" for="c-41118478">[9 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s not a false precision. The C <i>requires</i> the numbers (and memory size) to have an upper limit which it is obliged to tell you. The Python doesn&#x27;t require such limitations to exist. They will, of course, exist in practice since it&#x27;s impossible to build a Turing machine but only a sufficiently huge finite-state machine, but that is the <i>practical</i> consideration. In practice, all language implementations are FSMs. But C is a FSM even <i>in theory</i>, unlike Python.<p>You would have better luck trying to argue that there is a reading of standard that allows for unboundedly huge file streams and that fread()&#x2F;fwrite()&#x2F;fseek() then could be used to faithfully implement Turing machine.</div><br/><div id="41126362" class="c"><input type="checkbox" id="c-41126362" checked=""/><div class="controls bullet"><span class="by">majorexception</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41118478">parent</a><span>|</span><a href="#41118635">next</a><span>|</span><label class="collapse" for="c-41126362">[-]</label><label class="expand" for="c-41126362">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think there&#x27;s real difference between Python and C.
With Python you can&#x27;t make your program use more than 4 GB of address space if you run it with a 32-bit interpreter. You have to swap the interpreter. In C the same goes for the compiler. And yes, you can inspect the upper limit by looking at the width of size_t, but it will be seen differently with 32 and 64-bit compilers although the program will be the same. And you _can_ make program behave differently basing on size_t&#x27;s width, but you&#x27;re not required to. It doesn&#x27;t change that fundamentally Python is no more Turing-complete than C just because you can&#x27;t do it in Python (that&#x27;s my assumption, I don&#x27;t know Python well enough actually).<p>Maybe it all boils down to how CPUs work, and maybe it&#x27;s safe to say that the incompleteness comes from the CPU implementation? You can of course argue that Python interpreters are written in C&#x2F;C++, but of course we can imagine they can be written in assembly.<p>Edit: after I read some other comments I think I see the point - that indeed the problem is the implementation (on CPU).</div><br/></div></div><div id="41120350" class="c"><input type="checkbox" id="c-41120350" checked=""/><div class="controls bullet"><span class="by">PhunkyPhil</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41118478">parent</a><span>|</span><a href="#41118635">prev</a><span>|</span><a href="#41117509">next</a><span>|</span><label class="collapse" for="c-41120350">[-]</label><label class="expand" for="c-41120350">[6 more]</label></div><br/><div class="children"><div class="content">&gt; But C is a FSM even in theory, unlike Python<p>Write a python interpreter in C and it&#x27;s clear to see why your logic fails. You&#x27;ve reaped your claimed benefits of Python while remaining in C.</div><br/><div id="41121178" class="c"><input type="checkbox" id="c-41121178" checked=""/><div class="controls bullet"><span class="by">osmarks</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41120350">parent</a><span>|</span><a href="#41117509">next</a><span>|</span><label class="collapse" for="c-41121178">[-]</label><label class="expand" for="c-41121178">[5 more]</label></div><br/><div class="children"><div class="content">Python-the-language can be Turing-complete even if Python-as-actually-implemented is not.</div><br/><div id="41122335" class="c"><input type="checkbox" id="c-41122335" checked=""/><div class="controls bullet"><span class="by">PhunkyPhil</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41121178">parent</a><span>|</span><a href="#41117509">next</a><span>|</span><label class="collapse" for="c-41122335">[-]</label><label class="expand" for="c-41122335">[4 more]</label></div><br/><div class="children"><div class="content">Then C-the-language can be Turing complete, even if C-as-actually-implemented is not. Just implement a python interpreter. (Or you can also just implement bignums in C and use those for your computation)</div><br/><div id="41123007" class="c"><input type="checkbox" id="c-41123007" checked=""/><div class="controls bullet"><span class="by">osmarks</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41122335">parent</a><span>|</span><a href="#41117509">next</a><span>|</span><label class="collapse" for="c-41123007">[-]</label><label class="expand" for="c-41123007">[3 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t implement a Python interpreter with access to infinite memory in C as specified. That is the point.</div><br/><div id="41126250" class="c"><input type="checkbox" id="c-41126250" checked=""/><div class="controls bullet"><span class="by">PhunkyPhil</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41123007">parent</a><span>|</span><a href="#41123611">next</a><span>|</span><label class="collapse" for="c-41126250">[-]</label><label class="expand" for="c-41126250">[1 more]</label></div><br/><div class="children"><div class="content">Why not? Whether you&#x27;re running python code in your C interpreter or just running C code, the same memory restrictions will apply based on your hardware. CPython doesn&#x27;t place a lower bound on bignums over a non-C based implementation<p>EDIT: See the GMP library, which states &quot;There is no practical limit to the precision except the ones implied by the available memory in the machine GMP runs on&quot;[0]<p><a href="https:&#x2F;&#x2F;gmplib.org&#x2F;#WHAT" rel="nofollow">https:&#x2F;&#x2F;gmplib.org&#x2F;#WHAT</a></div><br/></div></div><div id="41123611" class="c"><input type="checkbox" id="c-41123611" checked=""/><div class="controls bullet"><span class="by">sambaumann</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41123007">parent</a><span>|</span><a href="#41126250">prev</a><span>|</span><a href="#41117509">next</a><span>|</span><label class="collapse" for="c-41123611">[-]</label><label class="expand" for="c-41123611">[1 more]</label></div><br/><div class="children"><div class="content">Would it be fair to say then that &quot;Python&quot; is Turing complete, while CPython&#x2F;PyPy implementations are not turing complete, because they will always implicitly run up against C&#x27;s memory limitations, therefore they do have a hard limit. Python itself as a language is turing complete because it does not place realistic limitations on the user like C does?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41117509" class="c"><input type="checkbox" id="c-41117509" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117467">parent</a><span>|</span><a href="#41118106">prev</a><span>|</span><a href="#41121712">next</a><span>|</span><label class="collapse" for="c-41117509">[-]</label><label class="expand" for="c-41117509">[3 more]</label></div><br/><div class="children"><div class="content">The difference is very small though, you could say that WIDTH amd ITER must be defined in the execution enviroment (shell)before execution and that the rest of the code is the program, and we are at the same situation as in C.</div><br/><div id="41117622" class="c"><input type="checkbox" id="c-41117622" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117509">parent</a><span>|</span><a href="#41121712">next</a><span>|</span><label class="collapse" for="c-41117622">[-]</label><label class="expand" for="c-41117622">[2 more]</label></div><br/><div class="children"><div class="content">If you define WIDTH and ITER prior to execution you are just giving arguments to your program.<p>Maybe using the term &quot;environment&quot; was not the best choice; what I mean is that WIDTH and ITER are program variables that impact program behavior and output (appear in regexes etc.) whereas (most) C programs don&#x27;t actually reference or depend on the pointer width (other than crashing if it&#x27;s too small); it is an internal detail of the C compiler and underlying hardware that only happens to be visible to the programmer due to leaky abstractions. I don&#x27;t think those are comparable.</div><br/><div id="41119045" class="c"><input type="checkbox" id="c-41119045" checked=""/><div class="controls bullet"><span class="by">horsawlarway</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117622">parent</a><span>|</span><a href="#41121712">next</a><span>|</span><label class="collapse" for="c-41119045">[-]</label><label class="expand" for="c-41119045">[1 more]</label></div><br/><div class="children"><div class="content">I mean... isn&#x27;t this just `sizeof` in c?<p>Honestly, I&#x27;m struggling to think of any real world code base I&#x27;ve worked with in C that <i>didn&#x27;t</i> care about pointer size.</div><br/></div></div></div></div></div></div></div></div><div id="41117401" class="c"><input type="checkbox" id="c-41117401" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117350">parent</a><span>|</span><a href="#41117467">prev</a><span>|</span><a href="#41119023">next</a><span>|</span><label class="collapse" for="c-41117401">[-]</label><label class="expand" for="c-41117401">[3 more]</label></div><br/><div class="children"><div class="content">On the other hand, a C running on a machine with a significantly larger address space would have appropriately larger pointers. The C standard does not specify any particular pointer bitwidth. With these things together, C as a language has a decent claim to Turing-completeness.</div><br/><div id="41117416" class="c"><input type="checkbox" id="c-41117416" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117401">parent</a><span>|</span><a href="#41119036">next</a><span>|</span><label class="collapse" for="c-41117416">[-]</label><label class="expand" for="c-41117416">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but you still configure (choose a compiler) it to a fixed size before running, that is in my mind no different than specifying a fixed tape size, like in the find + mkdir example.</div><br/></div></div><div id="41119036" class="c"><input type="checkbox" id="c-41119036" checked=""/><div class="controls bullet"><span class="by">oecumena</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117401">parent</a><span>|</span><a href="#41117416">prev</a><span>|</span><a href="#41119023">next</a><span>|</span><label class="collapse" for="c-41119036">[-]</label><label class="expand" for="c-41119036">[1 more]</label></div><br/><div class="children"><div class="content">For any C program there is a number N, that depends on the program, compiler, architecture, etc., but does not depend on the program input, such that the program won&#x27;t be able to access more than N bits of state at any moment in any of its possible executions. Hence, the program is equivalent to a finite state automaton.</div><br/></div></div></div></div><div id="41119023" class="c"><input type="checkbox" id="c-41119023" checked=""/><div class="controls bullet"><span class="by">oecumena</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117350">parent</a><span>|</span><a href="#41117401">prev</a><span>|</span><a href="#41121166">next</a><span>|</span><label class="collapse" for="c-41119023">[-]</label><label class="expand" for="c-41119023">[1 more]</label></div><br/><div class="children"><div class="content">C is definitely <i>not</i> Turing complete. The standard library provides no escape, because file sizes are also limited (due to ftell (3)), <i>and</i> there is no chdir in the C standard library, so the total number of files is also limited. I have a recollection of an attempt to construct a possible Turing-complete interpretation of the C standard involving recursion and va_arg, but I don&#x27;t think it went anywhere.</div><br/></div></div><div id="41121166" class="c"><input type="checkbox" id="c-41121166" checked=""/><div class="controls bullet"><span class="by">osmarks</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117350">parent</a><span>|</span><a href="#41119023">prev</a><span>|</span><a href="#41127230">next</a><span>|</span><label class="collapse" for="c-41121166">[-]</label><label class="expand" for="c-41121166">[4 more]</label></div><br/><div class="children"><div class="content">C is indeed not Turing-complete for more or less this reason.</div><br/><div id="41121766" class="c"><input type="checkbox" id="c-41121766" checked=""/><div class="controls bullet"><span class="by">ori_b</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41121166">parent</a><span>|</span><a href="#41127230">next</a><span>|</span><label class="collapse" for="c-41121766">[-]</label><label class="expand" for="c-41121766">[3 more]</label></div><br/><div class="children"><div class="content">Neither is the universe: we have (as far as we know) a limited number of matter and energy that can be converted to computation, which limits the size of an implementable system.<p>Real Turing completeness is necessarily theoretical.</div><br/><div id="41123140" class="c"><input type="checkbox" id="c-41123140" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41121766">parent</a><span>|</span><a href="#41123021">next</a><span>|</span><label class="collapse" for="c-41123140">[-]</label><label class="expand" for="c-41123140">[1 more]</label></div><br/><div class="children"><div class="content">We don’t know that at all. It’s a sensible assumption that the universe is infinite in size, and we have no indication to the contrary. The biggest impediments are the accelerating expansion of the universe (which however isn’t fully explained and thus may not be inevitable) and the heat death, which limits time for meaningful causal interaction.</div><br/></div></div><div id="41123021" class="c"><input type="checkbox" id="c-41123021" checked=""/><div class="controls bullet"><span class="by">osmarks</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41121766">parent</a><span>|</span><a href="#41123140">prev</a><span>|</span><a href="#41127230">next</a><span>|</span><label class="collapse" for="c-41123021">[-]</label><label class="expand" for="c-41123021">[1 more]</label></div><br/><div class="children"><div class="content">Yes. C is not Turing-complete even in theory. Other languages are. It doesn&#x27;t especially matter.</div><br/></div></div></div></div></div></div></div></div><div id="41127230" class="c"><input type="checkbox" id="c-41127230" checked=""/><div class="controls bullet"><span class="by">golol</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117141">parent</a><span>|</span><a href="#41117350">prev</a><span>|</span><a href="#41120133">next</a><span>|</span><label class="collapse" for="c-41127230">[-]</label><label class="expand" for="c-41127230">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s not that simple. It&#x27;s always confusing to talk about Turing machines and the requirement of infinite memory vs. the reality of finite memory. I think &quot;Turing completeness&quot; is not so obvious to define rigorously and the way people use it does maybe not exactly capture the idea of &quot;arbitrary computation&quot; being possible. I&#x27;ll try to clarify some things for myself and maybe others.<p>First of all, recall that a dynamical system is a set X with a map f: X -&gt; X. The evolution of the system is given by the iterated application of f. A dynamical system is finite if the set X is finite.<p>I think it is useful to broaden this concept and define an IO-system as three sets X and I and O with a map f: I × X -&gt; O × X. This means at every evolution step an &quot;input&quot; value i ∈ I has to be provided and an &quot;output&quot; value o ∈ O is obtained.<p>A Turing machine m consists of a finite alphabet A of symbols and a finite IO-system h: A × S -&gt; O × S, where O = {move left, move right, print symbol a ∈ A}. This represents how the &quot;head&quot; of the Turing machine updates its internal state s ∈ S when reading a symbol from the alphabet I. We call this IO-system h the head of the Turing machine. You could specify the Turing machine with the data T = (A, S, O, h).<p>You now couple this Turing machine with another IO-system, which we call the &quot;tape&quot;. It is either an infinite (N = ∞) tape or a finite, circular tape of length N. It has states X = {1, ..., N} × I × ... × I where the product I × ... × I has length N. It&#x27;s set of inputs is the set O and its set of outputs is A. It&#x27;s operation is given by a function t: O × X -&gt; A × X, which describes the intended reaction of the type to the instructions from the head, i.e. depending on the instruction in O it either moves the &quot;position counter&quot; of the tape to the left, to the right, or it prints a symbol onto the tape. After it has performed this it reads the symbol at the current position and gives this output back to the head.<p>We can now combine the head h and the tape t into a &quot;machine&quot; dynamical system m: X × S × O -&gt; X × S × O where h(x, s, o) = (t(o, x)_X, h(t(o, x)_A, s)_S, h(t(o, x)_A, s)_O). This represents the evolution of the Turing machine together with the tape. We call this the [machine dynamicals system with memory N of the Turing machine T].<p>Definition 1. Let&#x27;s say that [the dynamical system f: X -&gt; X simulates another dynamical system g: Y -&gt; Y] if there exists an injective map u: Y -&gt; X such that g(y) = f(u(y)). In order to compute the evolution g(g(...(g(y))...)) we can instead compute f(u(f(u(...(f(u(y))...)) and use injectivity of u to get back a result in Y.<p>Lemma 2. Any finite dynamical system is simulated by the machine dynamical system of some Turing machine with tape length N = 1.
proof: Just set the head of the Turing machine to be the desired dynamical system and trivialize all the other objects.<p>This is a triviality result and tells us that this is not a good attempt to investigate universality of Turing machines in a &quot;finite memory&quot; setting.<p>False Hypothesis 3. There exists a universal Turing machine U in the sense that this Turing machine has the property that its machine dynamical system with infinite memory simulates the machine dynamical system with infinite memory of any other Turing machine T.<p>As far as I know this hypothesis is false because the sense of simulation mentioned above is far too strong. At this point I think there are many definitions one can make so let&#x27;s stick with the one of Alan Turing.<p>Definition 4. We say that [the dynamical system f: X -&gt; X simulates another dynamical system g: Y -&gt; Y with respect to the &quot;result&quot; functions R: X -&gt; {null, 0, 1} and Q: Y -&gt; {null, 0, 1}] if there exists an injective map u: Y -&gt; X such that the sequences Q(g^n(y)) and R((f ∘ u)^n(y)) are &quot;result equivalent&quot;, meaning they are equal if you delete all instances of &quot;null&quot;.<p>We now extend the concept of a Turing machine T by adding to it a result function r: O -&gt; {null, 0, 1}.<p>Definition 5 (A. Turing, 1936). We say that [the Turing machine T with result function r: O -&gt; {null, 0, 1} (N,M)-simulates another Turing machine T&#x27; with result function r&#x27;: O&#x27; -&gt; {null, 0, 1}] if the machine dynamical system of T with memory N simulates the machine dynamical system of T&#x27; with memory M, with respect to the result functions R: X × S × O -&gt; {null, 0, 1} given by R(x, s, o) = r(o) and R&#x27;: X&#x27; × S&#x27; × O&#x27; -&gt; {null, 0, 1} given by R&#x27;(x, s, o) = r&#x27;(o).<p>Definition 6. We say that [a Turing machine U with result function r is (N,M)-universal] if it (N,M)-simulates any other Turing machine with result function.<p>Theorem 7 (A. Turing, 1936). There exists a (∞,∞)-universal Turing machine.<p>Definition 8. We say that [a Turing machine U with result function r is finite-weakly universal] if for any finite M there exists some finite N such that it (N,M) simulates any other Turing machine with result function.<p>Now it gets difficult becasue I don&#x27;t actually know the answers anymore. I am pretty sure that any (∞,∞)-universal Turing machine is also finite-weakly universal. Even more so, it might be the case that finite-weak universality is equivalent to (∞,∞)-universality. Most certainly finite-weak universality is not a trivial concept and captures an interesting aspect of the concept of computation. I want to make the point that in my opinion infinite memory should not be seen as requirement in order to talk about these concepts of computation like Turing machines and universality.<p>It is also unclear how exactly to define the &quot;Turing completeness&quot; of a system, as I don&#x27;t think there exists a definition of Turing completeness for dynamical systems. You have to specify how you are allowed to put an input into the dynamical system at least. I think that in some sense one could use what OP found and prove a rigorous result that with `find` + `mkdir` one can somehow construct a finite-weakly universal Turing machine.</div><br/></div></div><div id="41120133" class="c"><input type="checkbox" id="c-41120133" checked=""/><div class="controls bullet"><span class="by">thih9</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117141">parent</a><span>|</span><a href="#41127230">prev</a><span>|</span><a href="#41122781">next</a><span>|</span><label class="collapse" for="c-41120133">[-]</label><label class="expand" for="c-41120133">[3 more]</label></div><br/><div class="children"><div class="content">Looks like you&#x27;re treating Python as a spec; in this case I&#x27;d say we should treat mkdir+find as a spec too.<p>Programming language implementations often have some hard limits built in. E.g.: <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0611&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0611&#x2F;</a></div><br/><div id="41121229" class="c"><input type="checkbox" id="c-41121229" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41120133">parent</a><span>|</span><a href="#41122781">next</a><span>|</span><label class="collapse" for="c-41121229">[-]</label><label class="expand" for="c-41121229">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m treating mkdir+find as a spec. The values for WIDTH and ITER are in the program itself and will impact any implementation of mkdir and find you use, including theoretical ones.</div><br/><div id="41123828" class="c"><input type="checkbox" id="c-41123828" checked=""/><div class="controls bullet"><span class="by">thih9</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41121229">parent</a><span>|</span><a href="#41122781">next</a><span>|</span><label class="collapse" for="c-41123828">[-]</label><label class="expand" for="c-41123828">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for explaining. I missed that WIDTH and ITER are in the program.</div><br/></div></div></div></div></div></div><div id="41122781" class="c"><input type="checkbox" id="c-41122781" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117141">parent</a><span>|</span><a href="#41120133">prev</a><span>|</span><a href="#41118874">next</a><span>|</span><label class="collapse" for="c-41122781">[-]</label><label class="expand" for="c-41122781">[1 more]</label></div><br/><div class="children"><div class="content">I interpreted `-maxdepth` as a safety device.</div><br/></div></div></div></div><div id="41118874" class="c"><input type="checkbox" id="c-41118874" checked=""/><div class="controls bullet"><span class="by">upwardbound</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117076">parent</a><span>|</span><a href="#41117141">prev</a><span>|</span><a href="#41117360">next</a><span>|</span><label class="collapse" for="c-41118874">[-]</label><label class="expand" for="c-41118874">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know this field very well so I might be misunderstanding, but I think this is different than &quot;infinite tape&quot; in Turing Machines.  As I understand it, the proof of universality for Rule 110 required that the program code which is called the &quot;production rules&quot; be repeated infinitely on the tape <i>even for a finite size program</i>.  <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_110#:~:text=An%20infinitely%20repeating%20series%20of%20finite%20production%20rules" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_110#:~:text=An%20infinite...</a><p>If you had a halting problem oracle to tell you how much runtime is needed to run a certain program to completion, you could get away with having only a finite number of repetitions of the &quot;production rules&quot;, and simply pretending that they&#x27;re infinitely repeated.  This would only work for programs that halt.<p>If I understand correctly, any program that loops forever, if implemented within Rule 110 Cyclic Tags, <i>requires</i> infinite repetition of the production rules.  I think this is a difference of Rule 110 vs Turing Machine tape.  If I understand correctly, a Turing Machine with finite, even quite small, tape can loop forever.  But a Rule 110 program <i>must</i> have infinitely sized tape to be able to loop forever.<p>Basically (if I understand correctly), Rule 110 Cyclic Tags essentially &quot;consume&quot; tape symbols as basically a non-renewable resource, like an electrical computer server powered by the burning of coal.  Infinite runtime (looping forever) requires infinite repetition of the tape symbols (both the &quot;production rules&quot; and the &quot;clock pulses&quot; - see the Wiki page above).  I believe this is unlike Turing Machines, which can loop forever without &quot;consuming&quot; any non-renewable resource.<p>To clearly state this again: Running a simple &quot;while(true)&quot; loop in a Turing Machine only needs finite tape, but <i>requires infinite tape</i> in Rule 110.</div><br/><div id="41120223" class="c"><input type="checkbox" id="c-41120223" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41118874">parent</a><span>|</span><a href="#41117360">next</a><span>|</span><label class="collapse" for="c-41120223">[-]</label><label class="expand" for="c-41120223">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  +[-&gt;+]
</code></pre>
Turing machines can also eat tape infinitely.  If they&#x27;re <i>allowed</i> such an appetite, why would we forbid it for rule 110?<p>To be fair I&#x27;ve never been 100% sold on the Turing-completeness of rule 110, but your argument isn&#x27;t landing with me either.</div><br/><div id="41121037" class="c"><input type="checkbox" id="c-41121037" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41120223">parent</a><span>|</span><a href="#41117360">next</a><span>|</span><label class="collapse" for="c-41121037">[-]</label><label class="expand" for="c-41121037">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Allowed&quot; is probably covering too wide a meaning in your description. Just because something is capable of defining infinite consumption does not mean it was allowed to do so in the proof.</div><br/></div></div></div></div></div></div></div></div><div id="41117360" class="c"><input type="checkbox" id="c-41117360" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#41116980">parent</a><span>|</span><a href="#41117076">prev</a><span>|</span><a href="#41119724">next</a><span>|</span><label class="collapse" for="c-41117360">[-]</label><label class="expand" for="c-41117360">[2 more]</label></div><br/><div class="children"><div class="content">C is maybe technically not Turing compete either: <a href="https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;60965&#x2F;is-c-actually-turing-complete" rel="nofollow">https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;60965&#x2F;is-c-actually-t...</a></div><br/><div id="41118520" class="c"><input type="checkbox" id="c-41118520" checked=""/><div class="controls bullet"><span class="by">FartyMcFarter</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117360">parent</a><span>|</span><a href="#41119724">next</a><span>|</span><label class="collapse" for="c-41118520">[-]</label><label class="expand" for="c-41118520">[1 more]</label></div><br/><div class="children"><div class="content">According to the second answer, C99 is Turing complete.</div><br/></div></div></div></div><div id="41119724" class="c"><input type="checkbox" id="c-41119724" checked=""/><div class="controls bullet"><span class="by">safeimp</span><span>|</span><a href="#41116980">parent</a><span>|</span><a href="#41117360">prev</a><span>|</span><a href="#41116364">next</a><span>|</span><label class="collapse" for="c-41119724">[-]</label><label class="expand" for="c-41119724">[1 more]</label></div><br/><div class="children"><div class="content">The author has since updated their post:<p>&gt; The proof is flawed and I retract the claim that I proved that find + mkdir is Turing complete. See <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41117141">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41117141</a>. I will update the article if I could fix the proof.</div><br/></div></div></div></div><div id="41116364" class="c"><input type="checkbox" id="c-41116364" checked=""/><div class="controls bullet"><span class="by">aabhay</span><span>|</span><a href="#41116980">prev</a><span>|</span><a href="#41116459">next</a><span>|</span><label class="collapse" for="c-41116364">[-]</label><label class="expand" for="c-41116364">[2 more]</label></div><br/><div class="children"><div class="content">I thought that this was going to use some interesting form of lambda calculus but instead it simply relies on the regex parser of find to compute things.</div><br/><div id="41116396" class="c"><input type="checkbox" id="c-41116396" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41116364">parent</a><span>|</span><a href="#41116459">next</a><span>|</span><label class="collapse" for="c-41116396">[-]</label><label class="expand" for="c-41116396">[1 more]</label></div><br/><div class="children"><div class="content">Not the first time someone has coerced a regex into doing some nontrivial computation; here&#x27;s a memorable example:<p><a href="http:&#x2F;&#x2F;realgl.blogspot.com&#x2F;2013&#x2F;08&#x2F;battlecode.html" rel="nofollow">http:&#x2F;&#x2F;realgl.blogspot.com&#x2F;2013&#x2F;08&#x2F;battlecode.html</a> (scroll down to &quot;Regular Expression Pathfinding&quot;</div><br/></div></div></div></div><div id="41116459" class="c"><input type="checkbox" id="c-41116459" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#41116364">prev</a><span>|</span><a href="#41116751">next</a><span>|</span><label class="collapse" for="c-41116459">[-]</label><label class="expand" for="c-41116459">[4 more]</label></div><br/><div class="children"><div class="content">Of course no implementation is infinite, but in this case PATH_MAX with 4096 as a typical value seems particularly low.</div><br/><div id="41116560" class="c"><input type="checkbox" id="c-41116560" checked=""/><div class="controls bullet"><span class="by">Bootvis</span><span>|</span><a href="#41116459">parent</a><span>|</span><a href="#41116557">next</a><span>|</span><label class="collapse" for="c-41116560">[-]</label><label class="expand" for="c-41116560">[1 more]</label></div><br/><div class="children"><div class="content">Check out section “Expected questions and answers”. For GNU it seems to work with path lengths larger than 4096.</div><br/></div></div><div id="41116557" class="c"><input type="checkbox" id="c-41116557" checked=""/><div class="controls bullet"><span class="by">Arch-TK</span><span>|</span><a href="#41116459">parent</a><span>|</span><a href="#41116560">prev</a><span>|</span><a href="#41116751">next</a><span>|</span><label class="collapse" for="c-41116557">[-]</label><label class="expand" for="c-41116557">[2 more]</label></div><br/><div class="children"><div class="content">The blog post addresses this by using relative paths. Tested up to a path length of 30k apparently.</div><br/><div id="41116687" class="c"><input type="checkbox" id="c-41116687" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#41116459">root</a><span>|</span><a href="#41116557">parent</a><span>|</span><a href="#41116751">next</a><span>|</span><label class="collapse" for="c-41116687">[-]</label><label class="expand" for="c-41116687">[1 more]</label></div><br/><div class="children"><div class="content">I believe somewhere after 30k is when they will run into file system limits.  Despite being able to create directories nested to arbitrary depth with short file names, find() might not be able to read a directory if the total path length is too long.<p>I found this out when I couldn&#x27;t open a file with the path &quot;.&#x2F;.&#x2F;.&#x2F;name.h&quot; where there are lots of &quot;.&#x2F;&quot; in front.  And the reason why I got so many &quot;.&#x2F;&quot; was due to a clang preprocessor bug that modifies __FILE__:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;43825">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;43825</a></div><br/></div></div></div></div></div></div><div id="41116751" class="c"><input type="checkbox" id="c-41116751" checked=""/><div class="controls bullet"><span class="by">niederman</span><span>|</span><a href="#41116459">prev</a><span>|</span><a href="#41121666">next</a><span>|</span><label class="collapse" for="c-41116751">[-]</label><label class="expand" for="c-41116751">[1 more]</label></div><br/><div class="children"><div class="content">I suspect this proof could be greatly simplified by the use of tag systems (<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Tag_system" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Tag_system</a>) rather than cellular automata.</div><br/></div></div><div id="41121666" class="c"><input type="checkbox" id="c-41121666" checked=""/><div class="controls bullet"><span class="by">nibbula</span><span>|</span><a href="#41116751">prev</a><span>|</span><a href="#41116160">next</a><span>|</span><label class="collapse" for="c-41121666">[-]</label><label class="expand" for="c-41121666">[1 more]</label></div><br/><div class="children"><div class="content">My find is not only provably Turing complete, but not even a Turing tarpit and compiles to native code.</div><br/></div></div><div id="41116740" class="c"><input type="checkbox" id="c-41116740" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#41116160">prev</a><span>|</span><a href="#41116645">next</a><span>|</span><label class="collapse" for="c-41116740">[-]</label><label class="expand" for="c-41116740">[3 more]</label></div><br/><div class="children"><div class="content">well, it also supports `-exec` so it would imply rather a big problem with the host OS if that wasn&#x27;t turing complete</div><br/><div id="41116817" class="c"><input type="checkbox" id="c-41116817" checked=""/><div class="controls bullet"><span class="by">kachnuv_ocasek</span><span>|</span><a href="#41116740">parent</a><span>|</span><a href="#41116645">next</a><span>|</span><label class="collapse" for="c-41116817">[-]</label><label class="expand" for="c-41116817">[2 more]</label></div><br/><div class="children"><div class="content">Why would an OS need to be Turing complete?</div><br/><div id="41116971" class="c"><input type="checkbox" id="c-41116971" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41116740">root</a><span>|</span><a href="#41116817">parent</a><span>|</span><a href="#41116645">next</a><span>|</span><label class="collapse" for="c-41116971">[-]</label><label class="expand" for="c-41116971">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that wouldn&#x27;t necessarily be a problem.<p>Of course, getting a computer that&#x27;s useful in practice out of this would require some thought.<p>A simple model: you could only allow programs written in Coq (or similar), ie progams that come with a proof of termination (or a slight generalisation, that allows for infinite event loops, as long as each run threw the loop behaves well, in some sense).<p>There&#x27;s a trivial escape hatch, where you just take your normal unproven program but forcefully terminate it after 2^64 steps.  That&#x27;s strictly speaking not Turing complete, but you wouldn&#x27;t be able to tell the difference during the lifetime of the computer.</div><br/></div></div></div></div></div></div><div id="41116645" class="c"><input type="checkbox" id="c-41116645" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#41116740">prev</a><span>|</span><a href="#41116352">next</a><span>|</span><label class="collapse" for="c-41116645">[-]</label><label class="expand" for="c-41116645">[7 more]</label></div><br/><div class="children"><div class="content">Observation: Any piece of software&#x2F;service or piece of software&#x2F;service used in a software&#x2F;service chain which implements and&#x2F;or consumes Regular Expressions (aka RE&#x27;s, RegExp&#x27;s) -- is potentially Turing Complete, and should be audited for Turing completeness if security in that context is a concern...</div><br/><div id="41116679" class="c"><input type="checkbox" id="c-41116679" checked=""/><div class="controls bullet"><span class="by">acchow</span><span>|</span><a href="#41116645">parent</a><span>|</span><a href="#41116352">next</a><span>|</span><label class="collapse" for="c-41116679">[-]</label><label class="expand" for="c-41116679">[6 more]</label></div><br/><div class="children"><div class="content">Speaking strictly, the original definition of Regex required only a finite state machine with zero stacks.<p>You need 2 stacks for Turing completeness.<p>Tho a lot of regex libraries can support much more than just “regex”</div><br/><div id="41116998" class="c"><input type="checkbox" id="c-41116998" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#41116645">root</a><span>|</span><a href="#41116679">parent</a><span>|</span><a href="#41116352">next</a><span>|</span><label class="collapse" for="c-41116998">[-]</label><label class="expand" for="c-41116998">[5 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;You need 2 stacks for Turing completeness.&quot;<p>I am not completely sure about that assertion...<p>We know that Rule 110 is Turing complete:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_110" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_110</a><p>&gt;&quot;Rule 110 with a particular repeating background pattern is known to be Turing complete.[2]&quot;<p>So if <i>Rule 110</i> = <i>Turing completeness</i>, then we could either prove Turing completeness by proving Turing completeness OR we could <i>prove Turing completeness by proving Rule 110 equivalence</i>...<p>Next we have <i>Markov algorithms</i>:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Markov_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Markov_algorithm</a><p>&gt;&quot;a <i>Markov algorithm</i> is a <i>string rewriting system that uses grammar-like rules to operate on strings of symbols</i>.<p><i>Markov algorithms have been shown to be Turing-complete</i><p>, which means that they are suitable as a general model of computation and can represent any mathematical expression from its simple notation.&quot;<p>(Note that Markov algorithms <i>do not use stacks</i> (nor do Turing machines, nor does Rule 110, nor do stackless &quot;Turing tarpit&quot; esoteric languages, nor does Langton&#x27;s Ant or other Turing complete cellular automata).)<p>RegExp&#x27;s are basically a <i>&quot;string rewriting system that uses grammar-like rules to operate on strings of symbols&quot;</i><p>So <i>if</i> a such a string rewriting system used in conjunction with a Regular Expression functionality can be proved to be a <i>Markov algorithm</i>, then we have automatic proof that it is also <i>Turing complete</i>, with <i>no need for stacks</i>!<p>Why not read the following:<p>Simplest Turing-complete ruleset for Markov algorithm<p><a href="https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;44717&#x2F;simplest-turing-complete-ruleset-for-markov-algorithm" rel="nofollow">https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;44717&#x2F;simplest-turing...</a><p>And possibly this:<p><a href="https:&#x2F;&#x2F;esolangs.org&#x2F;wiki&#x2F;Nopfunge" rel="nofollow">https:&#x2F;&#x2F;esolangs.org&#x2F;wiki&#x2F;Nopfunge</a><p>&gt;&quot;Nopfunge is a fungeoid designed by Hubert Lamontagne in 2015. It is a two-dimensional esoteric programming language based on a severely restricted subset of the well known Befunge language. Its goal is to show that having access to a sufficiently flexible program geometry is indeed the only thing that is needed to achieve Turing completeness.&quot;<p>[...]<p>&gt;&quot;The ONLY valid commands in Nopfunge are the PC direction change commands &lt; &gt; v ^ and empty space (which are the same as in Befunge). This means that Nopfunge has no stack, no numbers and no conditionals: there are<p><i>NO stack manipulation commands</i><p>and NO commands to store or retrieve data from the program grid. There are no variables or data storage or functions or objects of any kind. The ONLY thing that ever happens in Nopfunge is PC movement.<p><i>In spite of this, Nopfunge is Turing complete.</i>&quot;<p>Point is: If it were me, and I were designing a system, then I&#x27;d be highly careful (perhaps &quot;circumspect&quot; is a better word) about code that implements or evaluates, produces or consumes Regular Expressions (or implements any text rewrite rules for that matter!) <i>if</i> the system which that code was to be part of, was intended to be as secure as possible...</div><br/><div id="41117100" class="c"><input type="checkbox" id="c-41117100" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41116645">root</a><span>|</span><a href="#41116998">parent</a><span>|</span><a href="#41117219">next</a><span>|</span><label class="collapse" for="c-41117100">[-]</label><label class="expand" for="c-41117100">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &gt;&quot;You need 2 stacks for Turing completeness.&quot;<p>&gt; I am not completely sure about that assertion...<p>What GP means is that a finite state machine is not Turing-complete, and neither is a finite state machine with a single stack (pushdown automaton &#x2F; stack automation).</div><br/><div id="41120332" class="c"><input type="checkbox" id="c-41120332" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#41116645">root</a><span>|</span><a href="#41117100">parent</a><span>|</span><a href="#41117219">next</a><span>|</span><label class="collapse" for="c-41120332">[-]</label><label class="expand" for="c-41120332">[1 more]</label></div><br/><div class="children"><div class="content">Piet is another near-exception to this -- the language only has a single &quot;stack&quot; but the &quot;stack&quot; is equipped with a &#x27;roll&#x27; operation that cannot be implemented with a proper stack and O(1) memory.</div><br/></div></div></div></div><div id="41117219" class="c"><input type="checkbox" id="c-41117219" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41116645">root</a><span>|</span><a href="#41116998">parent</a><span>|</span><a href="#41117100">prev</a><span>|</span><a href="#41116352">next</a><span>|</span><label class="collapse" for="c-41117219">[-]</label><label class="expand" for="c-41117219">[2 more]</label></div><br/><div class="children"><div class="content">&gt; do not use stacks (nor do Turing machines<p>A Turing machine has two stacks. They&#x27;re the part of the tape to the left of the head and the part of the tape to the right of the head.<p>The other Turing complete systems described use arbitrarily large amounts of storage that are addressed more often, and for example Langton&#x27;s Ant uses a two-dimensional tape, which is &quot;not two stacks&quot; in the sense that it is more complex than two stacks.</div><br/><div id="41118337" class="c"><input type="checkbox" id="c-41118337" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#41116645">root</a><span>|</span><a href="#41117219">parent</a><span>|</span><a href="#41116352">next</a><span>|</span><label class="collapse" for="c-41118337">[-]</label><label class="expand" for="c-41118337">[1 more]</label></div><br/><div class="children"><div class="content">More complex how? Both are abstract and can simulate each other. The difference in complexity would wend into practicality arguments that don&#x27;t apply in Turing world.<p>Turing machine uses a tape, which is equivalent to two stacks, and also equivalent to a 2-dimensional tape (Farey Sequence), and (I guess, per previous comment) equivalent to Rule 110.<p>The word &quot;Equivalent&quot; always carries some load, though. For example, the Langton Ant tape and Rule 110 use a more interesting version of &quot;blank&quot; initial state, similar to the &quot;send a message by flipping a coin on a chess board with an arbitrarily flipped coin on each square&quot; puzzle.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41116352" class="c"><input type="checkbox" id="c-41116352" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41116645">prev</a><span>|</span><a href="#41116702">next</a><span>|</span><label class="collapse" for="c-41116352">[-]</label><label class="expand" for="c-41116352">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the implication of this for users of these commands?</div><br/><div id="41116408" class="c"><input type="checkbox" id="c-41116408" checked=""/><div class="controls bullet"><span class="by">langcss</span><span>|</span><a href="#41116352">parent</a><span>|</span><a href="#41116702">next</a><span>|</span><label class="collapse" for="c-41116408">[-]</label><label class="expand" for="c-41116408">[2 more]</label></div><br/><div class="children"><div class="content">Not much practically other than watch out for non-terminating find queries.</div><br/><div id="41116661" class="c"><input type="checkbox" id="c-41116661" checked=""/><div class="controls bullet"><span class="by">PokestarFan</span><span>|</span><a href="#41116352">root</a><span>|</span><a href="#41116408">parent</a><span>|</span><a href="#41116702">next</a><span>|</span><label class="collapse" for="c-41116661">[-]</label><label class="expand" for="c-41116661">[1 more]</label></div><br/><div class="children"><div class="content">I mean I had never thought about the case where the command that find executes creates subfolders of the directory it&#x27;s executed in.</div><br/></div></div></div></div></div></div><div id="41116702" class="c"><input type="checkbox" id="c-41116702" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41116352">prev</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41116702">[-]</label><label class="expand" for="c-41116702">[7 more]</label></div><br/><div class="children"><div class="content">I have found interesting this in the parent article:<p>&quot;The proof leverages a common technique: showing the system can execute Rule 110.&quot;<p>because I was not aware about &quot;Rule 110&quot;.<p>Nevertheless, reading the Wikipedia page about &quot;Rule 110&quot;, I find it astonishing that &quot;Rule 110&quot; not only has been the subject of a research paper, but that paper has been even the ground for a legal affair based on a non-disclosure agreement with Wolfram Research, which has blocked the publication of the paper for several years.<p>The demonstration that &quot;Rule 110&quot; is capable of universal computation is completely trivial and it requires no more than a sentence. It cannot be the subject of a research paper of the last decades.<p>There are several known pairs of functions that are sufficient for computing any  Boolean functions, for example AND and NOT, OR and NOT, OR and XOR, AND and XOR. The last pair is a.k.a. multiplication and addition modulo 2.<p>Whenever there is a domain where all the possible functions can be expressed as combinations of a finite set of primitives, it is also possible to express all the members of the finite set of primitives by using a single primitive function that combines all the other primitives in such a way that composing that function with itself in various ways can separate each of the original primitives from the compound primitive.<p>Applying this concept to Boolean functions it is possible to obtain various choices for a single primitive function that can generate all Boolean functions, for instance NAND, which combines NOT and AND or NOR, which combines NOT and OR.<p>In general all the ado about how various kinds of computational domains can be reduced to a single primitive function is not warranted and it is not interesting at all. The reason is that such combined primitives do not change in any way the actual number of primitives. They just replace N distinct simple primitives with 1 compound primitive that must be used in N distinct ways. This does not change in any way the complexity of the domain and it does not make it easier to understand in any way.<p>&quot;Rule 110&quot; is just another banal example of this technique. Like NAND combines NOT and AND in a separable way, &quot;Rule 110&quot; combines multiplication and addition modulo 2, a.k.a. AND and XOR, in a separable way. Therefore it can express any Boolean function, therefore, by encoding, also any computable function.<p>There is absolutely no advantage in showing that some system can compute &quot;Rule 110&quot;. It is simpler and clearer to show that it can compute AND and XOR, or AND and NOT.</div><br/><div id="41117121" class="c"><input type="checkbox" id="c-41117121" checked=""/><div class="controls bullet"><span class="by">eigenket</span><span>|</span><a href="#41116702">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41117121">[-]</label><label class="expand" for="c-41117121">[6 more]</label></div><br/><div class="children"><div class="content">As far as I can tell from your comment you have the terms &quot;functional complete&quot; and &quot;Turing complete&quot; confused. These are emphatically not the same thing.<p>A circuit of (e.g.) NAND gates defines a mathematical function over a fixed, finite number of variables (the number of input wires to your circuit) and with a fixed number of outputs (likewise the output wires).<p>A Turing complete computer accepts inputs which are <i>unbounded</i> in length, I.e. it accepts an input of at least length n for any natural number n. It can also output unbounded strings.<p>These two are fundamentally completely different. Functional completeness for a set of gates doesn&#x27;t tell you much about Turing completeness. For all of the interesting stuff to do with Turing machines you need this unbounded input size so you can do things like consider descriptions of other Turing machines as inputs to your Turing machine.<p>Essentially what you need is something equivalent to looping or recursion. Note that the Halting problem is completely trivial for NAND circuits, exactly because there is no looping.</div><br/><div id="41117319" class="c"><input type="checkbox" id="c-41117319" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41116702">root</a><span>|</span><a href="#41117121">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41117319">[-]</label><label class="expand" for="c-41117319">[5 more]</label></div><br/><div class="children"><div class="content">Perhaps you have not read TFA.<p>Of course &quot;functional complete&quot; is not a sufficient condition for being Turing complete (because a Turing machine is not reduced to its arithmetic-logic unit, which must be functionally complete, but it is a complete automaton with memories).<p>However, &quot;functional complete&quot; is a necessary condition for being Turing complete.<p>Most proofs of Turing completeness do not go as low as the Boolean functions, but they suppose the availability of higher level functions that ensure the functional completeness, i.e. incrementing, decrementing and testing if a value is zero (which in real hardware must be implemented by using Boolean functions).<p>My comment was based on the line that I have quoted from the parent article, which was one of its first lines.<p>Moreover, a Turing machine with infinite memory has a fundamental difference only in theory, i.e. in the set of problems that can be solved with it, in comparison with a machine having an identical structure, but finite memory.<p>For practical purposes, the difference between a machine that is identical with a Turing machine, except by having a finite memory, and other simpler machines, like an automaton with one stack or a finite-state automaton, is much more fundamental.<p>Because an infinite memory is irrealizable, all the proofs that some real system is &quot;Turing complete&quot; are proofs that the system is equivalent with a Turing machine whose infinite memory is replaced by a finite memory, which is actually the only kind of computing machine that can be made.<p>So in such a context, any discussion about the infinite memory of a Turing machine is pointless.</div><br/><div id="41117405" class="c"><input type="checkbox" id="c-41117405" checked=""/><div class="controls bullet"><span class="by">eigenket</span><span>|</span><a href="#41116702">root</a><span>|</span><a href="#41117319">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41117405">[-]</label><label class="expand" for="c-41117405">[4 more]</label></div><br/><div class="children"><div class="content">Specifically I was responding to this<p>&gt;There is absolutely no advantage in showing that some system can compute &quot;Rule 110&quot;. It is simpler and clearer to show that it can compute AND and XOR, or AND and NOT.<p>Which is explicitly wrong. You need extra stuff (roughly) equivalent to looping as well as the ability to interact with an unbounded inputs (110 does this by emulating a tag system). Fixed-width boolean circuits implement AND and XOR, but they are not Turing complete.<p>Showing a system can implement rule 110 is a lot stronger than showing it can implement AND and XOR or AND and NOT. You can even have a system with a single unbounded stack and access to those functions and it still won&#x27;t be able to implement rule 110 (it will be a pushdown automaton).</div><br/><div id="41117457" class="c"><input type="checkbox" id="c-41117457" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41116702">root</a><span>|</span><a href="#41117405">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41117457">[-]</label><label class="expand" for="c-41117457">[3 more]</label></div><br/><div class="children"><div class="content">That sentence did not contain any reference to Turing machines.<p>&quot;Rule 110&quot; by itself is just a Boolean function, which, as I have mentioned is completely equivalent with the pair AND + XOR.<p>By using a suitably initialized memory and an automaton that besides other features that are needed to address the memory (a.k.a. &quot;move the tape&quot;, when the memory is modeled as a tape or shift register) is able to compute &quot;Rule 110&quot;, it is possible to build the equivalent of a Turing machine.<p>My point is that using &quot;Rule 110&quot; does not bring any simplification or any other advantage instead of just using the pair AND + XOR. The machine using &quot;Rule 110&quot; and which is equivalent with a Turing machine is completely equivalent with an otherwise identical machine, except that the &quot;Rule 110&quot; function is replaced by the AND + XOR pair. The only effect of &quot;Rule 110&quot; is to make the description of the machine more complicated and more obscure and if that machine were implemented in real hardware or software it would be more inefficient, due to redundant gates or computations.<p>Even using the equivalent machine with AND + XOR does not bring any advantage instead of the traditional definition of a Turing machine, which uses higher-level functions, whose implementation details are not relevant for proving Turing completeness.</div><br/><div id="41117508" class="c"><input type="checkbox" id="c-41117508" checked=""/><div class="controls bullet"><span class="by">eigenket</span><span>|</span><a href="#41116702">root</a><span>|</span><a href="#41117457">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41117508">[-]</label><label class="expand" for="c-41117508">[2 more]</label></div><br/><div class="children"><div class="content">Rule 110 is not a simple boolean function. It&#x27;s a cellular automata. The boolean function is part of its description but not the whole thing.<p>For example if you take the standard rule 110, but run it with a different background pattern (for example the one where every cell is by default in state 0) it isn&#x27;t Turing complete any more.<p>I suggest you take a look at the proof that 110 is Turing complete (pdf here <a href="http:&#x2F;&#x2F;www.complex-systems.com&#x2F;pdf&#x2F;15-1-1.pdf" rel="nofollow">http:&#x2F;&#x2F;www.complex-systems.com&#x2F;pdf&#x2F;15-1-1.pdf</a>). It doesn&#x27;t just follow from elementary properties of the boolean gates AND and XOR.</div><br/><div id="41118389" class="c"><input type="checkbox" id="c-41118389" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#41116702">root</a><span>|</span><a href="#41117508">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41118389">[-]</label><label class="expand" for="c-41118389">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, it&#x27;s pretty nasty that the Rules are named ambiguously, where a critical part of the &quot;Rule+&quot; of interest is something  (the background pattern) in the CA system but outside the Rule system.  It&#x27;s fixable, but still gross, and plays into Wolfram&#x27;s style of making things seem more profound by hiding the ball.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41116239" class="c"><input type="checkbox" id="c-41116239" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#41116702">prev</a><span>|</span><a href="#41119820">next</a><span>|</span><label class="collapse" for="c-41116239">[-]</label><label class="expand" for="c-41116239">[4 more]</label></div><br/><div class="children"><div class="content">Neat now we just need a compiler for a scripting language...</div><br/><div id="41117717" class="c"><input type="checkbox" id="c-41117717" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#41116239">parent</a><span>|</span><a href="#41116345">next</a><span>|</span><label class="collapse" for="c-41117717">[-]</label><label class="expand" for="c-41117717">[2 more]</label></div><br/><div class="children"><div class="content">Check awka for posix awk.</div><br/><div id="41118145" class="c"><input type="checkbox" id="c-41118145" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#41116239">root</a><span>|</span><a href="#41117717">parent</a><span>|</span><a href="#41116345">next</a><span>|</span><label class="collapse" for="c-41118145">[-]</label><label class="expand" for="c-41118145">[1 more]</label></div><br/><div class="children"><div class="content">They probably meant one that targets the environment described in the post :-)</div><br/></div></div></div></div></div></div><div id="41119820" class="c"><input type="checkbox" id="c-41119820" checked=""/><div class="controls bullet"><span class="by">marvinborner</span><span>|</span><a href="#41116239">prev</a><span>|</span><label class="collapse" for="c-41119820">[-]</label><label class="expand" for="c-41119820">[1 more]</label></div><br/><div class="children"><div class="content">I believe that if you could also move and link files, you could actually simulate lambda calculus with a similar technique. I imagine something like this would work, where applications are described by shared prefix in same directory depth and order of application is encoded in lexicographical name order:<p>λx.x:<p><pre><code>  $ tree .
  .
  └── x
      └── a -&gt; ..&#x2F;x&#x2F;
</code></pre>
λsz.(s (s (s z))):<p><pre><code>  $ tree .
  .
  └── s
      └── z
          ├── a -&gt; ..&#x2F;..&#x2F;s&#x2F;
          ├── b -&gt; ..&#x2F;..&#x2F;s&#x2F;
          ├── ca -&gt; ..&#x2F;..&#x2F;s&#x2F;
          └── cb -&gt; ..&#x2F;z&#x2F;</code></pre></div><br/></div></div></div></div></div></div></div></body></html>