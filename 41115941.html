<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722416514608" as="style"/><link rel="stylesheet" href="styles.css?v=1722416514608"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ogiekako.vercel.app/blog/find_mkdir_tc">`find` + `mkdir` is Turing complete</a> <span class="domain">(<a href="https://ogiekako.vercel.app">ogiekako.vercel.app</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>37 comments</span></div><br/><div><div id="41117089" class="c"><input type="checkbox" id="c-41117089" checked=""/><div class="controls bullet"><span class="by">vanderZwan</span><span>|</span><a href="#41116364">next</a><span>|</span><label class="collapse" for="c-41117089">[-]</label><label class="expand" for="c-41117089">[2 more]</label></div><br/><div class="children"><div class="content">So can you implement Folders with it?<p><a href="https:&#x2F;&#x2F;www.danieltemkin.com&#x2F;Esolangs&#x2F;Folders&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.danieltemkin.com&#x2F;Esolangs&#x2F;Folders&#x2F;</a></div><br/><div id="41117112" class="c"><input type="checkbox" id="c-41117112" checked=""/><div class="controls bullet"><span class="by">Moosturm</span><span>|</span><a href="#41117089">parent</a><span>|</span><a href="#41116364">next</a><span>|</span><label class="collapse" for="c-41117112">[-]</label><label class="expand" for="c-41117112">[1 more]</label></div><br/><div class="children"><div class="content">This is phenomenal</div><br/></div></div></div></div><div id="41116364" class="c"><input type="checkbox" id="c-41116364" checked=""/><div class="controls bullet"><span class="by">aabhay</span><span>|</span><a href="#41117089">prev</a><span>|</span><a href="#41116980">next</a><span>|</span><label class="collapse" for="c-41116364">[-]</label><label class="expand" for="c-41116364">[2 more]</label></div><br/><div class="children"><div class="content">I thought that this was going to use some interesting form of lambda calculus but instead it simply relies on the regex parser of find to compute things.</div><br/><div id="41116396" class="c"><input type="checkbox" id="c-41116396" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41116364">parent</a><span>|</span><a href="#41116980">next</a><span>|</span><label class="collapse" for="c-41116396">[-]</label><label class="expand" for="c-41116396">[1 more]</label></div><br/><div class="children"><div class="content">Not the first time someone has coerced a regex into doing some nontrivial computation; here&#x27;s a memorable example:<p><a href="http:&#x2F;&#x2F;realgl.blogspot.com&#x2F;2013&#x2F;08&#x2F;battlecode.html" rel="nofollow">http:&#x2F;&#x2F;realgl.blogspot.com&#x2F;2013&#x2F;08&#x2F;battlecode.html</a> (scroll down to &quot;Regular Expression Pathfinding&quot;</div><br/></div></div></div></div><div id="41116980" class="c"><input type="checkbox" id="c-41116980" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41116364">prev</a><span>|</span><a href="#41116751">next</a><span>|</span><label class="collapse" for="c-41116980">[-]</label><label class="expand" for="c-41116980">[8 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand how this shows Turing completeness. The implementation of the rule 110 automaton seems to be limited by both width (not Turing complete because there is a finite number of states of a given width) and iteration limit (not be Turning complete because it always terminates).<p>Can you write an implementation of rule 110 with arbitrary (i.e. unbounded) width and depth?</div><br/><div id="41117360" class="c"><input type="checkbox" id="c-41117360" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#41116980">parent</a><span>|</span><a href="#41117076">next</a><span>|</span><label class="collapse" for="c-41117360">[-]</label><label class="expand" for="c-41117360">[1 more]</label></div><br/><div class="children"><div class="content">C is maybe technically not Turing compete either: <a href="https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;60965&#x2F;is-c-actually-turing-complete" rel="nofollow">https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;60965&#x2F;is-c-actually-t...</a></div><br/></div></div><div id="41117076" class="c"><input type="checkbox" id="c-41117076" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#41116980">parent</a><span>|</span><a href="#41117360">prev</a><span>|</span><a href="#41116751">next</a><span>|</span><label class="collapse" for="c-41117076">[-]</label><label class="expand" for="c-41117076">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still ok if the implementation limits it rather than the concept. I mean, your computer has finite memory rather than infinite tape, so it doesn&#x27;t meet that requirement either regardless of language&#x2F;method.</div><br/><div id="41117141" class="c"><input type="checkbox" id="c-41117141" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117076">parent</a><span>|</span><a href="#41116751">next</a><span>|</span><label class="collapse" for="c-41117141">[-]</label><label class="expand" for="c-41117141">[5 more]</label></div><br/><div class="children"><div class="content">I am not talking about limitations of find or mkdir like other commenters are.<p>I can write a Python program that simulates rule 110 with unbounded state width and unbounded iteration depth. I might not be able to <i>execute</i> it on any computer (it&#x27;s going to run out of memory at some point), but I can still reason about it and its behavior with a (theoretical) infinite memory.  After reading the blog post, I am not convinced I can write such a program using `find` and `mkdir`, since the provided example uses explicit limits for WIDTH and ITER in the program itself.</div><br/><div id="41117350" class="c"><input type="checkbox" id="c-41117350" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117141">parent</a><span>|</span><a href="#41116751">next</a><span>|</span><label class="collapse" for="c-41117350">[-]</label><label class="expand" for="c-41117350">[4 more]</label></div><br/><div class="children"><div class="content">The same argument would make C non turing complete. Because the size of pointers is a compile time constant and because everything needs to have an address that puts a large, but hard limit on tape length.<p>There are ways to argue arround that, e.g. C might be able to interface with a infinite tape file via the stantard library, and maybe strict aliasing and pointer provenance let&#x27;s you create a system where bit identical pointers can be different. But the mental model most people have of C wouldn&#x27;t be turing complete.</div><br/><div id="41117467" class="c"><input type="checkbox" id="c-41117467" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117350">parent</a><span>|</span><a href="#41117401">next</a><span>|</span><label class="collapse" for="c-41117467">[-]</label><label class="expand" for="c-41117467">[1 more]</label></div><br/><div class="children"><div class="content">While strictly speaking true I don&#x27;t think it is the same argument at all. You are talking about a restriction of the runtime (much like mkdir argument length or maximum filesystem depth), even though it leaks into the standard because standard people care about physical hardware, not theoretical ones.<p>The WIDTH and ITER limit being actual constants that are part of the program makes all the difference compared to C pointer limitations that are part of the execution environment.</div><br/></div></div><div id="41117401" class="c"><input type="checkbox" id="c-41117401" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117350">parent</a><span>|</span><a href="#41117467">prev</a><span>|</span><a href="#41116751">next</a><span>|</span><label class="collapse" for="c-41117401">[-]</label><label class="expand" for="c-41117401">[2 more]</label></div><br/><div class="children"><div class="content">On the other hand, a C running on a machine with a significantly larger address space would have appropriately larger pointers. The C standard does not specify any particular pointer bitwidth. With these things together, C as a language has a decent claim to Turing-completeness.</div><br/><div id="41117416" class="c"><input type="checkbox" id="c-41117416" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#41116980">root</a><span>|</span><a href="#41117401">parent</a><span>|</span><a href="#41116751">next</a><span>|</span><label class="collapse" for="c-41117416">[-]</label><label class="expand" for="c-41117416">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but you still configure (choose a compiler) it to a fixed size before running, that is in my mind no different than specifying a fixed tape size, like in the find + mkdir example.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41116751" class="c"><input type="checkbox" id="c-41116751" checked=""/><div class="controls bullet"><span class="by">niederman</span><span>|</span><a href="#41116980">prev</a><span>|</span><a href="#41116645">next</a><span>|</span><label class="collapse" for="c-41116751">[-]</label><label class="expand" for="c-41116751">[1 more]</label></div><br/><div class="children"><div class="content">I suspect this proof could be greatly simplified by the use of tag systems (<a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Tag_system" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Tag_system</a>) rather than cellular automata.</div><br/></div></div><div id="41116645" class="c"><input type="checkbox" id="c-41116645" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#41116751">prev</a><span>|</span><a href="#41116160">next</a><span>|</span><label class="collapse" for="c-41116645">[-]</label><label class="expand" for="c-41116645">[5 more]</label></div><br/><div class="children"><div class="content">Observation: Any piece of software&#x2F;service or piece of software&#x2F;service used in a software&#x2F;service chain which implements and&#x2F;or consumes Regular Expressions (aka RE&#x27;s, RegExp&#x27;s) -- is potentially Turing Complete, and should be audited for Turing completeness if security in that context is a concern...</div><br/><div id="41116679" class="c"><input type="checkbox" id="c-41116679" checked=""/><div class="controls bullet"><span class="by">acchow</span><span>|</span><a href="#41116645">parent</a><span>|</span><a href="#41116160">next</a><span>|</span><label class="collapse" for="c-41116679">[-]</label><label class="expand" for="c-41116679">[4 more]</label></div><br/><div class="children"><div class="content">Speaking strictly, the original definition of Regex required only a finite state machine with zero stacks.<p>You need 2 stacks for Turing completeness.<p>Tho a lot of regex libraries can support much more than just “regex”</div><br/><div id="41116998" class="c"><input type="checkbox" id="c-41116998" checked=""/><div class="controls bullet"><span class="by">peter_d_sherman</span><span>|</span><a href="#41116645">root</a><span>|</span><a href="#41116679">parent</a><span>|</span><a href="#41116160">next</a><span>|</span><label class="collapse" for="c-41116998">[-]</label><label class="expand" for="c-41116998">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;You need 2 stacks for Turing completeness.&quot;<p>I am not completely sure about that assertion...<p>We know that Rule 110 is Turing complete:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_110" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_110</a><p>&gt;&quot;Rule 110 with a particular repeating background pattern is known to be Turing complete.[2]&quot;<p>So if <i>Rule 110</i> = <i>Turing completeness</i>, then we could either prove Turing completeness by proving Turing completeness OR we could <i>prove Turing completeness by proving Rule 110 equivalence</i>...<p>Next we have <i>Markov algorithms</i>:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Markov_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Markov_algorithm</a><p>&gt;&quot;a <i>Markov algorithm</i> is a <i>string rewriting system that uses grammar-like rules to operate on strings of symbols</i>.<p><i>Markov algorithms have been shown to be Turing-complete</i><p>, which means that they are suitable as a general model of computation and can represent any mathematical expression from its simple notation.&quot;<p>(Note that Markov algorithms <i>do not use stacks</i> (nor do Turing machines, nor does Rule 110, nor do stackless &quot;Turing tarpit&quot; esoteric languages, nor does Langton&#x27;s Ant or other Turing complete cellular automata).)<p>RegExp&#x27;s are basically a <i>&quot;string rewriting system that uses grammar-like rules to operate on strings of symbols&quot;</i><p>So <i>if</i> a such a string rewriting system used in conjunction with a Regular Expression functionality can be proved to be a <i>Markov algorithm</i>, then we have automatic proof that it is also <i>Turing complete</i>, with <i>no need for stacks</i>!<p>Why not read the following:<p>Simplest Turing-complete ruleset for Markov algorithm<p><a href="https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;44717&#x2F;simplest-turing-complete-ruleset-for-markov-algorithm" rel="nofollow">https:&#x2F;&#x2F;cs.stackexchange.com&#x2F;questions&#x2F;44717&#x2F;simplest-turing...</a><p>And possibly this:<p><a href="https:&#x2F;&#x2F;esolangs.org&#x2F;wiki&#x2F;Nopfunge" rel="nofollow">https:&#x2F;&#x2F;esolangs.org&#x2F;wiki&#x2F;Nopfunge</a><p>&gt;&quot;Nopfunge is a fungeoid designed by Hubert Lamontagne in 2015. It is a two-dimensional esoteric programming language based on a severely restricted subset of the well known Befunge language. Its goal is to show that having access to a sufficiently flexible program geometry is indeed the only thing that is needed to achieve Turing completeness.&quot;<p>[...]<p>&gt;&quot;The ONLY valid commands in Nopfunge are the PC direction change commands &lt; &gt; v ^ and empty space (which are the same as in Befunge). This means that Nopfunge has no stack, no numbers and no conditionals: there are<p><i>NO stack manipulation commands</i><p>and NO commands to store or retrieve data from the program grid. There are no variables or data storage or functions or objects of any kind. The ONLY thing that ever happens in Nopfunge is PC movement.<p><i>In spite of this, Nopfunge is Turing complete.</i>&quot;<p>Point is: If it were me, and I were designing a system, then I&#x27;d be highly careful (perhaps &quot;circumspect&quot; is a better word) about code that implements or evaluates, produces or consumes Regular Expressions (or implements any text rewrite rules for that matter!) <i>if</i> the system which that code was to be part of, was intended to be as secure as possible...</div><br/><div id="41117219" class="c"><input type="checkbox" id="c-41117219" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41116645">root</a><span>|</span><a href="#41116998">parent</a><span>|</span><a href="#41117100">next</a><span>|</span><label class="collapse" for="c-41117219">[-]</label><label class="expand" for="c-41117219">[1 more]</label></div><br/><div class="children"><div class="content">&gt; do not use stacks (nor do Turing machines<p>A Turing machine has two stacks. They&#x27;re the part of the tape to the left of the head and the part of the tape to the right of the head.<p>The other Turing complete systems described use arbitrarily large amounts of storage that are addressed more often, and for example Langton&#x27;s Ant uses a two-dimensional tape, which is &quot;not two stacks&quot; in the sense that it is more complex than two stacks.</div><br/></div></div><div id="41117100" class="c"><input type="checkbox" id="c-41117100" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#41116645">root</a><span>|</span><a href="#41116998">parent</a><span>|</span><a href="#41117219">prev</a><span>|</span><a href="#41116160">next</a><span>|</span><label class="collapse" for="c-41117100">[-]</label><label class="expand" for="c-41117100">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt;&quot;You need 2 stacks for Turing completeness.&quot;<p>&gt; I am not completely sure about that assertion...<p>What GP means is that a finite state machine is not Turing-complete, and neither is a finite state machine with a single stack (pushdown automaton &#x2F; stack automation).</div><br/></div></div></div></div></div></div></div></div><div id="41116459" class="c"><input type="checkbox" id="c-41116459" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#41116160">prev</a><span>|</span><a href="#41116740">next</a><span>|</span><label class="collapse" for="c-41116459">[-]</label><label class="expand" for="c-41116459">[4 more]</label></div><br/><div class="children"><div class="content">Of course no implementation is infinite, but in this case PATH_MAX with 4096 as a typical value seems particularly low.</div><br/><div id="41116560" class="c"><input type="checkbox" id="c-41116560" checked=""/><div class="controls bullet"><span class="by">Bootvis</span><span>|</span><a href="#41116459">parent</a><span>|</span><a href="#41116557">next</a><span>|</span><label class="collapse" for="c-41116560">[-]</label><label class="expand" for="c-41116560">[1 more]</label></div><br/><div class="children"><div class="content">Check out section “Expected questions and answers”. For GNU it seems to work with path lengths larger than 4096.</div><br/></div></div><div id="41116557" class="c"><input type="checkbox" id="c-41116557" checked=""/><div class="controls bullet"><span class="by">Arch-TK</span><span>|</span><a href="#41116459">parent</a><span>|</span><a href="#41116560">prev</a><span>|</span><a href="#41116740">next</a><span>|</span><label class="collapse" for="c-41116557">[-]</label><label class="expand" for="c-41116557">[2 more]</label></div><br/><div class="children"><div class="content">The blog post addresses this by using relative paths. Tested up to a path length of 30k apparently.</div><br/><div id="41116687" class="c"><input type="checkbox" id="c-41116687" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#41116459">root</a><span>|</span><a href="#41116557">parent</a><span>|</span><a href="#41116740">next</a><span>|</span><label class="collapse" for="c-41116687">[-]</label><label class="expand" for="c-41116687">[1 more]</label></div><br/><div class="children"><div class="content">I believe somewhere after 30k is when they will run into file system limits.  Despite being able to create directories nested to arbitrary depth with short file names, find() might not be able to read a directory if the total path length is too long.<p>I found this out when I couldn&#x27;t open a file with the path &quot;.&#x2F;.&#x2F;.&#x2F;name.h&quot; where there are lots of &quot;.&#x2F;&quot; in front.  And the reason why I got so many &quot;.&#x2F;&quot; was due to a clang preprocessor bug that modifies __FILE__:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;43825">https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;43825</a></div><br/></div></div></div></div></div></div><div id="41116740" class="c"><input type="checkbox" id="c-41116740" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#41116459">prev</a><span>|</span><a href="#41116352">next</a><span>|</span><label class="collapse" for="c-41116740">[-]</label><label class="expand" for="c-41116740">[3 more]</label></div><br/><div class="children"><div class="content">well, it also supports `-exec` so it would imply rather a big problem with the host OS if that wasn&#x27;t turing complete</div><br/><div id="41116817" class="c"><input type="checkbox" id="c-41116817" checked=""/><div class="controls bullet"><span class="by">kachnuv_ocasek</span><span>|</span><a href="#41116740">parent</a><span>|</span><a href="#41116352">next</a><span>|</span><label class="collapse" for="c-41116817">[-]</label><label class="expand" for="c-41116817">[2 more]</label></div><br/><div class="children"><div class="content">Why would an OS need to be Turing complete?</div><br/><div id="41116971" class="c"><input type="checkbox" id="c-41116971" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41116740">root</a><span>|</span><a href="#41116817">parent</a><span>|</span><a href="#41116352">next</a><span>|</span><label class="collapse" for="c-41116971">[-]</label><label class="expand" for="c-41116971">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that wouldn&#x27;t necessarily be a problem.<p>Of course, getting a computer that&#x27;s useful in practice out of this would require some thought.<p>A simple model: you could only allow programs written in Coq (or similar), ie progams that come with a proof of termination (or a slight generalisation, that allows for infinite event loops, as long as each run threw the loop behaves well, in some sense).<p>There&#x27;s a trivial escape hatch, where you just take your normal unproven program but forcefully terminate it after 2^64 steps.  That&#x27;s strictly speaking not Turing complete, but you wouldn&#x27;t be able to tell the difference during the lifetime of the computer.</div><br/></div></div></div></div></div></div><div id="41116352" class="c"><input type="checkbox" id="c-41116352" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#41116740">prev</a><span>|</span><a href="#41116702">next</a><span>|</span><label class="collapse" for="c-41116352">[-]</label><label class="expand" for="c-41116352">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the implication of this for users of these commands?</div><br/><div id="41116408" class="c"><input type="checkbox" id="c-41116408" checked=""/><div class="controls bullet"><span class="by">langcss</span><span>|</span><a href="#41116352">parent</a><span>|</span><a href="#41116702">next</a><span>|</span><label class="collapse" for="c-41116408">[-]</label><label class="expand" for="c-41116408">[2 more]</label></div><br/><div class="children"><div class="content">Not much practically other than watch out for non-terminating find queries.</div><br/><div id="41116661" class="c"><input type="checkbox" id="c-41116661" checked=""/><div class="controls bullet"><span class="by">PokestarFan</span><span>|</span><a href="#41116352">root</a><span>|</span><a href="#41116408">parent</a><span>|</span><a href="#41116702">next</a><span>|</span><label class="collapse" for="c-41116661">[-]</label><label class="expand" for="c-41116661">[1 more]</label></div><br/><div class="children"><div class="content">I mean I had never thought about the case where the command that find executes creates subfolders of the directory it&#x27;s executed in.</div><br/></div></div></div></div></div></div><div id="41116702" class="c"><input type="checkbox" id="c-41116702" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41116352">prev</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41116702">[-]</label><label class="expand" for="c-41116702">[5 more]</label></div><br/><div class="children"><div class="content">I have found interesting this in the parent article:<p>&quot;The proof leverages a common technique: showing the system can execute Rule 110.&quot;<p>because I was not aware about &quot;Rule 110&quot;.<p>Nevertheless, reading the Wikipedia page about &quot;Rule 110&quot;, I find it astonishing that &quot;Rule 110&quot; not only has been the subject of a research paper, but that paper has been even the ground for a legal affair based on a non-disclosure agreement with Wolfram Research, which has blocked the publication of the paper for several years.<p>The demonstration that &quot;Rule 110&quot; is capable of universal computation is completely trivial and it requires no more than a sentence. It cannot be the subject of a research paper of the last decades.<p>There are several known pairs of functions that are sufficient for computing any  Boolean functions, for example AND and NOT, OR and NOT, OR and XOR, AND and XOR. The last pair is a.k.a. multiplication and addition modulo 2.<p>Whenever there is a domain where all the possible functions can be expressed as combinations of a finite set of primitives, it is also possible to express all the members of the finite set of primitives by using a single primitive function that combines all the other primitives in such a way that composing that function with itself in various ways can separate each of the original primitives from the compound primitive.<p>Applying this concept to Boolean functions it is possible to obtain various choices for a single primitive function that can generate all Boolean functions, for instance NAND, which combines NOT and AND or NOR, which combines NOT and OR.<p>In general all the ado about how various kinds of computational domains can be reduced to a single primitive function is not warranted and it is not interesting at all. The reason is that such combined primitives do not change in any way the actual number of primitives. They just replace N distinct simple primitives with 1 compound primitive that must be used in N distinct ways. This does not change in any way the complexity of the domain and it does not make it easier to understand in any way.<p>&quot;Rule 110&quot; is just another banal example of this technique. Like NAND combines NOT and AND in a separable way, &quot;Rule 110&quot; combines multiplication and addition modulo 2, a.k.a. AND and XOR, in a separable way. Therefore it can express any Boolean function, therefore, by encoding, also any computable function.<p>There is absolutely no advantage in showing that some system can compute &quot;Rule 110&quot;. It is simpler and clearer to show that it can compute AND and XOR, or AND and NOT.</div><br/><div id="41117121" class="c"><input type="checkbox" id="c-41117121" checked=""/><div class="controls bullet"><span class="by">eigenket</span><span>|</span><a href="#41116702">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41117121">[-]</label><label class="expand" for="c-41117121">[4 more]</label></div><br/><div class="children"><div class="content">As far as I can tell from your comment you have the terms &quot;functional complete&quot; and &quot;Turing complete&quot; confused. These are emphatically not the same thing.<p>A circuit of (e.g.) NAND gates defines a mathematical function over a fixed, finite number of variables (the number of input wires to your circuit) and with a fixed number of outputs (likewise the output wires).<p>A Turing complete computer accepts inputs which are <i>unbounded</i> in length, I.e. it accepts an input of at least length n for any natural number n. It can also output unbounded strings.<p>These two are fundamentally completely different. Functional completeness for a set of gates doesn&#x27;t tell you much about Turing completeness. For all of the interesting stuff to do with Turing machines you need this unbounded input size so you can do things like consider descriptions of other Turing machines as inputs to your Turing machine.<p>Essentially what you need is something equivalent to looping or recursion. Note that the Halting problem is completely trivial for NAND circuits, exactly because there is no looping.</div><br/><div id="41117319" class="c"><input type="checkbox" id="c-41117319" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41116702">root</a><span>|</span><a href="#41117121">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41117319">[-]</label><label class="expand" for="c-41117319">[3 more]</label></div><br/><div class="children"><div class="content">Perhaps you have not read TFA.<p>Of course &quot;functional complete&quot; is not a sufficient condition for being Turing complete (because a Turing machine is not reduced to its arithmetic-logic unit, which must be functionally complete, but it is a complete automaton with memories).<p>However, &quot;functional complete&quot; is a necessary condition for being Turing complete.<p>Most proofs of Turing completeness do not go as low as the Boolean functions, but they suppose the availability of higher level functions that ensure the functional completeness, i.e. incrementing, decrementing and testing if a value is zero (which in real hardware must be implemented by using Boolean functions).<p>My comment was based on the line that I have quoted from the parent article, which was one of its first lines.<p>Moreover, a Turing machine with infinite memory has a fundamental difference only in theory, i.e. in the set of problems that can be solved with it, in comparison with a machine having an identical structure, but finite memory.<p>For practical purposes, the difference between a machine that is identical with a Turing machine, except by having a finite memory, and other simpler machines, like an automaton with one stack or a finite-state automaton, is much more fundamental.<p>Because an infinite memory is irrealizable, all the proofs that some real system is &quot;Turing complete&quot; are proofs that the system is equivalent with a Turing machine whose infinite memory is replaced by a finite memory, which is actually the only kind of computing machine that can be made.<p>So in such a context, any discussion about the infinite memory of a Turing machine is pointless.</div><br/><div id="41117405" class="c"><input type="checkbox" id="c-41117405" checked=""/><div class="controls bullet"><span class="by">eigenket</span><span>|</span><a href="#41116702">root</a><span>|</span><a href="#41117319">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41117405">[-]</label><label class="expand" for="c-41117405">[2 more]</label></div><br/><div class="children"><div class="content">Specifically I was responding to this<p>&gt;There is absolutely no advantage in showing that some system can compute &quot;Rule 110&quot;. It is simpler and clearer to show that it can compute AND and XOR, or AND and NOT.<p>Which is explicitly wrong. You need extra stuff (roughly) equivalent to looping as well as the ability to interact with an unbounded inputs (110 does this by emulating a tag system). Fixed-width boolean circuits implement AND and XOR, but they are not Turing complete.<p>Showing a system can implement rule 110 is a lot stronger than showing it can implement AND and XOR or AND and NOT. You can even have a system with a single unbounded stack and access to those functions and it still won&#x27;t be able to implement rule 110 (it will be a pushdown automaton).</div><br/><div id="41117457" class="c"><input type="checkbox" id="c-41117457" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41116702">root</a><span>|</span><a href="#41117405">parent</a><span>|</span><a href="#41116239">next</a><span>|</span><label class="collapse" for="c-41117457">[-]</label><label class="expand" for="c-41117457">[1 more]</label></div><br/><div class="children"><div class="content">That sentence did not contain any reference to Turing machines.<p>&quot;Rule 110&quot; by itself is just a Boolean function, which, as I have mentioned is completely equivalent with the pair AND + XOR.<p>By using a suitably initialized memory and an automaton that besides among other features that are needed to address the memory (a.k.a. &quot;move the tape&quot;, when the memory is modeled as a tape or shift register) is able to compute &quot;Rule 110&quot;, it is possible to build the equivalent of a Turing machine.<p>My point is that using &quot;Rule 110&quot; does not bring any simplification or any other advantage instead of just using the pair AND + XOR. The machine using &quot;Rule 110&quot; and which is equivalent with a Turing machine is completely equivalent with an otherwise identical machine, except that the &quot;Rule 110&quot; function is replaced by the AND + XOR pair. The only effect of &quot;Rule 110&quot; is to make the description of the machine more complicated and more obscure and if that machine were implemented in real hardware or software it would be more inefficient, due to redundant gates or computations.<p>Even using the equivalent machine with AND + XOR does not bring any advantage instead of the traditional definition of a Turing machine, which uses higher-level functions, whose implementation details are not relevant for proving Turing completeness.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41116239" class="c"><input type="checkbox" id="c-41116239" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#41116702">prev</a><span>|</span><label class="collapse" for="c-41116239">[-]</label><label class="expand" for="c-41116239">[2 more]</label></div><br/><div class="children"><div class="content">Neat now we just need a compiler for a scripting language...</div><br/></div></div></div></div></div></div></div></body></html>